'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importDefault(require("../languages"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const convert_1 = require("../util/convert");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const textedit_1 = require("../util/textedit");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const callHierarchy_1 = tslib_1.__importDefault(require("./callHierarchy"));
const codeActions_1 = tslib_1.__importDefault(require("./codeActions"));
const index_1 = tslib_1.__importDefault(require("./codelens/index"));
const index_2 = tslib_1.__importDefault(require("./colors/index"));
const commands_2 = tslib_1.__importDefault(require("./commands"));
const fold_1 = tslib_1.__importDefault(require("./fold"));
const format_1 = tslib_1.__importDefault(require("./format"));
const highlights_1 = tslib_1.__importDefault(require("./highlights"));
const hover_1 = tslib_1.__importDefault(require("./hover"));
const index_3 = tslib_1.__importDefault(require("./inlayHint/index"));
const linkedEditing_1 = tslib_1.__importDefault(require("./linkedEditing"));
const links_1 = tslib_1.__importDefault(require("./links"));
const locations_1 = tslib_1.__importDefault(require("./locations"));
const index_4 = tslib_1.__importDefault(require("./refactor/index"));
const rename_1 = tslib_1.__importDefault(require("./rename"));
const selectionRange_1 = tslib_1.__importDefault(require("./selectionRange"));
const index_5 = tslib_1.__importDefault(require("./semanticTokens/index"));
const signature_1 = tslib_1.__importDefault(require("./signature"));
const index_6 = tslib_1.__importDefault(require("./symbols/index"));
const typeHierarchy_1 = tslib_1.__importDefault(require("./typeHierarchy"));
const workspace_2 = tslib_1.__importDefault(require("./workspace"));
const logger = (0, logger_1.createLogger)('Handler');
class Handler {
    constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        events_1.default.on(['CursorMoved', 'CursorMovedI', 'InsertEnter', 'InsertSnippet', 'InsertLeave'], () => {
            if (this.requestTokenSource) {
                this.requestTokenSource.cancel();
                this.requestTokenSource = null;
            }
        }, null, this.disposables);
        this.fold = new fold_1.default(nvim, this);
        this.links = new links_1.default(nvim, this);
        this.codeLens = new index_1.default(nvim);
        this.colors = new index_2.default(nvim, this);
        this.format = new format_1.default(nvim, this);
        this.symbols = new index_6.default(nvim, this);
        this.refactor = new index_4.default(nvim, this);
        this.hover = new hover_1.default(nvim, this);
        this.locations = new locations_1.default(nvim, this);
        this.signature = new signature_1.default(nvim, this);
        this.rename = new rename_1.default(nvim, this);
        this.workspace = new workspace_2.default(nvim);
        this.codeActions = new codeActions_1.default(nvim, this);
        this.commands = new commands_2.default(nvim);
        this.callHierarchy = new callHierarchy_1.default(nvim, this);
        this.typeHierarchy = new typeHierarchy_1.default(nvim, this);
        this.documentHighlighter = new highlights_1.default(nvim, this);
        this.semanticHighlighter = new index_5.default(nvim);
        this.selectionRange = new selectionRange_1.default(nvim, this);
        this.linkedEditingHandler = new linkedEditing_1.default(nvim, this);
        this.inlayHintHandler = new index_3.default(nvim, this);
        this.disposables.push({
            dispose: () => {
                this.callHierarchy.dispose();
                this.typeHierarchy.dispose();
                this.codeLens.dispose();
                this.links.dispose();
                this.refactor.dispose();
                this.signature.dispose();
                this.symbols.dispose();
                this.hover.dispose();
                this.colors.dispose();
                this.documentHighlighter.dispose();
                this.semanticHighlighter.dispose();
            }
        });
        this.registerCommands();
    }
    registerCommands() {
        commands_1.default.register({
            id: 'document.renameCurrentWord',
            execute: async () => {
                let doc = await workspace_1.default.document;
                let edit = await this.rename.getWordEdit();
                let ranges = (0, textedit_1.getRangesFromEdit)(doc.uri, (0, object_1.toObject)(edit));
                if (!ranges)
                    return window_1.default.showWarningMessage('Invalid position');
                await commands_1.default.executeCommand('editor.action.addRanges', ranges);
            }
        }, false, 'rename word under cursor in current buffer by multiple cursors.');
        commands_1.default.register({
            id: ['workbench.action.reloadWindow', 'editor.action.restart'],
            execute: () => {
                this.nvim.command('CocRestart', true);
            }
        }, true);
        this.register('vscode.open', (url) => {
            this.nvim.call('coc#ui#open_url', url.toString(), true);
        });
        this.register('editor.action.doCodeAction', async (action) => {
            await this.codeActions.applyCodeAction(action);
        });
        this.register('editor.action.triggerParameterHints', async () => {
            await this.signature.triggerSignatureHelp();
        });
        this.register('editor.action.showReferences', async (uri, position, references) => {
            await workspace_1.default.jumpTo(uri, position);
            await workspace_1.default.showLocations(references);
        });
        this.register('editor.action.rename', async (uri, position, newName) => {
            await workspace_1.default.jumpTo(uri, position);
            await this.rename.rename(newName);
        });
        this.register('editor.action.format', async () => {
            await this.format.formatCurrentBuffer();
        });
        this.register('editor.action.showRefactor', async (locations) => {
            let locs = locations.filter(o => vscode_languageserver_types_1.Location.is(o));
            return await this.refactor.fromLocations(locs);
        });
    }
    register(key, handler) {
        this.disposables.push(commands_1.default.registerCommand(key, handler, null, true));
    }
    get requestStatusItem() {
        if (this._requestStatusItem)
            return this._requestStatusItem;
        this._requestStatusItem = window_1.default.createStatusBarItem(0, { progress: true });
        return this._requestStatusItem;
    }
    get labels() {
        let configuration = workspace_1.default.initialConfiguration;
        return configuration.get('suggest.completionItemKindLabels', {});
    }
    get uri() {
        var _a;
        return (_a = window_1.default.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document.uri;
    }
    async getCurrentState() {
        let { nvim } = this;
        let [bufnr, [line, character], winid, mode] = await nvim.eval("[bufnr('%'),coc#cursor#position(),win_getid(),mode()]");
        let doc = workspace_1.default.getAttachedDocument(bufnr);
        return {
            doc,
            mode,
            position: vscode_languageserver_types_1.Position.create(line, character),
            winid
        };
    }
    addDisposable(disposable) {
        this.disposables.push(disposable);
    }
    /**
     * Throw error when provider doesn't exist.
     */
    checkProvider(id, document) {
        if (!languages_1.default.hasProvider(id, document)) {
            throw new Error(`${id} provider not found for current buffer, your language server doesn't support it.`);
        }
    }
    async withRequestToken(name, fn, checkEmpty) {
        if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
            this.requestTokenSource.dispose();
        }
        if (this.requestTimer) {
            clearTimeout(this.requestTimer);
        }
        let statusItem = this.requestStatusItem;
        this.requestTokenSource = new protocol_1.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        token.onCancellationRequested(() => {
            statusItem.text = `${name} request canceled`;
            statusItem.isProgress = false;
            this.requestTimer = setTimeout(() => {
                statusItem.hide();
            }, 500);
        });
        statusItem.isProgress = true;
        statusItem.text = `requesting ${name}`;
        statusItem.show();
        let res;
        try {
            res = await Promise.resolve(fn(token));
        }
        catch (e) {
            logger.error(`Error on request ${name}`, e);
            this.nvim.errWriteLine(`Error on ${name}: ${e}`);
        }
        if (this.requestTokenSource) {
            this.requestTokenSource.dispose();
            this.requestTokenSource = undefined;
        }
        if (token.isCancellationRequested)
            return null;
        statusItem.hide();
        if (checkEmpty && (!res || (Array.isArray(res) && res.length == 0))) {
            void window_1.default.showWarningMessage(`${name} not found`);
            return null;
        }
        return res;
    }
    getIcon(kind) {
        let { labels } = this;
        let kindText = (0, convert_1.getSymbolKind)(kind);
        let defaultIcon = typeof labels['default'] === 'string' ? labels['default'] : kindText[0].toLowerCase();
        let text = kindText == 'Unknown' ? '' : labels[kindText[0].toLowerCase() + kindText.slice(1)];
        if (!text || typeof text !== 'string')
            text = defaultIcon;
        return {
            text,
            hlGroup: kindText == 'Unknown' ? 'CocSymbolDefault' : `CocSymbol${kindText}`
        };
    }
    async getCodeActions(doc, range, only) {
        let codeActions = await this.codeActions.getCodeActions(doc, range, only);
        return codeActions.filter(o => !o.disabled);
    }
    async applyCodeAction(action) {
        await this.codeActions.applyCodeAction(action);
    }
    async hasProvider(id) {
        let bufnr = await this.nvim.call('bufnr', '%');
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return false;
        return languages_1.default.hasProvider(id, doc.textDocument);
    }
    dispose() {
        if (this.requestTimer) {
            clearTimeout(this.requestTimer);
        }
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Handler;
//# sourceMappingURL=index.js.map