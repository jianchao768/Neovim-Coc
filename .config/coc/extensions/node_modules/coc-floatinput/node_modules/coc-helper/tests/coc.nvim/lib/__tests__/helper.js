"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPort = exports.makeLine = exports.createTmpFile = exports.Helper = void 0;
const tslib_1 = require("tslib");
const cp = tslib_1.__importStar(require("child_process"));
const events_1 = require("events");
const fs_1 = tslib_1.__importDefault(require("fs"));
const net_1 = tslib_1.__importDefault(require("net"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = tslib_1.__importDefault(require("util"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const attach_1 = tslib_1.__importDefault(require("../attach"));
const events_2 = tslib_1.__importDefault(require("../events"));
const object_1 = require("../util/object");
const processes_1 = require("../util/processes");
const vimrc = path_1.default.resolve(__dirname, 'vimrc');
const nullChannel = {
    content: '',
    show: () => { },
    dispose: () => { },
    name: 'null',
    append: () => { },
    appendLine: () => { },
    clear: () => { },
    hide: () => { }
};
process.on('uncaughtException', err => {
    let msg = 'Uncaught exception: ' + err.stack;
    console.error(msg);
});
class Helper extends events_1.EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(99);
    }
    get workspace() {
        if (!this.plugin || !this.plugin.workspace)
            throw new Error('helper not attached');
        return this.plugin.workspace;
    }
    get completion() {
        if (!this.plugin || !this.plugin.completion)
            throw new Error('helper not attached');
        return this.plugin.completion;
    }
    get nvim() {
        return this.plugin.nvim;
    }
    async setup(init = true) {
        var _a;
        let proc = this.proc = cp.spawn((_a = process.env.NVIM_COMMAND) !== null && _a !== void 0 ? _a : 'nvim', ['-u', vimrc, '-i', 'NONE', '--embed'], {
            cwd: __dirname
        });
        proc.unref();
        let plugin = this.plugin = (0, attach_1.default)({ proc });
        await this.nvim.uiAttach(160, 80, {});
        this.nvim.call('coc#rpc#set_channel', [1], true);
        this.nvim.on('vim_error', err => {
            // console.error('Error from vim: ', err)
        });
        if (init)
            await plugin.init('');
        return plugin;
    }
    async setupVim() {
        var _a;
        if (process.env.VIM_NODE_RPC != '1') {
            throw new Error(`VIM_NODE_RPC should be 1`);
        }
        let server;
        let promise = new Promise(resolve => {
            server = this.server = net_1.default.createServer(socket => {
                this.plugin = (0, attach_1.default)({ reader: socket, writer: socket });
                this.nvim.on('vim_error', err => {
                    // console.error('Error from vim: ', err)
                });
                resolve();
            });
        });
        let address = await this.listenOnVim(server);
        let proc = this.proc = cp.spawn((_a = process.env.VIM_COMMAND) !== null && _a !== void 0 ? _a : 'vim', ['--clean', '--not-a-term', '-u', vimrc], {
            stdio: 'pipe',
            shell: true,
            cwd: __dirname,
            env: Object.assign({ COC_NVIM_REMOTE_ADDRESS: address }, process.env)
        });
        proc.on('error', err => {
            console.error(err);
        });
        proc.on('exit', code => {
            if (code)
                console.error('vim exit with code ' + code);
        });
        await promise;
        await this.plugin.init('');
    }
    async listenOnVim(server) {
        const isWindows = process.platform === 'win32';
        return new Promise((resolve, reject) => {
            if (!isWindows) {
                // not work on old version vim.
                const socket = path_1.default.join(os_1.default.tmpdir(), `coc-test-${(0, uuid_1.v4)()}.sock`);
                server.listen(socket, () => {
                    resolve(socket);
                });
                server.on('error', reject);
                server.unref();
            }
            else {
                getPort().then(port => {
                    let localhost = '127.0.0.1';
                    server.listen(port, localhost, () => {
                        resolve(`${localhost}:${port}`);
                    });
                    server.on('error', reject);
                }, reject);
            }
            server.unref();
        });
    }
    async reset() {
        let mode = await this.nvim.mode;
        if (mode.blocking && mode.mode == 'r') {
            await this.nvim.input('<cr>');
        }
        else if (mode.mode != 'n' || mode.blocking) {
            await this.nvim.call('feedkeys', [String.fromCharCode(27), 'in']);
        }
        this.completion.stop(true);
        this.workspace.reset();
        await this.nvim.command('silent! %bwipeout! | setl nopreviewwindow');
        await this.wait(10);
        await this.workspace.document;
    }
    async shutdown() {
        if (this.plugin)
            this.plugin.dispose();
        if (this.nvim)
            await this.nvim.quit();
        if (this.server)
            this.server.close();
        if (this.proc)
            (0, processes_1.terminate)(this.proc);
        if (typeof global.gc === 'function') {
            global.gc();
        }
        await this.wait(30);
    }
    wait(ms = 30) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
    async waitPrompt() {
        for (let i = 0; i < 60; i++) {
            await this.wait(30);
            let prompt = await this.nvim.call('coc#prompt#activated');
            if (prompt)
                return;
        }
        throw new Error('Wait prompt timeout after 2s');
    }
    async waitPromptWin() {
        for (let i = 0; i < 60; i++) {
            await this.wait(30);
            let winid = await this.nvim.call('coc#dialog#get_prompt_win');
            if (winid != -1)
                return winid;
        }
        throw new Error('Wait prompt window timeout after 2s');
    }
    async waitFloat() {
        for (let i = 0; i < 50; i++) {
            await this.wait(20);
            let winid = await this.nvim.call('GetFloatWin');
            if (winid)
                return winid;
        }
        throw new Error('timeout after 2s');
    }
    async doAction(method, ...args) {
        return await this.plugin.cocAction(method, ...args);
    }
    async items() {
        var _a;
        return (_a = this.completion) === null || _a === void 0 ? void 0 : _a.activeItems.slice();
    }
    async waitPopup() {
        let visible = await this.nvim.call('coc#pum#visible');
        if (visible)
            return;
        let res = await events_2.default.race(['MenuPopupChanged'], 5000);
        if (!res)
            throw new Error('wait pum timeout after 5s');
    }
    async confirmCompletion(idx) {
        await this.nvim.call('coc#pum#select', [idx, 1, 1]);
    }
    async visible(word, source) {
        await this.waitPopup();
        let items = this.completion.activeItems;
        if (!items)
            return false;
        let item = items.find(o => o.word == word);
        if (!item)
            return false;
        if (source && item.source.name != source)
            return false;
        return true;
    }
    async edit(file) {
        if (!file || !path_1.default.isAbsolute(file)) {
            file = path_1.default.join(__dirname, file ? file : `${(0, uuid_1.v4)()}`);
        }
        let escaped = await this.nvim.call('fnameescape', file);
        await this.nvim.command(`edit ${escaped}`);
        let doc = await this.workspace.document;
        return doc.buffer;
    }
    async createDocument(name) {
        let buf = await this.edit(name);
        let doc = this.workspace.getDocument(buf.id);
        if (!doc)
            return await this.workspace.document;
        return doc;
    }
    async listInput(input) {
        await events_2.default.fire('InputChar', ['list', input, 0]);
    }
    async getCmdline(lnum) {
        let str = '';
        let n = await this.nvim.eval('&lines');
        for (let i = 1, l = 70; i < l; i++) {
            let ch = await this.nvim.call('screenchar', [lnum !== null && lnum !== void 0 ? lnum : n - 1, i]);
            if (ch == -1)
                break;
            str += String.fromCharCode(ch);
        }
        return str.trim();
    }
    updateConfiguration(key, value) {
        let curr = this.workspace.getConfiguration(key);
        let { configurations } = this.workspace;
        configurations.updateMemoryConfig({ [key]: value });
        return () => {
            configurations.updateMemoryConfig({ [key]: curr });
        };
    }
    async mockFunction(name, result) {
        let content = `
    function! ${name}(...)
      return ${typeof result == 'number' ? result : JSON.stringify(result)}
    endfunction`;
        await this.nvim.exec(content);
    }
    async getFloat(kind) {
        if (!kind) {
            let ids = await this.nvim.call('coc#float#get_float_win_list');
            return ids.length ? this.nvim.createWindow(ids[0]) : undefined;
        }
        else {
            let id = await this.nvim.call('coc#float#get_float_by_kind', [kind]);
            return id ? this.nvim.createWindow(id) : undefined;
        }
    }
    async getWinLines(winid) {
        return await this.nvim.eval(`getbufline(winbufnr(${winid}), 1, '$')`);
    }
    async waitFor(method, args, value) {
        let find = false;
        for (let i = 0; i < 100; i++) {
            await this.wait(20);
            let res = await this.nvim.call(method, args);
            if ((0, object_1.equals)(res, value) || (value instanceof RegExp && value.test(res.toString()))) {
                find = true;
                break;
            }
        }
        if (!find) {
            throw new Error(`waitFor ${value} timeout`);
        }
    }
    async waitNotification(event) {
        return new Promise((resolve, reject) => {
            let fn = (method) => {
                if (method == event) {
                    clearTimeout(timer);
                    this.nvim.removeListener('notification', fn);
                    resolve();
                }
            };
            let timer = setTimeout(() => {
                this.nvim.removeListener('notification', fn);
                reject(new Error('wait notification timeout after 2s'));
            }, 2000);
            this.nvim.on('notification', fn);
        });
    }
    async waitValue(fn, value) {
        let find = false;
        for (let i = 0; i < 200; i++) {
            await this.wait(20);
            let res = await Promise.resolve(fn());
            if ((0, object_1.equals)(res, value)) {
                find = true;
                break;
            }
        }
        if (!find) {
            throw new Error(`waitValue ${value} timeout`);
        }
    }
    createNullChannel() {
        return nullChannel;
    }
}
exports.Helper = Helper;
async function createTmpFile(content, disposables) {
    let tmpFolder = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}`);
    if (!fs_1.default.existsSync(tmpFolder)) {
        fs_1.default.mkdirSync(tmpFolder);
    }
    let fsPath = path_1.default.join(tmpFolder, (0, uuid_1.v4)());
    await util_1.default.promisify(fs_1.default.writeFile)(fsPath, content, 'utf8');
    if (disposables) {
        disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            if (fs_1.default.existsSync(fsPath))
                fs_1.default.unlinkSync(fsPath);
        }));
    }
    return fsPath;
}
exports.createTmpFile = createTmpFile;
function makeLine(length) {
    let result = '';
    let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 (){};,\\<>+=`^*!@#$%[]:"/?';
    let charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() *
            charactersLength));
    }
    return result;
}
exports.makeLine = makeLine;
let currPort = 5000;
function getPort() {
    let port = currPort;
    let fn = cb => {
        let server = net_1.default.createServer();
        server.listen(port, () => {
            server.once('close', () => {
                currPort = port + 1;
                cb(port);
            });
            server.close();
        });
        server.on('error', () => {
            port += 1;
            fn(cb);
        });
    };
    return new Promise(resolve => {
        fn(resolve);
    });
}
exports.getPort = getPort;
exports.default = new Helper();
//# sourceMappingURL=helper.js.map