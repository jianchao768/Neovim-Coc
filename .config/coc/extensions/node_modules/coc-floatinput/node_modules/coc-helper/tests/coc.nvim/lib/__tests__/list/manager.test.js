"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_2 = tslib_1.__importDefault(require("../../events"));
const manager_1 = tslib_1.__importStar(require("../../list/manager"));
const array_1 = require("../../util/array");
const window_1 = tslib_1.__importDefault(require("../../window"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
const locations = [{
        filename: __filename,
        col: 2,
        lnum: 1,
        text: 'foo'
    }, {
        filename: __filename,
        col: 1,
        lnum: 2,
        text: 'Bar'
    }, {
        filename: __filename,
        col: 1,
        lnum: 3,
        text: 'option'
    }];
async function getFloats() {
    let ids = await nvim.call('coc#float#get_float_win_list', []);
    if (!ids)
        return [];
    return ids.map(id => nvim.createWindow(id));
}
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    await nvim.setVar('coc_jump_locations', locations);
});
afterEach(async () => {
    manager_1.default.reset();
    await helper_1.default.reset();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('list', () => {
    describe('createConfigurationNode', () => {
        it('should createConfigurationNode', async () => {
            expect((0, manager_1.createConfigurationNode)('foo', true)).toBeDefined();
            expect((0, manager_1.createConfigurationNode)('bar', false)).toBeDefined();
            expect((0, manager_1.createConfigurationNode)('foo', false, 'id')).toBeDefined();
        });
    });
    describe('events', () => {
        it('should cancel and enable prompt', async () => {
            let winid = await nvim.call('win_getid');
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            await nvim.call('win_gotoid', [winid]);
            await helper_1.default.waitValue(async () => {
                return await nvim.call('coc#prompt#activated');
            }, 0);
            await nvim.command('wincmd p');
            await helper_1.default.waitPrompt();
        });
    });
    describe('list commands', () => {
        it('should not quit list with --no-quit', async () => {
            let list = {
                name: 'test',
                actions: [{
                        name: 'open', execute: _item => {
                            // noop
                        }
                    }],
                defaultAction: 'open',
                loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }]),
                resolveItem: item => {
                    item.label = item.label.slice(0, 1);
                    return Promise.resolve(item);
                }
            };
            global.__TEST__ = false;
            let disposable = manager_1.default.registerList(list);
            global.__TEST__ = true;
            await manager_1.default.start(['--normal', '--no-quit', 'test']);
            await manager_1.default.session.ui.ready;
            let id = await nvim.eval('win_getid()');
            await manager_1.default.doAction();
            disposable.dispose();
            let wins = await nvim.windows;
            let ids = wins.map(o => o.id);
            expect(ids).toContain(id);
        });
        it('should do default action for first item', async () => {
            expect(manager_1.ListManager).toBeDefined();
            await manager_1.default.start(['--normal', '--first', 'location']);
            let filename = path_1.default.basename(__filename);
            await helper_1.default.waitValue(async () => {
                let name = await nvim.eval('bufname("%")');
                return name.includes(filename);
            }, true);
            let pos = await nvim.eval('getcurpos()');
            expect(pos[1]).toBe(1);
            expect(pos[2]).toBe(2);
        });
        it('should goto next & previous', async () => {
            var _a, _b;
            await manager_1.default.start(['location']);
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            await helper_1.default.waitPrompt();
            await ((_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.ready);
            await manager_1.default.doAction();
            await helper_1.default.doAction('listCancel');
            let bufname = await nvim.eval('expand("%:p")');
            expect(bufname).toMatch('manager.test.ts');
            await helper_1.default.doAction('listNext');
            let line = await nvim.call('line', '.');
            expect(line).toBe(2);
            await helper_1.default.doAction('listPrev');
            line = await nvim.call('line', '.');
            expect(line).toBe(1);
        });
        it('should parse arguments', async () => {
            var _a, _b;
            await manager_1.default.start(['--input=test', '--reverse', '--normal', '--no-sort', '--ignore-case', '--top', '--number-select', '--auto-preview', '--strict', 'location']);
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            let opts = (_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.listOptions;
            expect(opts).toEqual({
                reverse: true,
                numberSelect: true,
                autoPreview: true,
                first: false,
                input: 'test',
                interactive: false,
                matcher: 'strict',
                ignorecase: true,
                position: 'top',
                mode: 'normal',
                noQuit: false,
                sort: false
            });
        });
    });
    describe('list configuration', () => {
        it('should change indicator', async () => {
            helper_1.default.updateConfiguration('list.indicator', '>>');
            manager_1.default.prompt.input = 'foo';
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.waitValue(async () => {
                let line = await helper_1.default.getCmdline();
                return line.includes('>>');
            }, true);
            await events_2.default.fire('FocusGained', []);
        });
        it('should split right for preview window', async () => {
            var _a;
            helper_1.default.updateConfiguration('list.previewSplitRight', true);
            await manager_1.default.doAction('preview');
            await manager_1.default.resume();
            let win = await nvim.window;
            await manager_1.default.start(['location']);
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            await manager_1.default.doAction('preview');
            await helper_1.default.waitValue(async () => {
                let wins = await nvim.windows;
                return wins.length;
            }, 3);
            manager_1.default.prompt.cancel();
            await nvim.call('win_gotoid', [win.id]);
            await nvim.command('wincmd l');
            let curr = await nvim.window;
            let isPreview = await curr.getVar('previewwindow');
            expect(isPreview).toBe(1);
        });
        it('should use smartcase for strict match', async () => {
            var _a, _b;
            helper_1.default.updateConfiguration('list.smartCase', true);
            await manager_1.default.start(['--input=Man', '--strict', 'location']);
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            let items = await ((_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.getItems());
            expect(items.length).toBe(0);
        });
        it('should use smartcase for fuzzy match', async () => {
            var _a, _b;
            helper_1.default.updateConfiguration('list.smartCase', true);
            await manager_1.default.start(['--input=Man', 'location']);
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            let items = await ((_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.getItems());
            expect(items.length).toBe(0);
        });
        it('should toggle selection mode', async () => {
            var _a, _b, _c;
            await manager_1.default.start(['--normal', 'location']);
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            await helper_1.default.waitPrompt();
            await window_1.default.selectRange(vscode_languageserver_types_1.Range.create(0, 0, 3, 0));
            await ((_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.toggleSelection());
            let items = await ((_c = manager_1.default.session) === null || _c === void 0 ? void 0 : _c.ui.getItems());
            expect(items.length).toBeGreaterThan(0);
        });
        it('should change next and previous keymap', async () => {
            helper_1.default.updateConfiguration('list.nextKeymap', '<tab>');
            helper_1.default.updateConfiguration('list.previousKeymap', '<s-tab>');
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.waitPrompt();
            await nvim.eval('feedkeys("\\<tab>", "in")');
            await helper_1.default.waitValue(async () => {
                let line = await nvim.line;
                return line.includes('Bar');
            }, true);
            await nvim.eval('feedkeys("\\<s-tab>", "in")');
            await helper_1.default.waitValue(async () => {
                let line = await nvim.line;
                return line.includes('foo');
            }, true);
        });
        it('should respect mouse events', async () => {
            async function setMouseEvent(line) {
                var _a;
                let winid = (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.winid;
                await nvim.command(`let v:mouse_winid = ${winid}`);
                await nvim.command(`let v:mouse_lnum = ${line}`);
                await nvim.command(`let v:mouse_col = 1`);
            }
            await manager_1.default.start(['--normal', 'location']);
            await manager_1.default.session.ui.ready;
            await setMouseEvent(1);
            await manager_1.default.onNormalInput('<LeftMouse>');
            await setMouseEvent(2);
            await manager_1.default.onNormalInput('<LeftDrag>');
            await setMouseEvent(3);
            await manager_1.default.onNormalInput('<LeftRelease>');
            await helper_1.default.waitValue(async () => {
                var _a;
                let items = await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.getItems());
                return items.length;
            }, 3);
        });
        it('should toggle preview', async () => {
            helper_1.default.updateConfiguration('list.floatPreview', true);
            await manager_1.default.start(['--normal', '--auto-preview', 'location']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.waitValue(async () => {
                let wins = await getFloats();
                return wins.length > 0;
            }, true);
            await manager_1.default.togglePreview();
            await helper_1.default.waitValue(async () => {
                let wins = await getFloats();
                return wins.length > 0;
            }, false);
            await manager_1.default.togglePreview();
            manager_1.default.session.ui.setCursor(2);
            await helper_1.default.waitValue(async () => {
                let wins = await getFloats();
                return wins.length > 0;
            }, true);
        });
        it('should show help of current list', async () => {
            var _a;
            await manager_1.default.start(['--normal', '--auto-preview', 'location']);
            await manager_1.default.session.ui.ready;
            await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.showHelp());
            let bufname = await nvim.call('bufname', '%');
            expect(bufname).toBe('[LIST HELP]');
        });
        it('should resolve list item', async () => {
            let list = {
                name: 'test',
                actions: [{
                        name: 'open', execute: _item => {
                            // noop
                        }
                    }],
                defaultAction: 'open',
                loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'foo bar' }]),
                resolveItem: item => {
                    item.label = 'foo bar';
                    return Promise.resolve(item);
                }
            };
            let disposable = manager_1.default.registerList(list, true);
            await manager_1.default.start(['--normal', 'test']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.waitFor('getline', ['.'], 'foo bar');
            await manager_1.default.session.next();
            await manager_1.default.session.resolveItem();
            disposable.dispose();
        });
    });
    describe('descriptions', () => {
        it('should get descriptions', async () => {
            let res = await helper_1.default.doAction('listDescriptions');
            expect(res).toBeDefined();
            expect(res.location).toBeDefined();
        });
    });
    describe('switchMatcher()', () => {
        it('should switch matcher', async () => {
            await manager_1.default.switchMatcher();
            await manager_1.default.start(['--normal', 'location']);
            manager_1.default.session.onInputChange();
            await manager_1.default.session.ui.ready;
            const assertMatcher = (value) => {
                expect(manager_1.default.session.listOptions.matcher).toBe(value);
            };
            await manager_1.default.switchMatcher();
            assertMatcher('strict');
            await manager_1.default.switchMatcher();
            assertMatcher('regex');
            await manager_1.default.switchMatcher();
            assertMatcher('fuzzy');
            await manager_1.default.switchMatcher();
            assertMatcher('strict');
            manager_1.default.session.listOptions.interactive = true;
            await manager_1.default.switchMatcher();
            assertMatcher('strict');
            await manager_1.default.cancel(true);
        });
    });
    describe('loadItems()', () => {
        it('should load items for list', async () => {
            let res = await manager_1.default.loadItems('location');
            expect(res.length).toBeGreaterThan(0);
            Object.assign(manager_1.default, { lastSession: undefined });
            manager_1.default.toggleMode();
            manager_1.default.stop();
            res = await helper_1.default.doAction('listLoadItems', '');
            expect(res).toBeUndefined();
            let error = true;
            manager_1.default.registerList({
                name: 'emitter',
                actions: [],
                defaultAction: '',
                loadItems: () => {
                    let emitter = new events_1.default();
                    emitter.dispose = () => {
                        emitter.removeAllListeners();
                    };
                    if (error) {
                        setTimeout(() => {
                            emitter.emit('error', new Error('error'));
                            emitter.emit('end');
                        }, 2);
                    }
                    else {
                        setTimeout(() => {
                            emitter.emit('data', { label: 'foo' });
                            emitter.emit('end');
                        }, 2);
                    }
                    setInterval(() => {
                        emitter.emit('data', { label: 'bar' });
                        emitter.emit('error', new Error('error'));
                    }, 10);
                    return emitter;
                }
            });
            await expect(async () => {
                await manager_1.default.loadItems('emitter');
            }).rejects.toThrow(Error);
            error = false;
            res = await manager_1.default.loadItems('emitter');
            expect(res.length).toBe(1);
            await helper_1.default.wait(10);
        });
    });
    describe('onInsertInput()', () => {
        it('should handle insert input', async () => {
            await manager_1.default.onInsertInput('k');
            await manager_1.default.onInsertInput('<LeftMouse>');
            await manager_1.default.start(['--number-select', 'location']);
            await manager_1.default.session.ui.ready;
            await manager_1.default.onInsertInput('1');
            await manager_1.default.onInsertInput(String.fromCharCode(129));
            let basename = path_1.default.basename(__filename);
            await helper_1.default.waitValue(async () => {
                let bufname = await nvim.call('bufname', ['%']);
                return bufname.includes(basename);
            }, true);
        });
        it('should ignore invalid input', async () => {
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            await manager_1.default.onInsertInput('<X-y>');
            await manager_1.default.onInsertInput(String.fromCharCode(65533));
            await manager_1.default.onInsertInput(String.fromCharCode(30));
            expect(manager_1.default.isActivated).toBe(true);
        });
        it('should ignore <plug> insert', async () => {
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            await nvim.eval('feedkeys("\\<plug>x", "in")');
            await helper_1.default.wait(20);
            expect(manager_1.default.isActivated).toBe(true);
        });
    });
    describe('parseArgs()', () => {
        it('should show error for bad option', async () => {
            await helper_1.default.wait(20);
            manager_1.default.parseArgs(['$x', 'location']);
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('Invalid list option');
            manager_1.default.parseArgs(['-xyz', 'location']);
            msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('Invalid option');
        });
        it('should parse valid arguments', async () => {
            let res = manager_1.default.parseArgs([]);
            expect(res.list.name).toBe('lists');
            res = manager_1.default.parseArgs(['lists', '-foo']);
            expect(res.listArgs).toEqual(['-foo']);
        });
        it('should show error for interactive with list not support interactive', async () => {
            manager_1.default.parseArgs(['--interactive', 'location']);
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('not supported');
        });
    });
    describe('resume()', () => {
        it('should resume by name', async () => {
            await events_2.default.fire('FocusGained', []);
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            await manager_1.default.session.hide();
            await manager_1.default.resume('location');
            await helper_1.default.doAction('listResume');
            expect(manager_1.default.isActivated).toBe(true);
            await manager_1.default.resume('not_exists');
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('Can\'t find');
        });
    });
    describe('triggerCursorMoved()', () => {
        it('should triggerCursorMoved autocmd', async () => {
            let called = 0;
            let disposable = events_2.default.on('CursorMoved', () => {
                called++;
            });
            Object.assign(events_2.default, { _cursor: undefined });
            Object.assign(nvim, { isVim: true });
            manager_1.default.triggerCursorMoved();
            manager_1.default.triggerCursorMoved();
            Object.assign(nvim, { isVim: false });
            await helper_1.default.waitValue(() => {
                return called;
            }, 1);
            disposable.dispose();
        });
    });
    describe('first(), last()', () => {
        it('should get session by name', async () => {
            let last;
            let list = {
                name: 'test',
                actions: [{
                        name: 'open',
                        execute: item => {
                            last = (0, array_1.toArray)(item)[0].label;
                        }
                    }],
                defaultAction: 'open',
                loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }])
            };
            manager_1.default.registerList(list, true);
            await manager_1.default.start(['test']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.doAction('listFirst', 'a');
            await helper_1.default.doAction('listLast', 'a');
            await manager_1.default.first('test');
            expect(last).toBe('foo');
            await manager_1.default.last('test');
            expect(last).toBe('bar');
        });
    });
    describe('registerList()', () => {
        it('should recreate list', async () => {
            let fn = jest.fn();
            let list = {
                name: 'test',
                actions: [{
                        name: 'open', execute: _item => {
                            // noop
                        }
                    }],
                defaultAction: 'open',
                loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }]),
                dispose: () => {
                    fn();
                }
            };
            manager_1.default.registerList(list, true);
            helper_1.default.updateConfiguration('list.source.test.defaultAction', 'open');
            let disposable = manager_1.default.registerList(list, true);
            disposable.dispose();
            expect(fn).toBeCalled();
        });
    });
    describe('start()', () => {
        it('should show error when loadItems throws', async () => {
            let list = {
                name: 'test',
                actions: [{
                        name: 'open',
                        execute: _item => {
                        }
                    }],
                defaultAction: 'open',
                loadItems: () => {
                    throw new Error('test error');
                }
            };
            manager_1.default.registerList(list, true);
            await manager_1.default.start(['test']);
            await helper_1.default.wait(20);
        });
    });
    describe('list options', () => {
        it('should respect auto preview option', async () => {
            await manager_1.default.start(['--auto-preview', 'location']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.waitFor('winnr', ['$'], 3);
            let previewWinnr = await nvim.call('coc#list#has_preview');
            expect(previewWinnr).toBe(2);
            let bufnr = await nvim.call('winbufnr', previewWinnr);
            let buf = nvim.createBuffer(bufnr);
            let name = await buf.name;
            expect(name).toMatch('manager.test.ts');
            await nvim.eval('feedkeys("j", "in")');
            await helper_1.default.wait(30);
            let winnr = await nvim.call('coc#list#has_preview');
            expect(winnr).toBe(previewWinnr);
        });
        it('should respect input option', async () => {
            await manager_1.default.start(['--input=foo', 'location']);
            await manager_1.default.session.ui.ready;
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('foo');
            expect(manager_1.default.isActivated).toBe(true);
        });
        it('should respect regex filter', async () => {
            var _a, _b;
            await manager_1.default.start(['--input=f.o', '--regex', 'location']);
            await manager_1.default.session.ui.ready;
            let item = await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.item);
            expect(item.label).toMatch('foo');
            await manager_1.default.session.hide();
            await manager_1.default.start(['--input=f.o', '--ignore-case', '--regex', 'location']);
            await manager_1.default.session.ui.ready;
            item = await ((_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.item);
            expect(item.label).toMatch('foo');
        });
        it('should respect normal option', async () => {
            await manager_1.default.start(['--normal', 'location']);
            await manager_1.default.session.ui.ready;
            let line = await helper_1.default.getCmdline();
            expect(line).toBe('');
        });
        it('should respect nosort option', async () => {
            await manager_1.default.start(['--ignore-case', '--no-sort', 'location']);
            await manager_1.default.session.ui.ready;
            await nvim.input('oo');
            await helper_1.default.waitValue(async () => {
                let line = await nvim.call('getline', ['.']);
                return line.includes('foo');
            }, true);
        });
        it('should respect ignorecase option', async () => {
            await manager_1.default.start(['--ignore-case', '--strict', 'location']);
            await manager_1.default.session.ui.ready;
            expect(manager_1.default.isActivated).toBe(true);
            await nvim.input('bar');
            await helper_1.default.waitValue(() => {
                var _a;
                return (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.length;
            }, 1);
            let line = await nvim.line;
            expect(line).toMatch('Bar');
        });
        it('should respect top & height option', async () => {
            await manager_1.default.start(['--top', '--height=2', 'location']);
            await manager_1.default.session.ui.ready;
            let nr = await nvim.call('winnr');
            expect(nr).toBe(1);
            let win = await nvim.window;
            let height = await win.height;
            expect(height).toBe(2);
        });
        it('should respect number select option', async () => {
            await manager_1.default.start(['--number-select', 'location']);
            await manager_1.default.session.ui.ready;
            await nvim.eval('feedkeys("2", "in")');
            let lnum = locations[1].lnum;
            await helper_1.default.waitFor('line', ['.'], lnum);
        });
        it('should respect tab option', async () => {
            await manager_1.default.start(['--tab', '--auto-preview', 'location']);
            await manager_1.default.session.ui.ready;
            await helper_1.default.waitFor('tabpagenr', ['$'], 2);
        });
    });
});
//# sourceMappingURL=manager.test.js.map