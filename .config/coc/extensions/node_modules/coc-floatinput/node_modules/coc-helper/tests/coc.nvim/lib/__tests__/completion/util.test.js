"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const match_1 = require("../../completion/match");
const sources_1 = tslib_1.__importDefault(require("../../completion/sources"));
const types_1 = require("../../completion/types");
const util_1 = require("../../completion/util");
const wordDistance_1 = require("../../completion/wordDistance");
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const chars_1 = require("../../model/chars");
const util_2 = require("../../util");
const fuzzy_1 = require("../../util/fuzzy");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let disposables = [];
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(() => {
    (0, util_2.disposeAll)(disposables);
});
function getSource() {
    return sources_1.default.getSource('$words');
}
describe('util functions', () => {
    it('should toCompleteDoneItem', async () => {
        expect((0, util_1.toCompleteDoneItem)(undefined, undefined)).toEqual({});
    });
    it('should getPriority', async () => {
        expect((0, util_1.getPriority)(getSource(), 5)).toBe(5);
    });
    it('should add documentation', () => {
        let docs = (0, util_1.getDocumentaions)({ label: 'word', detail: 'detail' }, '');
        expect(docs).toEqual([{ filetype: 'txt', content: 'detail' }]);
        docs = (0, util_1.getDocumentaions)({ label: 'word', documentation: { kind: 'plaintext', value: '' } }, '');
        expect(docs).toEqual([]);
        docs = (0, util_1.getDocumentaions)({ label: 'word', detail: 'detail' }, '', true);
        expect(docs).toEqual([]);
        docs = (0, util_1.getDocumentaions)({ label: 'word', detail: 'detail', documentation: { kind: 'markdown', value: 'markdown' } }, 'vim');
        expect(docs.length).toBe(2);
        docs = (0, util_1.getDocumentaions)({ word: '' }, '', true);
        expect(docs).toEqual([]);
        docs = (0, util_1.getDocumentaions)({ word: '', documentation: [{ content: 'content', filetype: 'vim' }] }, '', true);
        expect(docs).toEqual([{ content: 'content', filetype: 'vim' }]);
        docs = (0, util_1.getDocumentaions)({ word: '', info: 'info' }, '', true);
        expect(docs).toEqual([{ content: 'info', filetype: 'txt' }]);
    });
    it('should get detail doc', () => {
        let item = { label: '', detail: 'detail', labelDetails: {} };
        expect((0, util_1.getDetail)(item, '')).toEqual({ filetype: 'txt', content: 'detail' });
        item = { label: '', detail: 'detail', labelDetails: { detail: 'detail', description: 'desc' } };
        expect((0, util_1.getDetail)(item, '')).toEqual({ filetype: 'txt', content: 'detail desc' });
        item = { label: '', detail: 'detail', labelDetails: { description: 'desc' } };
        expect((0, util_1.getDetail)(item, '')).toEqual({ filetype: 'txt', content: ' desc' });
        item = { label: '', detail: 'detail', labelDetails: { detail: 'detail' } };
        expect((0, util_1.getDetail)(item, '')).toEqual({ filetype: 'txt', content: 'detail' });
        item = { label: '', detail: 'detail()' };
        expect((0, util_1.getDetail)(item, 'vim')).toEqual({ filetype: 'vim', content: 'detail()' });
    });
    it('should get caseScore', () => {
        expect(typeof (0, match_1.caseScore)(10, 10, 2)).toBe('number');
    });
    it('should check action', async () => {
        expect((0, util_1.hasAction)({ label: 'foo', additionalTextEdits: [] }, {})).toBe(false);
        expect((0, util_1.hasAction)({ label: 'foo', insertTextFormat: vscode_languageserver_protocol_1.InsertTextFormat.Snippet }, {})).toBe(true);
    });
    it('should check indentChanged', () => {
        expect((0, util_1.indentChanged)(undefined, [1, 1, ''], '')).toBe(false);
        expect((0, util_1.indentChanged)({ word: 'foo' }, [1, 4, 'foo'], '  foo')).toBe(true);
        expect((0, util_1.indentChanged)({ word: 'foo' }, [1, 4, 'bar'], '  foo')).toBe(false);
    });
    it('should get highlight offset', () => {
        let n = (0, util_1.highlightOffert)(3, { abbr: 'abc', filterText: 'def' });
        expect(n).toBe(-1);
        expect((0, util_1.highlightOffert)(3, { abbr: 'abc', filterText: 'abc' })).toBe(3);
        expect((0, util_1.highlightOffert)(3, { abbr: 'xy abc', filterText: 'abc' })).toBe(6);
    });
    it('should getKindText', () => {
        expect((0, util_1.getKindText)('t', new Map(), '')).toBe('t');
        let m = new Map();
        m.set(vscode_languageserver_protocol_1.CompletionItemKind.Class, 'C');
        expect((0, util_1.getKindText)(vscode_languageserver_protocol_1.CompletionItemKind.Class, m, 'D')).toBe('C');
        expect((0, util_1.getKindText)(vscode_languageserver_protocol_1.CompletionItemKind.Class, new Map(), 'D')).toBe('D');
    });
    it('should getKindHighlight', async () => {
        const testHi = (kind, res) => {
            expect((0, util_1.getKindHighlight)(kind)).toBe(res);
        };
        testHi(vscode_languageserver_protocol_1.CompletionItemKind.Class, 'CocSymbolClass');
        testHi(999, 'CocSymbolDefault');
        testHi('', 'CocSymbolDefault');
    });
    it('should createKindMap', () => {
        let map = (0, util_1.createKindMap)({ constructor: 'C' });
        expect(map.get(vscode_languageserver_protocol_1.CompletionItemKind.Constructor)).toBe('C');
        map = (0, util_1.createKindMap)({ constructor: undefined });
        expect(map.get(vscode_languageserver_protocol_1.CompletionItemKind.Constructor)).toBe('');
    });
    it('should checkIgnoreRegexps', () => {
        expect((0, util_1.checkIgnoreRegexps)([], '')).toBe(false);
        expect((0, util_1.checkIgnoreRegexps)(['^^*^^'], 'input')).toBe(false);
        expect((0, util_1.checkIgnoreRegexps)(['^inp', '^ind'], 'input')).toBe(true);
    });
    it('should getResumeInput', () => {
        let opt = { line: 'foo', colnr: 4, col: 1, position: { line: 0, character: 3 } };
        expect((0, util_1.getResumeInput)(opt, 'f')).toBeNull();
        expect((0, util_1.getResumeInput)(opt, 'bar')).toBeNull();
        expect((0, util_1.getResumeInput)(opt, 'foo f')).toBeNull();
        expect((0, util_1.getResumeInput)(opt, 'foot')).toBe('oot');
    });
    function createOption(bufnr, linenr, line, colnr) {
        return { bufnr, linenr, line, colnr };
    }
    it('should check stop', () => {
        let opt = createOption(1, 1, 'a', 2);
        expect((0, util_1.shouldStop)(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: '' }, opt)).toBe(true);
        expect((0, util_1.shouldStop)(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: ' ' }, opt)).toBe(true);
        expect((0, util_1.shouldStop)(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: 'fo' }, opt)).toBe(true);
        expect((0, util_1.shouldStop)(2, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: 'foob' }, opt)).toBe(true);
        expect((0, util_1.shouldStop)(1, 'foo', { line: '', col: 2, lnum: 2, changedtick: 1, pre: 'foob' }, opt)).toBe(true);
        expect((0, util_1.shouldStop)(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: 'barb' }, opt)).toBe(true);
    });
    it('should check indent', () => {
        let res = (0, util_1.shouldIndent)('0{,0},0),0],!^F,o,O,e,=endif,=enddef,=endfu,=endfor', 'endfor');
        expect(res).toBe(true);
        res = (0, util_1.shouldIndent)('', 'endfor');
        expect(res).toBe(false);
        res = (0, util_1.shouldIndent)('0{,0},0),0],!^F,o,O,e,=endif,=enddef,=endfu,=endfor', 'foo bar');
        expect(res).toBe(false);
        res = (0, util_1.shouldIndent)('=~endif,=enddef,=endfu,=endfor', 'Endif');
        expect(res).toBe(true);
        res = (0, util_1.shouldIndent)(' ', '');
        expect(res).toBe(false);
        res = (0, util_1.shouldIndent)('*=endif', 'endif');
        expect(res).toBe(false);
        res = (0, util_1.shouldIndent)('0=foo', '  foo');
        expect(res).toBe(true);
    });
    it('should check isWordCode', () => {
        let chars = new chars_1.Chars('@,_,#');
        expect((0, util_1.isWordCode)(chars, 97, true)).toBe(true);
        expect((0, util_1.isWordCode)(chars, 97, false)).toBe(true);
        expect((0, util_1.isWordCode)(chars, 10, false)).toBe(false);
        expect((0, util_1.isWordCode)(chars, 0xdc00, false)).toBe(false);
        expect((0, util_1.isWordCode)(chars, 20320, true)).toBe(false);
    });
    it('should consider none word character as input', () => {
        let chars = new chars_1.Chars('@,_,#');
        let res = (0, util_1.getInput)(chars, 'a#b#', false);
        expect(res).toBe('a#b#');
        res = (0, util_1.getInput)(chars, '你b#', true);
        expect(res).toBe('b#');
        res = (0, util_1.getInput)(chars, '你b#', false);
        expect(res).toBe('b#');
    });
    it('should check emptLabelDetails', () => {
        expect((0, util_1.emptLabelDetails)(null)).toBe(true);
        expect((0, util_1.emptLabelDetails)({})).toBe(true);
        expect((0, util_1.emptLabelDetails)({ detail: '' })).toBe(true);
        expect((0, util_1.emptLabelDetails)({ detail: 'detail' })).toBe(false);
        expect((0, util_1.emptLabelDetails)({ description: 'detail' })).toBe(false);
    });
    it('should get word from complete item', () => {
        let item = { label: 'foo', textEdit: vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), '$foo\nbar') };
        let word = (0, util_1.getWord)(item, {});
        expect(word).toBe('$foo');
        item = { label: 'foo', data: { word: '$foo' } };
        word = (0, util_1.getWord)(item, {});
        expect(word).toBe('$foo');
        item = { label: 'foo', insertText: 'foo($1)' };
        word = (0, util_1.getWord)(item, { insertTextFormat: vscode_languageserver_protocol_1.InsertTextFormat.Snippet });
        expect(word).toBe('foo()');
        word = (0, util_1.getWord)(item, { insertTextFormat: vscode_languageserver_protocol_1.InsertTextFormat.PlainText });
        expect(word).toBe('foo($1)');
        item = { label: 'foo' };
        word = (0, util_1.getWord)(item, {});
        expect(word).toBe('foo');
        item = { label: 'foo', insertText: 'foo' };
        word = (0, util_1.getWord)(item, { insertTextFormat: vscode_languageserver_protocol_1.InsertTextFormat.Snippet });
        expect(word).toBe('foo');
        item = { label: 'foo', insertText: 'foo($1)', kind: vscode_languageserver_protocol_1.CompletionItemKind.Function };
        word = (0, util_1.getWord)(item, { insertTextFormat: vscode_languageserver_protocol_1.InsertTextFormat.Snippet });
        expect(word).toBe('foo');
    });
    it('should get replace range', () => {
        let item = { label: 'foo' };
        expect((0, util_1.getReplaceRange)(item, {})).toBeUndefined();
        expect((0, util_1.getReplaceRange)(item, {}, 0)).toBeUndefined();
        expect((0, util_1.getReplaceRange)(item, {
            editRange: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3)
        }, 0)).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
        expect((0, util_1.getReplaceRange)(item, {
            editRange: {
                insert: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0),
                replace: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
            }
        }, 0)).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
        expect((0, util_1.getReplaceRange)(item, {
            editRange: {
                insert: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0),
                replace: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
            }
        }, 0, types_1.InsertMode.Insert)).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
        item.textEdit = vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), 'foo');
        expect((0, util_1.getReplaceRange)(item, {}, 0)).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
        item.textEdit = {
            newText: 'foo',
            insert: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0),
            replace: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
        };
        expect((0, util_1.getReplaceRange)(item, {}, 0)).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
        item.textEdit = {
            newText: 'foo',
            insert: vscode_languageserver_protocol_1.Range.create(0, 1, 0, 0),
            replace: vscode_languageserver_protocol_1.Range.create(0, 1, 0, 3),
        };
        expect((0, util_1.getReplaceRange)(item, {}, 0)).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
    });
    describe('Converter', () => {
        function create(inputStart, option, opt) {
            return new util_1.Converter(inputStart, option, opt);
        }
        it('should get previous & after', () => {
            let opt = {
                line: '$foo',
                col: 1,
                position: vscode_languageserver_protocol_1.Position.create(0, 1)
            };
            let option = {
                insertMode: types_1.InsertMode.Repalce,
                priority: 0,
                range: vscode_languageserver_protocol_1.Range.create(0, 1, 0, 4),
                source: getSource(),
            };
            let c = create(1, option, opt);
            expect(c.getPrevious(0)).toBe('$');
            expect(c.getPrevious(0)).toBe('$');
            expect(c.getAfter(4)).toBe('foo');
            expect(c.getAfter(4)).toBe('foo');
            expect(c.getAfter(2)).toBe('f');
        });
        it('should convert completion item', () => {
            let opt = {
                line: '',
                position: vscode_languageserver_protocol_1.Position.create(0, 0)
            };
            let option = {
                insertMode: types_1.InsertMode.Repalce,
                range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0),
                priority: 0,
                source: getSource(),
            };
            let item = {
                label: 'f',
                insertText: 'f',
                score: 3,
                data: { optional: true, dup: 0 },
                tags: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated]
            };
            let c = create(0, option, opt);
            let res = c.convertToDurationItem(item);
            expect(res.abbr.endsWith('?')).toBe(true);
            expect(typeof res.sortText).toBe('string');
            expect(res.deprecated).toBe(true);
            expect(res.dup).toBe(false);
        });
        it('should replace word after cursor', () => {
            let opt = {
                line: 'afoo',
                position: vscode_languageserver_protocol_1.Position.create(0, 1)
            };
            let option = {
                insertMode: types_1.InsertMode.Repalce,
                range: vscode_languageserver_protocol_1.Range.create(0, 1, 0, 1),
                priority: 0,
                source: getSource(),
            };
            let item = {
                label: 'afoo',
                insertText: 'afoo',
                textEdit: vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 4), 'afoo'),
            };
            let c = create(1, option, opt);
            let res = c.convertToDurationItem(item);
            expect(res.character).toBe(0);
            expect(res.word).toBe('a');
            item.textEdit = vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 1, 0, 4), 'foo');
            item.labelDetails = { description: 'description' };
            res = c.convertToDurationItem(item);
            expect(res.character).toBe(1);
            expect(res.labelDetails).toBeDefined();
        });
        it('should convert completion item', () => {
            let opt = {
                line: '@',
                position: vscode_languageserver_protocol_1.Position.create(0, 1)
            };
            let option = {
                range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1),
                insertMode: types_1.InsertMode.Repalce,
                priority: 0,
                asciiMatch: false,
                source: getSource(),
            };
            let item = {
                word: '@foo',
                abbr: 'foo'
            };
            let c = create(1, option, opt);
            let res = c.convertToDurationItem(item);
            expect(res.filterText).toBe('@foo');
            expect(res.delta).toBe(1);
        });
    });
    describe('matchScore', () => {
        function score(word, input) {
            return (0, match_1.matchScore)(word, (0, fuzzy_1.getCharCodes)(input));
        }
        it('should match score for last letter', () => {
            expect(score('#!3', '3')).toBe(1);
            expect(score('bar', 'f')).toBe(0);
        });
        it('should return 0 when not matched', () => {
            expect(score('and', '你')).toBe(0);
            expect(score('你and', '你的')).toBe(0);
            expect(score('fooBar', 'Bt')).toBe(0);
            expect(score('thisbar', 'tihc')).toBe(0);
        });
        it('should match first letter', () => {
            expect(score('abc', '')).toBe(0);
            expect(score('abc', 'a')).toBe(5);
            expect(score('Abc', 'a')).toBe(2.5);
            expect(score('__abc', 'a')).toBe(2);
            expect(score('$Abc', 'a')).toBe(1);
            expect(score('$Abc', 'A')).toBe(2);
            expect(score('$Abc', '$A')).toBe(6);
            expect(score('$Abc', '$a')).toBe(5.5);
            expect(score('foo_bar', 'b')).toBe(2);
            expect(score('foo_Bar', 'b')).toBe(1);
            expect(score('_foo_Bar', 'b')).toBe(0.5);
            expect(score('_foo_Bar', 'f')).toBe(2);
            expect(score('bar', 'a')).toBe(1);
            expect(score('fooBar', 'B')).toBe(2);
            expect(score('fooBar', 'b')).toBe(1);
            expect(score('fobtoBar', 'bt')).toBe(2);
        });
        it('should match follow letters', () => {
            expect(score('abc', 'ab')).toBe(6);
            expect(score('adB', 'ab')).toBe(5.75);
            expect(score('adb', 'ab')).toBe(5.1);
            expect(score('adCB', 'ab')).toBe(5.05);
            expect(score('a_b_c', 'ab')).toBe(6);
            expect(score('FooBar', 'fb')).toBe(3.25);
            expect(score('FBar', 'fb')).toBe(3);
            expect(score('FooBar', 'FB')).toBe(6);
            expect(score('FBar', 'FB')).toBe(6);
            expect(score('a__b', 'a__b')).toBe(8);
            expect(score('aBc', 'ab')).toBe(5.5);
            expect(score('a_B_c', 'ab')).toBe(5.75);
            expect(score('abc', 'abc')).toBe(7);
            expect(score('abc', 'aC')).toBe(0);
            expect(score('abc', 'ac')).toBe(5.1);
            expect(score('abC', 'ac')).toBe(5.75);
            expect(score('abC', 'aC')).toBe(6);
        });
        it('should only allow search once', () => {
            expect(score('foobar', 'fbr')).toBe(5.2);
            expect(score('foobaRow', 'fbr')).toBe(5.85);
            expect(score('foobaRow', 'fbR')).toBe(6.1);
            expect(score('foobar', 'fa')).toBe(5.1);
        });
        it('should have higher score for strict match', () => {
            expect(score('language-client-protocol', 'lct')).toBe(6.1);
            expect(score('language-client-types', 'lct')).toBe(7);
        });
        it('should find highest score', () => {
            expect(score('ArrayRotateTail', 'art')).toBe(3.6);
        });
    });
    describe('matchScoreWithPositions', () => {
        function assertMatch(word, input, res) {
            let result = (0, match_1.matchScoreWithPositions)(word, (0, fuzzy_1.getCharCodes)(input));
            if (!res) {
                expect(result).toBeUndefined();
            }
            else {
                expect(result).toEqual(res);
            }
        }
        it('should return undefined when not match found', () => {
            assertMatch('a', 'abc', undefined);
            assertMatch('a', '', undefined);
            assertMatch('ab', 'ac', undefined);
        });
        it('should find matches by position fix', () => {
            assertMatch('this', 'tih', [5.6, [0, 1, 2]]);
            assertMatch('globalThis', 'tihs', [2.6, [6, 7, 8, 9]]);
        });
        it('should find matched positions', () => {
            assertMatch('this', 'th', [6, [0, 1]]);
            assertMatch('foo_bar', 'fb', [6, [0, 4]]);
            assertMatch('assertMatch', 'am', [5.75, [0, 6]]);
        });
    });
    describe('wordDistance', () => {
        it('should empty when not enabled', async () => {
            let w = await wordDistance_1.WordDistance.create(false, {}, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), {})).toBe(0);
        });
        it('should empty when selectRanges is empty', async () => {
            let opt = await nvim.call('coc#util#get_complete_option');
            let w = await wordDistance_1.WordDistance.create(true, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(w).toBe(wordDistance_1.WordDistance.None);
        });
        it('should empty when timeout', async () => {
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)
                        }];
                }
            }));
            let spy = jest.spyOn(workspace_1.default, 'computeWordRanges').mockImplementation(() => {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(null);
                    }, 50);
                });
            });
            let opt = await nvim.call('coc#util#get_complete_option');
            let w = await wordDistance_1.WordDistance.create(true, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            spy.mockRestore();
            expect(w).toBe(wordDistance_1.WordDistance.None);
        });
        it('should get distance', async () => {
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0),
                            parent: {
                                range: vscode_languageserver_protocol_1.Range.create(0, 0, 3, 0)
                            }
                        }];
                }
            }));
            let filepath = await (0, helper_1.createTmpFile)('foo bar\ndef', disposables);
            await helper_1.default.edit(filepath);
            let opt = await nvim.call('coc#util#get_complete_option');
            let w = await wordDistance_1.WordDistance.create(true, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(1, 0), {})).toBeGreaterThan(0);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), { word: '', kind: vscode_languageserver_protocol_1.CompletionItemKind.Keyword })).toBeGreaterThan(0);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), { word: 'not_exists' })).toBeGreaterThan(0);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), { word: 'bar' })).toBe(0);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), { word: 'def' })).toBeGreaterThan(0);
            await nvim.call('cursor', [1, 2]);
            await events_1.default.fire('CursorMoved', [opt.bufnr, [1, 2]]);
            expect(w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), { word: 'bar' })).toBe(0);
        });
        it('should get same range', async () => {
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0),
                            parent: {
                                range: vscode_languageserver_protocol_1.Range.create(0, 0, 3, 0)
                            }
                        }];
                }
            }));
            let spy = jest.spyOn(workspace_1.default, 'computeWordRanges').mockImplementation(() => {
                return Promise.resolve({ foo: [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0)] });
            });
            let opt = await nvim.call('coc#util#get_complete_option');
            opt.word = '';
            let w = await wordDistance_1.WordDistance.create(true, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            spy.mockRestore();
            let res = w.distance(vscode_languageserver_protocol_1.Position.create(0, 0), { word: 'foo' });
            expect(res).toBe(0);
        });
    });
    describe('MruLoader', () => {
        it('should add item without prefix', () => {
            let loader = new util_1.MruLoader();
            loader.add('foo', { kind: '', source: getSource(), filterText: 'foo' });
            let item = { kind: vscode_languageserver_protocol_1.CompletionItemKind.Class, source: getSource(), filterText: '$foo' };
            loader.add('foo', item);
            let score = loader.getScore('', item, util_1.Selection.RecentlyUsed);
            expect(score).toBeGreaterThan(-1);
            score = loader.getScore('a', item, util_1.Selection.RecentlyUsedByPrefix);
            expect(score).toBe(-1);
            score = loader.getScore('f', item, util_1.Selection.RecentlyUsed);
            expect(score).toBeGreaterThan(-1);
        });
    });
});
//# sourceMappingURL=util.test.js.map