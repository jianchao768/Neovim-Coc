'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinesTextDocument = exports.computeLinesOffsets = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const string_1 = require("../util/string");
const textline_1 = require("./textline");
function computeLinesOffsets(lines, eol) {
    const result = [];
    let textOffset = 0;
    for (let line of lines) {
        result.push(textOffset);
        textOffset += line.length + 1;
    }
    if (eol)
        result.push(textOffset);
    return result;
}
exports.computeLinesOffsets = computeLinesOffsets;
/**
 * Text document that created with readonly lines.
 *
 * Created for save memory since we could reuse readonly lines.
 */
class LinesTextDocument {
    constructor(uri, languageId, version, lines, bufnr, eol) {
        this.uri = uri;
        this.languageId = languageId;
        this.version = version;
        this.lines = lines;
        this.bufnr = bufnr;
        this.eol = eol;
    }
    get content() {
        if (!this._content) {
            this._content = this.lines.join('\n') + (this.eol ? '\n' : '');
        }
        return this._content;
    }
    get length() {
        if (!this._content) {
            let n = this.lines.reduce((p, c) => {
                return p + c.length + 1;
            }, 0);
            return this.eol ? n : n - 1;
        }
        return this._content.length;
    }
    get end() {
        let line = this.lineCount - 1;
        if (this.eol)
            return vscode_languageserver_types_1.Position.create(line, 0);
        return vscode_languageserver_types_1.Position.create(line, this.lines[line].length);
    }
    get lineCount() {
        return this.lines.length + (this.eol ? 1 : 0);
    }
    getText(range) {
        if (range) {
            let { start, end } = range;
            if (start.line === end.line) {
                if (start.character === end.character)
                    return '';
                let line = (0, string_1.toText)(this.lines[start.line]);
                return line.substring(start.character, end.character);
            }
            return this.content.substring(this.offsetAt(range.start), this.offsetAt(range.end));
        }
        return this.content;
    }
    lineAt(lineOrPos) {
        var _a;
        const line = vscode_languageserver_types_1.Position.is(lineOrPos) ? lineOrPos.line : lineOrPos;
        if (typeof line !== 'number' ||
            line < 0 ||
            line >= this.lineCount ||
            Math.floor(line) !== line) {
            throw new Error('Illegal value for `line`');
        }
        return new textline_1.TextLine(line, (_a = this.lines[line]) !== null && _a !== void 0 ? _a : '', line === this.lineCount - 1);
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this.content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0;
        let high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this.content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this.content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLinesOffsets(this.lines, this.eol);
        }
        return this._lineOffsets;
    }
}
exports.LinesTextDocument = LinesTextDocument;
//# sourceMappingURL=textdocument.js.map