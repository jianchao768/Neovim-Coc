'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseLanguageClient = exports.MessageTransports = exports.ClientState = exports.State = exports.RevealOutputChannelOn = exports.NullLogger = exports.CloseAction = exports.ErrorAction = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const errors_1 = require("../util/errors");
const fs_1 = require("../util/fs");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const callHierarchy_1 = require("./callHierarchy");
const codeAction_1 = require("./codeAction");
const codeLens_1 = require("./codeLens");
const colorProvider_1 = require("./colorProvider");
const completion_1 = require("./completion");
const configuration_1 = require("./configuration");
const declaration_1 = require("./declaration");
const definition_1 = require("./definition");
const diagnostic_1 = require("./diagnostic");
const documentHighlight_1 = require("./documentHighlight");
const documentLink_1 = require("./documentLink");
const documentSymbol_1 = require("./documentSymbol");
const executeCommand_1 = require("./executeCommand");
const features_1 = require("./features");
const fileOperations_1 = require("./fileOperations");
const fileSystemWatcher_1 = require("./fileSystemWatcher");
const foldingRange_1 = require("./foldingRange");
const formatting_1 = require("./formatting");
const hover_1 = require("./hover");
const implementation_1 = require("./implementation");
const inlayHint_1 = require("./inlayHint");
const inlineValue_1 = require("./inlineValue");
const linkedEditingRange_1 = require("./linkedEditingRange");
const progress_1 = require("./progress");
const progressPart_1 = require("./progressPart");
const reference_1 = require("./reference");
const rename_1 = require("./rename");
const selectionRange_1 = require("./selectionRange");
const semanticTokens_1 = require("./semanticTokens");
const signatureHelp_1 = require("./signatureHelp");
const textSynchronization_1 = require("./textSynchronization");
const typeDefinition_1 = require("./typeDefinition");
const typeHierarchy_1 = require("./typeHierarchy");
const utils_1 = require("./utils");
const cv = tslib_1.__importStar(require("./utils/converter"));
const errorHandler_1 = require("./utils/errorHandler");
Object.defineProperty(exports, "CloseAction", { enumerable: true, get: function () { return errorHandler_1.CloseAction; } });
Object.defineProperty(exports, "ErrorAction", { enumerable: true, get: function () { return errorHandler_1.ErrorAction; } });
const logger_2 = require("./utils/logger");
Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function () { return logger_2.NullLogger; } });
const UUID = tslib_1.__importStar(require("./utils/uuid"));
const workspaceFolders_1 = require("./workspaceFolders");
const workspaceSymbol_1 = require("./workspaceSymbol");
const logger = (0, logger_1.createLogger)('language-client-client');
const redOpen = '\x1B[31m';
const redClose = '\x1B[39m';
function createConnection(input, output, errorHandler, closeHandler, options) {
    let logger = new logger_2.ConsoleLogger();
    let connection = (0, protocol_1.createProtocolConnection)(input, output, logger, options);
    // let disposables: Disposable[] = []
    connection.onError(data => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    let result = {
        id: '',
        hasPendingResponse: () => connection.hasPendingResponse(),
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => {
            return connection.sendRequest((0, utils_1.toMethod)(type), ...params);
        },
        onRequest: (type, handler) => connection.onRequest((0, utils_1.toMethod)(type), handler),
        sendNotification: (type, params) => {
            return connection.sendNotification((0, utils_1.toMethod)(type), params);
        },
        onNotification: (type, handler) => connection.onNotification((0, utils_1.toMethod)(type), handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            return connection.trace(value, tracer, sendNotificationOrTraceOptions);
        },
        initialize: (params) => {
            return connection.sendRequest(protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
            return connection.sendRequest(protocol_1.ShutdownRequest.type, undefined);
        },
        exit: () => {
            return connection.sendNotification(protocol_1.ExitNotification.type);
        },
        end: () => connection.end(),
        dispose: () => connection.dispose()
    };
    return result;
}
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Running"] = 2] = "Running";
    State[State["Starting"] = 3] = "Starting";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState = exports.ClientState || (exports.ClientState = {}));
// eslint-disable-next-line no-redeclare
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return (candidate &&
            protocol_1.MessageReader.is(value.reader) &&
            protocol_1.MessageWriter.is(value.writer));
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._consoleDebug = false;
        this._features = [];
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
        }
        else {
            this._outputChannel = undefined;
        }
        this._clientOptions = this.resolveClientOptions(clientOptions);
        this.$state = ClientState.Initial;
        this._connection = undefined;
        this._initializeResult = undefined;
        this._listeners = [];
        this._diagnostics = undefined;
        this._notificationHandlers = new Map();
        this._pendingNotificationHandlers = new Map();
        this._notificationDisposables = new Map();
        this._requestHandlers = new Map();
        this._pendingRequestHandlers = new Map();
        this._requestDisposables = new Map();
        this._progressHandlers = new Map();
        this._pendingProgressHandlers = new Map();
        this._progressDisposables = new Map();
        this._ignoredRegistrations = new Set();
        this._onStop = undefined;
        this._stateChangeEmitter = new protocol_1.Emitter();
        this._trace = protocol_1.Trace.Off;
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            }
        };
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    switchConsole() {
        this._consoleDebug = !this._consoleDebug;
        if (!this._consoleDebug) {
            this.enableVerboseTrace();
        }
    }
    resolveClientOptions(clientOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown != null) {
            markdown.isTrusted = clientOptions.markdown.isTrusted === true;
            markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        let disableSnippetCompletion = clientOptions.disableSnippetCompletion;
        let disableMarkdown = clientOptions.disableMarkdown;
        if (disableMarkdown === undefined) {
            disableMarkdown = workspace_1.default.initialConfiguration.get('coc.preferences.enableMarkdown') === false;
        }
        const pullConfig = workspace_1.default.getConfiguration('pullDiagnostic', clientOptions.workspaceFolder);
        let pullOption = (_a = clientOptions.diagnosticPullOptions) !== null && _a !== void 0 ? _a : {};
        if (pullOption.onChange === undefined)
            pullOption.onChange = pullConfig.get('onChange');
        if (pullOption.onSave === undefined)
            pullOption.onSave = pullConfig.get('onSave');
        if (pullOption.workspace === undefined)
            pullOption.workspace = pullConfig.get('workspace');
        pullOption.ignored = pullConfig.get('ignored', []).concat((_b = pullOption.ignored) !== null && _b !== void 0 ? _b : []);
        let disabledFeatures = (_c = clientOptions.disabledFeatures) !== null && _c !== void 0 ? _c : [];
        for (let key of ['disableCompletion', 'disableWorkspaceFolders', 'disableDiagnostics']) {
            if (typeof clientOptions[key] === 'boolean') {
                let stack = '\n' + Error().stack.split('\n').slice(2, 4).join('\n');
                logger.warn(`${key} in the client options is deprecated. use disabledFeatures instead.`, stack);
                if (clientOptions[key] === true) {
                    let s = key.slice(7);
                    disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
                }
            }
        }
        let separateDiagnostics = clientOptions.separateDiagnostics;
        if (clientOptions.separateDiagnostics === undefined) {
            separateDiagnostics = workspace_1.default.getConfiguration('diagnostic', clientOptions.workspaceFolder).get('separateRelatedInformationAsDiagnostics');
        }
        return {
            disabledFeatures,
            disableMarkdown,
            disableSnippetCompletion,
            separateDiagnostics,
            diagnosticPullOptions: pullOption,
            rootPatterns: (_d = clientOptions.rootPatterns) !== null && _d !== void 0 ? _d : [],
            requireRootPattern: clientOptions.requireRootPattern,
            disableDynamicRegister: clientOptions.disableDynamicRegister,
            formatterPriority: (_e = clientOptions.formatterPriority) !== null && _e !== void 0 ? _e : 0,
            ignoredRootPaths: (_f = clientOptions.ignoredRootPaths) !== null && _f !== void 0 ? _f : [],
            documentSelector: (_g = clientOptions.documentSelector) !== null && _g !== void 0 ? _g : [],
            synchronize: (_h = clientOptions.synchronize) !== null && _h !== void 0 ? _h : {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: (_j = clientOptions.outputChannelName) !== null && _j !== void 0 ? _j : this._id,
            revealOutputChannelOn: (_k = clientOptions.revealOutputChannelOn) !== null && _k !== void 0 ? _k : RevealOutputChannelOn.Never,
            stdioEncoding: (_l = clientOptions.stdioEncoding) !== null && _l !== void 0 ? _l : 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: clientOptions.progressOnInitialization === true,
            errorHandler: (_m = clientOptions.errorHandler) !== null && _m !== void 0 ? _m : this.createDefaultErrorHandler((_o = clientOptions.connectionOptions) === null || _o === void 0 ? void 0 : _o.maxRestartCount),
            middleware: (_p = clientOptions.middleware) !== null && _p !== void 0 ? _p : {},
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown
        };
    }
    get supportedMarkupKind() {
        if (!this.clientOptions.disableMarkdown)
            return [vscode_languageserver_types_1.MarkupKind.Markdown, vscode_languageserver_types_1.MarkupKind.PlainText];
        return [vscode_languageserver_types_1.MarkupKind.PlainText];
    }
    get state() {
        return this.getPublicState();
    }
    get $state() {
        return this._state;
    }
    set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._name;
    }
    get middleware() {
        return this._clientOptions.middleware;
    }
    getPublicState() {
        if (this.$state === ClientState.Running) {
            return State.Running;
        }
        else if (this.$state === ClientState.Starting) {
            return State.Starting;
        }
        else {
            return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    async sendRequest(type, ...params) {
        this.checkState();
        try {
            const connection = await this.$start();
            return await connection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${(0, utils_1.toMethod)(type)} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        const method = (0, utils_1.toMethod)(type);
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._requestDisposables.set(method, connection.onRequest(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingRequestHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingRequestHandlers.delete(method);
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._requestHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            // not throw for notification
            return;
        }
        try {
            const connection = await this.$start();
            return await connection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${(0, utils_1.toMethod)(type)} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        const method = (0, utils_1.toMethod)(type);
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._notificationDisposables.set(method, connection.onNotification(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingNotificationHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingNotificationHandlers.delete(method);
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._notificationHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
        const realHandler = protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== undefined
            ? (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
            }
            : handler;
        if (connection !== undefined) {
            this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
            disposable = {
                dispose: () => {
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        else {
            this._pendingProgressHandlers.set(token, { type, handler });
            disposable = {
                dispose: () => {
                    this._pendingProgressHandlers.delete(token);
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._progressHandlers.delete(token);
                disposable.dispose();
            }
        };
    }
    async sendProgress(type, token, value) {
        this.checkState();
        try {
            const connection = await this.$start();
            await connection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    /**
     * languageserver.xxx.settings or undefined
     */
    get configuredSection() {
        var _a;
        let section = (_a = this._clientOptions.synchronize) === null || _a === void 0 ? void 0 : _a.configurationSection;
        return typeof section === 'string' && section.startsWith('languageserver.') ? section : undefined;
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            let { outputChannelName } = this._clientOptions;
            this._outputChannel = window_1.default.createOutputChannel((0, util_1.defaultValue)(outputChannelName, this._name));
        }
        return this._outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler(maxRestartCount) {
        return new errorHandler_1.DefaultErrorHandler(this._id, maxRestartCount !== null && maxRestartCount !== void 0 ? maxRestartCount : 4);
    }
    set trace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== undefined) {
            void connection.trace(this._trace, this._tracer, {
                sendNotification: false,
                traceFormat: this._traceFormat
            });
        }
    }
    logObjectTrace(data) {
        this.outputChannel.append((0, utils_1.getTraceMessage)(data));
        this.traceData(data);
    }
    traceData(data, error = false) {
        this.outputChannel.appendLine((0, utils_1.data2String)(data));
        if (this._consoleDebug)
            error ? console.error(redOpen + (0, utils_1.data2String)(data) + redClose) : console.log((0, utils_1.parseTraceData)(data));
    }
    consoleMessage(prefix, message, error = false) {
        if (this._consoleDebug) {
            let msg = prefix + ' ' + message;
            error ? console.error(redOpen + msg + redClose) : console.log(msg);
        }
    }
    info(message, data, showNotification = true) {
        let prefix = `[Info  - ${(0, utils_1.currentTimeStamp)()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null)
            this.traceData(data);
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage(protocol_1.MessageType.Info, message);
        }
    }
    warn(message, data, showNotification = true) {
        let prefix = `[Warn  - ${(0, utils_1.currentTimeStamp)()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null)
            this.traceData(data);
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage(protocol_1.MessageType.Warning, message);
        }
    }
    error(message, data, showNotification = true) {
        let prefix = `[Error - ${(0, utils_1.currentTimeStamp)()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message, true);
        if (data != null)
            this.traceData(data, true);
        if (showNotification === 'force' || (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error)) {
            this.showNotificationMessage(protocol_1.MessageType.Error, message);
        }
    }
    logTrace(message, data) {
        let prefix = `[Trace - ${(0, utils_1.currentTimeStamp)()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null)
            this.traceData(data);
    }
    showNotificationMessage(type, message) {
        const messageFunc = type === protocol_1.MessageType.Error
            ? window_1.default.showErrorMessage.bind(window_1.default)
            : type === protocol_1.MessageType.Warning
                ? window_1.default.showWarningMessage.bind(window_1.default)
                : window_1.default.showInformationMessage.bind(window_1.default);
        void messageFunc(message);
    }
    needsStart() {
        return (this.$state === ClientState.Initial ||
            this.$state === ClientState.Stopping ||
            this.$state === ClientState.Stopped);
    }
    needsStop() {
        return (this.$state === ClientState.Starting || this.$state === ClientState.Running);
    }
    activeConnection() {
        return this.$state === ClientState.Running && this._connection !== undefined ? this._connection : undefined;
    }
    get hasPendingResponse() {
        var _a;
        return (_a = this._connection) === null || _a === void 0 ? void 0 : _a.hasPendingResponse();
    }
    onReady() {
        if (this._onStart)
            return this._onStart;
        return new Promise(resolve => {
            let disposable = this.onDidChangeState(e => {
                if (e.newState === State.Running) {
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    get started() {
        return this.$state != ClientState.Initial;
    }
    isRunning() {
        return this.$state === ClientState.Running;
    }
    async _start() {
        if (this._disposed === 'disposing' || this._disposed === 'disposed') {
            throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
            throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        // We are already running or are in the process of getting up
        // to speed.
        if (this._onStart !== undefined) {
            return this._onStart;
        }
        this._rootPath = this.resolveRootPath();
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        // If we restart then the diagnostics collection is reused.
        if (this._diagnostics === undefined) {
            let opts = this._clientOptions;
            let name = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
            if (!opts.disabledFeatures.includes('diagnostics')) {
                this._diagnostics = languages_1.default.createDiagnosticCollection(name);
            }
        }
        // When we start make all buffer handlers pending so that they
        // get added.
        for (const [method, handler] of this._notificationHandlers) {
            if (!this._pendingNotificationHandlers.has(method)) {
                this._pendingNotificationHandlers.set(method, handler);
            }
        }
        for (const [method, handler] of this._requestHandlers) {
            if (!this._pendingRequestHandlers.has(method)) {
                this._pendingRequestHandlers.set(method, handler);
            }
        }
        for (const [token, data] of this._progressHandlers) {
            if (!this._pendingProgressHandlers.has(token)) {
                this._pendingProgressHandlers.set(token, data);
            }
        }
        this.$state = ClientState.Starting;
        try {
            const connection = await this.createConnection();
            this.handleConnectionEvents(connection);
            connection.listen();
            await this.initialize(connection);
            resolve();
        }
        catch (error) {
            this.$state = ClientState.StartFailed;
            this.error(`${this._name} client: couldn't create connection to server.`, error, 'force');
            reject(error);
        }
        return this._onStart;
    }
    start() {
        let p = this._start();
        p.dispose = () => {
            if (this.needsStop()) {
                void this.stop();
            }
        };
        return p;
    }
    async $start() {
        if (this.$state === ClientState.StartFailed) {
            throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this._start();
        const connection = this.activeConnection();
        if (connection === undefined) {
            throw new Error(`Starting server failed`);
        }
        return connection;
    }
    handleConnectionEvents(connection) {
        connection.onNotification(protocol_1.LogMessageNotification.type, message => {
            switch (message.type) {
                case protocol_1.MessageType.Error:
                    this.error(message.message);
                    break;
                case protocol_1.MessageType.Warning:
                    this.warn(message.message);
                    break;
                case protocol_1.MessageType.Info:
                    this.info(message.message);
                    break;
                default:
                    this.outputChannel.appendLine(message.message);
            }
        });
        connection.onNotification(protocol_1.ShowMessageNotification.type, message => {
            switch (message.type) {
                case protocol_1.MessageType.Error:
                    void window_1.default.showErrorMessage(message.message);
                    break;
                case protocol_1.MessageType.Warning:
                    void window_1.default.showWarningMessage(message.message);
                    break;
                case protocol_1.MessageType.Info:
                    void window_1.default.showInformationMessage(message.message);
                    break;
                default:
                    void window_1.default.showInformationMessage(message.message);
            }
        });
        // connection.onNotification(TelemetryEventNotification.type, data => {
        //   // Not supported.
        //   // this._telemetryEmitter.fire(data);
        // })
        connection.onRequest(protocol_1.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
                case protocol_1.MessageType.Error:
                    messageFunc = window_1.default.showErrorMessage.bind(window_1.default);
                    break;
                case protocol_1.MessageType.Warning:
                    messageFunc = window_1.default.showWarningMessage.bind(window_1.default);
                    break;
                case protocol_1.MessageType.Info:
                    messageFunc = window_1.default.showInformationMessage.bind(window_1.default);
                    break;
                default:
                    messageFunc = window_1.default.showInformationMessage.bind(window_1.default);
            }
            let actions = (0, array_1.toArray)(params.actions);
            return messageFunc(params.message, ...actions).then(res => {
                return res == null ? null : res;
            });
        });
        connection.onRequest(protocol_1.ShowDocumentRequest.type, async (params) => {
            var _a;
            const showDocument = async (params) => {
                try {
                    if (params.external === true || /^https?:\/\//.test(params.uri)) {
                        await workspace_1.default.openResource(params.uri);
                        return { success: true };
                    }
                    else {
                        let { selection, takeFocus } = params;
                        if (takeFocus === false) {
                            await workspace_1.default.loadFile(params.uri);
                        }
                        else {
                            await workspace_1.default.jumpTo(params.uri, selection === null || selection === void 0 ? void 0 : selection.start);
                            if (selection && (0, position_1.comparePosition)(selection.start, selection.end) != 0) {
                                await window_1.default.selectRange(selection);
                            }
                        }
                        return { success: true };
                    }
                }
                catch (error) {
                    return { success: false };
                }
            };
            const middleware = (_a = this._clientOptions.middleware.window) === null || _a === void 0 ? void 0 : _a.showDocument;
            if (middleware !== undefined) {
                return middleware(params, showDocument);
            }
            else {
                return showDocument(params);
            }
        });
    }
    createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
        });
        return [promise, resolve, reject];
    }
    resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
            return vscode_uri_1.URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths, rootPatterns, requireRootPattern } = this._clientOptions;
        let resolved;
        if (!(0, array_1.isFalsyOrEmpty)(rootPatterns)) {
            resolved = workspace_1.default.documentsManager.resolveRoot(rootPatterns, requireRootPattern);
        }
        let rootPath = resolved || workspace_1.default.rootPath;
        if ((0, fs_1.sameFile)(rootPath, node_1.os.homedir()) || ignoredRootPaths.some(p => (0, fs_1.sameFile)(rootPath, p))) {
            this.warn(`Ignored rootPath ${rootPath} of client "${this._id}"`);
            return null;
        }
        return rootPath;
    }
    initialize(connection) {
        let { initializationOptions, workspaceFolder, progressOnInitialization } = this._clientOptions;
        this.refreshTrace(connection, false);
        let rootPath = this._rootPath;
        let initParams = {
            processId: process.pid,
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? cv.asUri(vscode_uri_1.URI.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initializationOptions) ? initializationOptions() : initializationOptions,
            trace: protocol_1.Trace.toString(this._trace),
            workspaceFolders: workspaceFolder ? [workspaceFolder] : null,
            locale: (0, utils_1.getLocale)(),
            clientInfo: {
                name: 'coc.nvim',
                version: workspace_1.default.version
            }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
            const token = UUID.generateUuid();
            initParams.workDoneToken = token;
            connection.id = this._id;
            const part = new progressPart_1.ProgressPart(connection, token);
            part.begin({ title: `Initializing ${this.id}`, kind: 'begin' });
            return this.doInitialize(connection, initParams).then(result => {
                part.done();
                return result;
            }, error => {
                part.done();
                return Promise.reject(error);
            });
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    async doInitialize(connection, initParams) {
        try {
            const result = await connection.initialize(initParams);
            if (result.capabilities.positionEncoding !== undefined && result.capabilities.positionEncoding !== protocol_1.PositionEncodingKind.UTF16) {
                await connection.shutdown();
                await connection.exit();
                connection.end();
                connection.dispose();
                throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
            }
            this._initializeResult = result;
            this.$state = ClientState.Running;
            let textDocumentSyncOptions;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== undefined && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onNotification(protocol_1.PublishDiagnosticsNotification.type, params => this.handleDiagnostics(params));
            connection.onRequest(protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            // Add pending notification, request and progress handlers.
            for (const [method, handler] of this._pendingNotificationHandlers) {
                this._notificationDisposables.set(method, connection.onNotification(method, handler));
            }
            this._pendingNotificationHandlers.clear();
            for (const [method, handler] of this._pendingRequestHandlers) {
                this._requestDisposables.set(method, connection.onRequest(method, handler));
            }
            this._pendingRequestHandlers.clear();
            for (const [token, data] of this._pendingProgressHandlers) {
                this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
            }
            this._pendingProgressHandlers.clear();
            await connection.sendNotification(protocol_1.InitializedNotification.type, {});
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            return result;
        }
        catch (error) {
            let cb = (retry) => {
                if (retry) {
                    this.initialize(connection).catch(() => { });
                }
                else {
                    this.stop().catch(() => { });
                }
            };
            if (this._clientOptions.initializationFailedHandler) {
                cb(this._clientOptions.initializationFailedHandler(error));
            }
            else if (error instanceof protocol_1.ResponseError && error.data && error.data.retry) {
                if (this._connection) {
                    let connection = this._connection;
                    connection.end();
                    this._connection.dispose();
                    this._connection = null;
                }
                void window_1.default.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    cb(item && item.id === 'retry');
                });
            }
            else {
                void window_1.default.showErrorMessage((0, string_1.toText)(error.message));
                this.error('Server initialization failed.', error);
                logger.error(`Server ${this.id} initialization failed.`, error);
                cb(false);
            }
            throw error;
        }
    }
    stop(timeout = 2000) {
        // Wait 2 seconds on stop
        return this.shutdown('stop', timeout);
    }
    async shutdown(mode, timeout) {
        // If the client is stopped or in its initial state return.
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
            return;
        }
        // If we are stopping the client and have a stop promise return it.
        if (this.$state === ClientState.Stopping) {
            return this._onStop;
        }
        const connection = this.activeConnection();
        // We can't stop a client that is not running (e.g. has no connection). Especially not
        // on that us starting since it can't be correctly synchronized.
        if (connection === undefined || (this.$state !== ClientState.Running && this.$state !== ClientState.Starting)) {
            throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = undefined;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        let tm;
        const tp = new Promise(c => { tm = setTimeout(c, timeout); });
        const shutdown = (async (connection) => {
            await connection.shutdown();
            await connection.exit();
            return connection;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then(connection => {
            if (tm)
                clearTimeout(tm);
            // The connection won the race with the timeout.
            if (connection !== undefined) {
                connection.end();
                connection.dispose();
            }
            else {
                this.error(`Stopping server timed out`, undefined);
                throw new Error(`Stopping the server timed out`);
            }
        }, error => {
            this.error(`Stopping server failed`, error);
            throw error;
        }).finally(() => {
            this.$state = ClientState.Stopped;
            mode === 'stop' && this.cleanUpChannel();
            this._onStart = undefined;
            this._onStop = undefined;
            this._connection = undefined;
            this._ignoredRegistrations.clear();
        });
    }
    dispose(timeout = 2000) {
        if (this._disposed)
            return;
        try {
            this._disposed = 'disposing';
            if (!this.needsStop())
                return;
            return this.stop(timeout);
        }
        finally {
            this._disposed = 'disposed';
        }
    }
    cleanUp(mode) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = [];
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        for (let feature of this._features.values()) {
            if (typeof feature.dispose === 'function') {
                feature.dispose();
            }
        }
        if (mode === 'stop' && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
    }
    cleanUpChannel() {
        if (this._outputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    async forceDocumentSync() {
        let textDocuments = Array.from(this._syncedDocuments.values());
        await Promise.all(textDocuments.map(textDocument => {
            let doc = workspace_1.default.getDocument(textDocument.uri);
            return doc ? doc.synchronize() : null;
        }));
    }
    handleDiagnostics(params) {
        let { uri, diagnostics, version } = params;
        if (Is.number(version) && !workspace_1.default.hasDocument(uri, version))
            return;
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
            middleware(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    }
    async createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        const transports = await this.createMessageTransports((0, util_1.defaultValue)(this._clientOptions.stdioEncoding, 'utf8'));
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.$state === ClientState.Stopped) {
            logger.debug(`client ${this._id} normal closed`);
            return;
        }
        try {
            if (this._connection) {
                this._connection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let action = errorHandler_1.CloseAction.DoNotRestart;
        if (this.$state !== ClientState.Stopping && this._clientOptions.errorHandler) {
            try {
                action = this._clientOptions.errorHandler.closed();
            }
            catch (error) {
                // Ignore errors coming from the error handler.
            }
        }
        this._connection = undefined;
        if (action === errorHandler_1.CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.', undefined, 'force');
            this.cleanUp('stop');
            if (this.$state === ClientState.Starting) {
                this.$state = ClientState.StartFailed;
            }
            else {
                this.$state = ClientState.Stopped;
            }
            this._onStop = Promise.resolve();
            this._onStart = undefined;
        }
        else if (action === errorHandler_1.CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp('restart');
            this.$state = ClientState.Initial;
            this._onStop = Promise.resolve();
            this._onStart = undefined;
            this.start().catch(this.error.bind(this, `Restarting server failed`));
        }
    }
    checkState() {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            throw new protocol_1.ResponseError(protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`);
        }
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === errorHandler_1.ErrorAction.Shutdown) {
            this.error(`Client ${this._name}: connection to server is erroring. Shutting down server.`, undefined, 'force');
            this.stop().catch(this.error.bind(this, `Stopping server failed`));
        }
    }
    hookConfigurationChanged(connection) {
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(this._id)) {
                this.refreshTrace(connection, true);
            }
        }, null, this._listeners);
    }
    refreshTrace(connection, sendNotification) {
        let config = workspace_1.default.getConfiguration(this._id, this.clientOptions.workspaceFolder);
        let trace = protocol_1.Trace.Off;
        let traceFormat = protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        if (sendNotification && this._trace == trace && this._traceFormat == traceFormat) {
            return;
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        }).catch(this.error.bind(this, `Updating trace failed with error`));
    }
    enableVerboseTrace() {
        this._trace = protocol_1.Trace.Verbose;
        this._traceFormat = protocol_1.TraceFormat.Text;
        this._connection.trace(this._trace, this._tracer, {
            sendNotification: true,
            traceFormat: this._traceFormat
        }).catch(this.error.bind(this, `Updating trace failed with error`));
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature, '');
        }
    }
    registerFeature(feature, name) {
        let { disabledFeatures } = this._clientOptions;
        if (disabledFeatures.length > 0 && disabledFeatures.includes(name))
            return;
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
        }
    }
    getStaticFeature(method) {
        return this._features.find(o => features_1.StaticFeature.is(o) && o.method == method);
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this), 'configuration');
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments), 'document');
        this.registerFeature(new textSynchronization_1.DidChangeTextDocumentFeature(this), 'document');
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments), 'document');
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this), 'willSave');
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this), 'willSaveWaitUntil');
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this), 'didSave');
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this), 'fileSystemWatcher');
        this.registerFeature(new completion_1.CompletionItemFeature(this), 'completion');
        this.registerFeature(new hover_1.HoverFeature(this), 'hover');
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this), 'signatureHelp');
        this.registerFeature(new reference_1.ReferencesFeature(this), 'references');
        this.registerFeature(new definition_1.DefinitionFeature(this), 'definition');
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this), 'documentHighlight');
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this), 'documentSymbol');
        this.registerFeature(new codeAction_1.CodeActionFeature(this), 'codeAction');
        this.registerFeature(new codeLens_1.CodeLensFeature(this), 'codeLens');
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this), 'documentFormatting');
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this), 'documentRangeFormatting');
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this), 'documentOnTypeFormatting');
        this.registerFeature(new rename_1.RenameFeature(this), 'rename');
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this), 'documentLink');
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this), 'executeCommand');
        this.registerFeature(new configuration_1.PullConfigurationFeature(this), 'pullConfiguration');
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this), 'typeDefinition');
        this.registerFeature(new implementation_1.ImplementationFeature(this), 'implementation');
        this.registerFeature(new declaration_1.DeclarationFeature(this), 'declaration');
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this), 'colorProvider');
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this), 'foldingRange');
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this), 'selectionRange');
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this), 'callHierarchy');
        this.registerFeature(new progress_1.ProgressFeature(this), 'progress');
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this), 'linkedEditing');
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this), 'fileEvents');
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this), 'fileEvents');
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this), 'fileEvents');
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this), 'fileEvents');
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this), 'fileEvents');
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this), 'fileEvents');
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this), 'semanticTokens');
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this), 'inlayHint');
        this.registerFeature(new inlineValue_1.InlineValueFeature(this), 'inlineValue');
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this), 'pullDiagnostic');
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this), 'typeHierarchy');
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this), 'workspaceSymbol');
        // We only register the workspace folder feature if the client is not locked
        // to a specific workspace folder.
        if (this.clientOptions.workspaceFolder === undefined) {
            this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this), 'workspaceFolders');
        }
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, 'workspace').applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [protocol_1.ResourceOperationKind.Create, protocol_1.ResourceOperationKind.Rename, protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = protocol_1.FailureHandlingKind.Undo;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: false
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = true;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary, vscode_languageserver_types_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, 'window');
        const showMessage = (0, features_1.ensure)(windowCapabilities, 'showMessage');
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, 'showDocument');
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, 'general');
        generalCapabilities.regularExpressions = { engine: 'ECMAScript', version: 'ES2020' };
        generalCapabilities.markdown = { parser: 'marked', version: '4.0.10' };
        generalCapabilities.positionEncodings = ['utf-16'];
        // Added in 3.17.0
        // if (this._clientOptions.markdown.supportHtml) {
        //   generalCapabilities.markdown.allowedTags = ['ul', 'li', 'p', 'code', 'blockquote', 'ol', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'em', 'pre', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'div', 'del', 'a', 'strong', 'br', 'img', 'span']
        // }
        generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
            if (Is.func(feature.preInitialize)) {
                feature.preInitialize(this._capabilities, documentSelector);
            }
        }
        for (let feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    handleRegistrationRequest(params) {
        var _a, _b;
        if (this.clientOptions.disableDynamicRegister)
            return;
        // We will not receive a registration call before a client is running
        // from a server. However if we stop or shutdown we might which might
        // try to restart the server. So ignore registrations if we are not running
        if (!this.isRunning()) {
            for (const registration of params.registrations) {
                this._ignoredRegistrations.add(registration.id);
            }
            return;
        }
        for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (!feature) {
                this.error(`No feature implementation for ${registration.method} found. Registration failed.`);
                return;
            }
            const options = (_a = registration.registerOptions) !== null && _a !== void 0 ? _a : {};
            options.documentSelector = (_b = options.documentSelector) !== null && _b !== void 0 ? _b : this._clientOptions.documentSelector;
            const data = {
                id: registration.id,
                registerOptions: options
            };
            feature.register(data);
        }
    }
    handleUnregistrationRequest(params) {
        return new Promise(resolve => {
            for (let unregistration of params.unregisterations) {
                if (this._ignoredRegistrations.has(unregistration.id))
                    continue;
                const feature = this._dynamicFeatures.get(unregistration.method);
                if (feature)
                    feature.unregister(unregistration.id);
            }
            resolve();
        });
    }
    setDiagnostics(uri, diagnostics) {
        var _a;
        if (!this._diagnostics)
            return;
        const separate = this.clientOptions.separateDiagnostics;
        // TODO make is async
        if (separate && diagnostics.length > 0) {
            const entries = new Map();
            entries.set(uri, diagnostics);
            for (const diagnostic of diagnostics) {
                if ((_a = diagnostic.relatedInformation) === null || _a === void 0 ? void 0 : _a.length) {
                    let message = `${diagnostic.message}\n\nRelated diagnostics:\n`;
                    for (const info of diagnostic.relatedInformation) {
                        const basename = node_1.path.basename(vscode_uri_1.URI.parse(info.location.uri).fsPath);
                        const ln = info.location.range.start.line;
                        message = `${message}\n${basename}(line ${ln + 1}): ${info.message}`;
                        const diags = entries.get(info.location.uri) || [];
                        diags.push(vscode_languageserver_types_1.Diagnostic.create(info.location.range, info.message, vscode_languageserver_types_1.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
                        entries.set(info.location.uri, diags);
                    }
                    diagnostic.message = message;
                }
                this._diagnostics.set(Array.from(entries));
            }
        }
        else {
            this._diagnostics.set(uri, diagnostics);
        }
    }
    handleApplyWorkspaceEdit(params) {
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        workspace_1.default.textDocuments.forEach(document => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_types_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return workspace_1.default.applyEdit(params.edit).then(value => {
            return { applied: value };
        });
    }
    handleFailedRequest(type, token, error, defaultValue) {
        if (token && token.isCancellationRequested)
            return defaultValue;
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof protocol_1.ResponseError) {
            // The connection got disposed while we were waiting for a response.
            // Simply return the default value. Is the best we can do.
            if (error.code === protocol_1.ErrorCodes.PendingResponseRejected || error.code === protocol_1.ErrorCodes.ConnectionInactive) {
                return defaultValue;
            }
            if (error.code === protocol_1.LSPErrorCodes.RequestCancelled || error.code === protocol_1.LSPErrorCodes.ServerCancelled) {
                if (error.data != null) {
                    throw new features_1.LSPCancellationError(error.data);
                }
                else {
                    throw new errors_1.CancellationError();
                }
            }
            else if (error.code === protocol_1.LSPErrorCodes.ContentModified) {
                if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
                    throw new errors_1.CancellationError();
                }
                else {
                    return defaultValue;
                }
            }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
    }
    // Should be keeped
    logFailedRequest() {
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
BaseLanguageClient.RequestsToCancelOnContentModified = new Set([
    protocol_1.InlayHintRequest.method,
    protocol_1.SemanticTokensRequest.method,
    protocol_1.SemanticTokensRangeRequest.method,
    protocol_1.SemanticTokensDeltaRequest.method
]);
const ProposedFeatures = {
    createAll: (_client) => {
        let result = [];
        return result;
    }
};
//# sourceMappingURL=client.js.map