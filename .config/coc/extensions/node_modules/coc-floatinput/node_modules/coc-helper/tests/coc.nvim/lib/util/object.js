'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.equals = exports.mixin = exports.deepFreeze = exports.hasOwnProperty = exports.deepClone = exports.toReadonly = exports.deepIterate = exports.omitUndefined = exports.toObject = exports.isEmpty = void 0;
const tslib_1 = require("tslib");
const Is = tslib_1.__importStar(require("./is"));
function isEmpty(obj) {
    if (!obj)
        return true;
    if (Array.isArray(obj))
        return obj.length == 0;
    return Object.keys(obj).length == 0;
}
exports.isEmpty = isEmpty;
function toObject(obj) {
    return obj == null ? {} : obj;
}
exports.toObject = toObject;
function omitUndefined(obj) {
    const result = {};
    Object.entries(obj).forEach(([key, val]) => {
        if (val !== undefined)
            result[key] = val;
    });
    return result;
}
exports.omitUndefined = omitUndefined;
function deepIterate(obj, fn) {
    Object.entries(obj).forEach(([key, val]) => {
        fn(obj, key);
        if (Array.isArray(val)) {
            val.forEach(node => {
                if (Is.objectLiteral(node)) {
                    deepIterate(node, fn);
                }
            });
        }
        else if (Is.objectLiteral(val)) {
            deepIterate(val, fn);
        }
    });
    return obj;
}
exports.deepIterate = deepIterate;
function toReadonly(obj) {
    const result = {};
    for (let key of Object.keys(obj)) {
        Object.defineProperty(result, key, {
            value: obj[key],
            writable: false,
            enumerable: true
        });
    }
    return result;
}
exports.toReadonly = toReadonly;
function deepClone(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof RegExp) {
        // See https://github.com/Microsoft/TypeScript/issues/10990
        return obj;
    }
    const result = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach(key => {
        if (obj[key] && typeof obj[key] === 'object') {
            result[key] = deepClone(obj[key]);
        }
        else {
            result[key] = obj[key];
        }
    });
    return result;
}
exports.deepClone = deepClone;
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
exports.hasOwnProperty = hasOwnProperty;
function deepFreeze(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    const stack = [obj];
    while (stack.length > 0) {
        let obj = stack.shift();
        Object.freeze(obj);
        for (const key of Object.keys(obj)) {
            let prop = obj[key];
            if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                stack.push(prop);
            }
        }
    }
    return obj;
}
exports.deepFreeze = deepFreeze;
/**
 * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
 * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
 */
function mixin(destination, source, overwrite = true) {
    if (!Is.objectLiteral(destination)) {
        return source;
    }
    if (Is.objectLiteral(source)) {
        Object.keys(source).forEach(key => {
            if (key in destination) {
                if (overwrite) {
                    if (Is.objectLiteral(destination[key]) && Is.objectLiteral(source[key])) {
                        mixin(destination[key], source[key], overwrite);
                    }
                    else {
                        destination[key] = source[key];
                    }
                }
            }
            else {
                destination[key] = source[key];
            }
        });
    }
    return destination;
}
exports.mixin = mixin;
function equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null ||
        one === undefined ||
        other === null ||
        other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
        return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        const oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        const otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
exports.equals = equals;
//# sourceMappingURL=object.js.map