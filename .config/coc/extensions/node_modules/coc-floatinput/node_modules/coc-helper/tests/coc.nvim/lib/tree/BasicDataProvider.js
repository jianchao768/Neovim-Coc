'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const protocol_1 = require("../util/protocol");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const util_1 = require("../util");
const TreeItem_1 = require("./TreeItem");
const array_1 = require("../util/array");
function isIcon(obj) {
    if (!obj)
        return false;
    return typeof obj.text === 'string' && typeof obj.hlGroup === 'string';
}
/**
 * Check label and key, children not checked.
 */
function sameTreeNode(one, two) {
    if (one.label === two.label
        && one.deprecated === two.deprecated
        && one.key === two.key) {
        return true;
    }
    return false;
}
/**
 * Check changes of nodes array, children not checked.
 */
function sameTreeNodes(one, two) {
    if (one.length !== two.length)
        return false;
    return one.every((v, idx) => sameTreeNode(v, two[idx]));
}
/**
 * Tree data provider for resolved tree with children.
 * Use update() to update data.
 */
class BasicDataProvider {
    // data is shared with TreeView
    constructor(opts) {
        this.opts = opts;
        this.disposables = [];
        // only fired for change of exists TreeNode
        this._onDidChangeTreeData = new protocol_1.Emitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.invokeCommand = `_invoke_${(0, uuid_1.v4)()}`;
        this.disposables.push(commands_1.default.registerCommand(this.invokeCommand, async (node) => {
            await opts.handleClick(node);
        }, null, true));
        if (typeof opts.resolveActions === 'function') {
            this.resolveActions = opts.resolveActions.bind(this);
        }
    }
    iterate(node, parentNode, level, fn) {
        let res = fn(node, parentNode, level);
        if (res === false)
            return false;
        if (Array.isArray(node.children)) {
            for (let element of node.children) {
                let res = this.iterate(element, node, level + 1, fn);
                if (res === false)
                    return false;
            }
        }
        return res;
    }
    /**
     * Change old array to new nodes in place, keep old reference when possible.
     */
    updateNodes(old, data, parentNode, fireEvent = true) {
        let sameNodes = sameTreeNodes(old, data);
        const applyNode = (previous, curr, fireEvent) => {
            var _a, _b, _c, _d;
            let changed = false;
            for (let key of Object.keys(curr)) {
                if (['children', 'key'].includes(key))
                    continue;
                previous[key] = curr[key];
            }
            if (((_a = previous.children) === null || _a === void 0 ? void 0 : _a.length) && !((_b = curr.children) === null || _b === void 0 ? void 0 : _b.length)) {
                // removed children
                delete previous.children;
                changed = true;
            }
            if (!((_c = previous.children) === null || _c === void 0 ? void 0 : _c.length) && ((_d = curr.children) === null || _d === void 0 ? void 0 : _d.length)) {
                // new children
                previous.children = curr.children;
                changed = true;
            }
            if (changed) {
                if (fireEvent)
                    this._onDidChangeTreeData.fire(previous);
                return;
            }
            if ((0, array_1.toArray)(previous.children).length > 0 && (0, array_1.toArray)(curr.children).length > 0) {
                this.updateNodes(previous.children, curr.children, previous, fireEvent);
            }
        };
        if (sameNodes) {
            for (let i = 0; i < old.length; i++) {
                applyNode(old[i], data[i], fireEvent);
            }
        }
        else {
            let oldNodes = old.splice(0, old.length);
            let used = new Set();
            for (let i = 0; i < data.length; i++) {
                let curr = data[i];
                let findIndex;
                if (curr.key) {
                    findIndex = oldNodes.findIndex((o, i) => !used.has(i) && o.key == curr.key);
                }
                else {
                    findIndex = oldNodes.findIndex((o, i) => !used.has(i) && o.label == curr.label);
                }
                if (findIndex === -1) {
                    old[i] = curr;
                }
                else {
                    used.add(findIndex);
                    let previous = oldNodes[findIndex];
                    applyNode(previous, curr, false);
                    old[i] = previous;
                }
            }
            if (fireEvent) {
                this._onDidChangeTreeData.fire(parentNode);
            }
        }
    }
    /**
     * Update with new data, fires change event when necessary.
     */
    update(data, reset) {
        if (!this.data)
            return;
        if (reset) {
            this.data = (0, array_1.toArray)(data);
            this._onDidChangeTreeData.fire(undefined);
        }
        else {
            this.updateNodes(this.data, (0, array_1.toArray)(data), undefined);
        }
        return this.data;
    }
    getTreeItem(node) {
        var _a;
        let label = node.label;
        let { expandLevel } = this.opts;
        let item;
        if (!((_a = node.children) === null || _a === void 0 ? void 0 : _a.length)) {
            item = new TreeItem_1.TreeItem(label);
        }
        else {
            if (expandLevel && expandLevel > 0) {
                let level = this.getLevel(node);
                let state = level && level <= expandLevel ? TreeItem_1.TreeItemCollapsibleState.Expanded : TreeItem_1.TreeItemCollapsibleState.Collapsed;
                item = new TreeItem_1.TreeItem(label, state);
            }
            else {
                item = new TreeItem_1.TreeItem(label, TreeItem_1.TreeItemCollapsibleState.Collapsed);
            }
        }
        item.description = node.description;
        if (node.deprecated)
            item.deprecated = true;
        if (node.tooltip)
            item.tooltip = node.tooltip;
        if (isIcon(node.icon)) {
            item.icon = node.icon;
        }
        else if (typeof this.opts.resolveIcon === 'function') {
            let res = this.opts.resolveIcon(node);
            if (res)
                item.icon = res;
        }
        return item;
    }
    async getChildren(element) {
        var _a;
        if (element)
            return (_a = element.children) !== null && _a !== void 0 ? _a : [];
        if (this.data)
            return this.data;
        let data = await Promise.resolve(this.opts.provideData());
        if (!Array.isArray(data))
            throw new Error(`Unable to fetch data`);
        this.data = data;
        return data;
    }
    /**
     * Use reference check
     */
    getParent(element) {
        if (!this.data)
            return undefined;
        let find;
        for (let item of this.data) {
            let res = this.iterate(item, null, 0, (node, parentNode) => {
                if (node === element) {
                    find = parentNode;
                    return false;
                }
            });
            if (res === false)
                break;
        }
        return find;
    }
    getLevel(element) {
        if (!this.data)
            return 0;
        let level = 0;
        for (let item of (0, array_1.toArray)(this.data)) {
            let res = this.iterate(item, null, 1, (node, _parentNode, l) => {
                if (node === element) {
                    level = l;
                    return false;
                }
            });
            if (res === false)
                break;
        }
        return level;
    }
    /**
     * Resolve command and tooltip
     */
    async resolveTreeItem(item, element, token) {
        if (typeof this.opts.resolveItem === 'function') {
            let res = await Promise.resolve(this.opts.resolveItem(item, element, token));
            if (res)
                Object.assign(item, res);
        }
        if (!item.command) {
            item.command = {
                title: `invoke ${element.label}`,
                command: this.invokeCommand,
                arguments: [element]
            };
        }
        return item;
    }
    dispose() {
        this.data = [];
        this._onDidChangeTreeData.dispose();
        if (typeof this.opts.onDispose === 'function') {
            this.opts.onDispose();
        }
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = BasicDataProvider;
//# sourceMappingURL=BasicDataProvider.js.map