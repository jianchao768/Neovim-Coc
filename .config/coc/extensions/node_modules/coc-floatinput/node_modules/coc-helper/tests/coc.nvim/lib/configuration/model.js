'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationModel = void 0;
const array_1 = require("../util/array");
const is_1 = require("../util/is");
const object_1 = require("../util/object");
const util_1 = require("./util");
class ConfigurationModel {
    constructor(_contents = {}, _keys = [], _overrides = []) {
        this._contents = _contents;
        this._keys = _keys;
        this._overrides = _overrides;
        this.frozen = false;
        this.overrideConfigurations = new Map();
    }
    get contents() {
        return this.checkAndFreeze(this._contents);
    }
    get overrides() {
        return this.checkAndFreeze(this._overrides);
    }
    get keys() {
        return this.checkAndFreeze(this._keys);
    }
    get isFrozen() {
        return this.frozen;
    }
    checkAndFreeze(data) {
        if (this.frozen && !Object.isFrozen(data)) {
            return (0, object_1.deepFreeze)(data);
        }
        return data;
    }
    isEmpty() {
        return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
    }
    clone() {
        return new ConfigurationModel((0, object_1.deepClone)(this._contents), [...this.keys], (0, object_1.deepClone)(this.overrides));
    }
    toJSON() {
        return {
            contents: this.contents,
            overrides: this.overrides,
            keys: this.keys
        };
    }
    getValue(section) {
        let res = section
            ? (0, util_1.getConfigurationValue)(this.contents, section)
            : this.contents;
        return res;
    }
    getOverrideValue(section, overrideIdentifier) {
        const overrideContents = this.getContentsForOverrideIdentifier(overrideIdentifier);
        return overrideContents
            ? section ? (0, util_1.getConfigurationValue)(overrideContents, section) : overrideContents
            : undefined;
    }
    getKeysForOverrideIdentifier(identifier) {
        const keys = [];
        for (const override of this.overrides) {
            if (override.identifiers.includes(identifier)) {
                keys.push(...override.keys);
            }
        }
        return (0, array_1.distinct)(keys);
    }
    getAllOverrideIdentifiers() {
        const result = [];
        for (const override of this.overrides) {
            result.push(...override.identifiers);
        }
        return (0, array_1.distinct)(result);
    }
    override(identifier) {
        let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
        if (!overrideConfigurationModel) {
            overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);
            this.overrideConfigurations.set(identifier, overrideConfigurationModel);
        }
        return overrideConfigurationModel;
    }
    merge(...others) {
        const contents = (0, object_1.deepClone)(this._contents);
        const overrides = (0, object_1.deepClone)(this._overrides);
        const keys = [...this._keys];
        for (const other of others) {
            if (other.isEmpty()) {
                continue;
            }
            this.mergeContents(contents, other.contents);
            for (const otherOverride of other.overrides) {
                const [override] = overrides.filter(o => (0, object_1.equals)(o.identifiers, otherOverride.identifiers));
                if (override) {
                    this.mergeContents(override.contents, otherOverride.contents);
                    override.keys.push(...otherOverride.keys);
                    override.keys = (0, array_1.distinct)(override.keys);
                }
                else {
                    overrides.push((0, object_1.deepClone)(otherOverride));
                }
            }
            for (const key of other.keys) {
                if (keys.indexOf(key) === -1) {
                    keys.push(key);
                }
            }
        }
        return new ConfigurationModel(contents, keys, overrides);
    }
    freeze() {
        this.frozen = true;
        return this;
    }
    mergeContents(source, target) {
        for (const key of Object.keys(target)) {
            if (key in source) {
                if ((0, is_1.objectLiteral)(source[key]) && (0, is_1.objectLiteral)(target[key])) {
                    this.mergeContents(source[key], target[key]);
                    continue;
                }
            }
            source[key] = (0, object_1.deepClone)(target[key]);
        }
    }
    // Update methods
    setValue(key, value) {
        this.addKey(key);
        (0, util_1.addToValueTree)(this.contents, key, value, e => { console.error(e); });
    }
    removeValue(key) {
        if (this.removeKey(key)) {
            (0, util_1.removeFromValueTree)(this.contents, key);
        }
    }
    addKey(key) {
        let index = this.keys.length;
        for (let i = 0; i < index; i++) {
            if (key.indexOf(this.keys[i]) === 0) {
                index = i;
            }
        }
        this.keys.splice(index, 1, key);
    }
    removeKey(key) {
        const index = this.keys.indexOf(key);
        if (index !== -1) {
            this.keys.splice(index, 1);
            return true;
        }
        return false;
    }
    createOverrideConfigurationModel(identifier) {
        const overrideContents = this.getContentsForOverrideIdentifier(identifier);
        if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {
            // If there are no valid overrides, return self
            return this;
        }
        const contents = {};
        for (const key of (0, array_1.distinct)([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
            let contentsForKey = this.contents[key];
            const overrideContentsForKey = overrideContents[key];
            // If there are override contents for the key, clone and merge otherwise use base contents
            if (overrideContentsForKey) {
                // Clone and merge only if base contents and override contents are of type object otherwise just override
                if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {
                    contentsForKey = (0, object_1.deepClone)(contentsForKey);
                    this.mergeContents(contentsForKey, overrideContentsForKey);
                }
                else {
                    contentsForKey = overrideContentsForKey;
                }
            }
            contents[key] = contentsForKey;
        }
        return new ConfigurationModel(contents, this._keys, this.overrides);
    }
    getContentsForOverrideIdentifier(identifier) {
        let contentsForIdentifierOnly = null;
        let contents = null;
        const mergeContents = (contentsToMerge) => {
            if (contentsToMerge) {
                if (contents) {
                    this.mergeContents(contents, contentsToMerge);
                }
                else {
                    contents = (0, object_1.deepClone)(contentsToMerge);
                }
            }
        };
        for (const override of this.overrides) {
            if ((0, object_1.equals)(override.identifiers, [identifier])) {
                contentsForIdentifierOnly = override.contents;
            }
            else if (override.identifiers.includes(identifier)) {
                mergeContents(override.contents);
            }
        }
        // Merge contents of the identifier only at the end to take precedence.
        mergeContents(contentsForIdentifierOnly);
        return contents;
    }
}
exports.ConfigurationModel = ConfigurationModel;
//# sourceMappingURL=model.js.map