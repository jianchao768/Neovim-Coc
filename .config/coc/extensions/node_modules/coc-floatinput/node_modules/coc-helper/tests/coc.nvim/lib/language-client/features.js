'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.BaseFeature = exports.LSPCancellationError = void 0;
const tslib_1 = require("tslib");
const protocol_1 = require("../util/protocol");
const Is = tslib_1.__importStar(require("../util/is"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
const errors_1 = require("../util/errors");
class LSPCancellationError extends errors_1.CancellationError {
    constructor(data) {
        super();
        this.data = data;
    }
}
exports.LSPCancellationError = LSPCancellationError;
class BaseFeature {
    constructor(client) {
        this._client = client;
    }
    sendRequest(type, params, token, defaultValue) {
        return this._client.sendRequest(type, params, token).then((res => {
            return token.isCancellationRequested || res == null ? defaultValue !== null && defaultValue !== void 0 ? defaultValue : null : res;
        }), error => {
            return this._client.handleFailedRequest(type, token, error, defaultValue !== null && defaultValue !== void 0 ? defaultValue : null);
        });
    }
}
exports.BaseFeature = BaseFeature;
function ensure(target, key) {
    if (target[key] === undefined) {
        target[key] = {};
    }
    return target[key];
}
exports.ensure = ensure;
// eslint-disable-next-line no-redeclare
var StaticFeature;
(function (StaticFeature) {
    function is(value) {
        return value !== undefined && value !== null &&
            Is.func(value.fillClientCapabilities) && Is.func(value.initialize) && Is.func(value.dispose) &&
            (value.fillInitializeParams === undefined || Is.func(value.fillInitializeParams)) && value.registrationType === undefined;
    }
    StaticFeature.is = is;
})(StaticFeature = exports.StaticFeature || (exports.StaticFeature = {}));
// eslint-disable-next-line no-redeclare
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) &&
            Is.func(candidate.unregister) && candidate.registrationType !== undefined;
    }
    DynamicFeature.is = is;
})(DynamicFeature = exports.DynamicFeature || (exports.DynamicFeature = {}));
/**
 * An abstract dynamic feature implementation that operates on documents (e.g. text
 * documents or notebooks).
 */
class DynamicDocumentFeature extends BaseFeature {
    constructor(client) {
        super(client);
    }
    /**
     * Returns the state the feature is in.
     */
    getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
            count++;
            for (const document of workspace_1.default.textDocuments) {
                if (workspace_1.default.match(selector, document) > 0) {
                    return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
                }
            }
        }
        const registrations = count > 0;
        return { kind: 'document', id: this.registrationType.method, registrations, matches: false };
    }
}
exports.DynamicDocumentFeature = DynamicDocumentFeature;
class TextDocumentEventFeature extends DynamicDocumentFeature {
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (workspace_1.default.match(selector, textDocument) > 0) {
                return true;
            }
        }
        return false;
    }
    constructor(client, event, type, middleware, createParams, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._selectorFilter = selectorFilter;
        this._selectors = new Map();
        this._onNotificationSent = new protocol_1.Emitter();
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(data => {
                this.callback(data).catch(error => {
                    this._client.error(`Sending document notification ${this._type.method} failed.`, error);
                });
            });
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    async callback(data) {
        if (!this.matches(data))
            return;
        const doSend = async (data) => {
            const params = this._createParams(data);
            await this._client.sendNotification(this._type, params).catch();
            this.notificationSent(data, this._type, params);
        };
        const middleware = this._client.middleware[this._middleware];
        return Promise.resolve(middleware ? middleware(data, data => doSend(data)) : doSend(data));
    }
    matches(data) {
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
    }
    unregister(id) {
        this._selectors.delete(id);
    }
    dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this.getDocumentSelectors()) {
            if (workspace_1.default.match(selector, document) > 0) {
                return {
                    send: (data) => {
                        return this.callback(data);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.TextDocumentEventFeature = TextDocumentEventFeature;
/**
 * A abstract feature implementation that registers language providers
 * for text documents using a given document selector.
 */
class TextDocumentLanguageFeature extends DynamicDocumentFeature {
    constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
            const selector = registration.data.registerOptions.documentSelector;
            if (selector === null) {
                continue;
            }
            yield selector;
        }
    }
    get registrationType() {
        return this._registrationType;
    }
    get registrationLength() {
        return this._registrations.size;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach(value => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        var _a;
        if (!capability)
            return [undefined, undefined];
        if (Is.boolean(capability) && capability === true) {
            return [UUID.generateUuid(), { documentSelector }];
        }
        if (protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = (_a = capability.documentSelector) !== null && _a !== void 0 ? _a : documentSelector;
            return [id, Object.assign({}, { documentSelector: selector }, capability)];
        }
        if (protocol_1.WorkDoneProgressOptions.is(capability)) {
            const id = protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            return [id, Object.assign({}, { documentSelector }, capability)];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && workspace_1.default.match(selector, textDocument) > 0) {
                return registration.provider;
            }
        }
        return undefined;
    }
    getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
            result.push(item.provider);
        }
        return result;
    }
}
exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
//# sourceMappingURL=features.js.map