'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInput = exports.indexOf = exports.convertItemLabel = exports.toInputs = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("../logger");
const util_1 = require("../util");
const ansiparse_1 = require("../util/ansiparse");
const array_1 = require("../util/array");
const async_1 = require("../util/async");
const diff_1 = require("../util/diff");
const fuzzy_1 = require("../util/fuzzy");
const mutex_1 = require("../util/mutex");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const configuration_1 = tslib_1.__importDefault(require("./configuration"));
const logger = (0, logger_1.createLogger)('list-worker');
const controlCode = '\x1b';
const WHITE_SPACE_CHARS = [32, 9];
const SERCH_HL_GROUP = 'CocListSearch';
// perform loading task
class Worker {
    constructor(list, prompt, listOptions) {
        this.list = list;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this._loading = false;
        this._finished = false;
        this.mutex = new mutex_1.Mutex();
        this.totalItems = [];
        this._onDidChangeItems = new protocol_1.Emitter();
        this._onDidChangeLoading = new protocol_1.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        this.onDidChangeLoading = this._onDidChangeLoading.event;
        this.fuzzyMatch = workspace_1.default.createFuzzyMatch();
    }
    set loading(loading) {
        if (this._loading == loading)
            return;
        this._loading = loading;
        this._onDidChangeLoading.fire(loading);
    }
    get isLoading() {
        return this._loading;
    }
    async loadItems(context, reload = false) {
        this.cancelFilter();
        this.filteredCount = 0;
        this._finished = false;
        let { list, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        this.tokenSource = new protocol_1.CancellationTokenSource();
        let token = this.tokenSource.token;
        let items = await list.loadItems(context, token);
        if (token.isCancellationRequested)
            return;
        items = items !== null && items !== void 0 ? items : [];
        if (Array.isArray(items)) {
            this.tokenSource = null;
            this.totalItems = items;
            this.loading = false;
            this._finished = true;
            let filtered;
            if (!interactive) {
                this.filterTokenSource = new protocol_1.CancellationTokenSource();
                await this.mutex.use(async () => {
                    await this.filterItems(items, { reload }, token);
                });
            }
            else {
                filtered = this.convertToHighlightItems(items);
                this._onDidChangeItems.fire({
                    sorted: true,
                    items: filtered,
                    reload,
                    finished: true
                });
            }
        }
        else {
            let task = items;
            let totalItems = this.totalItems = [];
            let taken = 0;
            let currInput = context.input;
            this.filterTokenSource = new protocol_1.CancellationTokenSource();
            let _onData = async (finished) => {
                await this.mutex.use(async () => {
                    let inputChanged = this.input != currInput;
                    if (inputChanged) {
                        currInput = this.input;
                        taken = (0, util_1.defaultValue)(this.filteredCount, 0);
                    }
                    if (taken >= totalItems.length)
                        return;
                    let append = taken > 0;
                    let remain = totalItems.slice(taken);
                    taken = totalItems.length;
                    if (!interactive) {
                        let tokenSource = this.filterTokenSource;
                        await this.filterItems(remain, { append, reload }, tokenSource.token);
                    }
                    else {
                        let items = this.convertToHighlightItems(remain);
                        this._onDidChangeItems.fire({ items, append, reload, sorted: true, finished });
                    }
                });
            };
            let interval = setInterval(async () => {
                await _onData();
            }, 50);
            task.on('data', item => {
                totalItems.push(item);
            });
            let onEnd = async () => {
                if (task == null)
                    return;
                clearInterval(interval);
                this.tokenSource = null;
                task = null;
                this.loading = false;
                this._finished = true;
                disposable.dispose();
                if (token.isCancellationRequested)
                    return;
                if (totalItems.length == 0) {
                    this._onDidChangeItems.fire({ items: [], append: false, sorted: true, reload, finished: true });
                    return;
                }
                await _onData(true);
            };
            let disposable = token.onCancellationRequested(() => {
                this.mutex.reset();
                task === null || task === void 0 ? void 0 : task.dispose();
                void onEnd();
            });
            task.on('error', async (error) => {
                if (task == null)
                    return;
                task = null;
                this.tokenSource = null;
                this.loading = false;
                disposable.dispose();
                clearInterval(interval);
                workspace_1.default.nvim.call('coc#prompt#stop_prompt', ['list'], true);
                workspace_1.default.nvim.echoError(`Task error: ${error.toString()}`);
                logger.error('Task error:', error);
            });
            task.on('end', onEnd);
        }
    }
    /*
     * Draw all items with filter if necessary
     */
    async drawItems() {
        let { totalItems } = this;
        if (totalItems.length === 0)
            return;
        this.cancelFilter();
        let tokenSource = this.filterTokenSource = new protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        await this.mutex.use(async () => {
            if (token.isCancellationRequested)
                return;
            let { totalItems } = this;
            this.filteredCount = totalItems.length;
            await this.filterItems(totalItems, {}, tokenSource.token);
        });
    }
    cancelFilter() {
        if (this.filterTokenSource) {
            this.filterTokenSource.cancel();
            this.filterTokenSource = null;
        }
    }
    stop() {
        this.cancelFilter();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
        this.loading = false;
    }
    get length() {
        return this.totalItems.length;
    }
    get input() {
        return this.prompt.input;
    }
    /**
     * Add highlights for interactive list
     */
    convertToHighlightItems(items) {
        let input = (0, string_1.toText)(this.input);
        if (input.length > 0)
            this.fuzzyMatch.setPattern(input);
        let res = items.map(item => {
            convertItemLabel(item);
            let search = input.length > 0 && item.filterText !== '';
            if (search) {
                let filterLabel = getFilterLabel(item);
                let results = this.fuzzyMatch.matchHighlights(filterLabel, SERCH_HL_GROUP);
                item.ansiHighlights = Array.isArray(item.ansiHighlights) ? item.ansiHighlights.filter(o => o.hlGroup !== SERCH_HL_GROUP) : [];
                if (results)
                    item.ansiHighlights.push(...results.highlights);
            }
            return item;
        });
        this.fuzzyMatch.free();
        return res;
    }
    async filterItemsByInclude(input, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        const smartcase = configuration_1.default.smartcase;
        let inputs = toInputs(input, configuration_1.default.extendedSearchMode);
        if (ignorecase)
            inputs = inputs.map(s => s.toLowerCase());
        await (0, async_1.filter)(items, item => {
            convertItemLabel(item);
            let spans = [];
            let filterLabel = getFilterLabel(item);
            let byteIndex = (0, string_1.bytes)(filterLabel);
            let curr = 0;
            item.ansiHighlights = (0, array_1.toArray)(item.ansiHighlights).filter(o => o.hlGroup !== SERCH_HL_GROUP);
            for (let input of inputs) {
                let label = filterLabel.slice(curr);
                let idx = indexOf(label, input, smartcase, ignorecase);
                if (idx === -1)
                    break;
                let end = idx + curr + input.length;
                spans.push([byteIndex(idx + curr), byteIndex(end)]);
                curr = end;
            }
            if (spans.length !== inputs.length)
                return false;
            item.ansiHighlights.push(...spans.map(s => {
                return { span: s, hlGroup: SERCH_HL_GROUP };
            }));
            return true;
        }, onFilter, token);
    }
    async filterItemsByRegex(input, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        let flags = ignorecase ? 'iu' : 'u';
        let inputs = toInputs(input, configuration_1.default.extendedSearchMode);
        let regexes = inputs.reduce((p, c) => {
            try {
                p.push(new RegExp(c, flags));
            }
            catch (e) { }
            return p;
        }, []);
        await (0, async_1.filter)(items, item => {
            convertItemLabel(item);
            item.ansiHighlights = (0, array_1.toArray)(item.ansiHighlights).filter(o => o.hlGroup !== SERCH_HL_GROUP);
            let spans = [];
            let filterLabel = getFilterLabel(item);
            let byteIndex = (0, string_1.bytes)(filterLabel);
            let curr = 0;
            for (let regex of regexes) {
                let ms = filterLabel.slice(curr).match(regex);
                if (ms == null)
                    break;
                let end = ms.index + curr + ms[0].length;
                spans.push([byteIndex(ms.index + curr), byteIndex(end)]);
                curr = end;
            }
            if (spans.length !== inputs.length)
                return false;
            item.ansiHighlights.push(...spans.map(s => {
                return { span: s, hlGroup: SERCH_HL_GROUP };
            }));
            return true;
        }, onFilter, token);
    }
    async filterItemsByFuzzyMatch(input, items, token, onFilter) {
        let { extendedSearchMode, smartcase } = configuration_1.default;
        let { sort } = this.listOptions;
        let idx = 0;
        this.fuzzyMatch.setPattern(input, !extendedSearchMode);
        let codes = (0, fuzzy_1.getCharCodes)(input);
        if (extendedSearchMode)
            codes = codes.filter(c => !WHITE_SPACE_CHARS.includes(c));
        await (0, async_1.filter)(items, item => {
            convertItemLabel(item);
            let filterLabel = getFilterLabel(item);
            let match = this.fuzzyMatch.matchHighlights(filterLabel, SERCH_HL_GROUP);
            if (!match || (smartcase && !(0, fuzzy_1.fuzzyMatch)(codes, filterLabel)))
                return false;
            let ansiHighlights = Array.isArray(item.ansiHighlights) ? item.ansiHighlights.filter(o => o.hlGroup != SERCH_HL_GROUP) : [];
            ansiHighlights.push(...match.highlights);
            return {
                sortText: typeof item.sortText === 'string' ? item.sortText : String.fromCharCode(idx),
                score: match.score,
                ansiHighlights
            };
        }, (items, done) => {
            onFilter(items, done, sort);
        }, token);
    }
    async filterItems(arr, opts, token) {
        let { input } = this;
        if (input.length === 0) {
            let items = arr.map(item => {
                return convertItemLabel(item);
            });
            this._onDidChangeItems.fire(Object.assign({ items, sorted: true, finished: this._finished }, opts));
            return;
        }
        let called = false;
        let itemsToSort = [];
        const onFilter = (items, done, sort) => {
            let finished = done && this._finished;
            if (token.isCancellationRequested || (!finished && items.length == 0))
                return;
            if (sort) {
                itemsToSort.push(...items);
                if (done)
                    this._onDidChangeItems.fire({ items: itemsToSort, append: false, sorted: false, reload: opts.reload, finished });
            }
            else {
                let append = opts.append === true || called;
                called = true;
                this._onDidChangeItems.fire({ items, append, sorted: true, reload: opts.reload, finished });
            }
        };
        switch (this.listOptions.matcher) {
            case 'strict':
                await this.filterItemsByInclude(input, arr, token, onFilter);
                break;
            case 'regex':
                await this.filterItemsByRegex(input, arr, token, onFilter);
                break;
            default:
                await this.filterItemsByFuzzyMatch(input, arr, token, onFilter);
        }
    }
    dispose() {
        this.stop();
    }
}
exports.default = Worker;
function getFilterLabel(item) {
    return item.filterText != null ? (0, diff_1.patchLine)(item.filterText, item.label) : item.label;
}
function toInputs(input, extendedSearchMode) {
    return extendedSearchMode ? parseInput(input) : [input];
}
exports.toInputs = toInputs;
function convertItemLabel(item) {
    let { label, converted } = item;
    if (converted)
        return item;
    if (label.includes('\n')) {
        label = item.label = label.replace(/\r?\n.*/gm, '');
    }
    if (label.includes(controlCode)) {
        let { line, highlights } = (0, ansiparse_1.parseAnsiHighlights)(label);
        item.label = line;
        if (!Array.isArray(item.ansiHighlights))
            item.ansiHighlights = highlights;
    }
    item.converted = true;
    return item;
}
exports.convertItemLabel = convertItemLabel;
function indexOf(label, input, smartcase, ignorecase) {
    if (smartcase)
        return (0, string_1.smartcaseIndex)(input, label);
    return ignorecase ? label.toLowerCase().indexOf(input.toLowerCase()) : label.indexOf(input);
}
exports.indexOf = indexOf;
/**
 * `a\ b` => [`a b`]
 * `a b` =>  ['a', 'b']
 */
function parseInput(input) {
    let res = [];
    let startIdx = 0;
    let currIdx = 0;
    let prev = '';
    for (; currIdx < input.length; currIdx++) {
        let ch = input[currIdx];
        if (WHITE_SPACE_CHARS.includes(ch.charCodeAt(0))) {
            // find space
            if (prev && prev != '\\' && startIdx != currIdx) {
                res.push(input.slice(startIdx, currIdx));
                startIdx = currIdx + 1;
            }
        }
        else {
        }
        prev = ch;
    }
    if (startIdx != input.length) {
        res.push(input.slice(startIdx, input.length));
    }
    return res.map(s => s.replace(/\\\s/g, ' ').trim()).filter(s => s.length > 0);
}
exports.parseInput = parseInput;
//# sourceMappingURL=worker.js.map