'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNodeByPosition = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const BasicDataProvider_1 = tslib_1.__importDefault(require("../../tree/BasicDataProvider"));
const TreeView_1 = tslib_1.__importDefault(require("../../tree/TreeView"));
const util_1 = require("../../util");
const position_1 = require("../../util/position");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const hoverTimeout = (0, util_1.getConditionValue)(300, 10);
/**
 * Manage TreeViews and Providers of outline.
 */
class SymbolsOutline {
    constructor(nvim, buffers, handler) {
        this.nvim = nvim;
        this.buffers = buffers;
        this.handler = handler;
        this.treeViewList = [];
        this.providersMap = new Map();
        this.sortByMap = new Map();
        this.disposables = [];
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        workspace_1.default.onDidCloseTextDocument(async (e) => {
            let { bufnr } = e;
            let provider = this.providersMap.get(bufnr);
            if (!provider)
                return;
            let loaded = await nvim.call('bufloaded', [bufnr]);
            // reload detected
            if (loaded)
                return;
            this.providersMap.delete(bufnr);
            provider.dispose();
        }, null, this.disposables);
        window_1.default.onDidChangeActiveTextEditor(async (editor) => {
            if (!this.config.checkBufferSwitch)
                return;
            let view = this.treeViewList.find(v => v.visible && v.targetTabId == editor.tabpageid);
            if (view) {
                await this.showOutline(editor.document.bufnr, editor.tabpageid);
                await nvim.command(`noa call win_gotoid(${editor.winid})`);
            }
        }, null, this.disposables);
        events_1.default.on('CursorHold', async (bufnr, cursor) => {
            if (!this.config.followCursor)
                return;
            let provider = this.providersMap.get(bufnr);
            if (!provider)
                return;
            let tabpage = await nvim.tabpage;
            let view = this.treeViewList.find(o => o.visible && o.targetBufnr == bufnr && o.targetTabId == tabpage.id);
            if (!view)
                return;
            await this.revealPosition(bufnr, view, vscode_languageserver_types_1.Position.create(cursor[0] - 1, cursor[1] - 1));
        }, null, this.disposables);
    }
    async revealPosition(bufnr, treeView, position) {
        let provider = this.providersMap.get(bufnr);
        let nodes = await Promise.resolve(provider.getChildren());
        let curr = getNodeByPosition(position, nodes);
        if (curr)
            await treeView.reveal(curr);
    }
    loadConfiguration(e) {
        if (!e || e.affectsConfiguration('outline')) {
            let c = workspace_1.default.getConfiguration('outline', null);
            this.config = {
                splitCommand: c.get('splitCommand'),
                switchSortKey: c.get('switchSortKey'),
                togglePreviewKey: c.get('togglePreviewKey'),
                followCursor: c.get('followCursor'),
                keepWindow: c.get('keepWindow'),
                expandLevel: c.get('expandLevel'),
                autoWidth: c.get('autoWidth'),
                checkBufferSwitch: c.get('checkBufferSwitch'),
                detailAsDescription: c.get('detailAsDescription'),
                sortBy: c.get('sortBy'),
                showLineNumber: c.get('showLineNumber'),
                codeActionKinds: c.get('codeActionKinds'),
                autoPreview: c.get('autoPreview'),
                previewMaxWidth: c.get('previewMaxWidth'),
                previewBorder: c.get('previewBorder'),
                previewBorderRounded: c.get('previewBorderRounded'),
                previewHighlightGroup: c.get('previewHighlightGroup'),
                previewBorderHighlightGroup: c.get('previewBorderHighlightGroup'),
                previewWinblend: c.get('previewWinblend'),
            };
        }
    }
    convertSymbolToNode(documentSymbol, sortFn) {
        var _a;
        let descs = [];
        let { detailAsDescription, showLineNumber } = this.config;
        if (detailAsDescription && documentSymbol.detail)
            descs.push(documentSymbol.detail);
        if (showLineNumber)
            descs.push(`${documentSymbol.selectionRange.start.line + 1}`);
        return {
            label: documentSymbol.name,
            tooltip: detailAsDescription ? undefined : documentSymbol.detail,
            description: descs.join(' '),
            icon: this.handler.getIcon(documentSymbol.kind),
            deprecated: (_a = documentSymbol.tags) === null || _a === void 0 ? void 0 : _a.includes(vscode_languageserver_types_1.SymbolTag.Deprecated),
            kind: documentSymbol.kind,
            range: documentSymbol.range,
            selectRange: documentSymbol.selectionRange,
            children: Array.isArray(documentSymbol.children) ? documentSymbol.children.map(o => {
                return this.convertSymbolToNode(o, sortFn);
            }).sort(sortFn) : undefined
        };
    }
    setMessage(bufnr, msg) {
        this.treeViewList.forEach(v => {
            if (v.valid && v.targetBufnr == bufnr) {
                v.message = msg;
            }
        });
    }
    convertSymbols(bufnr, symbols) {
        let sortBy = this.getSortBy(bufnr);
        let sortFn = (a, b) => {
            if (sortBy === 'name') {
                return a.label < b.label ? -1 : 1;
            }
            if (sortBy === 'category') {
                if (a.kind == b.kind)
                    return a.label < b.label ? -1 : 1;
                return a.kind - b.kind;
            }
            return (0, position_1.comparePosition)(a.selectRange.start, b.selectRange.start);
        };
        return symbols.map(s => this.convertSymbolToNode(s, sortFn)).sort(sortFn);
    }
    onSymbolsUpdate(bufnr, symbols) {
        let provider = this.providersMap.get(bufnr);
        if (provider)
            provider.update(this.convertSymbols(bufnr, symbols));
    }
    createProvider(bufnr) {
        let { nvim } = this;
        let provider = new BasicDataProvider_1.default({
            expandLevel: this.config.expandLevel,
            provideData: async () => {
                let buf = this.buffers.getItem(bufnr);
                if (!buf)
                    throw new Error('Document not attached');
                let doc = workspace_1.default.getDocument(bufnr);
                if (!languages_1.default.hasProvider(languages_1.ProviderName.DocumentSymbol, doc.textDocument)) {
                    throw new Error('Document symbol provider not found');
                }
                let meta = languages_1.default.getDocumentSymbolMetadata(doc.textDocument);
                if (meta && meta.label) {
                    let views = this.treeViewList.filter(v => v.valid && v.targetBufnr == bufnr);
                    views.forEach(view => view.description = meta.label);
                }
                this.setMessage(bufnr, 'Loading document symbols');
                let arr = await buf.getSymbols();
                if (!arr || arr.length == 0) {
                    // server may return empty symbols on buffer initialize, throw error to force reload.
                    throw new Error('Empty symbols returned from language server. ');
                }
                this.setMessage(bufnr, undefined);
                return this.convertSymbols(bufnr, arr);
            },
            handleClick: async (item) => {
                let winnr = await nvim.call('bufwinnr', [bufnr]);
                if (winnr == -1)
                    return;
                nvim.pauseNotification();
                nvim.command(`${winnr}wincmd w`, true);
                let pos = item.selectRange.start;
                nvim.call('coc#cursor#move_to', [pos.line, pos.character], true);
                nvim.command(`normal! zz`, true);
                let buf = nvim.createBuffer(bufnr);
                buf.highlightRanges('outline-hover', 'CocHoverRange', [item.selectRange]);
                nvim.command('redraw', true);
                await nvim.resumeNotification();
                setTimeout(() => {
                    buf.clearNamespace('outline-hover');
                    nvim.command('redraw', true);
                }, hoverTimeout);
            },
            resolveActions: async (_, element) => {
                let winnr = await nvim.call('bufwinnr', [bufnr]);
                if (winnr == -1)
                    return;
                let doc = workspace_1.default.getDocument(bufnr);
                let actions = await this.handler.getCodeActions(doc, element.range, this.config.codeActionKinds);
                let arr = actions.map(o => {
                    return {
                        title: o.title,
                        handler: async () => {
                            let position = element.range.start;
                            await nvim.command(`${winnr}wincmd w`);
                            await this.nvim.call('coc#cursor#move_to', [position.line, position.character]);
                            await this.handler.applyCodeAction(o);
                        }
                    };
                });
                return [...arr, {
                        title: 'Visual Select',
                        handler: async (item) => {
                            await nvim.command(`${winnr}wincmd w`);
                            await window_1.default.selectRange(item.range);
                        }
                    }];
            },
            onDispose: () => {
                for (let view of this.treeViewList.slice()) {
                    if (view.provider === provider) {
                        view.dispose();
                    }
                }
            }
        });
        return provider;
    }
    getSortBy(bufnr) {
        var _a;
        return (_a = this.sortByMap.get(bufnr)) !== null && _a !== void 0 ? _a : this.config.sortBy;
    }
    async showOutline(bufnr, tabId) {
        if (!this.providersMap.has(bufnr)) {
            this.providersMap.set(bufnr, this.createProvider(bufnr));
        }
        let treeView = this.treeViewList.find(v => v.valid && v.targetBufnr == bufnr && v.targetTabId == tabId);
        if (!treeView) {
            let { switchSortKey, togglePreviewKey } = this.config;
            let autoPreview = this.config.autoPreview;
            let previewBufnr;
            treeView = new TreeView_1.default('OUTLINE', {
                autoWidth: this.config.autoWidth,
                bufhidden: 'hide',
                enableFilter: true,
                treeDataProvider: this.providersMap.get(bufnr),
            });
            let sortBy = this.getSortBy(bufnr);
            let prev;
            treeView.description = `${sortBy[0].toUpperCase()}${sortBy.slice(1)}`;
            this.treeViewList.push(treeView);
            let disposable = events_1.default.on('BufEnter', bufnr => {
                if (previewBufnr && bufnr !== previewBufnr) {
                    prev = undefined;
                    this.closePreview();
                }
            });
            treeView.onDispose(() => {
                let idx = this.treeViewList.findIndex(v => v === treeView);
                if (idx !== -1)
                    this.treeViewList.splice(idx, 1);
                disposable.dispose();
                this.closePreview();
            });
            treeView.onDidCursorMoved(async (node) => {
                if (autoPreview && prev !== node) {
                    prev = node;
                    previewBufnr = await this.doPreview(bufnr, node);
                }
            });
            treeView.registerLocalKeymap('n', switchSortKey, async () => {
                let arr = ['category', 'name', 'position'];
                let curr = this.getSortBy(bufnr);
                let items = arr.map(s => {
                    return { text: s, disabled: s === curr };
                });
                let res = await window_1.default.showMenuPicker(items, { title: 'Choose sort method' });
                if (res < 0)
                    return;
                let sortBy = arr[res];
                this.sortByMap.set(bufnr, sortBy);
                let views = this.treeViewList.filter(o => o.targetBufnr == bufnr);
                views.forEach(view => {
                    view.description = `${sortBy[0].toUpperCase()}${sortBy.slice(1)}`;
                });
                let item = this.buffers.getItem(bufnr);
                this.onSymbolsUpdate(bufnr, item.symbols);
            }, true);
            treeView.registerLocalKeymap('n', togglePreviewKey, async (node) => {
                autoPreview = !autoPreview;
                if (!autoPreview) {
                    prev = undefined;
                    this.closePreview();
                }
                else {
                    previewBufnr = await this.doPreview(bufnr, node);
                }
            }, true);
        }
        await treeView.show(this.config.splitCommand, false);
        return treeView;
    }
    async doPreview(bufnr, node) {
        if (!node) {
            this.closePreview();
            return;
        }
        let config = {
            bufnr,
            range: node.range,
            border: this.config.previewBorder,
            rounded: this.config.previewBorderRounded,
            maxWidth: this.config.previewMaxWidth,
            highlight: this.config.previewHighlightGroup,
            borderhighlight: this.config.previewBorderHighlightGroup,
            winblend: this.config.previewWinblend
        };
        return await this.nvim.call('coc#ui#outline_preview', [config]);
    }
    closePreview() {
        this.nvim.call('coc#ui#outline_close_preview', [], true);
    }
    /**
     * Create outline view.
     */
    async show(keep) {
        let [bufnr, winid] = await this.nvim.eval('[bufnr("%"),win_getid()]');
        let tabpage = await this.nvim.tabpage;
        let doc = workspace_1.default.getDocument(bufnr);
        if (doc && !doc.attached) {
            void window_1.default.showErrorMessage(`Unable to show outline, ${doc.notAttachReason}`);
            return;
        }
        let position = await window_1.default.getCursorPosition();
        let treeView = await this.showOutline(bufnr, tabpage.id);
        if (keep == 1 || (keep === undefined && this.config.keepWindow)) {
            await this.nvim.command(`noa call win_gotoid(${winid})`);
        }
        else if (this.config.followCursor) {
            let disposable = treeView.onDidRefrash(async () => {
                disposable.dispose();
                let curr = await this.nvim.eval('bufnr("%")');
                if (curr == bufnr && treeView.visible) {
                    await this.revealPosition(bufnr, treeView, position);
                }
            });
        }
    }
    has(bufnr) {
        return this.providersMap.has(bufnr);
    }
    /**
     * Hide outline of current tab.
     */
    async hide() {
        let winid = await this.nvim.call('coc#window#find', ['cocViewId', 'OUTLINE']);
        if (winid == -1)
            return;
        await this.nvim.call('coc#window#close', [winid]);
    }
    dispose() {
        for (let view of this.treeViewList) {
            view.dispose();
        }
        this.treeViewList = [];
        for (let provider of this.providersMap.values()) {
            provider.dispose();
        }
        this.providersMap.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = SymbolsOutline;
function getNodeByPosition(position, nodes) {
    let curr;
    let checkNodes = (nodes) => {
        for (let node of nodes) {
            if ((0, position_1.positionInRange)(position, node.range) == 0) {
                curr = node;
                if (Array.isArray(node.children)) {
                    checkNodes(node.children);
                }
                break;
            }
        }
    };
    checkNodes(nodes);
    return curr;
}
exports.getNodeByPosition = getNodeByPosition;
//# sourceMappingURL=outline.js.map