'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixChangeParams = exports.SEPARATOR = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const logger_1 = require("../../logger");
const highligher_1 = tslib_1.__importDefault(require("../../model/highligher"));
const util_1 = require("../../util");
const fs_1 = require("../../util/fs");
const lodash_1 = require("../../util/lodash");
const mutex_1 = require("../../util/mutex");
const node_1 = require("../../util/node");
const object_1 = require("../../util/object");
const position_1 = require("../../util/position");
const string_1 = require("../../util/string");
const textedit_1 = require("../../util/textedit");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const changes_1 = tslib_1.__importDefault(require("./changes"));
const logger = (0, logger_1.createLogger)('handler-refactorBuffer');
exports.SEPARATOR = '\u3000';
class RefactorBuffer {
    constructor(bufnr, srcId, nvim, config, opts) {
        this.bufnr = bufnr;
        this.srcId = srcId;
        this.nvim = nvim;
        this.config = config;
        this.opts = opts;
        this._disposed = false;
        this._fileItems = [];
        this.mutex = new mutex_1.Mutex();
        this.disposables = [];
        this.matchIds = new Set();
        this.changing = false;
        this.changes = new changes_1.default();
        this.disposables.push(workspace_1.default.registerLocalKeymap(bufnr, 'n', '<CR>', this.splitOpen.bind(this), true));
        if (config.showMenu) {
            this.disposables.push(workspace_1.default.registerLocalKeymap(bufnr, 'n', config.showMenu, this.showMenu.bind(this), true));
        }
        workspace_1.default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
    }
    async showMenu() {
        let res = await window_1.default.showMenuPicker(['Tab open', 'Remove block']);
        if (res == -1)
            return;
        let fileRange = await this.searchCurrentRange();
        if (!fileRange)
            return;
        if (res == 0) {
            let before = await this.nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
            let character = before.length;
            let bufname = this.getAbsolutePath(fileRange.filepath);
            this.nvim.call('coc#util#jump', ['tabe', bufname, [fileRange.line, character]], true);
        }
        if (res == 1) {
            let range = this.getDeleteRange(fileRange);
            await this.document.applyEdits([vscode_languageserver_types_1.TextEdit.del(range)]);
        }
    }
    get fileItems() {
        return this._fileItems;
    }
    getFileItem(uri) {
        let filepath = vscode_uri_1.URI.parse(uri).fsPath;
        return this._fileItems.find(o => (0, fs_1.sameFile)(o.filepath, filepath));
    }
    getFileRange(lnum) {
        for (let item of this._fileItems) {
            for (let r of item.ranges) {
                if (r.lnum == lnum) {
                    return Object.assign((0, lodash_1.omit)(r, ['highlights']), { filepath: item.filepath });
                }
            }
        }
        throw new Error(`File range not found at lnum: ${lnum}`);
    }
    onChange(e) {
        if (this.changing)
            return;
        if (e.contentChanges.length === 0) {
            this.highlightLineNr();
            this.nvim.redrawVim();
            return;
        }
        let { nvim } = this;
        e = fixChangeParams(e);
        let change = e.contentChanges[0];
        let { original } = e;
        if (change.range.end.line > 2) {
            nvim.call('setbufvar', [e.bufnr, '&modified', 1], true);
        }
        let { range, text } = change;
        let lineChange = (0, textedit_1.lineCountChange)(vscode_languageserver_types_1.TextEdit.replace(range, text));
        if (lineChange == 0)
            return;
        let edits = [vscode_languageserver_types_1.TextEdit.replace(range, text)];
        let addRanges = [];
        // Check removed ranges
        if (!(0, position_1.emptyRange)(range) && !text.includes('\u3000')) {
            let sl = range.start.line;
            let lnums = [];
            let lines = original.split(/\r?\n/);
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                if (line.length > 1 && line.includes('\u3000')) {
                    lnums.push(sl + i + 1);
                }
            }
            if (lnums.length) {
                let infos = lnums.map(lnum => {
                    return this.getFileRange(lnum);
                });
                for (let item of this._fileItems) {
                    item.ranges = item.ranges.filter(o => !lnums.includes(o.lnum));
                }
                this.changes.add(infos);
            }
        }
        else if ((0, position_1.emptyRange)(range) && text.includes('\u3000')) {
            // check undo
            let lines = text.split(/\r?\n/);
            let lnums = [];
            let sl = range.start.line;
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                if (line.length > 1 && line.includes('\u3000')) {
                    lnums.push(sl + i + 1);
                }
            }
            if (lnums.length) {
                let res = this.changes.checkInsert(lnums);
                if (res)
                    addRanges = res;
            }
        }
        else if (text.includes('\u3000')) {
            // check multiple ranges change
            edits = this.diffChanges(original, text);
            edits.forEach(e => {
                e.range = (0, position_1.adjustRangePosition)(e.range, range.start);
            });
        }
        this.adjustLnums(edits);
        nvim.pauseNotification();
        this.highlightLineNr();
        nvim.resumeNotification(true, true);
        if (addRanges.length) {
            addRanges.forEach(info => {
                let item = this._fileItems.find(o => o.filepath == info.filepath);
                item.ranges.push(info);
            });
        }
    }
    diffChanges(original, text) {
        let edits = [];
        let diffs = (0, node_1.fastDiff)(original, text);
        let offset = 0;
        let orig = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, original);
        for (let i = 0; i < diffs.length; i++) {
            let diff = diffs[i];
            let pos = orig.positionAt(offset);
            if (diff[0] == node_1.fastDiff.EQUAL) {
                offset = offset + diff[1].length;
            }
            else if (diff[0] == node_1.fastDiff.DELETE) {
                let end = orig.positionAt(offset + diff[1].length);
                if (diffs[i + 1] && diffs[i + 1][0] == node_1.fastDiff.INSERT) {
                    let text = diffs[i + 1][1];
                    edits.push(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(pos, end), text));
                    i = i + 1;
                }
                else {
                    edits.push(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(pos, end), ''));
                }
                offset = offset + diff[1].length;
            }
            else if (diff[0] == node_1.fastDiff.INSERT) {
                edits.push(vscode_languageserver_types_1.TextEdit.insert(pos, diff[1]));
            }
        }
        return edits;
    }
    /**
     * Handle changes of other buffers.
     */
    async onDocumentChange(e) {
        if (this.changing || e.contentChanges.length === 0)
            return;
        let { uri } = e.textDocument;
        let fileItem = this.getFileItem(uri);
        // not affected
        if (!fileItem)
            return;
        let { range, text } = e.contentChanges[0];
        let lineChange = (0, textedit_1.lineCountChange)(vscode_languageserver_types_1.TextEdit.replace(range, text));
        let edits = [];
        let deleteIndexes = [];
        // 4 cases: ignore, change lineNr, reload, remove
        for (let i = 0; i < fileItem.ranges.length; i++) {
            let r = fileItem.ranges[i];
            // change after range
            if (range.start.line >= r.start + r.lines.length)
                continue;
            // change before range
            if (range.end.line < r.start) {
                r.start = r.start + lineChange;
                continue;
            }
            let textDocument = workspace_1.default.getDocument(uri).textDocument;
            let end = r.start + r.lines.length + lineChange;
            let newLines = textDocument.lines.slice(r.start, end);
            if (!newLines.length) {
                deleteIndexes.push(i);
                let replaceRange = this.getDeleteRange(r);
                edits.push(vscode_languageserver_types_1.TextEdit.replace(replaceRange, ''));
            }
            else {
                r.lines = newLines;
                let replaceRange = this.getReplaceRange(r);
                edits.push(vscode_languageserver_types_1.TextEdit.replace(replaceRange, newLines.join('\n')));
            }
        }
        if (deleteIndexes.length) {
            fileItem.ranges = fileItem.ranges.filter((_, i) => !deleteIndexes.includes(i));
        }
        // clean fileItem with empty ranges
        this._fileItems = this._fileItems.filter(o => o.ranges && o.ranges.length > 0);
        if (edits.length) {
            this.adjustLnums(edits);
            this.changing = true;
            await this.document.applyEdits(edits);
            this.changing = false;
        }
        this.nvim.pauseNotification();
        this.highlightLineNr();
        this.buffer.setOption('modified', false, true);
        await this.nvim.resumeNotification(true);
    }
    adjustLnums(edits) {
        for (let item of this._fileItems) {
            for (let fileRange of item.ranges) {
                let line = fileRange.lnum - 1;
                fileRange.lnum += (0, textedit_1.getChangedLineCount)(vscode_languageserver_types_1.Position.create(line, 0), edits);
            }
        }
    }
    /**
     * Current changed file ranges
     */
    async getFileChanges() {
        let changes = [];
        let lines = await this.buffer.lines;
        lines.push(exports.SEPARATOR);
        // current lines
        let arr = [];
        let fsPath;
        let lnum;
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.startsWith(exports.SEPARATOR)) {
                if (fsPath) {
                    changes.push({
                        filepath: fsPath,
                        lines: arr.slice(),
                        lnum
                    });
                    fsPath = undefined;
                    arr = [];
                }
                if (line.length > 1) {
                    let ms = line.match(/^\u3000(.*)/);
                    if (ms) {
                        fsPath = this.getAbsolutePath(ms[1].replace(/\s+$/, ''));
                        lnum = i + 1;
                        arr = [];
                    }
                }
            }
            else {
                arr.push(line);
            }
        }
        return changes;
    }
    /**
     * Open line under cursor in split window
     */
    async splitOpen() {
        let { nvim } = this;
        let win = nvim.createWindow(this.opts.fromWinid);
        let valid = await win.valid;
        let before = await nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
        let character = before.length;
        let fileRange = await this.searchCurrentRange();
        if (fileRange) {
            let bufname = this.getAbsolutePath(fileRange.filepath);
            nvim.pauseNotification();
            if (valid) {
                nvim.call('win_gotoid', [this.opts.fromWinid], true);
                this.nvim.call('coc#util#jump', ['edit', bufname, [fileRange.line, character]], true);
            }
            else {
                this.nvim.call('coc#util#jump', ['belowright vs', bufname, [fileRange.line, character]], true);
            }
            nvim.command('normal! zz', true);
            await nvim.resumeNotification(true);
            if (!valid) {
                this.opts.fromWinid = await nvim.call('win_getid');
            }
        }
    }
    async searchCurrentRange() {
        let { nvim } = this;
        let lines = await nvim.eval('getline(1,line("."))');
        let len = lines.length;
        for (let i = 0; i < len; i++) {
            let line = lines[len - i - 1];
            let ms = line.match(/^\u3000(.+)/);
            if (ms) {
                let r = this.getFileRange(len - i);
                return Object.assign({ line: r.start + (i == 0 ? 1 : i) - 1 }, r);
            }
        }
        return undefined;
    }
    /**
     * Add FileItem to refactor buffer.
     */
    async addFileItems(items) {
        if (this._disposed)
            return;
        let { cwd } = this.opts;
        let { document } = this;
        const release = await this.mutex.acquire();
        try {
            await document.synchronize();
            let count = document.lineCount;
            let highligher = new highligher_1.default();
            let hlRanges = [];
            for (let item of items) {
                let ranges = [];
                for (let range of item.ranges) {
                    highligher.addLine(exports.SEPARATOR);
                    highligher.addLine(exports.SEPARATOR);
                    let lnum = count + highligher.length;
                    highligher.addText(`${(0, fs_1.isParentFolder)(cwd, item.filepath) ? node_1.path.relative(cwd, item.filepath) : item.filepath}`);
                    // white spaces for conceal texts
                    let n = String(range.start + 1).length + String(range.end).length + 4;
                    if (!this.srcId)
                        highligher.addText(' '.repeat(n));
                    let base = 0 - highligher.length - count;
                    if (range.highlights) {
                        hlRanges.push(...range.highlights.map(r => adjustRange(r, base)));
                    }
                    let { lines, start, end, highlights } = range;
                    if (!lines) {
                        lines = await this.getLines(item.filepath, start, end);
                    }
                    ranges.push({ lines, lnum, start, highlights });
                    highligher.addLines(lines);
                }
                if (ranges.length) {
                    let newItem = { filepath: item.filepath, ranges };
                    let fileItem = this._fileItems.find(o => o.filepath == item.filepath);
                    if (fileItem) {
                        fileItem.ranges.push(...newItem.ranges);
                    }
                    else {
                        this._fileItems.push(newItem);
                    }
                }
            }
            let { nvim, buffer } = this;
            this.changing = true;
            nvim.pauseNotification();
            highligher.render(buffer, count);
            this.highlightLineNr();
            buffer.setOption('modified', false, true);
            buffer.setOption('undolevels', 1000, true);
            if (count == 2 && hlRanges.length) {
                let pos = hlRanges[0].start;
                nvim.call('coc#cursor#move_to', [pos.line, pos.character], true);
            }
            await nvim.resumeNotification(true);
            await document.patchChange();
            this.changing = false;
            await window_1.default.cursors.addRanges(hlRanges);
        }
        catch (e) {
            this.changing = false;
            logger.error(`Error on add file item:`, e);
        }
        release();
    }
    findRange(filepath, lnum) {
        let item = this.fileItems.find(o => (0, fs_1.sameFile)(this.getAbsolutePath(o.filepath), filepath));
        let range = item.ranges.find(o => o.lnum == lnum);
        if (!range)
            throw new Error(`File range not found at lnum: ${lnum}`);
        return range;
    }
    /**
     * Save changes to buffers/files, return false when no change made.
     */
    async save() {
        let { nvim } = this;
        let doc = this.document;
        let { buffer } = doc;
        await doc.patchChange();
        let changes = await this.getFileChanges();
        if (!changes)
            return;
        changes.sort((a, b) => a.lnum - b.lnum);
        // filter changes that not change
        let fileChanges = [];
        for (let i = 0; i < changes.length; i++) {
            let change = changes[i];
            let range = this.findRange(change.filepath, change.lnum);
            if ((0, object_1.equals)(range.lines, change.lines))
                continue;
            fileChanges.push(Object.assign({ start: range.start, end: range.start + range.lines.length }, change));
            range.lines = change.lines;
        }
        if (fileChanges.length == 0) {
            await window_1.default.showInformationMessage('No change.');
            await buffer.setOption('modified', false);
            return false;
        }
        let changeMap = {};
        for (let change of fileChanges) {
            let uri = vscode_uri_1.URI.file(change.filepath).toString();
            let edits = changeMap[uri] || [];
            edits.push({
                range: vscode_languageserver_types_1.Range.create(change.start, 0, change.end, 0),
                newText: change.lines.join('\n') + '\n'
            });
            changeMap[uri] = edits;
        }
        this.changing = true;
        await workspace_1.default.applyEdit({ changes: changeMap });
        this.changing = false;
        for (let item of this.fileItems) {
            let uri = vscode_uri_1.URI.file(this.getAbsolutePath(item.filepath)).toString();
            let edits = changeMap[uri];
            if (edits && edits.length > 0) {
                item.ranges.forEach(r => {
                    r.start += (0, textedit_1.getChangedLineCount)(vscode_languageserver_types_1.Position.create(r.start, 0), edits);
                });
            }
        }
        nvim.pauseNotification();
        buffer.setOption('modified', false, true);
        if (this.config.saveToFile) {
            nvim.command('silent noa wa', true);
        }
        this.highlightLineNr();
        await nvim.resumeNotification();
        return true;
    }
    async getLines(fsPath, start, end) {
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        let doc = workspace_1.default.getDocument(uri);
        if (doc)
            return doc.getLines(start, end);
        return await (0, fs_1.readFileLines)(fsPath, start, end - 1);
    }
    getAbsolutePath(filepath) {
        if (node_1.path.isAbsolute(filepath))
            return filepath;
        return node_1.path.join(this.opts.cwd, filepath);
    }
    /**
     * Use conceal/virtual text to add lineNr
     */
    highlightLineNr() {
        let { fileItems, nvim, srcId, bufnr } = this;
        let { winid, cwd } = this.opts;
        let info = {};
        if (srcId) {
            nvim.call('nvim_buf_clear_namespace', [bufnr, srcId, 0, -1], true);
            for (let item of fileItems) {
                for (let range of item.ranges) {
                    let end = range.start + range.lines.length;
                    let text = `${range.start + 1}:${end}`;
                    info[range.lnum] = [range.start + 1, end];
                    nvim.call('nvim_buf_set_virtual_text', [bufnr, srcId, range.lnum - 1, [[text, 'LineNr']], {}], true);
                }
            }
        }
        else {
            if (this.matchIds.size) {
                nvim.call('coc#highlight#clear_matches', [winid, Array.from(this.matchIds)], true);
                this.matchIds.clear();
            }
            let id = 2000;
            for (let item of fileItems) {
                let filename = `${cwd ? node_1.path.relative(cwd, item.filepath) : item.filepath}`;
                let col = (0, string_1.byteLength)(filename) + 1;
                for (let range of item.ranges) {
                    let end = range.start + range.lines.length;
                    let text = `:${range.start + 1}:${end}`;
                    for (let i = 0; i < text.length; i++) {
                        let ch = text[i];
                        this.matchIds.add(id);
                        info[range.lnum] = [range.start + 1, end];
                        nvim.call('matchaddpos', ['Conceal', [[range.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);
                        id++;
                    }
                }
            }
        }
        this.buffer.setVar('line_infos', info, true);
    }
    getDeleteRange(r) {
        let { document } = this;
        let start = r.lnum - 1;
        let end;
        let total = document.lineCount;
        for (let i = start; i < total; i++) {
            if (i + 1 == total) {
                end = vscode_languageserver_types_1.Position.create(total, 0);
                break;
            }
            let line = document.getline(i);
            if (line === exports.SEPARATOR) {
                end = vscode_languageserver_types_1.Position.create(i + 1, 0);
                break;
            }
            if (i != start && line.startsWith(exports.SEPARATOR)) {
                end = vscode_languageserver_types_1.Position.create(i, 0);
                break;
            }
        }
        return vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(start, 0), end);
    }
    getReplaceRange(r) {
        let { document } = this;
        let start = r.lnum;
        let end;
        let total = document.lineCount;
        for (let i = start; i < total; i++) {
            let line = document.getline(i);
            if (i + 1 == total) {
                end = vscode_languageserver_types_1.Position.create(i, line.length);
                break;
            }
            let next = document.getline(i + 1);
            if (next.startsWith('\u3000')) {
                end = vscode_languageserver_types_1.Position.create(i, line.length);
                break;
            }
        }
        return vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(start, 0), end);
    }
    get valid() {
        return this.buffer.valid;
    }
    get buffer() {
        return this.nvim.createBuffer(this.bufnr);
    }
    get document() {
        return workspace_1.default.getDocument(this.bufnr);
    }
    dispose() {
        this._disposed = true;
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = RefactorBuffer;
function adjustRange(range, offset) {
    let { start, end } = range;
    return vscode_languageserver_types_1.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function fixChangeParams(e) {
    let { contentChanges, bufnr, textDocument, original, originalLines } = e;
    let { range, text } = contentChanges[0];
    let changes = [{ range, text }];
    if (!original) {
        if ((0, position_1.emptyRange)(range) && range.start.character != 0) {
            let lines = text.split(/\r?\n/);
            let last = lines[lines.length - 1];
            let before = originalLines[range.start.line].slice(0, range.start.character);
            if (last.startsWith(exports.SEPARATOR) && before == last) {
                changes[0].text = before + lines.slice(0, -1).join('\n') + '\n';
                let { start, end } = range;
                changes[0].range = vscode_languageserver_types_1.Range.create(start.line, 0, end.line, 0);
            }
        }
    }
    else {
        let lines = original.split(/\r?\n/);
        let last = lines[lines.length - 1];
        if (last.startsWith(exports.SEPARATOR)) {
            let before = originalLines[range.start.line].slice(0, range.start.character);
            if (before == last) {
                original = before + lines.slice(0, -1).join('\n') + '\n';
                let { start, end } = range;
                changes[0].range = vscode_languageserver_types_1.Range.create(start.line, 0, end.line, 0);
            }
        }
        let prev = originalLines[range.start.line - 1];
        let nest = lines.length > 1 ? lines[lines.length - 2] : '';
        if (last == '' &&
            nest.startsWith(exports.SEPARATOR) &&
            prev == nest &&
            range.start.character == 0 && range.end.character == 0) {
            original = prev + '\n' + lines.slice(0, -2).join('\n') + '\n';
            let { start, end } = range;
            changes[0].range = vscode_languageserver_types_1.Range.create(start.line - 1, 0, end.line - 1, 0);
        }
    }
    return { contentChanges: changes, bufnr, textDocument, original, originalLines };
}
exports.fixChangeParams = fixChangeParams;
//# sourceMappingURL=buffer.js.map