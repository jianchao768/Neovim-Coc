"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bser_1 = tslib_1.__importDefault(require("bser"));
const net_1 = tslib_1.__importDefault(require("net"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const index_1 = tslib_1.__importDefault(require("../../configuration/index"));
const fileSystemWatcher_1 = require("../../core/fileSystemWatcher");
const watchman_1 = tslib_1.__importStar(require("../../core/watchman"));
const workspaceFolder_1 = tslib_1.__importDefault(require("../../core/workspaceFolder"));
const relativePattern_1 = tslib_1.__importDefault(require("../../model/relativePattern"));
const util_1 = require("../../util");
const fs_1 = require("../../util/fs");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let server;
let client;
const cwd = process.cwd();
const sockPath = path_1.default.join(os_1.default.tmpdir(), `watchman-fake-${(0, uuid_1.v4)()}`);
process.env.WATCHMAN_SOCK = sockPath;
let workspaceFolder;
let watcherManager;
let configurations;
let disposables = [];
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(undefined);
        }, ms);
    });
}
function createFileChange(file, isNew = true, exists = true) {
    return {
        size: 1,
        name: file,
        exists,
        new: isNew,
        type: 'f',
        mtime_ms: Date.now()
    };
}
function sendResponse(data) {
    client.write(bser_1.default.dumpToBuffer(data));
}
function sendSubscription(uid, root, files) {
    client.write(bser_1.default.dumpToBuffer({
        subscription: uid,
        root,
        files
    }));
}
let capabilities;
let watchResponse;
beforeAll(async () => {
    await helper_1.default.setup();
});
beforeAll(done => {
    let userConfigFile = path_1.default.join(process.env.COC_VIMCONFIG, 'coc-settings.json');
    configurations = new index_1.default(userConfigFile, undefined);
    workspaceFolder = new workspaceFolder_1.default(configurations);
    watcherManager = new fileSystemWatcher_1.FileSystemWatcherManager(workspaceFolder, 'watchman');
    Object.assign(watcherManager, { disabled: false });
    watcherManager.attach(helper_1.default.createNullChannel());
    // create a mock sever for watchman
    server = net_1.default.createServer(c => {
        client = c;
        c.on('data', data => {
            let obj = bser_1.default.loadFromBuffer(data);
            if (obj[0] == 'watch-project') {
                sendResponse(watchResponse || { watch: obj[1], warning: 'warning' });
            }
            else if (obj[0] == 'unsubscribe') {
                sendResponse({ path: obj[1] });
            }
            else if (obj[0] == 'clock') {
                sendResponse({ clock: 'clock' });
            }
            else if (obj[0] == 'version') {
                let { optional, required } = obj[1];
                let res = {};
                for (let key of optional) {
                    res[key] = true;
                }
                for (let key of required) {
                    res[key] = true;
                }
                sendResponse({ capabilities: capabilities || res });
            }
            else if (obj[0] == 'subscribe') {
                sendResponse({ subscribe: obj[2] });
            }
            else {
                sendResponse({});
            }
        });
    });
    server.on('error', err => {
        throw err;
    });
    server.listen(sockPath, () => {
        done();
    });
    server.unref();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    capabilities = undefined;
    watchResponse = undefined;
});
afterAll(async () => {
    await helper_1.default.shutdown();
    watcherManager.dispose();
    server.close();
    await (0, fs_1.remove)(sockPath);
});
describe('watchman', () => {
    it('should throw error when not watching', async () => {
        let client = new watchman_1.default(null);
        disposables.push(client);
        let fn = async () => {
            await client.subscribe('**/*', () => { });
        };
        await expect(fn()).rejects.toThrow(/not watching/);
    });
    it('should checkCapability', async () => {
        let client = new watchman_1.default(null);
        let res = await client.checkCapability();
        expect(res).toBe(true);
        capabilities = { relative_root: false };
        res = await client.checkCapability();
        expect(res).toBe(false);
        client.dispose();
    });
    it('should watchProject', async () => {
        let client = new watchman_1.default(null);
        disposables.push(client);
        let res = await client.watchProject(__dirname);
        expect(res).toBe(true);
        client.dispose();
    });
    it('should unsubscribe', async () => {
        let client = new watchman_1.default(null);
        disposables.push(client);
        await client.watchProject(cwd);
        let fn = jest.fn();
        let disposable = await client.subscribe(`${cwd}/*`, fn);
        disposable.dispose();
        client.dispose();
    });
});
describe('Watchman#subscribe', () => {
    it('should subscribe file change', async () => {
        let client = new watchman_1.default(null, helper_1.default.createNullChannel());
        disposables.push(client);
        await client.watchProject(cwd);
        let fn = jest.fn();
        let disposable = await client.subscribe(`${cwd}/*`, fn);
        let changes = [createFileChange(`${cwd}/a`)];
        sendSubscription(disposable.subscribe, cwd, changes);
        await wait(30);
        expect(fn).toBeCalled();
        let call = fn.mock.calls[0][0];
        disposable.dispose();
        expect(call.root).toBe(cwd);
        client.dispose();
    });
    it('should subscribe with relative_path', async () => {
        let client = new watchman_1.default(null, helper_1.default.createNullChannel());
        watchResponse = { watch: cwd, relative_path: 'foo' };
        await client.watchProject(cwd);
        let fn = jest.fn();
        let disposable = await client.subscribe(`${cwd}/*`, fn);
        let changes = [createFileChange(`${cwd}/a`)];
        sendSubscription(disposable.subscribe, cwd, changes);
        await wait(30);
        expect(fn).toBeCalled();
        let call = fn.mock.calls[0][0];
        disposable.dispose();
        expect(call.root).toBe(path_1.default.join(cwd, 'foo'));
        client.dispose();
    });
    it('should not subscribe invalid response', async () => {
        let c = new watchman_1.default(null, helper_1.default.createNullChannel());
        disposables.push(c);
        watchResponse = { watch: cwd, relative_path: 'foo' };
        await c.watchProject(cwd);
        let fn = jest.fn();
        let disposable = await c.subscribe(`${cwd}/*`, fn);
        let changes = [createFileChange(`${cwd}/a`)];
        sendSubscription('uuid', cwd, changes);
        await wait(10);
        sendSubscription(disposable.subscribe, cwd, []);
        await wait(10);
        client.write(bser_1.default.dumpToBuffer({
            subscription: disposable.subscribe,
            root: cwd
        }));
        await wait(10);
        expect(fn).toBeCalledTimes(0);
    });
});
describe('Watchman#createClient', () => {
    it('should not create client when capabilities not match', async () => {
        capabilities = { relative_root: false };
        await expect(async () => {
            await watchman_1.default.createClient(null, cwd);
        }).rejects.toThrow(Error);
    });
    it('should not create when watch failed', async () => {
        watchResponse = {};
        await expect(async () => {
            await watchman_1.default.createClient(null, cwd);
        }).rejects.toThrow(Error);
    });
    it('should create client', async () => {
        let client = await watchman_1.default.createClient(null, cwd);
        disposables.push(client);
        expect(client).toBeDefined();
    });
    it('should not create client for root', async () => {
        await expect(async () => {
            await watchman_1.default.createClient(null, '/');
        }).rejects.toThrow(Error);
    });
});
describe('isValidWatchRoot()', () => {
    it('should check valid root', async () => {
        expect((0, watchman_1.isValidWatchRoot)('/')).toBe(false);
        expect((0, watchman_1.isValidWatchRoot)(os_1.default.homedir())).toBe(false);
        expect((0, watchman_1.isValidWatchRoot)('/tmp/a/b/c')).toBe(false);
        expect((0, watchman_1.isValidWatchRoot)(os_1.default.tmpdir())).toBe(false);
    });
});
describe('fileSystemWatcher', () => {
    function createWatcher(pattern, ignoreCreateEvents = false, ignoreChangeEvents = false, ignoreDeleteEvents = false) {
        let watcher = watcherManager.createFileSystemWatcher(pattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        disposables.push(watcher);
        return watcher;
    }
    function waitReady(watcher) {
        return new Promise(resolve => {
            watcher.onDidListen(() => {
                resolve();
            });
        });
    }
    beforeAll(async () => {
        workspaceFolder.addWorkspaceFolder(cwd, true);
        await watcherManager.waitClient(cwd);
    });
    it('should use relative pattern #1', async () => {
        let folder = workspaceFolder.workspaceFolders[0];
        expect(folder).toBeDefined();
        let pattern = new relativePattern_1.default(folder, '**/*');
        let watcher = createWatcher(pattern, false, true, true);
        let fn = jest.fn();
        watcher.onDidCreate(fn);
        await waitReady(watcher);
        let changes = [createFileChange(`a`)];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.wait(50);
        expect(fn).toBeCalled();
    });
    it('should use relative pattern #2', async () => {
        let called = false;
        let pattern = new relativePattern_1.default(__dirname, '**/*');
        let watcher = createWatcher(pattern, false, true, true);
        await waitReady(watcher);
        watcher.onDidCreate(() => {
            called = true;
        });
        let changes = [createFileChange(`a`)];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.wait(50);
        expect(called).toBe(false);
    });
    it('should use relative pattern #3', async () => {
        let called = false;
        let root = path_1.default.join(os_1.default.tmpdir(), 'not_exists');
        let pattern = new relativePattern_1.default(root, '**/*');
        let watcher = createWatcher(pattern, false, true, true);
        watcher.onDidCreate(() => {
            called = true;
        });
        await helper_1.default.wait(10);
        let changes = [createFileChange(`a`)];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.wait(10);
        expect(called).toBe(false);
    });
    it('should watch for file create', async () => {
        let watcher = createWatcher('**/*', false, true, true);
        await waitReady(watcher);
        let called = false;
        watcher.onDidCreate(() => {
            called = true;
        });
        let changes = [createFileChange(`a`)];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
    it('should watch for file delete', async () => {
        let watcher = createWatcher('**/*', true, true, false);
        await waitReady(watcher);
        let called = false;
        watcher.onDidDelete(() => {
            called = true;
        });
        let changes = [createFileChange(`a`, false, false)];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
    it('should watch for file change', async () => {
        let watcher = createWatcher('**/*', false, false, false);
        await waitReady(watcher);
        let called = false;
        watcher.onDidChange(() => {
            called = true;
        });
        let changes = [createFileChange(`a`, false, true)];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
    it('should watch for file rename', async () => {
        let watcher = createWatcher('**/*', false, false, false);
        await waitReady(watcher);
        let called = false;
        watcher.onDidRename(() => {
            called = true;
        });
        await helper_1.default.wait(50);
        let changes = [
            createFileChange(`a`, false, false),
            createFileChange(`b`, true, true),
        ];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
    it('should not watch for events', async () => {
        let watcher = createWatcher('**/*', true, true, true);
        await waitReady(watcher);
        let called = false;
        let onChange = () => { called = true; };
        watcher.onDidCreate(onChange);
        watcher.onDidChange(onChange);
        watcher.onDidDelete(onChange);
        let changes = [
            createFileChange(`a`, false, false),
            createFileChange(`b`, true, true),
            createFileChange(`c`, false, true),
        ];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.wait(10);
        expect(called).toBe(false);
    });
    it('should watch for folder rename', async () => {
        let watcher = createWatcher('**/*');
        await waitReady(watcher);
        let newFiles = [];
        let count = 0;
        watcher.onDidRename(e => {
            count++;
            newFiles.push(e.newUri.fsPath);
        });
        let changes = [
            createFileChange(`a/1`, false, false),
            createFileChange(`a/2`, false, false),
            createFileChange(`b/1`, true, true),
            createFileChange(`b/2`, true, true),
        ];
        sendSubscription(watcher.subscribe, cwd, changes);
        await helper_1.default.waitValue(() => {
            return count;
        }, 2);
    });
    it('should watch for new folder', async () => {
        let watcher = createWatcher('**/*');
        expect(watcher).toBeDefined();
        workspaceFolder.renameWorkspaceFolder(cwd, __dirname);
        let uri;
        watcher.onDidCreate(e => {
            uri = e;
        });
        await helper_1.default.wait(50);
        let changes = [createFileChange(`a`)];
        sendSubscription(watcher.subscribe, __dirname, changes);
        await helper_1.default.waitValue(() => {
            return uri === null || uri === void 0 ? void 0 : uri.fsPath;
        }, path_1.default.join(__dirname, 'a'));
    });
});
describe('create FileSystemWatcherManager', () => {
    it('should attach to existing workspace folder', async () => {
        let workspaceFolder = new workspaceFolder_1.default(configurations);
        workspaceFolder.addWorkspaceFolder(cwd, false);
        let watcherManager = new fileSystemWatcher_1.FileSystemWatcherManager(workspaceFolder, '');
        Object.assign(watcherManager, { disabled: false });
        watcherManager.attach(helper_1.default.createNullChannel());
        await watcherManager.createClient(os_1.default.tmpdir());
        await watcherManager.createClient(cwd);
        await watcherManager.waitClient(cwd);
        watcherManager.dispose();
    });
    it('should get watchman path', async () => {
        let watcherManager = new fileSystemWatcher_1.FileSystemWatcherManager(workspaceFolder, 'invalid_command');
        process.env.WATCHMAN_SOCK = '';
        await expect(async () => {
            await watcherManager.getWatchmanPath();
        }).rejects.toThrow(Error);
        process.env.WATCHMAN_SOCK = sockPath;
    });
});
//# sourceMappingURL=fileSystemWatcher.test.js.map