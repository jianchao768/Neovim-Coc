'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const util_1 = require("../util");
const is_1 = require("../util/is");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const debounceTime = (0, util_1.getConditionValue)(100, 10);
class Signature {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        this.signatureFactory = window_1.default.createFloatFactory(Object.assign({
            preferTop: this.config.preferAbove,
            autoHide: false,
            modes: ['i', 'ic', 's'],
        }, this.config.floatConfig));
        this.disposables.push(this.signatureFactory);
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_1.default.on('CursorMovedI', (0, node_1.debounce)(this.checkCurosr.bind(this), debounceTime), null, this.disposables);
        events_1.default.on(['InsertLeave', 'BufEnter'], () => {
            var _a;
            (_a = this.tokenSource) === null || _a === void 0 ? void 0 : _a.cancel();
        }, null, this.disposables);
        events_1.default.on('TextChangedI', () => {
            if (this.config.hideOnChange) {
                this.signatureFactory.close();
            }
        }, null, this.disposables);
        events_1.default.on('TextInsert', async (bufnr, info, character) => {
            if (!this.config.enableTrigger)
                return;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc || !doc.attached || !languages_1.default.shouldTriggerSignatureHelp(doc.textDocument, character))
                return;
            await this._triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);
        }, null, this.disposables);
        window_1.default.onDidChangeActiveTextEditor(() => {
            this.loadConfiguration();
        }, null, this.disposables);
    }
    checkCurosr(bufnr, cursor) {
        let pos = this.lastPosition;
        let floatFactory = this.signatureFactory;
        if (!pos || bufnr !== pos.bufnr || floatFactory.window == null)
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || cursor[0] != pos.lnum || cursor[1] < pos.col) {
            floatFactory.close();
            return;
        }
        let line = doc.getline(pos.lnum - 1);
        let text = (0, string_1.byteSlice)(line, pos.col - 1, cursor[1] - 1);
        if (text.endsWith(')'))
            return floatFactory.close();
    }
    loadConfiguration(e) {
        var _a;
        if (!e || e.affectsConfiguration('signature')) {
            let doc = (_a = window_1.default.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document;
            let config = workspace_1.default.getConfiguration('signature', doc);
            this.config = {
                target: config.get('target', 'float'),
                floatConfig: config.get('floatConfig', {}),
                enableTrigger: config.get('enable', true),
                wait: Math.max(config.get('triggerSignatureWait', 500), 200),
                preferAbove: config.get('preferShownAbove', true),
                hideOnChange: config.get('hideOnTextChange', false),
            };
        }
    }
    async triggerSignatureHelp() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_1.default.hasProvider(languages_1.ProviderName.Signature, doc.textDocument))
            return false;
        return await this._triggerSignatureHelp(doc, position, true, 0);
    }
    async _triggerSignatureHelp(doc, position, invoke = true, offset = 0) {
        var _a;
        (_a = this.tokenSource) === null || _a === void 0 ? void 0 : _a.cancel();
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        token.onCancellationRequested(() => {
            tokenSource.dispose();
            this.tokenSource = undefined;
        });
        let { target } = this.config;
        let timer = this.timer = setTimeout(() => {
            tokenSource.cancel();
        }, this.config.wait);
        await doc.patchChange(true);
        let signatureHelp = await languages_1.default.getSignatureHelp(doc.textDocument, position, token, {
            isRetrigger: this.signatureFactory.checkRetrigger(doc.bufnr),
            triggerKind: invoke ? protocol_1.SignatureHelpTriggerKind.Invoked : protocol_1.SignatureHelpTriggerKind.TriggerCharacter
        });
        clearTimeout(timer);
        if (token.isCancellationRequested)
            return false;
        if (!signatureHelp || signatureHelp.signatures.length == 0) {
            this.signatureFactory.close();
            return false;
        }
        let { activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
            // make active first
            let [active] = signatures.splice(activeSignature, 1);
            if (active)
                signatures.unshift(active);
        }
        if (target == 'echo') {
            this.echoSignature(signatureHelp);
        }
        else {
            await this.showSignatureHelp(doc, position, signatureHelp, offset);
        }
        return true;
    }
    async showSignatureHelp(doc, position, signatureHelp, offset) {
        let { signatures, activeParameter } = signatureHelp;
        activeParameter = typeof activeParameter === 'number' ? activeParameter : undefined;
        let paramDoc = null;
        let startOffset = offset;
        let docs = signatures.reduce((p, c, idx) => {
            var _a, _b, _c;
            let activeIndexes = null;
            let activeIndex = (_a = c.activeParameter) !== null && _a !== void 0 ? _a : activeParameter;
            if (activeIndex === undefined && ((_b = c.parameters) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                activeIndex = 0;
            }
            let nameIndex = c.label.indexOf('(');
            if (idx == 0 && typeof activeIndex === 'number') {
                let active = (_c = c.parameters) === null || _c === void 0 ? void 0 : _c[activeIndex];
                if (active) {
                    let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
                    paramDoc = active.documentation;
                    if (typeof active.label === 'string') {
                        let str = after.slice(0);
                        let ms = str.match(new RegExp('\\b' + active.label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b'));
                        let index = ms ? ms.index : str.indexOf(active.label);
                        if (index != -1) {
                            activeIndexes = [
                                index + nameIndex,
                                index + active.label.length + nameIndex
                            ];
                        }
                    }
                    else {
                        activeIndexes = active.label;
                    }
                }
            }
            if (activeIndexes == null) {
                activeIndexes = [nameIndex + 1, nameIndex + 1];
            }
            if (offset == startOffset) {
                offset = offset + activeIndexes[0] + 1;
            }
            p.push({
                content: c.label,
                filetype: doc.filetype,
                active: activeIndexes
            });
            if (paramDoc) {
                let content = typeof paramDoc === 'string' ? paramDoc : paramDoc.value;
                if (content.trim().length) {
                    p.push({
                        content,
                        filetype: (0, is_1.isMarkdown)(c.documentation) ? 'markdown' : 'txt'
                    });
                }
            }
            if (idx == 0 && c.documentation) {
                let { documentation } = c;
                let content = typeof documentation === 'string' ? documentation : documentation.value;
                if (content.trim().length) {
                    p.push({
                        content,
                        filetype: (0, is_1.isMarkdown)(c.documentation) ? 'markdown' : 'txt'
                    });
                }
            }
            return p;
        }, []);
        let content = doc.getline(position.line, false).slice(0, position.character);
        this.lastPosition = { bufnr: doc.bufnr, lnum: position.line + 1, col: (0, string_1.byteLength)(content) + 1 };
        await this.signatureFactory.show(docs, { offsetX: offset });
    }
    echoSignature(signatureHelp) {
        var _a;
        let { signatures, activeParameter } = signatureHelp;
        let columns = workspace_1.default.env.columns;
        signatures = signatures.slice(0, workspace_1.default.env.cmdheight);
        let signatureList = [];
        for (let signature of signatures) {
            let parts = [];
            let { label } = signature;
            label = label.replace(/\n/g, ' ');
            if (label.length >= columns - 16) {
                label = label.slice(0, columns - 16) + '...';
            }
            let nameIndex = label.indexOf('(');
            if (nameIndex == -1) {
                parts = [{ text: label, type: 'Normal' }];
            }
            else {
                parts.push({
                    text: label.slice(0, nameIndex),
                    type: 'Label'
                });
                let after = label.slice(nameIndex);
                if (signatureList.length == 0 && activeParameter != null) {
                    let active = (_a = signature.parameters) === null || _a === void 0 ? void 0 : _a[activeParameter];
                    if (active) {
                        let start;
                        let end;
                        if (typeof active.label === 'string') {
                            let str = after.slice(0);
                            let ms = str.match(new RegExp('\\b' + active.label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b'));
                            let idx = ms ? ms.index : str.indexOf(active.label);
                            if (idx == -1) {
                                parts.push({ text: after, type: 'Normal' });
                            }
                            else {
                                start = idx;
                                end = idx + active.label.length;
                            }
                        }
                        else {
                            [start, end] = active.label;
                            start = start - nameIndex;
                            end = end - nameIndex;
                        }
                        if (start != null && end != null) {
                            parts.push({ text: after.slice(0, start), type: 'Normal' });
                            parts.push({ text: after.slice(start, end), type: 'MoreMsg' });
                            parts.push({ text: after.slice(end), type: 'Normal' });
                        }
                    }
                }
                else {
                    parts.push({
                        text: after,
                        type: 'Normal'
                    });
                }
            }
            signatureList.push(parts);
        }
        this.nvim.callTimer('coc#ui#echo_signatures', [signatureList], true);
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
        if (this.timer) {
            clearTimeout(this.timer);
        }
    }
}
exports.default = Signature;
//# sourceMappingURL=signature.js.map