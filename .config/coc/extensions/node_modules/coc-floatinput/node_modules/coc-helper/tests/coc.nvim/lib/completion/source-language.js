'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixIndent = exports.getUltisnipOption = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const ui_1 = require("../core/ui");
const logger_1 = require("../logger");
const manager_1 = tslib_1.__importDefault(require("../snippets/manager"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const errors_1 = require("../util/errors");
const Is = tslib_1.__importStar(require("../util/is"));
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const types_1 = require("./types");
const util_2 = require("./util");
const logger = (0, logger_1.createLogger)('source-language');
class LanguageSource {
    constructor(name, shortcut, provider, documentSelector, triggerCharacters, allCommitCharacters, priority) {
        this.name = name;
        this.shortcut = shortcut;
        this.provider = provider;
        this.documentSelector = documentSelector;
        this.triggerCharacters = triggerCharacters;
        this.allCommitCharacters = allCommitCharacters;
        this.priority = priority;
        this.sourceType = types_1.SourceType.Service;
        this._enabled = true;
        this.itemDefaults = {};
        // Keeped Promise for resolve
        this.resolving = new WeakMap();
    }
    get enable() {
        return this._enabled;
    }
    toggle() {
        this._enabled = !this._enabled;
    }
    shouldCommit(item, character) {
        var _a;
        if (this.allCommitCharacters.includes(character))
            return true;
        let commitCharacters = (0, array_1.toArray)((_a = item.commitCharacters) !== null && _a !== void 0 ? _a : this.itemDefaults.commitCharacters);
        return commitCharacters.includes(character);
    }
    async doComplete(option, token) {
        let { triggerCharacter, bufnr, position } = option;
        let triggerKind = this.getTriggerKind(option);
        this.triggerContext = { lnum: position.line, character: position.character, line: option.line };
        let context = { triggerKind, option };
        if (triggerKind == protocol_1.CompletionTriggerKind.TriggerCharacter)
            context.triggerCharacter = triggerCharacter;
        let textDocument = workspace_1.default.getDocument(bufnr).textDocument;
        await (0, util_1.waitImmediate)();
        let result = await Promise.resolve(this.provider.provideCompletionItems(textDocument, position, token, context));
        if (!result || token.isCancellationRequested)
            return null;
        let completeItems = Array.isArray(result) ? result : result.items;
        if (!completeItems || completeItems.length == 0)
            return null;
        let itemDefaults = this.itemDefaults = (0, object_1.toObject)(result['itemDefaults']);
        let isIncomplete = Is.isCompletionList(result) ? result.isIncomplete === true : false;
        return { isIncomplete, items: completeItems, itemDefaults };
    }
    onCompleteResolve(item, _opt, token) {
        let hasResolve = Is.func(this.provider.resolveCompletionItem);
        if (!hasResolve)
            return;
        let promise = this.resolving.get(item);
        if (promise)
            return promise;
        let invalid = false;
        promise = new Promise(async (resolve, reject) => {
            let disposable = token.onCancellationRequested(() => {
                this.resolving.delete(item);
                reject(new errors_1.CancellationError());
            });
            try {
                let resolved = await Promise.resolve(this.provider.resolveCompletionItem(item, token));
                disposable.dispose();
                if (!token.isCancellationRequested) {
                    if (!resolved) {
                        invalid = true;
                        this.resolving.delete(item);
                    }
                    else {
                        // addDocumentation(item, completeItem, opt.filetype)
                        Object.assign(item, resolved);
                    }
                }
                resolve();
            }
            catch (e) {
                invalid = true;
                this.resolving.delete(item);
                reject(e);
            }
        });
        if (!invalid) {
            this.resolving.set(item, promise);
        }
        return promise;
    }
    async onCompleteDone(item, opt) {
        let doc = workspace_1.default.getDocument(opt.bufnr);
        await doc.patchChange(true);
        let additionalEdits = !(0, array_1.isFalsyOrEmpty)(item.additionalTextEdits);
        if (additionalEdits) {
            let shouldCancel = await manager_1.default.editsInsideSnippet(item.additionalTextEdits);
            if (shouldCancel)
                manager_1.default.cancel();
        }
        let version = doc.version;
        let isSnippet = await this.applyTextEdit(doc, additionalEdits, item, opt);
        if (additionalEdits) {
            // move cursor after edit
            await doc.applyEdits(item.additionalTextEdits, doc.version != version, !isSnippet);
            if (isSnippet)
                await manager_1.default.selectCurrentPlaceholder();
        }
        if (item.command) {
            if (commands_1.default.has(item.command.command)) {
                await commands_1.default.execute(item.command);
            }
            else {
                logger.warn(`Command "${item.command.command}" not registered to coc.nvim`);
            }
        }
    }
    async applyTextEdit(doc, additionalEdits, item, option) {
        var _a;
        let { linenr, col } = option;
        let { character, line } = this.triggerContext;
        let pos = await (0, ui_1.getLineAndPosition)(workspace_1.default.nvim);
        if (pos.line != linenr - 1)
            return;
        let { textEdit, insertText, label } = item;
        let range = (0, util_2.getReplaceRange)(item, this.itemDefaults, undefined, option.insertMode);
        if (!range) {
            // create default replace range
            let end = character + (option.insertMode == types_1.InsertMode.Insert ? 0 : option.followWord.length);
            range = vscode_languageserver_types_1.Range.create(pos.line, (0, string_1.characterIndex)(line, col), pos.line, end);
        }
        // replace range must contains cursor position.
        if (range.end.character < character)
            range.end.character = character;
        let newText = textEdit ? textEdit.newText : insertText !== null && insertText !== void 0 ? insertText : label;
        // adjust range by indent
        let indentCount = fixIndent(line, pos.text, range);
        // cursor moved count
        let delta = pos.character - character - indentCount;
        // fix range by count cursor moved to replace insert word on complete done.
        if (delta !== 0)
            range.end.character += delta;
        let next = pos.text[range.end.character];
        if (next && newText.endsWith(next) && util_1.pariedCharacters.get(newText[0]) === next) {
            range.end.character += 1;
        }
        if (option.snippetsSupport !== false && (0, util_2.isSnippetItem)(item, this.itemDefaults)) {
            let opts = getUltisnipOption(item);
            let insertTextMode = (_a = item.insertTextMode) !== null && _a !== void 0 ? _a : this.itemDefaults.insertTextMode;
            return await manager_1.default.insertSnippet(newText, !additionalEdits, range, insertTextMode, opts);
        }
        await doc.applyEdits([vscode_languageserver_types_1.TextEdit.replace(range, newText)], false, pos);
        return false;
    }
    getTriggerKind(opt) {
        let { triggerCharacters } = this;
        let isTrigger = triggerCharacters.includes(opt.triggerCharacter);
        let triggerKind = protocol_1.CompletionTriggerKind.Invoked;
        if (opt.triggerForInComplete) {
            triggerKind = protocol_1.CompletionTriggerKind.TriggerForIncompleteCompletions;
        }
        else if (isTrigger) {
            triggerKind = protocol_1.CompletionTriggerKind.TriggerCharacter;
        }
        return triggerKind;
    }
}
exports.default = LanguageSource;
function getUltisnipOption(item) {
    var _a, _b;
    let opts = ((_a = item.data) === null || _a === void 0 ? void 0 : _a.ultisnip) === true ? {} : (_b = item.data) === null || _b === void 0 ? void 0 : _b.ultisnip;
    return opts ? opts : undefined;
}
exports.getUltisnipOption = getUltisnipOption;
function fixIndent(line, currline, range) {
    let oldIndent = line.match(/^\s*/)[0];
    let newIndent = currline.match(/^\s*/)[0];
    if (oldIndent === newIndent)
        return 0;
    let d = newIndent.length - oldIndent.length;
    range.start.character += d;
    range.end.character += d;
    return d;
}
exports.fixIndent = fixIndent;
//# sourceMappingURL=source-language.js.map