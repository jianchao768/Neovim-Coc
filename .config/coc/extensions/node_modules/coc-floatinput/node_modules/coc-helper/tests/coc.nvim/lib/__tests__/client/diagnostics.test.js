"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_uri_1 = require("vscode-uri");
const lsclient = tslib_1.__importStar(require("../../language-client"));
const diagnostic_1 = require("../../language-client/diagnostic");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
function getId(uri) {
    let ms = uri.match(/\d+$/);
    return ms ? Number(ms[0]) : undefined;
}
function createDocument(id, version = 1) {
    let uri = `file:///${id}`;
    return vscode_languageserver_textdocument_1.TextDocument.create(uri, '', version, '');
}
function createUri(id) {
    return vscode_uri_1.URI.file(id.toString());
}
describe('BackgroundScheduler', () => {
    it('should schedule documents by add', async () => {
        let uris = [];
        let s = new diagnostic_1.BackgroundScheduler({
            pull(document) {
                uris.push(document.uri);
            }
        });
        s.add(createDocument(1));
        s.add(createDocument(1));
        s.add(createDocument(2));
        s.add(createDocument(3));
        await helper_1.default.waitValue(() => {
            return uris.length;
        }, 3);
        let ids = uris.map(u => getId(u));
        expect(ids).toEqual([1, 2, 3]);
    });
    it('should schedule documents by remove', async () => {
        let uris = [];
        let s = new diagnostic_1.BackgroundScheduler({
            pull(document) {
                uris.push(document.uri);
            }
        });
        s.add(createDocument(1));
        s.add(createDocument(2));
        s.remove(createDocument(2));
        s.add(createDocument(3));
        s.remove(createDocument(3));
        s.remove(createDocument(1));
        await helper_1.default.waitValue(() => {
            return uris.length;
        }, 3);
        let ids = uris.map(u => getId(u));
        expect(ids).toEqual([2, 3, 1]);
        s.dispose();
    });
});
describe('DocumentPullStateTracker', () => {
    it('should track document', async () => {
        let tracker = new diagnostic_1.DocumentPullStateTracker();
        let state = tracker.track(diagnostic_1.PullState.document, createDocument(1));
        let other = tracker.track(diagnostic_1.PullState.document, createDocument(1));
        expect(state).toBe(other);
        tracker.track(diagnostic_1.PullState.workspace, createDocument(3));
        let id = 'dcf06d3b-79f6-4a5e-bc8d-d3334f7b4cad';
        tracker.update(diagnostic_1.PullState.document, createDocument(1, 2), id);
        tracker.update(diagnostic_1.PullState.document, createDocument(2, 2), 'f758ae47-c94e-406e-ba41-0f3bb2fe4fc7');
        let curr = tracker.getResultId(diagnostic_1.PullState.document, createDocument(1, 2));
        expect(curr).toBe(id);
        expect(tracker.getResultId(diagnostic_1.PullState.workspace, createDocument(1, 2))).toBeUndefined();
        tracker.unTrack(diagnostic_1.PullState.document, createDocument(2, 2));
        expect(tracker.trackingDocuments()).toEqual(['file:///1']);
        tracker.update(diagnostic_1.PullState.workspace, createDocument(3, 2), 'fcb905e2-8edb-4239-9150-198c8175ed4a');
        tracker.update(diagnostic_1.PullState.workspace, createDocument(1, 2), 'fe96d175-c19f-4705-bff1-101bf83b2953');
        expect(tracker.tracks(diagnostic_1.PullState.workspace, createDocument(3, 1))).toBe(true);
        expect(tracker.tracks(diagnostic_1.PullState.document, createDocument(4, 1))).toBe(false);
        let res = tracker.getAllResultIds();
        expect(res.length).toBe(2);
    });
    it('should track URI', async () => {
        let tracker = new diagnostic_1.DocumentPullStateTracker();
        let state = tracker.track(diagnostic_1.PullState.document, createUri(1), undefined);
        let other = tracker.track(diagnostic_1.PullState.document, createUri(1), undefined);
        expect(state).toBe(other);
        tracker.track(diagnostic_1.PullState.workspace, createUri(3), undefined);
        let id = 'dcf06d3b-79f6-4a5e-bc8d-d3334f7b4cad';
        tracker.update(diagnostic_1.PullState.document, createUri(1), undefined, id);
        tracker.update(diagnostic_1.PullState.document, createUri(2), undefined, 'f758ae47-c94e-406e-ba41-0f3bb2fe4fc7');
        let curr = tracker.getResultId(diagnostic_1.PullState.document, createUri(1));
        expect(curr).toBe(id);
        tracker.unTrack(diagnostic_1.PullState.document, createUri(2));
        expect(tracker.trackingDocuments()).toEqual(['file:///1']);
        tracker.update(diagnostic_1.PullState.workspace, createUri(3), undefined, undefined);
        tracker.update(diagnostic_1.PullState.workspace, createUri(1), undefined, 'fe96d175-c19f-4705-bff1-101bf83b2953');
        expect(tracker.tracks(diagnostic_1.PullState.workspace, createUri(3))).toBe(true);
        expect(tracker.tracks(diagnostic_1.PullState.document, createUri(4))).toBe(false);
        let res = tracker.getAllResultIds();
        expect(res.length).toBe(1);
    });
});
describe('DiagnosticFeature', () => {
    let nvim;
    beforeAll(async () => {
        await helper_1.default.setup();
        nvim = workspace_1.default.nvim;
    });
    afterAll(async () => {
        await helper_1.default.shutdown();
    });
    afterEach(async () => {
        await helper_1.default.reset();
    });
    async function createServer(interFileDependencies, workspaceDiagnostics = false, middleware = {}, fun) {
        let clientOptions = {
            documentSelector: [{ language: '*' }],
            middleware,
            initializationOptions: {
                interFileDependencies: interFileDependencies == true,
                workspaceDiagnostics
            }
        };
        if (fun)
            fun(clientOptions);
        let serverModule = path_1.default.join(__dirname, './server/diagnosticServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.ipc
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        await client.start();
        return client;
    }
    function getUri(s) {
        let fsPath = path_1.default.join(os_1.default.tmpdir(), s.toString());
        return vscode_uri_1.URI.file(fsPath).toString();
    }
    it('should work when change visible editor', async () => {
        let doc = await workspace_1.default.loadFile(getUri(1), 'edit');
        await workspace_1.default.loadFile(getUri(3), 'tabe');
        let client = await createServer(true);
        await helper_1.default.wait(30);
        await workspace_1.default.loadFile(getUri(2), 'edit');
        await helper_1.default.wait(30);
        await workspace_1.default.loadFile(getUri(3), 'tabe');
        await helper_1.default.wait(30);
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        expect(feature).toBeDefined();
        let provider = feature.getProvider(doc.textDocument);
        let res = provider.knows(diagnostic_1.PullState.document, doc.textDocument);
        expect(res).toBe(false);
        await client.stop();
    });
    it('should filter by document selector', async () => {
        let client = await createServer(true, false, {}, opt => {
            opt.documentSelector = [{ language: 'vim' }];
        });
        let doc = await workspace_1.default.loadFile(getUri(1), 'edit');
        await helper_1.default.wait(10);
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        let provider = feature.getProvider(vscode_languageserver_textdocument_1.TextDocument.create('file:///1', 'vim', 1, ''));
        let res = provider.knows(diagnostic_1.PullState.document, doc.textDocument);
        expect(res).toBe(false);
        await client.stop();
    });
    it('should filter by ignore', async () => {
        let client = await createServer(true, false, {}, opt => {
            opt.diagnosticPullOptions = {
                ignored: ['**/*.ts']
            };
        });
        let doc = await workspace_1.default.loadFile(getUri('a.ts'), 'edit');
        await helper_1.default.wait(10);
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        let provider = feature.getProvider(doc.textDocument);
        let res = provider.knows(diagnostic_1.PullState.document, doc.textDocument);
        expect(res).toBe(false);
        await client.stop();
    });
    it('should not throw on request error', async () => {
        let client = await createServer(true);
        await workspace_1.default.loadFile(getUri('error'), 'edit');
        await workspace_1.default.loadFile(getUri('cancel'), 'tabe');
        await workspace_1.default.loadFile(getUri('retrigger'), 'tabe');
        await helper_1.default.wait(10);
        await nvim.command('normal! 2gt');
        await workspace_1.default.loadFile(getUri('unchanged'), 'edit');
        await helper_1.default.wait(20);
        await client.stop();
    });
    it('should pull diagnostic on change', async () => {
        let doc = await workspace_1.default.loadFile(getUri('change'), 'edit');
        let client = await createServer(true, false, {}, opt => {
            opt.diagnosticPullOptions = {
                onChange: true,
                filter: doc => {
                    return doc.uri.endsWith('filtered');
                }
            };
        });
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        let provider = feature.getProvider(doc.textDocument);
        await helper_1.default.waitValue(() => {
            return provider.knows(diagnostic_1.PullState.document, doc.textDocument);
        }, true);
        await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')]);
        await helper_1.default.waitValue(async () => {
            return await client.sendRequest('getChangeCount');
        }, 2);
        await nvim.call('setline', [1, 'foo']);
        let d = await workspace_1.default.loadFile(getUri('filtered'), 'tabe');
        await d.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')]);
        await helper_1.default.wait(30);
        await nvim.command(`bd! ${doc.bufnr}`);
        await client.stop();
    });
    it('should pull diagnostic on save', async () => {
        let doc = await workspace_1.default.loadFile(getUri((0, uuid_1.v4)() + 'filtered'), 'edit');
        await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')]);
        doc = await workspace_1.default.loadFile(getUri((0, uuid_1.v4)() + 'save'), 'tabe');
        let client = await createServer(true, false, {}, opt => {
            opt.diagnosticPullOptions = {
                onSave: true,
                filter: doc => {
                    return doc.uri.endsWith('filtered');
                }
            };
        });
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        let provider = feature.getProvider(doc.textDocument);
        await helper_1.default.waitValue(() => {
            return provider.knows(diagnostic_1.PullState.document, doc.textDocument);
        }, true);
        await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')]);
        await nvim.command('wa');
        await helper_1.default.wait(10);
        await client.stop();
    });
    it('should use provideDiagnostics middleware', async () => {
        let called = false;
        let callHandle = false;
        let client = await createServer(true, false, {
            provideDiagnostics: (doc, id, token, next) => {
                called = true;
                return next(doc, id, token);
            },
            handleDiagnostics: (uri, diagnostics, next) => {
                callHandle = true;
                return next(uri, diagnostics);
            }
        });
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        expect(feature).toBeDefined();
        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(getUri('empty'), 'e', 1, '');
        let provider = feature.getProvider(textDocument);
        let res = await provider.diagnostics.provideDiagnostics(textDocument, '', vscode_languageserver_protocol_1.CancellationToken.None);
        expect(called).toBe(true);
        expect(res).toEqual({ kind: 'full', items: [] });
        await helper_1.default.waitValue(() => {
            return callHandle;
        }, true);
        await client.stop();
    });
    it('should use provideWorkspaceDiagnostics middleware', async () => {
        let called = false;
        let client = await createServer(false, true, {
            provideWorkspaceDiagnostics: (resultIds, token, resultReporter, next) => {
                called = true;
                return next(resultIds, token, resultReporter);
            }
        });
        expect(called).toBe(true);
        await helper_1.default.waitValue(async () => {
            let count = await client.sendRequest('getWorkspceCount');
            return count > 1;
        }, true);
        await client.stop();
    });
    it('should receive partial result', async () => {
        let client = await createServer(false, true, {}, opt => {
            opt.diagnosticPullOptions = {
                workspace: false
            };
        });
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(getUri('empty'), 'e', 1, '');
        let provider = feature.getProvider(textDocument);
        let n = 0;
        await provider.diagnostics.provideWorkspaceDiagnostics([{ uri: 'uri', value: '1' }], vscode_languageserver_protocol_1.CancellationToken.None, chunk => {
            n++;
        });
        expect(n).toBe(4);
        await client.stop();
    });
    it('should fire refresh event', async () => {
        let client = await createServer(true, false, {});
        let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method);
        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(getUri('1'), 'e', 1, '');
        let provider = feature.getProvider(textDocument);
        let called = false;
        provider.onDidChangeDiagnosticsEmitter.event(() => {
            called = true;
        });
        await client.sendNotification('fireRefresh');
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        await client.stop();
    });
});
//# sourceMappingURL=diagnostics.test.js.map