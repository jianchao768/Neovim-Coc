"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const manager_1 = tslib_1.__importStar(require("../../snippets/manager"));
const string_1 = require("../../snippets/string");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let doc;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    let pyfile = path_1.default.join(__dirname, '../ultisnips.py');
    await nvim.command(`execute 'pyxfile '.fnameescape('${pyfile}')`);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
});
beforeEach(async () => {
    doc = await helper_1.default.createDocument();
});
describe('snippet provider', () => {
    describe('Events', () => {
        it('should change status item on editor change', async () => {
            let doc = await helper_1.default.createDocument('foo');
            await nvim.input('i');
            await manager_1.default.insertSnippet('${1:foo} $1 ');
            let val = await nvim.getVar('coc_status');
            expect(val).toBeDefined();
            await nvim.command('edit bar');
            await helper_1.default.waitValue(async () => {
                let val = await nvim.getVar('coc_status');
                return val.includes('SNIP');
            }, false);
            await nvim.command('buffer ' + doc.bufnr);
            await helper_1.default.waitValue(async () => {
                let val = await nvim.getVar('coc_status');
                return val.includes('SNIP');
            }, true);
        });
        it('should check position on InsertEnter', async () => {
            await nvim.input('ibar<left><left><left>');
            await manager_1.default.insertSnippet('${1:foo} $1 ');
            await nvim.input('<esc>A');
            await helper_1.default.wait(50);
            expect(manager_1.default.session).toBeUndefined();
        });
    });
    describe('insertSnippet()', () => {
        it('should throw when buffer not attached', async () => {
            await nvim.command(`vnew +setl\\ buftype=nofile`);
            await expect(async () => {
                await manager_1.default.insertSnippet('foo');
            }).rejects.toThrow(Error);
        });
        it('should throw with invalid range', async () => {
            await expect(async () => {
                await manager_1.default.insertSnippet('foo', false, vscode_languageserver_protocol_1.Range.create(3, 0, 3, 0));
            }).rejects.toThrow(Error);
        });
        it('should replace range for ultisnip with python code', async () => {
            await nvim.setLine('foo');
            await manager_1.default.insertSnippet('`!p snip.rv = vim.current.line`', false, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), vscode_languageserver_protocol_1.InsertTextMode.asIs, {});
            let line = await nvim.line;
            expect(line).toBe('');
            await helper_1.default.doAction('selectCurrentPlaceholder');
        });
        it('should not active when insert plain snippet', async () => {
            await manager_1.default.insertSnippet('foo');
            let line = await nvim.line;
            expect(line).toBe('foo');
            expect(manager_1.default.session).toBe(undefined);
            expect(manager_1.default.getSession(doc.bufnr)).toBeUndefined();
        });
        it('should insert snippet by action', async () => {
            await nvim.input('i');
            let res = await helper_1.default.plugin.cocAction('snippetInsert', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), '${1:foo}');
            expect(res).toBe(true);
        });
        it('should start new session if session exists', async () => {
            await nvim.setLine('bar');
            await manager_1.default.insertSnippet('${1:foo} ');
            await nvim.input('<esc>');
            await nvim.command('stopinsert');
            await nvim.input('A');
            let active = await manager_1.default.insertSnippet('${2:bar}');
            expect(active).toBe(true);
            let line = await nvim.getLine();
            expect(line).toBe('foo barbar');
        });
        it('should start nest session', async () => {
            await manager_1.default.insertSnippet('${1:foo} ${2:bar}');
            await nvim.input('<backspace>');
            let active = await manager_1.default.insertSnippet('${1:x} $1');
            expect(active).toBe(true);
        });
        it('should insert snippetString', async () => {
            let snippetString = new string_1.SnippetString()
                .appendTabstop(1)
                .appendText(' ')
                .appendPlaceholder('bar', 2);
            await manager_1.default.insertSnippet(snippetString);
            await nvim.input('$foo;');
            snippetString = new string_1.SnippetString()
                .appendVariable('foo', 'x');
            await manager_1.default.insertSnippet(snippetString, false, vscode_languageserver_protocol_1.Range.create(0, 5, 0, 6));
            let line = await nvim.line;
            expect(line).toBe('$foo;xbar');
        });
    });
    describe('nextPlaceholder()', () => {
        it('should goto next placeholder', async () => {
            await manager_1.default.insertSnippet('${1:a} ${2:b}');
            await helper_1.default.doAction('snippetNext');
            let col = await nvim.call('col', '.');
            expect(col).toBe(3);
        });
        it('should remove keymap on nextPlaceholder when session not exits', async () => {
            await nvim.call('coc#snippet#enable');
            await manager_1.default.nextPlaceholder();
            let val = await doc.buffer.getVar('coc_snippet_active');
            expect(val).toBe(0);
        });
        it('should respect preferCompleteThanJumpPlaceholder', async () => {
            helper_1.default.updateConfiguration('suggest.preferCompleteThanJumpPlaceholder', true);
            let doc = await workspace_1.default.document;
            await nvim.input('o');
            await manager_1.default.insertSnippet('${1} ${2:bar} foot');
            await doc.synchronize();
            await nvim.input('f');
            await helper_1.default.waitPopup();
            await nvim.call('coc#pum#select_confirm');
            await helper_1.default.waitFor('getline', ['.'], 'foot bar foot');
        });
    });
    describe('previousPlaceholder()', () => {
        it('should goto previous placeholder', async () => {
            await manager_1.default.insertSnippet('${1:a} ${2:b}');
            await manager_1.default.nextPlaceholder();
            await helper_1.default.doAction('snippetPrev');
            let col = await nvim.call('col', '.');
            expect(col).toBe(1);
        });
        it('should remove keymap on previousPlaceholder when session not exits', async () => {
            await nvim.call('coc#snippet#enable');
            await manager_1.default.previousPlaceholder();
            let val = await doc.buffer.getVar('coc_snippet_active');
            expect(val).toBe(0);
        });
    });
    describe('cancel()', () => {
        it('should cancel snippet session', async () => {
            let buffer = doc.buffer;
            await nvim.call('coc#snippet#enable');
            await helper_1.default.doAction('snippetCancel');
            let val = await buffer.getVar('coc_snippet_active');
            expect(val).toBe(0);
            let active = await manager_1.default.insertSnippet('${1:foo}');
            expect(active).toBe(true);
            manager_1.default.cancel();
            expect(manager_1.default.session).toBeUndefined();
        });
    });
    describe('jumpable()', () => {
        it('should check jumpable', async () => {
            await nvim.input('i');
            await manager_1.default.insertSnippet('${1:foo} ${2:bar}');
            let jumpable = manager_1.default.jumpable();
            expect(jumpable).toBe(true);
            await manager_1.default.nextPlaceholder();
            jumpable = manager_1.default.jumpable();
            expect(jumpable).toBe(true);
            await manager_1.default.nextPlaceholder();
            jumpable = manager_1.default.jumpable();
            expect(jumpable).toBe(false);
        });
    });
    describe('synchronize text', () => {
        it('should synchronize when position changed and pum visible', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setLine('foo');
            await nvim.input('o');
            let res = await manager_1.default.insertSnippet("`!p snip.rv = ' '*(4- len(t[1]))`${1}", true, undefined, vscode_languageserver_protocol_1.InsertTextMode.asIs, {});
            expect(res).toBe(true);
            let line = await nvim.line;
            expect(line).toBe('    ');
            await nvim.input('f');
            await helper_1.default.waitFor('coc#pum#visible', [], 1);
            await nvim.input('<C-e>');
            let s = manager_1.default.getSession(doc.bufnr);
            expect(s).toBeDefined();
        });
        it('should update placeholder on placeholder update', async () => {
            let doc = await workspace_1.default.document;
            await nvim.input('i');
            await manager_1.default.insertSnippet('$1\n${1/,/|/g}', true, undefined, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation, {});
            await nvim.input('a,b');
            doc._forceSync();
            let s = manager_1.default.getSession(doc.bufnr);
            await s.forceSynchronize();
            let lines = await nvim.call('getline', [1, '$']);
            expect(lines).toEqual(['a,b', 'a|b']);
        });
        it('should adjust cursor position on update', async () => {
            await nvim.call('cursor', [1, 1]);
            await nvim.input('i');
            await manager_1.default.insertSnippet('${1/..*/ -> /}$1');
            let line = await nvim.line;
            expect(line).toBe('');
            await nvim.input('x');
            let s = manager_1.default.getSession(doc.bufnr);
            expect(s).toBeDefined();
            await s.forceSynchronize();
            line = await nvim.line;
            expect(line).toBe(' -> x');
            let col = await nvim.call('col', '.');
            expect(col).toBe(6);
        });
        it('should synchronize text on change final placeholder', async () => {
            let doc = await workspace_1.default.document;
            await nvim.input('i');
            let res = await manager_1.default.insertSnippet('$0empty$0');
            expect(res).toBe(true);
            await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 0, 0, 0, ['abc']]);
            await doc.synchronize();
            let s = manager_1.default.getSession(doc.bufnr);
            await s.forceSynchronize();
            let line = await nvim.line;
            expect(line).toBe('abcemptyabc');
        });
    });
    describe('resolveSnippet()', () => {
        it('should resolve snippet text', async () => {
            let snippet = await manager_1.default.resolveSnippet('${1:foo}');
            expect(snippet.toString()).toBe('foo');
            snippet = await manager_1.default.resolveSnippet('${1:foo} ${2:`!p snip.rv = "foo"`}', {});
            expect(snippet.toString()).toBe('foo foo');
        });
        it('should avoid python resolve when necessary', async () => {
            await nvim.command('startinsert');
            let res = await manager_1.default.insertSnippet('${1:foo} `!p snip.rv = t[1]`', true, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), vscode_languageserver_protocol_1.InsertTextMode.asIs, {});
            expect(res).toBe(true);
            let snippet = await manager_1.default.resolveSnippet('${1:x} `!p snip.rv= t[1]`', {});
            expect(snippet.toString()).toBe('x x');
            res = await nvim.call('pyxeval', 't[1]');
            expect(res).toBe('x');
        });
    });
    describe('normalizeInsertText()', () => {
        it('should normalizeInsertText', async () => {
            let doc = await workspace_1.default.document;
            Object.defineProperty(window_1.default, 'activeTextEditor', {
                get: () => {
                    return undefined;
                },
                configurable: true,
                enumerable: true
            });
            let res = await manager_1.default.normalizeInsertText(doc.uri, 'foo\nbar', '  ', vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation);
            expect(res).toBe('foo\n  bar');
            Object.defineProperty(window_1.default, 'activeTextEditor', {
                get: () => {
                    return workspace_1.default.editors.activeTextEditor;
                }
            });
        });
    });
    describe('editsInsideSnippet()', () => {
        it('should check editsInsideSnippet', async () => {
            await nvim.setLine('foo');
            await nvim.input('o');
            await manager_1.default.insertSnippet('${1:foo} $1 ');
            let res = await manager_1.default.editsInsideSnippet([vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), '')]);
            expect(res).toBe(false);
        });
    });
    describe('insertSnippet command', () => {
        it('should insert ultisnips snippet', async () => {
            expect(manager_1.SnippetManager).toBeDefined();
            await nvim.setLine('foo');
            let edit = vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), '${1:`echo "bar"`}');
            await commands_1.default.executeCommand('editor.action.insertSnippet', edit, {});
            let line = await nvim.line;
            expect(line).toBe('bar');
            edit = vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), '${1:`echo "foo"`}');
            await commands_1.default.executeCommand('editor.action.insertSnippet', edit, { regex: '' });
            line = await nvim.line;
            expect(line).toBe('foo');
        });
    });
    describe('dispose()', () => {
        it('should dispose', async () => {
            let active = await manager_1.default.insertSnippet('${1:foo}');
            expect(active).toBe(true);
            manager_1.default.dispose();
            expect(manager_1.default.session).toBeUndefined();
        });
    });
});
//# sourceMappingURL=manager.test.js.map