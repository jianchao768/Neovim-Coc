'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = exports.resolveRequestOptions = exports.getAgent = exports.getSystemProxyURI = exports.getDataType = exports.toPort = exports.toURL = exports.getText = exports.getRequestModule = exports.timeout = void 0;
const tslib_1 = require("tslib");
const decompress_response_1 = tslib_1.__importDefault(require("decompress-response"));
const follow_redirects_1 = require("follow-redirects");
const http_proxy_agent_1 = tslib_1.__importDefault(require("http-proxy-agent"));
const https_proxy_agent_1 = tslib_1.__importDefault(require("https-proxy-agent"));
const querystring_1 = require("querystring");
const url_1 = require("url");
const logger_1 = require("../logger");
const errors_1 = require("../util/errors");
const is_1 = require("../util/is");
const node_1 = require("../util/node");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const string_1 = require("../util/string");
const util_1 = require("../util");
const logger = (0, logger_1.createLogger)('model-fetch');
exports.timeout = (0, util_1.getConditionValue)(500, 50);
function getRequestModule(url) {
    return url.protocol === 'https:' ? follow_redirects_1.https : follow_redirects_1.http;
}
exports.getRequestModule = getRequestModule;
function getText(data) {
    if (typeof data === 'string' || Buffer.isBuffer(data))
        return data;
    return JSON.stringify(data);
}
exports.getText = getText;
function toURL(urlInput) {
    if (urlInput instanceof url_1.URL)
        return urlInput;
    let url = new url_1.URL(urlInput);
    if (!['https:', 'http:'].includes(url.protocol))
        throw new Error(`Not valid protocol with ${urlInput}, should be http: or https:`);
    return url;
}
exports.toURL = toURL;
function toPort(port, protocol) {
    if (port) {
        port = typeof port === 'number' ? port : parseInt(port, 10);
        if (!isNaN(port))
            return port;
    }
    return protocol.startsWith('https') ? 443 : 80;
}
exports.toPort = toPort;
function getDataType(data) {
    if (data === null)
        return 'null';
    if (data === undefined)
        return 'undefined';
    if (typeof data == 'string')
        return 'string';
    if (Buffer.isBuffer(data))
        return 'buffer';
    if (Array.isArray(data) || (0, is_1.objectLiteral)(data))
        return 'object';
    return 'unknown';
}
exports.getDataType = getDataType;
function getSystemProxyURI(endpoint, env = process.env) {
    var _a;
    let noProxy = (_a = env.NO_PROXY) !== null && _a !== void 0 ? _a : env.no_proxy;
    if (noProxy === '*') {
        return null;
    }
    if (noProxy) {
        // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
        const hostname = endpoint.hostname.replace(/^\.*/, '.').toLowerCase();
        const port = toPort(endpoint.port, endpoint.protocol).toString();
        const noProxyList = noProxy.split(',');
        for (let i = 0, len = noProxyList.length; i < len; i++) {
            let noProxyItem = noProxyList[i].trim().toLowerCase();
            // no_proxy can be granular at the port level, which complicates things a bit.
            if (noProxyItem.includes(':')) {
                let noProxyItemParts = noProxyItem.split(':', 2);
                let noProxyHost = noProxyItemParts[0].replace(/^\.*/, '.');
                let noProxyPort = noProxyItemParts[1];
                if (port == noProxyPort && hostname.endsWith(noProxyHost)) {
                    return null;
                }
            }
            else {
                noProxyItem = noProxyItem.replace(/^\.*/, '.');
                if (hostname.endsWith(noProxyItem)) {
                    return null;
                }
            }
        }
    }
    let proxyUri;
    if (endpoint.protocol === 'http:') {
        proxyUri = env.HTTP_PROXY || env.http_proxy || null;
    }
    else {
        proxyUri = env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy || null;
    }
    return proxyUri;
}
exports.getSystemProxyURI = getSystemProxyURI;
function getAgent(endpoint, options) {
    let proxy = options.proxy || getSystemProxyURI(endpoint);
    if (proxy) {
        let proxyURL;
        try {
            proxyURL = new url_1.URL(proxy);
            if (!/^https?:$/.test(proxyURL.protocol))
                return null;
        }
        catch (e) {
            return null;
        }
        let opts = {
            host: proxyURL.hostname,
            port: toPort(proxyURL.port, proxyURL.protocol),
            auth: proxyURL.username ? `${proxyURL.username}:${(0, string_1.toText)(proxyURL.password)}` : undefined,
            rejectUnauthorized: typeof options.proxyStrictSSL === 'boolean' ? options.proxyStrictSSL : true
        };
        logger.info(`Using proxy ${proxy} from ${options.proxy ? 'configuration' : 'system environment'} for ${endpoint.hostname}:`);
        return endpoint.protocol === 'http:' ? (0, http_proxy_agent_1.default)(opts) : (0, https_proxy_agent_1.default)(opts);
    }
    return null;
}
exports.getAgent = getAgent;
function resolveRequestOptions(url, options) {
    var _a, _b;
    let config = workspace_1.default.getConfiguration('http', null);
    let dataType = getDataType(options.data);
    let proxyOptions = {
        proxy: config.get('proxy', ''),
        proxyStrictSSL: config.get('proxyStrictSSL', true),
        proxyAuthorization: config.get('proxyAuthorization', null),
        proxyCA: config.get('proxyCA', null)
    };
    if (options.query && !url.search) {
        url.search = `?${(0, querystring_1.stringify)(options.query)}`;
    }
    let agent = getAgent(url, proxyOptions);
    let opts = {
        method: (_a = options.method) !== null && _a !== void 0 ? _a : 'GET',
        hostname: url.hostname,
        port: toPort(url.port, url.protocol),
        path: url.pathname + url.search,
        agent,
        rejectUnauthorized: proxyOptions.proxyStrictSSL,
        maxRedirects: 3,
        headers: Object.assign({ 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)', 'Accept-Encoding': 'gzip, deflate' }, ((_b = options.headers) !== null && _b !== void 0 ? _b : {}))
    };
    if (dataType == 'object') {
        opts.headers['Content-Type'] = 'application/json';
    }
    else if (dataType == 'string') {
        opts.headers['Content-Type'] = 'text/plain';
    }
    if (proxyOptions.proxyAuthorization)
        opts.headers['Proxy-Authorization'] = proxyOptions.proxyAuthorization;
    if (proxyOptions.proxyCA)
        opts.ca = node_1.fs.readFileSync(proxyOptions.proxyCA);
    if (options.user)
        opts.auth = options.user + ':' + ((0, string_1.toText)(options.password));
    if (url.username)
        opts.auth = url.username + ':' + ((0, string_1.toText)(url.password));
    if (options.timeout)
        opts.timeout = options.timeout;
    if (options.buffer)
        opts.buffer = true;
    return opts;
}
exports.resolveRequestOptions = resolveRequestOptions;
function request(url, data, opts, token) {
    let mod = getRequestModule(url);
    return new Promise((resolve, reject) => {
        if (token) {
            let disposable = token.onCancellationRequested(() => {
                disposable.dispose();
                req.destroy(new errors_1.CancellationError());
            });
        }
        let timer;
        const req = mod.request(opts, res => {
            let readable = res;
            if ((res.statusCode >= 200 && res.statusCode < 300) || res.statusCode === 1223) {
                let headers = res.headers;
                let chunks = [];
                let contentType = (0, string_1.toText)(headers['content-type']);
                readable = (0, decompress_response_1.default)(res);
                readable.on('data', chunk => {
                    chunks.push(chunk);
                });
                readable.on('end', () => {
                    clearTimeout(timer);
                    let buf = Buffer.concat(chunks);
                    if (!opts.buffer && (contentType.startsWith('application/json') || contentType.startsWith('text/'))) {
                        let ms = contentType.match(/charset=(\S+)/);
                        let encoding = ms ? ms[1] : 'utf8';
                        let rawData = buf.toString(encoding);
                        if (!contentType.includes('application/json')) {
                            resolve(rawData);
                        }
                        else {
                            try {
                                const parsedData = JSON.parse(rawData);
                                resolve(parsedData);
                            }
                            catch (e) {
                                reject(new Error(`Parse response error: ${e}`));
                            }
                        }
                    }
                    else {
                        resolve(buf);
                    }
                });
                readable.on('error', err => {
                    reject(new Error(`Connection error to ${url}: ${err.message}`));
                });
            }
            else {
                reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
            }
        });
        req.on('error', e => {
            // Possible succeed proxy request with ECONNRESET error on node > 14
            if (opts.agent && e['code'] == 'ECONNRESET') {
                timer = setTimeout(() => {
                    reject(e);
                }, exports.timeout);
            }
            else {
                reject(e);
            }
        });
        req.on('timeout', () => {
            req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
        });
        if (data)
            req.write(getText(data));
        if (opts.timeout)
            req.setTimeout(opts.timeout);
        req.end();
    });
}
exports.request = request;
/**
 * Send request to server for response, supports:
 *
 * - Send json data and parse json response.
 * - Throw error for failed response statusCode.
 * - Timeout support (no timeout by default).
 * - Send buffer (as data) and receive data (as response).
 * - Proxy support from user configuration & environment.
 * - Redirect support, limited to 3.
 * - Support of gzip & deflate response content.
 */
function fetch(urlInput, options = {}, token) {
    let url = toURL(urlInput);
    let opts = resolveRequestOptions(url, options);
    return request(url, options.data, opts, token).catch(err => {
        logger.error(`Fetch error for ${url}:`, opts, err);
        if (opts.agent && opts.agent.proxy) {
            let { proxy } = opts.agent;
            throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
        }
        else {
            throw err;
        }
    });
}
exports.default = fetch;
//# sourceMappingURL=fetch.js.map