'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBeforeCount = exports.getChange = exports.getDelta = exports.isTextChange = exports.isSurrondChange = exports.getVisualRanges = exports.splitRange = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const object_1 = require("../util/object");
const textedit_1 = require("../util/textedit");
/**
 * Split to single line ranges
 */
function splitRange(doc, range) {
    let splited = [];
    for (let i = range.start.line; i <= range.end.line; i++) {
        let curr = doc.getline(i) || '';
        let sc = i == range.start.line ? range.start.character : 0;
        let ec = i == range.end.line ? range.end.character : curr.length;
        if (sc == ec)
            continue;
        splited.push(vscode_languageserver_types_1.Range.create(i, sc, i, ec));
    }
    return splited;
}
exports.splitRange = splitRange;
/**
 * Get ranges of visual block
 */
function getVisualRanges(doc, range) {
    let { start, end } = (0, textedit_1.getWellformedRange)(range);
    let sc = start.character < end.character ? start.character : end.character;
    let ec = start.character < end.character ? end.character : start.character;
    let ranges = [];
    for (let i = start.line; i <= end.line; i++) {
        let line = doc.getline(i);
        ranges.push(vscode_languageserver_types_1.Range.create(i, sc, i, Math.min(line.length, ec)));
    }
    return ranges;
}
exports.getVisualRanges = getVisualRanges;
function isSurrondChange(change) {
    return Array.isArray(change['prepend']) && Array.isArray(change['append']);
}
exports.isSurrondChange = isSurrondChange;
function isTextChange(change) {
    return typeof change['offset'] === 'number' && typeof change['remove'] === 'number';
}
exports.isTextChange = isTextChange;
function getDelta(change) {
    if (isSurrondChange(change)) {
        return change.append[1].length + change.prepend[1].length - change.append[0] - change.prepend[0];
    }
    return change.insert.length - change.remove;
}
exports.getDelta = getDelta;
function getChange(r, range, newText) {
    let text = r.text;
    if ((0, object_1.equals)(r.range, range)) {
        // surrond
        let idx = text.indexOf(newText);
        if (idx !== -1) {
            let prepend = [idx, ''];
            let append = [text.length - newText.length - idx, ''];
            return { prepend, append };
        }
        idx = newText.indexOf(text);
        if (idx !== -1) {
            let prepend = [0, newText.slice(0, idx)];
            let append = [0, newText.slice(-(newText.length - text.length - idx))];
            return { prepend, append };
        }
    }
    if ((0, object_1.equals)(r.range.end, range.end)) {
        // end change
        let remove = range.end.character - range.start.character;
        return { offset: remove, remove, insert: newText, fromEnd: true };
    }
    let remove = range.end.character - range.start.character;
    let offset = range.start.character - r.range.start.character;
    return { offset, remove, insert: newText };
}
exports.getChange = getChange;
function getBeforeCount(textRange, ranges, exclude) {
    let n = 0;
    for (let idx = 0; idx < ranges.length; idx++) {
        const r = ranges[idx];
        if (r.position.line < textRange.position.line || r === exclude)
            continue;
        if (r.isBefore(textRange)) {
            n++;
            continue;
        }
        break;
    }
    return n;
}
exports.getBeforeCount = getBeforeCount;
//# sourceMappingURL=util.js.map