'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const array_1 = require("../util/array");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const HintTags = [vscode_languageserver_types_1.DiagnosticTag.Deprecated, vscode_languageserver_types_1.DiagnosticTag.Unnecessary];
class DiagnosticCollection {
    constructor(name, onDispose) {
        this.name = name;
        this.onDispose = onDispose;
        this.diagnosticsMap = new Map();
        this._onDidDiagnosticsChange = new protocol_1.Emitter();
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
    }
    set(entries, diagnostics) {
        let diagnosticsPerFile = new Map();
        if (!Array.isArray(entries)) {
            let doc = workspace_1.default.getDocument(entries);
            let uri = doc ? doc.uri : entries;
            diagnosticsPerFile.set(uri, diagnostics || []);
        }
        else {
            for (let item of entries) {
                let [uri, diagnostics] = item;
                let doc = workspace_1.default.getDocument(uri);
                uri = doc ? doc.uri : uri;
                if (diagnostics == null) {
                    // clear previous diagnostics if entry contains null
                    diagnostics = [];
                }
                else {
                    diagnostics = (diagnosticsPerFile.get(uri) || []).concat(diagnostics);
                }
                diagnosticsPerFile.set(uri, diagnostics);
            }
        }
        for (let item of diagnosticsPerFile) {
            let [uri, diagnostics] = item;
            uri = vscode_uri_1.URI.parse(uri).toString();
            diagnostics.forEach(o => {
                var _a, _b;
                // should be message for the file, but we need range
                o.range = (_a = o.range) !== null && _a !== void 0 ? _a : vscode_languageserver_types_1.Range.create(0, 0, 0, 0);
                o.message = (_b = o.message) !== null && _b !== void 0 ? _b : '';
                o.source = o.source || this.name;
                if (!o.severity && Array.isArray(o.tags) && (0, array_1.intersect)(o.tags, HintTags)) {
                    o.severity = vscode_languageserver_types_1.DiagnosticSeverity.Hint;
                }
            });
            this.diagnosticsMap.set(uri, diagnostics);
            this._onDidDiagnosticsChange.fire(uri);
        }
    }
    delete(uri) {
        this.diagnosticsMap.delete(uri);
        this._onDidDiagnosticsChange.fire(uri);
    }
    clear() {
        let uris = Array.from(this.diagnosticsMap.keys());
        uris = uris.filter(uri => this.diagnosticsMap.get(uri).length > 0);
        this.diagnosticsMap.clear();
        for (let uri of uris) {
            this._onDidDiagnosticsChange.fire(uri);
        }
    }
    forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
            let diagnostics = this.diagnosticsMap.get(uri);
            callback.call(thisArg, uri, diagnostics, this);
        }
    }
    entries() {
        return this.diagnosticsMap.entries();
    }
    get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr.slice();
    }
    has(uri) {
        return this.diagnosticsMap.has(uri);
    }
    dispose() {
        this.clear();
        if (this.onDispose)
            this.onDispose();
        this._onDidDiagnosticsChange.dispose();
    }
}
exports.default = DiagnosticCollection;
//# sourceMappingURL=collection.js.map