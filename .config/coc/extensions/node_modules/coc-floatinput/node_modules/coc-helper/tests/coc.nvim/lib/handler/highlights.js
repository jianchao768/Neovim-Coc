'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const util_1 = require("../util");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
/**
 * Highlight same symbols on current window.
 * Highlights are added to window by matchaddpos.
 */
class Highlights {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlights = new Map();
        events_1.default.on(['CursorMoved', 'CursorMovedI'], () => {
            this.cancel();
            this.clearHighlights();
        }, null, this.disposables);
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        window_1.default.onDidChangeActiveTextEditor(() => {
            this.loadConfiguration();
        }, null, this.disposables);
        commands_1.default.register({
            id: 'document.jumpToNextSymbol',
            execute: async () => {
                await this.jumpSymbol('next');
            }
        }, false, 'Jump to next symbol highlight position.');
        commands_1.default.register({
            id: 'document.jumpToPrevSymbol',
            execute: async () => {
                await this.jumpSymbol('previous');
            }
        }, false, 'Jump to previous symbol highlight position.');
    }
    loadConfiguration(e) {
        let config = workspace_1.default.getConfiguration('documentHighlight', this.handler.uri);
        if (!e || e.affectsConfiguration('documentHighlight')) {
            this.config = Object.assign(this.config || {}, {
                priority: config.get('priority', -1),
                timeout: config.get('timeout', 300)
            });
        }
    }
    isEnabled(bufnr, cursors) {
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached || cursors)
            return false;
        if (!languages_1.default.hasProvider(languages_1.ProviderName.DocumentHighlight, doc.textDocument))
            return false;
        return true;
    }
    clearHighlights() {
        if (this.highlights.size == 0)
            return;
        for (let winid of this.highlights.keys()) {
            let win = this.nvim.createWindow(winid);
            win.clearMatchGroup('^CocHighlight');
        }
        this.highlights.clear();
    }
    async highlight() {
        let { nvim } = this;
        this.cancel();
        let [bufnr, winid, pos, cursors] = await nvim.eval(`[bufnr("%"),win_getid(),coc#cursor#position(),get(b:,'coc_cursors_activated',0)]`);
        if (!this.isEnabled(bufnr, cursors))
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        let highlights = await this.getHighlights(doc, vscode_languageserver_types_1.Position.create(pos[0], pos[1]));
        if (!highlights)
            return;
        let groups = {};
        for (let hl of highlights) {
            if (!hl.range)
                continue;
            let hlGroup = hl.kind == vscode_languageserver_types_1.DocumentHighlightKind.Text
                ? 'CocHighlightText'
                : hl.kind == vscode_languageserver_types_1.DocumentHighlightKind.Read ? 'CocHighlightRead' : 'CocHighlightWrite';
            groups[hlGroup] = groups[hlGroup] || [];
            groups[hlGroup].push(hl.range);
        }
        let win = nvim.createWindow(winid);
        nvim.pauseNotification();
        win.clearMatchGroup('^CocHighlight');
        for (let hlGroup of Object.keys(groups)) {
            win.highlightRanges(hlGroup, groups[hlGroup], this.config.priority, true);
        }
        nvim.resumeNotification(true, true);
        this.highlights.set(winid, highlights);
    }
    async jumpSymbol(direction) {
        let ranges = await this.getSymbolsRanges();
        if (!ranges)
            return;
        let pos = await window_1.default.getCursorPosition();
        if (direction == 'next') {
            for (let i = 0; i <= ranges.length - 1; i++) {
                if ((0, position_1.comparePosition)(ranges[i].start, pos) > 0) {
                    await window_1.default.moveTo(ranges[i].start);
                    return;
                }
            }
            await window_1.default.moveTo(ranges[0].start);
        }
        else {
            for (let i = ranges.length - 1; i >= 0; i--) {
                if ((0, position_1.comparePosition)(ranges[i].end, pos) < 0) {
                    await window_1.default.moveTo(ranges[i].start);
                    return;
                }
            }
            await window_1.default.moveTo(ranges[ranges.length - 1].start);
        }
    }
    async getSymbolsRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.DocumentHighlight, doc.textDocument);
        let highlights = await this.getHighlights(doc, position);
        if (!highlights)
            return null;
        return highlights.map(o => o.range).sort((a, b) => {
            if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
            }
            return a.start.character - b.start.character;
        });
    }
    hasHighlights(winid) {
        return this.highlights.get(winid) != null;
    }
    async getHighlights(doc, position) {
        let line = doc.getline(position.line);
        let ch = line[position.character];
        if (!ch || !doc.isWord(ch))
            return null;
        await doc.synchronize();
        this.cancel();
        let source = this.tokenSource = new protocol_1.CancellationTokenSource();
        let timer = this.timer = setTimeout(() => {
            if (source.token.isCancellationRequested)
                return;
            source.cancel();
        }, this.config.timeout);
        let highlights = await languages_1.default.getDocumentHighLight(doc.textDocument, position, source.token);
        clearTimeout(timer);
        if (source.token.isCancellationRequested)
            return null;
        return highlights;
    }
    cancel() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource.dispose();
            this.tokenSource = null;
        }
    }
    dispose() {
        if (this.timer)
            clearTimeout(this.timer);
        this.cancel();
        this.highlights.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Highlights;
//# sourceMappingURL=highlights.js.map