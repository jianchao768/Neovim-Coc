'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const fs_1 = require("../util/fs");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const buffer_1 = require("./buffer");
const collection_1 = tslib_1.__importDefault(require("./collection"));
const util_2 = require("./util");
class DiagnosticManager {
    constructor() {
        this._onDidRefresh = new protocol_1.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.enabled = true;
        this.collections = [];
        this.disposables = [];
    }
    init() {
        commands_1.default.register({
            id: 'workspace.diagnosticRelated',
            execute: () => this.jumpRelated()
        }, false, 'jump to related locations of current diagnostic.');
        this.defineSigns(workspace_1.default.initialConfiguration.get('diagnostic'));
        this.buffers = workspace_1.default.registerBufferSync(doc => {
            let buf = new buffer_1.DiagnosticBuffer(this.nvim, doc);
            buf.onDidRefresh(diagnostics => {
                this._onDidRefresh.fire({ diagnostics, uri: buf.uri, bufnr: buf.bufnr });
            });
            let diagnostics = this.getDiagnostics(buf);
            // ignore empty diagnostics on first time.
            if (Object.keys(diagnostics).length > 0 && buf.config.autoRefresh) {
                void buf.reset(diagnostics);
            }
            return buf;
        });
        workspace_1.default.onDidChangeConfiguration(e => {
            if (this.buffers && e.affectsConfiguration('diagnostic')) {
                for (let item of this.buffers.items) {
                    item.loadConfiguration();
                }
            }
        }, null, this.disposables);
        let config = workspace_1.default.initialConfiguration.get('diagnostic');
        events_1.default.on('CursorMoved', (bufnr, cursor) => {
            if (this.messageTimer)
                clearTimeout(this.messageTimer);
            this.messageTimer = setTimeout(() => {
                let buf = this.buffers.getItem(bufnr);
                if (buf == null || buf.dirty)
                    return;
                void Promise.allSettled([
                    buf.onCursorHold(cursor[0], cursor[1]),
                    buf.showVirtualTextCurrentLine(cursor[0])
                ]);
            }, config.messageDelay);
        }, null, this.disposables);
        events_1.default.on(['InsertEnter', 'BufEnter'], () => {
            clearTimeout(this.messageTimer);
        }, null, this.disposables);
        events_1.default.on('InsertLeave', bufnr => {
            let buf = this.buffers.getItem(bufnr);
            if (!buf || buf.config.refreshOnInsertMode)
                return;
            for (let buf of this.buffers.items) {
                buf.refreshHighlights();
            }
        }, null, this.disposables);
        events_1.default.on('BufWinEnter', (bufnr) => {
            let buf = this.buffers.getItem(bufnr);
            if (buf)
                buf.refreshHighlights();
        }, null, this.disposables);
        this.checkConfigurationErrors();
        workspace_1.default.configurations.onError(ev => {
            const collection = this.create('config');
            collection.set(ev.uri, ev.diagnostics);
        }, null, this.disposables);
    }
    checkConfigurationErrors() {
        const errors = workspace_1.default.configurations.errors;
        if (!(0, array_1.isFalsyOrEmpty)(errors)) {
            const collection = this.create('config');
            for (let [uri, diagnostics] of errors.entries()) {
                let fsPath = vscode_uri_1.URI.parse(uri).fsPath;
                void window_1.default.showErrorMessage(`Error detected for config file ${fsPath}, please check diagnostics list.`);
                collection.set(uri, diagnostics);
            }
        }
    }
    defineSigns(config) {
        let { nvim } = this;
        nvim.pauseNotification();
        for (let kind of ['Error', 'Warning', 'Info', 'Hint']) {
            let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
            let signText = config[kind.toLowerCase() + 'Sign'];
            if (signText)
                cmd += ` texthl=Coc${kind}Sign text=${signText}`;
            if (!constants_1.isVim && config.enableHighlightLineNumber)
                cmd += ` numhl=Coc${kind}Sign`;
            nvim.command(cmd, true);
        }
        nvim.resumeNotification(false, true);
    }
    getItem(bufnr) {
        return this.buffers.getItem(bufnr);
    }
    /**
     * Fill location list with diagnostics
     */
    async setLocationlist(bufnr) {
        let doc = workspace_1.default.getAttachedDocument(bufnr);
        let buf = this.buffers.getItem(doc.bufnr);
        let diagnostics = [];
        for (let diags of Object.values(this.getDiagnostics(buf))) {
            diagnostics.push(...diags);
        }
        let items = buf.toLocationListItems(diagnostics);
        await this.nvim.call('coc#ui#setloclist', [0, items, ' ', 'Diagnostics of coc']);
    }
    /**
     * Create collection by name
     */
    create(name) {
        let collection = this.getCollectionByName(name);
        if (collection)
            return collection;
        collection = new collection_1.default(name, () => {
            let idx = this.collections.findIndex(o => o == collection);
            if (idx !== -1)
                this.collections.splice(idx, 1);
        });
        this.collections.push(collection);
        collection.onDidDiagnosticsChange(uri => {
            var _a;
            let buf = (_a = this.buffers) === null || _a === void 0 ? void 0 : _a.getItem(uri);
            if (buf && buf.config.autoRefresh)
                void buf.update(name, this.getDiagnosticsByCollection(buf, collection));
        });
        return collection;
    }
    /**
     * Get diagnostics ranges from document
     */
    getSortedRanges(uri, minLevel, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level = severity ? (0, util_2.severityLevel)(severity) : 0;
        for (let collection of collections) {
            let diagnostics = collection.get(uri);
            if (level) {
                diagnostics = diagnostics.filter(o => o.severity == level);
            }
            else {
                if (minLevel && minLevel < vscode_languageserver_types_1.DiagnosticSeverity.Hint) {
                    diagnostics = diagnostics.filter(o => {
                        return o.severity && o.severity > minLevel ? false : true;
                    });
                }
            }
            let ranges = diagnostics.map(o => o.range);
            res.push(...ranges);
        }
        res.sort((a, b) => {
            if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
            }
            return a.start.character - b.start.character;
        });
        return res;
    }
    /**
     * Get readonly diagnostics for a buffer
     */
    getDiagnostics(buf) {
        let res = {};
        for (let collection of this.collections) {
            if (!collection.has(buf.uri))
                continue;
            res[collection.name] = this.getDiagnosticsByCollection(buf, collection);
        }
        return res;
    }
    /**
     * Get filtered diagnostics by collection.
     */
    getDiagnosticsByCollection(buf, collection) {
        var _a;
        // let config = this.buffers.getItem(uri)
        let { level, showUnused, showDeprecated } = buf.config;
        let items = (_a = collection.get(buf.uri)) !== null && _a !== void 0 ? _a : [];
        if (items.length) {
            items = items.filter(d => {
                var _a, _b;
                if (level && d.severity && d.severity > level) {
                    return false;
                }
                if (!showUnused && ((_a = d.tags) === null || _a === void 0 ? void 0 : _a.includes(vscode_languageserver_types_1.DiagnosticTag.Unnecessary))) {
                    return false;
                }
                if (!showDeprecated && ((_b = d.tags) === null || _b === void 0 ? void 0 : _b.includes(vscode_languageserver_types_1.DiagnosticTag.Deprecated))) {
                    return false;
                }
                return true;
            });
            items.sort((a, b) => {
                return (0, position_1.comparePosition)(a.range.start, b.range.start);
            });
        }
        return items;
    }
    getDiagnosticsInRange(document, range) {
        var _a;
        let res = [];
        for (let collection of this.collections) {
            for (let item of (_a = collection.get(document.uri)) !== null && _a !== void 0 ? _a : []) {
                if ((0, position_1.rangeIntersect)(item.range, range)) {
                    res.push(item);
                }
            }
        }
        return res;
    }
    /**
     * Show diagnostics under curosr in preview window
     */
    async preview() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (diagnostics.length == 0) {
            this.nvim.command('pclose', true);
            return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
            let { source, code, severity, message } = diagnostic;
            let s = (0, util_2.getSeverityName)(severity)[0];
            lines.push(`[${source}${code ? ' ' + code : ''}] [${s}]`);
            lines.push(...message.split(/\r?\n/));
            lines.push('');
        }
        this.nvim.call('coc#ui#preview_info', [lines, 'txt'], true);
    }
    async prepareJump(severity) {
        let bufnr = await this.nvim.call('bufnr', ['%']);
        let item = this.buffers.getItem(bufnr);
        if (!item)
            return;
        let ranges = this.getSortedRanges(item.uri, item.config.level, severity);
        if ((0, array_1.isFalsyOrEmpty)(ranges))
            return;
        let curpos = await window_1.default.getCursorPosition();
        let wrapscan = await this.nvim.getOption('wrapscan');
        return {
            item,
            curpos,
            wrapscan: wrapscan != 0,
            ranges
        };
    }
    /**
     * Jump to previous diagnostic position
     */
    async jumpPrevious(severity) {
        let result = await this.prepareJump(severity);
        if (!result)
            return;
        let { curpos, item, wrapscan, ranges } = result;
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
            let end = ranges[i].end;
            if ((0, position_1.comparePosition)(end, curpos) < 0) {
                pos = ranges[i].start;
                break;
            }
        }
        if (!pos && wrapscan)
            pos = ranges[ranges.length - 1].start;
        if (pos) {
            await window_1.default.moveTo(pos);
            await item.echoMessage(false, pos);
        }
        else {
            void window_1.default.showWarningMessage(`No more diagnostic before cursor position`);
        }
    }
    /**
     * Jump to next diagnostic position
     */
    async jumpNext(severity) {
        let result = await this.prepareJump(severity);
        if (!result)
            return;
        let { curpos, item, wrapscan, ranges } = result;
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
            let start = ranges[i].start;
            if ((0, position_1.comparePosition)(start, curpos) > 0) {
                // The position could be invalid (ex: exceed end of line)
                let arr = await this.nvim.call('coc#util#valid_position', [start.line, start.character]);
                if ((arr[0] != start.line || arr[1] != start.character)
                    && (0, position_1.comparePosition)(vscode_languageserver_types_1.Position.create(arr[0], arr[1]), curpos) <= 0) {
                    continue;
                }
                pos = vscode_languageserver_types_1.Position.create(arr[0], arr[1]);
                break;
            }
        }
        if (!pos && wrapscan)
            pos = ranges[0].start;
        if (pos) {
            await window_1.default.moveTo(pos);
            await item.echoMessage(false, pos);
        }
        else {
            void window_1.default.showWarningMessage(`No more diagnostic after cursor position`);
        }
    }
    /**
     * Get all sorted diagnostics
     */
    async getDiagnosticList() {
        var _a, _b, _c, _d;
        let res = [];
        let config = workspace_1.default.getConfiguration('diagnostic');
        let level = (0, util_2.severityLevel)(config.get('level', 'hint'));
        for (let collection of this.collections) {
            for (let [uri, diagnostics] of collection.entries()) {
                if (diagnostics.length == 0)
                    continue;
                let u = vscode_uri_1.URI.parse(uri);
                let doc = workspace_1.default.getDocument(uri);
                let lines = doc && doc.attached ? doc.textDocument.lines : undefined;
                if (!lines && u.scheme === 'file') {
                    try {
                        const max = diagnostics.reduce((p, c) => {
                            return Math.max(c.range.end.line, p);
                        }, 0);
                        lines = await (0, fs_1.readFileLines)(u.fsPath, 0, max);
                    }
                    catch (e) { }
                }
                for (let diagnostic of diagnostics) {
                    if (diagnostic.severity && diagnostic.severity > level)
                        continue;
                    let { start, end } = diagnostic.range;
                    let o = {
                        file: u.fsPath,
                        lnum: start.line + 1,
                        end_lnum: end.line + 1,
                        col: Array.isArray(lines) ? (0, string_1.byteIndex)((_a = lines[start.line]) !== null && _a !== void 0 ? _a : '', start.character) + 1 : start.character + 1,
                        end_col: Array.isArray(lines) ? (0, string_1.byteIndex)((_b = lines[end.line]) !== null && _b !== void 0 ? _b : '', end.character) + 1 : end.character + 1,
                        code: diagnostic.code,
                        source: (_c = diagnostic.source) !== null && _c !== void 0 ? _c : collection.name,
                        message: diagnostic.message,
                        severity: (0, util_2.getSeverityName)(diagnostic.severity),
                        level: (_d = diagnostic.severity) !== null && _d !== void 0 ? _d : 0,
                        location: vscode_languageserver_types_1.Location.create(uri, diagnostic.range)
                    };
                    res.push(o);
                }
            }
        }
        res.sort((a, b) => {
            if (a.level !== b.level) {
                return a.level - b.level;
            }
            if (a.file !== b.file) {
                return a.file > b.file ? 1 : -1;
            }
            else {
                if (a.lnum != b.lnum) {
                    return a.lnum - b.lnum;
                }
                return a.col - b.col;
            }
        });
        return res;
    }
    async getBufferAndPosition() {
        let [bufnr, lnum, col] = await this.nvim.eval(`[bufnr("%"),line('.'),col('.')]`);
        let item = this.buffers.getItem(bufnr);
        if (!item)
            return;
        let pos = item.doc.getPosition(lnum, col);
        return [item, pos];
    }
    async getCurrentDiagnostics() {
        let res = await this.getBufferAndPosition();
        if (!res)
            return;
        return res[0].getDiagnosticsAtPosition(res[1]);
    }
    async echoCurrentMessage() {
        let res = await this.getBufferAndPosition();
        if (!res)
            return;
        let [item, position] = res;
        await item.echoMessage(false, position);
    }
    async jumpRelated() {
        let diagnostics = await this.getCurrentDiagnostics();
        let diagnostic = diagnostics.find(o => o.relatedInformation != null);
        let locations = diagnostic ? diagnostic.relatedInformation.map(o => o.location) : [];
        if (locations.length == 1) {
            await workspace_1.default.jumpTo(locations[0].uri, locations[0].range.start);
        }
        else if (locations.length > 1) {
            await workspace_1.default.showLocations(locations);
        }
        else {
            void window_1.default.showWarningMessage('No related information found.');
        }
    }
    reset() {
        clearTimeout(this.messageTimer);
        this.buffers.reset();
        for (let collection of this.collections) {
            collection.dispose();
        }
        this.collections = [];
    }
    dispose() {
        clearTimeout(this.messageTimer);
        this.buffers.dispose();
        for (let collection of this.collections) {
            collection.dispose();
        }
        this.collections = [];
        (0, util_1.disposeAll)(this.disposables);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    getCollectionByName(name) {
        return this.collections.find(o => o.name == name);
    }
    getCollections(uri) {
        return this.collections.filter(c => c.has(uri));
    }
    async toggleDiagnostic(enable) {
        this.enabled = enable == undefined ? !this.enabled : enable != 0;
        await Promise.allSettled(this.buffers.items.map(buf => {
            return buf.setState(this.enabled);
        }));
    }
    async toggleDiagnosticBuffer(bufnr, enable) {
        bufnr = bufnr !== null && bufnr !== void 0 ? bufnr : workspace_1.default.bufnr;
        let buf = this.buffers.getItem(bufnr);
        if (buf) {
            let isEnabled = enable == undefined ? await buf.isEnabled() : enable == 0;
            await this.nvim.call('setbufvar', [bufnr, 'coc_diagnostic_disable', isEnabled ? 1 : 0]);
            await buf.setState(!isEnabled);
        }
    }
    /**
     * Refresh diagnostics by uri or bufnr
     */
    async refreshBuffer(uri) {
        let buf = this.buffers.getItem(uri);
        if (!buf)
            return false;
        await buf.reset(this.getDiagnostics(buf));
        return true;
    }
    /**
     * Force diagnostics refresh.
     */
    async refresh(bufnr) {
        let items;
        if (!bufnr) {
            items = this.buffers.items;
        }
        else {
            let item = this.buffers.getItem(bufnr);
            items = item ? [item] : [];
        }
        for (let item of items) {
            await this.refreshBuffer(item.uri);
        }
    }
}
exports.default = new DiagnosticManager();
//# sourceMappingURL=manager.js.map