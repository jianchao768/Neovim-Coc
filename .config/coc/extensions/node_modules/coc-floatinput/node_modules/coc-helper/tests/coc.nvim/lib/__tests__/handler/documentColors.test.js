"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const color_1 = require("../../util/color");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const path_1 = tslib_1.__importDefault(require("path"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const events_1 = tslib_1.__importDefault(require("../../events"));
let nvim;
let state = 'normal';
let colors;
let disposables = [];
let colorPresentations = [];
let disposable;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    await nvim.command(`source ${path_1.default.join(process.cwd(), 'autoload/coc/color.vim')}`);
    colors = helper_1.default.plugin.getHandler().colors;
    disposable = languages_1.default.registerDocumentColorProvider([{ language: '*' }], {
        provideColorPresentations: (_color, _context, _token) => colorPresentations,
        provideDocumentColors: (document, _token) => {
            if (state == 'empty')
                return [];
            if (state == 'error')
                return Promise.reject(new Error('no color'));
            let matches = Array.from(document.getText().matchAll(/#\w{6}/g));
            return matches.map(o => {
                let start = document.positionAt(o.index);
                let end = document.positionAt(o.index + o[0].length);
                return {
                    range: vscode_languageserver_protocol_1.Range.create(start, end),
                    color: getColor(255, 255, 255)
                };
            });
        }
    });
});
beforeEach(() => {
    helper_1.default.updateConfiguration('colors.filetypes', ['*']);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    state = 'normal';
    colorPresentations = [];
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
function getColor(r, g, b) {
    return { red: r / 255, green: g / 255, blue: b / 255, alpha: 1 };
}
describe('Colors', () => {
    describe('utils', () => {
        it('should get hex string', () => {
            let color = getColor(255, 255, 255);
            let hex = (0, color_1.toHexString)(color);
            expect(hex).toBe('ffffff');
        });
    });
    describe('configuration', () => {
        it('should toggle enable state on configuration change', async () => {
            let doc = await helper_1.default.createDocument();
            helper_1.default.updateConfiguration('colors.filetypes', []);
            let enabled = colors.isEnabled(doc.bufnr);
            expect(enabled).toBe(false);
            helper_1.default.updateConfiguration('colors.enable', true);
            enabled = colors.isEnabled(doc.bufnr);
            expect(enabled).toBe(true);
            helper_1.default.updateConfiguration('colors.enable', false);
            enabled = colors.isEnabled(doc.bufnr);
            expect(enabled).toBe(false);
        });
    });
    describe('commands', () => {
        it('should register editor.action.pickColor command', async () => {
            await helper_1.default.mockFunction('coc#color#pick_color', [0, 0, 0]);
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            doc.forceSync();
            await colors.doHighlight(doc.bufnr);
            await commands_1.default.executeCommand('editor.action.pickColor');
            let line = await nvim.getLine();
            expect(line).toBe('#000000');
        });
        it('should register editor.action.colorPresentation command', async () => {
            colorPresentations = [vscode_languageserver_protocol_1.ColorPresentation.create('red'), vscode_languageserver_protocol_1.ColorPresentation.create('#ff0000')];
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            await doc.synchronize();
            await colors.doHighlight(doc.bufnr);
            let p = commands_1.default.executeCommand('editor.action.colorPresentation');
            await helper_1.default.waitPrompt();
            await nvim.input('1');
            await p;
            let line = await nvim.getLine();
            expect(line).toBe('red');
        });
        it('should register document.toggleColors command', async () => {
            helper_1.default.updateConfiguration('colors.filetypes', []);
            helper_1.default.updateConfiguration('colors.enable', true);
            let doc = await workspace_1.default.document;
            await events_1.default.fire('BufUnload', [doc.bufnr]);
            await expect(async () => {
                await commands_1.default.executeCommand('document.toggleColors');
            }).rejects.toThrow(Error);
            doc = await helper_1.default.createDocument();
            expect(colors.isEnabled(doc.bufnr)).toBe(true);
            await commands_1.default.executeCommand('document.toggleColors');
            let enabled = colors.isEnabled(doc.bufnr);
            expect(enabled).toBe(false);
            await commands_1.default.executeCommand('document.toggleColors');
            enabled = colors.isEnabled(doc.bufnr);
            expect(enabled).toBe(true);
        });
    });
    describe('doHighlight', () => {
        it('should merge colors of providers', async () => {
            disposables.push(languages_1.default.registerDocumentColorProvider([{ language: '*' }], {
                provideColorPresentations: () => colorPresentations,
                provideDocumentColors: () => {
                    return [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0),
                            color: getColor(0, 0, 0)
                        }, {
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 7),
                            color: getColor(1, 1, 1)
                        }];
                }
            }));
            disposables.push(languages_1.default.registerDocumentColorProvider([{ language: '*' }], {
                provideColorPresentations: () => colorPresentations,
                provideDocumentColors: () => {
                    return null;
                }
            }));
            let doc = await workspace_1.default.document;
            await nvim.setLine('#ffffff #ff0000');
            await doc.synchronize();
            let colors = await languages_1.default.provideDocumentColors(doc.textDocument, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(colors.length).toBe(3);
            let color = vscode_languageserver_protocol_1.ColorInformation.create(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0), getColor(0, 0, 0));
            let presentation = await languages_1.default.provideColorPresentations(color, doc.textDocument, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(presentation).toEqual([]);
        });
        it('should clearHighlight on empty result', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            state = 'empty';
            await colors.doHighlight(doc.bufnr);
            let res = colors.hasColor(doc.bufnr);
            expect(res).toBe(false);
        });
        it('should highlight after ColorScheme event', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff #ff0000');
            await doc.synchronize();
            await colors.doHighlight(doc.bufnr);
            await events_1.default.fire('ColorScheme', []);
            expect(colors.hasColor(doc.bufnr)).toBe(true);
        });
        it('should not throw on error result', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            state = 'error';
            let err;
            try {
                await colors.doHighlight(doc.bufnr);
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeUndefined();
        });
        it('should highlight after document changed', async () => {
            let doc = await helper_1.default.createDocument();
            await colors.doHighlight(doc.bufnr);
            expect(colors.hasColor(doc.bufnr)).toBe(false);
            expect(colors.hasColorAtPosition(doc.bufnr, vscode_languageserver_protocol_1.Position.create(0, 1))).toBe(false);
            await nvim.setLine('#ffffff #ff0000');
            await doc.synchronize();
            await helper_1.default.waitValue(() => {
                return colors.hasColorAtPosition(doc.bufnr, vscode_languageserver_protocol_1.Position.create(0, 1));
            }, true);
            expect(colors.hasColor(doc.bufnr)).toBe(true);
        });
        it('should clearHighlight on clearHighlight', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff #ff0000');
            await doc.synchronize();
            await colors.doHighlight(doc.bufnr);
            expect(colors.hasColor(doc.bufnr)).toBe(true);
            colors.clearHighlight(doc.bufnr);
            expect(colors.hasColor(doc.bufnr)).toBe(false);
        });
        it('should highlight colors', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            await colors.doHighlight(doc.bufnr);
            let exists = await nvim.call('hlexists', 'BGffffff');
            expect(exists).toBe(1);
        });
    });
    describe('hasColor()', () => {
        it('should return false when bufnr does not exist', async () => {
            let res = colors.hasColor(99);
            colors.clearHighlight(99);
            expect(res).toBe(false);
        });
    });
    describe('getColorInformation()', () => {
        it('should return null when highlighter does not exist', async () => {
            let res = await colors.getColorInformation(99);
            expect(res).toBe(null);
        });
        it('should return null when color not found', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff foo ');
            doc.forceSync();
            await colors.doHighlight(doc.bufnr);
            await nvim.call('cursor', [1, 12]);
            let res = await colors.getColorInformation(doc.bufnr);
            expect(res).toBe(null);
        });
    });
    describe('hasColorAtPosition()', () => {
        it('should return false when bufnr does not exist', async () => {
            let res = colors.hasColorAtPosition(99, vscode_languageserver_protocol_1.Position.create(0, 0));
            expect(res).toBe(false);
        });
    });
    describe('pickPresentation()', () => {
        it('should show warning when color does not exist', async () => {
            await helper_1.default.createDocument();
            await colors.pickPresentation();
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('Color not found');
        });
        it('should not throw when presentations do not exist', async () => {
            colorPresentations = [];
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            doc.forceSync();
            await colors.doHighlight(99);
            await colors.doHighlight(doc.bufnr);
            await helper_1.default.doAction('colorPresentation');
        });
        it('should pick presentations', async () => {
            colorPresentations = [vscode_languageserver_protocol_1.ColorPresentation.create('red'), vscode_languageserver_protocol_1.ColorPresentation.create('#ff0000')];
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            doc.forceSync();
            await colors.doHighlight(doc.bufnr);
            let p = helper_1.default.doAction('colorPresentation');
            await helper_1.default.waitPrompt();
            await nvim.input('1');
            await p;
            let line = await nvim.getLine();
            expect(line).toBe('red');
        });
    });
    describe('pickColor()', () => {
        it('should show warning when color does not exist', async () => {
            await helper_1.default.createDocument();
            await colors.pickColor();
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('not found');
        });
        it('should pickColor', async () => {
            await helper_1.default.mockFunction('coc#color#pick_color', [0, 0, 0]);
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            doc.forceSync();
            await colors.doHighlight(doc.bufnr);
            await helper_1.default.doAction('pickColor');
            let line = await nvim.getLine();
            expect(line).toBe('#000000');
        });
        it('should not throw when pick color return 0', async () => {
            await helper_1.default.mockFunction('coc#color#pick_color', 0);
            let doc = await helper_1.default.createDocument();
            await nvim.setLine('#ffffff');
            doc.forceSync();
            await colors.doHighlight(doc.bufnr);
            await helper_1.default.doAction('pickColor');
            let line = await nvim.getLine();
            expect(line).toBe('#ffffff');
        });
        it('should return null when provider not exists', async () => {
            disposable.dispose();
            let doc = await workspace_1.default.document;
            let color = vscode_languageserver_protocol_1.ColorInformation.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 6), vscode_languageserver_protocol_1.Color.create(100, 100, 100, 0));
            let res = await languages_1.default.provideColorPresentations(color, doc.textDocument, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
    });
});
//# sourceMappingURL=documentColors.test.js.map