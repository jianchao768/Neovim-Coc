"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const chars_1 = require("../../model/chars");
const helper_1 = require("../helper");
describe('funcs', () => {
    it('should splitKeywordsOptions', () => {
        expect((0, chars_1.splitKeywordOption)('')).toEqual([]);
        expect((0, chars_1.splitKeywordOption)('_,-,128-140,#-43')).toEqual(['_', '-', '128-140', '#-43']);
        expect((0, chars_1.splitKeywordOption)('^a-z,#,^')).toEqual(['^a-z', '#', '^']);
        expect((0, chars_1.splitKeywordOption)('@,^a-z')).toEqual(['@', '^a-z']);
        expect((0, chars_1.splitKeywordOption)('48-57,,,_')).toEqual(['48-57', ',', '_']);
        expect((0, chars_1.splitKeywordOption)(' -~,^,,9')).toEqual([' -~', '^,', '9']);
        expect((0, chars_1.splitKeywordOption)(' -~,^,')).toEqual([' -~', '^,']);
    });
    it('should toCharCode', () => {
        expect((0, chars_1.getCharCode)('10')).toBe(10);
        expect((0, chars_1.getCharCode)('')).toBeUndefined();
        expect((0, chars_1.getCharCode)('a')).toBe(97);
    });
    it('should sameScope', () => {
        expect((0, chars_1.sameScope)(1, 3)).toBe(true);
        expect((0, chars_1.sameScope)(266, 1024)).toBe(true);
        expect((0, chars_1.sameScope)(97, 19970)).toBe(false);
    });
    it('should chineseSegments', () => {
        let res = Array.from((0, chars_1.chineseSegments)('ä½ å¥½ä¸–ç•Œ'));
        expect(Array.isArray(res)).toBe(true);
        let fn = Intl['Segmenter'];
        if (typeof fn === 'function') {
            Object.defineProperty(Intl, 'Segmenter', {
                get: () => {
                    return undefined;
                }
            });
            res = Array.from((0, chars_1.chineseSegments)('ä½ å¥½ä¸–ç•Œ'));
            Object.defineProperty(Intl, 'Segmenter', {
                get: () => {
                    return fn;
                }
            });
            expect(res).toEqual(['ä½ å¥½ä¸–ç•Œ']);
        }
    });
});
describe('IntegerRanges', () => {
    it('should add ranges', () => {
        let r = new chars_1.IntegerRanges();
        expect(r.flatten()).toEqual([]);
        r.add(4, 3);
        r.add(1);
        r.add(2);
        expect(r.flatten()).toEqual([1, 1, 2, 2, 3, 4]);
        r.add(2, 7);
        expect(r.flatten()).toEqual([1, 1, 2, 7]);
        r.add(7, 9);
        expect(r.flatten()).toEqual([1, 1, 2, 9]);
        r.add(2, 5);
        expect(r.flatten()).toEqual([1, 1, 2, 9]);
    });
    it('should exclude ranges', () => {
        let r = new chars_1.IntegerRanges();
        r.add(1, 2);
        r.add(4, 6);
        r.exclude(3, 3);
        r.exclude(8);
        r.exclude(9, 10);
        expect(r.flatten()).toEqual([1, 2, 4, 6]);
        r.exclude(4, 6);
        r.exclude(1, 2);
        expect(r.flatten()).toEqual([]);
        r.add(3, 8);
        r.exclude(1, 3);
        r.exclude(8, 9);
        expect(r.flatten()).toEqual([4, 7]);
        r.exclude(6, 5);
        expect(r.flatten()).toEqual([4, 4, 7, 7]);
        expect(r.includes(4)).toBe(true);
        expect(r.includes(7)).toBe(true);
    });
    it('should check word code', () => {
        let r = new chars_1.IntegerRanges([], true);
        expect(r.includes(258)).toBe(true);
        expect(r.includes(894)).toBe(false);
        expect(r.includes(33)).toBe(false);
    });
    it('should fromKeywordOption', () => {
        let r = chars_1.IntegerRanges.fromKeywordOption('@,_');
        expect(r.includes(97)).toBe(true);
        expect(r.includes('_'.charCodeAt(0))).toBe(true);
        r = chars_1.IntegerRanges.fromKeywordOption('@-@,9,^');
        expect(r.includes(9)).toBe(true);
        expect(r.includes('@'.charCodeAt(0))).toBe(true);
        expect(r.includes('^'.charCodeAt(0))).toBe(true);
        r = chars_1.IntegerRanges.fromKeywordOption('@,^a-z');
        expect(r.includes(97)).toBe(false);
        r = chars_1.IntegerRanges.fromKeywordOption('48-57,,,_');
        expect(r.includes(48)).toBe(true);
        expect(r.includes(','.charCodeAt(0))).toBe(true);
        expect(r.includes('_'.charCodeAt(0))).toBe(true);
        r = chars_1.IntegerRanges.fromKeywordOption('_,-,128-140,#-43');
        expect(r.includes(130)).toBe(true);
        expect(r.includes(43)).toBe(true);
        expect(r.includes('_'.charCodeAt(0))).toBe(true);
        expect(r.includes('-'.charCodeAt(0))).toBe(true);
        expect(r.includes('#'.charCodeAt(0))).toBe(true);
        r = chars_1.IntegerRanges.fromKeywordOption(' -~,^,,9');
        expect(r.includes(' '.charCodeAt(0))).toBe(true);
        expect(r.includes(','.charCodeAt(0))).toBe(false);
        expect(r.includes(9)).toBe(true);
        r = chars_1.IntegerRanges.fromKeywordOption('65,-x,x-');
        expect(r.includes(65)).toBe(true);
        r = chars_1.IntegerRanges.fromKeywordOption('128-140,-');
        expect(r.includes('-'.charCodeAt(0))).toBe(true);
    });
});
describe('chars', () => {
    describe('isKeywordChar()', () => {
        it('should match @', () => {
            let chars = new chars_1.Chars('@');
            expect(chars.isKeywordChar('a')).toBe(true);
            expect(chars.isKeywordChar('z')).toBe(true);
            expect(chars.isKeywordChar('A')).toBe(true);
            expect(chars.isKeywordChar('Z')).toBe(true);
            expect(chars.isKeywordChar('\u205f')).toBe(false);
        });
        it('should iterateWords', async () => {
            let chars = new chars_1.Chars('@');
            let res = Array.from(chars.iterateWords(' ä½ å¥½foo bar'));
            expect(res).toEqual([[1, 3], [3, 6], [7, 10]]);
        });
        it('should match code range', () => {
            let chars = new chars_1.Chars('48-57');
            expect(chars.isKeywordChar('0')).toBe(true);
            expect(chars.isKeywordChar('9')).toBe(true);
        });
        it('should match @-@', () => {
            let chars = new chars_1.Chars('@-@');
            expect(chars.isKeywordChar('@')).toBe(true);
        });
        it('should match single code', () => {
            let chars = new chars_1.Chars('58');
            expect(chars.isKeywordChar(':')).toBe(true);
        });
        it('should match single character', () => {
            let chars = new chars_1.Chars('_');
            expect(chars.isKeywordChar('_')).toBe(true);
        });
    });
    describe('addKeyword()', () => {
        it('should add keyword', () => {
            let chars = new chars_1.Chars('_');
            chars.addKeyword(':');
            expect(chars.isKeywordChar(':')).toBe(true);
            chars.addKeyword(':');
            expect(chars.isKeywordChar(':')).toBe(true);
        });
    });
    describe('computeWordRanges()', () => {
        it('should computeWordRanges', async () => {
            let chars = new chars_1.Chars('@');
            let res = await chars.computeWordRanges(['abc def hijkl'], vscode_languageserver_protocol_1.Range.create(0, 4, 0, 7));
            expect(res).toEqual({
                def: [
                    {
                        start: {
                            line: 0,
                            character: 4
                        },
                        end: {
                            line: 0,
                            character: 7
                        }
                    }
                ]
            });
            res = await chars.computeWordRanges(['abc def ', 'foo def', ' ', ' abc'], vscode_languageserver_protocol_1.Range.create(0, 3, 4, 0));
            expect(Object.keys(res)).toEqual(['def', 'foo', 'abc']);
            const r = (sl, sc, el, ec) => {
                return vscode_languageserver_protocol_1.Range.create(sl, sc, el, ec);
            };
            expect(res['def']).toEqual([r(0, 4, 0, 7), r(1, 4, 1, 7)]);
            expect(res['foo']).toEqual([r(1, 0, 1, 3)]);
            expect(res['abc']).toEqual([r(3, 1, 3, 4)]);
        });
        it('should wait after timeout', async () => {
            let l = (0, helper_1.makeLine)(200);
            let arr = [];
            for (let i = 0; i < 8000; i++) {
                arr.push(l);
            }
            let chars = new chars_1.Chars('@');
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let timer = setTimeout(() => {
                tokenSource.cancel();
            }, 30);
            await chars.computeWordRanges(arr, vscode_languageserver_protocol_1.Range.create(0, 0, 8000, 0), tokenSource.token);
            clearTimeout(timer);
            expect(tokenSource.token.isCancellationRequested).toBe(true);
        });
    });
    describe('matchLine()', () => {
        it('should matchLine', async () => {
            let text = 'a'.repeat(2048);
            let chars = new chars_1.Chars('@');
            expect(chars.matchLine(text, 3, 128)).toEqual(['a'.repeat(128)]);
            expect(chars.matchLine('a b c')).toEqual([]);
            expect(chars.matchLine('foo bar')).toEqual(['foo', 'bar']);
            expect(chars.matchLine('?foo bar')).toEqual(['foo', 'bar']);
            expect(chars.matchLine('?foo $')).toEqual(['foo']);
            expect(chars.matchLine('?foo foo foo')).toEqual(['foo']);
            expect(chars.matchLine(' ä½ å¥½foo')).toEqual(['ä½ å¥½', 'foo']);
            expect(chars.matchLine('barä½ å¥½')).toEqual(['bar', 'ä½ å¥½']);
            expect(chars.matchLine('ä½ å¥½ï¼Œä¸–ç•Œã€‚')).toEqual(['ä½ å¥½', 'ä¸–ç•Œ']);
            expect(chars.matchLine('fooðŸ˜bar fooï¼Œbar')).toEqual(['foo', 'bar']);
        });
    });
    describe('iskeyword()', () => {
        it('should check isKeyword', () => {
            let chars = new chars_1.Chars('@');
            expect(chars.isKeyword('foo')).toBe(true);
            expect(chars.isKeyword('f@')).toBe(false);
        });
    });
});
//# sourceMappingURL=chars.test.js.map