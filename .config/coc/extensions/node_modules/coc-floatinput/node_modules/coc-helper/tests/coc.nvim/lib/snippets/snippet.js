'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.comparePlaceholder = exports.shouldFormat = exports.normalizeSnippetString = exports.getParts = exports.getEndPosition = exports.checkContentBefore = exports.checkCursor = exports.reduceTextEdit = exports.getContentBefore = exports.CocSnippet = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const util_1 = require("../util");
const position_1 = require("../util/position");
const textedit_1 = require("../util/textedit");
const eval_1 = require("./eval");
const Snippets = tslib_1.__importStar(require("./parser"));
class CocSnippet {
    constructor(snippetString, position, nvim, resolver) {
        this.snippetString = snippetString;
        this.position = position;
        this.nvim = nvim;
        this.resolver = resolver;
    }
    async init(ultisnip, isResolve = false) {
        const matchCode = ultisnip ? (0, eval_1.prepareMatchCode)(ultisnip) : undefined;
        const parser = new Snippets.SnippetParser(!!ultisnip, matchCode);
        const snippet = parser.parse(this.snippetString, true);
        this.tmSnippet = snippet;
        await this.resolve(ultisnip);
        this.synchronize();
        if (!isResolve) {
            this.nvim.call('coc#compat#del_var', ['coc_selected_text'], true);
            this.nvim.call('coc#compat#del_var', ['coc_last_placeholder'], true);
        }
    }
    async resolve(ultisnip) {
        let { snippet } = this.tmSnippet;
        let { resolver, nvim } = this;
        if (resolver) {
            await snippet.resolveVariables(resolver);
        }
        if (ultisnip && ultisnip.noPython !== true) {
            let pyCodes = [];
            if (snippet.hasPython)
                pyCodes = (0, eval_1.preparePythonCodes)(ultisnip);
            await snippet.evalCodeBlocks(nvim, pyCodes);
        }
    }
    getRanges(placeholder) {
        let marker = placeholder.marker;
        if (placeholder.value.length == 0)
            return [];
        let placeholders = this._placeholders.filter(o => o.index == placeholder.index);
        let ranges = placeholders.map(o => o.range);
        let parents = this.tmSnippet.enclosingPlaceholders(marker);
        let markers;
        let p = marker.parent;
        if (marker instanceof Snippets.Placeholder) {
            let index = marker.index;
            markers = this.tmSnippet.placeholders.filter(o => o.index == index && o.parent == p);
        }
        else {
            let name = marker.name;
            markers = this.tmSnippet.variables.filter(o => o.name == name && o.parent == p);
        }
        parents.forEach(p => {
            let arr = this._placeholders.filter(o => o.index == p.index && o.marker !== p);
            if (!arr.length)
                return;
            for (let m of markers) {
                let before = this.tmSnippet.getTextBefore(m, p);
                arr.forEach(item => {
                    if (item.transform) {
                        ranges.push(item.range);
                    }
                    else {
                        let s = item.range.start;
                        ranges.push(vscode_languageserver_types_1.Range.create((0, position_1.getEnd)(s, before), (0, position_1.getEnd)(s, before + m.toString())));
                    }
                });
            }
        });
        return ranges.filter(r => !(0, position_1.emptyRange)(r));
    }
    getSortedPlaceholders(curr) {
        let res = curr ? [curr] : [];
        let arr = this._placeholders.filter(o => o !== curr && !o.transform);
        arr.sort(comparePlaceholder);
        res.push(...arr);
        return res;
    }
    get hasPython() {
        return this.tmSnippet.pyBlocks.length > 0;
    }
    resetStartPosition(pos) {
        this.position = pos;
        this.synchronize();
    }
    get start() {
        return Object.assign({}, this.position);
    }
    get range() {
        return vscode_languageserver_types_1.Range.create(this.position, (0, position_1.getEnd)(this.position, this._text));
    }
    get text() {
        return this._text;
    }
    get finalCount() {
        return this._placeholders.filter(o => o.index == 0).length;
    }
    get placeholders() {
        return this._placeholders.map(o => o.marker);
    }
    get firstPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
            if (p.index == 0 || p.transform)
                continue;
            if (index == 0 || p.index < index) {
                index = p.index;
            }
        }
        return this.getPlaceholder(index);
    }
    getPlaceholderByMarker(marker) {
        return this._placeholders.find(o => o.marker === marker);
    }
    getPlaceholder(index) {
        let filtered = this._placeholders.filter(o => o.index == index && !o.transform);
        let find = filtered.find(o => o.primary);
        return (0, util_1.defaultValue)(find, filtered[0]);
    }
    getPrevPlaceholder(index) {
        if (index <= 1)
            return undefined;
        let placeholders = this._placeholders.filter(o => o.index < index && o.index != 0 && !o.transform);
        let find;
        while (index > 1) {
            index = index - 1;
            let arr = placeholders.filter(o => o.index == index);
            if (arr.length) {
                find = (0, util_1.defaultValue)(arr.find(o => o.primary), arr[0]);
                break;
            }
        }
        return find;
    }
    getNextPlaceholder(index) {
        let placeholders = this._placeholders.filter(o => !o.transform);
        let find;
        let indexes = placeholders.map(o => o.index);
        let max = Math.max.apply(null, indexes);
        for (let i = index + 1; i <= max + 1; i++) {
            let idx = i == max + 1 ? 0 : i;
            let arr = placeholders.filter(o => o.index == idx);
            if (arr.length) {
                find = arr.find(o => o.primary) || arr[0];
                break;
            }
        }
        return find;
    }
    getPlaceholderByRange(range) {
        return this._placeholders.find(o => (0, position_1.rangeInRange)(range, o.range));
    }
    async insertSnippet(placeholder, snippet, parts, ultisnip) {
        if (ultisnip) {
            let { start, end } = placeholder.range;
            this.nvim.setVar('coc_last_placeholder', {
                current_text: placeholder.value,
                start: { line: start.line, col: start.character, character: start.character },
                end: { line: end.line, col: end.character, character: end.character }
            }, true);
        }
        let select = this.tmSnippet.insertSnippet(snippet, placeholder.marker, parts, ultisnip);
        await this.resolve(ultisnip);
        this.synchronize();
        return select;
    }
    /**
     * Check newText for placeholder.
     */
    getNewText(placeholder, inserted) {
        let { before, after } = placeholder;
        if (!inserted.startsWith(before))
            return undefined;
        if (inserted.length < before.length + after.length)
            return undefined;
        if (!inserted.endsWith(after))
            return undefined;
        if (!after.length)
            return inserted.slice(before.length);
        return inserted.slice(before.length, -after.length);
    }
    async updatePlaceholder(placeholder, cursor, newText, token) {
        let start = this.position;
        let { marker, before } = placeholder;
        let cloned = this.tmSnippet.clone();
        token.onCancellationRequested(() => {
            this.tmSnippet = cloned;
            this.synchronize();
        });
        // range before placeholder
        let r = vscode_languageserver_types_1.Range.create(start, (0, position_1.getEnd)(start, before));
        await this.tmSnippet.update(this.nvim, marker, newText);
        if (token.isCancellationRequested)
            return undefined;
        this.synchronize();
        let after = this.getTextBefore(marker, before);
        return { text: this._text, delta: (0, textedit_1.getChangedPosition)(cursor, vscode_languageserver_types_1.TextEdit.replace(r, after)) };
    }
    getTextBefore(marker, defaultValue) {
        let placeholder = this._placeholders.find(o => o.marker == marker);
        if (placeholder)
            return placeholder.before;
        return defaultValue;
    }
    removeText(offset, length) {
        let succeed = this.tmSnippet.deleteText(offset, length);
        if (succeed)
            this.synchronize();
        return succeed;
    }
    synchronize() {
        const snippet = this.tmSnippet;
        const { line, character } = this.position;
        const document = vscode_languageserver_textdocument_1.TextDocument.create('untitled:/1', 'snippet', 0, snippet.toString());
        let { placeholders, variables, maxIndexNumber } = snippet;
        const variableIndexMap = new Map();
        let variableIndex = maxIndexNumber + 1;
        this._placeholders = [...placeholders, ...variables].map(p => {
            const offset = snippet.offset(p);
            const position = document.positionAt(offset);
            const start = {
                line: line + position.line,
                character: position.line == 0 ? character + position.character : position.character
            };
            let index;
            if (p instanceof Snippets.Variable) {
                let key = p.name;
                if (variableIndexMap.has(key)) {
                    index = variableIndexMap.get(key);
                }
                else {
                    variableIndexMap.set(key, variableIndex);
                    index = variableIndex;
                    variableIndex = variableIndex + 1;
                }
            }
            else {
                index = p.index;
            }
            const value = p.toString();
            const end = (0, position_1.getEnd)(position, value);
            let res = {
                index,
                value,
                marker: p,
                transform: !!p.transform,
                range: vscode_languageserver_types_1.Range.create(start, (0, position_1.getEnd)(start, value)),
                before: document.getText(vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), position)),
                after: document.getText(vscode_languageserver_types_1.Range.create(end, vscode_languageserver_types_1.Position.create(document.lineCount, 0))),
                primary: p instanceof Snippets.Placeholder && p.primary === true
            };
            return res;
        });
        this._text = this.tmSnippet.toString();
    }
}
exports.CocSnippet = CocSnippet;
/**
 * Current line text before marker
 */
function getContentBefore(marker) {
    let res = '';
    const calc = (m) => {
        let p = m.parent;
        if (!p)
            return;
        let s = '';
        for (let b of p.children) {
            if (b === m)
                break;
            s = s + b.toString();
        }
        if (s.indexOf('\n') !== -1) {
            let arr = s.split(/\n/);
            res = arr[arr.length - 1] + res;
            return;
        }
        res = s + res;
        calc(p);
    };
    calc(marker);
    return res;
}
exports.getContentBefore = getContentBefore;
/*
 * Avoid change unnecessary range of text.
 */
function reduceTextEdit(edit, oldText) {
    let { range, newText } = edit;
    let ol = oldText.length;
    let nl = newText.length;
    if (ol === 0 || nl === 0)
        return edit;
    let { start, end } = range;
    let bo = 0;
    for (let i = 1; i <= Math.min(nl, ol); i++) {
        if (newText[i - 1] === oldText[i - 1]) {
            bo = i;
        }
        else {
            break;
        }
    }
    let eo = 0;
    let t = Math.min(nl - bo, ol - bo);
    if (t > 0) {
        for (let i = 1; i <= t; i++) {
            if (newText[nl - i] === oldText[ol - i]) {
                eo = i;
            }
            else {
                break;
            }
        }
    }
    let text = eo == 0 ? newText.slice(bo) : newText.slice(bo, -eo);
    if (bo > 0)
        start = (0, position_1.getEnd)(start, newText.slice(0, bo));
    if (eo > 0)
        end = (0, position_1.getEnd)(range.start, oldText.slice(0, -eo));
    return vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(start, end), text);
}
exports.reduceTextEdit = reduceTextEdit;
/*
 * Check if cursor inside
 */
function checkCursor(start, cursor, newText) {
    let r = vscode_languageserver_types_1.Range.create(start, (0, position_1.getEnd)(start, newText));
    return (0, position_1.positionInRange)(cursor, r) == 0;
}
exports.checkCursor = checkCursor;
/*
 * Check if textDocument have same text before position.
 */
function checkContentBefore(position, oldTextDocument, textDocument) {
    var _a;
    let lines = textDocument.lines;
    if (lines.length < position.line)
        return false;
    let checked = true;
    for (let i = position.line; i >= 0; i--) {
        let newLine = (_a = textDocument.lines[i]) !== null && _a !== void 0 ? _a : '';
        if (i === position.line) {
            let before = oldTextDocument.lines[i].slice(0, position.character);
            if (!newLine.startsWith(before)) {
                checked = false;
                break;
            }
        }
        else if (newLine !== oldTextDocument.lines[i]) {
            checked = false;
            break;
        }
    }
    return checked;
}
exports.checkContentBefore = checkContentBefore;
/**
 * Get new end position by old end position and new TextDocument
 */
function getEndPosition(position, oldTextDocument, textDocument) {
    let total = oldTextDocument.lines.length;
    if (textDocument.lines.length < total - position.line)
        return undefined;
    let end;
    let cl = textDocument.lines.length - total;
    for (let i = position.line; i < total; i++) {
        let newLine = textDocument.lines[i + cl];
        if (i == position.line) {
            let text = oldTextDocument.lines[i].slice(position.character);
            if (text.length && !newLine.endsWith(text))
                break;
            end = vscode_languageserver_types_1.Position.create(i + cl, newLine.length - text.length);
        }
        else if (newLine !== oldTextDocument.lines[i]) {
            end = undefined;
            break;
        }
    }
    return end;
}
exports.getEndPosition = getEndPosition;
/*
 * r in range, get text before and after
 */
function getParts(text, range, r) {
    var _a;
    let before = [];
    let after = [];
    let lines = text.split('\n');
    let d = r.start.line - range.start.line;
    for (let i = 0; i <= d; i++) {
        let s = (0, util_1.defaultValue)(lines[i], '');
        if (i == d) {
            before.push(i == 0 ? s.substring(0, r.start.character - range.start.character) : s.substring(0, r.start.character));
        }
        else {
            before.push(s);
        }
    }
    d = range.end.line - r.end.line;
    for (let i = 0; i <= d; i++) {
        let s = (_a = lines[r.end.line - range.start.line + i]) !== null && _a !== void 0 ? _a : '';
        if (i == 0) {
            if (d == 0) {
                after.push(range.end.character == r.end.character ? '' : s.slice(r.end.character - range.end.character));
            }
            else {
                after.push(s.substring(r.end.character));
            }
        }
        else {
            after.push(s);
        }
    }
    return [before.join('\n'), after.join('\n')];
}
exports.getParts = getParts;
function normalizeSnippetString(snippet, indent, opts) {
    let lines = snippet.split(/\r?\n/);
    let ind = opts.insertSpaces ? ' '.repeat(opts.tabSize) : '\t';
    let tabSize = (0, util_1.defaultValue)(opts.tabSize, 2);
    lines = lines.map((line, idx) => {
        let space = line.match(/^\s*/)[0];
        let pre = space;
        let isTab = space.startsWith('\t');
        if (isTab && opts.insertSpaces) {
            pre = ind.repeat(space.length);
        }
        else if (!isTab && !opts.insertSpaces) {
            pre = ind.repeat(space.length / tabSize);
        }
        return (idx == 0 || line.length == 0 ? '' : indent) + pre + line.slice(space.length);
    });
    return lines.join('\n');
}
exports.normalizeSnippetString = normalizeSnippetString;
function shouldFormat(snippet) {
    if (/^\s/.test(snippet))
        return true;
    if (snippet.indexOf('\n') !== -1)
        return true;
    return false;
}
exports.shouldFormat = shouldFormat;
function comparePlaceholder(a, b) {
    if (a.primary !== b.primary)
        return a.primary ? -1 : 1;
    if (a.index == 0 || b.index == 0)
        return a.index == 0 ? 1 : -1;
    return a.index - b.index;
}
exports.comparePlaceholder = comparePlaceholder;
//# sourceMappingURL=snippet.js.map