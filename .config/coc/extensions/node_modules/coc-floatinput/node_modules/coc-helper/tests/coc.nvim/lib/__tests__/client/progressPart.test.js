"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const progressPart_1 = require("../../language-client/progressPart");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterEach(async () => {
    await helper_1.default.reset();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('ProgressPart', () => {
    function createClient() {
        let _onDidProgress = new vscode_languageserver_protocol_1.Emitter();
        let onDidProgress = _onDidProgress.event;
        let notificationToken;
        return {
            id: 'test',
            get token() {
                return notificationToken;
            },
            fire(ev) {
                _onDidProgress.fire(ev);
            },
            onProgress(_, __, handler) {
                return onDidProgress(ev => {
                    handler(ev);
                });
            },
            sendNotification(_, params) {
                notificationToken = params.token;
            }
        };
    }
    it('should not start if cancelled', async () => {
        let client = createClient();
        let p = new progressPart_1.ProgressPart(client, '0c7faec8-e36c-4cde-9815-95635c37d696');
        p.cancel();
        expect(p.begin({ kind: 'begin', title: 'canceleld' })).toBe(false);
    });
    it('should report progress', async () => {
        let client = createClient();
        let p = new progressPart_1.ProgressPart(client, '0c7faec8-e36c-4cde-9815-95635c37d696');
        p.begin({ kind: 'begin', title: 'p', percentage: 1, cancellable: true });
        await helper_1.default.wait(30);
        p.report({ kind: 'report', message: 'msg', percentage: 10 });
        await helper_1.default.wait(10);
        p.report({ kind: 'report', message: 'msg', percentage: 50 });
        await helper_1.default.wait(10);
        p.done('finised');
    });
    it('should close notification on cancel', async () => {
        helper_1.default.updateConfiguration('notification.statusLineProgress', false);
        let client = createClient();
        let p = new progressPart_1.ProgressPart(client, '0c7faec8-e36c-4cde-9815-95635c37d696');
        let started = p.begin({ kind: 'begin', title: 'canceleld' });
        expect(started).toBe(true);
        p.cancel();
        p.cancel();
        let winids = await nvim.call('coc#notify#win_list');
        await helper_1.default.wait(30);
        expect(winids.length).toBe(1);
        let win = nvim.createWindow(winids[0]);
        let closing = await win.getVar('closing');
        expect(closing).toBe(1);
    });
    it('should send notification on cancel', async () => {
        helper_1.default.updateConfiguration('notification.statusLineProgress', false);
        let client = createClient();
        let token = '0c7faec8-e36c-4cde-9815-95635c37d696';
        let p = new progressPart_1.ProgressPart(client, token);
        let started = p.begin({ kind: 'begin', title: 'canceleld', cancellable: true });
        expect(started).toBe(true);
        for (let i = 0; i < 10; i++) {
            await helper_1.default.wait(30);
            let winids = await nvim.call('coc#notify#win_list');
            if (winids.length == 1)
                break;
        }
        await helper_1.default.wait(30);
        nvim.call('coc#float#close_all', [], true);
        await helper_1.default.waitValue(() => {
            return client.token;
        }, token);
    });
});
//# sourceMappingURL=progressPart.test.js.map