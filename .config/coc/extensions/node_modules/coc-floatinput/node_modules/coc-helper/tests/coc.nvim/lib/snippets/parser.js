'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformEscapes = exports.SnippetParser = exports.TextmateSnippet = exports.Variable = exports.FormatString = exports.ConditionString = exports.Transform = exports.Choice = exports.Placeholder = exports.CodeBlock = exports.Text = exports.Marker = exports.Scanner = void 0;
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const node_1 = require("../util/node");
const string_1 = require("../util/string");
const eval_1 = require("./eval");
const logger = (0, logger_1.createLogger)('snippets-parser');
const ULTISNIP_VARIABLES = ['VISUAL', 'YANK', 'UUID'];
const knownRegexOptions = ['d', 'g', 'i', 'm', 's', 'u', 'y'];
class Scanner {
    static isDigitCharacter(ch) {
        return ch >= 48 /* CharCode.Digit0 */ && ch <= 57 /* CharCode.Digit9 */;
    }
    static isVariableCharacter(ch) {
        return ch === 95 /* CharCode.Underline */
            || (ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */)
            || (ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */);
    }
    constructor() {
        this.text('');
    }
    text(value) {
        this.value = value;
        this.pos = 0;
    }
    tokenText(token) {
        return this.value.substr(token.pos, token.len);
    }
    next() {
        if (this.pos >= this.value.length) {
            return { type: 14 /* TokenType.EOF */, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        // static types
        type = Scanner._table[ch];
        if (typeof type === 'number') {
            this.pos += 1;
            return { type, pos, len: 1 };
        }
        // number
        if (Scanner.isDigitCharacter(ch)) {
            type = 8 /* TokenType.Int */;
            do {
                len += 1;
                ch = this.value.charCodeAt(pos + len);
            } while (Scanner.isDigitCharacter(ch));
            this.pos += len;
            return { type, pos, len };
        }
        // variable name
        if (Scanner.isVariableCharacter(ch)) {
            type = 9 /* TokenType.VariableName */;
            do {
                ch = this.value.charCodeAt(pos + (++len));
            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
            this.pos += len;
            return { type, pos, len };
        }
        // format
        type = 10 /* TokenType.Format */;
        do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch)
            && typeof Scanner._table[ch] === 'undefined' // not static token
            && !Scanner.isDigitCharacter(ch) // not number
            && !Scanner.isVariableCharacter(ch) // not variable
        );
        this.pos += len;
        return { type, pos, len };
    }
}
exports.Scanner = Scanner;
Scanner._table = {
    [36 /* CharCode.DollarSign */]: 0 /* TokenType.Dollar */,
    [58 /* CharCode.Colon */]: 1 /* TokenType.Colon */,
    [44 /* CharCode.Comma */]: 2 /* TokenType.Comma */,
    [123 /* CharCode.OpenCurlyBrace */]: 3 /* TokenType.CurlyOpen */,
    [125 /* CharCode.CloseCurlyBrace */]: 4 /* TokenType.CurlyClose */,
    [92 /* CharCode.Backslash */]: 5 /* TokenType.Backslash */,
    [47 /* CharCode.Slash */]: 6 /* TokenType.Forwardslash */,
    [124 /* CharCode.Pipe */]: 7 /* TokenType.Pipe */,
    [43 /* CharCode.Plus */]: 11 /* TokenType.Plus */,
    [45 /* CharCode.Dash */]: 12 /* TokenType.Dash */,
    [63 /* CharCode.QuestionMark */]: 13 /* TokenType.QuestionMark */,
    [40 /* CharCode.OpenParen */]: 15 /* TokenType.OpenParen */,
    [41 /* CharCode.CloseParen */]: 16 /* TokenType.CloseParen */,
    [96 /* CharCode.BackTick */]: 17 /* TokenType.BackTick */,
    [33 /* CharCode.ExclamationMark */]: 18 /* TokenType.ExclamationMark */,
};
class Marker {
    constructor() {
        this._children = [];
    }
    appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
            // this and previous child are text -> merge them
            this._children[this._children.length - 1].value += child.value;
        }
        else {
            // normal adoption of child
            child.parent = this;
            this._children.push(child);
        }
        return this;
    }
    setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
    }
    replaceChildren(children) {
        for (const child of children) {
            child.parent = this;
        }
        this._children = children;
    }
    get children() {
        return this._children;
    }
    get snippet() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let candidate = this;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (!candidate) {
                return undefined;
            }
            if (candidate instanceof TextmateSnippet) {
                return candidate;
            }
            candidate = candidate.parent;
        }
    }
    toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), '');
    }
    len() {
        return 0;
    }
}
exports.Marker = Marker;
class Text extends Marker {
    static escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    constructor(value) {
        super();
        this.value = value;
    }
    toString() {
        return this.value;
    }
    toTextmateString() {
        return Text.escape(this.value);
    }
    len() {
        return this.value.length;
    }
    clone() {
        return new Text(this.value);
    }
}
exports.Text = Text;
class CodeBlock extends Marker {
    constructor(code, kind, value) {
        super();
        this.code = code;
        this.kind = kind;
        this._value = '';
        this._related = [];
        if (kind === 'python') {
            let { _related } = this;
            let arr;
            let re = /\bt\[(\d+)\]/g;
            // eslint-disable-next-line no-constant-condition
            while (true) {
                arr = re.exec(code);
                if (arr == null)
                    break;
                let n = parseInt(arr[1], 10);
                if (!_related.includes(n))
                    _related.push(n);
            }
        }
        if (typeof value === 'string')
            this._value = value;
    }
    get related() {
        return this._related;
    }
    update(map) {
        if (this.kind !== 'python')
            return;
        let related = new Set();
        this.code = this.code.replace(/\bt\[(\d+)\]/g, (_, p1) => {
            let idx = Number(p1);
            let id = map.has(idx) ? map.get(idx) : idx;
            related.add(id);
            return `t[${id}]`;
        });
        this._related = Array.from(related);
    }
    get index() {
        if (this.parent instanceof Placeholder) {
            return this.parent.index;
        }
        return undefined;
    }
    async resolve(nvim) {
        if (!this.code.length)
            return;
        let res = await (0, eval_1.evalCode)(nvim, this.kind, this.code, (0, util_1.defaultValue)(this._value, ''));
        if (res != null)
            this._value = res;
    }
    len() {
        return this._value.length;
    }
    toString() {
        return this._value;
    }
    get value() {
        return this._value;
    }
    toTextmateString() {
        let t = '';
        if (this.kind == 'python') {
            t = '!p ';
        }
        else if (this.kind == 'shell') {
            t = '';
        }
        else if (this.kind == 'vim') {
            t = '!v ';
        }
        return '`' + t + (this.code) + '`';
    }
    clone() {
        return new CodeBlock(this.code, this.kind, this.value);
    }
}
exports.CodeBlock = CodeBlock;
class TransformableMarker extends Marker {
}
class Placeholder extends TransformableMarker {
    constructor(index) {
        super();
        this.index = index;
        this.primary = false;
    }
    get isFinalTabstop() {
        return this.index === 0;
    }
    get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice
            ? this._children[0]
            : undefined;
    }
    toTextmateString() {
        let transformString = '';
        if (this.transform) {
            transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
            return `$${this.index}`;
        }
        else if (this.children.length === 0 || (this.children.length == 1 && this.children[0].toTextmateString() == '')) {
            return `\${${this.index}${transformString}}`;
        }
        else if (this.choice) {
            return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        }
        else {
            return `\${${this.index}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
        }
    }
    clone() {
        let ret = new Placeholder(this.index);
        if (this.transform) {
            ret.transform = this.transform.clone();
        }
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
}
exports.Placeholder = Placeholder;
class Choice extends Marker {
    constructor() {
        super(...arguments);
        this.options = [];
    }
    appendChild(marker) {
        if (marker instanceof Text) {
            marker.parent = this;
            this.options.push(marker);
        }
        return this;
    }
    toString() {
        return this.options[0].value;
    }
    toTextmateString() {
        return this.options
            .map(option => option.value.replace(/\||,/g, '\\$&'))
            .join(',');
    }
    len() {
        return this.options[0].len();
    }
    clone() {
        let ret = new Choice();
        for (let opt of this.options) {
            ret.appendChild(opt);
        }
        return ret;
    }
}
exports.Choice = Choice;
class Transform extends Marker {
    constructor() {
        super(...arguments);
        this.ascii = false;
        this.ultisnip = false;
    }
    resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
            didMatch = true;
            return this._replace(args.slice(0, -2));
        });
        // when the regex didn't match and when the transform has
        // else branches, then run those
        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {
            ret = this._replace([]);
        }
        return ret;
    }
    _replace(groups) {
        let ret = '';
        let backslashIndexes = [];
        for (const marker of this._children) {
            if (marker instanceof FormatString) {
                let val = marker.resolve(groups[marker.index] || '');
                if (this.ultisnip && val.indexOf('\\') !== -1) {
                    let s = ret.length;
                    backslashIndexes.push(...(0, string_1.getCharIndexes)(val, '\\').map(i => i + s));
                }
                ret += val;
            }
            else if (marker instanceof ConditionString) {
                ret += marker.resolve(groups[marker.index]);
            }
            else {
                ret += marker.toString();
            }
        }
        if (this.ascii)
            ret = (0, node_1.unidecode)(ret);
        return this.ultisnip ? transformEscapes(ret, backslashIndexes) : ret;
    }
    toString() {
        return '';
    }
    toTextmateString() {
        let format = this.children.map(c => c.toTextmateString()).join('');
        if (this.ultisnip) {
            // avoid bad escape of Text for ultisnip format
            format = format.replace(/\\\\(\w)/g, (match, ch) => {
                if (['u', 'l', 'U', 'L', 'E', 'n', 't'].includes(ch)) {
                    return '\\' + ch;
                }
                return match;
            });
        }
        return `/${this.regexp.source}/${format}/${(this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : '')}`;
    }
    clone() {
        let ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
}
exports.Transform = Transform;
class ConditionString extends Marker {
    constructor(index, ifValue, elseValue) {
        super();
        this.index = index;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
    }
    resolve(value) {
        if (value)
            return this.ifValue;
        return this.elseValue;
    }
    toTextmateString() {
        return '(?' + this.index + ':' + this.ifValue + (this.elseValue ? ':' + this.elseValue : '') + ')';
    }
    clone() {
        return new ConditionString(this.index, this.ifValue, this.elseValue);
    }
}
exports.ConditionString = ConditionString;
class FormatString extends Marker {
    constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
    }
    resolve(value) {
        if (this.shorthandName === 'upcase') {
            return !value ? '' : value.toLocaleUpperCase();
        }
        else if (this.shorthandName === 'downcase') {
            return !value ? '' : value.toLocaleLowerCase();
        }
        else if (this.shorthandName === 'capitalize') {
            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));
        }
        else if (this.shorthandName === 'pascalcase') {
            return !value ? '' : this._toPascalCase(value);
        }
        else if (Boolean(value) && typeof this.ifValue === 'string') {
            return this.ifValue;
        }
        else if (!value && typeof this.elseValue === 'string') {
            return this.elseValue;
        }
        else {
            return value || '';
        }
    }
    _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
            return value;
        }
        return match.map(word => word.charAt(0).toUpperCase()
            + word.substr(1).toLowerCase())
            .join('');
    }
    toTextmateString() {
        let value = '${';
        value += this.index;
        if (this.shorthandName) {
            value += `:/${this.shorthandName}`;
        }
        else if (this.ifValue && this.elseValue) {
            value += `:?${this.ifValue}:${this.elseValue}`;
        }
        else if (this.ifValue) {
            value += `:+${this.ifValue}`;
        }
        else if (this.elseValue) {
            value += `:-${this.elseValue}`;
        }
        value += '}';
        return value;
    }
    clone() {
        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
    }
}
exports.FormatString = FormatString;
class Variable extends TransformableMarker {
    constructor(name, resolved = false) {
        super();
        this.name = name;
        this._resolved = resolved;
    }
    get resolved() {
        return this._resolved;
    }
    async resolve(resolver) {
        let value = await resolver.resolve(this);
        this._resolved = true;
        if (value && value.includes('\n')) {
            // get indent from previous texts
            let indent = '';
            this.snippet.walk(m => {
                if (m == this) {
                    return false;
                }
                if (m instanceof Text) {
                    let lines = m.toString().split(/\r?\n/);
                    indent = lines[lines.length - 1].match(/^\s*/)[0];
                }
                return true;
            });
            let lines = value.split('\n');
            let indents = lines.filter(s => s.length > 0).map(s => s.match(/^\s*/)[0]);
            let minIndent = indents.reduce((p, c) => p < c.length ? p : c.length, 0);
            let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(' '.repeat(minIndent)) ? s :
                indent + s.slice(minIndent));
            value = newLines.join('\n');
        }
        if (this.transform) {
            value = this.transform.resolve((0, string_1.toText)(value));
        }
        if (value != null) {
            this._children = [new Text(value.toString())];
            return true;
        }
        return false;
    }
    toTextmateString() {
        let transformString = '';
        if (this.transform) {
            transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
            return `\${${this.name}${transformString}}`;
        }
        else {
            return `\${${this.name}:${this.children.map(child => child.toTextmateString()).join('')}${transformString}}`;
        }
    }
    clone() {
        const ret = new Variable(this.name, this.resolved);
        if (this.transform) {
            ret.transform = this.transform.clone();
        }
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
}
exports.Variable = Variable;
function walk(marker, visitor) {
    const stack = [...marker];
    while (stack.length > 0) {
        const marker = stack.shift();
        const recurse = visitor(marker);
        if (!recurse) {
            break;
        }
        stack.unshift(...marker.children);
    }
}
class TextmateSnippet extends Marker {
    constructor(ultisnip) {
        super();
        this.ultisnip = ultisnip === true;
    }
    get hasPython() {
        if (!this.ultisnip)
            return false;
        return this.pyBlocks.length > 0;
    }
    get hasCodeBlock() {
        if (!this.ultisnip)
            return false;
        let { pyBlocks, otherBlocks } = this;
        return pyBlocks.length > 0 || otherBlocks.length > 0;
    }
    /**
     * Values for each placeholder index
     */
    get values() {
        if (this._values)
            return this._values;
        let values = {};
        let maxIndexNumber = 0;
        this.placeholders.forEach(c => {
            maxIndexNumber = Math.max(c.index, maxIndexNumber);
            if (c.transform != null)
                return;
            if (c.primary || values[c.index] === undefined)
                values[c.index] = c.toString();
        });
        for (let i = 0; i <= maxIndexNumber; i++) {
            if (values[i] === undefined)
                values[i] = '';
        }
        this._values = values;
        return values;
    }
    get orderedPyIndexBlocks() {
        let res = [];
        let filtered = this.pyBlocks.filter(o => typeof o.index === 'number');
        if (filtered.length === 0)
            return res;
        let allIndexes = filtered.map(o => o.index);
        let usedIndexes = [];
        const checkBlock = (b) => {
            let { related } = b;
            if (related.length == 0
                || related.every(idx => !allIndexes.includes(idx) || usedIndexes.includes(idx))) {
                usedIndexes.push(b.index);
                res.push(b);
                return true;
            }
            return false;
        };
        while (filtered.length > 0) {
            let c = false;
            for (let b of filtered) {
                if (checkBlock(b)) {
                    c = true;
                }
            }
            if (!c) {
                // recuisive dependencies detected
                break;
            }
            filtered = filtered.filter(o => !usedIndexes.includes(o.index));
        }
        return res;
    }
    async evalCodeBlocks(nvim, prepareCodes) {
        let { pyBlocks, otherBlocks } = this;
        // update none python blocks
        await Promise.all(otherBlocks.map(block => {
            let pre = block.value;
            return block.resolve(nvim).then(() => {
                if (block.parent instanceof Placeholder && pre !== block.value) {
                    // update placeholder with same index
                    this.onPlaceholderUpdate(block.parent);
                }
            });
        }));
        if (pyBlocks.length) {
            // run all python code by sequence
            const variableCode = (0, eval_1.getVariablesCode)(this.values);
            await (0, eval_1.executePythonCode)(nvim, [...prepareCodes, variableCode]);
            for (let block of pyBlocks) {
                let pre = block.value;
                await block.resolve(nvim);
                if (pre === block.value)
                    continue;
                if (block.parent instanceof Placeholder) {
                    // update placeholder with same index
                    this.onPlaceholderUpdate(block.parent);
                    await (0, eval_1.executePythonCode)(nvim, [(0, eval_1.getVariablesCode)(this.values)]);
                }
            }
            for (let block of this.orderedPyIndexBlocks) {
                await this.updatePyIndexBlock(nvim, block);
            }
            // update normal python block with related.
            let filtered = pyBlocks.filter(o => o.index === undefined && o.related.length > 0);
            for (let block of filtered) {
                await block.resolve(nvim);
            }
        }
    }
    /**
     * Update python blocks after user change Placeholder with index
     */
    async updatePythonCodes(nvim, marker) {
        let index;
        if (marker instanceof Placeholder) {
            index = marker.index;
        }
        else {
            // variables of ultisnips can't be updated,
            while (marker.parent) {
                if (marker instanceof Placeholder) {
                    index = marker.index;
                    break;
                }
                marker = marker.parent;
            }
            if (index === undefined)
                return;
        }
        // update related placeholders
        let blocks = this.getDependentPyIndexBlocks(index);
        await (0, eval_1.executePythonCode)(nvim, [(0, eval_1.getVariablesCode)(this.values)]);
        for (let block of blocks) {
            await this.updatePyIndexBlock(nvim, block);
        }
        // update normal py codes.
        let filtered = this.pyBlocks.filter(o => o.index === undefined && o.related.length > 0);
        for (let block of filtered) {
            await block.resolve(nvim);
        }
    }
    getDependentPyIndexBlocks(index) {
        const res = [];
        const taken = [];
        let filtered = this.pyBlocks.filter(o => typeof o.index === 'number');
        const search = (idx) => {
            let blocks = filtered.filter(o => !taken.includes(o.index) && o.related.includes(idx));
            if (blocks.length > 0) {
                res.push(...blocks);
                blocks.forEach(b => {
                    search(b.index);
                });
            }
        };
        search(index);
        return res;
    }
    /**
     * Update single index block
     */
    async updatePyIndexBlock(nvim, block) {
        let pre = block.value;
        await block.resolve(nvim);
        if (pre === block.value)
            return;
        if (block.parent instanceof Placeholder) {
            this.onPlaceholderUpdate(block.parent);
        }
        await (0, eval_1.executePythonCode)(nvim, [(0, eval_1.getVariablesCode)(this.values)]);
    }
    get placeholderInfo() {
        if (!this._placeholders) {
            const variables = [];
            const pyBlocks = [];
            const otherBlocks = [];
            // fill in placeholders
            let placeholders = [];
            this.walk(candidate => {
                if (candidate instanceof Placeholder) {
                    placeholders.push(candidate);
                }
                else if (candidate instanceof Variable) {
                    let first = candidate.name.charCodeAt(0);
                    // not jumpover for uppercase variable.
                    if (first < 65 || first > 90) {
                        variables.push(candidate);
                    }
                }
                else if (candidate instanceof CodeBlock) {
                    if (candidate.kind === 'python') {
                        pyBlocks.push(candidate);
                    }
                    else {
                        otherBlocks.push(candidate);
                    }
                }
                return true;
            });
            this._placeholders = { placeholders, pyBlocks, otherBlocks, variables };
        }
        return this._placeholders;
    }
    get variables() {
        return this.placeholderInfo.variables;
    }
    get placeholders() {
        return this.placeholderInfo.placeholders;
    }
    get pyBlocks() {
        return this.placeholderInfo.pyBlocks;
    }
    get otherBlocks() {
        return this.placeholderInfo.otherBlocks;
    }
    get maxIndexNumber() {
        let { placeholders } = this;
        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
    }
    get first() {
        var _a, _b;
        let { placeholders, variables } = this;
        let [normals, finals] = (0, array_1.groupBy)(placeholders.filter(p => !p.transform), v => v.index !== 0);
        if (normals.length) {
            let minIndex = Math.min.apply(null, normals.map(o => o.index));
            let arr = normals.filter(v => v.index == minIndex);
            return (_a = arr.find(p => p.primary)) !== null && _a !== void 0 ? _a : arr[0];
        }
        if (variables.length)
            return variables[0];
        return (_b = finals.find(o => o.primary)) !== null && _b !== void 0 ? _b : finals[0];
    }
    insertSnippet(snippet, marker, parts, ultisnip) {
        let index = marker instanceof Placeholder ? marker.index : this.maxIndexNumber + 1;
        let [before, after] = parts;
        let matchCode = ultisnip ? (0, eval_1.prepareMatchCode)(ultisnip) : undefined;
        let nested = new SnippetParser(!!ultisnip, matchCode).parse(snippet, true);
        let maxIndexAdded = nested.maxIndexNumber + 1;
        let changed = new Map();
        for (let p of nested.placeholders) {
            let idx = p.index;
            if (p.isFinalTabstop) {
                p.index = maxIndexAdded + index;
            }
            else {
                p.index = p.index + index;
            }
            changed.set(idx, p.index);
        }
        if (ultisnip) {
            nested.pyBlocks.forEach(b => {
                b.update(changed);
            });
        }
        let map = new Map();
        this.walk(m => {
            if (m instanceof Placeholder && m.index > index) {
                let idx = m.index;
                m.index = m.index + maxIndexAdded;
                map.set(idx, m.index);
            }
            return true;
        });
        if (this.hasPython) {
            this.walk(m => {
                if (m instanceof CodeBlock) {
                    m.update(map);
                }
                return true;
            });
        }
        const select = nested.first;
        let children = nested.children.slice();
        if (before)
            children.unshift(new Text(before));
        if (after)
            children.push(new Text(after));
        this.replace(marker, children);
        return select;
    }
    async update(nvim, marker, value) {
        this.resetMarker(marker, value);
        if (this.hasPython) {
            await this.updatePythonCodes(nvim, marker);
        }
    }
    deleteText(offset, length) {
        let pos = 0;
        let marker;
        let end = offset + length;
        let start = 0;
        this.walk(candidate => {
            let len = candidate.len();
            if (candidate instanceof Text && offset >= pos && pos + len >= end) {
                marker = candidate;
                start = offset - pos;
                return false;
            }
            pos += len;
            return true;
        });
        if (!marker)
            return false;
        let parent = marker.parent;
        let text = marker.value;
        let value = text.slice(0, start) + text.slice(start + length);
        let children = parent.children.slice();
        let idx = children.indexOf(marker);
        children.splice(idx, 1, new Text(value));
        parent.replaceChildren(children);
        return true;
    }
    resetMarker(marker, val) {
        let markers;
        if (marker instanceof Placeholder) {
            markers = this.placeholders.filter(o => o.index == marker.index);
        }
        else {
            markers = this.variables.filter(o => o.name == marker.name);
        }
        for (let p of markers) {
            let newText = p.transform ? p.transform.resolve(val) : val;
            p.setOnlyChild(new Text(newText || ''));
        }
        this.synchronizeParents(markers);
        this.reset();
    }
    /**
     * Reflact changes for related markers.
     */
    onPlaceholderUpdate(marker) {
        let val = marker.toString();
        let markers;
        if (marker instanceof Placeholder) {
            this.values[marker.index] = val;
            markers = this.placeholders.filter(o => o.index == marker.index);
        }
        else {
            markers = this.variables.filter(o => o.name == marker.name);
        }
        for (let p of markers) {
            if (p === marker)
                continue;
            let newText = p.transform ? p.transform.resolve(val) : val;
            p.setOnlyChild(new Text((0, string_1.toText)(newText)));
        }
        this.synchronizeParents(markers);
    }
    synchronizeParents(markers) {
        let arr = [];
        markers.forEach(m => {
            let p = m.parent;
            if (p instanceof Placeholder && !arr.includes(p)) {
                arr.push(p);
            }
        });
        arr.forEach(p => {
            this.onPlaceholderUpdate(p);
        });
    }
    offset(marker) {
        let pos = 0;
        let found = false;
        this.walk(candidate => {
            if (candidate === marker) {
                found = true;
                return false;
            }
            pos += candidate.len();
            return true;
        });
        if (!found) {
            return -1;
        }
        return pos;
    }
    fullLen(marker) {
        let ret = 0;
        walk([marker], marker => {
            ret += marker.len();
            return true;
        });
        return ret;
    }
    getTextBefore(marker, parent) {
        let res = '';
        const calc = (m) => {
            let p = m.parent;
            if (!p)
                return;
            let s = '';
            for (let b of p.children) {
                if (b === m)
                    break;
                s = s + b.toString();
            }
            res = s + res;
            if (p == parent)
                return;
            calc(p);
        };
        calc(marker);
        return res;
    }
    enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
            if (parent instanceof Placeholder) {
                ret.push(parent);
            }
            parent = parent.parent;
        }
        return ret;
    }
    async resolveVariables(resolver) {
        let items = [];
        this.walk(candidate => {
            if (candidate instanceof Variable && !candidate.resolved) {
                items.push(candidate);
            }
            return true;
        });
        if (items.length) {
            await Promise.all(items.map(o => o.resolve(resolver)));
            this.synchronizeParents(items);
        }
    }
    appendChild(child) {
        this.reset();
        return super.appendChild(child);
    }
    replace(marker, children) {
        marker.replaceChildren(children);
        if (marker instanceof Placeholder || marker instanceof Variable) {
            this.onPlaceholderUpdate(marker);
        }
        this.reset();
    }
    /**
     * Used on replace happens.
     */
    reset() {
        this._placeholders = undefined;
        this._values = undefined;
    }
    toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), '');
    }
    clone() {
        let ret = new TextmateSnippet(this.ultisnip);
        ret._children = this.children.map(child => child.clone());
        return ret;
    }
    walk(visitor) {
        walk(this.children, visitor);
    }
}
exports.TextmateSnippet = TextmateSnippet;
class SnippetParser {
    constructor(ultisnip, matchCode) {
        this.ultisnip = ultisnip;
        this.matchCode = matchCode;
        this._scanner = new Scanner();
    }
    static escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    static isPlainText(value) {
        let s = new SnippetParser().parse(value.replace(/\$0$/, ''), false);
        return s.children.length == 1 && s.children[0] instanceof Text;
    }
    text(value) {
        return this.parse(value, false).toString();
    }
    parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet(this.ultisnip);
        while (this._parse(snippet)) {
            // nothing
        }
        // fill in values for placeholders. the first placeholder of an index
        // that has a value defines the value for all placeholders with that index
        const defaultValues = new Map();
        const incompletePlaceholders = [];
        let complexPlaceholders = [];
        let hasFinal = false;
        snippet.walk(marker => {
            if (marker instanceof Placeholder) {
                if (marker.index == 0)
                    hasFinal = true;
                if (marker.children.some(o => o instanceof Placeholder)) {
                    complexPlaceholders.push(marker);
                }
                else if (!defaultValues.has(marker.index) && marker.children.length > 0) {
                    marker.primary = true;
                    defaultValues.set(marker.index, marker.toString());
                }
                else {
                    incompletePlaceholders.push(marker);
                }
            }
            return true;
        });
        const complexIndexes = complexPlaceholders.map(p => p.index);
        for (const placeholder of incompletePlaceholders) {
            // avoid transform and replace since no value exists.
            if (defaultValues.has(placeholder.index)) {
                let val = defaultValues.get(placeholder.index);
                let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
                placeholder.setOnlyChild(text);
            }
            else if (!complexIndexes.includes(placeholder.index)) {
                if (placeholder.transform) {
                    let text = new Text(placeholder.transform.resolve(''));
                    placeholder.setOnlyChild(text);
                }
                else {
                    placeholder.primary = true;
                    defaultValues.set(placeholder.index, '');
                }
            }
        }
        const resolveComplex = () => {
            let resolved = new Set();
            for (let p of complexPlaceholders) {
                if (p.children.every(o => !(o instanceof Placeholder) || defaultValues.has(o.index))) {
                    let val = p.toString();
                    defaultValues.set(p.index, val);
                    for (let placeholder of incompletePlaceholders.filter(o => o.index == p.index)) {
                        let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
                        placeholder.setOnlyChild(text);
                    }
                    resolved.add(p.index);
                }
            }
            complexPlaceholders = complexPlaceholders.filter(p => !resolved.has(p.index));
            if (complexPlaceholders.length == 0 || !resolved.size)
                return;
            resolveComplex();
        };
        resolveComplex();
        if (!hasFinal && insertFinalTabstop) {
            // the snippet uses placeholders but has no
            // final tabstop defined -> insert at the end
            snippet.appendChild(new Placeholder(0));
        }
        return snippet;
    }
    _accept(type, value) {
        if (type === undefined || this._token.type === type) {
            let ret = !value ? true : this._scanner.tokenText(this._token);
            this._token = this._scanner.next();
            return ret;
        }
        return false;
    }
    _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
    }
    _until(type, checkBackSlash = false) {
        if (this._token.type === 14 /* TokenType.EOF */) {
            return false;
        }
        let start = this._token;
        let pre;
        while (this._token.type !== type || (checkBackSlash && pre && pre.type === 5 /* TokenType.Backslash */)) {
            if (checkBackSlash)
                pre = this._token;
            this._token = this._scanner.next();
            if (this._token.type === 14 /* TokenType.EOF */) {
                return false;
            }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
    }
    _parse(marker) {
        return this._parseEscaped(marker)
            || this._parseCodeBlock(marker)
            || this._parseTabstopOrVariableName(marker)
            || this._parseComplexPlaceholder(marker)
            || this._parseComplexVariable(marker)
            || this._parseAnything(marker);
    }
    // \$, \\, \} -> just text
    _parseEscaped(marker) {
        let value;
        // eslint-disable-next-line no-cond-assign
        if (value = this._accept(5 /* TokenType.Backslash */, true)) {
            // saw a backslash, append escaped token or that backslash
            value = this._accept(0 /* TokenType.Dollar */, true)
                || this._accept(4 /* TokenType.CurlyClose */, true)
                || this._accept(5 /* TokenType.Backslash */, true)
                || (this.ultisnip && this._accept(3 /* TokenType.CurlyOpen */, true))
                || (this.ultisnip && this._accept(17 /* TokenType.BackTick */, true))
                || value;
            marker.appendChild(new Text(value));
            return true;
        }
        return false;
    }
    // $foo -> variable, $1 -> tabstop
    _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0 /* TokenType.Dollar */)
            && (value = this._accept(9 /* TokenType.VariableName */, true) || this._accept(8 /* TokenType.Int */, true));
        if (!match) {
            return this._backTo(token);
        }
        if (/^\d+$/.test(value)) {
            parent.appendChild(new Placeholder(Number(value)));
        }
        else {
            if (this.ultisnip && !ULTISNIP_VARIABLES.includes(value)) {
                parent.appendChild(new Text('$' + value));
            }
            else {
                parent.appendChild(new Variable(value));
            }
        }
        return true;
    }
    // ${1:<children>}, ${1} -> placeholder
    _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0 /* TokenType.Dollar */)
            && this._accept(3 /* TokenType.CurlyOpen */)
            && (index = this._accept(8 /* TokenType.Int */, true));
        if (!match) {
            return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1 /* TokenType.Colon */)) {
            // ${1:<children>}
            // eslint-disable-next-line no-constant-condition
            while (true) {
                // ...} -> done
                if (this._accept(4 /* TokenType.CurlyClose */)) {
                    parent.appendChild(placeholder);
                    return true;
                }
                if (this._parse(placeholder)) {
                    continue;
                }
                // fallback
                parent.appendChild(new Text('${' + index + ':'));
                placeholder.children.forEach(parent.appendChild, parent);
                return true;
            }
        }
        else if (placeholder.index > 0 && this._accept(7 /* TokenType.Pipe */)) {
            // ${1|one,two,three|}
            const choice = new Choice();
            // eslint-disable-next-line no-constant-condition
            while (true) {
                if (this._parseChoiceElement(choice)) {
                    if (this._accept(2 /* TokenType.Comma */)) {
                        // opt, -> more
                        continue;
                    }
                    if (this._accept(7 /* TokenType.Pipe */)) {
                        placeholder.appendChild(choice);
                        if (this._accept(4 /* TokenType.CurlyClose */)) {
                            // ..|} -> done
                            parent.appendChild(placeholder);
                            return true;
                        }
                    }
                }
                this._backTo(token);
                return false;
            }
        }
        else if (this._accept(6 /* TokenType.Forwardslash */)) {
            // ${1/<regex>/<format>/<options>}
            if (this._parseTransform(placeholder)) {
                parent.appendChild(placeholder);
                return true;
            }
            this._backTo(token);
            return false;
        }
        else if (this._accept(4 /* TokenType.CurlyClose */)) {
            // ${1}
            parent.appendChild(placeholder);
            return true;
        }
        else {
            // ${1 <- missing curly or colon
            return this._backTo(token);
        }
    }
    _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._token.type === 2 /* TokenType.Comma */ || this._token.type === 7 /* TokenType.Pipe */) {
                break;
            }
            let value;
            // eslint-disable-next-line no-cond-assign
            if (value = this._accept(5 /* TokenType.Backslash */, true)) {
                // \, \|, or \\
                value = this._accept(2 /* TokenType.Comma */, true)
                    || this._accept(7 /* TokenType.Pipe */, true)
                    || this._accept(5 /* TokenType.Backslash */, true)
                    || value;
            }
            else {
                value = this._accept(undefined, true);
            }
            if (!value) {
                // EOF
                this._backTo(token);
                return false;
            }
            values.push(value);
        }
        if (values.length === 0) {
            this._backTo(token);
            return false;
        }
        parent.appendChild(new Text(values.join('')));
        return true;
    }
    // ${foo:<children>}, ${foo} -> variable
    _parseComplexVariable(parent) {
        let name;
        const token = this._token;
        const match = this._accept(0 /* TokenType.Dollar */)
            && this._accept(3 /* TokenType.CurlyOpen */)
            && (name = this._accept(9 /* TokenType.VariableName */, true));
        if (!match) {
            return this._backTo(token);
        }
        if (this.ultisnip && !ULTISNIP_VARIABLES.includes(name)) {
            return this._backTo(token);
        }
        const variable = new Variable(name);
        if (this._accept(1 /* TokenType.Colon */)) {
            // ${foo:<children>}
            // eslint-disable-next-line no-constant-condition
            while (true) {
                // ...} -> done
                if (this._accept(4 /* TokenType.CurlyClose */)) {
                    parent.appendChild(variable);
                    return true;
                }
                if (this._parse(variable)) {
                    continue;
                }
                // fallback
                parent.appendChild(new Text('${' + name + ':'));
                variable.children.forEach(parent.appendChild, parent);
                return true;
            }
        }
        else if (this._accept(6 /* TokenType.Forwardslash */)) {
            // ${foo/<regex>/<format>/<options>}
            if (this._parseTransform(variable)) {
                parent.appendChild(variable);
                return true;
            }
            this._backTo(token);
            return false;
        }
        else if (this._accept(4 /* TokenType.CurlyClose */)) {
            // ${foo}
            parent.appendChild(variable);
            return true;
        }
        else {
            // ${foo <- missing curly or colon
            return this._backTo(token);
        }
    }
    _parseTransform(parent) {
        // ...<regex>/<format>/<options>}
        let transform = new Transform();
        transform.ultisnip = this.ultisnip === true;
        let regexValue = '';
        let regexOptions = '';
        // (1) /regex
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._accept(6 /* TokenType.Forwardslash */)) {
                break;
            }
            let escaped;
            // eslint-disable-next-line no-cond-assign
            if (escaped = this._accept(5 /* TokenType.Backslash */, true)) {
                escaped = this._accept(6 /* TokenType.Forwardslash */, true) || escaped;
                regexValue += escaped;
                continue;
            }
            if (this._token.type !== 14 /* TokenType.EOF */) {
                regexValue += this._accept(undefined, true);
                continue;
            }
            return false;
        }
        // (2) /format
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._accept(6 /* TokenType.Forwardslash */)) {
                break;
            }
            let escaped;
            // eslint-disable-next-line no-cond-assign
            if (escaped = this._accept(5 /* TokenType.Backslash */, true)) {
                escaped = this._accept(5 /* TokenType.Backslash */, true) || this._accept(6 /* TokenType.Forwardslash */, true) || escaped;
                transform.appendChild(new Text(escaped));
                continue;
            }
            if (this._parseFormatString(transform) || this._parseConditionString(transform) || this._parseAnything(transform)) {
                continue;
            }
            return false;
        }
        let ascii = false;
        // (3) /option
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this._accept(4 /* TokenType.CurlyClose */)) {
                break;
            }
            if (this._token.type !== 14 /* TokenType.EOF */) {
                let c = this._accept(undefined, true);
                if (c == 'a') {
                    ascii = true;
                }
                else {
                    if (!knownRegexOptions.includes(c)) {
                        logger.error(`Unknown regex option: ${c}`);
                    }
                    regexOptions += c;
                }
                continue;
            }
            return false;
        }
        try {
            if (ascii)
                transform.ascii = true;
            if (this.ultisnip)
                regexValue = (0, eval_1.convertRegex)(regexValue);
            transform.regexp = new RegExp(regexValue, regexOptions);
        }
        catch (e) {
            return false;
        }
        parent.transform = transform;
        return true;
    }
    _parseConditionString(parent) {
        if (!this.ultisnip)
            return false;
        const token = this._token;
        // (?1:foo:bar)
        if (!this._accept(15 /* TokenType.OpenParen */)) {
            return false;
        }
        if (!this._accept(13 /* TokenType.QuestionMark */)) {
            this._backTo(token);
            return false;
        }
        let index = this._accept(8 /* TokenType.Int */, true);
        if (!index) {
            this._backTo(token);
            return false;
        }
        if (!this._accept(1 /* TokenType.Colon */)) {
            this._backTo(token);
            return false;
        }
        let text = this._until(16 /* TokenType.CloseParen */, true);
        if (text) {
            let i = 0;
            while (i < text.length) {
                let t = text[i];
                if (t == ':' && text[i - 1] != '\\') {
                    break;
                }
                i++;
            }
            let ifValue = text.slice(0, i);
            let elseValue = text.slice(i + 1);
            parent.appendChild(new ConditionString(Number(index), ifValue, elseValue));
            return true;
        }
        this._backTo(token);
        return false;
    }
    _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0 /* TokenType.Dollar */)) {
            return false;
        }
        let complex = false;
        if (this._accept(3 /* TokenType.CurlyOpen */)) {
            complex = true;
        }
        let index = this._accept(8 /* TokenType.Int */, true);
        if (!index) {
            this._backTo(token);
            return false;
        }
        else if (!complex) {
            // $1
            parent.appendChild(new FormatString(Number(index)));
            return true;
        }
        else if (this._accept(4 /* TokenType.CurlyClose */)) {
            // ${1}
            parent.appendChild(new FormatString(Number(index)));
            return true;
        }
        else if (!this._accept(1 /* TokenType.Colon */)) {
            this._backTo(token);
            return false;
        }
        if (this.ultisnip) {
            this._backTo(token);
            return false;
        }
        if (this._accept(6 /* TokenType.Forwardslash */)) {
            // ${1:/upcase}
            let shorthand = this._accept(9 /* TokenType.VariableName */, true);
            if (!shorthand || !this._accept(4 /* TokenType.CurlyClose */)) {
                this._backTo(token);
                return false;
            }
            else {
                parent.appendChild(new FormatString(Number(index), shorthand));
                return true;
            }
        }
        else if (this._accept(11 /* TokenType.Plus */)) {
            // ${1:+<if>}
            let ifValue = this._until(4 /* TokenType.CurlyClose */);
            if (ifValue) {
                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));
                return true;
            }
        }
        else if (this._accept(12 /* TokenType.Dash */)) {
            // ${2:-<else>}
            let elseValue = this._until(4 /* TokenType.CurlyClose */);
            if (elseValue) {
                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));
                return true;
            }
        }
        else if (this._accept(13 /* TokenType.QuestionMark */)) {
            // ${2:?<if>:<else>}
            let ifValue = this._until(1 /* TokenType.Colon */);
            if (ifValue) {
                let elseValue = this._until(4 /* TokenType.CurlyClose */);
                if (elseValue) {
                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));
                    return true;
                }
            }
        }
        else {
            let elseValue = this._until(4 /* TokenType.CurlyClose */);
            if (elseValue) {
                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));
                return true;
            }
        }
        this._backTo(token);
        return false;
    }
    _parseCodeBlock(parent) {
        if (!this.ultisnip)
            return false;
        const token = this._token;
        if (!this._accept(17 /* TokenType.BackTick */)) {
            return false;
        }
        let text = this._until(17 /* TokenType.BackTick */, true);
        // `shell code` `!v` `!p`
        if (text) {
            if (!text.startsWith('!')) {
                let marker = new CodeBlock(text.trim(), 'shell');
                parent.appendChild(marker);
                return true;
            }
            if (text.startsWith('!v')) {
                let marker = new CodeBlock(text.slice(2).trim(), 'vim');
                parent.appendChild(marker);
                return true;
            }
            if (text.startsWith('!p')) {
                let code = text.slice(2);
                let pre = this.matchCode ? this.matchCode + '\n' : '';
                if (code.indexOf('\n') == -1) {
                    let marker = new CodeBlock(pre + code.trim(), 'python');
                    parent.appendChild(marker);
                }
                else {
                    let codes = code.split(/\r?\n/);
                    codes = codes.filter(s => !/^\s*$/.test(s));
                    if (!codes.length)
                        return true;
                    // format multi line code
                    let ind = codes[0].match(/^\s*/)[0];
                    if (ind.length && codes.every(s => s.startsWith(ind))) {
                        codes = codes.map(s => s.slice(ind.length));
                    }
                    if (ind == ' ' && codes[0].startsWith(ind))
                        codes[0] = codes[0].slice(1);
                    let marker = new CodeBlock(pre + codes.join('\n'), 'python');
                    parent.appendChild(marker);
                }
                return true;
            }
        }
        this._backTo(token);
        return false;
    }
    _parseAnything(marker) {
        if (this._token.type !== 14 /* TokenType.EOF */) {
            let text = this._scanner.tokenText(this._token);
            marker.appendChild(new Text(text));
            this._accept(undefined);
            return true;
        }
        return false;
    }
}
exports.SnippetParser = SnippetParser;
const escapedCharacters = [':', '(', ')', '{', '}'];
// \u \l \U \L \E \n \t
function transformEscapes(input, backslashIndexes = []) {
    let res = '';
    let len = input.length;
    let i = 0;
    let toUpper = false;
    let toLower = false;
    while (i < len) {
        let ch = input[i];
        if (ch.charCodeAt(0) === 92 /* CharCode.Backslash */ && !backslashIndexes.includes(i)) {
            let next = input[i + 1];
            if (escapedCharacters.includes(next)) {
                i++;
                continue;
            }
            if (next == 'u' || next == 'l') {
                // Uppercase/Lowercase next letter
                let follow = input[i + 2];
                if (follow)
                    res = res + (next == 'u' ? follow.toUpperCase() : follow.toLowerCase());
                i = i + 3;
                continue;
            }
            if (next == 'U' || next == 'L') {
                // Uppercase/Lowercase to \E
                if (next == 'U') {
                    toUpper = true;
                }
                else {
                    toLower = true;
                }
                i = i + 2;
                continue;
            }
            if (next == 'E') {
                toUpper = false;
                toLower = false;
                i = i + 2;
                continue;
            }
            if (next == 'n') {
                res += '\n';
                i = i + 2;
                continue;
            }
            if (next == 't') {
                res += '\t';
                i = i + 2;
                continue;
            }
        }
        if (toUpper) {
            ch = ch.toUpperCase();
        }
        else if (toLower) {
            ch = ch.toLowerCase();
        }
        res += ch;
        i++;
    }
    return res;
}
exports.transformEscapes = transformEscapes;
//# sourceMappingURL=parser.js.map