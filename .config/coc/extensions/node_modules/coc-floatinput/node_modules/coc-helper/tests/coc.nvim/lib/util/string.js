'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.smartcaseIndex = exports.contentToLines = exports.equalsIgnoreCase = exports.doEqualsIgnoreCase = exports.isAlphabet = exports.byteSlice = exports.utf8_code2len = exports.characterIndex = exports.indexOf = exports.upperFirst = exports.byteIndex = exports.byteLength = exports.isLowSurrogate = exports.isHighSurrogate = exports.getCharIndexes = exports.getNextWord = exports.getCase = exports.rangeParts = exports.isEmojiImprecise = exports.isHighlightGroupCharCode = exports.toBase64 = exports.toText = exports.toInteger = exports.toErrorText = void 0;
const array_1 = require("./array");
const UTF8_2BYTES_START = 0x80;
const UTF8_3BYTES_START = 0x800;
const UTF8_4BYTES_START = 65536;
const encoding = 'utf8';
const asciiTable = [
    [48, 57],
    [65, 90],
    [97, 122]
];
function toErrorText(error) {
    return error instanceof Error ? error.message : error.toString();
}
exports.toErrorText = toErrorText;
function toInteger(text) {
    let n = parseInt(text, 10);
    return isNaN(n) ? undefined : n;
}
exports.toInteger = toInteger;
function toText(text) {
    return text !== null && text !== void 0 ? text : '';
}
exports.toText = toText;
function toBase64(text) {
    return global.Buffer.from(text).toString('base64');
}
exports.toBase64 = toBase64;
function isHighlightGroupCharCode(code) {
    if ((0, array_1.intable)(code, asciiTable))
        return true;
    return code === 95 /* CharCode.Underline */ || code === 46 /* CharCode.Period */ || code === 64 /* CharCode.AtSign */;
}
exports.isHighlightGroupCharCode = isHighlightGroupCharCode;
/**
 * A fast function (therefore imprecise) to check if code points are emojis.
 * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js
 */
function isEmojiImprecise(x) {
    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)
        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)
        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)
        || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)
        || (x >= 129648 && x <= 129782));
}
exports.isEmojiImprecise = isEmojiImprecise;
/**
 * Get previous and after part of range
 */
function rangeParts(text, range) {
    let { start, end } = range;
    let lines = text.split(/\r?\n/);
    let before = '';
    let after = '';
    let len = lines.length;
    // get start and end parts
    for (let i = 0; i < len; i++) {
        let curr = lines[i];
        if (i < start.line) {
            before += curr + '\n';
            continue;
        }
        if (i > end.line) {
            after += curr + (i == len - 1 ? '' : '\n');
            continue;
        }
        if (i == start.line) {
            before += curr.slice(0, start.character);
        }
        if (i == end.line) {
            after += curr.slice(end.character) + (i == len - 1 ? '' : '\n');
        }
    }
    return [before, after];
}
exports.rangeParts = rangeParts;
// lowerCase 1, upperCase 2
function getCase(code) {
    if (code >= 97 && code <= 122)
        return 1;
    if (code >= 65 && code <= 90)
        return 2;
    return 0;
}
exports.getCase = getCase;
function getNextWord(codes, index) {
    let preCase = index == 0 ? 0 : getCase(codes[index - 1]);
    for (let i = index; i < codes.length; i++) {
        let curr = getCase(codes[i]);
        if (curr > 0 && curr != preCase) {
            return [i, codes[i]];
        }
        preCase = curr;
    }
    return undefined;
}
exports.getNextWord = getNextWord;
function getCharIndexes(input, character) {
    let res = [];
    for (let i = 0; i < input.length; i++) {
        if (input[i] == character)
            res.push(i);
    }
    return res;
}
exports.getCharIndexes = getCharIndexes;
function isHighSurrogate(codePoint) {
    return codePoint >= 0xd800 && codePoint <= 0xdbff;
}
exports.isHighSurrogate = isHighSurrogate;
function isLowSurrogate(codePoint) {
    return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}
exports.isLowSurrogate = isLowSurrogate;
/**
 * Get byte length from string, from code unit start index.
 */
function byteLength(str, start = 0) {
    if (start === 0)
        return Buffer.byteLength(str, encoding);
    let len = 0;
    let unitIndex = 0;
    for (let codePoint of str) {
        let n = codePoint.codePointAt(0);
        if (unitIndex >= start) {
            len += utf8_code2len(n);
        }
        unitIndex += (n >= UTF8_4BYTES_START ? 2 : 1);
    }
    return len;
}
exports.byteLength = byteLength;
/**
 * utf16 code unit to byte index.
 */
function byteIndex(content, index) {
    let byteLength = 0;
    let codePoint;
    let prevCodePoint;
    let max = Math.min(index, content.length);
    for (let i = 0; i < max; i++) {
        codePoint = content.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
            if (prevCodePoint && isHighSurrogate(prevCodePoint)) {
                byteLength += 1;
            }
            else {
                byteLength += 3;
            }
        }
        else {
            byteLength += utf8_code2len(codePoint);
        }
        prevCodePoint = codePoint;
    }
    return byteLength;
}
exports.byteIndex = byteIndex;
function upperFirst(str) {
    return (str === null || str === void 0 ? void 0 : str.length) > 0 ? str[0].toUpperCase() + str.slice(1) : '';
}
exports.upperFirst = upperFirst;
function indexOf(str, ch, count = 1) {
    let curr = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] == ch) {
            curr = curr + 1;
            if (curr == count) {
                return i;
            }
        }
    }
    return -1;
}
exports.indexOf = indexOf;
function characterIndex(content, byteIndex) {
    if (byteIndex == 0)
        return 0;
    let characterIndex = 0;
    let total = 0;
    for (let codePoint of content) {
        let code = codePoint.codePointAt(0);
        if (code >= UTF8_4BYTES_START) {
            characterIndex += 2;
            total += 4;
        }
        else {
            characterIndex += 1;
            total += utf8_code2len(code);
        }
        if (total >= byteIndex)
            break;
    }
    return characterIndex;
}
exports.characterIndex = characterIndex;
function utf8_code2len(code) {
    if (code < UTF8_2BYTES_START)
        return 1;
    if (code < UTF8_3BYTES_START)
        return 2;
    if (code < UTF8_4BYTES_START)
        return 3;
    return 4;
}
exports.utf8_code2len = utf8_code2len;
/**
 * No need to create Buffer
 */
function byteSlice(content, start, end) {
    let si = characterIndex(content, start);
    let ei = end === undefined ? undefined : characterIndex(content, end);
    return content.slice(si, ei);
}
exports.byteSlice = byteSlice;
function isAlphabet(code) {
    if (code >= 65 && code <= 90)
        return true;
    if (code >= 97 && code <= 122)
        return true;
    return false;
}
exports.isAlphabet = isAlphabet;
function doEqualsIgnoreCase(a, b, stopAt = a.length) {
    if (typeof a !== 'string' || typeof b !== 'string') {
        return false;
    }
    for (let i = 0; i < stopAt; i++) {
        const codeA = a.charCodeAt(i);
        const codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            continue;
        }
        // a-z A-Z
        if (isAlphabet(codeA) && isAlphabet(codeB)) {
            const diff = Math.abs(codeA - codeB);
            if (diff !== 0 && diff !== 32) {
                return false;
            }
        }
        // Any other charcode
        else {
            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                return false;
            }
        }
    }
    return true;
}
exports.doEqualsIgnoreCase = doEqualsIgnoreCase;
function equalsIgnoreCase(a, b) {
    const len1 = a ? a.length : 0;
    const len2 = b ? b.length : 0;
    if (len1 !== len2)
        return false;
    return doEqualsIgnoreCase(a, b);
}
exports.equalsIgnoreCase = equalsIgnoreCase;
function contentToLines(content, eol) {
    if (eol && content.endsWith('\n')) {
        return content.slice(0, -1).split('\n');
    }
    return content.split('\n');
}
exports.contentToLines = contentToLines;
function hasUpperCase(str) {
    for (let i = 0, l = str.length; i < l; i++) {
        let code = str.charCodeAt(i);
        if (code >= 65 && code <= 90) {
            return true;
        }
    }
    return false;
}
function smartMatch(a, b) {
    if (a === b)
        return true;
    let c = b.charCodeAt(0);
    if (c >= 65 && c <= 90) {
        if (c + 32 === a.charCodeAt(0))
            return true;
    }
    return false;
}
// check if string smartcase include the other string
function smartcaseIndex(input, other) {
    if (input.length > other.length)
        return -1;
    if (input.length === 0)
        return 0;
    if (!hasUpperCase(input)) {
        return other.toLowerCase().indexOf(input);
    }
    let total = input.length;
    let checked = 0;
    for (let i = 0; i < other.length; i++) {
        let ch = other[i];
        if (smartMatch(input[checked], ch)) {
            checked++;
            if (checked === total) {
                return i - checked + 1;
            }
        }
        else if (checked > 0) {
            i = i - checked;
            checked = 0;
        }
    }
    return -1;
}
exports.smartcaseIndex = smartcaseIndex;
/**
 * For faster convert sequence utf16 character index to byte index
 */
function bytes(text, max) {
    max = max !== null && max !== void 0 ? max : text.length;
    let lens = new Uint8Array(max);
    let ascii = true;
    let prevCodePoint;
    for (let i = 0; i < max; i++) {
        let code = text.charCodeAt(i);
        let len;
        if (isLowSurrogate(code)) {
            if (prevCodePoint && isHighSurrogate(prevCodePoint)) {
                len = 1;
            }
            else {
                len = 3;
            }
        }
        else {
            len = utf8_code2len(code);
        }
        if (ascii && len > 1)
            ascii = false;
        lens[i] = len;
        prevCodePoint = code;
    }
    return characterIndex => {
        if (characterIndex === 0)
            return 0;
        if (ascii)
            return Math.min(characterIndex, max);
        let res = 0;
        for (let i = 0; i < Math.min(characterIndex, max); i++) {
            res += lens[i];
        }
        return res;
    };
}
exports.bytes = bytes;
//# sourceMappingURL=string.js.map