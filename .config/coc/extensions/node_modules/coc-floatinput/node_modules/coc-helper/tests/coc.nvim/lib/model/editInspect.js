'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOriginalLine = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const textedit_1 = require("../util/textedit");
const highligher_1 = tslib_1.__importDefault(require("./highligher"));
let global_id = 0;
class EditInspect {
    constructor(nvim, keymaps) {
        this.nvim = nvim;
        this.keymaps = keymaps;
        this.disposables = [];
        this.items = [];
        this.renameMap = new Map();
        events_1.default.on('BufUnload', bufnr => {
            if (bufnr == this.bufnr)
                this.dispose();
        }, null, this.disposables);
    }
    addFile(filepath, highligher, lnum) {
        this.items.push({
            index: highligher.length,
            filepath,
            lnum
        });
    }
    async show(state) {
        var _a;
        let { nvim } = this;
        let id = global_id++;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ buftype=nofile CocWorkspaceEdit${id}`, true);
        nvim.command(`setl bufhidden=wipe nolist`, true);
        nvim.command('setl nobuflisted wrap undolevels=-1 filetype=cocedits noswapfile', true);
        await nvim.resumeNotification(true);
        let buffer = await nvim.buffer;
        let cwd = await nvim.call('getcwd');
        this.bufnr = buffer.id;
        const relpath = (uri) => {
            let fsPath = vscode_uri_1.URI.parse(uri).fsPath;
            return (0, fs_1.isParentFolder)(cwd, fsPath, true) ? node_1.path.relative(cwd, fsPath) : fsPath;
        };
        const absPath = filepath => {
            return node_1.path.isAbsolute(filepath) ? filepath : node_1.path.join(cwd, filepath);
        };
        let highligher = new highligher_1.default();
        let changes = (0, array_1.toArray)(state.edit.documentChanges);
        let map = grouByAnnotation(changes, (_a = state.edit.changeAnnotations) !== null && _a !== void 0 ? _a : {});
        for (let [label, changes] of map.entries()) {
            if (label) {
                highligher.addLine(label, 'MoreMsg');
                highligher.addLine('');
            }
            for (let change of changes) {
                if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
                    let linesChange = state.changes[change.textDocument.uri];
                    let fsPath = relpath(change.textDocument.uri);
                    highligher.addTexts([
                        { text: 'Change', hlGroup: 'Title' },
                        { text: ' ' },
                        { text: fsPath, hlGroup: 'Directory' },
                        { text: `:${linesChange.lnum}`, hlGroup: 'LineNr' },
                    ]);
                    this.addFile(fsPath, highligher, linesChange.lnum);
                    highligher.addLine('');
                    this.addChangedLines(highligher, linesChange, fsPath, linesChange.lnum);
                    highligher.addLine('');
                }
                else if (vscode_languageserver_types_1.CreateFile.is(change) || vscode_languageserver_types_1.DeleteFile.is(change)) {
                    let title = vscode_languageserver_types_1.DeleteFile.is(change) ? 'Delete' : 'Create';
                    let fsPath = relpath(change.uri);
                    highligher.addTexts([
                        { text: title, hlGroup: 'Title' },
                        { text: ' ' },
                        { text: fsPath, hlGroup: 'Directory' }
                    ]);
                    this.addFile(fsPath, highligher);
                    highligher.addLine('');
                }
                else if (vscode_languageserver_types_1.RenameFile.is(change)) {
                    let oldPath = relpath(change.oldUri);
                    let newPath = relpath(change.newUri);
                    highligher.addTexts([
                        { text: 'Rename', hlGroup: 'Title' },
                        { text: ' ' },
                        { text: oldPath, hlGroup: 'Directory' },
                        { text: '->', hlGroup: 'Comment' },
                        { text: newPath, hlGroup: 'Directory' }
                    ]);
                    this.renameMap.set(oldPath, newPath);
                    this.addFile(newPath, highligher);
                    highligher.addLine('');
                }
            }
        }
        nvim.pauseNotification();
        highligher.render(buffer);
        buffer.setOption('modifiable', false, true);
        await nvim.resumeNotification(true);
        this.disposables.push(this.keymaps.registerLocalKeymap(buffer.id, 'n', '<CR>', async () => {
            let lnum = await nvim.call('line', '.');
            let col = await nvim.call('col', '.');
            let find;
            for (let i = this.items.length - 1; i >= 0; i--) {
                let item = this.items[i];
                if (lnum >= item.index) {
                    find = item;
                    break;
                }
            }
            if (!find)
                return;
            let uri = vscode_uri_1.URI.file(absPath(find.filepath)).toString();
            let filepath = this.renameMap.has(find.filepath) ? this.renameMap.get(find.filepath) : find.filepath;
            await nvim.call('coc#util#open_file', ['tab drop', absPath(filepath)]);
            let documentChanges = (0, array_1.toArray)(state.edit.documentChanges);
            let change = documentChanges.find(o => vscode_languageserver_types_1.TextDocumentEdit.is(o) && o.textDocument.uri == uri);
            let originLine = getOriginalLine(find, change);
            if (originLine !== undefined)
                await nvim.call('cursor', [originLine, col]);
            nvim.redrawVim();
        }, true));
        this.disposables.push(this.keymaps.registerLocalKeymap(buffer.id, 'n', '<esc>', async () => {
            nvim.command('bwipeout!', true);
        }, true));
    }
    addChangedLines(highligher, linesChange, fsPath, lnum) {
        let diffs = (0, node_1.fastDiff)(linesChange.oldLines.join('\n'), linesChange.newLines.join('\n'));
        for (let i = 0; i < diffs.length; i++) {
            let diff = diffs[i];
            if (diff[0] == node_1.fastDiff.EQUAL) {
                let text = diff[1];
                if (!text.includes('\n')) {
                    highligher.addText(text);
                }
                else {
                    let parts = text.split('\n');
                    highligher.addText(parts[0]);
                    let curr = lnum + parts.length - 1;
                    highligher.addLine('');
                    highligher.addTexts([
                        { text: 'Change', hlGroup: 'Title' },
                        { text: ' ' },
                        { text: fsPath, hlGroup: 'Directory' },
                        { text: `:${curr}`, hlGroup: 'LineNr' },
                    ]);
                    this.addFile(fsPath, highligher, curr);
                    highligher.addLine('');
                    let last = parts[parts.length - 1];
                    highligher.addText(last);
                }
                lnum += text.split('\n').length - 1;
            }
            else if (diff[0] == node_1.fastDiff.DELETE) {
                lnum += diff[1].split('\n').length - 1;
                highligher.addText(diff[1], 'DiffDelete');
            }
            else {
                highligher.addText(diff[1], 'DiffAdd');
            }
        }
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = EditInspect;
function getOriginalLine(item, change) {
    if (typeof item.lnum !== 'number')
        return undefined;
    let lnum = item.lnum;
    if (change) {
        let edits = (0, textedit_1.mergeSortEdits)(change.edits);
        let pos = (0, textedit_1.getPositionFromEdits)(vscode_languageserver_types_1.Position.create(lnum - 1, 0), edits);
        lnum = pos.line + 1;
    }
    return lnum;
}
exports.getOriginalLine = getOriginalLine;
function grouByAnnotation(changes, annotations) {
    var _a, _b;
    let map = new Map();
    for (let change of changes) {
        let id = (_a = (0, textedit_1.getAnnotationKey)(change)) !== null && _a !== void 0 ? _a : null;
        let key = id ? (_b = annotations[id]) === null || _b === void 0 ? void 0 : _b.label : null;
        let arr = map.get(key);
        if (arr) {
            arr.push(change);
        }
        else {
            map.set(key, [change]);
        }
    }
    return map;
}
//# sourceMappingURL=editInspect.js.map