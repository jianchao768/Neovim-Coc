"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
let highlights;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    highlights = helper_1.default.plugin.handler.documentHighlighter;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
    disposables = [];
});
function registerProvider() {
    disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
        provideDocumentHighlights: async (document) => {
            let word = await nvim.eval('expand("<cword>")');
            // let word = document.get
            let matches = Array.from(document.getText().matchAll(/\w+/g));
            let filtered = matches.filter(o => o[0] == word);
            return filtered.map((o, i) => {
                let start = document.positionAt(o.index);
                let end = document.positionAt(o.index + o[0].length);
                return {
                    range: vscode_languageserver_protocol_1.Range.create(start, end),
                    kind: i % 2 == 0 ? vscode_languageserver_protocol_1.DocumentHighlightKind.Read : vscode_languageserver_protocol_1.DocumentHighlightKind.Write
                };
            });
        }
    }));
}
describe('document highlights', () => {
    function registerTimerProvider(fn, timeout) {
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: (_document, _position, token) => {
                return new Promise(resolve => {
                    token.onCancellationRequested(() => {
                        clearTimeout(timer);
                        fn();
                        resolve([]);
                    });
                    let timer = setTimeout(() => {
                        resolve([{ range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3) }]);
                    }, timeout);
                });
            }
        }));
    }
    it('should not throw when no range to jump', async () => {
        let fn = jest.fn();
        registerTimerProvider(fn, 10);
        await commands_1.default.executeCommand('document.jumpToNextSymbol');
        await commands_1.default.executeCommand('document.jumpToPrevSymbol');
    });
    it('should jump to previous range', async () => {
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: () => {
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1),
                        kind: vscode_languageserver_protocol_1.DocumentHighlightKind.Read
                    }, {
                        range: vscode_languageserver_protocol_1.Range.create(0, 2, 0, 3),
                        kind: vscode_languageserver_protocol_1.DocumentHighlightKind.Read
                    }];
            }
        }));
        await nvim.setLine('foo bar');
        await nvim.command('normal! $');
        await commands_1.default.executeCommand('document.jumpToPrevSymbol');
        let cur = await window_1.default.getCursorPosition();
        expect(cur).toEqual(vscode_languageserver_protocol_1.Position.create(0, 2));
        await commands_1.default.executeCommand('document.jumpToPrevSymbol');
        cur = await window_1.default.getCursorPosition();
        expect(cur).toEqual(vscode_languageserver_protocol_1.Position.create(0, 0));
        await commands_1.default.executeCommand('document.jumpToPrevSymbol');
        cur = await window_1.default.getCursorPosition();
        expect(cur).toEqual(vscode_languageserver_protocol_1.Position.create(0, 2));
    });
    it('should jump to next range', async () => {
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: () => {
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1),
                        kind: vscode_languageserver_protocol_1.DocumentHighlightKind.Read
                    }, {
                        range: vscode_languageserver_protocol_1.Range.create(0, 2, 0, 3),
                        kind: vscode_languageserver_protocol_1.DocumentHighlightKind.Read
                    }];
            }
        }));
        await nvim.setLine('foo bar');
        await nvim.command('normal! ^');
        await commands_1.default.executeCommand('document.jumpToNextSymbol');
        let cur = await window_1.default.getCursorPosition();
        expect(cur).toEqual(vscode_languageserver_protocol_1.Position.create(0, 2));
        await commands_1.default.executeCommand('document.jumpToNextSymbol');
        cur = await window_1.default.getCursorPosition();
        expect(cur).toEqual(vscode_languageserver_protocol_1.Position.create(0, 0));
        await commands_1.default.executeCommand('document.jumpToNextSymbol');
        cur = await window_1.default.getCursorPosition();
        expect(cur).toEqual(vscode_languageserver_protocol_1.Position.create(0, 2));
    });
    it('should not throw when provide throws', async () => {
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: () => {
                return null;
            }
        }));
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: () => {
                throw new Error('fake error');
            }
        }));
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: () => {
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
                        kind: vscode_languageserver_protocol_1.DocumentHighlightKind.Read
                    }];
            }
        }));
        let doc = await workspace_1.default.document;
        await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')]);
        let res = await highlights.getHighlights(doc, vscode_languageserver_protocol_1.Position.create(0, 0));
        expect(res).toBeDefined();
    });
    it('should return null when highlights provide not exist', async () => {
        let doc = await workspace_1.default.document;
        await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')]);
        let res = await highlights.getHighlights(doc, vscode_languageserver_protocol_1.Position.create(0, 0));
        expect(res).toBeNull();
    });
    it('should cancel request on CursorMoved', async () => {
        let fn = jest.fn();
        registerTimerProvider(fn, 3000);
        await helper_1.default.edit();
        await nvim.setLine('foo');
        let p = highlights.highlight();
        await helper_1.default.wait(50);
        await nvim.call('cursor', [1, 2]);
        await p;
        expect(fn).toBeCalled();
    });
    it('should cancel on timeout', async () => {
        helper_1.default.updateConfiguration('documentHighlight.timeout', 10);
        let fn = jest.fn();
        registerTimerProvider(fn, 3000);
        await helper_1.default.edit();
        await nvim.setLine('foo');
        await highlights.highlight();
        expect(fn).toBeCalled();
    });
    it('should add highlights to symbols', async () => {
        registerProvider();
        await helper_1.default.createDocument();
        await nvim.setLine('foo bar foo');
        await helper_1.default.doAction('highlight');
        let winid = await nvim.call('win_getid');
        expect(highlights.hasHighlights(winid)).toBe(true);
    });
    it('should return highlight ranges', async () => {
        registerProvider();
        await helper_1.default.createDocument();
        await nvim.setLine('foo bar foo');
        let res = await helper_1.default.doAction('symbolRanges');
        expect(res.length).toBe(2);
    });
    it('should return null when cursor not in word range', async () => {
        disposables.push(languages_1.default.registerDocumentHighlightProvider([{ language: '*' }], {
            provideDocumentHighlights: () => {
                return [{ range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3) }];
            }
        }));
        let doc = await helper_1.default.createDocument();
        await nvim.setLine('  oo');
        await nvim.call('cursor', [1, 2]);
        let res = await highlights.getHighlights(doc, vscode_languageserver_protocol_1.Position.create(0, 0));
        expect(res).toBeNull();
    });
    it('should not throw when document is command line', async () => {
        await nvim.call('feedkeys', ['q:', 'in']);
        let doc = await workspace_1.default.document;
        expect(doc.isCommandLine).toBe(true);
        await highlights.highlight();
        await nvim.input('<C-c>');
    });
    it('should not throw when provider not found', async () => {
        (0, util_1.disposeAll)(disposables);
        await helper_1.default.createDocument();
        await nvim.setLine('  oo');
        await nvim.call('cursor', [1, 2]);
        await highlights.highlight();
    });
});
//# sourceMappingURL=highlights.test.js.map