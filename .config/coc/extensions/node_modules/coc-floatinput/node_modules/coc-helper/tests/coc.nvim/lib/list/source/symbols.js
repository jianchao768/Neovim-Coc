'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortSymbolItems = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languages_1 = tslib_1.__importStar(require("../../languages"));
const array_1 = require("../../util/array");
const convert_1 = require("../../util/convert");
const node_1 = require("../../util/node");
const protocol_1 = require("../../util/protocol");
const string_1 = require("../../util/string");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const formatting_1 = require("../formatting");
const location_1 = tslib_1.__importDefault(require("./location"));
class Symbols extends location_1.default {
    constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = 'search workspace symbols';
        this.detail = 'Symbols list is provided by server, it works on interactive mode only.';
        this.fuzzyMatch = workspace_1.default.createFuzzyMatch();
        this.name = 'symbols';
        this.options = [{
                name: '-k, -kind KIND',
                description: 'Filter symbols by kind.',
                hasValue: true
            }];
    }
    async loadItems(context, token) {
        let { input } = context;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toString().toLowerCase() : '';
        if (!languages_1.default.hasProvider(languages_1.ProviderName.WorkspaceSymbols, { uri: 'file:///1', languageId: '' })) {
            throw new Error('No workspace symbols provider registered');
        }
        let symbols = await languages_1.default.getWorkspaceSymbols(input, token);
        if (token.isCancellationRequested)
            return [];
        let config = this.getConfig();
        let excludes = config.get('excludes', []);
        let items = [];
        this.fuzzyMatch.setPattern(input, true);
        for (let s of symbols) {
            let kind = (0, convert_1.getSymbolKind)(s.kind);
            if (filterKind && kind.toLowerCase() != filterKind) {
                continue;
            }
            let file = (0, formatting_1.formatUri)(s.location.uri, workspace_1.default.cwd);
            if (excludes.some(p => (0, node_1.minimatch)(file, p))) {
                continue;
            }
            let item = this.createListItem(input, s, kind, file);
            items.push(item);
        }
        this.fuzzyMatch.free();
        items.sort(sortSymbolItems);
        return items;
    }
    async resolveItem(item) {
        let symbolItem = item.data.original;
        if (!symbolItem)
            return null;
        let tokenSource = new protocol_1.CancellationTokenSource();
        let resolved = await languages_1.default.resolveWorkspaceSymbol(symbolItem, tokenSource.token);
        if (!resolved)
            return null;
        symbolItem.location = resolved.location;
        item.location = toTargetLocation(resolved.location);
        return item;
    }
    createListItem(input, item, kind, file) {
        let { name } = item;
        let label = '';
        let ansiHighlights = [];
        // Normal Typedef Comment
        let parts = [name, `[${kind}]`, file];
        let highlights = ['Normal', 'Typedef', 'Comment'];
        for (let index = 0; index < parts.length; index++) {
            const text = parts[index];
            let start = (0, string_1.byteLength)(label);
            label += text;
            let end = (0, string_1.byteLength)(label);
            if (index != parts.length - 1) {
                label += ' ';
            }
            ansiHighlights.push({ span: [start, end], hlGroup: highlights[index] });
            if (index === 0 && ((0, array_1.toArray)(item.tags)).includes(vscode_languageserver_types_1.SymbolTag.Deprecated)) {
                ansiHighlights.push({ span: [start, end], hlGroup: 'CocDeprecatedHighlight' });
            }
        }
        let score = 0;
        if (input.length > 0) {
            let result = this.fuzzyMatch.matchHighlights(name, 'CocListSearch');
            if (result) {
                score = result.score;
                ansiHighlights.push(...result.highlights);
            }
        }
        return {
            label,
            filterText: '',
            ansiHighlights,
            location: toTargetLocation(item.location),
            data: {
                original: item,
                input,
                kind: item.kind,
                file,
                score,
            }
        };
    }
}
exports.default = Symbols;
function toTargetLocation(location) {
    let loc = vscode_languageserver_types_1.Location.create(location.uri, vscode_languageserver_types_1.Range.create(location.range.start, location.range.start));
    loc.targetRange = location.range;
    return loc;
}
function sortSymbolItems(a, b) {
    if (a.data.score != b.data.score) {
        return b.data.score - a.data.score;
    }
    if (a.data.kind != b.data.kind) {
        return a.data.kind - b.data.kind;
    }
    return a.data.file.length - b.data.file.length;
}
exports.sortSymbolItems = sortSymbolItems;
//# sourceMappingURL=symbols.js.map