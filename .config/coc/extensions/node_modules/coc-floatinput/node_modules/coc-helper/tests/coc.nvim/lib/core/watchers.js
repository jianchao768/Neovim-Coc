'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const logger = (0, logger_1.createLogger)('watchers');
class Watchers {
    constructor() {
        this.optionCallbacks = new Map();
        this.globalCallbacks = new Map();
        this.disposables = [];
        this._onDidRuntimePathChange = new protocol_1.Emitter();
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        events_1.default.on('OptionSet', async (changed, oldValue, newValue) => {
            var _a;
            let cbs = Array.from((_a = this.optionCallbacks.get(changed)) !== null && _a !== void 0 ? _a : []);
            await Promise.allSettled(cbs.map(cb => {
                return (async () => {
                    try {
                        await Promise.resolve(cb(oldValue, newValue));
                    }
                    catch (e) {
                        this.nvim.errWriteLine(`Error on OptionSet '${changed}': ${(0, string_1.toErrorText)(e)}`);
                        logger.error(`Error on OptionSet callback:`, e);
                    }
                })();
            }));
        }, null, this.disposables);
        events_1.default.on('GlobalChange', async (changed, oldValue, newValue) => {
            var _a;
            let cbs = Array.from((_a = this.globalCallbacks.get(changed)) !== null && _a !== void 0 ? _a : []);
            await Promise.allSettled(cbs.map(cb => {
                return (async () => {
                    try {
                        await Promise.resolve(cb(oldValue, newValue));
                    }
                    catch (e) {
                        this.nvim.errWriteLine(`Error on GlobalChange '${changed}': ${(0, string_1.toErrorText)(e)}`);
                        logger.error(`Error on GlobalChange callback:`, e);
                    }
                })();
            }));
        }, null, this.disposables);
    }
    get options() {
        return Array.from(this.optionCallbacks.keys());
    }
    attach(nvim, env) {
        this.nvim = nvim;
        this.env = env;
        this.watchOption('runtimepath', (oldValue, newValue) => {
            let oldList = oldValue.split(',');
            let newList = newValue.split(',');
            let paths = newList.filter(x => !oldList.includes(x));
            if (paths.length > 0) {
                this._onDidRuntimePathChange.fire(paths);
            }
            this.env.runtimepath = newValue;
        }, this.disposables);
    }
    /**
     * Watch for option change.
     */
    watchOption(key, callback, disposables) {
        let cbs = this.optionCallbacks.get(key);
        if (!cbs) {
            cbs = new Set();
            this.optionCallbacks.set(key, cbs);
        }
        cbs.add(callback);
        let cmd = `autocmd! coc_dynamic_option OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`;
        this.nvim.command(cmd, true);
        let disposable = protocol_1.Disposable.create(() => {
            let cbs = this.optionCallbacks.get(key);
            cbs.delete(callback);
            if (cbs.size === 0)
                this.nvim.command(`autocmd! coc_dynamic_option OptionSet ${key}`, true);
        });
        if (disposables)
            disposables.push(disposable);
        return disposable;
    }
    /**
     * Watch global variable, works on neovim only.
     */
    watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        let cbs = this.globalCallbacks.get(key);
        if (!cbs) {
            cbs = new Set();
            this.globalCallbacks.set(key, cbs);
        }
        cbs.add(callback);
        nvim.call('coc#_watch', key, true);
        let disposable = protocol_1.Disposable.create(() => {
            let cbs = this.globalCallbacks.get(key);
            cbs.delete(callback);
            if (cbs.size === 0)
                nvim.call('coc#_unwatch', key, true);
        });
        if (disposables)
            disposables.push(disposable);
        return disposable;
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
        this._onDidRuntimePathChange.dispose();
    }
}
exports.default = Watchers;
//# sourceMappingURL=watchers.js.map