"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let signature;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    signature = helper_1.default.plugin.getHandler().signature;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
    disposables = [];
});
describe('signatureHelp', () => {
    describe('triggerSignatureHelp', () => {
        it('should show signature by api', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }));
            await helper_1.default.createDocument();
            await nvim.input('foo');
            await commands_1.default.executeCommand('editor.action.triggerParameterHints');
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            let lines = await helper_1.default.getWinLines(win.id);
            expect(lines[2]).toMatch('my signature');
        });
        it('should use 0 when activeParameter is undefined', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo(a)', 'my signature', { label: 'a' })],
                        activeParameter: undefined,
                        activeSignature: null
                    };
                }
            }, []));
            await helper_1.default.createDocument();
            await nvim.input('foo');
            await helper_1.default.doAction('showSignatureHelp');
            await signature.triggerSignatureHelp();
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            let highlights = await win.getVar('highlights');
            expect(highlights).toBeDefined();
            expect(highlights[0].hlGroup).toBe('CocFloatActive');
        });
        it('should trigger by space', async () => {
            let promise = new Promise(resolve => {
                disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                    provideSignatureHelp: (_doc, _position) => {
                        resolve(undefined);
                        return {
                            signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                            activeParameter: null,
                            activeSignature: null
                        };
                    }
                }, [' ']));
            });
            await helper_1.default.createDocument();
            await nvim.input('i');
            await helper_1.default.wait(30);
            await nvim.input(' ');
            await promise;
        });
        it('should show signature help with param label as string', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [
                            vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature'),
                            vscode_languageserver_protocol_1.SignatureInformation.create('foo(a, b)', 'my signature', vscode_languageserver_protocol_1.ParameterInformation.create('a', 'description')),
                        ],
                        activeParameter: 0,
                        activeSignature: 1
                    };
                }
            }, []));
            await helper_1.default.createDocument();
            await nvim.input('foo');
            await signature.triggerSignatureHelp();
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            let lines = await helper_1.default.getWinLines(win.id);
            expect(lines.join('\n')).toMatch(/description/);
        });
    });
    describe('events', () => {
        it('should trigger signature help', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo(x, y)', 'my signature')],
                        activeParameter: 0,
                        activeSignature: 0
                    };
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            await nvim.input('foo');
            await nvim.input('(');
            await helper_1.default.waitValue(async () => {
                let win = await helper_1.default.getFloat();
                return win != null;
            }, true);
            let win = await helper_1.default.getFloat();
            let lines = await helper_1.default.getWinLines(win.id);
            expect(lines[2]).toMatch('my signature');
        });
        it('should cancel trigger on InsertLeave', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: async (_doc, _position, token) => {
                    return new Promise(resolve => {
                        let timer = setTimeout(() => {
                            resolve({
                                signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                                activeParameter: null,
                                activeSignature: null
                            });
                        }, 1000);
                        token.onCancellationRequested(() => {
                            clearTimeout(timer);
                            resolve(undefined);
                        });
                    });
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            await nvim.input('foo');
            let p = signature.triggerSignatureHelp();
            await helper_1.default.wait(10);
            await nvim.command('stopinsert');
            await nvim.call('feedkeys', [String.fromCharCode(27), 'in']);
            let res = await p;
            expect(res).toBe(false);
        });
        it('should not close signature on type', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }, ['( ,']));
            let doc = await helper_1.default.createDocument();
            await nvim.input('foo(');
            await doc.synchronize();
            await nvim.input('bar');
            await doc.synchronize();
            await helper_1.default.waitFloat();
            let win = await helper_1.default.getFloat();
            let lines = await helper_1.default.getWinLines(win.id);
            expect(lines[2]).toMatch('my signature');
        });
        it('should close signature float when empty signatures returned', async () => {
            let empty = false;
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    if (empty)
                        return undefined;
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            await nvim.input('foo(');
            await helper_1.default.wait(100);
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            empty = true;
            await signature.triggerSignatureHelp();
            await helper_1.default.wait(50);
            let res = await nvim.call('coc#float#valid', [win.id]);
            expect(res).toBe(0);
        });
        it('should close float on cursor moved', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }, ['(', ',']));
            const show = async () => {
                await helper_1.default.createDocument();
                await nvim.input('i');
                await nvim.call('append', [1, 'bar']);
                await nvim.input('(');
                await helper_1.default.waitValue(async () => {
                    let win = await helper_1.default.getFloat();
                    return win != null;
                }, true);
            };
            await show();
            await nvim.call('cursor', [2, 1]);
            await helper_1.default.waitValue(async () => {
                let win = await helper_1.default.getFloat();
                return win == null;
            }, true);
            await nvim.input('<esc>');
            await show();
            await nvim.input(')');
            await helper_1.default.waitValue(async () => {
                let win = await helper_1.default.getFloat();
                return win == null;
            }, true);
        });
    });
    describe('float window', () => {
        it('should align signature window to top', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            let buf = await nvim.buffer;
            await buf.setLines(['', '', '', '', ''], { start: 0, end: -1, strictIndexing: true });
            await nvim.call('cursor', [5, 1]);
            await nvim.input('foo(');
            await helper_1.default.wait(100);
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            let lines = await helper_1.default.getWinLines(win.id);
            expect(lines[2]).toMatch('my signature');
            let res = await nvim.call('GetFloatCursorRelative', [win.id]);
            expect(res.row).toBeLessThan(0);
        });
        it('should show parameter docs', async () => {
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo(a, b)', 'my signature', vscode_languageserver_protocol_1.ParameterInformation.create('a', 'foo'), vscode_languageserver_protocol_1.ParameterInformation.create([7, 8], 'bar'))],
                        activeParameter: 1,
                        activeSignature: null
                    };
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            let buf = await nvim.buffer;
            await buf.setLines(['', '', '', '', ''], { start: 0, end: -1, strictIndexing: true });
            await nvim.call('cursor', [5, 1]);
            await nvim.input('foo(a,');
            await helper_1.default.wait(100);
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            let lines = await helper_1.default.getWinLines(win.id);
            expect(lines.join('\n')).toMatch('bar');
        });
    });
    describe('configurations', () => {
        let { configurations } = workspace_1.default;
        afterEach(() => {
            configurations.updateMemoryConfig({
                'signature.target': 'float',
                'signature.hideOnTextChange': false,
                'signature.enable': true,
                'signature.triggerSignatureWait': 500
            });
        });
        it('should cancel signature on timeout', async () => {
            configurations.updateMemoryConfig({ 'signature.triggerSignatureWait': 50 });
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position, token) => {
                    return new Promise(resolve => {
                        token.onCancellationRequested(() => {
                            clearTimeout(timer);
                            resolve(undefined);
                        });
                        let timer = setTimeout(() => {
                            resolve({
                                signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                                activeParameter: null,
                                activeSignature: null
                            });
                        }, 200);
                    });
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            await signature.triggerSignatureHelp();
            let win = await helper_1.default.getFloat();
            expect(win).toBeUndefined();
            configurations.updateMemoryConfig({ 'signature.triggerSignatureWait': 100 });
        });
        it('should hide signature window on text change', async () => {
            configurations.updateMemoryConfig({ 'signature.hideOnTextChange': true });
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            await nvim.input('ifoo(');
            let winid = await helper_1.default.waitFloat();
            await nvim.input('x');
            await helper_1.default.wait(100);
            let res = await nvim.call('coc#float#valid', [winid]);
            expect(res).toBe(0);
            configurations.updateMemoryConfig({ 'signature.hideOnTextChange': false });
        });
        it('should disable signature help trigger', async () => {
            configurations.updateMemoryConfig({ 'signature.enable': false });
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo()', 'my signature')],
                        activeParameter: null,
                        activeSignature: null
                    };
                }
            }, ['(', ',']));
            await helper_1.default.createDocument();
            await nvim.input('foo');
            await nvim.input('(');
            await helper_1.default.wait(100);
            let win = await helper_1.default.getFloat();
            expect(win).toBeUndefined();
        });
        it('should echo simple signature help', async () => {
            let idx = 0;
            let activeSignature = null;
            configurations.updateMemoryConfig({ 'signature.target': 'echo' });
            disposables.push(languages_1.default.registerSignatureHelpProvider([{ scheme: 'file' }], {
                provideSignatureHelp: (_doc, _position) => {
                    return {
                        signatures: [vscode_languageserver_protocol_1.SignatureInformation.create('foo(a, b)', 'my signature', vscode_languageserver_protocol_1.ParameterInformation.create('a', 'foo'), vscode_languageserver_protocol_1.ParameterInformation.create([7, 8], 'bar')),
                            vscode_languageserver_protocol_1.SignatureInformation.create('a'.repeat(workspace_1.default.env.columns + 10))
                        ],
                        activeParameter: idx,
                        activeSignature
                    };
                }
            }, []));
            await helper_1.default.createDocument();
            await nvim.input('foo(');
            await signature.triggerSignatureHelp();
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('(a, b)');
            await nvim.input('a,');
            idx = 1;
            await signature.triggerSignatureHelp();
            line = await helper_1.default.getCmdline();
            expect(line).toMatch('foo(a, b)');
            activeSignature = 1;
            await signature.triggerSignatureHelp();
            line = await helper_1.default.getCmdline();
            expect(line).toMatch('aaaaaa');
        });
    });
});
//# sourceMappingURL=signature.test.js.map