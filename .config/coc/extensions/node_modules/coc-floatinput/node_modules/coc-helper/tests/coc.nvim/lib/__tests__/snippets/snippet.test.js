"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const textdocument_1 = require("../../model/textdocument");
const eval_1 = require("../../snippets/eval");
const parser_1 = require("../../snippets/parser");
const snippet_1 = require("../../snippets/snippet");
const variableResolve_1 = require("../../snippets/variableResolve");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    let pyfile = path_1.default.join(__dirname, '../ultisnips.py');
    await nvim.command(`execute 'pyxfile '.fnameescape('${pyfile}')`);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
async function createSnippet(snippet, opts, range = vscode_languageserver_types_1.Range.create(0, 0, 0, 0), line = '') {
    let resolver = new variableResolve_1.SnippetVariableResolver(nvim, workspace_1.default.workspaceFolderControl);
    let snip = new snippet_1.CocSnippet(snippet, vscode_languageserver_types_1.Position.create(0, 0), nvim, resolver);
    let context;
    if (opts)
        context = Object.assign({ range, line }, opts);
    await snip.init(context);
    return snip;
}
function createTextDocument(text) {
    return new textdocument_1.LinesTextDocument('file://a', 'txt', 1, text.split('\n'), 1, true);
}
describe('CocSnippet', () => {
    async function assertResult(snip, resolved, opts) {
        let c = await createSnippet(snip, opts);
        expect(c.text).toBe(resolved);
    }
    async function assertPyxValue(code, res) {
        let val = await nvim.call(`pyxeval`, code);
        if (typeof res === 'number' || typeof res === 'string' || typeof res === 'boolean') {
            expect(val).toBe(res);
        }
        else if (res instanceof RegExp) {
            expect(val).toMatch(res);
        }
        else {
            expect(val).toEqual(res);
        }
    }
    describe('resolveVariables()', () => {
        it('should padZero', () => {
            expect((0, variableResolve_1.padZero)(1)).toBe('01');
            expect((0, variableResolve_1.padZero)(10)).toBe('10');
        });
        it('should getVariablesCode', () => {
            expect((0, eval_1.getVariablesCode)({})).toBe('t = ()');
            expect((0, eval_1.getVariablesCode)({ 1: 'foo', 3: 'bar' })).toBe('t = ("","foo","","bar",)');
        });
        it('should resolve uppercase variables', async () => {
            let doc = await helper_1.default.createDocument();
            let fsPath = vscode_uri_1.URI.parse(doc.uri).fsPath;
            await assertResult('$TM_FILENAME', path_1.default.basename(fsPath));
            await assertResult('$TM_FILENAME_BASE', path_1.default.basename(fsPath, path_1.default.extname(fsPath)));
            await assertResult('$TM_DIRECTORY', path_1.default.dirname(fsPath));
            await assertResult('$TM_FILEPATH', fsPath);
            await nvim.call('setreg', ['""', 'foo']);
            await assertResult('$YANK', 'foo');
            await assertResult('$TM_LINE_INDEX', '0');
            await assertResult('$TM_LINE_NUMBER', '1');
            await nvim.setLine('foo');
            await assertResult('$TM_CURRENT_LINE', 'foo');
            await nvim.call('setreg', ['*', 'foo']);
            await assertResult('$CLIPBOARD', 'foo');
            let d = new Date();
            await assertResult('$CURRENT_YEAR', d.getFullYear().toString());
            await assertResult('$NOT_EXISTS', 'NOT_EXISTS');
            await assertResult('$TM_CURRENT_WORD', 'foo');
        });
        it('should resolve new VSCode variables', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.buffer.setOption('comments', 's1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-');
            await doc.buffer.setOption('commentstring', '');
            let fsPath = vscode_uri_1.URI.parse(doc.uri).fsPath;
            let c = await createSnippet('$RANDOM');
            expect(c.text.length).toBe(6);
            c = await createSnippet('$RANDOM_HEX');
            expect(c.text.length).toBe(6);
            c = await createSnippet('$UUID');
            expect(c.text).toMatch('-');
            c = await createSnippet('$RELATIVE_FILEPATH');
            expect(c.text).toMatch(path_1.default.basename(fsPath));
            c = await createSnippet('$WORKSPACE_NAME');
            expect(c.text.length).toBeGreaterThan(0);
            c = await createSnippet('$WORKSPACE_FOLDER');
            expect(c.text.length).toBeGreaterThan(0);
            await assertResult('$LINE_COMMENT', '//');
            await assertResult('$BLOCK_COMMENT_START', '/*');
            await assertResult('$BLOCK_COMMENT_END', '*/');
            await doc.buffer.setOption('comments', '');
            await doc.buffer.setOption('commentstring', '// %s');
            await assertResult('$LINE_COMMENT', '//');
            await assertResult('$BLOCK_COMMENT_START', '');
            await assertResult('$BLOCK_COMMENT_END', '');
        });
        it('should resolve variables in placeholders', async () => {
            await nvim.setLine('foo');
            await assertResult('$1 ${1:$TM_CURRENT_LINE}', 'foo foo');
            await assertResult('$1 ${1:$TM_CURRENT_LINE bar}', 'foo bar foo bar');
            await assertResult('$2 ${2:|${1:$TM_CURRENT_LINE}|}', '|foo| |foo|');
            await assertResult('$1 $2 ${2:${1:|$TM_CURRENT_LINE|}}', '|foo| |foo| |foo|');
        });
        it('should resolve variables  with default value', async () => {
            await assertResult('$1 ${1:${VISUAL:foo}}', 'foo foo');
        });
        it('should resolve for lower case variables', async () => {
            await assertResult('${foo:abcdef} ${bar}', 'abcdef bar');
            await assertResult('${1:${foo:abcdef}} ${1/^\\w\\w(.*)/$1/}', 'abcdef cdef');
        });
    });
    describe('code block initialize', () => {
        it('should init shell code block', async () => {
            await assertResult('`echo "hello"` world', 'hello world', {});
        });
        it('should init vim block', async () => {
            await assertResult('`!v eval("1 + 1")` = 2', '2 = 2', {});
            await nvim.setLine('  ');
            await assertResult('${1:`!v indent(".")`} "$1"', '2 "2"', {});
        });
        it('should init code block in placeholders', async () => {
            await assertResult('f ${1:`echo "b"`}', 'f b', {});
            await assertResult('f ${1:`!v "b"`}', 'f b', {});
            await assertResult('f ${1:`!p snip.rv = "b"`}', 'f b', {});
        });
        it('should setup python globals', async () => {
            await helper_1.default.edit('t.js');
            await createSnippet('`!p snip.rv = fn`', {});
            await assertPyxValue('fn', 't.js');
            await assertPyxValue('path', /t\.js$/);
            await assertPyxValue('t', ['']);
            await assertPyxValue('context', true);
            await createSnippet('`!p snip.rv = fn`', {
                regex: '[ab]',
                context: 'False'
            }, vscode_languageserver_types_1.Range.create(0, 2, 0, 3), 'a b');
            await assertPyxValue('context', false);
            await assertPyxValue('match.group(0)', 'b');
        });
        it('should setup python match', async () => {
            let c = await createSnippet('\\\\frac{`!p snip.rv = match.group(1)`}{$1}$0', {
                regex: '((\\d+)|(\\d*)(\\\\)?([A-Za-z]+)((\\^|_)(\\{\\d+\\}|\\d))*)/',
                context: 'True'
            }, vscode_languageserver_types_1.Range.create(0, 0, 0, 3), '20/');
            await assertPyxValue('context', true);
            await assertPyxValue('match.group(1)', '20');
            expect(c.text).toBe('\\frac{20}{}');
        });
        it('should work with methods of snip', async () => {
            await nvim.command('setl shiftwidth=4 ft=txt tabstop=4 expandtab');
            await createSnippet('`!p snip.rv = "a"`', {}, vscode_languageserver_types_1.Range.create(0, 4, 0, 8), '    abcd');
            await (0, eval_1.executePythonCode)(nvim, [
                'snip.shift(1)',
                // ultisnip indent only when there's '\n' in snip.rv
                'snip += ""',
                'newLine = snip.mkline("foo")'
            ]);
            await assertPyxValue('newLine', '        foo');
            await (0, eval_1.executePythonCode)(nvim, [
                'snip.unshift(1)',
                'newLine = snip.mkline("b")'
            ]);
            await assertPyxValue('newLine', '    b');
            await (0, eval_1.executePythonCode)(nvim, [
                'snip.shift(1)',
                'snip.reset_indent()',
                'newLine = snip.mkline("f")'
            ]);
            await assertPyxValue('newLine', '    f');
            await (0, eval_1.executePythonCode)(nvim, [
                'fff = snip.opt("&fff", "foo")',
                'ft = snip.opt("&ft", "ft")',
            ]);
            await assertPyxValue('fff', 'foo');
            await assertPyxValue('ft', 'txt');
        });
        it('should init python code block', async () => {
            await assertResult('`!p snip.rv = "a"` = a', 'a = a', {});
            await assertResult('`!p snip.rv = t[1]` = ${1:a}', 'a = a', {});
            await assertResult('`!p snip.rv = t[1]` = ${1:`!v eval("\'a\'")`}', 'a = a', {});
            await assertResult('`!p snip.rv = t[1] + t[2]` = ${1:a} ${2:b}', 'ab = a b', {});
        });
        it('should init python placeholder', async () => {
            await assertResult('foo ${1/^\\|(.*)\\|$/$1/} ${1:|`!p snip.rv = "a"`|}', 'foo a |a|', {});
            await assertResult('foo $1 ${1:`!p snip.rv = "a"`}', 'foo a a', {});
            await assertResult('${1/^_(.*)/$1/} $1 aa ${1:`!p snip.rv = "_foo"`}', 'foo _foo aa _foo', {});
        });
        it('should init nested python placeholder', async () => {
            await assertResult('${1:foo`!p snip.rv = t[2]`} ${2:bar} $1', 'foobar bar foobar', {});
            await assertResult('${3:f${2:oo${1:b`!p snip.rv = "ar"`}}} `!p snip.rv = t[3]`', 'foobar foobar', {});
        });
        it('should recursive init python placeholder', async () => {
            await assertResult('${1:`!p snip.rv = t[2]`} ${2:`!p snip.rv = t[3]`} ${3:`!p snip.rv = t[4][0]`} ${4:bar}', 'b b b bar', {});
            await assertResult('${1:foo} ${2:`!p snip.rv = t[1][0]`} ${3:`!p snip.rv = ""`} ${4:`!p snip.rv = t[2]`}', 'foo f  f', {});
        });
        it('should update python block from placeholder', async () => {
            await assertResult('`!p snip.rv = t[1][0] if len(t[1]) > 0 else ""` ${1:`!p snip.rv = t[2]`} ${2:foo}', 'f foo foo', {});
        });
        it('should update nested placeholder values', async () => {
            let c = await createSnippet('${2:foo ${1:`!p snip.rv = "bar"`}} ${2/^\\w//} `!p snip.rv = t[2]`', {});
            expect(c.text).toBe('foo bar oo bar foo bar');
        });
        it('should update variable marker', async () => {
            let c = await createSnippet('${1:${VISUAL}`!p snip.rv = "bar"`} $1', {});
            let variable = c.tmSnippet.placeholders[0].children[0];
            await c.tmSnippet.update(nvim, variable, 'x');
            expect(c.tmSnippet.toString()).toBe('bar bar');
            variable = new parser_1.Variable('name');
            await c.tmSnippet.update(nvim, variable, 'x');
        });
    });
    describe('getContentBefore()', () => {
        it('should get text before marker', async () => {
            let c = await createSnippet('${1:foo} ${2:bar}', {});
            let markers = c.placeholders;
            let p = markers[0].parent;
            expect(p instanceof parser_1.TextmateSnippet).toBe(true);
            expect((0, snippet_1.getContentBefore)(p)).toBe('');
            expect((0, snippet_1.getContentBefore)(markers[0])).toBe('');
            expect((0, snippet_1.getContentBefore)(markers[1])).toBe('foo ');
        });
        it('should get text before nested marker', async () => {
            let c = await createSnippet('${1:foo} ${2:is nested with $4} $3 bar', {});
            let markers = c.placeholders;
            let p = markers.find(o => o.index == 4);
            expect((0, snippet_1.getContentBefore)(p)).toBe('foo is nested with ');
            p = markers.find(o => o.index == 0);
            expect((0, snippet_1.getContentBefore)(p)).toBe('foo is nested with   bar');
        });
        it('should consider normal line break', async () => {
            let c = await createSnippet('${1:foo}\n${2:is nested with $4}', {});
            let markers = c.placeholders;
            let p = markers.find(o => o.index == 4);
            expect((0, snippet_1.getContentBefore)(p)).toBe('is nested with ');
        });
        it('should consider line break after update', async () => {
            let c = await createSnippet('${1:foo} ${2}', {});
            let p = c.getPlaceholder(1);
            await c.tmSnippet.update(nvim, p.marker, 'abc\ndef');
            let markers = c.placeholders;
            let placeholder = markers.find(o => o.index == 2);
            expect((0, snippet_1.getContentBefore)(placeholder)).toBe('def ');
        });
    });
    describe('getSortedPlaceholders()', () => {
        it('should get sorted placeholders', async () => {
            const assert = (snip, index, indexes) => {
                let curr = index == null ? undefined : snip.getPlaceholder(index);
                let res = snip.getSortedPlaceholders(curr);
                expect(res.map(o => o.index)).toEqual(indexes);
            };
            let c = await createSnippet('${1:foo} ${2/^\\w//} ${2:bar} ', {});
            assert(c, undefined, [1, 2, 0]);
            assert(c, 1, [1, 2, 0]);
            assert(c, 2, [2, 1, 0]);
        });
        it('should compares placeholders', () => {
            expect((0, snippet_1.comparePlaceholder)({ primary: false, index: 1 }, { primary: false, index: 0 })).toBe(-1);
            expect((0, snippet_1.comparePlaceholder)({ primary: true, index: 1 }, { primary: false, index: 1 })).toBe(-1);
        });
    });
    describe('getNewText()', () => {
        it('should getNewText for placeholder', async () => {
            let c = await createSnippet('before ${1:foo} after$2', {});
            let p = c.getPlaceholder(1);
            expect(c.getNewText(p, `fff`)).toBe(undefined);
            expect(c.getNewText(p, `before foo `)).toBe(undefined);
            expect(c.getNewText(p, `before foo afteralll`)).toBe(undefined);
            expect(c.getNewText(p, `before bar after`)).toBe('bar');
            p = c.getPlaceholder(2);
            expect(c.getNewText(p, `before foo afterbar`)).toBe('bar');
        });
    });
    describe('updatePlaceholder()', () => {
        async function assertUpdate(text, value, result, index = 1, ultisnip = {}) {
            let c = await createSnippet(text, ultisnip);
            let p = c.getPlaceholder(index);
            expect(p != null).toBe(true);
            await c.tmSnippet.update(nvim, p.marker, value);
            expect(c.tmSnippet.toString()).toBe(result);
            return c;
        }
        it('should update variable placeholders', async () => {
            await assertUpdate('${foo} ${foo}', 'bar', 'bar bar', 1, null);
            await assertUpdate('${foo} ${foo:x}', 'bar', 'bar bar', 1, null);
            await assertUpdate('${1:${foo:x}} $1', 'bar', 'bar bar', 1, null);
        });
        it('should work with snip.c', async () => {
            let code = [
                '#ifndef ${1:`!p',
                'if not snip.c:',
                '  import random, string',
                "  name = re.sub(r'[^A-Za-z0-9]+','_', snip.fn).upper()",
                "  rand = ''.join(random.sample(string.ascii_letters+string.digits, 8))",
                "  snip.rv = ('%s_%s' % (name,rand)).upper()",
                "else:",
                "  snip.rv = snip.c + t[2]`}",
                '#define $1',
                '$2'
            ].join('\n');
            let c = await createSnippet(code, {});
            let first = c.text.split('\n')[0];
            let p = c.getPlaceholder(2);
            expect(p).toBeDefined();
            await c.tmSnippet.update(nvim, p.marker, 'foo');
            let t = c.tmSnippet.toString();
            expect(t.startsWith(first)).toBe(true);
            expect(t.split('\n').map(s => s.endsWith('foo'))).toEqual([true, true, true]);
        });
        it('should calculate delta', async () => {
            // TODO
        });
        it('should update placeholder with code blocks', async () => {
            await assertUpdate('${1:`echo "foo"`} $1', 'bar', 'bar bar');
            await assertUpdate('${2:${1:`echo "foo"`}} $2', 'bar', 'bar bar');
            await assertUpdate('${1:`!v "foo"`} $1', 'bar', 'bar bar');
            await assertUpdate('${1:`!p snip.rv = "foo"`} $1', 'bar', 'bar bar');
        });
        it('should update related python blocks', async () => {
            // multiple
            await assertUpdate('`!p snip.rv = t[1]` ${1:`!p snip.rv = "foo"`} `!p snip.rv = t[1]`', 'bar', 'bar bar bar');
            // parent
            await assertUpdate('`!p snip.rv = t[2]` ${2:foo ${1:`!p snip.rv = "foo"`}}', 'bar', 'foo bar foo bar');
            // related placeholders
            await assertUpdate('${2:foo `!p snip.rv = t[1]`} ${1:`!p snip.rv = "foo"`}', 'bar', 'foo bar bar');
        });
        it('should update python code blocks with normal placeholder values', async () => {
            await assertUpdate('`!p snip.rv = t[1]` $1 `!p snip.rv = t[1]`', 'bar', 'bar bar bar');
            await assertUpdate('`!p snip.rv = t[2]` ${2:foo $1}', 'bar', 'foo bar foo bar');
            await assertUpdate('${2:foo `!p snip.rv = t[1]`} $1', 'bar', 'foo bar bar');
        });
        it('should reset values for removed placeholders', async () => {
            // Keep remained placeholder this is same behavior of VSCode.
            let s = await assertUpdate('${2:bar${1:foo}} $2 $1', 'bar', 'bar bar foo', 2);
            let prev = s.getPrevPlaceholder(2);
            expect(prev).toBeDefined();
            expect(prev.value).toBe('foo');
            // python placeholder, reset to empty value
            await assertUpdate('${2:bar${1:foo}} $2 `!p snip.rv = t[1]`', 'bar', 'bar bar ', 2);
            // not reset since $1 still exists
            await assertUpdate('${2:bar${1:foo}} $2 $1 `!p snip.rv = t[1]`', 'bar', 'bar bar foo foo', 2);
        });
    });
    describe('getRanges()', () => {
        it('should get ranges of placeholder', async () => {
            let c = await createSnippet('${2:${1:x} $1}\n$2', {});
            let p = c.getPlaceholder(1);
            let arr = c.getRanges(p);
            expect(arr.length).toBe(4);
            expect(arr[0]).toEqual(vscode_languageserver_types_1.Range.create(0, 0, 0, 1));
            expect(arr[1]).toEqual(vscode_languageserver_types_1.Range.create(0, 2, 0, 3));
            expect(arr[2]).toEqual(vscode_languageserver_types_1.Range.create(1, 0, 1, 1));
            expect(arr[3]).toEqual(vscode_languageserver_types_1.Range.create(1, 2, 1, 3));
            expect(c.text).toBe('x x\nx x');
        });
    });
    describe('insertSnippet()', () => {
        it('should update indexes of python blocks', async () => {
            let c = await createSnippet('${1:a} ${2:b} ${3:`!p snip.rv=t[2]`}', {});
            let p = c.getPlaceholder(1);
            await c.insertSnippet(p, '${1:foo} ${2:bar}', ['', '']);
            expect(c.text).toBe('foo bar b b');
            p = c.getPlaceholder(5);
            expect(p.after).toBe(' b');
            let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await c.updatePlaceholder(p, vscode_languageserver_types_1.Position.create(0, 9), 'xyz', source.token);
            expect(res.text).toBe('foo bar xyz xyz');
        });
        it('should insert nested placeholder', async () => {
            let c = await createSnippet('${1:foo}\n$1', {});
            let p = c.getPlaceholder(1);
            let marker = await c.insertSnippet(p, '${1:x} $1', ['', '']);
            p = c.getPlaceholder(marker.index);
            let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await c.updatePlaceholder(p, vscode_languageserver_types_1.Position.create(0, 3), 'bar', source.token);
            expect(res.text).toBe('bar bar\nbar bar');
            expect(res.delta).toEqual(vscode_languageserver_types_1.Position.create(0, 0));
        });
        it('should insert nested python snippet', async () => {
            let c = await createSnippet('${1:foo}\n`!p snip.rv = t[1]`', {});
            let p = c.getPlaceholder(1);
            let line = await nvim.line;
            let marker = await c.insertSnippet(p, '${1:x} `!p snip.rv = t[1]`', ['', ''], { line, range: vscode_languageserver_types_1.Range.create(0, 0, 0, 3) });
            p = c.getPlaceholder(marker.index);
            expect(c.text).toBe('x x\nx x');
            let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await c.updatePlaceholder(p, vscode_languageserver_types_1.Position.create(0, 1), 'bar', source.token);
            expect(res.text).toBe('bar bar\nbar bar');
            await (0, eval_1.executePythonCode)(nvim, [`snip = ContextSnippet()`]);
            let val = await nvim.call('pyxeval', 'snip.last_placeholder.current_text');
            expect(val).toBe('foo');
        });
        it('should insert python snippet to normal snippet', async () => {
            let c = await createSnippet('${1:foo}\n$1', {});
            let p = c.getPlaceholder(1);
            expect(c.hasPython).toBe(false);
            let marker = await c.insertSnippet(p, '${1:x} `!p snip.rv = t[1]`', ['', ''], { line: '', range: vscode_languageserver_types_1.Range.create(0, 0, 0, 3) });
            p = c.getPlaceholder(marker.index);
            expect(c.text).toBe('x x\nx x');
            let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await c.updatePlaceholder(p, vscode_languageserver_types_1.Position.create(0, 1), 'bar', source.token);
            expect(res.text).toBe('bar bar\nbar bar');
            expect(c.hasPython).toBe(true);
        });
        it('should not change match for original placeholders', async () => {
            let c = await createSnippet('`!p snip.rv = match.group(1)` $1', {
                regex: '^(\\w+)'
            }, vscode_languageserver_types_1.Range.create(0, 0, 0, 3), 'foo');
            let p = c.getPlaceholder(1);
            expect(c.hasPython).toBe(true);
            expect(c.text).toBe('foo ');
            await c.insertSnippet(p, '`!p snip.rv = match.group(1)`', ['', ''], {
                regex: '^(\\w+)',
                line: 'bar',
                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 3)
            });
            expect(c.text).toBe('foo bar');
        });
    });
    describe('utils', () => {
        function assertThrow(fn) {
            let err;
            try {
                fn();
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeDefined();
        }
        it('should check shouldFormat', () => {
            expect((0, snippet_1.shouldFormat)(' f')).toBe(true);
            expect((0, snippet_1.shouldFormat)('a\nb')).toBe(true);
            expect((0, snippet_1.shouldFormat)('foo')).toBe(false);
        });
        it('should normalizeSnippetString', () => {
            expect((0, snippet_1.normalizeSnippetString)('a\n\n\tb', '  ', {
                insertSpaces: true,
                tabSize: 2
            })).toBe('a\n\n    b');
            expect((0, snippet_1.normalizeSnippetString)('a\n\n  b', '\t', {
                insertSpaces: false,
                tabSize: 2
            })).toBe('a\n\n\t\tb');
        });
        it('should throw for invalid regex', async () => {
            assertThrow(() => {
                (0, eval_1.convertRegex)('\\z');
            });
            assertThrow(() => {
                (0, eval_1.convertRegex)('(?s)');
            });
            assertThrow(() => {
                (0, eval_1.convertRegex)('(?x)');
            });
            assertThrow(() => {
                (0, eval_1.convertRegex)('a\nb');
            });
            assertThrow(() => {
                (0, eval_1.convertRegex)('(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)');
            });
            assertThrow(() => {
                (0, eval_1.convertRegex)('(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|)');
            });
        });
        it('should convert regex', async () => {
            // \\A
            expect((0, eval_1.convertRegex)('\\A')).toBe('^');
            expect((0, eval_1.convertRegex)('f(?#abc)b')).toBe('fb');
            expect((0, eval_1.convertRegex)('f(?P<abc>def)b')).toBe('f(?<abc>def)b');
            expect((0, eval_1.convertRegex)('f(?P=abc)b')).toBe('f\\k<abc>b');
        });
        it('should catch error with executePythonCode', async () => {
            let fn = async () => {
                await (0, eval_1.executePythonCode)(nvim, ['INVALID_CODE']);
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should set error with addPythonTryCatch', async () => {
            let code = (0, eval_1.addPythonTryCatch)('INVALID_CODE', true);
            await nvim.command(`pyx ${code}`);
            let msg = await nvim.getVar('errmsg');
            expect(msg).toBeDefined();
            expect(msg).toMatch('INVALID_CODE');
        });
        it('should parse comments', async () => {
            expect((0, variableResolve_1.parseCommentstring)('a%sb')).toBeUndefined();
            expect((0, variableResolve_1.parseCommentstring)('// %s')).toBe('//');
            expect((0, variableResolve_1.parseComments)('')).toEqual({
                start: undefined,
                end: undefined,
                single: undefined
            });
            expect((0, variableResolve_1.parseComments)('s:/*')).toEqual({
                start: '/*',
                end: undefined,
                single: undefined
            });
            expect((0, variableResolve_1.parseComments)('e:*/')).toEqual({
                end: '*/',
                start: undefined,
                single: undefined
            });
            expect((0, variableResolve_1.parseComments)(':#,:b')).toEqual({
                end: undefined,
                start: undefined,
                single: '#'
            });
        });
        it('should reduce TextEdit', () => {
            let e;
            e = vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 0, 3), 'foo');
            expect((0, snippet_1.reduceTextEdit)(e, '')).toEqual(e);
            e = vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 0, 3), 'foo\nbar');
            expect((0, snippet_1.reduceTextEdit)(e, 'bar')).toEqual(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 0, 0), 'foo\n'));
            e = vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 0, 3), 'foo\nbar');
            expect((0, snippet_1.reduceTextEdit)(e, 'foo')).toEqual(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 3, 0, 3), '\nbar'));
            e = vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 0, 3), 'def');
            expect((0, snippet_1.reduceTextEdit)(e, 'daf')).toEqual(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 1, 0, 2), 'e'));
            e = vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(2, 0, 3, 0), 'ascii ascii bar\n');
            expect((0, snippet_1.reduceTextEdit)(e, 'xyz ascii bar\n')).toEqual(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(2, 0, 2, 3), 'ascii'));
        });
        it('should get new end position', () => {
            let assert = (pos, oldText, newText, res) => {
                expect((0, snippet_1.getEndPosition)(pos, createTextDocument(oldText), createTextDocument(newText))).toEqual(res);
            };
            assert(vscode_languageserver_types_1.Position.create(0, 0), 'foo', 'bar', undefined);
            assert(vscode_languageserver_types_1.Position.create(0, 0), 'foo\nbar', 'bar', undefined);
            assert(vscode_languageserver_types_1.Position.create(0, 0), 'foo\nbar', 'x\nfoo\nba', undefined);
            assert(vscode_languageserver_types_1.Position.create(0, 0), 'foo\nbar', 'x\nfoo\nbar', vscode_languageserver_types_1.Position.create(1, 0));
            assert(vscode_languageserver_types_1.Position.create(0, 0), 'foo', 'foo', vscode_languageserver_types_1.Position.create(0, 0));
        });
        it('should check content before position', () => {
            let assert = (pos, oldText, newText, res) => {
                expect((0, snippet_1.checkContentBefore)(pos, createTextDocument(oldText), createTextDocument(newText))).toBe(res);
            };
            assert(vscode_languageserver_types_1.Position.create(1, 0), 'foo\nbar', 'foo', true);
            assert(vscode_languageserver_types_1.Position.create(1, 1), 'foo\nbar', 'foo', false);
            assert(vscode_languageserver_types_1.Position.create(2, 0), 'foo\nbar\n', 'foo', false);
            assert(vscode_languageserver_types_1.Position.create(1, 1), 'foo\nbar', 'foo\nbd', true);
            assert(vscode_languageserver_types_1.Position.create(1, 1), 'foo\nbar', 'foo\nab', false);
            assert(vscode_languageserver_types_1.Position.create(1, 1), 'foo\nbar', 'aoo\nbb', false);
        });
        it('should getParts by range', async () => {
            expect((0, snippet_1.getParts)('abcdef', vscode_languageserver_types_1.Range.create(1, 5, 1, 11), vscode_languageserver_types_1.Range.create(1, 6, 1, 10))).toEqual(['a', 'f']);
            expect((0, snippet_1.getParts)('abc\nfoo\ndef', vscode_languageserver_types_1.Range.create(0, 5, 2, 3), vscode_languageserver_types_1.Range.create(1, 1, 1, 2))).toEqual(['abc\nf', 'o\ndef']);
            expect((0, snippet_1.getParts)('abc\ndef', vscode_languageserver_types_1.Range.create(0, 1, 2, 3), vscode_languageserver_types_1.Range.create(0, 1, 2, 3))).toEqual(['', '']);
        });
    });
});
//# sourceMappingURL=snippet.test.js.map