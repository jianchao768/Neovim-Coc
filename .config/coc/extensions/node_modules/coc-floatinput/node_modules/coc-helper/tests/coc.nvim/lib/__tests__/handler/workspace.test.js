"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const extension_1 = tslib_1.__importDefault(require("../../extension"));
const util_1 = require("../../util");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let handler;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    handler = helper_1.default.plugin.getHandler().workspace;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('Workspace handler', () => {
    async function checkFloat(content) {
        let win = await helper_1.default.getFloat();
        expect(win).toBeDefined();
        let buf = await win.buffer;
        let lines = await buf.lines;
        expect(lines.join('\n')).toMatch(content);
    }
    describe('methods', () => {
        it('should check filetype', async () => {
            await helper_1.default.createDocument('t.vim');
            await commands_1.default.executeCommand('document.echoFiletype');
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('vim');
        });
        it('should show workspace folders', async () => {
            await helper_1.default.edit(__filename);
            await commands_1.default.executeCommand('workspace.workspaceFolders');
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('coc.nvim');
        });
        it('should write writeHeapSnapshot', async () => {
            const v8 = require('v8');
            let called = false;
            let spy = jest.spyOn(v8, 'writeHeapSnapshot').mockImplementation(() => {
                called = true;
            });
            let filepath = await commands_1.default.executeCommand('workspace.writeHeapSnapshot');
            spy.mockRestore();
            expect(filepath).toBeDefined();
            expect(called).toBe(true);
        });
        it('should show output', async () => {
            window_1.default.createOutputChannel('foo');
            window_1.default.createOutputChannel('bar');
            let p = commands_1.default.executeCommand('workspace.showOutput');
            await helper_1.default.waitFloat();
            await nvim.input('<esc>');
            await p;
            let bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toBe('');
            await commands_1.default.executeCommand('workspace.showOutput', 'foo');
            bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toMatch('output');
        });
        it('should rename buffer', async () => {
            let doc = await helper_1.default.createDocument('a');
            let fsPath = vscode_uri_1.URI.parse(doc.uri).fsPath.replace(/a$/, 'b');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(fsPath))
                    fs_1.default.unlinkSync(fsPath);
            }));
            let p = handler.renameCurrent();
            await helper_1.default.wait(50);
            await nvim.input('<backspace>b<cr>');
            await p;
            let name = await nvim.eval('bufname("%")');
            expect(name.endsWith('b')).toBe(true);
        });
        it('should rename file', async () => {
            let fsPath = path_1.default.join(os_1.default.tmpdir(), 'x');
            let newPath = path_1.default.join(os_1.default.tmpdir(), 'b');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(fsPath))
                    fs_1.default.unlinkSync(fsPath);
                if (fs_1.default.existsSync(newPath))
                    fs_1.default.unlinkSync(newPath);
            }));
            fs_1.default.writeFileSync(fsPath, 'foo', 'utf8');
            await helper_1.default.createDocument(fsPath);
            let p = commands_1.default.executeCommand('workspace.renameCurrentFile');
            await helper_1.default.waitFor('mode', [], 'c');
            await nvim.input('<backspace>b<cr>');
            await p;
            let name = await nvim.eval('bufname("%")');
            expect(name.endsWith('b')).toBe(true);
            expect(fs_1.default.existsSync(newPath)).toBe(true);
            let content = fs_1.default.readFileSync(newPath, 'utf8');
            expect(content).toMatch(/foo/);
        });
        it('should not throw when workspace folder does not exist', async () => {
            helper_1.default.updateConfiguration('workspace.rootPatterns', []);
            helper_1.default.updateConfiguration('workspace.ignoredFiletypes', ['vim']);
            await nvim.command('enew');
            await window_1.default.openLocalConfig();
            await nvim.command(`e ${path_1.default.join(os_1.default.tmpdir(), 'a')}`);
            await helper_1.default.doAction('openLocalConfig');
            await nvim.command(`e t.md`);
            await nvim.command('setf markdown');
            await handler.openLocalConfig();
            await nvim.command(`e ${path_1.default.join(os_1.default.tmpdir(), 't.vim')}`);
            await nvim.command('setf vim');
            await handler.openLocalConfig();
        });
        it('should open local config', async () => {
            let dir = path_1.default.join(os_1.default.tmpdir(), '.vim');
            fs_1.default.rmSync(dir, { recursive: true, force: true });
            fs_1.default.mkdirSync(path_1.default.join(os_1.default.tmpdir(), '.git'), { recursive: true });
            await helper_1.default.edit(path_1.default.join(os_1.default.tmpdir(), 't'));
            let root = workspace_1.default.root;
            expect(root).toBe(os_1.default.tmpdir());
            let p = handler.openLocalConfig();
            await helper_1.default.waitPromptWin();
            await nvim.input('n');
            await p;
            p = handler.openLocalConfig();
            await helper_1.default.waitPromptWin();
            await nvim.input('y');
            await p;
            let bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toMatch('coc-settings.json');
        });
        it('should add workspace folder', async () => {
            expect(() => {
                handler.addWorkspaceFolder(undefined);
            }).toThrow(TypeError);
            expect(() => {
                handler.addWorkspaceFolder(__filename);
            }).toThrow(Error);
            await helper_1.default.plugin.cocAction('addWorkspaceFolder', __dirname);
            let folders = workspace_1.default.workspaceFolderControl.workspaceFolders;
            let uri = vscode_uri_1.URI.file(__dirname).toString();
            let find = folders.find(o => o.uri === uri);
            expect(find).toBeDefined();
        });
        it('should check env on vim resized', async () => {
            await events_1.default.fire('VimResized', [80, 80]);
            expect(workspace_1.default.env.columns).toBe(80);
            await events_1.default.fire('VimResized', [160, 80]);
            expect(workspace_1.default.env.columns).toBe(160);
        });
        it('should should error message for document not attached', async () => {
            await nvim.command('edit t|let b:coc_enabled = 0');
            await commands_1.default.executeCommand('document.checkBuffer');
            await checkFloat('not attached');
            await nvim.call('coc#float#close_all', []);
            await nvim.command('edit +setl\\ buftype=nofile b');
            await helper_1.default.doAction('bufferCheck');
            await checkFloat('not attached');
            await nvim.call('coc#float#close_all', []);
            helper_1.default.updateConfiguration('coc.preferences.maxFileSize', '1KB');
            await helper_1.default.edit(__filename);
            await handler.bufferCheck();
            await checkFloat('not attached');
            await nvim.call('coc#float#close_all', []);
        });
        it('should check json extension', async () => {
            let spy = jest.spyOn(extension_1.default, 'has').mockImplementation(() => {
                return true;
            });
            await helper_1.default.doAction('checkJsonExtension');
            spy.mockRestore();
            await helper_1.default.doAction('checkJsonExtension');
            let line = await helper_1.default.getCmdline();
            expect(line).toBeDefined();
        });
        it('should get rootPatterns', async () => {
            let bufnr = await nvim.call('bufnr', ['%']);
            let res = await helper_1.default.doAction('rootPatterns', bufnr);
            expect(res).toBeDefined();
        });
        it('should get config by key', async () => {
            let res = await helper_1.default.doAction('getConfig', ['suggest']);
            expect(res.autoTrigger).toBeDefined();
        });
        it('should open log', async () => {
            await helper_1.default.doAction('openLog');
            let bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toMatch('coc-nvim');
        });
        it('should get configuration of current document', async () => {
            let config = await handler.getConfiguration('suggest');
            let wait = config.get('triggerCompletionWait');
            expect(wait).toBe(0);
        });
        it('should get root patterns', async () => {
            let doc = await helper_1.default.createDocument();
            let patterns = handler.getRootPatterns(doc.bufnr);
            expect(patterns).toBeDefined();
            patterns = handler.getRootPatterns(999);
            expect(patterns).toBeNull();
        });
    });
    describe('doKeymap()', () => {
        it('should return default value when key mapping does not exist', async () => {
            let res = await helper_1.default.doAction('doKeymap', ['not_exists', '']);
            expect(res).toBe('');
        });
        it('should support repeat key mapping', async () => {
            let called = false;
            await nvim.command('nmap do <Plug>(coc-test)');
            disposables.push(workspace_1.default.registerKeymap(['n'], 'test', () => {
                called = true;
            }));
            await helper_1.default.waitValue(async () => {
                let res = await nvim.call('maparg', ['<Plug>(coc-test)', 'n']);
                return res.length > 0;
            }, true);
            await nvim.call('feedkeys', ['do', 'i']);
            await helper_1.default.waitValue(() => {
                return called;
            }, true);
        });
    });
    describe('snippetCheck()', () => {
        it('should return false when coc-snippets not found', async () => {
            let fn = async () => {
                expect(await handler.snippetCheck(true, false)).toBe(false);
            };
            await expect(fn()).rejects.toThrow(Error);
            let spy = jest.spyOn(extension_1.default.manager, 'call').mockImplementation(() => {
                return Promise.resolve(true);
            });
            expect(await handler.snippetCheck(true, false)).toBe(true);
            spy.mockRestore();
        });
        it('should check jump', async () => {
            expect(await handler.snippetCheck(false, true)).toBe(false);
        });
    });
});
//# sourceMappingURL=workspace.test.js.map