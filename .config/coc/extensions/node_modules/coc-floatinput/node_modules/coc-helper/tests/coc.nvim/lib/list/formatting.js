'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatPath = exports.formatListItems = exports.formatUri = exports.fixWidth = void 0;
const node_1 = require("../util/node");
const vscode_uri_1 = require("vscode-uri");
const fs_1 = require("../util/fs");
const string_1 = require("../util/string");
function fixWidth(str, width) {
    if (str.length > width) {
        return str.slice(0, width - 1) + '.';
    }
    return str + ' '.repeat(width - str.length);
}
exports.fixWidth = fixWidth;
function formatUri(uri, cwd) {
    if (!uri.startsWith('file:'))
        return uri;
    let filepath = vscode_uri_1.URI.parse(uri).fsPath;
    return (0, fs_1.isParentFolder)(cwd, filepath) ? node_1.path.relative(cwd, filepath) : filepath;
}
exports.formatUri = formatUri;
function formatListItems(align, list) {
    if (list.length === 0) {
        return [];
    }
    let processedList = [];
    if (align) {
        const maxWidths = Array(Math.min(...list.map(item => item.label.length))).fill(0);
        for (let item of list) {
            for (let i = 0; i < maxWidths.length; i++) {
                maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
            }
        }
        processedList = list
            .map(item => (Object.assign(Object.assign({}, item), { label: item.label
                .map((element, idx) => element.padEnd(maxWidths[idx]))
                .join("\t") })));
    }
    else {
        processedList = list.map(item => (Object.assign(Object.assign({}, item), { label: item.label.join("\t") })));
    }
    return processedList;
}
exports.formatListItems = formatListItems;
function formatPath(format, pathToFormat) {
    if (format === "hidden") {
        return "";
    }
    else if (format === "full") {
        return pathToFormat;
    }
    else if (format === "short") {
        const segments = pathToFormat.split(node_1.path.sep);
        if (segments.length < 2) {
            return pathToFormat;
        }
        const shortenedInit = segments
            .slice(0, segments.length - 2)
            .filter(seg => seg.length > 0)
            .map(seg => seg[0]);
        return [...shortenedInit, segments[segments.length - 1]].join(node_1.path.sep);
    }
    else {
        const segments = pathToFormat.split(node_1.path.sep);
        return (0, string_1.toText)(segments[segments.length - 1]);
    }
}
exports.formatPath = formatPath;
//# sourceMappingURL=formatting.js.map