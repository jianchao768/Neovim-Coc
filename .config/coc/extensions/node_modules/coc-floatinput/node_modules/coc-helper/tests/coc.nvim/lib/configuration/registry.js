"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateProperty = exports.configurationDefaultsSchemaId = exports.resourceLanguageSettingsSchemaId = exports.resourceSettings = exports.allSettings = exports.Extensions = void 0;
const array_1 = require("../util/array");
const jsonRegistry_1 = require("../util/jsonRegistry");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const registry_1 = require("../util/registry");
const util_1 = require("./util");
const EXCLUDE_KEYS = ['log-path', 'logPath'];
exports.Extensions = {
    Configuration: 'base.contributions.configuration'
};
exports.allSettings = { properties: {}, patternProperties: {} };
exports.resourceSettings = { properties: {}, patternProperties: {} };
exports.resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';
exports.configurationDefaultsSchemaId = 'vscode://schemas/settings/configurationDefaults';
const contributionRegistry = registry_1.Registry.as(jsonRegistry_1.Extensions.JSONContribution);
class ConfigurationRegistry {
    constructor() {
        this._onDidSchemaChange = new protocol_1.Emitter();
        this.onDidSchemaChange = this._onDidSchemaChange.event;
        this._onDidUpdateConfiguration = new protocol_1.Emitter();
        this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
        this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown coc.nvim configuration property', allowTrailingCommas: true, allowComments: true };
        this.configurationProperties = {};
        this.excludedConfigurationProperties = {};
        contributionRegistry.registerSchema(exports.resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
        this.registerOverridePropertyPatternKey();
    }
    registerConfiguration(configuration, validate = true) {
        this.registerConfigurations([configuration], validate);
    }
    registerConfigurations(configurations, validate = true) {
        const properties = this.doRegisterConfigurations(configurations, validate);
        contributionRegistry.notifySchemaChanged(exports.resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
    }
    deregisterConfigurations(configurations) {
        const properties = this.doDeregisterConfigurations(configurations);
        contributionRegistry.notifySchemaChanged(exports.resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
    }
    updateConfigurations({ add, remove }) {
        const properties = [];
        properties.push(...this.doDeregisterConfigurations(remove));
        properties.push(...this.doRegisterConfigurations(add, false));
        contributionRegistry.notifySchemaChanged(exports.resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties: (0, array_1.distinct)(properties) });
    }
    doRegisterConfigurations(configurations, validate) {
        const properties = [];
        configurations.forEach(configuration => {
            properties.push(...this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo)); // fills in defaults
            this.registerJSONConfiguration(configuration);
        });
        return properties;
    }
    doDeregisterConfigurations(configurations) {
        const properties = [];
        const deregisterConfiguration = (configuration) => {
            for (const key in (0, object_1.toObject)(configuration.properties)) {
                properties.push(key);
                delete this.configurationProperties[key];
                this.removeFromSchema(key, configuration.properties[key]);
            }
        };
        for (const configuration of configurations) {
            deregisterConfiguration(configuration);
        }
        return properties;
    }
    validateAndRegisterProperties(configuration, validate, extensionInfo, scope = 1 /* ConfigurationScope.APPLICATION */) {
        scope = configuration.scope == null ? scope : configuration.scope;
        const propertyKeys = [];
        const properties = configuration.properties;
        for (const key in (0, object_1.toObject)(properties)) {
            const property = properties[key];
            if (validate && validateProperty(key, property)) {
                delete properties[key];
                continue;
            }
            property.source = extensionInfo;
            // update default value
            property.defaultDefaultValue = properties[key].default;
            this.updatePropertyDefaultValue(key, property);
            // update scope
            property.scope = property.scope == null ? scope : property.scope;
            if (extensionInfo)
                property.description = (property.description ? `${property.description}\n` : '') + `From ${extensionInfo.id}`;
            // Add to properties maps
            // Property is included by default if 'included' is unspecified
            if (property.hasOwnProperty('included') && !property.included) {
                this.excludedConfigurationProperties[key] = properties[key];
                delete properties[key];
                continue;
            }
            else {
                this.configurationProperties[key] = properties[key];
            }
            if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
                // If not set, default deprecationMessage to the markdown source
                properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
            }
            propertyKeys.push(key);
        }
        return propertyKeys;
    }
    getConfigurationProperties() {
        return this.configurationProperties;
    }
    getExcludedConfigurationProperties() {
        return this.excludedConfigurationProperties;
    }
    registerJSONConfiguration(configuration) {
        const register = (configuration) => {
            const properties = configuration.properties;
            for (const key in (0, object_1.toObject)(properties)) {
                this.updateSchema(key, properties[key]);
            }
        };
        register(configuration);
    }
    updateSchema(key, property) {
        exports.allSettings.properties[key] = property;
        switch (property.scope) {
            case 2 /* ConfigurationScope.WINDOW */:
            case 3 /* ConfigurationScope.RESOURCE */:
                exports.resourceSettings.properties[key] = property;
                break;
            case 4 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */:
                exports.resourceSettings.properties[key] = property;
                this.resourceLanguageSettingsSchema.properties[key] = property;
                break;
        }
    }
    removeFromSchema(key, property) {
        delete exports.allSettings.properties[key];
        switch (property.scope) {
            case 2 /* ConfigurationScope.WINDOW */:
            case 3 /* ConfigurationScope.RESOURCE */:
            case 4 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */:
                delete exports.resourceSettings.properties[key];
                delete this.resourceLanguageSettingsSchema.properties[key];
                break;
        }
    }
    registerOverridePropertyPatternKey() {
        const resourceLanguagePropertiesSchema = {
            type: 'object',
            description: 'Configure editor settings to be overridden for a language.',
            errorMessage: 'This setting does not support per-language configuration.',
            $ref: exports.resourceLanguageSettingsSchemaId,
        };
        exports.allSettings.patternProperties[util_1.OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        exports.resourceSettings.patternProperties[util_1.OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
    }
    updatePropertyDefaultValue(key, property) {
        let defaultValue = property.defaultDefaultValue;
        if (typeof defaultValue === 'undefined' && !EXCLUDE_KEYS.some(k => key.includes(k))) {
            defaultValue = (0, util_1.getDefaultValue)(property.type);
        }
        property.default = defaultValue;
        property.defaultValueSource = undefined;
    }
}
const configurationRegistry = new ConfigurationRegistry();
registry_1.Registry.add(exports.Extensions.Configuration, configurationRegistry);
function validateProperty(property, _schema = undefined) {
    if (!property.trim()) {
        return 'Cannot register an empty property';
    }
    if (util_1.OVERRIDE_PROPERTY_REGEX.test(property)) {
        return `Cannot register ${property}. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings`;
    }
    if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {
        return `Cannot register '${property}'. This property is already registered.`;
    }
    return null;
}
exports.validateProperty = validateProperty;
//# sourceMappingURL=registry.js.map