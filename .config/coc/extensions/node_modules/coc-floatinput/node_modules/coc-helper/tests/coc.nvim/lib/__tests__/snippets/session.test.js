"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const session_1 = require("../../snippets/session");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    let pyfile = path_1.default.join(__dirname, '../ultisnips.py');
    await nvim.command(`execute 'pyxfile '.fnameescape('${pyfile}')`);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
});
async function createSession(enableHighlight = false, preferComplete = false, nextOnDelete = false) {
    let doc = await workspace_1.default.document;
    let config = { highlight: enableHighlight, preferComplete, nextOnDelete };
    return new session_1.SnippetSession(nvim, doc, config);
}
describe('SnippetSession', () => {
    const defaultRange = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0);
    const defaultContext = {
        line: '',
        range: defaultRange
    };
    async function start(inserted, range = defaultRange, select = true, context) {
        await nvim.input('i');
        let doc = await workspace_1.default.document;
        let session = new session_1.SnippetSession(nvim, doc, { highlight: false, nextOnDelete: false, preferComplete: false });
        return await session.start(inserted, range, select, context);
    }
    async function getCursorRange() {
        let pos = await window_1.default.getCursorPosition();
        return vscode_languageserver_protocol_1.Range.create(pos, pos);
    }
    describe('start()', () => {
        it('should insert escaped text', async () => {
            let res = await start('\\`a\\` \\$ \\{\\}', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), false, defaultContext);
            expect(res).toBe(true);
            let line = await nvim.line;
            expect(line).toBe('`a` $ {}');
        });
        it('should not start with plain snippet when jump to final placeholder', async () => {
            let res = await start('bar$0', defaultRange);
            expect(res).toBe(false);
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 3 });
        });
        it('should start with range replaced', async () => {
            await nvim.setLine('foo');
            let res = await start('bar$0', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), true);
            expect(res).toBe(false);
            let line = await nvim.line;
            expect(line).toBe('bar');
        });
        it('should fix indent of next line when necessary', async () => {
            let buf = await nvim.buffer;
            await nvim.setLine('  ab');
            await nvim.input('i');
            let session = await createSession();
            await session.selectCurrentPlaceholder();
            let res = await session.start('${1:x}\n', vscode_languageserver_protocol_1.Range.create(0, 3, 0, 3));
            expect(res).toBe(true);
            let lines = await buf.lines;
            expect(lines).toEqual(['  ax', '  b']);
        });
        it('should insert indent for snippet endsWith line break', async () => {
            let buf = await nvim.buffer;
            await nvim.setLine('  bar');
            await nvim.command('startinsert');
            await nvim.call('cursor', [1, 3]);
            let session = await createSession();
            let res = await session.start('${1:foo}\n', vscode_languageserver_protocol_1.Range.create(0, 2, 0, 2));
            expect(res).toBe(true);
            let lines = await buf.lines;
            expect(lines).toEqual(['  foo', '  bar']);
        });
        it('should start without select placeholder', async () => {
            let session = await createSession();
            let res = await session.start(' ${1:aa} ', defaultRange, false);
            expect(res).toBe(true);
            let { mode } = await nvim.mode;
            expect(mode).toBe('n');
            await session.selectCurrentPlaceholder();
            await helper_1.default.waitFor('mode', [], 's');
        });
        it('should start with variable selected', async () => {
            let session = await createSession();
            let res = await session.start('${foo:bar}', defaultRange, false);
            expect(res).toBe(true);
            let line = await nvim.getLine();
            expect(line).toBe('bar');
            await session.selectCurrentPlaceholder();
            await helper_1.default.waitFor('mode', [], 's');
        });
        it('should select none transform placeholder', async () => {
            await start('${1/..*/ -> /}xy$1', defaultRange);
            let col = await nvim.call('col', '.');
            expect(col).toBe(3);
        });
        it('should indent multiple lines variable text', async () => {
            let buf = await nvim.buffer;
            let text = 'abc\n  def';
            await nvim.setVar('coc_selected_text', text);
            await start('fun\n  ${0:${TM_SELECTED_TEXT:return}}\nend');
            let lines = await buf.lines;
            expect(lines.length).toBe(4);
            expect(lines).toEqual([
                'fun', '  abc', '    def', 'end'
            ]);
        });
        it('should resolve VISUAL', async () => {
            let text = 'abc';
            await nvim.setVar('coc_selected_text', text);
            await start('$VISUAL');
            let line = await nvim.line;
            expect(line).toBe('abc');
        });
        it('should resolve default value of VISUAL', async () => {
            await nvim.setVar('coc_selected_text', '');
            await start('${VISUAL:foo}');
            let line = await nvim.line;
            expect(line).toBe('foo');
        });
    });
    describe('nested snippet', () => {
        it('should start with nest snippet', async () => {
            let session = await createSession();
            let res = await session.start('${1:a} ${2:b}', defaultRange, false);
            let line = await nvim.getLine();
            expect(line).toBe('a b');
            expect(res).toBe(true);
            let { placeholder } = session;
            expect(placeholder.index).toBe(1);
            let r = await getCursorRange();
            res = await session.start('${1:foo} ${2:bar}', r);
            expect(res).toBe(true);
            placeholder = session.placeholder;
            expect(placeholder.index).toBe(2);
            line = await nvim.getLine();
            expect(line).toBe('foo bara b');
            expect(session.snippet.text).toBe('foo bara b');
            await session.nextPlaceholder();
            placeholder = session.placeholder;
            expect(placeholder.index).toBe(3);
            expect(session.placeholder.value).toBe('bar');
            let col = await nvim.call('col', ['.']);
            expect(col).toBe(7);
            await session.nextPlaceholder();
            await session.nextPlaceholder();
            expect(session.placeholder.index).toBe(5);
            expect(session.placeholder.value).toBe('b');
        });
        it('should start nest snippet without select', async () => {
            await nvim.command('startinsert');
            let session = await createSession();
            let res = await session.start('${1:a} ${2:b}', defaultRange);
            let line = await nvim.call('getline', ['.']);
            let r = await getCursorRange();
            res = await session.start('${1:foo} ${2:bar}', r, false);
            expect(res).toBe(true);
            line = await nvim.line;
            expect(line).toBe('afoo bar b');
        });
        it('should not nested when range not contains', async () => {
            await nvim.command('startinsert');
            let session = await createSession();
            let res = await session.start('${1:a} ${2:b}', defaultRange);
            res = await session.start('${1:foo} ${2:bar}', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), false);
            expect(res).toBe(true);
            let line = await nvim.line;
            expect(line).toBe('foo bar');
        });
    });
    describe('getRanges()', () => {
        it('should getRanges of placeholder', async () => {
            async function checkRanges(snippet, results) {
                let session = await createSession();
                await session.start(snippet, defaultRange);
                let curr = session.placeholder;
                let res = session.snippet.getRanges(curr);
                expect(res).toEqual(results);
                session.deactivate();
                await nvim.setLine('');
            }
            await checkRanges('$1 $1', []);
            await checkRanges('${foo}', [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3)]);
            await checkRanges('${2:${1:foo}}', [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3)]);
            await checkRanges('${2:${1:foo}} ${2/^_(.*)/$1/}', [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), vscode_languageserver_protocol_1.Range.create(0, 4, 0, 7)]);
        });
    });
    describe('synchronize()', () => {
        it('should synchronize content change', async () => {
            let session = await createSession(true);
            await session.checkPosition();
            expect(session.version).toBe(-1);
            await session.start('${1:foo}${2:`!p snip.rv = ""`} `!p snip.rv = t[1] + t[2]`', defaultRange, true, {
                line: '',
                range: defaultRange
            });
            await nvim.input('bar');
            await session.forceSynchronize();
            await helper_1.default.waitFor('getline', ['.'], 'bar bar');
            expect(session.snippet.getTextBefore(undefined, 'before')).toBe('before');
        });
        it('should cancel with unexpected change', async () => {
            let session = await createSession(true);
            await nvim.setLine('c');
            await nvim.input('A');
            await session.start('${1:foo}', vscode_languageserver_protocol_1.Range.create(0, 1, 0, 1));
            await nvim.setLine('bxoo');
            await session.forceSynchronize();
            expect(session.isActive).toBe(false);
        });
        it('should cancel when document have changed', async () => {
            let session = await createSession();
            let doc = await workspace_1.default.document;
            await nvim.input('i');
            await session.start('${2:foo} ${1}', defaultRange);
            await nvim.setLine('bfoo ');
            await doc.patchChange(true);
            await nvim.setLine('xfoo ');
            await nvim.call('cursor', [1, 1]);
            await session.forceSynchronize();
            expect(session.snippet.text).toBe('xfoo ');
            expect(session.isActive).toBe(true);
        });
        it('should reset snippet when cancelled', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('${1} `!p snip.rv = t[1]`', defaultRange, false, defaultContext);
            await nvim.setLine('b ');
            let cancelled = false;
            let spy = jest.spyOn(session.snippet.tmSnippet, 'updatePythonCodes').mockImplementation(() => {
                return new Promise(resolve => {
                    session.cancel();
                    spy.mockRestore();
                    setImmediate(() => {
                        resolve();
                        cancelled = true;
                    });
                });
            });
            await helper_1.default.waitValue(() => cancelled, true);
            expect(session.snippet.text).toBe(' ');
        });
        it('should cancel when change after snippet', async () => {
            let session = await createSession();
            await nvim.setLine(' x');
            await nvim.input('i');
            await session.start('${1:foo }bar', defaultRange);
            await nvim.setLine('foo bar y');
            await session.forceSynchronize();
            expect(session.isActive).toBe(false);
        });
        it('should cancel when change before and in snippet', async () => {
            let session = await createSession();
            await nvim.setLine(' x');
            await nvim.input('i');
            await session.start('${1:foo }bar', defaultRange);
            await nvim.setLine('afoobar');
            await session.forceSynchronize();
            expect(session.isActive).toBe(false);
        });
        it('should reset position when change before snippet', async () => {
            let session = await createSession();
            await nvim.setLine('x');
            await nvim.input('a');
            let r = await getCursorRange();
            await session.start('${1:foo} bar', r);
            await nvim.setLine('yfoo bar');
            await session.forceSynchronize();
            expect(session.isActive).toBe(true);
            let start = session.snippet.start;
            expect(start).toEqual(vscode_languageserver_protocol_1.Position.create(0, 1));
        });
        it('should cancel when before and body changed', async () => {
            let session = await createSession();
            await nvim.setLine('x');
            await nvim.input('a');
            await session.start('${1:foo }bar', defaultRange);
            await nvim.setLine('yfoo  bar');
            await session.forceSynchronize();
            expect(session.isActive).toBe(false);
        });
        it('should cancel when unable to find placeholder', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('${1:foo} bar', defaultRange);
            await nvim.setLine('foodbar');
            await session.forceSynchronize();
            expect(session.isActive).toBe(false);
        });
        it('should cancel when unable to find removed Text', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('${1:foo} bar', defaultRange);
            await nvim.setLine('fobar');
            await session.forceSynchronize();
            expect(session.isActive).toBe(false);
        });
        it('should adjust with removed text', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('${1:foo} bar$0', defaultRange);
            await nvim.input('<esc>');
            await nvim.call('cursor', [1, 5]);
            await nvim.input('i');
            await nvim.input('<backspace>');
            await helper_1.default.wait(1);
            await session.forceSynchronize();
            expect(session.isActive).toBe(true);
            await session.nextPlaceholder();
            let col = await nvim.call('col', ['.']);
            expect(col).toBe(7);
        });
        it('should automatically select next placeholder', async () => {
            let session = await createSession(false, false, true);
            await nvim.input('i');
            await session.start('${1:foo} bar$0', defaultRange);
            await nvim.input('<backspace>');
            await session.forceSynchronize();
            let col = await nvim.call('col', ['.']);
            expect(col).toBe(5);
        });
        it('should prefer range contains current cursor', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('$1 $2', defaultRange);
            await nvim.input('<esc>A');
            await nvim.input(' ');
            await session.forceSynchronize();
            expect(session.isActive).toBe(true);
            let p = session.placeholder;
            expect(p.index).toBe(2);
        });
        it('should update cursor column after synchronize', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('${1} ${1:foo}', defaultRange);
            await nvim.input('b');
            await session.forceSynchronize();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual(vscode_languageserver_protocol_1.Position.create(0, 3));
            await nvim.input('a');
            await session.forceSynchronize();
            pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual(vscode_languageserver_protocol_1.Position.create(0, 5));
            await nvim.input('<backspace>');
            await session.forceSynchronize();
            pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual(vscode_languageserver_protocol_1.Position.create(0, 3));
        });
        it('should update cursor line after synchronize', async () => {
            let buf = await nvim.buffer;
            let session = await createSession();
            await nvim.input('i');
            await session.start('${1} ${1:foo}', defaultRange);
            await nvim.input('b');
            await session.forceSynchronize();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual(vscode_languageserver_protocol_1.Position.create(0, 3));
            await nvim.input('<cr>');
            await session.forceSynchronize();
            expect(session.isActive).toBe(true);
            pos = await window_1.default.getCursorPosition();
            let lines = await buf.lines;
            expect(lines).toEqual(['b', ' b', '']);
            expect(pos).toEqual(vscode_languageserver_protocol_1.Position.create(2, 0));
        });
        it('should synchronize changes at the same time', async () => {
            await nvim.input('i');
            let doc = await workspace_1.default.document;
            let session = await createSession();
            let res = await session.start('|$1 $1|', defaultRange);
            expect(res).toBe(true);
            let line = await nvim.line;
            expect(line).toBe('| |');
            let p = new Promise(resolve => {
                doc.onDocumentChange(e => {
                    resolve(undefined);
                });
            });
            await nvim.input('xy');
            await p;
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 1, 0, 3), '')]);
            await session.forceSynchronize();
            line = await nvim.line;
            expect(line).toBe('| |');
        });
    });
    describe('deactivate()', () => {
        it('should deactivate on cursor outside', async () => {
            let buf = await nvim.buffer;
            let session = await createSession();
            let res = await session.start('a${1:a}b', defaultRange);
            expect(res).toBe(true);
            await buf.append(['foo', 'bar']);
            await nvim.call('cursor', [2, 1]);
            await session.checkPosition();
            expect(session.isActive).toBe(false);
        });
        it('should not throw when jump on deactivate session', async () => {
            let session = await createSession();
            session.deactivate();
            await session.start('${1:foo} $0', defaultRange);
            await session.selectPlaceholder(undefined, true);
            await session.forceSynchronize();
            await session.previousPlaceholder();
            await session.nextPlaceholder();
        });
        it('should cancel keymap on jump final placeholder', async () => {
            let session = await createSession();
            await nvim.input('i');
            await session.start('$0x${1:a}b$0', defaultRange);
            let line = await nvim.line;
            expect(line).toBe('xab');
            let map = await nvim.call('maparg', ['<C-j>', 'i']);
            expect(map).toMatch('coc#snippet#jump');
            await session.nextPlaceholder();
            map = await nvim.call('maparg', ['<C-j>', 'i']);
            expect(map).toBe('');
        });
    });
    describe('nextPlaceholder()', () => {
        it('should not throw when session not activated', async () => {
            let session = await createSession();
            await session.start('${foo} ${bar}', defaultRange, false);
            session.deactivate();
            await session.nextPlaceholder();
            await session.previousPlaceholder();
        });
        it('should jump to variable placeholder', async () => {
            let session = await createSession();
            await session.start('${foo} ${bar}', defaultRange, false);
            await session.selectCurrentPlaceholder();
            await session.nextPlaceholder();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 6 });
        });
        it('should jump to variable placeholder after number placeholder', async () => {
            let session = await createSession();
            await session.start('${foo} ${1:bar}', defaultRange, false);
            await session.selectCurrentPlaceholder();
            await session.nextPlaceholder();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 2 });
        });
        it('should jump to first placeholder', async () => {
            let session = await createSession();
            await session.start('${foo} ${foo} ${2:bar}', defaultRange, false);
            await session.selectCurrentPlaceholder();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 10 });
            await session.nextPlaceholder();
            pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 2 });
            await session.nextPlaceholder();
            pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 11 });
        });
        it('should goto next placeholder', async () => {
            let session = await createSession();
            let res = await session.start('${1:a} ${2:b} c', defaultRange);
            expect(res).toBe(true);
            await session.nextPlaceholder();
            let { placeholder } = session;
            expect(placeholder.index).toBe(2);
        });
        it('should jump to none transform placeholder', async () => {
            let session = await createSession();
            let res = await session.start('${1} ${2/^_(.*)/$2/}bar$2', defaultRange);
            expect(res).toBe(true);
            let line = await nvim.line;
            expect(line).toBe(' bar');
            await session.nextPlaceholder();
            let col = await nvim.call('col', '.');
            expect(col).toBe(5);
        });
    });
    describe('previousPlaceholder()', () => {
        it('should goto previous placeholder', async () => {
            let session = await createSession();
            let res = await session.start('${1:foo} ${2:bar}', defaultRange);
            expect(res).toBe(true);
            await session.nextPlaceholder();
            expect(session.placeholder.index).toBe(2);
            await session.previousPlaceholder();
            expect(session.placeholder.index).toBe(1);
        });
    });
    describe('highlights()', () => {
        it('should add highlights', async () => {
            let ns = await nvim.call('coc#highlight#create_namespace', ['snippets']);
            let session = await createSession(true);
            await session.start('${2:bar ${1:foo}} $2', defaultRange);
            let buf = nvim.createBuffer(workspace_1.default.bufnr);
            let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(2);
            expect(markers[0][3].hl_group).toBe('CocSnippetVisual');
            expect(markers[1][3].hl_group).toBe('CocSnippetVisual');
            session.deactivate();
        });
    });
    describe('checkPosition()', () => {
        it('should cancel snippet if position out of range', async () => {
            let session = await createSession();
            await nvim.setLine('bar');
            await session.start('${1:foo}', defaultRange);
            await nvim.call('cursor', [1, 5]);
            await session.checkPosition();
            expect(session.isActive).toBe(false);
        });
        it('should not cancel snippet if position in range', async () => {
            let session = await createSession();
            await session.start('${1:foo}', defaultRange);
            await nvim.call('cursor', [1, 3]);
            await session.checkPosition();
            expect(session.isActive).toBe(true);
        });
    });
    describe('findPlaceholder()', () => {
        it('should find current placeholder if possible', async () => {
            let session = await createSession();
            await session.start('${1:abc}${2:def}', defaultRange);
            let placeholder = session.findPlaceholder(vscode_languageserver_protocol_1.Range.create(0, 3, 0, 3));
            expect(placeholder.index).toBe(1);
        });
        it('should return null if placeholder not found', async () => {
            let session = await createSession();
            await session.start('${1:abc}xyz${2:def}', defaultRange);
            let placeholder = session.findPlaceholder(vscode_languageserver_protocol_1.Range.create(0, 4, 0, 4));
            expect(placeholder).toBeNull();
        });
    });
    describe('resolveSnippet()', () => {
        it('should resolveSnippet', async () => {
            let res = await session_1.SnippetSession.resolveSnippet(nvim, '${1:`!p snip.rv = "foo"`}', { line: 'foo', range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3) });
            expect(res).toBe('foo');
        });
    });
    describe('selectPlaceholder()', () => {
        it('should select range placeholder', async () => {
            let session = await createSession();
            await session.start('${1:abc}', defaultRange);
            let mode = await nvim.mode;
            expect(mode.mode).toBe('s');
            await nvim.input('<backspace>');
            let line = await nvim.line;
            expect(line).toBe('');
        });
        it('should select empty placeholder', async () => {
            let session = await createSession();
            await session.start('a ${1} ${2}', defaultRange);
            let mode = await nvim.mode;
            expect(mode.mode).toBe('i');
            let col = await nvim.call('col', '.');
            expect(col).toBe(3);
        });
        it('should select choice placeholder', async () => {
            await nvim.input('i');
            let session = await createSession();
            await session.start('${1|one,two,three|}', defaultRange);
            let line = await nvim.line;
            expect(line).toBe('one');
            await helper_1.default.waitPopup();
            let items = await helper_1.default.items();
            expect(items.length).toBe(3);
        }, 10000);
    });
});
//# sourceMappingURL=session.test.js.map