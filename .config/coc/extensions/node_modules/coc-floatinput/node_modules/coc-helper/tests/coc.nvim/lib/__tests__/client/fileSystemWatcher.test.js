"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const index_1 = require("../../language-client/index");
const helper_1 = tslib_1.__importDefault(require("../helper"));
function createClient(fileEvents, middleware = {}) {
    const serverModule = path_1.default.join(__dirname, './server/fileWatchServer.js');
    const serverOptions = {
        run: { module: serverModule, transport: index_1.TransportKind.ipc },
        debug: { module: serverModule, transport: index_1.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }
    };
    const documentSelector = [{ scheme: 'file' }];
    const clientOptions = {
        documentSelector,
        synchronize: { fileEvents },
        initializationOptions: {},
        middleware
    };
    clientOptions.$testMode = true;
    const result = new index_1.LanguageClient('test', 'Test Language Server', serverOptions, clientOptions);
    return result;
}
class CustomWatcher {
    constructor() {
        this.ignoreCreateEvents = false;
        this.ignoreChangeEvents = false;
        this.ignoreDeleteEvents = false;
        this._onDidCreate = new vscode_languageserver_protocol_1.Emitter();
        this.onDidCreate = this._onDidCreate.event;
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onDidDelete = new vscode_languageserver_protocol_1.Emitter();
        this.onDidDelete = this._onDidDelete.event;
    }
    fireCreate(uri) {
        this._onDidCreate.fire(uri);
    }
    fireChange(uri) {
        this._onDidChange.fire(uri);
    }
    fireDelete(uri) {
        this._onDidDelete.fire(uri);
    }
    dispose() {
    }
}
beforeAll(async () => {
    await helper_1.default.setup();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('FileSystemWatcherFeature', () => {
    it('should hook file events from client configuration', async () => {
        let client;
        let watcher = new CustomWatcher();
        let called = false;
        let changes = [];
        client = createClient([watcher], {
            workspace: {
                didChangeWatchedFile: async (event, next) => {
                    called = true;
                    changes.push(event.type);
                    return next(event);
                }
            }
        });
        let received;
        client.onNotification('filesChange', params => {
            received = params.changes;
        });
        await client.start();
        expect(called).toBe(false);
        let uri = vscode_uri_1.URI.file(__filename);
        watcher.fireCreate(uri);
        expect(called).toBe(true);
        watcher.fireChange(uri);
        watcher.fireDelete(uri);
        expect(changes).toEqual([1, 2, 3]);
        await helper_1.default.waitValue(() => {
            return received === null || received === void 0 ? void 0 : received.length;
        }, 1);
        await client.stop();
        expect(received[0]).toEqual({
            uri: uri.toString(),
            type: 3
        });
    });
    it('should work with single watcher', async () => {
        let client;
        let watcher = new CustomWatcher();
        client = createClient(watcher, {});
        let received;
        client.onNotification('filesChange', params => {
            received = params.changes;
        });
        await client.start();
        let uri = vscode_uri_1.URI.file(__filename);
        watcher.fireCreate(uri);
        await helper_1.default.waitValue(() => {
            return received === null || received === void 0 ? void 0 : received.length;
        }, 1);
        await client.stop();
    });
    it('should support dynamic registration', async () => {
        let client;
        client = createClient(undefined);
        await client.start();
        await helper_1.default.waitValue(async () => {
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.method);
            if (feature)
                await feature._notifyFileEvent();
            return feature != undefined;
        }, true);
        await helper_1.default.waitValue(async () => {
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.method);
            let state = feature.getState();
            return state.registrations;
        }, true);
        await client.sendNotification('unwatch');
        await helper_1.default.waitValue(() => {
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.method);
            let state = feature.getState();
            return state === null || state === void 0 ? void 0 : state.registrations;
        }, false);
        await client.stop();
    });
});
//# sourceMappingURL=fileSystemWatcher.test.js.map