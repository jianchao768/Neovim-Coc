'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const lodash_1 = require("../util/lodash");
const manager_1 = tslib_1.__importDefault(require("./manager"));
const excludeKeys = ['source'];
class TypeHierarchyManager extends manager_1.default {
    register(selector, provider) {
        return this.addProvider({
            id: (0, uuid_1.v4)(),
            selector,
            provider
        });
    }
    /**
     * Multiple providers can be registered for a language. In that case providers are asked in
     * parallel and the results are merged. A failing provider (rejected promise or exception) will
     * not cause a failure of the whole operation.
     */
    async prepareTypeHierarchy(document, position, token) {
        const items = this.getProviders(document);
        let hierarchyItems = [];
        let results = await Promise.allSettled(items.map(item => {
            let { provider, id } = item;
            return (async () => {
                let arr = await Promise.resolve(provider.prepareTypeHierarchy(document, position, token));
                if (Array.isArray(arr)) {
                    let noCheck = hierarchyItems.length === 0;
                    arr.forEach(item => {
                        if (noCheck || hierarchyItems.every(o => o.name !== item.name)) {
                            hierarchyItems.push(Object.assign({ source: id }, item));
                        }
                    });
                }
            })();
        }));
        this.handleResults(results, 'prepareTypeHierarchy');
        return hierarchyItems;
    }
    async provideTypeHierarchySupertypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider)
            return [];
        return await Promise.resolve(provider.provideTypeHierarchySupertypes((0, lodash_1.omit)(item, excludeKeys), token)).then(arr => {
            if (Array.isArray(arr)) {
                return arr.map(item => {
                    return Object.assign({ source }, item);
                });
            }
            return [];
        });
    }
    async provideTypeHierarchySubtypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider)
            return [];
        return await Promise.resolve(provider.provideTypeHierarchySubtypes((0, lodash_1.omit)(item, excludeKeys), token)).then(arr => {
            if (Array.isArray(arr)) {
                return arr.map(item => {
                    return Object.assign({ source }, item);
                });
            }
            return [];
        });
    }
}
exports.default = TypeHierarchyManager;
//# sourceMappingURL=typeHierarchyManager.js.map