'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const filter_1 = require("../util/filter");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const fuzzyMatch_1 = require("./fuzzyMatch");
const input_1 = tslib_1.__importDefault(require("./input"));
const popup_1 = tslib_1.__importDefault(require("./popup"));
const strwidth_1 = require("./strwidth");
const logger = (0, logger_1.createLogger)('quickpick');
/**
 * Pick single/multiple items from prompt list.
 */
class QuickPick {
    constructor(nvim, preferences = {}) {
        this.nvim = nvim;
        this.preferences = preferences;
        this.canSelectMany = false;
        this.matchOnDescription = false;
        this.maxHeight = 10;
        this.filteredItems = [];
        this.disposables = [];
        this._changed = false;
        // emitted with selected items or undefined when cancelled.
        this._onDidFinish = new protocol_1.Emitter();
        this._onDidChangeSelection = new protocol_1.Emitter();
        this._onDidChangeValue = new protocol_1.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeValue = this._onDidChangeValue.event;
        let items = [];
        let input = this.input = new input_1.default(this.nvim, '');
        if (preferences.maxHeight)
            this.maxHeight = preferences.maxHeight;
        Object.defineProperty(this, 'items', {
            set: (list) => {
                items = (0, array_1.toArray)(list);
                this.selectedItems = items.filter(o => o.picked);
                this.filterItems('');
            },
            get: () => items
        });
        Object.defineProperty(this, 'activeItems', {
            set: (list) => {
                items = (0, array_1.toArray)(list);
                this.filteredItems = items;
                this.showFilteredItems();
            },
            get: () => this.filteredItems
        });
        Object.defineProperty(this, 'value', {
            set: (value) => {
                this.input.value = value;
            },
            get: () => this.input.value
        });
        Object.defineProperty(this, 'title', {
            set: (newTitle) => {
                input.title = (0, string_1.toText)(newTitle);
            },
            get: () => { var _a; return (_a = input.title) !== null && _a !== void 0 ? _a : ''; }
        });
        Object.defineProperty(this, 'loading', {
            set: (loading) => {
                input.loading = loading;
            },
            get: () => input.loading
        });
        input.onDidChange(value => {
            this._changed = false;
            this._onDidChangeValue.fire(value);
            // List already update by change items or activeItems
            if (this._changed) {
                this._changed = false;
                return;
            }
            this.filterItems(value);
        }, this);
        input.onDidFinish(this.onFinish, this);
    }
    get maxWidth() {
        var _a;
        return (_a = this.preferences.maxWidth) !== null && _a !== void 0 ? _a : 80;
    }
    get currIndex() {
        return this.win ? this.win.currIndex : 0;
    }
    get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : undefined;
    }
    get winid() {
        var _a;
        return (_a = this.win) === null || _a === void 0 ? void 0 : _a.winid;
    }
    setCursor(index) {
        var _a;
        (_a = this.win) === null || _a === void 0 ? void 0 : _a.setCursor(index, true);
    }
    attachEvents(inputBufnr) {
        events_1.default.on('BufWinLeave', bufnr => {
            if (bufnr == this.bufnr) {
                this.bufnr = undefined;
                this.win = undefined;
            }
        }, null, this.disposables);
        events_1.default.on('PromptKeyPress', async (bufnr, key) => {
            if (bufnr == inputBufnr) {
                if (key == '<C-f>') {
                    await this.win.scrollForward();
                }
                else if (key == '<C-b>') {
                    await this.win.scrollBackward();
                }
                else if (['<C-j>', '<C-n>', '<down>'].includes(key)) {
                    this.setCursor(this.currIndex + 1);
                }
                else if (['<C-k>', '<C-p>', '<up>'].includes(key)) {
                    this.setCursor(this.currIndex - 1);
                }
                else if (this.canSelectMany && key == '<C-@>') {
                    this.toggePicked(this.currIndex);
                }
            }
        }, null, this.disposables);
    }
    async show() {
        let { nvim, items, input, width, preferences, maxHeight } = this;
        let { lines, highlights } = this.buildList(items, input.value);
        let minWidth;
        if (typeof width === 'number') {
            minWidth = Math.min(width, this.maxWidth);
        }
        else {
            let sw = await strwidth_1.StrWidth.create();
            minWidth = Math.max(40, Math.min(80, lines.reduce((p, c) => Math.max(p, sw.getWidth(c)), 0)));
        }
        let rounded = !!preferences.rounded;
        await input.show(this.title, {
            position: 'center',
            placeHolder: this.placeHolder,
            marginTop: 10,
            border: [1, 1, 0, 1],
            list: true,
            rounded,
            minWidth,
            maxWidth: this.maxWidth,
            highlight: preferences.floatHighlight,
            borderhighlight: preferences.floatBorderHighlight
        });
        let opts = { lines, rounded, maxHeight, highlights };
        if (preferences.floatHighlight)
            opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
            opts.borderhighlight = preferences.floatBorderHighlight;
        let res = await nvim.call('coc#dialog#create_list', [input.winid, input.dimension, opts]);
        if (!res)
            throw new Error('Unable to open list window.');
        // let height
        this.win = new popup_1.default(nvim, res[0], res[1], lines.length);
        this.win.refreshScrollbar();
        this.bufnr = res[1];
        this.setCursor(0);
        this.attachEvents(input.bufnr);
    }
    buildList(items, input, loose = false) {
        let { selectedItems, canSelectMany } = this;
        let filteredItems = [];
        let filtered = [];
        let emptyInput = input.length === 0;
        let lowInput = input.toLowerCase();
        const scoreFn = loose ? filter_1.anyScore : filter_1.fuzzyScoreGracefulAggressive;
        const wordPos = canSelectMany ? 4 : 0;
        for (let index = 0; index < items.length; index++) {
            const item = items[index];
            let filterText = this.toFilterText(item);
            let spans = [];
            let score = 0;
            let descriptionSpan;
            if (!emptyInput) {
                let res = scoreFn(input, lowInput, 0, filterText, filterText.toLowerCase(), wordPos, { boostFullMatch: false, firstMatchCanBeWeak: true });
                if (!res)
                    continue;
                // keep the order for loose match
                score = loose ? 0 : res[0];
                spans = (0, fuzzyMatch_1.toSpans)(filterText, res);
            }
            let picked = selectedItems.includes(item);
            let line = canSelectMany ? `[${picked ? 'x' : ' '}] ${item.label}` : item.label;
            if (item.description) {
                let start = (0, string_1.byteLength)(line);
                line = line + ` ${item.description}`;
                descriptionSpan = [start, start + 1 + (0, string_1.byteLength)(item.description)];
            }
            let lineItem = { line, descriptionSpan, index, score, spans };
            filtered.push(lineItem);
        }
        let lines = [];
        let highlights = [];
        filtered.sort((a, b) => {
            if (a.score != b.score)
                return b.score - a.score;
            return a.index - b.index;
        });
        const toHighlight = (lnum, span, hlGroup, pre) => {
            return { lnum, colStart: span[0] + pre, colEnd: span[1] + pre, hlGroup };
        };
        filtered.forEach((item, index) => {
            lines.push(item.line);
            item.spans.forEach(span => {
                highlights.push(toHighlight(index, span, 'CocSearch', wordPos));
            });
            if (item.descriptionSpan) {
                highlights.push(toHighlight(index, item.descriptionSpan, 'Comment', 0));
            }
            filteredItems.push(items[item.index]);
        });
        this.filteredItems = filteredItems;
        return { lines, highlights };
    }
    /**
     * Filter items, does highlight only when loose is true
     */
    _filter(items, input, loose = false) {
        if (!this.win)
            return;
        this._changed = true;
        let { lines, highlights } = this.buildList(items, input, loose);
        this.nvim.call('coc#dialog#update_list', [this.win.winid, this.win.bufnr, lines, highlights], true);
        this.win.linecount = lines.length;
        this.setCursor(0);
    }
    /**
     * Filter items with input
     */
    filterItems(input) {
        this._filter(this.items, input);
    }
    showFilteredItems() {
        let { input, filteredItems } = this;
        this._filter(filteredItems, input.value, true);
    }
    onFinish(input) {
        let items = input == null ? null : this.getSelectedItems();
        if (!this.canSelectMany && input !== undefined && !(0, array_1.isFalsyOrEmpty)(items)) {
            this._onDidChangeSelection.fire(items);
        }
        this.nvim.call('coc#float#close', [this.winid], true);
        // needed to make sure window closed
        setTimeout(() => {
            this._onDidFinish.fire(items);
            this.dispose();
        }, 30);
    }
    getSelectedItems() {
        let { canSelectMany } = this;
        if (canSelectMany)
            return this.selectedItems;
        return (0, array_1.toArray)(this.filteredItems[this.currIndex]);
    }
    toggePicked(index) {
        let { nvim, filteredItems, selectedItems } = this;
        let item = filteredItems[index];
        if (!item)
            return;
        let idx = selectedItems.indexOf(item);
        if (idx != -1) {
            selectedItems.splice(idx, 1);
        }
        else {
            selectedItems.push(item);
        }
        let text = idx == -1 ? 'x' : ' ';
        nvim.pauseNotification();
        this.win.execute(`normal! ^1lr${text}`);
        this.win.setCursor(this.win.currIndex + 1);
        nvim.resumeNotification(true, true);
        this._onDidChangeSelection.fire(selectedItems);
    }
    toFilterText(item) {
        let { label, description } = item;
        let { canSelectMany } = this;
        let line = `${canSelectMany ? '    ' : ''}${label.replace(/\r?\n/, '')}`;
        return this.matchOnDescription ? line + ' ' + (description !== null && description !== void 0 ? description : '') : line;
    }
    dispose() {
        var _a;
        this.bufnr = undefined;
        this.input.dispose();
        (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();
        this._onDidFinish.dispose();
        this._onDidChangeSelection.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = QuickPick;
//# sourceMappingURL=quickpick.js.map