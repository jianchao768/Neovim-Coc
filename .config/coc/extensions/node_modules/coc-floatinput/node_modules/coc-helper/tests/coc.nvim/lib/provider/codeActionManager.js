'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAction = void 0;
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const array_1 = require("../util/array");
const Is = tslib_1.__importStar(require("../util/is"));
const lodash_1 = require("../util/lodash");
const manager_1 = tslib_1.__importDefault(require("./manager"));
function codeActionContains(kinds, kind) {
    return kinds.some(k => kind === k || kind.startsWith(k + '.'));
}
function checkAction(only, action) {
    if ((0, array_1.isFalsyOrEmpty)(only))
        return true;
    if (vscode_languageserver_types_1.Command.is(action))
        return false;
    return codeActionContains(only, action.kind);
}
exports.checkAction = checkAction;
class CodeActionManager extends manager_1.default {
    register(selector, provider, clientId, codeActionKinds) {
        return this.addProvider({
            id: (0, uuid_1.v4)(),
            selector,
            provider,
            kinds: codeActionKinds,
            clientId
        });
    }
    async provideCodeActions(document, range, context, token) {
        let providers = this.getProviders(document);
        const only = (0, array_1.isFalsyOrEmpty)(context.only) ? undefined : context.only;
        if (only) {
            providers = providers.filter(p => {
                if (Array.isArray(p.kinds) && !p.kinds.some(kind => codeActionContains(only, kind))) {
                    return false;
                }
                return true;
            });
        }
        let res = [];
        const titles = [];
        let results = await Promise.allSettled(providers.map(item => {
            let { provider, id } = item;
            let fn = async () => {
                let actions = await Promise.resolve(provider.provideCodeActions(document, range, context, token));
                if ((0, array_1.isFalsyOrEmpty)(actions))
                    return;
                for (let action of actions) {
                    if (titles.includes(action.title) || !checkAction(only, action))
                        continue;
                    if (vscode_languageserver_types_1.Command.is(action)) {
                        let codeAction = {
                            title: action.title,
                            command: action,
                            providerId: id
                        };
                        res.push(codeAction);
                    }
                    else {
                        res.push(Object.assign({ providerId: id }, action));
                    }
                    titles.push(action.title);
                }
            };
            return fn();
        }));
        this.handleResults(results, 'provideCodeActions');
        return res;
    }
    async resolveCodeAction(codeAction, token) {
        // no need to resolve
        if (codeAction.edit != null || codeAction.providerId == null)
            return codeAction;
        let provider = this.getProviderById(codeAction.providerId);
        if (!provider || !Is.func(provider.resolveCodeAction))
            return codeAction;
        let resolved = await Promise.resolve(provider.resolveCodeAction((0, lodash_1.omit)(codeAction, ['providerId']), token));
        return resolved !== null && resolved !== void 0 ? resolved : codeAction;
    }
}
exports.default = CodeActionManager;
//# sourceMappingURL=codeActionManager.js.map