'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const index_1 = require("../../util/index");
const object_1 = require("../../util/object");
const position_1 = require("../../util/position");
const protocol_1 = require("../../util/protocol");
const string_1 = require("../../util/string");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const buffer_1 = tslib_1.__importDefault(require("./buffer"));
const outline_1 = tslib_1.__importDefault(require("./outline"));
const util_1 = require("./util");
class Symbols {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.autoUpdateBufnrs = new Set();
        this.buffers = workspace_1.default.registerBufferSync(doc => {
            let { bufnr } = doc;
            let buf = new buffer_1.default(doc, this.autoUpdateBufnrs);
            buf.onDidUpdate(symbols => {
                if (!this.outline)
                    return;
                this.outline.onSymbolsUpdate(bufnr, symbols);
            });
            return buf;
        });
        this.outline = new outline_1.default(nvim, this.buffers, handler);
        events_1.default.on('CursorHold', async (bufnr, cursor) => {
            if (!this.buffers.getItem(bufnr) || !this.autoUpdate(bufnr))
                return;
            let doc = workspace_1.default.getDocument(bufnr);
            let character = (0, string_1.characterIndex)(doc.getline(cursor[0] - 1), cursor[1] - 1);
            let pos = vscode_languageserver_types_1.Position.create(cursor[0] - 1, character);
            let func = await this.getFunctionSymbol(bufnr, pos);
            let buffer = nvim.createBuffer(bufnr);
            buffer.setVar('coc_current_function', func !== null && func !== void 0 ? func : '', true);
            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);
        }, null, this.disposables);
        events_1.default.on('InsertEnter', (bufnr) => {
            let buf = this.buffers.getItem(bufnr);
            if (buf)
                buf.cancel();
        }, null, this.disposables);
    }
    autoUpdate(bufnr) {
        let doc = workspace_1.default.getDocument(bufnr);
        let config = workspace_1.default.getConfiguration('coc.preferences', doc);
        return config.get('currentFunctionSymbolAutoUpdate', false);
    }
    get labels() {
        return workspace_1.default.getConfiguration('suggest').get('completionItemKindLabels', {});
    }
    async getWorkspaceSymbols(input) {
        this.handler.checkProvider(languages_1.ProviderName.WorkspaceSymbols, null);
        let tokenSource = new protocol_1.CancellationTokenSource();
        return await languages_1.default.getWorkspaceSymbols(input, tokenSource.token);
    }
    async resolveWorkspaceSymbol(symbolInfo) {
        var _a;
        if ((_a = symbolInfo.location) === null || _a === void 0 ? void 0 : _a.uri)
            return symbolInfo;
        let tokenSource = new protocol_1.CancellationTokenSource();
        return await languages_1.default.resolveWorkspaceSymbol(symbolInfo, tokenSource.token);
    }
    async getDocumentSymbols(bufnr) {
        if (!bufnr) {
            bufnr = await this.nvim.call('bufnr', ['%']);
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc || !doc.attached)
                return undefined;
        }
        let buf = this.buffers.getItem(bufnr);
        if (!buf)
            return;
        let res = await buf.getSymbols();
        return res ? (0, util_1.convertSymbols)(res) : undefined;
    }
    async getFunctionSymbol(bufnr, position) {
        let symbols = await this.getDocumentSymbols(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        if (!symbols || symbols.length === 0) {
            buffer.setVar('coc_current_function', '', true);
            this.nvim.call('coc#util#do_autocmd', ['CocStatusChange'], true);
            return '';
        }
        symbols = symbols.filter(s => [
            'Class',
            'Method',
            'Function',
            'Struct',
        ].includes(s.kind));
        let functionName = '';
        let labels = this.labels;
        for (let sym of symbols.reverse()) {
            if (sym.range
                && (0, position_1.positionInRange)(position, sym.range) == 0
                && !sym.text.endsWith(') callback')) {
                functionName = sym.text;
                let label = labels[sym.kind.toLowerCase()];
                if (label)
                    functionName = `${label} ${functionName}`;
                break;
            }
        }
        return functionName;
    }
    async getCurrentFunctionSymbol() {
        let bufnr = await this.nvim.call('bufnr', ['%']);
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached || !languages_1.default.hasProvider(languages_1.ProviderName.DocumentSymbol, doc.textDocument))
            return;
        let position = await window_1.default.getCursorPosition();
        return await this.getFunctionSymbol(bufnr, position);
    }
    /*
     * supportedSymbols must be string values of symbolKind
     */
    async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.DocumentSymbol, doc.textDocument);
        let range;
        if (visualmode) {
            range = await window_1.default.getSelectedRange(visualmode);
        }
        else {
            let pos = await window_1.default.getCursorPosition();
            range = vscode_languageserver_types_1.Range.create(pos, pos);
        }
        let symbols = await this.getDocumentSymbols(doc.bufnr);
        if (!symbols || symbols.length === 0) {
            void window_1.default.showWarningMessage('No symbols found');
            return;
        }
        symbols = symbols.filter(s => supportedSymbols.includes(s.kind));
        let selectRange;
        for (let sym of symbols.reverse()) {
            if (sym.range && !(0, object_1.equals)(sym.range, range) && (0, position_1.rangeInRange)(range, sym.range)) {
                selectRange = sym.range;
                break;
            }
        }
        if (inner && selectRange) {
            let { start, end } = selectRange;
            let line = doc.getline(start.line + 1);
            let endLine = doc.getline(end.line - 1);
            selectRange = vscode_languageserver_types_1.Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
        }
        if (selectRange) {
            await window_1.default.selectRange(selectRange);
        }
        else if (['v', 'V', '\x16'].includes(visualmode)) {
            await this.nvim.command('normal! gv');
        }
    }
    async showOutline(keep) {
        await this.outline.show(keep);
    }
    async hideOutline() {
        await this.outline.hide();
    }
    hasOutline(bufnr) {
        return this.outline.has(bufnr);
    }
    dispose() {
        this.outline.dispose();
        this.buffers.dispose();
        (0, index_1.disposeAll)(this.disposables);
    }
}
exports.default = Symbols;
//# sourceMappingURL=index.js.map