"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../../events"));
const bufferSync_1 = tslib_1.__importDefault(require("../../model/bufferSync"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let documents;
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    documents = workspace_1.default.documentsManager;
});
afterEach(async () => {
    await helper_1.default.reset();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('BufferSync', () => {
    it('should recreate document', async () => {
        let doc = documents.getDocument(documents.bufnr);
        let called = false;
        let sync = new bufferSync_1.default(doc => {
            return {
                bufnr: doc.bufnr,
                dispose: () => {
                    called = true;
                }
            };
        }, documents);
        sync.create(doc);
        expect(called).toBe(true);
    });
});
describe('documents', () => {
    it('should get document', async () => {
        await helper_1.default.createDocument('bar');
        let doc = await helper_1.default.createDocument('foo');
        let res = documents.getDocument(doc.uri);
        expect(res.uri).toBe(doc.uri);
        let uri = 'file:///' + doc.uri.slice(8).toUpperCase();
        res = documents.getDocument(uri);
        expect(res.uri).toBe(doc.uri);
    });
    it('should resolveRoot', async () => {
        let res = documents.resolveRoot(['package.json']);
        expect(res).toBeDefined();
        expect(() => {
            documents.resolveRoot(['unexpected file'], true);
        }).toThrow(Error);
        await helper_1.default.edit(__filename);
        res = documents.resolveRoot(['package.json']);
        expect(res).toBeDefined();
    });
    it('should consider lisp option for iskeyword', async () => {
        await nvim.command(`e +setl\\ lisp t`);
        let doc = await workspace_1.default.document;
        expect(doc.isWord('-')).toBe(true);
    });
    it('should get languageId', async () => {
        await helper_1.default.createDocument('t.vim');
        expect(documents.getLanguageId('/a/b')).toBe('');
        expect(documents.getLanguageId('/a/b.vim')).toBe('vim');
        expect(documents.getLanguageId('/a/b.c')).toBe('');
    });
    it('should get lines', async () => {
        let doc = await helper_1.default.createDocument('tmp');
        await doc.applyEdits([vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo\nbar')]);
        let lines = await documents.getLines(doc.uri);
        expect(lines).toEqual(['foo', 'bar']);
        lines = await documents.getLines('lsptest:///1');
        expect(lines).toEqual([]);
        lines = await documents.getLines('file:///not_exists_file');
        expect(lines).toEqual([]);
        let uri = vscode_uri_1.URI.file(__filename).toString();
        lines = await documents.getLines(uri);
        expect(lines.length).toBeGreaterThan(0);
    });
    it('should read empty string from none file', async () => {
        let res = await documents.readFile('test:///1');
        expect(res).toBe('');
    });
    it('should get empty line from none file', async () => {
        let res = await documents.getLine('test:///1', 1);
        expect(res).toBe('');
        let uri = vscode_uri_1.URI.file(path_1.default.join(__dirname, 'not_exists_file')).toString();
        res = await documents.getLine(uri, 1);
        expect(res).toBe('');
    });
    it('should get QuickfixItem from location link', async () => {
        let doc = await helper_1.default.createDocument('quickfix');
        let loc = vscode_languageserver_types_1.LocationLink.create(doc.uri, vscode_languageserver_types_1.Range.create(0, 0, 3, 0), vscode_languageserver_types_1.Range.create(0, 0, 0, 3));
        let res = await documents.getQuickfixItem(loc, 'text', 'E', 'module');
        expect(res.targetRange).toBeDefined();
        expect(res.type).toBe('E');
        expect(res.module).toBe('module');
        expect(res.bufnr).toBe(doc.bufnr);
    });
    it('should create document', async () => {
        await helper_1.default.createDocument();
        let bufnrs = await nvim.call('coc#ui#open_files', [[__filename]]);
        let bufnr = bufnrs[0];
        let doc = workspace_1.default.getDocument(bufnr);
        expect(doc).toBeUndefined();
        doc = await documents.createDocument(bufnr);
        expect(doc).toBeDefined();
    });
    it('should check buffer rename on save', async () => {
        let doc = await workspace_1.default.document;
        let bufnr = doc.bufnr;
        let name = `${(0, uuid_1.v4)()}.vim`;
        let tmpfile = path_1.default.join(os_1.default.tmpdir(), name);
        await nvim.command(`write ${tmpfile}`);
        doc = workspace_1.default.getDocument(bufnr);
        expect(doc).toBeDefined();
        expect(doc.filetype).toBe('vim');
        expect(doc.bufname).toMatch(name);
        fs_1.default.unlinkSync(tmpfile);
    });
    it('should get current document', async () => {
        let p1 = workspace_1.default.document;
        let p2 = workspace_1.default.document;
        let arr = await Promise.all([p1, p2]);
        expect(arr[0]).toBe(arr[1]);
    });
    it('should get bufnrs', async () => {
        await workspace_1.default.document;
        let bufnrs = Array.from(documents.bufnrs);
        expect(bufnrs.length).toBe(1);
    });
    it('should get uri', async () => {
        let doc = await workspace_1.default.document;
        expect(documents.uri).toBe(doc.uri);
    });
    it('should get current uri', async () => {
        let doc = await workspace_1.default.document;
        documents.detachBuffer(doc.bufnr);
        let uri = await documents.getCurrentUri();
        expect(uri).toBeUndefined();
    });
    it('should attach events on vim', async () => {
        await documents.attach(nvim, workspace_1.default.env);
        let env = Object.assign(workspace_1.default.env, { isVim: true });
        documents.detach();
        await documents.attach(nvim, env);
        documents.detach();
        await events_1.default.fire('CursorMoved', [1, [1, 1]]);
    });
    it('should compute word ranges', async () => {
        expect(await workspace_1.default.computeWordRanges('file:///1', vscode_languageserver_types_1.Range.create(0, 0, 1, 0))).toBeNull();
        let doc = await workspace_1.default.document;
        expect(await workspace_1.default.computeWordRanges(doc.uri, vscode_languageserver_types_1.Range.create(0, 0, 1, 0))).toBeDefined();
    });
});
//# sourceMappingURL=documents.test.js.map