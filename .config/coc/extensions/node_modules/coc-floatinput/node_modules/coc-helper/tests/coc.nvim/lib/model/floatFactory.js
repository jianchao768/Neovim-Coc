'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_1 = require("../util/node");
const events_1 = tslib_1.__importDefault(require("../events"));
const markdown_1 = require("../markdown");
const util_1 = require("../util");
const array_1 = require("../util/array");
const mutex_1 = require("../util/mutex");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const constants_1 = require("../util/constants");
const debounceTime = (0, util_1.getConditionValue)(100, 10);
/**
 * Float window/popup factory for create float/popup around current cursor.
 */
class FloatFactoryImpl {
    constructor(nvim) {
        this.nvim = nvim;
        this.winid = 0;
        this._bufnr = 0;
        this.mutex = new mutex_1.Mutex();
        this.disposables = [];
        this.onCursorMoved = (0, node_1.debounce)(this._onCursorMoved.bind(this), debounceTime);
    }
    bindEvents(autoHide, alignTop) {
        let eventNames = ['InsertLeave', 'InsertEnter', 'BufEnter'];
        for (let ev of eventNames) {
            events_1.default.on(ev, bufnr => {
                if (bufnr == this._bufnr)
                    return;
                this.close();
            }, null, this.disposables);
        }
        events_1.default.on('MenuPopupChanged', () => {
            // avoid intersect with pum
            if (events_1.default.pumAlignTop == alignTop) {
                this.close();
            }
        }, null, this.disposables);
        this.disposables.push(protocol_1.Disposable.create(() => {
            this.onCursorMoved.clear();
        }));
        events_1.default.on('CursorMoved', this.onCursorMoved.bind(this, autoHide), this, this.disposables);
        events_1.default.on('CursorMovedI', this.onCursorMoved.bind(this, autoHide), this, this.disposables);
    }
    unbind() {
        if (this.disposables.length) {
            (0, util_1.disposeAll)(this.disposables);
            this.disposables = [];
        }
    }
    _onCursorMoved(autoHide, bufnr, cursor) {
        if (bufnr == this._bufnr)
            return;
        if (bufnr == this.targetBufnr && (0, object_1.equals)(cursor, this.cursor)) {
            // cursor not moved
            return;
        }
        if (bufnr != this.targetBufnr || !events_1.default.insertMode || autoHide) {
            this.close();
            return;
        }
    }
    /**
     * Create float window/popup at cursor position.
     *
     * @deprecated use show method instead
     */
    async create(docs, _allowSelection = false, offsetX = 0) {
        await this.show(docs, {
            offsetX
        });
    }
    /**
     * Show documentations in float window/popup around cursor.
     * Window and buffer are reused when possible.
     * Window is closed automatically on change buffer, InsertEnter, CursorMoved and CursorMovedI.
     *
     * @param docs List of documentations.
     * @param config Configuration for floating window/popup.
     */
    async show(docs, config = {}) {
        if (docs.length == 0 || docs.every(doc => doc.content.length == 0)) {
            this.close();
            return;
        }
        let curr = Date.now();
        let release = await this.mutex.acquire();
        try {
            await this.createPopup(docs, config, curr);
            release();
        }
        catch (e) {
            this.nvim.echoError(e);
            release();
        }
    }
    async createPopup(docs, opts, timestamp) {
        docs = docs.filter(o => o.content.trim().length > 0);
        let { lines, codes, highlights } = (0, markdown_1.parseDocuments)(docs, { excludeImages: opts.excludeImages, breaks: opts.breaks });
        let config = {
            codes,
            highlights,
            pumAlignTop: events_1.default.pumAlignTop,
            preferTop: typeof opts.preferTop === 'boolean' ? opts.preferTop : false,
            offsetX: opts.offsetX || 0,
            title: opts.title || '',
            close: opts.close ? 1 : 0,
            rounded: opts.rounded ? 1 : 0,
            modes: opts.modes || ['n', 'i', 'ic', 's'],
            zindex: 1
        };
        if (!constants_1.isVim) {
            if (typeof opts.winblend === 'number')
                config.winblend = opts.winblend;
            if (opts.focusable != null)
                config.focusable = opts.focusable ? 1 : 0;
            if (opts.shadow)
                config.shadow = 1;
        }
        if (opts.maxHeight)
            config.maxHeight = opts.maxHeight;
        if (opts.maxWidth)
            config.maxWidth = opts.maxWidth;
        if (opts.border === true) {
            config.border = [1, 1, 1, 1];
        }
        else if (Array.isArray(opts.border) && !opts.border.every(o => o == 0)) {
            config.border = opts.border.slice(0, 4);
            config.rounded = opts.rounded ? 1 : 0;
        }
        if (opts.highlight)
            config.highlight = opts.highlight;
        if (opts.borderhighlight)
            config.borderhighlight = opts.borderhighlight;
        if (opts.cursorline)
            config.cursorline = 1;
        let autoHide = opts.autoHide === false ? false : true;
        if (autoHide)
            config.autohide = 1;
        this.unbind();
        let arr = await this.nvim.call('coc#dialog#create_cursor_float', [this.winid, this._bufnr, lines, config]);
        this.nvim.redrawVim();
        if ((0, array_1.isFalsyOrEmpty)(arr) || this.closeTs > timestamp) {
            let winid = arr && arr.length > 0 ? arr[2] : this.winid;
            if (winid) {
                this.winid = 0;
                this.nvim.call('coc#float#close', [winid], true);
                this.nvim.redrawVim();
            }
            return;
        }
        let [targetBufnr, cursor, winid, bufnr, alignTop] = arr;
        this.winid = winid;
        this._bufnr = bufnr;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        this.bindEvents(autoHide, alignTop == 1);
    }
    /**
     * Close float window
     */
    close() {
        let { winid, nvim } = this;
        this.closeTs = Date.now();
        this.unbind();
        if (winid) {
            this.winid = 0;
            nvim.call('coc#float#close', [winid], true);
            nvim.redrawVim();
        }
    }
    checkRetrigger(bufnr) {
        if (this.winid && this.targetBufnr == bufnr)
            return true;
        return false;
    }
    get bufnr() {
        return this._bufnr;
    }
    get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
    }
    get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
    }
    async activated() {
        if (!this.winid)
            return false;
        return await this.nvim.call('coc#float#valid', [this.winid]) != 0;
    }
    dispose() {
        this.cursor = undefined;
        this.onCursorMoved.clear();
        this.close();
    }
}
exports.default = FloatFactoryImpl;
//# sourceMappingURL=floatFactory.js.map