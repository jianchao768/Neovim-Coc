"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let handler;
let disposables = [];
let wordPattern;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    handler = helper_1.default.plugin.getHandler().linkedEditingHandler;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    helper_1.default.updateConfiguration('coc.preferences.enableLinkedEditing', true);
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
async function registerProvider(content, position) {
    let doc = await workspace_1.default.document;
    disposables.push(languages_1.default.registerLinkedEditingRangeProvider([{ language: '*' }], {
        provideLinkedEditingRanges: (doc, pos) => {
            let document = workspace_1.default.getDocument(doc.uri);
            let range = document.getWordRangeAtPosition(pos);
            if (!range)
                return null;
            let text = doc.getText(range);
            let ranges = document.getSymbolRanges(text);
            return { ranges, wordPattern };
        }
    }));
    await nvim.setLine(content);
    await doc.synchronize();
    await handler.enable(doc, position);
}
async function matches() {
    let res = await nvim.call('getmatches');
    res = res.filter(o => o.group === 'CocLinkedEditing');
    return res.length;
}
describe('LinkedEditing', () => {
    it('should active and cancel on cursor moved', async () => {
        await registerProvider('foo foo a ', vscode_languageserver_protocol_1.Position.create(0, 0));
        expect(await matches()).toBe(2);
        await nvim.command(`normal! $`);
        await helper_1.default.waitValue(() => {
            return matches();
        }, 0);
    });
    it('should active when moved to another word', async () => {
        await registerProvider('foo foo bar bar bar', vscode_languageserver_protocol_1.Position.create(0, 0));
        await nvim.call('cursor', [1, 9]);
        await helper_1.default.waitValue(() => {
            return matches();
        }, 3);
    });
    it('should active on text change', async () => {
        let doc = await workspace_1.default.document;
        await registerProvider('foo foo a ', vscode_languageserver_protocol_1.Position.create(0, 0));
        await nvim.call('cursor', [1, 1]);
        await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 0, 0, 0, ['i']]);
        await doc.synchronize();
        let line = await nvim.line;
        expect(line).toBe('ifoo ifoo a ');
        await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 0, 0, 1, []]);
        await doc.synchronize();
        line = await nvim.line;
        expect(line).toBe('foo foo a ');
    });
    it('should cancel when change out of range', async () => {
        let doc = await workspace_1.default.document;
        await registerProvider('foo foo bar', vscode_languageserver_protocol_1.Position.create(0, 0));
        await helper_1.default.waitValue(() => {
            return matches();
        }, 2);
        await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 9, 0, 10, ['']]);
        await doc.synchronize();
        await helper_1.default.waitValue(() => {
            return matches();
        }, 0);
    });
    it('should cancel on editor change', async () => {
        await registerProvider('foo foo a ', vscode_languageserver_protocol_1.Position.create(0, 0));
        await nvim.command(`enew`);
        await helper_1.default.wait(50);
        await helper_1.default.waitValue(() => {
            return matches();
        }, 0);
    });
    it('should cancel when insert none word character', async () => {
        await registerProvider('foo foo a ', vscode_languageserver_protocol_1.Position.create(0, 0));
        await nvim.call('cursor', [1, 4]);
        await nvim.input('i');
        await nvim.input('a');
        await helper_1.default.waitValue(() => {
            return matches();
        }, 2);
        await nvim.input('i');
        await nvim.input('@');
        await helper_1.default.waitValue(() => {
            return matches();
        }, 0);
    });
    it('should cancel when insert not match wordPattern', async () => {
        wordPattern = '[A-Z]';
        await registerProvider('foo foo a ', vscode_languageserver_protocol_1.Position.create(0, 0));
        await nvim.call('cursor', [1, 4]);
        await nvim.input('i');
        await nvim.input('A');
        await helper_1.default.waitValue(() => {
            return matches();
        }, 2);
        await nvim.input('i');
        await nvim.input('3');
        await helper_1.default.waitValue(() => {
            return matches();
        }, 0);
    });
    it('should cancel request on cursor moved', async () => {
        disposables.push(languages_1.default.registerLinkedEditingRangeProvider([{ language: '*' }], {
            provideLinkedEditingRanges: (doc, pos, token) => {
                return new Promise(resolve => {
                    token.onCancellationRequested(() => {
                        clearTimeout(timer);
                        resolve(null);
                    });
                    let timer = setTimeout(() => {
                        let document = workspace_1.default.getDocument(doc.uri);
                        let range = document.getWordRangeAtPosition(pos);
                        if (!range)
                            return resolve(null);
                        let text = doc.getText(range);
                        let ranges = document.getSymbolRanges(text);
                        resolve({ ranges, wordPattern });
                    }, 1000);
                });
            }
        }));
        let doc = await workspace_1.default.document;
        await nvim.setLine('foo foo  ');
        await doc.synchronize();
        await nvim.call('cursor', [1, 2]);
        await helper_1.default.wait(10);
        await nvim.call('cursor', [1, 9]);
        await helper_1.default.waitValue(() => {
            return matches();
        }, 0);
    });
});
//# sourceMappingURL=linkedEditing.test.js.map