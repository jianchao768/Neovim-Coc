"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const codeActions_1 = require("../../handler/codeActions");
const languages_1 = tslib_1.__importStar(require("../../languages"));
const codeActionManager_1 = require("../../provider/codeActionManager");
const util_1 = require("../../util");
const position_1 = require("../../util/position");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
let codeActions;
let currActions;
let resolvedAction;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    codeActions = helper_1.default.plugin.getHandler().codeActions;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
        provideCodeActions: (_document, _range, _context, _token) => currActions,
        resolveCodeAction: (_action, _token) => resolvedAction
    }, undefined));
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('handler codeActions', () => {
    describe('autoApply', () => {
        it('should check auto apply', async () => {
            expect((0, codeActions_1.shouldAutoApply)(undefined)).toBe(false);
            expect((0, codeActions_1.shouldAutoApply)([])).toBe(false);
            expect((0, codeActions_1.shouldAutoApply)([vscode_languageserver_protocol_1.CodeActionKind.Refactor])).toBe(false);
        });
    });
    describe('organizeImport', () => {
        it('should filter command ', () => {
            let cmd = vscode_languageserver_protocol_1.Command.create('title', 'command');
            let res = (0, codeActionManager_1.checkAction)([vscode_languageserver_protocol_1.CodeActionKind.Refactor], cmd);
            expect(res).toBe(false);
            res = (0, codeActionManager_1.checkAction)(undefined, cmd);
            expect(res).toBe(true);
        });
        it('should return false when organize import action not found', async () => {
            currActions = [];
            let doc = await helper_1.default.createDocument();
            expect(languages_1.default.hasProvider(languages_1.ProviderName.CodeAction, doc)).toBe(true);
            let res = await helper_1.default.doAction('organizeImport');
            expect(res).toBe(false);
            expect(languages_1.default.hasProvider('undefined', doc)).toBe(false);
        });
        it('should perform organize import action', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), 'bar'));
            edits.push(vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3), 'foo'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('organize import', edit, vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports);
            currActions = [action, vscode_languageserver_protocol_1.CodeAction.create('another action'), vscode_languageserver_protocol_1.Command.create('title', 'command')];
            await codeActions.organizeImport();
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar', 'foo']);
        });
        it('should register editor.action.organizeImport command', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), 'bar'));
            edits.push(vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3), 'foo'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('organize import', edit, vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports);
            currActions = [action, vscode_languageserver_protocol_1.CodeAction.create('another action')];
            await commands_1.default.executeCommand('editor.action.organizeImport');
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar', 'foo']);
        });
    });
    describe('codeActionRange', () => {
        it('should show warning when no action available', async () => {
            await helper_1.default.createDocument();
            currActions = [];
            await helper_1.default.doAction('codeActionRange', 1, 2, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch(/No quickfix code action/);
        });
        it('should apply chosen action', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', edit, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            currActions = [action];
            let p = codeActions.codeActionRange(1, 2, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            await helper_1.default.waitPrompt();
            await nvim.input('<CR>');
            await p;
            let buf = nvim.createBuffer(doc.bufnr);
            let lines = await buf.lines;
            expect(lines[0]).toBe('bar');
        });
    });
    describe('getCodeActions', () => {
        it('should get empty actions', async () => {
            currActions = [];
            let doc = await helper_1.default.createDocument();
            let res = await codeActions.getCodeActions(doc);
            expect(res.length).toBe(0);
        });
        it('should not filter disabled actions', async () => {
            currActions = [];
            let action = vscode_languageserver_protocol_1.CodeAction.create('foo', vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            action.disabled = { reason: 'disabled' };
            currActions.push(action);
            action = vscode_languageserver_protocol_1.CodeAction.create('bar', vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            action.disabled = { reason: 'disabled' };
            currActions.push(action);
            let doc = await helper_1.default.createDocument();
            let res = await codeActions.getCodeActions(doc);
            expect(res.length).toBe(2);
        });
        it('should get all actions', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.buffer.setLines(['', '', ''], { start: 0, end: -1, strictIndexing: false });
            let action = vscode_languageserver_protocol_1.CodeAction.create('curr action', vscode_languageserver_protocol_1.CodeActionKind.Empty);
            currActions = [action];
            let range;
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: (_document, r, _context, _token) => {
                    range = r;
                    return [vscode_languageserver_protocol_1.CodeAction.create('a'), vscode_languageserver_protocol_1.CodeAction.create('b'), vscode_languageserver_protocol_1.CodeAction.create('c'), vscode_languageserver_protocol_1.Command.create('title', 'command')];
                },
            }, undefined));
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: () => {
                    return [vscode_languageserver_protocol_1.CodeAction.create('a')];
                },
            }, undefined));
            let res = await codeActions.getCodeActions(doc);
            expect(range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 3, 0));
            expect(res.length).toBe(5);
        });
        it('should filter actions by range', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.buffer.setLines(['', '', ''], { start: 0, end: -1, strictIndexing: false });
            currActions = [];
            let range;
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: (_document, r, _context, _token) => {
                    range = r;
                    if ((0, position_1.rangeInRange)(r, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0)))
                        return [vscode_languageserver_protocol_1.CodeAction.create('a')];
                    return [vscode_languageserver_protocol_1.CodeAction.create('a'), vscode_languageserver_protocol_1.CodeAction.create('b'), vscode_languageserver_protocol_1.CodeAction.create('c')];
                },
            }, undefined));
            let res = await codeActions.getCodeActions(doc, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
            expect(range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
            expect(res.length).toBe(1);
        });
        it('should filter actions by kind prefix', async () => {
            let doc = await helper_1.default.createDocument();
            let action = vscode_languageserver_protocol_1.CodeAction.create('my action', vscode_languageserver_protocol_1.CodeActionKind.SourceFixAll);
            currActions = [action];
            let res = await codeActions.getCodeActions(doc, undefined, [vscode_languageserver_protocol_1.CodeActionKind.Source]);
            expect(res.length).toBe(1);
            expect(res[0].kind).toBe(vscode_languageserver_protocol_1.CodeActionKind.SourceFixAll);
            await helper_1.default.doAction('fixAll');
        });
    });
    describe('getCurrentCodeActions', () => {
        let range;
        beforeEach(() => {
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: (_document, r, _context, _token) => {
                    range = r;
                    return [vscode_languageserver_protocol_1.CodeAction.create('a'), vscode_languageserver_protocol_1.CodeAction.create('b'), vscode_languageserver_protocol_1.CodeAction.create('c')];
                },
            }, undefined));
        });
        it('should get codeActions by line', async () => {
            currActions = [];
            await helper_1.default.createDocument();
            let res = await helper_1.default.doAction('codeActions', 'line');
            expect(range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0));
            expect(res.length).toBe(3);
        });
        it('should get codeActions by cursor', async () => {
            currActions = [];
            await helper_1.default.createDocument();
            let res = await codeActions.getCurrentCodeActions('cursor');
            expect(range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
            expect(res.length).toBe(3);
        });
        it('should get codeActions by visual mode', async () => {
            currActions = [];
            await helper_1.default.createDocument();
            await nvim.setLine('foo');
            await nvim.command('normal! 0v$');
            await nvim.input('<esc>');
            let res = await codeActions.getCurrentCodeActions('v');
            expect(range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            expect(res.length).toBe(3);
        });
    });
    describe('doCodeAction', () => {
        it('should not throw when no action exists', async () => {
            currActions = [];
            await helper_1.default.createDocument();
            await helper_1.default.doAction('codeAction', undefined);
        });
        it('should apply single code action when only is title', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', edit, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            currActions = [action];
            await codeActions.doCodeAction(undefined, 'code fix');
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar']);
        });
        it('should apply single code action when only is QuickFix', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', edit, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            currActions = [action];
            await codeActions.doCodeAction(undefined, [vscode_languageserver_protocol_1.CodeActionKind.QuickFix]);
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar']);
        });
        it('should show disabled code action', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let refactorAction = vscode_languageserver_protocol_1.CodeAction.create('code refactor', edit, vscode_languageserver_protocol_1.CodeActionKind.Refactor);
            refactorAction.disabled = { reason: 'invalid position' };
            let fixAction = vscode_languageserver_protocol_1.CodeAction.create('code fix', edit, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            currActions = [refactorAction, fixAction];
            let p = codeActions.doCodeAction(undefined, undefined, true);
            let winid = await helper_1.default.waitFloat();
            let win = nvim.createWindow(winid);
            let buf = await win.buffer;
            let lines = await buf.lines;
            expect(lines.length).toBe(2);
            expect(lines[1]).toMatch(/code refactor/);
            await nvim.input('2');
            await helper_1.default.wait(1);
            await nvim.input('j');
            await nvim.input('<cr>');
            await helper_1.default.waitValue(async () => {
                let cmdline = await helper_1.default.getCmdline();
                return cmdline.includes('invalid position');
            }, true);
            await nvim.input('<esc>');
            await p;
        });
        it('should action dialog to choose action', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', edit, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            currActions = [action, vscode_languageserver_protocol_1.CodeAction.create('foo')];
            let promise = codeActions.doCodeAction(null);
            await helper_1.default.waitFloat();
            let ids = await nvim.call('coc#float#get_float_win_list');
            expect(ids.length).toBeGreaterThan(0);
            await nvim.input('<CR>');
            await promise;
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar']);
        });
        it('should choose code actions by range', async () => {
            let range;
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: (_document, r, _context, _token) => {
                    range = r;
                    return [vscode_languageserver_protocol_1.CodeAction.create('my title'), vscode_languageserver_protocol_1.CodeAction.create('b'), vscode_languageserver_protocol_1.CodeAction.create('c')];
                },
            }, undefined));
            await helper_1.default.createDocument();
            await nvim.setLine('abc');
            await nvim.command('normal! 0v$');
            await nvim.input('<esc>');
            await codeActions.doCodeAction('v', 'my title');
            expect(range).toEqual({ start: { line: 0, character: 0 }, end: { line: 0, character: 3 } });
        });
        it('should filter by provider kinds', async () => {
            currActions = [];
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: () => {
                    return [vscode_languageserver_protocol_1.CodeAction.create('my title'), vscode_languageserver_protocol_1.CodeAction.create('b'), vscode_languageserver_protocol_1.CodeAction.create('c')];
                },
            }, undefined, [vscode_languageserver_protocol_1.CodeActionKind.QuickFix]));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.getCodeActions(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 1), { only: [vscode_languageserver_protocol_1.CodeActionKind.Refactor], diagnostics: [] }, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toEqual([]);
        });
        it('should filter by codeAction kind', async () => {
            currActions = [];
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: () => {
                    return [
                        vscode_languageserver_protocol_1.CodeAction.create('my title', vscode_languageserver_protocol_1.CodeActionKind.QuickFix),
                        vscode_languageserver_protocol_1.CodeAction.create('b'),
                        vscode_languageserver_protocol_1.Command.create('command', 'command')
                    ];
                },
                resolveCodeAction: () => {
                    return null;
                }
            }, undefined));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.getCodeActions(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 1), { only: [vscode_languageserver_protocol_1.CodeActionKind.QuickFix], diagnostics: [] }, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(1);
            let resolved = await languages_1.default.resolveCodeAction(res[0], vscode_languageserver_protocol_1.CancellationToken.None);
            expect(resolved).toBeDefined();
        });
    });
    describe('doQuickfix', () => {
        it('should show message when quickfix action does not exist', async () => {
            currActions = [];
            await helper_1.default.createDocument();
            await helper_1.default.doAction('doQuickfix');
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('No quickfix');
        });
        it('should do preferred quickfix action', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', edit, vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            action.isPreferred = true;
            currActions = [vscode_languageserver_protocol_1.CodeAction.create('foo', vscode_languageserver_protocol_1.CodeActionKind.QuickFix), action, vscode_languageserver_protocol_1.CodeAction.create('bar')];
            await codeActions.doQuickfix();
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar']);
        });
    });
    describe('applyCodeAction', () => {
        it('should resolve codeAction', async () => {
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            action.isPreferred = true;
            currActions = [action];
            resolvedAction = Object.assign({ edit }, action);
            let arr = await helper_1.default.doAction('quickfixes', 'line');
            await commands_1.default.executeCommand('editor.action.doCodeAction', arr[0]);
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar']);
        });
        it('should throw for disabled action', async () => {
            let action = vscode_languageserver_protocol_1.CodeAction.create('my action', vscode_languageserver_protocol_1.CodeActionKind.Empty);
            action.disabled = { reason: 'disabled', providerId: 'x' };
            await expect(async () => {
                await helper_1.default.doAction('doCodeAction', action);
            }).rejects.toThrow(Error);
        });
        it('should invoke registered command after apply edit', async () => {
            let called;
            disposables.push(commands_1.default.registerCommand('test.execute', async (s) => {
                called = s;
                await nvim.command(s);
            }));
            let doc = await helper_1.default.createDocument();
            let edits = [];
            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'));
            let edit = { changes: { [doc.uri]: edits } };
            let action = vscode_languageserver_protocol_1.CodeAction.create('code fix', vscode_languageserver_protocol_1.CodeActionKind.QuickFix);
            action.isPreferred = true;
            currActions = [action];
            resolvedAction = Object.assign({
                edit,
                command: vscode_languageserver_protocol_1.Command.create('run vim command', 'test.execute', 'normal! $')
            }, action);
            let arr = await codeActions.getCurrentCodeActions('line', [vscode_languageserver_protocol_1.CodeActionKind.QuickFix]);
            await codeActions.applyCodeAction(arr[0]);
            let lines = await doc.buffer.lines;
            expect(lines).toEqual(['bar']);
            expect(called).toBe('normal! $');
        });
    });
});
//# sourceMappingURL=codeActions.test.js.map