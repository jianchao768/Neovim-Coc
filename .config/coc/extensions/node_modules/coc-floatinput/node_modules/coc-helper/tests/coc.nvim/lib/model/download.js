'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtname = exports.getEtag = void 0;
const uuid_1 = require("uuid");
const logger_1 = require("../logger");
const node_1 = require("../util/node");
const fetch_1 = require("./fetch");
const logger = (0, logger_1.createLogger)('model-download');
function getEtag(headers) {
    let header = headers['etag'];
    if (typeof header !== 'string')
        return undefined;
    header = header.replace(/^W\//, '');
    if (!header.startsWith('"') || !header.endsWith('"'))
        return undefined;
    return header.slice(1, -1);
}
exports.getEtag = getEtag;
function getExtname(dispositionHeader) {
    const contentDisposition = require('content-disposition');
    let disposition = contentDisposition.parse(dispositionHeader);
    let filename = disposition.parameters.filename;
    if (filename)
        return node_1.path.extname(filename);
    return undefined;
}
exports.getExtname = getExtname;
/**
 * Download file from url, with optional untar/unzip support.
 *
 * @param {string} url
 * @param {DownloadOptions} options contains dest folder and optional onProgress callback
 */
function download(urlInput, options, token) {
    let url = (0, fetch_1.toURL)(urlInput);
    let { etagAlgorithm } = options;
    let { dest, onProgress, extract } = options;
    if (!dest || !node_1.path.isAbsolute(dest)) {
        throw new Error(`Expect absolute file path for dest option.`);
    }
    if (!node_1.fs.existsSync(dest)) {
        node_1.fs.mkdirSync(dest, { recursive: true });
    }
    else {
        let stat = node_1.fs.statSync(dest);
        if (stat && !stat.isDirectory()) {
            throw new Error(`${dest} exists, but not directory!`);
        }
    }
    let mod = (0, fetch_1.getRequestModule)(url);
    let opts = (0, fetch_1.resolveRequestOptions)(url, options);
    if (!opts.agent && options.agent)
        opts.agent = options.agent;
    let extname = node_1.path.extname(url.pathname);
    let finished = false;
    return new Promise((resolve, reject) => {
        if (token) {
            let disposable = token.onCancellationRequested(() => {
                disposable.dispose();
                req.destroy(new Error('request aborted'));
            });
        }
        let timer;
        const req = mod.request(opts, (res) => {
            var _a;
            if ((res.statusCode >= 200 && res.statusCode < 300) || res.statusCode === 1223) {
                let headers = res.headers;
                let dispositionHeader = headers['content-disposition'];
                let etag = getEtag(headers);
                let checkEtag = etag && typeof etagAlgorithm === 'string';
                if (!extname && dispositionHeader) {
                    extname = getExtname(dispositionHeader);
                }
                if (extract === true) {
                    if (extname === '.zip' || headers['content-type'] == 'application/zip') {
                        extract = 'unzip';
                    }
                    else if (extname == '.tgz') {
                        extract = 'untar';
                    }
                    else {
                        reject(new Error(`Unable to detect extract method for ${url}`));
                        return;
                    }
                }
                let total = Number(headers['content-length']);
                let hasTotal = !isNaN(total);
                let cur = 0;
                res.on('error', err => {
                    reject(new Error(`Unable to connect ${url}: ${err.message}`));
                });
                let hash = checkEtag ? node_1.crypto.createHash(etagAlgorithm) : undefined;
                res.on('data', chunk => {
                    cur += chunk.length;
                    if (hash)
                        hash.update(chunk);
                    if (hasTotal) {
                        let percent = (cur / total * 100).toFixed(1);
                        typeof onProgress === 'function' ? onProgress(percent) : logger.info(`Download ${url} progress ${percent}%`);
                    }
                });
                res.on('end', () => {
                    clearTimeout(timer);
                    timer = undefined;
                    logger.info('Download completed:', url);
                });
                let stream;
                if (extract === 'untar') {
                    const tar = require('tar');
                    stream = res.pipe(tar.x({ strip: (_a = options.strip) !== null && _a !== void 0 ? _a : 1, C: dest }));
                }
                else if (extract === 'unzip') {
                    const unzip = require('unzip-stream');
                    stream = res.pipe(unzip.Extract({ path: dest }));
                }
                else {
                    dest = node_1.path.join(dest, `${(0, uuid_1.v1)()}${extname}`);
                    stream = res.pipe(node_1.fs.createWriteStream(dest));
                }
                stream.on('finish', () => {
                    if (hash) {
                        if (hash.digest('hex') !== etag) {
                            reject(new Error(`Etag check failed by ${etagAlgorithm}, content not match.`));
                            return;
                        }
                    }
                    logger.info(`Downloaded ${url} => ${dest}`);
                    setTimeout(() => {
                        resolve(dest);
                    }, 100);
                });
                stream.on('error', reject);
            }
            else {
                reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
            }
        });
        req.on('error', e => {
            // Possible succeed proxy request with ECONNRESET error on node > 14
            if (opts.agent && e['code'] == 'ECONNRESET') {
                timer = setTimeout(() => {
                    finished = true;
                    reject(e);
                }, fetch_1.timeout);
            }
            else {
                clearTimeout(timer);
                if (opts.agent && opts.agent.proxy) {
                    reject(new Error(`Request failed using proxy ${opts.agent.proxy.host}: ${e.message}`));
                    return;
                }
                finished = true;
                reject(e);
            }
        });
        req.on('timeout', () => {
            req.destroy(new Error(`request timeout after ${options.timeout}ms`));
        });
        if (typeof options.timeout === 'number' && options.timeout) {
            req.setTimeout(options.timeout);
        }
        req.end();
    });
}
exports.default = download;
//# sourceMappingURL=download.js.map