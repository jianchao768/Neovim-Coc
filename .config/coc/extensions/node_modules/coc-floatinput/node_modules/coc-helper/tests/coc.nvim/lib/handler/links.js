'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.sameLinks = void 0;
const tslib_1 = require("tslib");
const debounce_1 = tslib_1.__importDefault(require("debounce"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const object_1 = require("../util/object");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
// const regex = /CocAction(Async)?\(["']openLink["']\)/
let floatFactory;
const debounceTime = (0, util_1.getConditionValue)(200, 10);
const NAMESPACE = 'links';
const highlightGroup = 'CocLink';
class Links {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.setConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        events_1.default.on('CursorHold', async () => {
            await this.showTooltip();
        }, null, this.disposables);
        events_1.default.on(['CursorMoved', 'InsertEnter'], () => {
            this.cancel();
        }, null, this.disposables);
        this.buffers = workspace_1.default.registerBufferSync(doc => {
            return new LinkBuffer(doc);
        });
        this.disposables.push(this.buffers);
        languages_1.default.onDidLinksRefresh(selector => {
            for (let item of this.buffers.items) {
                if (workspace_1.default.match(selector, item.doc)) {
                    item.fetchLinks();
                }
            }
        }, null, this.disposables);
    }
    setConfiguration(e) {
        if (!e || e.affectsConfiguration('links')) {
            this.tooltip = workspace_1.default.initialConfiguration.get('links.tooltip', false);
            if (e) {
                for (let item of this.buffers.items) {
                    item.updateDocumentConfig();
                }
            }
        }
    }
    async showTooltip() {
        if (!this.tooltip)
            return;
        let link = await this.getCurrentLink();
        if (!link || !link.target)
            return;
        let text = link.target;
        if (link.tooltip)
            text += ' ' + link.tooltip;
        let doc = { content: text, filetype: 'txt' };
        if (!floatFactory)
            floatFactory = window_1.default.createFloatFactory({});
        await floatFactory.show([doc]);
    }
    async getLinks() {
        let { doc } = await this.handler.getCurrentState();
        let buf = this.buffers.getItem(doc.bufnr);
        await buf.getLinks();
        return (0, array_1.toArray)(buf.links);
    }
    async getCurrentLink() {
        let links = await this.getLinks();
        let pos = await window_1.default.getCursorPosition();
        if (links && links.length) {
            for (let link of links) {
                if ((0, position_1.positionInRange)(pos, link.range) == 0) {
                    if (!link.target) {
                        let tokenSource = this.tokenSource = this.tokenSource || new protocol_1.CancellationTokenSource();
                        link = await languages_1.default.resolveDocumentLink(link, this.tokenSource.token);
                        this.tokenSource = undefined;
                        if (!link.target || tokenSource.token.isCancellationRequested)
                            continue;
                    }
                    return link;
                }
            }
        }
        let line = await this.nvim.call('getline', ['.']);
        let regex = /\w+?:\/\/[^)\]'" ]+/g;
        let arr;
        let link;
        while ((arr = regex.exec(line)) !== null) {
            let start = arr.index;
            if (start <= pos.character && start + arr[0].length >= pos.character) {
                link = vscode_languageserver_types_1.DocumentLink.create(vscode_languageserver_types_1.Range.create(pos.line, start, pos.line, start + arr[0].length), arr[0]);
                break;
            }
        }
        return link;
    }
    async openCurrentLink() {
        let link = await this.getCurrentLink();
        if (link) {
            await this.openLink(link);
            return true;
        }
        return false;
    }
    async openLink(link) {
        if (!link.target)
            throw new Error(`Failed to resolve link target`);
        await workspace_1.default.openResource(link.target);
    }
    getBuffer(bufnr) {
        return this.buffers.getItem(bufnr);
    }
    cancel() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Links;
class LinkBuffer {
    // last highlight version
    constructor(doc) {
        this.doc = doc;
        this.links = [];
        this.fetchLinks = (0, debounce_1.default)(() => {
            void this.getLinks();
        }, debounceTime);
        if (this.hasProvider)
            this.fetchLinks();
    }
    get config() {
        if (this._config)
            return this._config;
        this.updateDocumentConfig();
        return this._config;
    }
    get hasProvider() {
        return languages_1.default.hasProvider(languages_1.ProviderName.DocumentLink, this.doc);
    }
    updateDocumentConfig() {
        let configuration = workspace_1.default.getConfiguration('links', this.doc);
        this._config = {
            enable: configuration.get('enable', true),
            highlight: configuration.get('highlight', false),
        };
    }
    onChange(e) {
        if (e.contentChanges.length == 0) {
            this.highlight();
        }
        else {
            this.cancel();
            this.fetchLinks();
        }
    }
    highlight() {
        if (!this.config.highlight || !this.links)
            return;
        let { links, doc } = this;
        if ((0, array_1.isFalsyOrEmpty)(links)) {
            this.clearHighlight();
        }
        else {
            let highlights = [];
            links.forEach(link => {
                doc.addHighlights(highlights, highlightGroup, link.range);
            });
            this.doc.buffer.updateHighlights(NAMESPACE, highlights, { priority: 2048 });
        }
    }
    clearHighlight() {
        this.buffer.clearNamespace(NAMESPACE);
    }
    get buffer() {
        return this.doc.buffer;
    }
    cancel() {
        this.fetchLinks.clear();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    async getLinks() {
        if (!this.hasProvider || !this.config.enable)
            return;
        this.cancel();
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        let links = await languages_1.default.getDocumentLinks(this.doc.textDocument, token);
        this.tokenSource = undefined;
        if (token.isCancellationRequested || sameLinks((0, array_1.toArray)(this.links), (0, array_1.toArray)(links)))
            return;
        this.links = (0, array_1.toArray)(links);
        this.highlight();
    }
    dispose() {
        this.cancel();
    }
}
function sameLinks(links, other) {
    if (links.length != other.length)
        return false;
    for (let i = 0; i < links.length; i++) {
        if (!(0, object_1.equals)(links[i].range, other[i].range)) {
            return false;
        }
    }
    return true;
}
exports.sameLinks = sameLinks;
//# sourceMappingURL=links.js.map