"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const configuration_1 = require("../../language-client/configuration");
const index_1 = require("../../language-client/index");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
function createClient(section, middleware = {}, opts = {}) {
    const serverModule = path_1.default.join(__dirname, './server/configServer.js');
    const serverOptions = {
        run: { module: serverModule, transport: index_1.TransportKind.ipc },
        debug: { module: serverModule, transport: index_1.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }
    };
    const documentSelector = [{ scheme: 'file' }];
    const clientOptions = Object.assign({
        documentSelector,
        synchronize: {
            configurationSection: section
        },
        initializationOptions: {},
        middleware
    }, opts);
    const result = new index_1.LanguageClient('test', 'Test Language Server', serverOptions, clientOptions);
    return result;
}
beforeAll(async () => {
    await helper_1.default.setup();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('pull configuration feature', () => {
    let client;
    beforeAll(async () => {
        client = createClient(undefined);
        await client.start();
    });
    afterAll(async () => {
        await client.stop();
    });
    it('should request all configuration', async () => {
        var _a;
        let config;
        client.middleware.workspace = (_a = client.middleware.workspace) !== null && _a !== void 0 ? _a : {};
        client.middleware.workspace.configuration = (params, token, next) => {
            config = next(params, token);
            return config;
        };
        await client.sendNotification('pull0');
        await helper_1.default.waitValue(() => {
            return config != null;
        }, true);
        expect(config[0].http).toBeDefined();
    });
    it('should request configurations with sections', async () => {
        var _a;
        let config;
        client.middleware.workspace = (_a = client.middleware.workspace) !== null && _a !== void 0 ? _a : {};
        client.middleware.workspace.configuration = (params, token, next) => {
            config = next(params, token);
            return config;
        };
        await client.sendNotification('pull1');
        await helper_1.default.waitValue(() => {
            return config === null || config === void 0 ? void 0 : config.length;
        }, 3);
        expect(config[1]).toBeNull();
        expect(config[0].proxy).toBeDefined();
        expect(config[2]).toBeNull();
    });
});
describe('publish configuration feature', () => {
    it('should send configuration for languageserver', async () => {
        let client;
        client = createClient('languageserver.cpp.settings');
        let changed;
        client.onNotification('configurationChange', params => {
            changed = params;
        });
        await client.start();
        await helper_1.default.waitValue(() => {
            return changed != null;
        }, true);
        expect(changed).toEqual({ settings: {} });
        await client.stop();
    });
    it('should get configuration from workspace folder', async () => {
        let folder = path_1.default.resolve(__dirname, '../sample');
        workspace_1.default.workspaceFolderControl.addWorkspaceFolder(folder, false);
        let configFilePath = path_1.default.join(folder, '.vim/coc-settings.json');
        workspace_1.default.configurations.addFolderFile(configFilePath, false, folder);
        let client = createClient('coc.preferences', {}, {
            workspaceFolder: { name: 'sample', uri: vscode_uri_1.URI.file(folder).toString() }
        });
        let changed;
        client.onNotification('configurationChange', params => {
            changed = params;
        });
        await client.start();
        await helper_1.default.waitValue(() => {
            return changed != null;
        }, true);
        expect(changed.settings.coc.preferences.rootPath).toBe('./src');
        workspace_1.default.workspaceFolderControl.removeWorkspaceFolder(folder);
        let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.method);
        feature.dispose();
        await client.stop();
    });
    it('should send configuration for specific sections', async () => {
        let client;
        let called = false;
        client = createClient(['coc.preferences', 'npm', 'unknown'], {
            workspace: {
                didChangeConfiguration: (sections, next) => {
                    called = true;
                    return next(sections);
                }
            }
        });
        let changed;
        client.onNotification('configurationChange', params => {
            changed = params;
        });
        await client.start();
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        await helper_1.default.waitValue(() => {
            return changed != null;
        }, true);
        expect(changed.settings.coc).toBeDefined();
        expect(changed.settings.npm).toBeDefined();
        let { configurations } = workspace_1.default;
        configurations.updateMemoryConfig({ 'npm.binPath': 'cnpm' });
        await helper_1.default.waitValue(() => {
            var _a;
            return (_a = changed.settings.npm) === null || _a === void 0 ? void 0 : _a.binPath;
        }, 'cnpm');
        await client.stop();
    });
    it('should catch reject error', async () => {
        let client;
        let called = false;
        client = createClient(['cpp'], {
            workspace: {
                didChangeConfiguration: () => {
                    return Promise.reject(new Error('custom error'));
                }
            }
        });
        let changed;
        client.onNotification('configurationChange', params => {
            changed = params;
        });
        await client.start();
        await helper_1.default.wait(50);
        expect(called).toBe(false);
        void client.stop();
        await client.stop();
    });
    it('should extractSettingsInformation', async () => {
        let res = configuration_1.SyncConfigurationFeature.extractSettingsInformation(['http.proxy', 'http.proxyCA']);
        expect(res.http).toBeDefined();
        expect(res.http.proxy).toBeDefined();
    });
});
//# sourceMappingURL=configuration.test.js.map