"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const around_1 = require("../../completion/native/around");
const buffer_1 = require("../../completion/native/buffer");
const file_1 = require("../../completion/native/file");
const source_1 = tslib_1.__importStar(require("../../completion/source"));
const source_vim_1 = tslib_1.__importDefault(require("../../completion/source-vim"));
const sources_1 = tslib_1.__importStar(require("../../completion/sources"));
const types_1 = require("../../completion/types");
const util_1 = require("../../util");
const extension_1 = tslib_1.__importDefault(require("../../extension"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let disposables = [];
const emptyFn = () => Promise.resolve(null);
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('KeywordsBuffer', () => {
    it('should parse keywords', async () => {
        let filepath = await (0, helper_1.createTmpFile)(' ab\nab');
        let doc = await helper_1.default.createDocument(filepath);
        let b = sources_1.default.getKeywordsBuffer(doc.bufnr);
        let words = b.getWords();
        expect(words).toEqual(['ab']);
        await doc.applyEdits([vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo\nbar')]);
        words = b.getWords();
        expect(words).toEqual(['foo', 'bar', 'ab']);
        await doc.applyEdits([vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 1, 3), 'def ')]);
        words = b.getWords();
        expect(words).toEqual(['def', 'ab']);
    });
    it('should yield match words', async () => {
        let filepath = await (0, helper_1.createTmpFile)(`_foo\nbar\n`);
        let doc = await helper_1.default.createDocument(filepath);
        let b = sources_1.default.getKeywordsBuffer(doc.bufnr);
        const getResults = (iterable) => {
            let res = [];
            for (let word of iterable) {
                res.push(word);
            }
            return res;
        };
        let iterable = b.matchWords(0);
        expect(getResults(iterable)).toEqual(['_foo', 'bar']);
        iterable = b.matchWords(2);
        expect(getResults(iterable)).toEqual(['_foo', 'bar']);
    });
});
describe('Source', () => {
    function createSource(opt) {
        let s = new source_1.default(opt);
        disposables.push(s);
        return s;
    }
    function makeid(length) {
        let result = '';
        let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        return result;
    }
    it('should check trigger only source', async () => {
        expect(typeof sources_1.Sources).toBe('function');
        (0, sources_1.logError)('');
        let name = 'foo';
        let s = createSource({ name, triggerOnly: true, doComplete: emptyFn });
        expect(s.triggerOnly).toBe(true);
        expect(s.triggerPatterns).toBeNull();
        s = createSource({ name, doComplete: emptyFn });
        helper_1.default.updateConfiguration(`coc.source.${name}.triggerPatterns`, [null, 'foo']);
        expect(s.triggerOnly).toBe(true);
    });
    it('should get source type', async () => {
        for (let t of [types_1.SourceType.Native, types_1.SourceType.Remote, types_1.SourceType.Service]) {
            expect((0, sources_1.getSourceType)(t)).toBeDefined();
        }
    });
    it('should check complete', async () => {
        let name = 'foo';
        let s = createSource({ name, doComplete: emptyFn });
        helper_1.default.updateConfiguration(`coc.source.${name}.disableSyntaxes`, ['comment']);
        await nvim.input('i');
        let opt = await nvim.call('coc#util#get_complete_option');
        opt.synname = 'Comment';
        expect(await s.checkComplete(opt)).toBe(false);
        let result = await s.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(result).toBeNull();
        opt.synname = 'String';
        expect(await s.checkComplete(opt)).toBe(true);
        opt.synname = '';
        expect(await s.checkComplete(opt)).toBe(true);
        s = createSource({
            name, shouldComplete: () => {
                return Promise.resolve(false);
            },
            doComplete: emptyFn
        });
        expect(await s.checkComplete(opt)).toBe(false);
    });
    it('should call optional functions', async () => {
        await nvim.input('i');
        let opt = await nvim.call('coc#util#get_complete_option');
        let name = 'foo';
        let n = 0;
        let s = createSource({
            name,
            doComplete: emptyFn,
            refresh: () => {
                n++;
                return Promise.resolve();
            },
            onCompleteDone: () => {
                n++;
                return Promise.resolve();
            },
            onCompleteResolve: () => {
                n++;
                return Promise.resolve();
            }
        });
        expect(s.optionalFns).toEqual([]);
        await s.refresh();
        await s.onCompleteDone({}, opt);
        await s.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        await s.onCompleteResolve({}, opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(n).toBe(3);
    });
    it('should get results', async () => {
        let name = 'foo';
        let s = createSource({ name, doComplete: emptyFn });
        let words = [];
        for (let i = 0; i < 80000; i++) {
            words.push(makeid(10));
        }
        let items = new Set();
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let p = s.getResults([words], '_$c', '', items, tokenSource.token);
        tokenSource.cancel();
        let res = await p;
        expect(res).toBe(true);
        let n = Date.now();
        p = s.getResults([words], '_$a', '', items, vscode_languageserver_protocol_1.CancellationToken.None);
        let spy = jest.spyOn(Date, 'now').mockImplementation(() => {
            return n + 200;
        });
        res = await p;
        spy.mockRestore();
        expect(res).toBe(true);
        words = [];
        for (let i = 0; i < 300; i++) {
            words.push('a' + makeid(10));
        }
        items = new Set();
        res = await s.getResults([words], 'a', '', items, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(items.size).toBe(50);
        items = new Set();
        res = await s.getResults([['你好']], 'ni', '', items, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(items.size).toBe(1);
    });
});
describe('vim source', () => {
    function createSourceFile(name, content) {
        let dir = path_1.default.join(os_1.default.tmpdir(), `coc/source`);
        fs_1.default.mkdirSync(dir, { recursive: true });
        let filepath = path_1.default.join(dir, `${name}.vim`);
        fs_1.default.writeFileSync(filepath, content, 'utf8');
        return filepath;
    }
    it('should not throw when pluginPath already used', async () => {
        await sources_1.default.createVimSources(process.cwd());
        await sources_1.default.createVimSources(process.cwd());
    });
    it('should show error for bad source file', async () => {
        let filepath = createSourceFile('tmp', '');
        await sources_1.default.createVimSourceExtension(filepath);
        let line = await helper_1.default.getCmdline();
        expect(line).toMatch('Error');
    });
    it('should register filetypes extension for vim source', async () => {
        let content = `
function! coc#source#foo#init()
  return {'filetypes': ['vim'], 'firstMatch': v:true}
endfunction
function! coc#source#foo#complete(opt, cb) abort
  call a:cb([])
endfunction `;
        let filepath = createSourceFile('foo', content);
        await sources_1.default.createVimSourceExtension(filepath);
        let ext = extension_1.default.getExtension('coc-vim-source-foo');
        expect(ext).toBeDefined();
        await Promise.resolve(ext.deactivate());
    });
    it('should not run by check complete', async () => {
        let opt = await nvim.call('coc#util#get_complete_option');
        let source = new source_vim_1.default({
            name: 'vim',
            sourceType: types_1.SourceType.Remote,
            optionalFns: ['on_complete', 'on_enter']
        });
        helper_1.default.updateConfiguration('coc.source.vim.disableSyntaxes', ['comment']);
        helper_1.default.updateConfiguration('coc.source.vim.filetypes', ['vim']);
        opt.synname = 'VimComment';
        opt.filetype = 'vim';
        let res = await source.checkComplete(opt);
        expect(res).toBe(false);
        let result = await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(result).toBe(null);
        opt.synname = '';
        res = await source.checkComplete(opt);
        expect(res).toBe(true);
        result = await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.Cancelled);
        expect(result).toBe(null);
        source.onEnter(999);
        let bufnr = await nvim.call('bufnr', ['%']);
        source.onEnter(bufnr);
    });
    it('should register extension for vim source', async () => {
        let content = `
function! coc#source#foo#init()
  return {'firstMatch': v:true, 'isSnippet': v:true}
endfunction

function! coc#source#foo#on_enter(...)
  let g:coc_entered = 1
endfunction

function! coc#source#foo#get_startcol(opt)
  if a:opt['col'] == 1
    return 0
  endif
  return a:opt['col']
endfunction

function! coc#source#foo#complete(opt, cb) abort
  if a:opt['col'] == 0
    call a:cb([{'word': '.f'}])
    return
  endif
  call a:cb([])
endfunction `;
        let filepath = createSourceFile('foo', content);
        await sources_1.default.createVimSourceExtension(filepath);
        let source = sources_1.default.getSource('foo');
        expect(source).toBeDefined();
        let bufnr = await nvim.call('bufnr', ['%']);
        source.onEnter(bufnr);
        let val = await nvim.getVar('coc_entered');
        expect(val).toBe(1);
        await nvim.setLine('.');
        await nvim.input('A');
        let opt = await nvim.call('coc#util#get_complete_option');
        let res = await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(res.startcol).toBe(0);
        expect(res.items).toEqual([{ word: '.f', isSnippet: true }]);
        opt.col = 2;
        res = await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(res).toBe(null);
    });
    it('should not insert snippet when on_complete exists', async () => {
        let opt = await nvim.call('coc#util#get_complete_option');
        let source = new source_vim_1.default({
            name: 'vim',
            sourceType: types_1.SourceType.Remote,
            optionalFns: ['on_complete']
        });
        let item = {
            word: 'word',
            abbr: 'word',
            filterText: 'word',
            isSnippet: true,
            insertText: 'word($1)'
        };
        let spy = jest.spyOn(nvim, 'call').mockImplementation(() => {
            return undefined;
        });
        await source.refresh();
        await source.onCompleteDone(item, opt);
        spy.mockRestore();
        let line = await nvim.line;
        expect(line).toBe('');
    });
    it('should insert snippet', async () => {
        let opt = await nvim.call('coc#util#get_complete_option');
        let source = new source_vim_1.default({
            name: 'vim',
            sourceType: types_1.SourceType.Remote
        });
        let item = {
            word: 'word',
            abbr: 'word',
            filterText: 'word',
            isSnippet: true,
            insertText: 'word($1)'
        };
        await source.onCompleteDone(item, opt);
        let line = await nvim.line;
        expect(line).toBe('word()');
    });
});
describe('native sources', () => {
    it('should resolveEnvVariables', () => {
        expect((0, file_1.resolveEnvVariables)('%HOME%/data%x%', { HOME: '/home' })).toBe('/home/data%x%');
        expect((0, file_1.resolveEnvVariables)('$HOME/${USER}/data', { HOME: '/home', USER: 'foo' })).toBe('/home/foo/data');
        expect((0, file_1.resolveEnvVariables)('$PART/data', {})).toBe('$PART/data');
    });
    it('should getDirectory', () => {
        expect((0, file_1.getDirectory)('a/b', '/home')).toBe('/home/a');
        expect((0, file_1.getDirectory)(__dirname, '/home')).toBe(path_1.default.dirname(__dirname));
    });
    it('should getItemsFromRoot', async () => {
        let res = await (0, file_1.getItemsFromRoot)('a/b', '/not_exists', true, []);
        expect(res).toEqual([]);
    });
    it('should getFileItem', async () => {
        expect(await (0, file_1.getFileItem)(__dirname, '')).toBeDefined();
        expect(await (0, file_1.getFileItem)(__dirname, 'file_not_exists')).toBeNull();
        expect(await (0, file_1.getFileItem)(__dirname, path_1.default.basename(__filename))).toBeDefined();
    });
    it('should filterFiles', () => {
        expect((0, file_1.filterFiles)(['.a', '.b', null], false)).toEqual(['.a', '.b']);
        expect((0, file_1.filterFiles)(['a.js', 'b.ts'], true, ['*.js'])).toEqual(['b.ts']);
    });
    it('should getRoot', async () => {
        let file = new file_1.File(false);
        let filepath = __filename;
        let cwd = process.cwd();
        let root = await file.getRoot('./a', '', '', cwd);
        expect(root).toBe(cwd);
        root = await file.getRoot('./a', '', filepath, cwd);
        expect(root).toBe(path_1.default.dirname(filepath));
        root = await file.getRoot('/a/b/', '', filepath, cwd);
        expect(root).toBe('/a/b/');
        root = await file.getRoot('/a/b', '', filepath, cwd);
        expect(root).toBe('/a');
        root = await file.getRoot('', 'a/b/not_exists', filepath, cwd);
        expect(root).toBeUndefined();
        let dir = path_1.default.dirname(__dirname);
        let base = path_1.default.basename(__dirname);
        root = await file.getRoot('', base, __dirname, cwd);
        expect(root).toBe(dir);
        root = await file.getRoot('', base, '/a/b', dir);
        expect(root).toBe(dir);
        root = await file.getRoot('', '', '', dir);
        expect(root).toBe(dir);
        file.isWindows = true;
        root = await file.getRoot('C:\\user', '', filepath, cwd);
        expect(root).toBe('C:\\');
        root = await file.getRoot('C:\\user\\', '', filepath, cwd);
        expect(root).toBe('C:\\user\\');
        let arr = file.triggerCharacters;
        expect(arr.includes('\\')).toBe(true);
    });
    it('should firstMatchFuzzy', async () => {
        expect((0, source_1.firstMatchFuzzy)(97, true, '_a')).toBe(true);
        expect((0, source_1.firstMatchFuzzy)(97, true, 'a')).toBe(true);
        expect((0, source_1.firstMatchFuzzy)(97, true, 'A')).toBe(true);
        expect((0, source_1.firstMatchFuzzy)(97, true, 'â')).toBe(true);
        expect((0, source_1.firstMatchFuzzy)(226, false, 'â')).toBe(true);
    });
    it('should works for around source', async () => {
        let doc = await workspace_1.default.document;
        await nvim.setLine('foo ');
        await doc.synchronize();
        let { mode } = await nvim.mode;
        expect(mode).toBe('n');
        await nvim.input('Af');
        await helper_1.default.waitPopup();
        let res = await helper_1.default.visible('foo', 'around');
        expect(res).toBe(true);
        await nvim.input('<esc>');
    });
    it('should works for buffer source', async () => {
        await helper_1.default.createDocument();
        await nvim.command('set hidden');
        let doc = await helper_1.default.createDocument();
        await nvim.setLine('other');
        await nvim.command('bp');
        await doc.synchronize();
        let { mode } = await nvim.mode;
        expect(mode).toBe('n');
        await nvim.input('io');
        let res = await helper_1.default.visible('other', 'buffer');
        expect(res).toBe(true);
    });
    it('should trigger for inComplete complete', async () => {
        await nvim.setLine('foo');
        await nvim.input('A');
        let opt = await nvim.call('coc#util#get_complete_option');
        opt.triggerForInComplete = true;
        let around = new around_1.Around(sources_1.default.keywords);
        let res = await around.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(res).toBeDefined();
        let buffer = new buffer_1.Buffer(sources_1.default.keywords);
        res = await buffer.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(res).toBeDefined();
    });
    it('should fix col for file source', async () => {
        await nvim.command(`edit t|setl iskeyword+=/`);
        await nvim.setLine('./');
        await nvim.input('A');
        nvim.call('coc#start', { source: 'file' }, true);
        await helper_1.default.waitPopup();
    });
    it('should not complete when cancelled', async () => {
        await nvim.setLine('/foo');
        await nvim.input('A');
        let file = new file_1.File(false);
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let opt = await nvim.call('coc#util#get_complete_option');
        let p = file.doComplete(opt, tokenSource.token);
        tokenSource.cancel();
        let res = await p;
        expect(res).toBeNull();
    });
    it('should complete with words source', async () => {
        let stats = sources_1.default.sourceStats();
        let find = stats.find(o => o.name === '$words');
        expect(find).toBeUndefined();
        let s = sources_1.default.getSource('$words');
        expect(s.name).toBe('$words');
        expect(s.shortcut).toBe('');
        expect(s.triggerOnly).toBe(true);
        sources_1.default.setWords(['foo', 'bar']);
        await nvim.setLine('longwords');
        await nvim.input('A');
        nvim.call('coc#start', { source: '$words' }, true);
        await helper_1.default.waitPopup();
        let items = await helper_1.default.items();
        expect(items.map(o => o.word)).toEqual(['foo', 'bar']);
    });
});
//# sourceMappingURL=sources.test.js.map