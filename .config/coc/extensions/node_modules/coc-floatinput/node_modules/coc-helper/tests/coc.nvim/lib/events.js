'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventName = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("./logger");
const util_1 = require("./util");
const errors_1 = require("./util/errors");
const Is = tslib_1.__importStar(require("./util/is"));
const object_1 = require("./util/object");
const protocol_1 = require("./util/protocol");
const string_1 = require("./util/string");
const logger = (0, logger_1.createLogger)('events');
const SYNC_AUTOCMDS = ['BufWritePre'];
var EventName;
(function (EventName) {
    EventName["Ready"] = "ready";
    EventName["PumInsert"] = "PumInsert";
    EventName["InsertEnter"] = "InsertEnter";
    EventName["InsertLeave"] = "InsertLeave";
    EventName["CursorHoldI"] = "CursorHoldI";
    EventName["CursorMovedI"] = "CursorMovedI";
    EventName["CursorHold"] = "CursorHold";
    EventName["CursorMoved"] = "CursorMoved";
    EventName["MenuPopupChanged"] = "MenuPopupChanged";
    EventName["InsertCharPre"] = "InsertCharPre";
    EventName["TextChanged"] = "TextChanged";
    EventName["BufEnter"] = "BufEnter";
    EventName["TextChangedI"] = "TextChangedI";
    EventName["TextChangedP"] = "TextChangedP";
    EventName["TextInsert"] = "TextInsert";
})(EventName = exports.EventName || (exports.EventName = {}));
class Events {
    constructor() {
        this.handlers = new Map();
        this._bufnr = 1;
        // bufnr & character
        this._recentInserts = [];
        this._lastChange = 0;
        this._insertMode = false;
        this._pumAlignTop = false;
        this._pumVisible = false;
        this._completing = false;
        this._requesting = false;
        this._ready = false;
        this.timeout = 1000;
    }
    // public completing = false
    set requesting(val) {
        this._requesting = val;
    }
    get requesting() {
        return this._requesting;
    }
    get ready() {
        return this._ready;
    }
    set completing(completing) {
        this._completing = completing;
        this._pumVisible = completing;
    }
    get completing() {
        return this._completing;
    }
    get cursor() {
        var _a;
        return (_a = this._cursor) !== null && _a !== void 0 ? _a : { bufnr: this._bufnr, col: 1, lnum: 1, insert: false };
    }
    get bufnr() {
        return this._bufnr;
    }
    get pumvisible() {
        return this._pumVisible;
    }
    get pumAlignTop() {
        return this._pumAlignTop;
    }
    get insertMode() {
        return this._insertMode;
    }
    get lastChangeTs() {
        return this._lastChange;
    }
    /**
     * Resolved when first event fired or timeout
     */
    race(events, token) {
        let disposables = [];
        return new Promise(resolve => {
            if (Is.number(token)) {
                let timer = setTimeout(() => {
                    (0, util_1.disposeAll)(disposables);
                    resolve(undefined);
                }, token);
                disposables.push(protocol_1.Disposable.create(() => {
                    clearTimeout(timer);
                }));
            }
            else if (protocol_1.CancellationToken.is(token)) {
                token.onCancellationRequested(() => {
                    (0, util_1.disposeAll)(disposables);
                    resolve(undefined);
                }, null, disposables);
            }
            events.forEach(ev => {
                this.on(ev, (...args) => {
                    (0, util_1.disposeAll)(disposables);
                    resolve({ name: ev, args });
                }, null, disposables);
            });
        });
    }
    async fire(event, args) {
        var _a;
        if (event === EventName.Ready) {
            this._ready = true;
        }
        else if (event == EventName.InsertEnter) {
            this._insertMode = true;
        }
        else if (event == EventName.InsertLeave) {
            this._last_pum_insert = undefined;
            this._insertMode = false;
            this._pumVisible = false;
            this._recentInserts = [];
        }
        else if (event == EventName.CursorHoldI || event == EventName.CursorMovedI) {
            this._bufnr = args[0];
            if (!this._insertMode) {
                this._insertMode = true;
                void this.fire(EventName.InsertEnter, [args[0]]);
            }
        }
        else if (event == EventName.CursorHold || event == EventName.CursorMoved) {
            this._bufnr = args[0];
            if (this._insertMode) {
                this._insertMode = false;
                void this.fire(EventName.InsertLeave, [args[0]]);
            }
        }
        else if (event == EventName.MenuPopupChanged) {
            this._pumVisible = true;
            this._pumAlignTop = args[1] > args[0].row;
        }
        else if (event == EventName.InsertCharPre) {
            this._recentInserts.push([args[1], args[0]]);
        }
        else if (event == EventName.TextChanged) {
            this._lastChange = Date.now();
        }
        else if (event == EventName.BufEnter) {
            this._bufnr = args[0];
        }
        else if (event == EventName.TextChangedI || event == EventName.TextChangedP) {
            let info = args[1];
            let pre = (0, string_1.byteSlice)((_a = info.line) !== null && _a !== void 0 ? _a : '', 0, info.col - 1);
            let arr;
            // use TextChangedP and disable insert
            if (this._last_pum_insert != null && this._last_pum_insert == pre) {
                arr = [];
                event = EventName.TextChangedP;
            }
            else {
                arr = this._recentInserts.filter(o => o[0] == args[0]);
            }
            this._last_pum_insert = undefined;
            this._bufnr = args[0];
            this._recentInserts = [];
            this._lastChange = Date.now();
            info.pre = pre;
            // fix cursor since vim not send CursorMovedI event
            this._cursor = Object.freeze({
                bufnr: args[0],
                lnum: info.lnum,
                col: info.col,
                insert: true
            });
            if (arr.length && pre.length) {
                let character = pre.slice(-1);
                if (arr.findIndex(o => o[1] == character) !== -1) {
                    info.insertChar = character;
                    // make it fires after TextChangedI & TextChangedP
                    process.nextTick(() => {
                        void this.fire(EventName.TextInsert, [...args, character]);
                    });
                }
            }
        }
        else if (event == EventName.PumInsert) {
            this._last_pum_insert = args[0];
            return;
        }
        if (event == EventName.CursorMoved || event == EventName.CursorMovedI) {
            args.push(this._recentInserts.length > 0);
            let cursor = {
                bufnr: args[0],
                lnum: args[1][0],
                col: args[1][1],
                insert: event == EventName.CursorMovedI
            };
            if (this._last_pum_insert && (0, string_1.byteLength)(this._last_pum_insert) + 1 == cursor.col)
                return;
            // Avoid CursorMoved event when it's not moved at all
            if ((this._cursor && (0, object_1.equals)(this._cursor, cursor)))
                return;
            this._cursor = cursor;
        }
        let cbs = this.handlers.get(event);
        if (cbs === null || cbs === void 0 ? void 0 : cbs.length) {
            let fns = cbs.slice();
            let traceSlow = SYNC_AUTOCMDS.includes(event);
            await Promise.allSettled(fns.map(fn => {
                let promiseFn = async () => {
                    let timer;
                    if (traceSlow) {
                        timer = setTimeout(() => {
                            console.error(`Slow "${event}" handler detected`, fn['stack']);
                            logger.error(`Slow "${event}" handler detected`, fn['stack']);
                        }, this.timeout);
                    }
                    try {
                        await fn(args);
                    }
                    catch (e) {
                        let res = shouldIgnore(e);
                        if (!res)
                            logger.error(`Error on event: ${event}`, e);
                    }
                    clearTimeout(timer);
                };
                return promiseFn();
            }));
        }
    }
    on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
            let arr = disposables || [];
            for (let ev of event) {
                this.on(ev, handler, thisArg, arr);
            }
            return protocol_1.Disposable.create(() => {
                (0, util_1.disposeAll)(arr);
            });
        }
        else {
            let arr = this.handlers.get(event) || [];
            let wrappedhandler = args => new Promise((resolve, reject) => {
                try {
                    Promise.resolve(handler.apply(thisArg !== null && thisArg !== void 0 ? thisArg : null, args)).then(() => {
                        resolve(undefined);
                    }, e => {
                        reject(e);
                    });
                }
                catch (e) {
                    reject(e);
                }
            });
            Error.captureStackTrace(wrappedhandler);
            arr.push(wrappedhandler);
            this.handlers.set(event, arr);
            let disposable = protocol_1.Disposable.create(() => {
                let idx = arr.indexOf(wrappedhandler);
                if (idx !== -1) {
                    arr.splice(idx, 1);
                }
            });
            if (Array.isArray(disposables)) {
                disposables.push(disposable);
            }
            return disposable;
        }
    }
}
function shouldIgnore(err) {
    if (err instanceof errors_1.CancellationError || (err instanceof Error && err.message.includes('transport disconnected')))
        return true;
    return false;
}
exports.default = new Events();
//# sourceMappingURL=events.js.map