"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationModelParser = void 0;
const jsonc_parser_1 = require("jsonc-parser");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger_1 = require("../logger");
const model_1 = require("./model");
const util_1 = require("./util");
const logger = (0, logger_1.createLogger)('parser');
class ConfigurationModelParser {
    constructor(_name) {
        this._name = _name;
        this._raw = null;
        this._configurationModel = null;
        this._parseErrors = [];
    }
    get configurationModel() {
        return this._configurationModel || new model_1.ConfigurationModel();
    }
    get errors() {
        return this._parseErrors;
    }
    parse(content, options) {
        if (content != null) {
            const raw = this.doParseContent(content);
            this.parseRaw(raw, options);
        }
    }
    parseRaw(raw, options) {
        this._raw = raw;
        const { contents, keys, overrides } = this.doParseRaw(raw, options);
        this._configurationModel = new model_1.ConfigurationModel(contents, keys, overrides);
        // this._restrictedConfigurations = restricted || []
    }
    doParseContent(content) {
        var _a;
        let raw = {};
        let currentProperty = null;
        let currentParent = [];
        const previousParents = [];
        const _errors = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                (currentParent).push(value);
            }
            else if (currentProperty !== null) {
                currentParent[currentProperty] = value;
            }
        }
        const visitor = {
            onObjectBegin: () => {
                const object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: (name) => {
                currentProperty = name;
            },
            onObjectEnd: () => {
                currentParent = previousParents.pop();
            },
            onArrayBegin: () => {
                const array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: () => {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: (error, offset, length) => {
                _errors.push({ error, length, offset });
            }
        };
        if (content) {
            try {
                (0, jsonc_parser_1.visit)(content, visitor, { allowTrailingComma: true, allowEmptyContent: true });
                raw = (_a = currentParent[0]) !== null && _a !== void 0 ? _a : {};
                if (_errors.length > 0) {
                    this._parseErrors = (0, util_1.convertErrors)(content, _errors);
                }
            }
            catch (e) {
                this._parseErrors = [{
                        range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                        message: `Error on parse configuration file ${this._name}: ${e}`
                    }];
            }
        }
        return raw;
    }
    doParseRaw(raw, _options) {
        const onError = (message) => {
            console.error(`Conflict in settings file ${this._name}: ${message}`);
        };
        const contents = (0, util_1.toValuesTree)(raw, onError, true);
        const keys = Object.keys(raw);
        const overrides = this.toOverrides(raw, onError);
        return { contents, keys, overrides, restricted: [] };
    }
    toOverrides(raw, conflictReporter) {
        const overrides = [];
        for (const key of Object.keys(raw)) {
            if (util_1.OVERRIDE_PROPERTY_REGEX.test(key)) {
                const overrideRaw = {};
                for (const keyInOverrideRaw in raw[key]) {
                    overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                }
                overrides.push({
                    identifiers: (0, util_1.overrideIdentifiersFromKey)(key),
                    keys: Object.keys(overrideRaw),
                    contents: (0, util_1.toValuesTree)(overrideRaw, conflictReporter, true)
                });
            }
        }
        return overrides;
    }
}
exports.ConfigurationModelParser = ConfigurationModelParser;
//# sourceMappingURL=parser.js.map