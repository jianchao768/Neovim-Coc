"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const services_1 = tslib_1.__importDefault(require("../../services"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
const vscode_uri_1 = require("vscode-uri");
let nvim;
let locations;
let disposables = [];
let currLocations;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    Object.assign(workspace_1.default.env, {
        locationlist: false
    });
    locations = helper_1.default.plugin.getHandler().locations;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    await helper_1.default.createDocument();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
function createLocation(name, sl, sc, el, ec) {
    return vscode_languageserver_protocol_1.Location.create(`test://${name}`, vscode_languageserver_protocol_1.Range.create(sl, sc, el, ec));
}
function createLocationLink(name, sl, sc, el, ec) {
    let r = vscode_languageserver_protocol_1.Range.create(sl, sc, el, ec);
    return vscode_languageserver_protocol_1.LocationLink.create(`test://${name}`, r, r);
}
describe('locations', () => {
    describe('no provider', () => {
        it('should return null when provider does not exist', async () => {
            let doc = (await workspace_1.default.document).textDocument;
            let pos = vscode_languageserver_protocol_1.Position.create(0, 0);
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let token = tokenSource.token;
            expect(await languages_1.default.getDefinition(doc, pos, token)).toEqual([]);
            expect(await languages_1.default.getDefinitionLinks(doc, pos, token)).toEqual([]);
            expect(await languages_1.default.getDeclaration(doc, pos, token)).toEqual([]);
            expect(await languages_1.default.getTypeDefinition(doc, pos, token)).toEqual([]);
            expect(await languages_1.default.getImplementation(doc, pos, token)).toEqual([]);
            expect(await languages_1.default.getReferences(doc, { includeDeclaration: false }, pos, token)).toEqual([]);
        });
    });
    describe('reference', () => {
        beforeEach(() => {
            disposables.push(languages_1.default.registerReferencesProvider([{ language: '*' }], {
                provideReferences: () => {
                    return currLocations;
                }
            }));
        });
        it('should get references', async () => {
            currLocations = [createLocationLink('foo', 0, 0, 0, 0), createLocationLink('bar', 0, 0, 0, 0)];
            let res = await helper_1.default.doAction('references');
            expect(res.length).toBe(2);
        });
        it('should jump to references', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0)];
            let res = await helper_1.default.doAction('jumpReferences', 'edit');
            expect(res).toBe(true);
            let name = await nvim.call('bufname', ['%']);
            expect(name).toBe('test://foo');
        });
        it('should return false when references not found', async () => {
            currLocations = [];
            let res = await locations.gotoReferences('edit', true);
            expect(res).toBe(false);
            res = await helper_1.default.doAction('jumpUsed', 'edit');
            expect(res).toBe(false);
        });
    });
    describe('definition', () => {
        beforeEach(() => {
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return currLocations;
                }
            }));
        });
        it('should get definitions', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)];
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return [createLocation('foo', 0, 0, 0, 0)];
                }
            }));
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return createLocation('foo', 0, 0, 0, 0);
                }
            }));
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return [vscode_languageserver_protocol_1.LocationLink.create(`test://foo`, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0)), null];
                }
            }));
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return [vscode_languageserver_protocol_1.LocationLink.create(`test://foo`, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0))];
                }
            }));
            let res = await helper_1.default.doAction('definitions');
            expect(res.length).toBe(2);
        });
        it('should return empty locations when no definitions exist', async () => {
            currLocations = null;
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.getDefinitionLinks(doc.textDocument, vscode_languageserver_protocol_1.Position.create(0, 0), vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(0);
            currLocations = [createLocation('foo', 0, 0, 0, 0)];
            res = await languages_1.default.getDefinitionLinks(doc.textDocument, vscode_languageserver_protocol_1.Position.create(0, 0), vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(0);
        });
        it('should jump to definitions', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0)];
            let res = await helper_1.default.doAction('jumpDefinition', 'edit');
            expect(res).toBe(true);
            let name = await nvim.call('bufname', ['%']);
            expect(name).toBe('test://foo');
        });
        it('should return false when definitions not found', async () => {
            currLocations = [];
            let res = await locations.gotoDefinition('edit');
            expect(res).toBe(false);
        });
    });
    describe('declaration', () => {
        beforeEach(() => {
            disposables.push(languages_1.default.registerDeclarationProvider([{ language: '*' }], {
                provideDeclaration: () => {
                    return currLocations;
                }
            }));
        });
        it('should get declarations', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)];
            let res = await locations.declarations();
            expect(res.length).toBe(2);
        });
        it('should jump to declaration', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0)];
            let res = await locations.gotoDeclaration('edit');
            expect(res).toBe(true);
            let name = await nvim.call('bufname', ['%']);
            expect(name).toBe('test://foo');
        });
        it('should return false when declaration not found', async () => {
            currLocations = [];
            let res = await helper_1.default.doAction('jumpDeclaration', 'edit');
            expect(res).toBe(false);
        });
    });
    describe('typeDefinition', () => {
        beforeEach(() => {
            disposables.push(languages_1.default.registerTypeDefinitionProvider([{ language: '*' }], {
                provideTypeDefinition: () => {
                    return currLocations;
                }
            }));
        });
        it('should get type definition', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)];
            let res = await helper_1.default.doAction('typeDefinitions');
            expect(res.length).toBe(2);
        });
        it('should jump to type definition', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0)];
            let res = await locations.gotoTypeDefinition('edit');
            expect(res).toBe(true);
            let name = await nvim.call('bufname', ['%']);
            expect(name).toBe('test://foo');
        });
        it('should return false when type definition not found', async () => {
            currLocations = [];
            let res = await helper_1.default.doAction('jumpTypeDefinition', 'edit');
            expect(res).toBe(false);
        });
    });
    describe('implementation', () => {
        beforeEach(() => {
            disposables.push(languages_1.default.registerImplementationProvider([{ language: '*' }], {
                provideImplementation: () => {
                    return currLocations;
                }
            }));
        });
        it('should get implementations', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)];
            let res = await helper_1.default.doAction('implementations');
            expect(res.length).toBe(2);
        });
        it('should jump to implementation', async () => {
            currLocations = [createLocation('foo', 0, 0, 0, 0)];
            let res = await helper_1.default.doAction('jumpImplementation', 'edit');
            expect(res).toBe(true);
            let name = await nvim.call('bufname', ['%']);
            expect(name).toBe('test://foo');
        });
        it('should return false when implementation not found', async () => {
            currLocations = [];
            let res = await locations.gotoImplementation('edit');
            expect(res).toBe(false);
        });
    });
    describe('getTagList', () => {
        it('should return null when cword does not exist', async () => {
            let res = await helper_1.default.doAction('getTagList');
            expect(res).toBe(null);
        });
        it('should return null when provider does not exist', async () => {
            await nvim.setLine('foo');
            await nvim.command('normal! ^');
            let res = await locations.getTagList();
            expect(res).toBe(null);
        });
        it('should return null when result is empty', async () => {
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return [];
                }
            }));
            await nvim.setLine('foo');
            await nvim.command('normal! ^');
            let res = await locations.getTagList();
            expect(res).toBe(null);
        });
        it('should return tag definitions', async () => {
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition: () => {
                    return [createLocation('bar', 2, 0, 2, 5), vscode_languageserver_protocol_1.Location.create(vscode_uri_1.URI.file('/foo').toString(), vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5))];
                }
            }));
            await nvim.setLine('foo');
            await nvim.command('normal! ^');
            let res = await locations.getTagList();
            expect(res).toEqual([
                {
                    name: 'foo',
                    cmd: 'silent keepjumps 3 | normal 1|',
                    filename: 'test://bar'
                },
                { name: 'foo', cmd: 'silent keepjumps 2 | normal 1|', filename: '/foo' }
            ]);
        });
    });
    describe('findLocations', () => {
        // hook result
        let fn;
        let result;
        beforeAll(() => {
            fn = services_1.default.sendRequest;
            services_1.default.sendRequest = () => {
                return Promise.resolve(result);
            };
        });
        afterAll(() => {
            services_1.default.sendRequest = fn;
        });
        it('should handle locations from language client', async () => {
            result = [createLocation('bar', 2, 0, 2, 5)];
            await helper_1.default.doAction('findLocations', 'foo', 'mylocation', {}, false);
            let res = await nvim.getVar('coc_jump_locations');
            expect(res).toEqual([{
                    uri: 'test://bar',
                    lnum: 3,
                    end_lnum: 3,
                    col: 1,
                    end_col: 6,
                    filename: 'test://bar',
                    text: '',
                    range: vscode_languageserver_protocol_1.Range.create(2, 0, 2, 5)
                }]);
        });
        it('should handle empty result', async () => {
            result = null;
            let res = await locations.findLocations('foo', 'mylocation', undefined, false);
            expect(res).toBe(false);
        });
        it('should handle nested locations', async () => {
            let location = {
                location: createLocation('file', 0, 0, 0, 0),
                children: [{
                        location: createLocation('foo', 3, 0, 3, 5),
                        children: []
                    }, {
                        location: createLocation('bar', 4, 0, 4, 5),
                        children: []
                    }]
            };
            result = location;
            await locations.findLocations('foo', 'mylocation', {}, false);
            let res = await nvim.getVar('coc_jump_locations');
            expect(res.length).toBe(3);
        });
    });
    describe('toLocations()', () => {
        it('should convert to locations', async () => {
            let loc = createLocation('file', 0, 0, 0, 0);
            expect(locations.toLocations(loc).length).toBe(1);
            expect(locations.toLocations([loc]).length).toBe(1);
            let link = vscode_languageserver_protocol_1.LocationLink.create(`test://a`, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0), vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
            expect(locations.toLocations(link).length).toBe(1);
            expect(locations.toLocations([link]).length).toBe(1);
            expect(locations.toLocations(null).length).toBe(0);
            expect(locations.toLocations(undefined).length).toBe(0);
            let location = {
                location: createLocation('file', 0, 0, 0, 0),
                children: [{
                        location: link,
                        children: [{
                                location: loc
                            }, null, undefined, {}]
                    }]
            };
            expect(locations.toLocations(location).length).toBe(3);
        });
    });
    describe('handleLocations', () => {
        it('should not throw when locations is undefined', async () => {
            await locations.handleLocations(undefined);
        });
        it('should not throw when locations is empty array', async () => {
            await locations.handleLocations([]);
        });
    });
});
//# sourceMappingURL=locations.test.js.map