'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidWatchRoot = void 0;
const uuid_1 = require("uuid");
const logger_1 = require("../logger");
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const logger = (0, logger_1.createLogger)('core-watchman');
const requiredCapabilities = ['relative_root', 'cmd-watch-project', 'wildmatch', 'field-new'];
/**
 * Watchman wrapper for fb-watchman client
 *
 * @public
 */
class Watchman {
    constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        const watchman = require('fb-watchman');
        this.client = new watchman.Client({
            watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
    }
    checkCapability() {
        let { client } = this;
        return new Promise((resolve, reject) => {
            client.capabilityCheck({
                optional: [],
                required: requiredCapabilities
            }, (error, resp) => {
                if (error)
                    return resolve(false);
                let { capabilities } = resp;
                for (let key of Object.keys(capabilities)) {
                    if (!capabilities[key])
                        return resolve(false);
                }
                resolve(true);
            });
        });
    }
    async watchProject(root) {
        let resp = await this.command(['watch-project', root]);
        let { watch, warning, relative_path } = resp;
        if (!watch)
            return false;
        if (warning)
            logger.warn(warning);
        this.watch = watch;
        this.relative_path = relative_path;
        logger.info(`watchman watching project: ${root}`);
        this.appendOutput(`watchman watching project: ${root}`);
        return true;
    }
    command(args) {
        return new Promise((resolve, reject) => {
            this.client.command(args, (error, resp) => {
                if (error)
                    return reject(error);
                resolve(resp);
            });
        });
    }
    async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch)
            throw new Error('watchman not watching');
        let { clock } = await this.command(['clock', watch]);
        let uid = (0, uuid_1.v1)();
        let sub = {
            expression: ['allof', ['match', '**/*', 'wholename']],
            fields: ['name', 'size', 'new', 'exists', 'type', 'mtime_ms', 'ctime_ms'],
            since: clock,
        };
        let root = watch;
        if (relative_path) {
            sub.relative_root = relative_path;
            root = node_1.path.join(watch, relative_path);
        }
        if (!this.client)
            return;
        let { subscribe } = await this.command(['subscribe', watch, uid, sub]);
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on('subscription', resp => {
            if (!resp || resp.subscription != uid)
                return;
            let { files } = resp;
            if (!files)
                return;
            files = files.filter(f => f.type == 'f' && (0, node_1.minimatch)(f.name, globPattern, { dot: true }));
            if (!files.length)
                return;
            let ev = Object.assign({}, resp);
            if (this.relative_path)
                ev.root = node_1.path.resolve(resp.root, this.relative_path);
            this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
            cb(ev);
        });
        // return Disposable.create(() => )
        return {
            dispose: () => {
                void this.unsubscribe(subscribe);
            },
            subscribe
        };
    }
    unsubscribe(subscription) {
        if (this._disposed)
            return Promise.resolve();
        let { watch } = this;
        if (!watch)
            return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(['unsubscribe', watch, subscription]).catch(e => {
            var _a;
            if ((_a = e.message) === null || _a === void 0 ? void 0 : _a.includes('The client was ended'))
                logger.error(e);
        });
    }
    dispose() {
        if (this._disposed)
            return;
        this._disposed = true;
        if (this.client) {
            this.client.end();
            this.client = undefined;
        }
    }
    appendOutput(message, type = "Info") {
        if (this.channel) {
            this.channel.appendLine(`[${type}  - ${(new Date().toLocaleTimeString())}] ${message}`);
        }
    }
    static async createClient(binaryPath, root, channel) {
        if (!isValidWatchRoot(root))
            throw new Error(`Watch for ${root} is ignored`);
        let watchman;
        try {
            watchman = new Watchman(binaryPath, channel);
            let valid = await watchman.checkCapability();
            if (!valid)
                throw new Error('required capabilities do not exist.');
            let watching = await watchman.watchProject(root);
            if (!watching)
                throw new Error('unable to watch');
            return watchman;
        }
        catch (e) {
            if (watchman)
                watchman.dispose();
            throw e;
        }
    }
}
exports.default = Watchman;
/**
 * Exclude user's home, driver, tmpdir
 */
function isValidWatchRoot(root) {
    if (root == '/' || root == '/tmp' || root == '/private/tmp')
        return false;
    if ((0, fs_1.isParentFolder)(root, node_1.os.homedir(), true))
        return false;
    if (node_1.path.parse(root).base == root)
        return false;
    if (root.startsWith('/tmp/') || root.startsWith('/private/tmp/'))
        return false;
    if ((0, fs_1.isParentFolder)(node_1.os.tmpdir(), root, true))
        return false;
    return true;
}
exports.isValidWatchRoot = isValidWatchRoot;
//# sourceMappingURL=watchman.js.map