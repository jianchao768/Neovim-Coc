"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const search_1 = tslib_1.__importStar(require("../../handler/refactor/search"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const path_1 = tslib_1.__importDefault(require("path"));
let nvim;
let refactor;
// use fake rg command
let cmd = path_1.default.resolve(__dirname, '../rg');
let cwd = process.cwd();
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    refactor = helper_1.default.plugin.getHandler().refactor;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    refactor.reset();
    await helper_1.default.reset();
});
describe('getPathFromArgs', () => {
    it('should get undefined path', async () => {
        let res = (0, search_1.getPathFromArgs)(['a']);
        expect(res).toBeUndefined();
        res = (0, search_1.getPathFromArgs)(['a', 'b', '-c']);
        expect(res).toBeUndefined();
        res = (0, search_1.getPathFromArgs)(['a', '-b', 'c']);
        expect(res).toBeUndefined();
    });
});
describe('search', () => {
    it('should open refactor window', async () => {
        let search = new search_1.default(nvim, cmd);
        let buf = await refactor.createRefactorBuffer();
        await search.run([], cwd, buf);
        await helper_1.default.wait(50);
        let fileItems = buf.fileItems;
        expect(fileItems.length).toBe(2);
        expect(fileItems[0].ranges.length).toBe(2);
    });
    it('should abort task', async () => {
        let search = new search_1.default(nvim, cmd);
        let buf = await refactor.createRefactorBuffer();
        let p = search.run(['--sleep', '1000'], cwd, buf);
        search.abort();
        await p;
        let fileItems = buf.fileItems;
        expect(fileItems.length).toBe(0);
    });
    it('should work with CocAction search', async () => {
        await helper_1.default.doAction('search', ['CocAction']);
        let bufnr = await nvim.call('bufnr', ['%']);
        let buf = refactor.getBuffer(bufnr);
        expect(buf).toBeDefined();
    });
    it('should fail on invalid command', async () => {
        let search = new search_1.default(nvim, 'rrg');
        let buf = await refactor.createRefactorBuffer();
        let err;
        try {
            await search.run([], cwd, buf);
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
        let msg = await helper_1.default.getCmdline();
        expect(msg).toMatch(/Error on command "rrg"/);
    });
    it('should show empty result when no result found', async () => {
        await helper_1.default.doAction('search', ['should found ' + ' no result']);
        let bufnr = await nvim.call('bufnr', ['%']);
        let buf = refactor.getBuffer(bufnr);
        expect(buf).toBeDefined();
        let buffer = await nvim.buffer;
        let lines = await buffer.lines;
        expect(lines[1]).toMatch(/No match found/);
    });
    it('should use current search folder for rg', async () => {
        let search = new search_1.default(nvim, 'rg');
        await helper_1.default.createDocument();
        let buf = await refactor.createRefactorBuffer();
        await search.run(['-w', 'createRefactorBuffer', 'src/__tests__'], cwd, buf);
        let buffer = await nvim.buffer;
        let lines = await buffer.lines;
        expect(lines[1].startsWith('Files: ')).toBe(true);
    });
});
//# sourceMappingURL=search.test.js.map