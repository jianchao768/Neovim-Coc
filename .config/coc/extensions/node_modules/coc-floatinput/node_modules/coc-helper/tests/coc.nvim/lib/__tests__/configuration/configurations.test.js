"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_uri_1 = require("vscode-uri");
const configuration_1 = tslib_1.__importStar(require("../../configuration"));
const model_1 = require("../../configuration/model");
const shape_1 = tslib_1.__importDefault(require("../../configuration/shape"));
const configuration_2 = require("../../configuration/configuration");
const types_1 = require("../../configuration/types");
const util_1 = require("../../util");
const fs_2 = require("../../util/fs");
const helper_1 = tslib_1.__importDefault(require("../helper"));
const registry_1 = require("../../configuration/registry");
const constants_1 = require("../../util/constants");
const workspaceConfigFile = path_1.default.resolve(__dirname, `../sample/.vim/${constants_1.CONFIG_FILE_NAME}`);
function U(fsPath) {
    return vscode_uri_1.URI.file(fsPath).toString();
}
function createConfigurations() {
    let userConfigFile = path_1.default.join(__dirname, './settings.json');
    return new configuration_1.default(userConfigFile);
}
const disposables = [];
afterEach(() => {
    (0, util_1.disposeAll)(disposables);
});
function generateTmpDir() {
    return path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v1)());
}
describe('FolderConfigutions', () => {
    it('should getConfigurationByResource', async () => {
        let c = new configuration_2.FolderConfigutions();
        expect(c.getConfigurationByResource('')).toBeUndefined();
        expect(c.getConfigurationByResource('file:///a')).toBeUndefined();
        let model = new model_1.ConfigurationModel();
        c.set(os_1.default.tmpdir(), model);
        let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 'a/foo.js')).toString();
        let res = c.getConfigurationByResource(uri);
        expect(res.model).toBe(model);
    });
});
describe('Configurations', () => {
    describe('markdownPreference', () => {
        it('should get markdown preferences', async () => {
            let configurations = createConfigurations();
            let preferences = configurations.markdownPreference;
            expect(preferences).toEqual({
                excludeImages: true,
                breaks: true
            });
        });
    });
    describe('ConfigurationProxy', () => {
        it('should create file and parent folder when necessary', async () => {
            let folder = generateTmpDir();
            let uri = vscode_uri_1.URI.file(path_1.default.join(folder, 'a/b/settings.json'));
            let proxy = new shape_1.default({}, false);
            await proxy.modifyConfiguration(uri.fsPath, 'foo', true);
            let content = fs_1.default.readFileSync(uri.fsPath, 'utf8');
            expect(JSON.parse(content)).toEqual({ foo: true });
            await proxy.modifyConfiguration(uri.fsPath, 'foo', false);
            content = fs_1.default.readFileSync(uri.fsPath, 'utf8');
            expect(JSON.parse(content)).toEqual({ foo: false });
            await (0, fs_2.remove)(folder);
        });
        it('should get folder from resolver', async () => {
            let proxy = new shape_1.default({
                getWorkspaceFolder: (uri) => {
                    let fsPath = vscode_uri_1.URI.parse(uri).fsPath;
                    if (fsPath.startsWith(os_1.default.tmpdir())) {
                        return { uri: vscode_uri_1.URI.file(os_1.default.tmpdir()).toString(), name: 'tmp' };
                    }
                    if (fsPath.startsWith(os_1.default.homedir())) {
                        return { uri: vscode_uri_1.URI.file(os_1.default.homedir()).toString(), name: 'home' };
                    }
                    return undefined;
                },
                root: __dirname
            });
            let uri = proxy.getWorkspaceFolder(vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 'foo')).toString());
            expect(uri.fsPath.startsWith(os_1.default.tmpdir())).toBe(true);
            uri = proxy.getWorkspaceFolder(vscode_uri_1.URI.file('abc').toString());
            expect(uri).toBeUndefined();
            proxy = new shape_1.default({});
            uri = proxy.getWorkspaceFolder(vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 'foo')).toString());
            expect(uri).toBeUndefined();
        });
    });
    describe('watchFile', () => {
        it('should watch user config file', async () => {
            let userConfigFile = path_1.default.join(os_1.default.tmpdir(), `settings-${(0, uuid_1.v1)()}.json`);
            fs_1.default.writeFileSync(userConfigFile, '{"foo.bar": true}', { encoding: 'utf8' });
            let conf = new configuration_1.default(userConfigFile, undefined, false);
            disposables.push(conf);
            expect(conf.getDefaultResource()).toBe(undefined);
            await (0, util_1.wait)(50);
            fs_1.default.writeFileSync(userConfigFile, '{"foo.bar": false}', { encoding: 'utf8' });
            await helper_1.default.waitValue(() => {
                let c = conf.getConfiguration('foo');
                return c.get('bar');
            }, false);
            fs_1.default.rmSync(userConfigFile, { recursive: true });
        });
        it('should watch folder config file', async () => {
            let dir = generateTmpDir();
            let configFile = path_1.default.join(dir, '.vim/coc-settings.json');
            fs_1.default.mkdirSync(path_1.default.dirname(configFile), { recursive: true });
            fs_1.default.writeFileSync(configFile, '{"foo.bar": true}', { encoding: 'utf8' });
            let conf = new configuration_1.default('', {
                get root() {
                    return dir;
                },
                modifyConfiguration: async () => { },
                getWorkspaceFolder: () => {
                    return vscode_uri_1.URI.file(dir);
                }
            }, false);
            expect(conf.getDefaultResource()).toMatch('file:');
            disposables.push(conf);
            let uri = U(dir);
            let resolved = conf.locateFolderConfigution(uri);
            expect(resolved).toBeDefined();
            await (0, util_1.wait)(20);
            fs_1.default.writeFileSync(configFile, '{"foo.bar": false}', { encoding: 'utf8' });
            await helper_1.default.waitValue(() => {
                let c = conf.getConfiguration('foo');
                return c.get('bar');
            }, false);
        });
    });
    describe('getJSONSchema()', () => {
        it('should getJSONSchema', () => {
            let userConfigFile = path_1.default.join(__dirname, '.vim/coc-settings.json');
            let conf = new configuration_1.default(userConfigFile, undefined);
            expect(conf.getJSONSchema(configuration_1.userSettingsSchemaId)).toBeDefined();
            expect(conf.getJSONSchema(configuration_1.folderSettingsSchemaId)).toBeDefined();
            expect(conf.getJSONSchema(registry_1.resourceLanguageSettingsSchemaId)).toBeDefined();
            expect(conf.getJSONSchema('vscode://not_exists')).toBeUndefined();
        });
    });
    describe('getDescription()', () => {
        it('should get description', () => {
            let userConfigFile = path_1.default.join(__dirname, '.vim/coc-settings.json');
            let conf = new configuration_1.default(userConfigFile, undefined);
            expect(conf.getDescription('not_exists_key')).toBeUndefined();
        });
    });
    describe('addFolderFile()', () => {
        it('should not add invalid folder from cwd', async () => {
            let userConfigFile = path_1.default.join(__dirname, '.vim/coc-settings.json');
            let conf = new configuration_1.default(userConfigFile, undefined, true, os_1.default.homedir());
            let res = conf.folderToConfigfile(os_1.default.homedir());
            expect(res).toBeUndefined();
            res = conf.folderToConfigfile(__dirname);
            expect(res).toBeUndefined();
        });
        it('should add folder as workspace configuration', () => {
            let configurations = createConfigurations();
            disposables.push(configurations);
            let fired = false;
            configurations.onDidChange(() => {
                fired = true;
            });
            configurations.addFolderFile(workspaceConfigFile);
            let resource = vscode_uri_1.URI.file(path_1.default.resolve(workspaceConfigFile, '../../tmp'));
            let c = configurations.getConfiguration('coc.preferences', resource);
            let res = c.inspect('rootPath');
            expect(res.key).toBe('coc.preferences.rootPath');
            expect(res.workspaceFolderValue).toBe('./src');
            expect(c.get('rootPath')).toBe('./src');
            expect(fired).toBe(false);
        });
        it('should not add invalid folders', async () => {
            let configurations = createConfigurations();
            expect(configurations.addFolderFile('ab')).toBe(false);
        });
        it('should resolve folder configuration when possible', async () => {
            let configurations = createConfigurations();
            expect(configurations.locateFolderConfigution('test:///foo')).toBe(false);
            let fsPath = path_1.default.join(__dirname, `../sample/abc`);
            expect(configurations.locateFolderConfigution(vscode_uri_1.URI.file(fsPath).toString())).toBe(true);
            fsPath = path_1.default.join(__dirname, `../sample/foo`);
            expect(configurations.locateFolderConfigution(vscode_uri_1.URI.file(fsPath).toString())).toBe(true);
        });
    });
    describe('getConfiguration()', () => {
        it('should load default configurations', () => {
            let conf = new configuration_1.default(undefined, {
                modifyConfiguration: async () => { }
            });
            disposables.push(conf);
            expect(conf.configuration.defaults.contents.coc).toBeDefined();
            let c = conf.getConfiguration('languageserver');
            expect(c).toEqual({});
            expect(c.has('not_exists')).toBe(false);
        });
        it('should load configuration without folder configuration', async () => {
            let conf = new configuration_1.default(undefined, {
                root: path_1.default.join(path_1.default.dirname(__dirname), 'sample'),
                modifyConfiguration: async () => { }
            });
            disposables.push(conf);
            conf.addFolderFile(workspaceConfigFile);
            let c = conf.getConfiguration('coc.preferences');
            expect(c.rootPath).toBeDefined();
            c = conf.getConfiguration('coc.preferences', null);
            expect(c.rootPath).toBeUndefined();
        });
        it('should inspect configuration', async () => {
            let conf = new configuration_1.default();
            let c = conf.getConfiguration('suggest');
            let res = c.inspect('not_exists');
            expect(res.defaultValue).toBeUndefined();
            expect(res.globalValue).toBeUndefined();
            expect(res.workspaceValue).toBeUndefined();
            c = conf.getConfiguration();
            res = c.inspect('not_exists');
            expect(res.key).toBe('not_exists');
        });
        it('should update memory config #1', () => {
            let conf = new configuration_1.default();
            let fn = jest.fn();
            conf.onDidChange(e => {
                expect(e.affectsConfiguration('x')).toBe(true);
                fn();
            });
            conf.updateMemoryConfig({ x: 1 });
            let config = conf.configuration.memory;
            expect(config.contents).toEqual({ x: 1 });
            expect(fn).toBeCalled();
            expect(conf.configuration.workspace).toBeDefined();
        });
        it('should update memory config #2', () => {
            let conf = new configuration_1.default();
            conf.updateMemoryConfig({ x: 1 });
            conf.updateMemoryConfig({ x: undefined });
            let config = conf.configuration.user;
            expect(config.contents).toEqual({});
        });
        it('should update memory config #3', () => {
            let conf = new configuration_1.default();
            conf.updateMemoryConfig({ 'suggest.floatConfig': { border: true } });
            conf.updateMemoryConfig({ 'x.y': { foo: 1 } });
            let val = conf.getConfiguration();
            let res = val.get('suggest');
            expect(res.floatConfig).toEqual({ border: true });
            res = val.get('x.y');
            expect(res).toEqual({ foo: 1 });
        });
        it('should handle errors', () => {
            let tmpFile = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v1)());
            fs_1.default.writeFileSync(tmpFile, '{"x":', 'utf8');
            let conf = new configuration_1.default(tmpFile);
            disposables.push(conf);
            let errors = conf.errors;
            expect(errors.size).toBeGreaterThan(0);
        });
        it('should get nested property', () => {
            let config = createConfigurations();
            disposables.push(config);
            let conf = config.getConfiguration('servers.c');
            let res = conf.get('trace.server', '');
            expect(res).toBe('verbose');
        });
        it('should get user and workspace configuration', () => {
            let userConfigFile = path_1.default.join(__dirname, './settings.json');
            let configurations = new configuration_1.default(userConfigFile);
            disposables.push(configurations);
            let data = configurations.configuration.toData();
            expect(data.user).toBeDefined();
            expect(data.workspace).toBeDefined();
            expect(data.defaults).toBeDefined();
            let value = configurations.configuration.getValue(undefined, {});
            expect(value.foo).toBeDefined();
            expect(value.foo.bar).toBe(1);
        });
        it('should update configuration', async () => {
            let configurations = createConfigurations();
            disposables.push(configurations);
            configurations.addFolderFile(workspaceConfigFile);
            let resource = vscode_uri_1.URI.file(path_1.default.resolve(workspaceConfigFile, '../..'));
            let fn = jest.fn();
            configurations.onDidChange(e => {
                expect(e.affectsConfiguration('foo')).toBe(true);
                expect(e.affectsConfiguration('foo.bar')).toBe(true);
                expect(e.affectsConfiguration('foo.bar', 'file://tmp/foo.js')).toBe(false);
                fn();
            });
            let config = configurations.getConfiguration('foo', resource);
            let o = config.get('bar');
            expect(o).toBe(1);
            await config.update('bar', 6);
            config = configurations.getConfiguration('foo', resource);
            expect(config.get('bar')).toBe(6);
            expect(fn).toBeCalledTimes(1);
        });
        it('should remove configuration', async () => {
            let configurations = createConfigurations();
            disposables.push(configurations);
            configurations.addFolderFile(workspaceConfigFile);
            let resource = vscode_uri_1.URI.file(path_1.default.resolve(workspaceConfigFile, '../..'));
            let fn = jest.fn();
            configurations.onDidChange(e => {
                expect(e.affectsConfiguration('foo')).toBe(true);
                expect(e.affectsConfiguration('foo.bar')).toBe(true);
                fn();
            });
            let config = configurations.getConfiguration('foo', resource);
            let o = config.get('bar');
            expect(o).toBe(1);
            await config.update('bar', null, true);
            config = configurations.getConfiguration('foo', resource);
            expect(config.get('bar')).toBeUndefined();
            expect(fn).toBeCalledTimes(1);
        });
    });
    describe('changeConfiguration', () => {
        it('should change workspace configuration', async () => {
            let con = createConfigurations();
            let m = new model_1.ConfigurationModel({ x: { a: 1 } }, ['x.a']);
            con.changeConfiguration(types_1.ConfigurationTarget.Workspace, m, undefined);
            let res = con.getConfiguration('x');
            expect(res.a).toBe(1);
        });
        it('should change default configuration', async () => {
            let m = new model_1.ConfigurationModel({ x: { a: 1 } }, ['x.a']);
            let con = createConfigurations();
            con.changeConfiguration(types_1.ConfigurationTarget.Default, m, undefined);
            let res = con.getConfiguration('x');
            expect(res.a).toBe(1);
        });
    });
    describe('update()', () => {
        it('should update workspace configuration', async () => {
            let target = types_1.ConfigurationUpdateTarget.Workspace;
            let con = createConfigurations();
            let res = con.getConfiguration();
            await res.update('x', 3, target);
            let val = con.getConfiguration().get('x');
            expect(val).toBe(3);
        });
        it('should show error when workspace folder not resolved', async () => {
            let called = false;
            let s = jest.spyOn(console, 'error').mockImplementation(() => {
                called = true;
            });
            let con = new configuration_1.default(undefined, {
                modifyConfiguration: async () => { },
                getWorkspaceFolder: () => {
                    return undefined;
                }
            });
            let conf = con.getConfiguration(undefined, 'file:///1');
            await conf.update('x', 3, types_1.ConfigurationUpdateTarget.WorkspaceFolder);
            s.mockRestore();
            expect(called).toBe(true);
        });
    });
    describe('getWorkspaceConfigUri()', () => {
        it('should not get config uri for undefined resource', async () => {
            let conf = createConfigurations();
            let res = conf.resolveWorkspaceFolderForResource();
            expect(res).toBeUndefined();
        });
        it('should not get config folder same as home', async () => {
            let conf = new configuration_1.default(undefined, {
                modifyConfiguration: async () => { },
                getWorkspaceFolder: () => {
                    return vscode_uri_1.URI.file(os_1.default.homedir());
                }
            });
            let uri = U(__filename);
            let res = conf.resolveWorkspaceFolderForResource(uri);
            expect(res).toBeUndefined();
        });
        it('should create config file for workspace folder', async () => {
            let folder = path_1.default.join(os_1.default.tmpdir(), `test-workspace-folder-${(0, uuid_1.v1)()}`);
            let conf = new configuration_1.default(undefined, {
                modifyConfiguration: async () => { },
                getWorkspaceFolder: () => {
                    return vscode_uri_1.URI.file(folder);
                }
            });
            let res = conf.resolveWorkspaceFolderForResource('file:///1');
            expect(res).toBe(folder);
            let configFile = path_1.default.join(folder, '.vim/coc-settings.json');
            expect(fs_1.default.existsSync(configFile)).toBe(true);
            res = conf.resolveWorkspaceFolderForResource('file:///1');
            expect(res).toBe(folder);
        });
    });
});
//# sourceMappingURL=configurations.test.js.map