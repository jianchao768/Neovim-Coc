"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const net_1 = tslib_1.__importDefault(require("net"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_uri_1 = require("vscode-uri");
const language_client_1 = require("../../language-client");
const services_1 = tslib_1.__importStar(require("../../services"));
const util_1 = require("../../util");
const events_1 = tslib_1.__importDefault(require("../../events"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
let workspace;
const serverModule = path_1.default.join(__dirname, 'server.js');
beforeAll(async () => {
    await helper_1.default.setup();
    workspace = helper_1.default.workspace;
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
});
function toConfig(c) {
    if (!c.filetypes) {
        c.filetypes = ['vim'];
    }
    return c;
}
describe('services', () => {
    describe('functions', () => {
        it('should convertState', async () => {
            expect((0, services_1.convertState)(null)).toBeUndefined();
        });
        it('should check valid server config', async () => {
            expect((0, services_1.isValidServerConfig)('name', {})).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { module: [] })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { command: [] })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { transport: '' })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { transportPort: 'ab' })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { filetypes: '' })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { additionalSchemes: '' })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { additionalSchemes: [1] })).toBe(false);
            expect((0, services_1.isValidServerConfig)('name', { module: 'module', filetypes: ['vim'] })).toBe(true);
        });
        it('should get state name', async () => {
            expect((0, services_1.getStateName)(services_1.ServiceStat.Initial)).toBe('init');
            expect((0, services_1.getStateName)(services_1.ServiceStat.Running)).toBe('running');
            expect((0, services_1.getStateName)(services_1.ServiceStat.Starting)).toBe('starting');
            expect((0, services_1.getStateName)(services_1.ServiceStat.StartFailed)).toBe('startFailed');
            expect((0, services_1.getStateName)(services_1.ServiceStat.Stopping)).toBe('stopping');
            expect((0, services_1.getStateName)(services_1.ServiceStat.Stopped)).toBe('stopped');
            expect((0, services_1.getStateName)(null)).toBe('unknown');
        });
        it('should use languageserver config from workspace folder', async () => {
            let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_1.default.mkdirSync(path_1.default.join(folder, '.vim'), { recursive: true });
            let configFile = path_1.default.join(folder, '.vim/coc-settings.json');
            fs_1.default.writeFileSync(configFile, '{"languageserver": {"foo": {"command":"bar", "filetypes": ["vim"]}, "bar": {}}}');
            let uri = vscode_uri_1.URI.file(path_1.default.join(folder, 't')).toString();
            let added = workspace.configurations.locateFolderConfigution(uri);
            expect(added).toBe(true);
            let w = workspace.workspaceFolderControl;
            w.addWorkspaceFolder(folder, true);
            let s = services_1.default.getService('foo');
            expect(s).toBeDefined();
            await s.restart();
            w.removeWorkspaceFolder(folder);
        });
        it('should get stateString', async () => {
            expect((0, services_1.stateString)(language_client_1.State.Stopped)).toBe('stopped');
            expect((0, services_1.stateString)(language_client_1.State.Running)).toBe('running');
            expect((0, services_1.stateString)(language_client_1.State.Starting)).toBe('starting');
            expect((0, services_1.stateString)(null)).toBe('unknown');
        });
        it('should getSpawnOptions', async () => {
            expect((0, services_1.getSpawnOptions)(toConfig({ cwd: process.cwd() }))).toBeDefined();
            expect((0, services_1.getSpawnOptions)(toConfig({ cwd: process.cwd(), detached: true, shell: true, env: {} }))).toBeDefined();
        });
        it('should getForkOptions', async () => {
            expect((0, services_1.getForkOptions)(toConfig({ cwd: process.cwd() }))).toBeDefined();
            expect((0, services_1.getForkOptions)(toConfig({ cwd: process.cwd(), execArgv: [], env: {} }))).toBeDefined();
        });
        it('should getTransportKind', async () => {
            expect((0, services_1.getTransportKind)(toConfig({}))).toBe(language_client_1.TransportKind.ipc);
            expect((0, services_1.getTransportKind)(toConfig({ transport: 'ipc' }))).toBe(language_client_1.TransportKind.ipc);
            expect((0, services_1.getTransportKind)(toConfig({ transport: 'stdio' }))).toBe(language_client_1.TransportKind.stdio);
            expect((0, services_1.getTransportKind)(toConfig({ transport: 'pipe' }))).toBe(language_client_1.TransportKind.pipe);
            expect((0, services_1.getTransportKind)(toConfig({ transport: 'socket', transportPort: 3300 }))).toEqual({ kind: language_client_1.TransportKind.socket, port: 3300 });
        });
        it('should getDocumentSelector', async () => {
            expect((0, services_1.getDocumentSelector)(undefined, [])).toEqual([{ scheme: 'file' }, { scheme: 'untitled' }]);
            expect((0, services_1.getDocumentSelector)(['vim'], []).length).toBe(2);
        });
        it('should getRevealOutputChannelOn', async () => {
            expect((0, services_1.getRevealOutputChannelOn)('error')).toBe(language_client_1.RevealOutputChannelOn.Error);
            expect((0, services_1.getRevealOutputChannelOn)('info')).toBe(language_client_1.RevealOutputChannelOn.Info);
            expect((0, services_1.getRevealOutputChannelOn)('warn')).toBe(language_client_1.RevealOutputChannelOn.Warn);
            expect((0, services_1.getRevealOutputChannelOn)('never')).toBe(language_client_1.RevealOutputChannelOn.Never);
            expect((0, services_1.getRevealOutputChannelOn)('')).toBe(language_client_1.RevealOutputChannelOn.Never);
        });
        it('should getLanguageServerOptions', async () => {
            expect((0, services_1.getLanguageServerOptions)('x', 'y', {})).toBe(null);
            expect((0, services_1.getLanguageServerOptions)('x', 'y', { filetypes: ['vim'] })).toBe(null);
            expect((0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ module: 'not_exists' }))).toBe(null);
            expect((0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ module: __filename }))).toBeDefined();
            expect((0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ module: __filename, runtime: process.execPath }))).toBeDefined();
            expect((0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ command: 'cmd', args: [], disableWorkspaceFolders: true, disableSnippetCompletion: true }))).toBeDefined();
            expect((0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ command: 'cmd', ignoredRootPaths: ['/foo'], initializationOptions: {} }))).toBeDefined();
        });
        it('should use socket port for language server #1', async () => {
            let opts = (0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ port: 3300, host: '127.0.0.1' }));
            let fn = opts[1];
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should use socket port for language server #2', async () => {
            let connected = false;
            let s;
            let server = net_1.default.createServer(socket => {
                connected = true;
                s = socket;
            });
            server.listen(12580, '127.0.0.1');
            let opts = (0, services_1.getLanguageServerOptions)('x', 'y', toConfig({ port: 12580 }));
            let fn = opts[1];
            let res = await fn();
            await helper_1.default.wait(30);
            expect(res).toBeDefined();
            expect(connected).toBe(true);
            s.destroy();
            server.close();
        });
        it('should documentSelectorToLanguageIds', async () => {
            expect((0, services_1.documentSelectorToLanguageIds)(['vim'])).toEqual(['vim']);
        });
    });
    describe('getServiceStats()', () => {
        it('should get services', async () => {
            let res = await helper_1.default.doAction('services');
            expect(res).toBeDefined();
        });
    });
    describe('toggle()', () => {
        it('should throw when service not found ', async () => {
            let fn = async () => {
                await helper_1.default.doAction('toggleService', 'id');
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should toggle language client state', async () => {
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {
                documentSelector: [{ language: 'vim', scheme: 'file' }]
            });
            let d = services_1.default.registerLanguageClient(client);
            disposables.push(d);
            let p = services_1.default.toggle('test');
            void services_1.default.toggle('test');
            await p;
            let s = services_1.default.getService('test');
            expect(s.state).toBe(services_1.ServiceStat.Running);
            d.dispose();
        });
    });
    describe('start()', () => {
        it('should delay start when not plugin not ready', async () => {
            Object.assign(events_1.default, { _ready: false });
            let called = false;
            services_1.default.tryStartService({
                id: 'test',
                start: () => {
                    called = true;
                }
            });
            let started = false;
            services_1.default.tryStartService({
                id: 'test',
                state: services_1.ServiceStat.Initial,
                selector: [{ language: '*' }],
                start: () => {
                    started = true;
                }
            });
            await events_1.default.fire('ready', []);
            expect(called).toBe(false);
            expect(started).toBe(true);
        });
        it('should start language client on by document', async () => {
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {
                documentSelector: [{ language: 'vim', scheme: 'file' }]
            });
            disposables.push(services_1.default.registerLanguageClient(client));
            let document = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', 'vim', 1, '');
            await services_1.default.start(document);
            await services_1.default.start(vscode_languageserver_textdocument_1.TextDocument.create('file:///2', 'java', 1, ''));
            let s = services_1.default.getService('test');
            expect(s.state).toBe(services_1.ServiceStat.Running);
            let code = `call coc#on_notify('test', 'notification', { -> execute('let g:called = 1')})`;
            await nvim.exec(code);
            await helper_1.default.doAction('registerNotification', 'test', 'notification');
            await client.sendNotification('triggerNotification');
            await helper_1.default.waitValue(() => {
                return nvim.getVar('called');
            }, 1);
        });
    });
    describe('stop()', () => {
        it('should not throw when service not found ', async () => {
            await services_1.default.stop('id');
        });
    });
    describe('shouldStart()', () => {
        it('should start when document matches', async () => {
            await helper_1.default.edit('t.vim');
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {
                documentSelector: [{ language: 'vim', scheme: 'file' }]
            });
            disposables.push(services_1.default.registerLanguageClient(client));
            services_1.default.register({ id: 'test' });
            await helper_1.default.waitValue(() => {
                return client.state;
            }, language_client_1.State.Running);
            await nvim.command('bd!');
        });
        it('should not start when client already started', async () => {
            await helper_1.default.edit('t.vim');
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {
                documentSelector: [{ language: 'vim', scheme: 'file' }]
            });
            await client.start();
            disposables.push(services_1.default.registerLanguageClient(client));
            await nvim.command('bd!');
        });
    });
    describe('registerLanguageClient', () => {
        it('should not create client when not enabled', async () => {
            workspace.configurations.updateMemoryConfig({
                languageserver: {
                    test: {
                        filetypes: ['vim'],
                        enabled: false
                    }
                }
            });
            disposables.push(services_1.default.registerLanguageClient('test', { filetypes: ['vim'], enable: true }));
            let client = services_1.default.getService('test');
            expect(client).toBeDefined();
            await client.start();
            expect(client.state).toBe(services_1.ServiceStat.Initial);
        });
        it('should not start for bad config', async () => {
            workspace.configurations.updateMemoryConfig({
                languageserver: {
                    test: {
                        filetypes: ['vim']
                    }
                }
            });
            disposables.push(services_1.default.registerLanguageClient('test', { filetypes: ['vim'], enable: true }));
            let client = services_1.default.getService('test');
            expect(client).toBeDefined();
            await client.start();
            expect(client.state).toBe(services_1.ServiceStat.Initial);
        });
        it('should start and stop language client', async () => {
            let config = { filetypes: ['vim'], module: serverModule, enabled: false };
            workspace.configurations.updateMemoryConfig({
                languageserver: { test: config }
            });
            disposables.push(services_1.default.registerLanguageClient('test', config));
            disposables.push(services_1.default.registerLanguageClient('test', config));
            let client = services_1.default.getService('test');
            let p = client.start();
            void client.start();
            await p;
            await client.start();
            await client.restart();
            let pro = client.stop();
            void client.stop();
            await pro;
            expect(client.state).toBe(services_1.ServiceStat.Stopped);
        });
        it('should start language client by restart', async () => {
            let config = { filetypes: ['vim'], module: serverModule, enabled: false };
            workspace.configurations.updateMemoryConfig({
                languageserver: { test: config }
            });
            disposables.push(services_1.default.registerLanguageClient('test', config));
            let client = services_1.default.getService('test');
            await client.restart();
            expect(client.state).toBe(services_1.ServiceStat.Running);
        });
        it('should not throw on start error', async () => {
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {});
            let spy = jest.spyOn(client, 'start').mockImplementation(() => {
                throw new Error('custom error');
            });
            disposables.push(services_1.default.registerLanguageClient(client));
            let service = services_1.default.getService('test');
            await service.start();
            spy.mockRestore();
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('failed to start');
        });
        it('should sendRequest & sendNotification', async () => {
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {});
            disposables.push(services_1.default.registerLanguageClient(client));
            let service = services_1.default.getService('test');
            await service.start();
            let res = await helper_1.default.plugin.cocAction('sendRequest', 'test', 'request', { value: 2 });
            expect(res).toBe(3);
            await helper_1.default.plugin.cocAction('sendNotification', 'test', 'notification', {});
            let result = await service.client.sendRequest('notified');
            expect(result).toEqual({ notified: true });
        });
        it('should throw when service not found', async () => {
            let fn = async () => {
                await services_1.default.sendNotification('id', 'method');
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should register notification when client created', async () => {
            const serverOptions = {
                module: serverModule,
                transport: language_client_1.TransportKind.ipc,
            };
            const client = new language_client_1.LanguageClient('test', 'Test Language Server', serverOptions, {});
            services_1.default.registerLanguageClient(client);
            let service = services_1.default.getService('test');
            await helper_1.default.plugin.cocAction('registerNotification', 'test', 'notification');
            await service.start();
            await service.client.sendNotification('triggerNotification');
            await helper_1.default.wait(10);
            await services_1.default.stop('test');
        });
        it('should register notification when client not created', async () => {
            await helper_1.default.plugin.cocAction('registerNotification', 'def', 'notification');
            workspace.configurations.updateMemoryConfig({
                languageserver: {
                    def: {
                        filetypes: ['vim'],
                        module: serverModule,
                    }
                }
            });
            services_1.default.registerLanguageClient('def', { filetypes: ['.vim'], module: serverModule }, vscode_uri_1.URI.file(__dirname));
            let res;
            let spy = jest.spyOn(services_1.default, 'sendNotificationVim').mockImplementation((id, method, result) => {
                res = { id, method, result };
            });
            let service = services_1.default.getService('def');
            await service.start();
            await service.client.sendNotification('triggerNotification');
            await helper_1.default.waitValue(() => {
                return res != undefined;
            }, true);
            await services_1.default.stop('def');
            spy.mockRestore();
            expect(res).toEqual({ id: 'def', method: 'notification', result: { x: 1 } });
        });
    });
});
//# sourceMappingURL=services.test.js.map