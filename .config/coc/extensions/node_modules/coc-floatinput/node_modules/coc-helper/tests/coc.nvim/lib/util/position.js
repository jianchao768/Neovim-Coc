'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnd = exports.isSingleLine = exports.comparePosition = exports.positionInRange = exports.emptyRange = exports.lineInRange = exports.adjustRangePosition = exports.rangeIntersect = exports.rangeOverlap = exports.rangeAdjacent = exports.toValidRange = exports.compareRangesUsingStarts = exports.samePosition = exports.equalsRange = exports.rangeInRange = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
function rangeInRange(r, range) {
    return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;
}
exports.rangeInRange = rangeInRange;
function equalsRange(r, range) {
    if (!samePosition(r.start, range.start))
        return false;
    return samePosition(r.end, range.end);
}
exports.equalsRange = equalsRange;
function samePosition(one, two) {
    return one.line === two.line && one.character === two.character;
}
exports.samePosition = samePosition;
/**
 * A function that compares ranges, useful for sorting ranges
 * It will first compare ranges on the startPosition and then on the endPosition
 */
function compareRangesUsingStarts(a, b) {
    const aStartLineNumber = a.start.line | 0;
    const bStartLineNumber = b.start.line | 0;
    if (aStartLineNumber === bStartLineNumber) {
        const aStartColumn = a.start.character | 0;
        const bStartColumn = b.start.character | 0;
        if (aStartColumn === bStartColumn) {
            const aEndLineNumber = a.end.line | 0;
            const bEndLineNumber = b.end.line | 0;
            if (aEndLineNumber === bEndLineNumber) {
                const aEndColumn = a.end.character | 0;
                const bEndColumn = b.end.character | 0;
                return aEndColumn - bEndColumn;
            }
            return aEndLineNumber - bEndLineNumber;
        }
        return aStartColumn - bStartColumn;
    }
    return aStartLineNumber - bStartLineNumber;
}
exports.compareRangesUsingStarts = compareRangesUsingStarts;
/**
 * Convert to well formed range
 */
function toValidRange(range, max) {
    let { start, end } = range;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        let m = start;
        start = end;
        end = m;
    }
    start = vscode_languageserver_types_1.Position.create(Math.max(0, start.line), Math.max(0, start.character));
    let endCharacter = Math.max(0, end.character);
    if (typeof max === 'number' && endCharacter > max)
        endCharacter = max;
    end = vscode_languageserver_types_1.Position.create(Math.max(0, end.line), endCharacter);
    return { start, end };
}
exports.toValidRange = toValidRange;
function rangeAdjacent(r, range) {
    if (comparePosition(r.end, range.start) == 0) {
        return true;
    }
    if (comparePosition(range.end, r.start) == 0) {
        return true;
    }
    return false;
}
exports.rangeAdjacent = rangeAdjacent;
/**
 * Check if two ranges have overlap character.
 */
function rangeOverlap(r, range) {
    let { start, end } = r;
    if (comparePosition(end, range.start) <= 0) {
        return false;
    }
    if (comparePosition(start, range.end) >= 0) {
        return false;
    }
    return true;
}
exports.rangeOverlap = rangeOverlap;
/**
 * Check if two ranges have overlap or nested
 */
function rangeIntersect(r, range) {
    if (positionInRange(r.start, range) == 0) {
        return true;
    }
    if (positionInRange(r.end, range) == 0) {
        return true;
    }
    if (rangeInRange(range, r)) {
        return true;
    }
    return false;
}
exports.rangeIntersect = rangeIntersect;
/**
 * Adjust from start position
 */
function adjustRangePosition(range, position) {
    let { line, character } = position;
    let { start, end } = range;
    let endCharacter = end.line == start.line ? end.character + character : end.character;
    return vscode_languageserver_types_1.Range.create(start.line + line, character + start.character, end.line + line, endCharacter);
}
exports.adjustRangePosition = adjustRangePosition;
function lineInRange(line, range) {
    let { start, end } = range;
    return line >= start.line && line <= end.line;
}
exports.lineInRange = lineInRange;
function emptyRange(range) {
    let { start, end } = range;
    return start.line == end.line && start.character == end.character;
}
exports.emptyRange = emptyRange;
function positionInRange(position, range) {
    let { start, end } = range;
    if (comparePosition(position, start) < 0)
        return -1;
    if (comparePosition(position, end) > 0)
        return 1;
    return 0;
}
exports.positionInRange = positionInRange;
function comparePosition(position, other) {
    if (position.line > other.line)
        return 1;
    if (other.line == position.line && position.character > other.character)
        return 1;
    if (other.line == position.line && position.character == other.character)
        return 0;
    return -1;
}
exports.comparePosition = comparePosition;
function isSingleLine(range) {
    return range.start.line == range.end.line;
}
exports.isSingleLine = isSingleLine;
/*
 * Get end position by content
 */
function getEnd(start, content) {
    const lines = content.split(/\r?\n/);
    const len = lines.length;
    const lastLine = lines[len - 1];
    const end = len == 1 ? start.character + content.length : lastLine.length;
    return vscode_languageserver_types_1.Position.create(start.line + len - 1, end);
}
exports.getEnd = getEnd;
//# sourceMappingURL=position.js.map