'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeywordsBuffer = void 0;
const vscode_uri_1 = require("vscode-uri");
const fs_1 = require("../util/fs");
class KeywordsBuffer {
    constructor(doc) {
        this.doc = doc;
        this.lineWords = [];
        this._gitIgnored = false;
        this.parseWords();
        let uri = vscode_uri_1.URI.parse(doc.uri);
        if (uri.scheme === 'file') {
            void (0, fs_1.isGitIgnored)(uri.fsPath).then(ignored => {
                this._gitIgnored = ignored;
            });
        }
    }
    getWords() {
        let res = [];
        for (let words of this.lineWords) {
            words.forEach(word => {
                if (!res.includes(word)) {
                    res.push(word);
                }
            });
        }
        return res;
    }
    parseWords() {
        let { lineWords, doc } = this;
        let { chars } = doc;
        for (let line of this.doc.textDocument.lines) {
            let words = chars.matchLine(line, 2);
            lineWords.push(words);
        }
    }
    get bufnr() {
        return this.doc.bufnr;
    }
    get gitIgnored() {
        return this._gitIgnored;
    }
    onChange(e) {
        if (e.contentChanges.length == 0)
            return;
        let { lineWords, doc } = this;
        let { range, text } = e.contentChanges[0];
        let { start, end } = range;
        let sl = start.line;
        let el = end.line;
        let del = el - sl;
        let newLines = doc.textDocument.lines.slice(sl, sl + text.split(/\n/).length);
        let arr = newLines.map(line => doc.chars.matchLine(line, 2));
        lineWords.splice(sl, del + 1, ...arr);
    }
    *matchWords(line) {
        let { lineWords } = this;
        if (line >= lineWords.length)
            line = lineWords.length - 1;
        for (let i = 0; i < lineWords.length; i++) {
            let idx = i < line ? line - i - 1 : i;
            let words = lineWords[idx];
            for (let word of words) {
                yield word;
            }
        }
    }
    dispose() {
        this.lineWords = [];
    }
}
exports.KeywordsBuffer = KeywordsBuffer;
//# sourceMappingURL=keywords.js.map