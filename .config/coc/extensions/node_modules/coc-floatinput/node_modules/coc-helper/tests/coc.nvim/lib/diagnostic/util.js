'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.adjustDiagnostics = exports.getHighlightGroup = exports.sortDiagnostics = exports.getLocationListItem = exports.getNameFromSeverity = exports.severityLevel = exports.getSeverityType = exports.getSeverityName = exports.formatDiagnostic = exports.DiagnosticHighlight = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const position_1 = require("../util/position");
const string_1 = require("../util/string");
const textedit_1 = require("../util/textedit");
var DiagnosticHighlight;
(function (DiagnosticHighlight) {
    DiagnosticHighlight["Error"] = "CocErrorHighlight";
    DiagnosticHighlight["Warning"] = "CocWarningHighlight";
    DiagnosticHighlight["Information"] = "CocInfoHighlight";
    DiagnosticHighlight["Hint"] = "CocHintHighlight";
    DiagnosticHighlight["Deprecated"] = "CocDeprecatedHighlight";
    DiagnosticHighlight["Unused"] = "CocUnusedHighlight";
})(DiagnosticHighlight = exports.DiagnosticHighlight || (exports.DiagnosticHighlight = {}));
function formatDiagnostic(format, diagnostic) {
    let { source, code, severity, message } = diagnostic;
    let s = getSeverityName(severity)[0];
    const codeStr = code ? ' ' + code : '';
    return format.replace('%source', source)
        .replace('%code', codeStr)
        .replace('%severity', s)
        .replace('%message', message);
}
exports.formatDiagnostic = formatDiagnostic;
function getSeverityName(severity) {
    switch (severity) {
        case vscode_languageserver_types_1.DiagnosticSeverity.Warning:
            return 'Warning';
        case vscode_languageserver_types_1.DiagnosticSeverity.Information:
            return 'Information';
        case vscode_languageserver_types_1.DiagnosticSeverity.Hint:
            return 'Hint';
        default:
            return 'Error';
    }
}
exports.getSeverityName = getSeverityName;
function getSeverityType(severity) {
    switch (severity) {
        case vscode_languageserver_types_1.DiagnosticSeverity.Warning:
            return 'W';
        case vscode_languageserver_types_1.DiagnosticSeverity.Information:
            return 'I';
        case vscode_languageserver_types_1.DiagnosticSeverity.Hint:
            return 'I';
        default:
            return 'E';
    }
}
exports.getSeverityType = getSeverityType;
function severityLevel(level) {
    if (level == null)
        return undefined;
    switch (level) {
        case 'hint':
            return vscode_languageserver_types_1.DiagnosticSeverity.Hint;
        case 'information':
            return vscode_languageserver_types_1.DiagnosticSeverity.Information;
        case 'warning':
            return vscode_languageserver_types_1.DiagnosticSeverity.Warning;
        case 'error':
            return vscode_languageserver_types_1.DiagnosticSeverity.Error;
        default:
            return vscode_languageserver_types_1.DiagnosticSeverity.Hint;
    }
}
exports.severityLevel = severityLevel;
function getNameFromSeverity(severity) {
    switch (severity) {
        case vscode_languageserver_types_1.DiagnosticSeverity.Error:
            return 'CocError';
        case vscode_languageserver_types_1.DiagnosticSeverity.Warning:
            return 'CocWarning';
        case vscode_languageserver_types_1.DiagnosticSeverity.Information:
            return 'CocInfo';
        case vscode_languageserver_types_1.DiagnosticSeverity.Hint:
            return 'CocHint';
        default:
            return 'CocError';
    }
}
exports.getNameFromSeverity = getNameFromSeverity;
function getLocationListItem(bufnr, diagnostic, lines) {
    var _a, _b;
    let { start, end } = diagnostic.range;
    let owner = diagnostic.source || 'coc.nvim';
    let msg = diagnostic.message.split('\n')[0];
    let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
    return {
        bufnr,
        lnum: start.line + 1,
        end_lnum: end.line + 1,
        col: Array.isArray(lines) ? (0, string_1.byteIndex)((_a = lines[start.line]) !== null && _a !== void 0 ? _a : '', start.character) + 1 : start.character + 1,
        end_col: Array.isArray(lines) ? (0, string_1.byteIndex)((_b = lines[end.line]) !== null && _b !== void 0 ? _b : '', end.character) + 1 : end.character + 1,
        text: `[${owner}${diagnostic.code ? ' ' + diagnostic.code : ''}] ${msg} [${type}]`,
        type
    };
}
exports.getLocationListItem = getLocationListItem;
/**
 * Sort by severity and position
 */
function sortDiagnostics(a, b) {
    var _a, _b;
    let sa = (_a = a.severity) !== null && _a !== void 0 ? _a : 1;
    let sb = (_b = b.severity) !== null && _b !== void 0 ? _b : 1;
    if (sa != sb)
        return sa - sb;
    let d = (0, position_1.comparePosition)(a.range.start, b.range.start);
    if (d != 0)
        return d;
    return a.source > b.source ? 1 : -1;
}
exports.sortDiagnostics = sortDiagnostics;
function getHighlightGroup(diagnostic) {
    let tags = diagnostic.tags || [];
    if (tags.includes(vscode_languageserver_types_1.DiagnosticTag.Deprecated)) {
        return DiagnosticHighlight.Deprecated;
    }
    if (tags.includes(vscode_languageserver_types_1.DiagnosticTag.Unnecessary)) {
        return DiagnosticHighlight.Unused;
    }
    switch (diagnostic.severity) {
        case vscode_languageserver_types_1.DiagnosticSeverity.Warning:
            return DiagnosticHighlight.Warning;
        case vscode_languageserver_types_1.DiagnosticSeverity.Information:
            return DiagnosticHighlight.Information;
        case vscode_languageserver_types_1.DiagnosticSeverity.Hint:
            return DiagnosticHighlight.Hint;
        default:
            return DiagnosticHighlight.Error;
    }
}
exports.getHighlightGroup = getHighlightGroup;
function adjustDiagnostics(diagnostics, edit) {
    let res = [];
    let { range } = edit;
    for (let diag of diagnostics) {
        let r = diag.range;
        if ((0, position_1.rangeOverlap)(range, r))
            continue;
        if ((0, position_1.comparePosition)(r.start, range.end) > 0) {
            let s = (0, textedit_1.getPosition)(r.start, edit);
            let e = (0, textedit_1.getPosition)(r.end, edit);
            if (s.line >= 0 && s.character >= 0 && e.line >= 0 && e.character >= 0) {
                diag.range = vscode_languageserver_types_1.Range.create(s, e);
            }
        }
        res.push(diag);
    }
    return res;
}
exports.adjustDiagnostics = adjustDiagnostics;
//# sourceMappingURL=util.js.map