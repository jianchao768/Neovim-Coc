'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeActionFeature = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const languages_1 = tslib_1.__importDefault(require("../languages"));
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const UUID = tslib_1.__importStar(require("./utils/uuid"));
class CodeActionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.CodeActionRequest.type);
        this.disposables = [];
    }
    fillClientCapabilities(capabilities) {
        const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.honorsChangeAnnotations = false;
        cap.resolveSupport = {
            properties: ['edit']
        };
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_types_1.CodeActionKind.Empty,
                    vscode_languageserver_types_1.CodeActionKind.QuickFix,
                    vscode_languageserver_types_1.CodeActionKind.Refactor,
                    vscode_languageserver_types_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_types_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_types_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_types_1.CodeActionKind.Source,
                    vscode_languageserver_types_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const registerCommand = (id) => {
            const client = this._client;
            const executeCommand = (command, args) => {
                const params = {
                    command,
                    arguments: args
                };
                return client.sendRequest(protocol_1.ExecuteCommandRequest.type, params);
            };
            const middleware = client.middleware;
            this.disposables.push(commands_1.default.registerCommand(id, (...args) => {
                return middleware.executeCommand
                    ? middleware.executeCommand(id, args, executeCommand)
                    : executeCommand(id, args);
            }, null, true));
        };
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = (document, range, context, token) => {
                    const params = {
                        textDocument: {
                            uri: document.uri
                        },
                        range,
                        context,
                    };
                    return this.sendRequest(protocol_1.CodeActionRequest.type, params, token).then(values => {
                        if (!values)
                            return undefined;
                        // some server may not registered commands to client.
                        values.forEach(val => {
                            var _a;
                            let cmd = vscode_languageserver_types_1.Command.is(val) ? val.command : (_a = val.command) === null || _a === void 0 ? void 0 : _a.command;
                            if (cmd && !commands_1.default.has(cmd))
                                registerCommand(cmd);
                        });
                        return values;
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            },
            resolveCodeAction: options.resolveProvider
                ? (item, token) => {
                    const middleware = this._client.middleware;
                    const resolveCodeAction = (item, token) => {
                        return this.sendRequest(protocol_1.CodeActionResolveRequest.type, item, token, item);
                    };
                    return middleware.resolveCodeAction
                        ? middleware.resolveCodeAction(item, token, resolveCodeAction)
                        : resolveCodeAction(item, token);
                }
                : undefined
        };
        return [languages_1.default.registerCodeActionProvider(options.documentSelector, provider, this._client.id, options.codeActionKinds), provider];
    }
    dispose() {
        this.disposables.forEach(o => {
            o.dispose();
        });
        this.disposables = [];
        super.dispose();
    }
}
exports.CodeActionFeature = CodeActionFeature;
//# sourceMappingURL=codeAction.js.map