'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.firstMatchFuzzy = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const fuzzy_1 = require("../util/fuzzy");
const node_1 = require("../util/node");
const Is = tslib_1.__importStar(require("../util/is"));
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const types_1 = require("./types");
const WORD_PREFIXES = ['_', '$', '-'];
const WORD_PREFIXES_CODE = [95, 36, 45];
const MAX_DURATION = (0, util_1.getConditionValue)(80, 20);
const MAX_COUNT = 50;
class Source {
    constructor(option) {
        /**
         * Words that not match during session
         * The word that not match previous input would not match further input
         */
        this.noMatchWords = new Set();
        this.disposables = [];
        this._disabled = false;
        // readonly properties
        this.name = option.name;
        this.filepath = option.filepath || '';
        this.sourceType = option.sourceType || types_1.SourceType.Native;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
        this.documentSelector = option.documentSelector;
        const key = `coc.source.${option.name}`;
        this.config = (0, util_1.defaultValue)(workspace_1.default.initialConfiguration.get(key), {});
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(key)) {
                this.config = (0, util_1.defaultValue)(workspace_1.default.initialConfiguration.get(key), {});
            }
        }, null, this.disposables);
        events_1.default.on('CompleteDone', () => {
            this.noMatchWords.clear();
        }, null, this.disposables);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    /**
     * Priority of source, higher priority makes items lower index.
     */
    get priority() {
        return this.getConfig('priority', 1);
    }
    get triggerPatterns() {
        let patterns = this.getConfig('triggerPatterns', null);
        if ((0, array_1.isFalsyOrEmpty)(patterns))
            return null;
        return patterns.map(s => Is.string(s) ? new RegExp(s + '$') : s);
    }
    /**
     * When triggerOnly is true, not trigger completion on keyword character insert.
     */
    get triggerOnly() {
        let triggerOnly = this.defaults['triggerOnly'];
        if (Is.boolean(triggerOnly))
            return triggerOnly;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length > 0;
    }
    get triggerCharacters() {
        return (0, array_1.toArray)(this.getConfig('triggerCharacters', []));
    }
    get firstMatch() {
        return this.getConfig('firstMatch', true);
    }
    // exists opitonnal function names for remote source
    get optionalFns() {
        return this.defaults['optionalFns'] || [];
    }
    get shortcut() {
        let shortcut = this.getConfig('shortcut', '');
        return shortcut ? shortcut : this.name.slice(0, 3);
    }
    get enable() {
        if (this._disabled)
            return false;
        return this.getConfig('enable', true);
    }
    get filetypes() {
        return this.getConfig('filetypes', null);
    }
    get disableSyntaxes() {
        return this.getConfig('disableSyntaxes', []);
    }
    getConfig(key, defaultValue) {
        let val = this.config[key];
        if (Is.func(val) || val == null)
            return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;
        return val;
    }
    toggle() {
        this._disabled = !this._disabled;
    }
    get menu() {
        return '';
    }
    async checkComplete(opt) {
        let { disableSyntaxes } = this;
        if (!(0, array_1.isFalsyOrEmpty)(disableSyntaxes) && opt.synname) {
            let synname = opt.synname.toLowerCase();
            if (disableSyntaxes.findIndex(s => synname.includes(s.toLowerCase())) !== -1) {
                return false;
            }
        }
        let fn = this.defaults['shouldComplete'];
        if (Is.func(fn))
            return !!(await Promise.resolve(fn.call(this, opt)));
        return true;
    }
    async refresh() {
        let fn = this.defaults['refresh'];
        if (Is.func(fn))
            await Promise.resolve(fn.call(this));
    }
    async onCompleteDone(item, opt) {
        let fn = this.defaults['onCompleteDone'];
        if (Is.func(fn))
            await Promise.resolve(fn.call(this, item, opt));
    }
    async doComplete(opt, token) {
        let shouldRun = await this.checkComplete(opt);
        if (!shouldRun || token.isCancellationRequested)
            return null;
        let fn = this.defaults['doComplete'];
        return await Promise.resolve(fn.call(this, opt, token));
    }
    async onCompleteResolve(item, opt, token) {
        let fn = this.defaults['onCompleteResolve'];
        if (Is.func(fn))
            await Promise.resolve(fn.call(this, item, opt, token));
    }
    /**
     * Add words to items with timer.
     */
    async getResults(iterables, input, exclude, items, token) {
        let { firstMatch, noMatchWords } = this;
        let start = Date.now();
        let prev = start;
        let len = input.length;
        let firstCode = input.charCodeAt(0);
        let codes = (0, fuzzy_1.getCharCodes)(input);
        let ascii = (0, string_1.isAlphabet)(firstCode);
        let i = 0;
        for (let iterable of iterables) {
            for (let w of iterable) {
                i++;
                if (i % 100 === 0) {
                    let curr = Date.now();
                    if (curr - prev > 15) {
                        await (0, util_1.waitImmediate)();
                        prev = curr;
                    }
                    if (token.isCancellationRequested || curr - start > MAX_DURATION)
                        return true;
                }
                if ((w.length <= 1 && w.charCodeAt(0) < 255) || w === exclude || items.has(w) || noMatchWords.has(w))
                    continue;
                if (firstMatch && !firstMatchFuzzy(firstCode, ascii, w)) {
                    noMatchWords.add(w);
                    continue;
                }
                if (len > 1) {
                    let matched = (0, fuzzy_1.fuzzyMatch)(codes, ascii && w[0].charCodeAt(0) > constants_1.ASCII_END ? (0, node_1.unidecode)(w) : w);
                    if (!matched) {
                        noMatchWords.add(w);
                        continue;
                    }
                }
                items.add(w);
                if (items.size == MAX_COUNT)
                    return true;
            }
        }
        return false;
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Source;
function firstMatchFuzzy(firstCode, ascii, word) {
    let ch = word[0];
    if (ascii && !WORD_PREFIXES_CODE.includes(firstCode) && WORD_PREFIXES.includes(ch))
        ch = word[1];
    if (ascii && ch.charCodeAt(0) > constants_1.ASCII_END)
        ch = (0, node_1.unidecode)(ch);
    return (0, fuzzy_1.caseMatch)(firstCode, ch.charCodeAt(0));
}
exports.firstMatchFuzzy = firstMatchFuzzy;
//# sourceMappingURL=source.js.map