'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workspace = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const configuration_1 = tslib_1.__importDefault(require("./configuration"));
const shape_1 = tslib_1.__importDefault(require("./configuration/shape"));
const autocmds_1 = tslib_1.__importDefault(require("./core/autocmds"));
const channels_1 = tslib_1.__importDefault(require("./core/channels"));
const contentProvider_1 = tslib_1.__importDefault(require("./core/contentProvider"));
const documents_1 = tslib_1.__importDefault(require("./core/documents"));
const editors_1 = tslib_1.__importDefault(require("./core/editors"));
const files_1 = tslib_1.__importDefault(require("./core/files"));
const fileSystemWatcher_1 = require("./core/fileSystemWatcher");
const funcs_1 = require("./core/funcs");
const keymaps_1 = tslib_1.__importDefault(require("./core/keymaps"));
const ui = tslib_1.__importStar(require("./core/ui"));
const watchers_1 = tslib_1.__importDefault(require("./core/watchers"));
const workspaceFolder_1 = tslib_1.__importDefault(require("./core/workspaceFolder"));
const events_1 = tslib_1.__importDefault(require("./events"));
const logger_1 = require("./logger");
const bufferSync_1 = tslib_1.__importDefault(require("./model/bufferSync"));
const db_1 = tslib_1.__importDefault(require("./model/db"));
const fuzzyMatch_1 = require("./model/fuzzyMatch");
const mru_1 = tslib_1.__importDefault(require("./model/mru"));
const status_1 = tslib_1.__importDefault(require("./model/status"));
const strwidth_1 = require("./model/strwidth");
const task_1 = tslib_1.__importDefault(require("./model/task"));
const constants_1 = require("./util/constants");
const extensionRegistry_1 = require("./util/extensionRegistry");
const node_1 = require("./util/node");
const object_1 = require("./util/object");
const processes_1 = require("./util/processes");
const logger = (0, logger_1.createLogger)('workspace');
const methods = [
    'showMessage', 'runTerminalCommand', 'openTerminal', 'showQuickpick',
    'menuPick', 'openLocalConfig', 'showPrompt', 'createStatusBarItem', 'createOutputChannel',
    'showOutputChannel', 'requestInput', 'echoLines', 'getCursorPosition', 'moveTo',
    'getOffset', 'getSelectedRange', 'selectRange', 'createTerminal',
];
class Workspace {
    constructor() {
        var _a;
        this.statusLine = new status_1.default();
        void (0, fuzzyMatch_1.initFuzzyWasm)().then(api => {
            this.fuzzyExports = api;
        });
        void strwidth_1.StrWidth.create().then(strWdith => {
            this.strWdith = strWdith;
        });
        events_1.default.on('VimResized', (columns, lines) => {
            Object.assign((0, object_1.toObject)(this.env), { columns, lines });
        });
        Object.defineProperty(this.statusLine, 'nvim', {
            get: () => this.nvim
        });
        let configurations = this.configurations = new configuration_1.default(constants_1.userConfigFile, new shape_1.default(this));
        this.workspaceFolderControl = new workspaceFolder_1.default(this.configurations);
        let documents = this.documentsManager = new documents_1.default(this.configurations, this.workspaceFolderControl);
        this.contentProvider = new contentProvider_1.default(documents);
        this.watchers = new watchers_1.default();
        this.autocmds = new autocmds_1.default();
        this.keymaps = new keymaps_1.default();
        this.files = new files_1.default(documents, this.configurations, this.workspaceFolderControl, this.keymaps);
        this.editors = new editors_1.default(documents);
        this.onDidRuntimePathChange = this.watchers.onDidRuntimePathChange;
        this.onDidChangeWorkspaceFolders = this.workspaceFolderControl.onDidChangeWorkspaceFolders;
        this.onDidChangeConfiguration = this.configurations.onDidChange;
        this.onDidOpenTextDocument = documents.onDidOpenTextDocument;
        this.onDidChangeTextDocument = documents.onDidChangeDocument;
        this.onDidCloseTextDocument = documents.onDidCloseDocument;
        this.onDidSaveTextDocument = documents.onDidSaveTextDocument;
        this.onWillSaveTextDocument = documents.onWillSaveTextDocument;
        this.onDidCreateFiles = this.files.onDidCreateFiles;
        this.onDidRenameFiles = this.files.onDidRenameFiles;
        this.onDidDeleteFiles = this.files.onDidDeleteFiles;
        this.onWillCreateFiles = this.files.onWillCreateFiles;
        this.onWillRenameFiles = this.files.onWillRenameFiles;
        this.onWillDeleteFiles = this.files.onWillDeleteFiles;
        const preferences = configurations.initialConfiguration.get('coc.preferences');
        const watchmanPath = (_a = preferences.watchmanPath) !== null && _a !== void 0 ? _a : constants_1.watchmanCommand;
        this.fileSystemWatchers = new fileSystemWatcher_1.FileSystemWatcherManager(this.workspaceFolderControl, watchmanPath);
    }
    get initialConfiguration() {
        return this.configurations.initialConfiguration;
    }
    async init(window) {
        let { nvim } = this;
        for (let method of methods) {
            Object.defineProperty(this, method, {
                get: () => {
                    return (...args) => {
                        let stack = '\n' + Error().stack.split('\n').slice(2, 4).join('\n');
                        logger.warn(`workspace.${method} is deprecated, please use window.${method} instead.`, stack);
                        return window[method].apply(window, args);
                    };
                }
            });
        }
        for (let name of ['onDidOpenTerminal', 'onDidCloseTerminal']) {
            Object.defineProperty(this, name, {
                get: () => {
                    let stack = '\n' + Error().stack.split('\n').slice(2, 4).join('\n');
                    logger.warn(`workspace.${name} is deprecated, please use window.${name} instead.`, stack);
                    return window[name];
                }
            });
        }
        let env = this._env = await nvim.call('coc#util#vim_info');
        window.init(env);
        this.checkVersion(constants_1.APIVERSION);
        this.configurations.updateMemoryConfig(this._env.config);
        this.workspaceFolderControl.setWorkspaceFolders(this._env.workspaceFolders);
        this.workspaceFolderControl.onDidChangeWorkspaceFolders(() => {
            nvim.setVar('WorkspaceFolders', this.folderPaths, true);
        });
        this.files.attach(nvim, env, window);
        this.contentProvider.attach(nvim);
        this.keymaps.attach(nvim);
        this.autocmds.attach(nvim, env);
        this.watchers.attach(nvim, env);
        await this.documentsManager.attach(this.nvim, this._env);
        await this.editors.attach(nvim);
        let channel = channels_1.default.create('watchman', nvim);
        this.fileSystemWatchers.attach(channel);
        if (this.strWdith)
            this.strWdith.setAmbw(!env.ambiguousIsNarrow);
    }
    checkVersion(version) {
        if (this._env.apiversion != version) {
            this.nvim.echoError(`API version ${this._env.apiversion} is not ${constants_1.APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);
        }
    }
    getDisplayWidth(text, cache = false) {
        return this.strWdith.getWidth(text, cache);
    }
    get version() {
        return constants_1.VERSION;
    }
    get cwd() {
        return this.documentsManager.cwd;
    }
    get env() {
        return this._env;
    }
    get root() {
        return this.documentsManager.root || this.cwd;
    }
    get rootPath() {
        return this.root;
    }
    get bufnr() {
        return this.documentsManager.bufnr;
    }
    /**
     * @deprecated
     */
    get insertMode() {
        return events_1.default.insertMode;
    }
    /**
     * @deprecated always true
     */
    get floatSupported() {
        return true;
    }
    /**
     * @deprecated
     */
    get uri() {
        return this.documentsManager.uri;
    }
    /**
     * @deprecated
     */
    get workspaceFolder() {
        return this.workspaceFolders[0];
    }
    get textDocuments() {
        return this.documentsManager.textDocuments;
    }
    get documents() {
        return this.documentsManager.documents;
    }
    get document() {
        return this.documentsManager.document;
    }
    get workspaceFolders() {
        return this.workspaceFolderControl.workspaceFolders;
    }
    checkPatterns(patterns, folders) {
        return this.workspaceFolderControl.checkPatterns(folders !== null && folders !== void 0 ? folders : this.workspaceFolderControl.workspaceFolders, patterns);
    }
    get folderPaths() {
        return this.workspaceFolders.map(f => vscode_uri_1.URI.parse(f.uri).fsPath);
    }
    get channelNames() {
        return channels_1.default.names;
    }
    get pluginRoot() {
        return constants_1.pluginRoot;
    }
    get isVim() {
        return this._env.isVim;
    }
    get isNvim() {
        return !this._env.isVim;
    }
    /**
     * Keeped for backward compatible
     */
    get completeOpt() {
        return '';
    }
    get filetypes() {
        return this.documentsManager.filetypes;
    }
    get languageIds() {
        return this.documentsManager.languageIds;
    }
    /**
     * @deprecated
     */
    createNameSpace(name) {
        return (0, funcs_1.createNameSpace)(name);
    }
    has(feature) {
        return (0, funcs_1.has)(this.env, feature);
    }
    /**
     * Register autocmd on vim.
     */
    registerAutocmd(autocmd) {
        if (autocmd.request && autocmd.event !== 'BufWritePre') {
            let name = (0, extensionRegistry_1.parseExtensionName)(Error().stack);
            logger.warn(`Extension "${name}" registered synchronized autocmd "${autocmd.event}", which could be slow.`);
        }
        return this.autocmds.registerAutocmd(autocmd);
    }
    /**
     * Watch for option change.
     */
    watchOption(key, callback, disposables) {
        return this.watchers.watchOption(key, callback, disposables);
    }
    /**
     * Watch global variable, works on neovim only.
     */
    watchGlobal(key, callback, disposables) {
        let cb = callback !== null && callback !== void 0 ? callback : function () { };
        return this.watchers.watchGlobal(key, cb, disposables);
    }
    /**
     * Check if selector match document.
     */
    match(selector, document) {
        return (0, funcs_1.score)(selector, document.uri, document.languageId);
    }
    /**
     * Create a FileSystemWatcher instance, doesn't fail when watchman not found.
     */
    createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        return this.fileSystemWatchers.createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete);
    }
    createFuzzyMatch() {
        return new fuzzyMatch_1.FuzzyMatch(this.fuzzyExports);
    }
    getWatchmanPath() {
        return (0, funcs_1.getWatchmanPath)(this.configurations);
    }
    /**
     * Get configuration by section and optional resource uri.
     */
    getConfiguration(section, scope) {
        return this.configurations.getConfiguration(section, scope);
    }
    resolveJSONSchema(uri) {
        return this.configurations.getJSONSchema(uri);
    }
    /**
     * Get created document by uri or bufnr.
     */
    getDocument(uri) {
        return this.documentsManager.getDocument(uri);
    }
    hasDocument(uri, version) {
        let doc = this.documentsManager.getDocument(uri);
        return doc != null && (version != null ? doc.version == version : true);
    }
    getUri(bufnr, defaultValue = '') {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc ? doc.uri : defaultValue;
    }
    isAttached(bufnr) {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc != null && doc.attached;
    }
    /**
     * Get attached document by uri or bufnr.
     * Throw error when document doesn't exist or isn't attached.
     */
    getAttachedDocument(uri) {
        let doc = this.getDocument(uri);
        if (!doc)
            throw new Error(`Buffer ${uri} not created.`);
        if (!doc.attached)
            throw new Error(`Buffer ${uri} not attached, ${doc.notAttachReason}`);
        return doc;
    }
    /**
     * Convert location to quickfix item.
     */
    getQuickfixItem(loc, text, type = '', module) {
        return this.documentsManager.getQuickfixItem(loc, text, type, module);
    }
    /**
     * Create persistence Mru instance.
     */
    createMru(name) {
        return new mru_1.default(name);
    }
    async getQuickfixList(locations) {
        return this.documentsManager.getQuickfixList(locations);
    }
    /**
     * Populate locations to UI.
     */
    async showLocations(locations) {
        await this.documentsManager.showLocations(locations);
    }
    /**
     * Get content of line by uri and line.
     */
    getLine(uri, line) {
        return this.documentsManager.getLine(uri, line);
    }
    /**
     * Get WorkspaceFolder of uri
     */
    getWorkspaceFolder(uri) {
        return this.workspaceFolderControl.getWorkspaceFolder(vscode_uri_1.URI.parse(uri));
    }
    /**
     * Get content from buffer or file by uri.
     */
    readFile(uri) {
        return this.documentsManager.readFile(uri);
    }
    async getCurrentState() {
        let document = await this.document;
        let position = await ui.getCursorPosition(this.nvim);
        return {
            document: document.textDocument,
            position
        };
    }
    async getFormatOptions(uri) {
        return this.documentsManager.getFormatOptions(uri);
    }
    /**
     * Resolve module from yarn or npm.
     */
    resolveModule(name) {
        return (0, funcs_1.resolveModule)(name);
    }
    /**
     * Run nodejs command
     */
    async runCommand(cmd, cwd, timeout) {
        return (0, processes_1.runCommand)(cmd, { cwd: cwd !== null && cwd !== void 0 ? cwd : this.cwd }, timeout);
    }
    /**
     * Expand filepath with `~` and/or environment placeholders
     */
    expand(filepath) {
        return this.documentsManager.expand(filepath);
    }
    async callAsync(method, args) {
        return await (0, funcs_1.callAsync)(this.nvim, method, args);
    }
    registerTextDocumentContentProvider(scheme, provider) {
        return this.contentProvider.registerTextDocumentContentProvider(scheme, provider);
    }
    registerKeymap(modes, key, fn, opts = {}) {
        return this.keymaps.registerKeymap(modes, key, fn, opts);
    }
    registerExprKeymap(mode, key, fn, buffer = false) {
        return this.keymaps.registerExprKeymap(mode, key, fn, buffer);
    }
    registerLocalKeymap(bufnr, mode, key, fn, notify = false) {
        var _a;
        if (typeof arguments[0] === 'string') {
            bufnr = this.bufnr;
            mode = arguments[0];
            key = arguments[1];
            fn = arguments[2];
            notify = (_a = arguments[3]) !== null && _a !== void 0 ? _a : false;
        }
        return this.keymaps.registerLocalKeymap(bufnr, mode, key, fn, notify);
    }
    /**
     * Create Task instance that runs in vim.
     */
    createTask(id) {
        return new task_1.default(this.nvim, id);
    }
    /**
     * Create DB instance at extension root.
     */
    createDatabase(name) {
        return new db_1.default(node_1.path.join(constants_1.dataHome, name + '.json'));
    }
    registerBufferSync(create) {
        return new bufferSync_1.default(create, this.documentsManager);
    }
    async attach() {
        await this.documentsManager.attach(this.nvim, this._env);
    }
    jumpTo(uri, position, openCommand) {
        return this.files.jumpTo(uri, position, openCommand);
    }
    /**
     * Findup for filename or filenames from current filepath or root.
     */
    findUp(filename) {
        return (0, funcs_1.findUp)(this.nvim, this.cwd, filename);
    }
    /**
     * Apply WorkspaceEdit.
     */
    applyEdit(edit) {
        return this.files.applyEdit(edit);
    }
    /**
     * Create a file in vim and disk
     */
    createFile(filepath, opts = {}) {
        return this.files.createFile(filepath, opts);
    }
    /**
     * Load uri as document.
     */
    loadFile(uri, cmd) {
        return this.files.loadResource(uri, cmd);
    }
    /**
     * Load the files that not loaded
     */
    async loadFiles(uris) {
        return this.files.loadResources(uris);
    }
    /**
     * Rename file in vim and disk
     */
    async renameFile(oldPath, newPath, opts = {}) {
        await this.files.renameFile(oldPath, newPath, opts);
    }
    /**
     * Delete file from vim and disk.
     */
    async deleteFile(filepath, opts = {}) {
        await this.files.deleteFile(filepath, opts);
    }
    /**
     * Open resource by uri
     */
    async openResource(uri) {
        await this.files.openResource(uri);
    }
    async computeWordRanges(uri, range, token) {
        let doc = this.getDocument(uri);
        if (!doc)
            return null;
        return await doc.chars.computeWordRanges(doc.textDocument.lines, range, token);
    }
    openTextDocument(uri) {
        return this.files.openTextDocument(uri);
    }
    getRelativePath(pathOrUri, includeWorkspace) {
        return this.workspaceFolderControl.getRelativePath(pathOrUri, includeWorkspace);
    }
    async findFiles(include, exclude, maxResults, token) {
        return this.files.findFiles(include, exclude, maxResults, token);
    }
    detach() {
        this.documentsManager.detach();
    }
    reset() {
        this.statusLine.reset();
        this.configurations.reset();
        this.workspaceFolderControl.reset();
        this.documentsManager.reset();
    }
    dispose() {
        this.autocmds.dispose();
        this.statusLine.dispose();
        this.watchers.dispose();
        this.contentProvider.dispose();
        this.documentsManager.dispose();
        this.configurations.dispose();
    }
}
exports.Workspace = Workspace;
exports.default = new Workspace();
//# sourceMappingURL=workspace.js.map