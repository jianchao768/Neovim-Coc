'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRegex = exports.addPythonTryCatch = exports.getVariablesCode = exports.executePythonCode = exports.preparePythonCodes = exports.prepareMatchCode = exports.evalCode = void 0;
const child_process_1 = require("child_process");
const constants_1 = require("../util/constants");
const node_1 = require("../util/node");
const string_1 = require("../util/string");
/**
 * Eval code for code placeholder.
 */
async function evalCode(nvim, kind, code, curr) {
    if (kind == 'vim') {
        let res = await nvim.eval(code);
        return res.toString();
    }
    if (kind == 'shell') {
        let res = await (0, node_1.promisify)(child_process_1.exec)(code);
        return res.stdout.replace(/\s*$/, '');
    }
    let lines = [`snip._reset("${escapeString(curr)}")`];
    lines.push(...code.split(/\r?\n/).map(line => line.replace(/\t/g, '    ')));
    await executePythonCode(nvim, lines);
    let res = await nvim.call(`pyxeval`, 'str(snip.rv)');
    return (0, string_1.toText)(res);
}
exports.evalCode = evalCode;
function prepareMatchCode(snip) {
    let { range, regex, line } = snip;
    let pyCodes = [];
    if (regex && range != null) {
        let trigger = line.slice(range.start.character, range.end.character);
        pyCodes.push(`pattern = re.compile("${escapeString(regex)}")`);
        pyCodes.push(`match = pattern.search("${escapeString(trigger)}")`);
    }
    else {
        pyCodes.push(`match = None`);
    }
    return pyCodes.join('\n');
}
exports.prepareMatchCode = prepareMatchCode;
function preparePythonCodes(snip) {
    let { range, context, line } = snip;
    let pyCodes = [
        'import re, os, vim, string, random',
        `path = vim.eval('expand("%:p")') or ""`,
        `fn = os.path.basename(path)`,
    ];
    if (context) {
        pyCodes.push(`snip = ContextSnippet()`);
        pyCodes.push(`context = ${context}`);
    }
    else {
        pyCodes.push(`context = True`);
    }
    let start = `(${range.start.line},${Buffer.byteLength(line.slice(0, range.start.character))})`;
    let end = `(${range.start.line},${Buffer.byteLength(line.slice(0, range.end.character))})`;
    let indent = line.match(/^\s*/)[0];
    pyCodes.push(`snip = SnippetUtil("${escapeString(indent)}", ${start}, ${end}, context)`);
    return pyCodes;
}
exports.preparePythonCodes = preparePythonCodes;
async function executePythonCode(nvim, codes) {
    try {
        await nvim.command(`pyx ${addPythonTryCatch(codes.join('\n'))}`);
    }
    catch (e) {
        let err = new Error(e.message);
        err.stack = `Error on execute python code:\n${codes.join('\n')}\n` + e.stack;
        throw err;
    }
}
exports.executePythonCode = executePythonCode;
function getVariablesCode(values) {
    let keys = Object.keys(values);
    if (keys.length == 0)
        return `t = ()`;
    let maxIndex = Math.max.apply(null, keys.map(v => Number(v)));
    let vals = (new Array(maxIndex)).fill('""');
    for (let [idx, val] of Object.entries(values)) {
        vals[idx] = `"${escapeString(val)}"`;
    }
    return `t = (${vals.join(',')},)`;
}
exports.getVariablesCode = getVariablesCode;
/**
 * vim8 doesn't throw any python error with :py command
 * we have to use g:errmsg since v:errmsg can't be changed in python script.
 */
function addPythonTryCatch(code, force = false) {
    if (!constants_1.isVim && force === false)
        return code;
    let lines = [
        'import traceback, vim',
        `vim.vars['errmsg'] = ''`,
        'try:',
    ];
    lines.push(...code.split('\n').map(line => '    ' + line));
    lines.push('except Exception as e:');
    lines.push(`    vim.vars['errmsg'] = traceback.format_exc()`);
    return lines.join('\n');
}
exports.addPythonTryCatch = addPythonTryCatch;
function escapeString(input) {
    return input
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n');
}
const stringStartRe = /\\A/;
const conditionRe = /\(\?\(\w+\).+\|/;
const commentRe = /\(\?#.*?\)/;
const namedCaptureRe = /\(\?P<\w+>.*?\)/;
const namedReferenceRe = /\(\?P=(\w+)\)/;
const regex = new RegExp(`${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}`, 'g');
/**
 * Convert python regex to javascript regex,
 * throw error when unsupported pattern found
 */
function convertRegex(str) {
    if (str.indexOf('\\z') !== -1) {
        throw new Error('pattern \\z not supported');
    }
    if (str.indexOf('(?s)') !== -1) {
        throw new Error('pattern (?s) not supported');
    }
    if (str.indexOf('(?x)') !== -1) {
        throw new Error('pattern (?x) not supported');
    }
    if (str.indexOf('\n') !== -1) {
        throw new Error('pattern \\n not supported');
    }
    if (conditionRe.test(str)) {
        throw new Error('pattern (?id/name)yes-pattern|no-pattern not supported');
    }
    return str.replace(regex, (match, p1) => {
        if (match.startsWith('(?#'))
            return '';
        if (match.startsWith('(?P<'))
            return '(?' + match.slice(3);
        if (match.startsWith('(?P='))
            return `\\k<${p1}>`;
        // if (match == '\\A') return '^'
        return '^';
    });
}
exports.convertRegex = convertRegex;
//# sourceMappingURL=eval.js.map