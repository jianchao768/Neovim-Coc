'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.HistoryInput = exports.sessionKey = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const protocol_1 = require("../util/protocol");
const util_1 = require("../util");
exports.sessionKey = 'filter';
class HistoryInput {
    constructor() {
        this.history = [];
    }
    next(input) {
        var _a;
        let idx = this.history.indexOf(input);
        return (_a = this.history[idx + 1]) !== null && _a !== void 0 ? _a : this.history[0];
    }
    previous(input) {
        var _a;
        let idx = this.history.indexOf(input);
        return (_a = this.history[idx - 1]) !== null && _a !== void 0 ? _a : this.history[this.history.length - 1];
    }
    add(input) {
        let idx = this.history.indexOf(input);
        if (idx !== -1) {
            this.history.splice(idx, 1);
        }
        this.history.unshift(input);
    }
    toJSON() {
        return `[${this.history.join(',')}]`;
    }
}
exports.HistoryInput = HistoryInput;
class Filter {
    constructor(nvim, keys) {
        this.nvim = nvim;
        this._activated = false;
        this.history = new HistoryInput();
        this.disposables = [];
        this._onDidUpdate = new protocol_1.Emitter();
        this._onDidExit = new protocol_1.Emitter();
        this._onDidKeyPress = new protocol_1.Emitter();
        this.onDidKeyPress = this._onDidKeyPress.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.onDidExit = this._onDidExit.event;
        this.text = '';
        events_1.default.on('InputChar', (session, character) => {
            if (session !== exports.sessionKey || !this._activated)
                return;
            if (!keys.includes(character)) {
                if (character.length == 1) {
                    this.text = this.text + character;
                    this._onDidUpdate.fire(this.text);
                    return;
                }
                if (character == '<bs>' || character == '<C-h>') {
                    this.text = this.text.slice(0, -1);
                    this._onDidUpdate.fire(this.text);
                    return;
                }
                if (character == '<C-u>') {
                    this.text = '';
                    this._onDidUpdate.fire(this.text);
                    return;
                }
                if (character == '<C-n>') {
                    let text = this.history.next(this.text);
                    if (text) {
                        this.text = text;
                        this._onDidUpdate.fire(this.text);
                    }
                    return;
                }
                if (character == '<C-p>') {
                    let text = this.history.previous(this.text);
                    if (text) {
                        this.text = text;
                        this._onDidUpdate.fire(this.text);
                    }
                }
                if (character == '<esc>' || character == '<C-o>') {
                    this.deactivate();
                    return;
                }
            }
            this._onDidKeyPress.fire(character);
        }, null, this.disposables);
    }
    active() {
        this._activated = true;
        this.text = '';
        this.nvim.call('coc#prompt#start_prompt', [exports.sessionKey], true);
    }
    deactivate(node) {
        if (!this._activated)
            return;
        this.nvim.call('coc#prompt#stop_prompt', [exports.sessionKey], true);
        this._activated = false;
        let { text } = this;
        this.text = '';
        this._onDidExit.fire(node);
        this.history.add(text);
    }
    get activated() {
        return this._activated;
    }
    dispose() {
        this.deactivate();
        this._onDidKeyPress.dispose();
        this._onDidUpdate.dispose();
        this._onDidExit.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Filter;
//# sourceMappingURL=filter.js.map