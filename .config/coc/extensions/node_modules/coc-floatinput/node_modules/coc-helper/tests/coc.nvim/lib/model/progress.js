'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatMessage = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const protocol_1 = require("../util/protocol");
const notification_1 = tslib_1.__importDefault(require("./notification"));
const logger = (0, logger_1.createLogger)('model-progress');
function formatMessage(title, message, total) {
    let parts = [];
    if (title)
        parts.push(title);
    if (message)
        parts.push(message);
    if (total)
        parts.push(total + '%');
    return parts.join(' ');
}
exports.formatMessage = formatMessage;
class ProgressNotification extends notification_1.default {
    constructor(nvim, option) {
        const buttons = [{ index: 0, text: 'Cancel' }];
        super(nvim, {
            kind: 'progress',
            title: option.title,
            buttons: option.cancellable ? buttons : undefined
        }, false);
        this.option = option;
        this._onDidFinish = new protocol_1.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.cancelProgress = (bufnr) => {
            if (bufnr == this.bufnr && this.tokenSource) {
                this.tokenSource.cancel();
            }
        };
        this.disposables.push(this._onDidFinish);
        events_1.default.on('BufWinLeave', this.cancelProgress, null, this.disposables);
        if (option.cancellable) {
            events_1.default.on('FloatBtnClick', (bufnr, buttonIndex) => {
                if (buttonIndex == buttons.findIndex(button => button.text == 'Cancel')) {
                    this.cancelProgress(bufnr);
                }
            }, null, this.disposables);
        }
    }
    async show(preferences) {
        let { task } = this.option;
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        this.disposables.push(tokenSource);
        let total = 0;
        if (this.config.buttons || !preferences.disabled) {
            await super.show(preferences);
        }
        else {
            logger.warn(`progress window disabled by "notification.disabledProgressSources"`);
        }
        task({
            report: p => {
                if (!this.winid)
                    return;
                let { nvim } = this;
                if (p.increment) {
                    total += p.increment;
                    nvim.call('coc#window#set_var', [this.winid, 'percent', `${total}%`], true);
                }
                if (p.message)
                    nvim.call('coc#window#set_var', [this.winid, 'message', p.message.replace(/\r?\n/g, ' ')], true);
            }
        }, tokenSource.token).then(res => {
            this._onDidFinish.fire(res);
            this.dispose();
        }, err => {
            if (err)
                this.nvim.echoError(err);
            this._onDidFinish.fire(undefined);
            this.dispose();
        });
    }
}
exports.default = ProgressNotification;
//# sourceMappingURL=progress.js.map