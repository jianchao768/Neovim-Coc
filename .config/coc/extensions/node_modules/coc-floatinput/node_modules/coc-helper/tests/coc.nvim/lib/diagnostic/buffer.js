'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticBuffer = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const util_2 = require("./util");
const signGroup = 'CocDiagnostic';
const NAMESPACE = 'diagnostic';
// higher priority first
const hlGroups = ['CocErrorHighlight', 'CocWarningHighlight', 'CocInfoHighlight', 'CocHintHighlight', 'CocDeprecatedHighlight', 'CocUnusedHighlight'];
const delay = (0, util_1.getConditionValue)(50, 10);
const aleMethod = (0, util_1.getConditionValue)('ale#other_source#ShowResults', 'MockAleResults');
let virtualTextSrcId;
let floatFactory;
/**
 * Manage diagnostics of buffer, including:
 *
 * - highlights
 * - variable
 * - signs
 * - location list
 * - virtual text
 */
class DiagnosticBuffer {
    constructor(nvim, doc) {
        this.nvim = nvim;
        this.doc = doc;
        this.diagnosticsMap = new Map();
        this._disposed = false;
        this._dirties = new Set();
        this._refreshing = false;
        this._onDidRefresh = new protocol_1.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.loadConfiguration();
        let timer;
        let fn = () => {
            clearTimeout(timer);
            this._refreshing = true;
            timer = setTimeout(() => {
                this._refreshing = false;
                if (!this._autoRefresh)
                    return;
                void this._refresh(true);
            }, delay);
        };
        fn.clear = () => {
            this._refreshing = false;
            clearTimeout(timer);
        };
        this.refreshHighlights = fn;
    }
    get _autoRefresh() {
        return this.config.enable && this.config.autoRefresh && this.dirty && !this.doc.hasChanged;
    }
    get config() {
        return this._config;
    }
    loadConfiguration() {
        let config = workspace_1.default.getConfiguration('diagnostic', this.doc);
        let changed = this._config && config.enable != this._config.enable;
        this._config = {
            enable: config.get('enable', true),
            floatConfig: config.get('floatConfig', {}),
            messageTarget: config.get('messageTarget', 'float'),
            enableHighlightLineNumber: config.get('enableHighlightLineNumber', true),
            highlightLimit: config.get('highlightLimit', 1000),
            highlightPriority: config.get('highlightPriority'),
            autoRefresh: config.get('autoRefresh', true),
            checkCurrentLine: config.get('checkCurrentLine', false),
            enableSign: workspace_1.default.env.sign && config.get('enableSign', true),
            locationlistUpdate: config.get('locationlistUpdate', true),
            enableMessage: config.get('enableMessage', 'always'),
            virtualText: config.get('virtualText', false),
            virtualTextAlign: config.get('virtualTextAlign', 'after'),
            virtualTextWinCol: config.get('virtualTextWinCol', null),
            virtualTextCurrentLineOnly: config.get('virtualTextCurrentLineOnly'),
            virtualTextPrefix: config.get('virtualTextPrefix', " "),
            virtualTextFormat: config.get('virtualTextFormat', "%message"),
            virtualTextLimitInOneLine: config.get('virtualTextLimitInOneLine', 999),
            virtualTextLineSeparator: config.get('virtualTextLineSeparator', " \\ "),
            virtualTextLines: config.get('virtualTextLines', 3),
            displayByAle: config.get('displayByAle', false),
            level: (0, util_2.severityLevel)(config.get('level', 'hint')),
            locationlistLevel: (0, util_2.severityLevel)(config.get('locationlistLevel')),
            signLevel: (0, util_2.severityLevel)(config.get('signLevel')),
            virtualTextLevel: (0, util_2.severityLevel)(config.get('virtualTextLevel')),
            messageLevel: (0, util_2.severityLevel)(config.get('messageLevel')),
            signPriority: config.get('signPriority', 10),
            refreshOnInsertMode: config.get('refreshOnInsertMode', false),
            filetypeMap: config.get('filetypeMap', {}),
            showUnused: config.get('showUnused', true),
            showDeprecated: config.get('showDeprecated', true),
            format: config.get('format', '[%source%code] [%severity] %message'),
        };
        if (this._config.virtualText && !virtualTextSrcId) {
            void this.nvim.createNamespace('coc-diagnostic-virtualText').then(id => {
                virtualTextSrcId = id;
            });
        }
        if (changed) {
            if (this.config.enable) {
                void this._refresh(false);
            }
            else {
                this.clear();
            }
        }
    }
    async setState(enable) {
        let curr = this._config.enable;
        if (curr == enable)
            return;
        this._config.enable = enable;
        if (enable) {
            await this._refresh(false);
        }
        else {
            this.clear();
        }
    }
    get dirty() {
        return this._dirties.size > 0;
    }
    get bufnr() {
        return this.doc.bufnr;
    }
    get uri() {
        return this.doc.uri;
    }
    onChange(e) {
        let changes = e.contentChanges;
        if (changes.length > 0) {
            let edit = vscode_languageserver_types_1.TextEdit.replace(changes[0].range, changes[0].text);
            for (let [collection, diagnostics] of this.diagnosticsMap.entries()) {
                let arr = (0, util_2.adjustDiagnostics)(diagnostics, edit);
                this.diagnosticsMap.set(collection, arr);
            }
            this._dirties = new Set(this.diagnosticsMap.keys());
        }
        if (!this.config.autoRefresh)
            return;
        this.refreshHighlights();
    }
    onTextChange() {
        this._dirties = new Set(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
    }
    get displayByAle() {
        return this._config.displayByAle;
    }
    clearHighlight(collection) {
        this.buffer.clearNamespace(NAMESPACE + collection);
    }
    clearSigns(collection) {
        this.buffer.unplaceSign({ group: signGroup + collection });
    }
    get diagnostics() {
        let res = [];
        for (let diags of this.diagnosticsMap.values()) {
            res.push(...diags);
        }
        return res;
    }
    get buffer() {
        return this.nvim.createBuffer(this.bufnr);
    }
    refreshAle(collection, diagnostics) {
        let aleItems = diagnostics.map(o => {
            let range = o.range;
            return {
                text: o.message,
                code: o.code,
                lnum: range.start.line + 1,
                col: range.start.character + 1,
                end_lnum: range.end.line + 1,
                end_col: range.end.character,
                type: (0, util_2.getSeverityType)(o.severity)
            };
        });
        this.nvim.call(aleMethod, [this.bufnr, 'coc' + collection, aleItems], true);
    }
    /**
     * Update diagnostics when diagnostics change on collection.
     *
     * @param {string} collection
     * @param {Diagnostic[]} diagnostics
     */
    async update(collection, diagnostics) {
        let { diagnosticsMap } = this;
        let curr = diagnosticsMap.get(collection);
        if (!this._dirties.has(collection) && (0, array_1.isFalsyOrEmpty)(diagnostics) && (0, array_1.isFalsyOrEmpty)(curr))
            return;
        diagnosticsMap.set(collection, diagnostics);
        void this.checkFloat();
        if (!this.config.enable || (diagnostics.length > 0 && this._refreshing)) {
            this._dirties.add(collection);
            return;
        }
        let info = await this.getDiagnosticInfo(diagnostics.length === 0);
        // avoid highlights on invalid state or buffer hidden.
        if (!info || info.winid == -1) {
            this._dirties.add(collection);
            return;
        }
        let map = new Map();
        map.set(collection, diagnostics);
        this.refresh(map, info);
    }
    async checkFloat() {
        if (workspace_1.default.bufnr != this.bufnr || !floatFactory)
            return;
        let pos = await window_1.default.getCursorPosition();
        let diagnostics = this.getDiagnosticsAtPosition(pos);
        if (diagnostics.length == 0) {
            floatFactory.close();
        }
    }
    /**
     * Reset all diagnostics of current buffer
     */
    async reset(diagnostics) {
        this.refreshHighlights.clear();
        let { diagnosticsMap } = this;
        for (let key of diagnosticsMap.keys()) {
            // make sure clear collection when it's empty.
            if ((0, array_1.isFalsyOrEmpty)(diagnostics[key]))
                diagnostics[key] = [];
        }
        for (let [key, value] of Object.entries(diagnostics)) {
            diagnosticsMap.set(key, value);
        }
        this._dirties = new Set(diagnosticsMap.keys());
        await this._refresh(false);
    }
    async onCursorHold(lnum, col) {
        if (this.config.enableMessage !== 'always')
            return;
        let pos = this.doc.getPosition(lnum, col);
        await this.echoMessage(true, pos);
    }
    /**
     * Echo diagnostic message under cursor.
     */
    async echoMessage(truncate = false, position) {
        const config = this.config;
        if (!config.enable || config.enableMessage === 'never' || config.displayByAle)
            return false;
        let useFloat = config.messageTarget == 'float';
        let diagnostics = this.getDiagnosticsAtPosition(position);
        if (config.messageLevel) {
            diagnostics = diagnostics.filter(diagnostic => {
                return diagnostic.severity && diagnostic.severity <= config.messageLevel;
            });
        }
        if (useFloat) {
            await this.showFloat(diagnostics);
        }
        else {
            const lines = [];
            diagnostics.forEach(diagnostic => {
                lines.push((0, util_2.formatDiagnostic)(config.format, diagnostic));
            });
            if (lines.length) {
                await this.nvim.command('echo ""');
                await window_1.default.echoLines(lines, truncate);
            }
        }
        return true;
    }
    async showVirtualTextCurrentLine(lnum) {
        let { config } = this;
        if (!config.virtualTextCurrentLineOnly || (events_1.default.insertMode && !config.refreshOnInsertMode))
            return false;
        let enabled = await this.isEnabled();
        if (!enabled)
            return false;
        this.showVirtualText(lnum);
        return true;
    }
    async showFloat(diagnostics) {
        if (this.config.messageTarget !== 'float')
            return false;
        if (!floatFactory)
            floatFactory = window_1.default.createFloatFactory({ modes: ['n'], autoHide: true });
        if (diagnostics.length == 0) {
            floatFactory.close();
            return false;
        }
        if (events_1.default.insertMode)
            return false;
        let config = this.config;
        let ft = '';
        let docs = [];
        if (Object.keys(config.filetypeMap).length > 0) {
            let filetype = this.doc.filetype;
            const defaultFiletype = config.filetypeMap['default'] || '';
            ft = config.filetypeMap[filetype] || (defaultFiletype == 'bufferType' ? filetype : defaultFiletype);
        }
        diagnostics.forEach(diagnostic => {
            var _a;
            let filetype = 'Error';
            if (ft === '') {
                switch (diagnostic.severity) {
                    case vscode_languageserver_types_1.DiagnosticSeverity.Hint:
                        filetype = 'Hint';
                        break;
                    case vscode_languageserver_types_1.DiagnosticSeverity.Warning:
                        filetype = 'Warning';
                        break;
                    case vscode_languageserver_types_1.DiagnosticSeverity.Information:
                        filetype = 'Info';
                        break;
                }
            }
            else {
                filetype = ft;
            }
            docs.push({ filetype, content: (0, util_2.formatDiagnostic)(config.format, diagnostic) });
            if ((_a = diagnostic.codeDescription) === null || _a === void 0 ? void 0 : _a.href) {
                docs.push({ filetype: 'txt', content: diagnostic.codeDescription.href });
            }
        });
        await floatFactory.show(docs, this.config.floatConfig);
        return true;
    }
    /**
     * Get buffer info needed for refresh.
     */
    async getDiagnosticInfo(force) {
        let { refreshOnInsertMode } = this._config;
        let { nvim, bufnr } = this;
        let checkInsert = !refreshOnInsertMode;
        if (force) {
            checkInsert = false;
        }
        else {
            let disabledByInsert = events_1.default.insertMode && !refreshOnInsertMode;
            if (disabledByInsert)
                return undefined;
        }
        return await nvim.call('coc#util#diagnostic_info', [bufnr, checkInsert]);
    }
    /**
     * Refresh changed diagnostics to UI.
     */
    refresh(diagnosticsMap, info) {
        let { nvim, displayByAle } = this;
        for (let collection of diagnosticsMap.keys()) {
            this._dirties.delete(collection);
        }
        if (displayByAle) {
            nvim.pauseNotification();
            for (let [collection, diagnostics] of diagnosticsMap.entries()) {
                this.refreshAle(collection, diagnostics);
            }
            nvim.resumeNotification(true, true);
        }
        else {
            let emptyCollections = [];
            nvim.pauseNotification();
            for (let [collection, diagnostics] of diagnosticsMap.entries()) {
                if (diagnostics.length == 0)
                    emptyCollections.push(collection);
                this.addSigns(collection, diagnostics);
                this.updateHighlights(collection, diagnostics);
            }
            this.showVirtualText(info.lnum);
            this.updateLocationList(info.winid, info.locationlist);
            this.setDiagnosticInfo();
            nvim.resumeNotification(true, true);
            // cleanup unnecessary collections
            emptyCollections.forEach(name => {
                this.diagnosticsMap.delete(name);
            });
        }
        this._onDidRefresh.fire(this.diagnostics);
    }
    updateLocationList(winid, title) {
        if (!this._config.locationlistUpdate || winid == -1 || title !== 'Diagnostics of coc')
            return;
        let items = this.toLocationListItems(this.diagnostics);
        this.nvim.call('coc#ui#setloclist', [winid, items, 'r', 'Diagnostics of coc'], true);
    }
    toLocationListItems(diagnostics) {
        let { locationlistLevel } = this._config;
        let items = [];
        let lines = this.doc.textDocument.lines;
        diagnostics.sort(util_2.sortDiagnostics);
        for (let diagnostic of diagnostics) {
            if (locationlistLevel && diagnostic.severity && diagnostic.severity > locationlistLevel)
                continue;
            items.push((0, util_2.getLocationListItem)(this.bufnr, diagnostic, lines));
        }
        return items;
    }
    addSigns(collection, diagnostics) {
        let { enableSign, signLevel } = this._config;
        if (!enableSign)
            return;
        let group = signGroup + collection;
        let signs = [];
        // this.buffer.unplaceSign({ group })
        let signsMap = new Map();
        for (let diagnostic of diagnostics) {
            let { range, severity } = diagnostic;
            if (!severity || (signLevel && severity > signLevel)) {
                continue;
            }
            let line = range.start.line;
            let exists = signsMap.get(line) || [];
            if (exists.includes(severity)) {
                continue;
            }
            exists.push(severity);
            signsMap.set(line, exists);
            let priority = this._config.signPriority + 4 - severity;
            signs.push({ name: (0, util_2.getNameFromSeverity)(severity), lnum: line + 1, priority });
        }
        this.nvim.call('coc#ui#update_signs', [this.bufnr, group, signs], true);
    }
    setDiagnosticInfo() {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostics of this.diagnosticsMap.values()) {
            for (let diagnostic of diagnostics) {
                let lnum = diagnostic.range.start.line + 1;
                switch (diagnostic.severity) {
                    case vscode_languageserver_types_1.DiagnosticSeverity.Warning:
                        info.warning = info.warning + 1;
                        lnums[1] = lnums[1] ? Math.min(lnums[1], lnum) : lnum;
                        break;
                    case vscode_languageserver_types_1.DiagnosticSeverity.Information:
                        info.information = info.information + 1;
                        lnums[2] = lnums[2] ? Math.min(lnums[2], lnum) : lnum;
                        break;
                    case vscode_languageserver_types_1.DiagnosticSeverity.Hint:
                        info.hint = info.hint + 1;
                        lnums[3] = lnums[3] ? Math.min(lnums[3], lnum) : lnum;
                        break;
                    default:
                        lnums[0] = lnums[0] ? Math.min(lnums[0], lnum) : lnum;
                        info.error = info.error + 1;
                }
            }
        }
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.setVar('coc_diagnostic_info', info, true);
        this.nvim.call('coc#util#do_autocmd', ['CocDiagnosticChange'], true);
    }
    showVirtualText(lnum) {
        var _a;
        let { _config: config } = this;
        let { virtualText, virtualTextLevel } = config;
        if (!virtualText || lnum < 0)
            return;
        let { virtualTextPrefix, virtualTextLimitInOneLine, virtualTextCurrentLineOnly } = this._config;
        let { diagnostics, buffer } = this;
        if (virtualTextCurrentLineOnly) {
            diagnostics = diagnostics.filter(d => {
                let { start, end } = d.range;
                return start.line <= lnum - 1 && end.line >= lnum - 1;
            });
        }
        diagnostics.sort(util_2.sortDiagnostics);
        buffer.clearNamespace(virtualTextSrcId);
        let map = new Map();
        let opts = {
            text_align: config.virtualTextAlign,
            virt_text_win_col: config.virtualTextWinCol
        };
        for (let i = diagnostics.length - 1; i >= 0; i--) {
            let diagnostic = diagnostics[i];
            if (virtualTextLevel && diagnostic.severity && diagnostic.severity > virtualTextLevel) {
                continue;
            }
            let { line } = diagnostic.range.start;
            let highlight = (0, util_2.getNameFromSeverity)(diagnostic.severity) + 'VirtualText';
            let msg = diagnostic.message.split(/\n/)
                .map((l) => l.trim())
                .filter((l) => l.length > 0)
                .slice(0, this._config.virtualTextLines)
                .join(this._config.virtualTextLineSeparator);
            let arr = (_a = map.get(line)) !== null && _a !== void 0 ? _a : [];
            arr.unshift([virtualTextPrefix + (0, util_2.formatDiagnostic)(this._config.virtualTextFormat, Object.assign(Object.assign({}, diagnostic), { message: msg })), highlight]);
            map.set(line, arr);
        }
        for (let [line, blocks] of map.entries()) {
            buffer.setVirtualText(virtualTextSrcId, line, blocks.slice(0, virtualTextLimitInOneLine), opts);
        }
    }
    updateHighlights(collection, diagnostics) {
        if (!diagnostics.length) {
            this.clearHighlight(collection);
        }
        else {
            let items = this.getHighlightItems(diagnostics);
            let priority = this._config.highlightPriority;
            this.buffer.updateHighlights(NAMESPACE + collection, items, { priority });
        }
    }
    /**
     * Refresh all diagnostics
     */
    async _refresh(dirtyOnly) {
        let info = await this.getDiagnosticInfo(!dirtyOnly);
        if (!info || info.winid == -1 || !this.config.enable)
            return;
        let { _dirties } = this;
        if (dirtyOnly) {
            let map = new Map();
            for (let [key, diagnostics] of this.diagnosticsMap.entries()) {
                if (!_dirties.has(key))
                    continue;
                map.set(key, diagnostics);
            }
            this.refresh(map, info);
        }
        else {
            this.refresh(this.diagnosticsMap, info);
        }
    }
    getHighlightItems(diagnostics) {
        let res = [];
        for (let i = 0; i < Math.min(this._config.highlightLimit, diagnostics.length); i++) {
            let diagnostic = diagnostics[i];
            let hlGroup = (0, util_2.getHighlightGroup)(diagnostic);
            this.doc.addHighlights(res, hlGroup, diagnostic.range);
        }
        // needed for iteration performance and since diagnostic highlight may cross lines.
        res.sort((a, b) => {
            if (a.lnum != b.lnum)
                return a.lnum - b.lnum;
            if (a.colStart != b.colStart)
                return a.colStart - b.colStart;
            return hlGroups.indexOf(b.hlGroup) - hlGroups.indexOf(a.hlGroup);
        });
        return res;
    }
    /**
     * Clear all diagnostics from UI.
     */
    clear() {
        let { nvim } = this;
        let collections = Array.from(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
        this._dirties.clear();
        if (this.displayByAle) {
            for (let collection of collections) {
                this.nvim.call(aleMethod, [this.bufnr, collection, []], true);
            }
        }
        else {
            nvim.pauseNotification();
            this.buffer.deleteVar('coc_diagnostic_info');
            for (let collection of collections) {
                this.clearHighlight(collection);
                this.clearSigns(collection);
            }
            if (this._config.virtualText) {
                this.buffer.clearNamespace(virtualTextSrcId);
            }
            nvim.resumeNotification(true, true);
        }
    }
    /**
     * Get diagnostics at cursor position.
     */
    getDiagnosticsAt(pos, checkCurrentLine) {
        let diagnostics = [];
        for (let diags of this.diagnosticsMap.values()) {
            if (checkCurrentLine) {
                diagnostics.push(...diags.filter(o => (0, position_1.lineInRange)(pos.line, o.range)));
            }
            else {
                diagnostics.push(...diags.filter(o => (0, position_1.positionInRange)(pos, o.range) == 0));
            }
        }
        diagnostics.sort(util_2.sortDiagnostics);
        return diagnostics;
    }
    getDiagnosticsAtPosition(pos) {
        let { config, doc } = this;
        let res = this.getDiagnosticsAt(pos, config.checkCurrentLine);
        if (config.checkCurrentLine || res.length)
            return res;
        // check next character when cursor at end of line.
        let total = doc.getline(pos.line).length;
        if (pos.character + 1 == total) {
            res = this.getDiagnosticsAt(vscode_languageserver_types_1.Position.create(pos.line, pos.character + 1), false);
            if (res.length)
                return res;
        }
        // check next line when cursor at the beginning of last line.
        if (pos.line === doc.lineCount - 1 && pos.character == 0) {
            pos = vscode_languageserver_types_1.Position.create(pos.line + 1, 0);
            res = this.getDiagnosticsAt(pos, true);
        }
        return res;
    }
    async isEnabled() {
        if (this._disposed || !this.config.enable)
            return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let res = await buf.getVar('coc_diagnostic_disable');
        return res != 1;
    }
    dispose() {
        this.clear();
        this.diagnosticsMap.clear();
        this._onDidRefresh.dispose();
        this._disposed = true;
    }
}
exports.DiagnosticBuffer = DiagnosticBuffer;
//# sourceMappingURL=buffer.js.map