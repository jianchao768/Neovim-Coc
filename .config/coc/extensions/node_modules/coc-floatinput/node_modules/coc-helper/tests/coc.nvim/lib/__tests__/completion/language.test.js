"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const completion_1 = tslib_1.__importDefault(require("../../completion"));
const source_language_1 = require("../../completion/source-language");
const sources_1 = tslib_1.__importDefault(require("../../completion/sources"));
const types_1 = require("../../completion/types");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const manager_1 = tslib_1.__importDefault(require("../../snippets/manager"));
const util_1 = require("../../util");
const window_1 = tslib_1.__importDefault(require("../../window"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
function createCompletionItem(word) {
    return { label: word, filterText: word };
}
describe('LanguageSource util', () => {
    it('should get ultisnip option', async () => {
        let item = { label: 'label' };
        expect((0, source_language_1.getUltisnipOption)(item)).toBeUndefined();
        item.data = {};
        expect((0, source_language_1.getUltisnipOption)(item)).toBeUndefined();
        item.data.ultisnip = true;
        expect((0, source_language_1.getUltisnipOption)(item)).toBeDefined();
        item.data.ultisnip = {};
        expect((0, source_language_1.getUltisnipOption)(item)).toBeDefined();
    });
    it('should fix range from indent', async () => {
        let line = '  foo';
        let currline = 'foo';
        let range = vscode_languageserver_types_1.Range.create(0, 2, 0, 5);
        expect((0, source_language_1.fixIndent)(line, currline, range)).toBe(-2);
        expect(range).toEqual(vscode_languageserver_types_1.Range.create(0, 0, 0, 3));
        expect((0, source_language_1.fixIndent)(currline, line, range)).toBe(2);
        expect(range).toEqual(vscode_languageserver_types_1.Range.create(0, 2, 0, 5));
    });
    it('should select recent item by prefix', async () => {
        helper_1.default.updateConfiguration('suggest.selection', 'recentlyUsedByPrefix');
        let provider = {
            provideCompletionItems: async () => [{
                    label: 'fa'
                }, {
                    label: 'fb'
                }, {
                    label: 'foo',
                    kind: vscode_languageserver_types_1.CompletionItemKind.Class
                }]
        };
        disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
        completion_1.default.mru.clear();
        completion_1.default.mru.add('f', {
            kind: vscode_languageserver_types_1.CompletionItemKind.Class,
            filterText: 'foo',
            source: sources_1.default.getSource('foo'),
        });
        await nvim.setLine('f');
        await nvim.input('A');
        await nvim.call('coc#start', { source: 'foo' });
        await helper_1.default.waitPopup();
        let info = await nvim.call('coc#pum#info');
        expect(info).toBeDefined();
        expect(info.word).toBe('foo');
    });
});
describe('language source', () => {
    describe('toggle()', () => {
        it('should toggle source', () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        detail: 'detail of foo'
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            let source = sources_1.default.getSource('foo');
            expect(source).toBeDefined();
            source.toggle();
            expect(source.enable).toBe(false);
            source.toggle();
            expect(source.enable).toBe(true);
        });
    });
    describe('shouldCommit()', () => {
        it('should check commit characters', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        detail: 'detail of foo'
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider, [], 3, ['.']));
            let source = sources_1.default.getSource('foo');
            let item = createCompletionItem('foo');
            let res = source.shouldCommit(item, '.');
            expect(res).toBe(true);
        });
    });
    describe('resolveCompletionItem()', () => {
        async function getDetailContent() {
            let winid = await nvim.call('coc#float#get_float_by_kind', ['pumdetail']);
            if (!winid)
                return;
            let bufnr = await nvim.call('winbufnr', [winid]);
            let lines = await (nvim.createBuffer(bufnr)).lines;
            return lines.join('\n');
        }
        it('should return null when canceled or no items returned', async () => {
            let provider = {
                provideCompletionItems: async () => []
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider, [], 3, ['.']));
            let source = sources_1.default.getSource('foo');
            let opt = await nvim.call('coc#util#get_complete_option');
            let res = await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.Cancelled);
            expect(res).toBeNull();
            res = await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
        it('should add detail to preview when no resolve exists', async () => {
            await helper_1.default.createDocument('foo.vim');
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        detail: 'detail of foo'
                    }, {
                        label: 'bar',
                        detail: 'bar()'
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', 'vim', provider));
            let mode = await nvim.mode;
            if (mode.mode !== 'i') {
                await nvim.input('i');
            }
            nvim.call('coc#start', [{ source: 'foo' }], true);
            await helper_1.default.waitPopup();
            await helper_1.default.waitValue(async () => {
                let content = await getDetailContent();
                return content && /foo/.test(content);
            }, true);
            await nvim.input('<C-n>');
            await helper_1.default.waitValue(async () => {
                let content = await getDetailContent();
                return content && /bar/.test(content);
            }, true);
        });
        it('should add documentation to preview when no resolve exists', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        labelDetails: {},
                        documentation: 'detail of foo'
                    }, {
                        label: 'bar',
                        documentation: {
                            kind: 'plaintext',
                            value: 'bar'
                        }
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            await nvim.input('i');
            await nvim.call('coc#start', { source: 'foo' });
            await helper_1.default.waitPopup();
            await helper_1.default.wait(10);
            let content = await getDetailContent();
            expect(content).toMatch('foo');
            await nvim.input('<C-n>');
            await helper_1.default.wait(30);
            content = await getDetailContent();
            expect(content).toMatch('bar');
        });
        it('should resolve again when request cancelled', async () => {
            let count = 0;
            let cancelled = false;
            let resolved = false;
            let provider = {
                provideCompletionItems: async () => [{ label: 'bar' }],
                resolveCompletionItem: (item, token) => {
                    if (count === 0) {
                        count++;
                        return new Promise(resolve => {
                            token.onCancellationRequested(() => {
                                cancelled = true;
                                resolve(undefined);
                            });
                        });
                    }
                    resolved = true;
                    return item;
                },
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            await nvim.input('i');
            await nvim.call('coc#start', { source: 'foo' });
            await helper_1.default.waitPopup();
            await helper_1.default.waitValue(() => {
                return cancelled;
            }, true);
            nvim.call('coc#pum#close', ['confirm'], true);
            await helper_1.default.waitValue(() => {
                return resolved;
            }, true);
        });
        it('should resolve CompletionItem', async () => {
            let res;
            let n = 0;
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'this',
                        documentation: 'detail of this'
                    }],
                resolveCompletionItem: item => {
                    if (res instanceof Error) {
                        throw res;
                    }
                    else {
                        n++;
                        return res;
                    }
                }
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            let opt = await nvim.call('coc#util#get_complete_option');
            let source = sources_1.default.getSource('foo');
            await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
            let item = createCompletionItem('this');
            await source.onCompleteResolve(item, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            res = { label: 'this' };
            let p = n;
            await source.onCompleteResolve(item, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            await source.onCompleteResolve(item, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(n - p).toBe(1);
            res = new Error('resolve error');
            item = createCompletionItem('this');
            await expect(async () => {
                await source.onCompleteResolve(item, opt, vscode_languageserver_protocol_1.CancellationToken.None);
            }).rejects.toThrow(Error);
        });
    });
    describe('command', () => {
        it('should invoke command', async () => {
            let id = 'test.command';
            let item = {
                label: 'this',
                command: {
                    command: id,
                    title: id,
                    arguments: []
                }
            };
            let provider = {
                provideCompletionItems: async () => [item]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            let opt = await nvim.call('coc#util#get_complete_option');
            opt.snippetsSupport = false;
            opt.insertMode = types_1.InsertMode.Insert;
            let source = sources_1.default.getSource('foo');
            await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
            await source.onCompleteDone(item, opt);
            let called = false;
            commands_1.default.registerCommand(id, () => {
                called = true;
            });
            await source.onCompleteDone(item, opt);
            expect(called).toBe(true);
        });
    });
    describe('labelDetails', () => {
        it('should show labelDetails to documentation window', async () => {
            helper_1.default.updateConfiguration('suggest.labelMaxLength', 10);
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        labelDetails: {
                            detail: 'foo'.repeat(5)
                        }
                    }, {
                        label: 'bar',
                        labelDetails: {
                            description: 'bar'.repeat(5)
                        }
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('i');
            await nvim.call('coc#start', { source: 'edits' });
            let winid;
            await helper_1.default.waitValue(async () => {
                winid = await nvim.call('coc#float#get_float_by_kind', ['pumdetail']);
                return winid > 0;
            }, true);
            let lines = await helper_1.default.getWinLines(winid);
            expect(lines[0]).toMatch('foo');
            await nvim.call('coc#pum#_navigate', [1, 1]);
            await helper_1.default.waitValue(async () => {
                lines = await helper_1.default.getWinLines(winid);
                return lines.join(' ').includes('bar');
            }, true);
        });
    });
    describe('additionalTextEdits', () => {
        it('should fix cursor position with plain text on additionalTextEdits', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        filterText: 'foo',
                        additionalTextEdits: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'a\nbar')]
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('if');
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'barfoo');
        });
        it('should fix cursor position with snippet on additionalTextEdits', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'if',
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, 0, 0, 1), newText: 'if($1)' },
                        additionalTextEdits: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar ')],
                        preselect: true
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('ii');
            await helper_1.default.waitPopup();
            let res = await helper_1.default.items();
            let idx = res.findIndex(o => { var _a; return ((_a = o.source) === null || _a === void 0 ? void 0 : _a.name) == 'edits'; });
            await helper_1.default.confirmCompletion(idx);
            await helper_1.default.waitFor('col', ['.'], 8);
        });
        it('should fix cursor position with plain text snippet on additionalTextEdits', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'if',
                        filterText: 'if',
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, 0, 0, 2), newText: 'do$0' },
                        additionalTextEdits: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar ')],
                        preselect: true
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('iif');
            await helper_1.default.waitPopup();
            let items = await helper_1.default.items();
            let idx = items.findIndex(o => { var _a; return o.word == 'do' && ((_a = o.source) === null || _a === void 0 ? void 0 : _a.name) == 'edits'; });
            await helper_1.default.confirmCompletion(idx);
            await helper_1.default.waitFor('getline', ['.'], 'bar do');
            await helper_1.default.waitFor('col', ['.'], 7);
        });
        it('should fix cursor position with nested snippet on additionalTextEdits', async () => {
            let pos = await window_1.default.getCursorPosition();
            let range = vscode_languageserver_types_1.Range.create(pos, pos);
            let res = await commands_1.default.executeCommand('editor.action.insertSnippet', vscode_languageserver_types_1.TextEdit.replace(range, 'func($1)$0'));
            expect(res).toBe(true);
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'if',
                        filterText: 'if',
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        insertText: 'do$0',
                        additionalTextEdits: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar ')],
                        preselect: true
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('if');
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'bar func(do)');
            let [, lnum, col] = await nvim.call('getcurpos');
            expect(lnum).toBe(1);
            expect(col).toBe(12);
        });
        it('should fix cursor position and keep placeholder with snippet on additionalTextEdits', async () => {
            let text = 'foo0bar1';
            await nvim.setLine(text);
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'var',
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, text.length + 1, 0, text.length + 1), newText: '${1:foo} = foo0bar1' },
                        additionalTextEdits: [vscode_languageserver_types_1.TextEdit.del(vscode_languageserver_types_1.Range.create(0, 0, 0, text.length + 1))],
                        preselect: true
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']));
            await nvim.input('A.');
            await helper_1.default.waitPopup();
            let res = await helper_1.default.items();
            let idx = res.findIndex(o => { var _a; return ((_a = o.source) === null || _a === void 0 ? void 0 : _a.name) == 'edits'; });
            await helper_1.default.confirmCompletion(idx);
            await helper_1.default.waitFor('getline', ['.'], 'foo = foo0bar1');
            await helper_1.default.wait(50);
            expect(manager_1.default.session).toBeDefined();
            let [, lnum, col] = await nvim.call('getcurpos');
            expect(lnum).toBe(1);
            expect(col).toBe(3);
        });
        it('should cancel current snippet session when additionalTextEdits inside snippet', async () => {
            await nvim.input('i');
            manager_1.default.cancel();
            let pos = await window_1.default.getCursorPosition();
            let range = vscode_languageserver_types_1.Range.create(pos, pos);
            await commands_1.default.executeCommand('editor.action.insertSnippet', vscode_languageserver_types_1.TextEdit.replace(range, 'foo($1, $2)$0'), true);
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'bar',
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, 4, 0, 5), newText: 'bar($1)' },
                        additionalTextEdits: [vscode_languageserver_types_1.TextEdit.del(vscode_languageserver_types_1.Range.create(0, 0, 0, 3))]
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']));
            await nvim.input('b');
            await helper_1.default.waitPopup();
            let res = await helper_1.default.items();
            let idx = res.findIndex(o => { var _a; return ((_a = o.source) === null || _a === void 0 ? void 0 : _a.name) == 'edits'; });
            await helper_1.default.confirmCompletion(idx);
            await helper_1.default.waitFor('col', ['.'], 6);
            await helper_1.default.waitFor('getline', ['.'], '(bar(), )');
        });
    });
    describe('filterText', () => {
        it('should fix input for snippet item', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        filterText: 'foo',
                        insertText: '${1:foo}($2)',
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('snippets-test', 'st', null, provider));
            await nvim.input('if');
            await helper_1.default.waitPopup();
            await nvim.call('coc#pum#select', [0, 1, 0]);
            await helper_1.default.waitFor('getline', ['.'], 'foo()');
        });
        it('should fix filterText of complete item', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'name',
                        sortText: '11',
                        textEdit: {
                            range: vscode_languageserver_types_1.Range.create(0, 1, 0, 2),
                            newText: '?.name'
                        }
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('name', 'N', null, provider, ['.']));
            await nvim.setLine('t');
            await nvim.input('A.');
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            let line = await nvim.line;
            expect(line).toBe('t?.name');
        });
    });
    describe('inComplete result', () => {
        it('should filter in complete request', async () => {
            let provider = {
                provideCompletionItems: async (doc, pos, token, context) => {
                    let option = context.option;
                    if (context.triggerCharacter == '.') {
                        return {
                            isIncomplete: true,
                            items: [
                                {
                                    label: 'foo'
                                }, {
                                    label: 'bar'
                                }
                            ]
                        };
                    }
                    if (option.input == 'f') {
                        if (token.isCancellationRequested)
                            return;
                        return {
                            isIncomplete: true,
                            items: [
                                {
                                    label: 'foo'
                                }
                            ]
                        };
                    }
                    if (option.input == 'fo') {
                        if (token.isCancellationRequested)
                            return;
                        return {
                            isIncomplete: false,
                            items: [
                                {
                                    label: 'foo'
                                }
                            ]
                        };
                    }
                }
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']));
            await nvim.input('i.');
            await helper_1.default.waitPopup();
            await nvim.input('fo');
            await helper_1.default.waitValue(async () => {
                let items = await helper_1.default.items();
                return items.length;
            }, 1);
        });
    });
    describe('itemDefaults', () => {
        async function start(item, itemDefaults) {
            let provider = {
                provideCompletionItems: async () => {
                    return { items: [item], itemDefaults, isIncomplete: false };
                }
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('test', 't', null, provider));
            await nvim.input('i');
            nvim.call('coc#start', [{ source: 'test' }], true);
            await helper_1.default.waitPopup();
        }
        it('should use commitCharacters from itemDefaults', async () => {
            helper_1.default.updateConfiguration('suggest.acceptSuggestionOnCommitCharacter', true);
            await start({ label: 'foo' }, { commitCharacters: ['.'] });
            await nvim.input('.');
            await helper_1.default.waitFor('getline', ['.'], 'foo.');
        });
        it('should use range of editRange from itemDefaults', async () => {
            await nvim.call('setline', ['.', 'bar']);
            await start({ label: 'foo' }, {
                editRange: vscode_languageserver_types_1.Range.create(0, 0, 0, 3)
            });
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'foo');
        });
        it('should use replace range of editRange from itemDefaults', async () => {
            await nvim.call('setline', ['.', 'bar']);
            await start({ label: 'foo' }, {
                editRange: {
                    insert: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                    replace: vscode_languageserver_types_1.Range.create(0, 0, 0, 3),
                }
            });
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'foo');
        });
        it('should use insertTextFormat from itemDefaults', async () => {
            await start({ label: 'foo', insertText: 'foo($1)$0' }, {
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                insertTextMode: vscode_languageserver_types_1.InsertTextMode.asIs,
                data: {}
            });
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'foo()');
        });
    });
    describe('textEdit', () => {
        it('should not apply edits when line changed', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        textEdit: vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo($1)'),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            let source = sources_1.default.getSource('foo');
            expect(source).toBeDefined();
            let opt = await nvim.call('coc#util#get_complete_option');
            await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
            let item = createCompletionItem('foo');
            await nvim.call('append', [0, ['', '']]);
            await nvim.command('normal! G');
            await source.onCompleteDone(item, opt);
            let line = await nvim.line;
            expect(line).toBe('');
        });
        it('should use insert range', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        insertText: 'foo'
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('foo', 'f', null, provider));
            let source = sources_1.default.getSource('foo');
            expect(source).toBeDefined();
            await nvim.setLine('foo');
            await nvim.input('I');
            let opt = await nvim.call('coc#util#get_complete_option');
            opt.insertMode = types_1.InsertMode.Insert;
            await source.doComplete(opt, vscode_languageserver_protocol_1.CancellationToken.None);
            let item = createCompletionItem('foo');
            await source.onCompleteDone(item, opt);
            let line = await nvim.line;
            expect(line).toBe('foofoo');
        });
        it('should fix replace range for paired characters', async () => {
            // LS may failed to replace paired character at the end
            await nvim.setLine('<>');
            await nvim.input('i<right>');
            let provider = {
                provideCompletionItems: async () => [{
                        label: '<foo>',
                        filterText: '<foo>',
                        // bad range
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0), newText: '<foo>' },
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            nvim.call('coc#start', [{ source: 'edits' }], true);
            await helper_1.default.waitPopup();
            let idx = completion_1.default.activeItems.findIndex(o => o.word == '<foo>');
            expect(idx).toBeGreaterThan(-1);
            await helper_1.default.confirmCompletion(idx);
            await helper_1.default.waitFor('getline', ['.'], '<foo>');
        });
        it('should fix bad range', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: 'foo',
                        filterText: 'foo',
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0), newText: 'foo' },
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('i');
            nvim.call('coc#start', [{ source: 'edits' }], true);
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'foo');
        });
        it('should applyEdits for empty word', async () => {
            let provider = {
                provideCompletionItems: async () => [{
                        label: '',
                        filterText: '!',
                        textEdit: { range: vscode_languageserver_types_1.Range.create(0, 0, 0, 1), newText: 'foo' },
                        data: { word: '' }
                    }]
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider, ['!']));
            await nvim.input('i!');
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'foo');
        });
        it('should provide word when textEdit after startcol', async () => {
            // some LS would send textEdit after first character,
            // need fix the word from newText
            let provider = {
                provideCompletionItems: async (_, position) => {
                    if (position.line != 0)
                        return null;
                    return [{
                            label: 'bar',
                            textEdit: {
                                range: vscode_languageserver_types_1.Range.create(0, 1, 0, 1),
                                newText: 'bar'
                            }
                        }, {
                            label: 'bad',
                            textEdit: {
                                replace: vscode_languageserver_types_1.Range.create(0, 1, 0, 1),
                                insert: vscode_languageserver_types_1.Range.create(0, 1, 0, 1),
                                newText: 'bad'
                            }
                        }];
                }
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('edits', 'edit', null, provider));
            await nvim.input('ib');
            await helper_1.default.waitPopup();
            let items = completion_1.default.activeItems;
            expect(items[0].word).toBe('bar');
        });
        it('should adjust completion position by textEdit start position', async () => {
            let provider = {
                provideCompletionItems: async (_document, _position, _token, context) => {
                    if (!context.triggerCharacter)
                        return;
                    return [{
                            label: 'foo',
                            textEdit: {
                                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 1),
                                newText: '?foo'
                            }
                        }];
                }
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('fix', 'f', null, provider, ['?']));
            await nvim.input('i?');
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            let line = await nvim.line;
            expect(line).toBe('?foo');
        });
        it('should fix range of removed text range', async () => {
            let provider = {
                provideCompletionItems: async () => {
                    return [{
                            label: 'React',
                            textEdit: {
                                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 8),
                                newText: 'import React$1 from "react"'
                            },
                            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
                        }];
                }
            };
            disposables.push(languages_1.default.registerCompletionItemProvider('fix', 'f', null, provider, ['?']));
            await nvim.call('setline', ['.', 'import r;']);
            await nvim.call('cursor', [1, 8]);
            await nvim.input('a');
            await nvim.call('coc#start', { source: 'fix' });
            await helper_1.default.waitPopup();
            await helper_1.default.confirmCompletion(0);
            await helper_1.default.waitFor('getline', ['.'], 'import React from "react";');
        });
    });
});
//# sourceMappingURL=language.test.js.map