"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WordDistance = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importDefault(require("../languages"));
const array_1 = require("../util/array");
const object_1 = require("../util/object");
const Is = tslib_1.__importStar(require("../util/is"));
const position_1 = require("../util/position");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const util_1 = require("../util");
class WordDistance {
    static async create(localityBonus, opt, token) {
        let { position } = opt;
        let cursor = [opt.linenr, opt.colnr];
        if (!localityBonus)
            return WordDistance.None;
        let doc = workspace_1.default.getDocument(opt.bufnr);
        const selectionRanges = await languages_1.default.getSelectionRanges(doc.textDocument, [position], token);
        if (!selectionRanges || token.isCancellationRequested)
            return WordDistance.None;
        let ranges = [];
        const iterate = (r) => {
            if (r && r.range.end.line - r.range.start.line < 2000) {
                ranges.unshift(r.range);
                iterate(r.parent);
            }
        };
        iterate((0, array_1.toArray)(selectionRanges)[0]);
        let wordRanges = ranges.length > 0 ? await Promise.race([(0, util_1.waitWithToken)(100, token), workspace_1.default.computeWordRanges(opt.bufnr, ranges[0], token)]) : undefined;
        if (!Is.objectLiteral(wordRanges))
            return WordDistance.None;
        // remove current word
        delete wordRanges[opt.word];
        return new class extends WordDistance {
            // Unlike VSCode, word insert position is used here
            distance(anchor, item) {
                if (!(0, object_1.equals)([events_1.default.cursor.lnum, events_1.default.cursor.col], cursor)) {
                    return 0;
                }
                if (item.kind === vscode_languageserver_types_1.CompletionItemKind.Keyword || (0, object_1.toObject)(item.source)['name'] === 'snippets') {
                    return 2 << 20;
                }
                const wordLines = wordRanges[item.word];
                if ((0, array_1.isFalsyOrEmpty)(wordLines)) {
                    return 2 << 20;
                }
                const idx = (0, array_1.binarySearch)(wordLines, vscode_languageserver_types_1.Range.create(anchor, anchor), position_1.compareRangesUsingStarts);
                const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
                let blockDistance = ranges.length;
                for (const range of ranges) {
                    if (!(0, position_1.rangeInRange)(bestWordRange, range)) {
                        break;
                    }
                    blockDistance -= 1;
                }
                return blockDistance;
            }
        }();
    }
}
exports.WordDistance = WordDistance;
WordDistance.None = new class extends WordDistance {
    distance() { return 0; }
}();
//# sourceMappingURL=wordDistance.js.map