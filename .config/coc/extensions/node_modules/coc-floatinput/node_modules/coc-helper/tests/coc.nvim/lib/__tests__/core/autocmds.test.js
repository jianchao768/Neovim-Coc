"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const autocmds_1 = require("../../core/autocmds");
const events_1 = tslib_1.__importDefault(require("../../events"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
    (0, util_1.disposeAll)(disposables);
});
describe('watchers', () => {
    it('should watch options', async () => {
        await events_1.default.fire('OptionSet', ['showmode', 0, 1]);
        let times = 0;
        let fn = () => {
            times++;
        };
        let disposable = workspace_1.default.watchOption('showmode', fn);
        disposables.push(workspace_1.default.watchOption('showmode', jest.fn()));
        nvim.command('set showmode', true);
        expect(workspace_1.default.watchers.options.length).toBeGreaterThan(0);
        await helper_1.default.waitValue(() => times, 1);
        disposable.dispose();
        nvim.command('set noshowmode', true);
        await helper_1.default.wait(20);
        expect(times).toBe(1);
    });
    it('should watch global', async () => {
        await events_1.default.fire('GlobalChange', ['x', 0, 1]);
        let times = 0;
        let fn = () => {
            times++;
        };
        let disposable = workspace_1.default.watchGlobal('x', fn);
        workspace_1.default.watchGlobal('x', undefined, disposables);
        workspace_1.default.watchGlobal('x', undefined, disposables);
        await nvim.command('let g:x = 1');
        await helper_1.default.waitValue(() => times, 1);
        disposable.dispose();
        await nvim.command('let g:x = 2');
        await helper_1.default.wait(20);
        expect(times).toBe(1);
    });
    it('should show error on watch callback error', async () => {
        let called = false;
        let fn = () => {
            called = true;
            throw new Error('error');
        };
        workspace_1.default.watchOption('showmode', fn, disposables);
        nvim.command('set showmode', true);
        await helper_1.default.waitValue(() => called, true);
        let line = await helper_1.default.getCmdline();
        expect(line).toMatch('Error on OptionSet');
        called = false;
        workspace_1.default.watchGlobal('y', fn, disposables);
        await nvim.command('let g:y = 2');
        await helper_1.default.waitValue(() => called, true);
        line = await helper_1.default.getCmdline();
        expect(line).toMatch('Error on GlobalChange');
    });
});
describe('contentProvider', () => {
    it('should not throw for scheme not registered', async () => {
        await workspace_1.default.contentProvider.onBufReadCmd('not_exists', '');
    });
    it('should register document content provider', async () => {
        let provider = {
            provideTextDocumentContent: (_uri, _token) => 'sample text'
        };
        workspace_1.default.registerTextDocumentContentProvider('test', provider);
        await nvim.command('edit test://1');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual(['sample text']);
    });
    it('should react on change event of document content provider', async () => {
        let text = 'foo';
        let emitter = new vscode_languageserver_protocol_1.Emitter();
        let event = emitter.event;
        let provider = {
            onDidChange: event,
            provideTextDocumentContent: (_uri, _token) => text
        };
        workspace_1.default.registerTextDocumentContentProvider('jdk', provider);
        await nvim.command('edit jdk://1');
        let doc = await workspace_1.default.document;
        text = 'bar';
        emitter.fire(vscode_uri_1.URI.parse('jdk://1'));
        await helper_1.default.waitFor('getline', ['.'], 'bar');
        await nvim.command('bwipeout!');
        await helper_1.default.waitValue(() => doc.attached, false);
        emitter.fire(vscode_uri_1.URI.parse('jdk://1'));
    });
});
describe('setupDynamicAutocmd()', () => {
    it('should create command', async () => {
        let callback = () => { };
        expect((0, autocmds_1.createCommand)(1, { callback, event: 'event', arglist: [], pattern: '*', request: true })).toMatch('event');
        expect((0, autocmds_1.createCommand)(1, { callback, event: 'event', arglist: ['foo'] })).toMatch('foo');
        expect((0, autocmds_1.createCommand)(1, { callback, event: ['foo', 'bar'], arglist: [] })).toMatch('foo');
        expect((0, autocmds_1.createCommand)(1, { callback, event: 'user Event', arglist: [] })).toMatch('user');
    });
    it('should setup autocmd on vim', async () => {
        await nvim.setLine('foo');
        let called = false;
        let disposable = workspace_1.default.registerAutocmd({
            event: 'CursorMoved',
            request: true,
            callback: () => {
                called = true;
            }
        });
        await helper_1.default.wait(10);
        await nvim.command('normal! $');
        await helper_1.default.waitValue(() => called, true);
        expect(called).toBe(true);
        disposable.dispose();
    });
    it('should setup user autocmd', async () => {
        let called = false;
        workspace_1.default.registerAutocmd({
            event: 'User CocJumpPlaceholder',
            request: true,
            callback: () => {
                called = true;
            }
        });
        workspace_1.default.autocmds.resetDynamicAutocmd();
        await helper_1.default.wait(10);
        await nvim.command('doautocmd <nomodeline> User CocJumpPlaceholder');
        await helper_1.default.waitValue(() => called, true);
    });
});
describe('doAutocmd()', () => {
    it('should not throw when command id does not exist', async () => {
        await workspace_1.default.autocmds.doAutocmd(999, []);
    });
    it('should dispose', async () => {
        workspace_1.default.autocmds.dispose();
    });
});
//# sourceMappingURL=autocmds.test.js.map