'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
class ContentProvider {
    constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.providers = new Map();
        this._onDidProviderChange = new protocol_1.Emitter();
        this.onDidProviderChange = this._onDidProviderChange.event;
    }
    attach(nvim) {
        this.nvim = nvim;
        events_1.default.on('BufReadCmd', this.onBufReadCmd, this, this.disposables);
    }
    get schemes() {
        return Array.from(this.providers.keys());
    }
    async onBufReadCmd(scheme, uri) {
        let provider = this.providers.get(scheme);
        if (!provider)
            return;
        let tokenSource = new protocol_1.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(vscode_uri_1.URI.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines((0, string_1.toText)(content).split(/\r?\n/), {
            start: 0,
            end: -1,
            strictIndexing: false
        });
        process.nextTick(() => {
            void events_1.default.fire('BufCreate', [buf.id]);
        });
    }
    resetAutocmds() {
        let { nvim, schemes } = this;
        nvim.pauseNotification();
        nvim.command(`autocmd! coc_dynamic_content`, true);
        for (let scheme of schemes) {
            nvim.command(getAutocmdCommand(scheme), true);
        }
        nvim.resumeNotification(false, true);
    }
    registerTextDocumentContentProvider(scheme, provider) {
        this.providers.set(scheme, provider);
        this._onDidProviderChange.fire();
        let disposables = [];
        if (provider.onDidChange) {
            provider.onDidChange(async (uri) => {
                let doc = this.documents.getDocument(uri.toString());
                if (!doc)
                    return;
                let tokenSource = new protocol_1.CancellationTokenSource();
                let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
                await doc.buffer.setLines(content.split(/\r?\n/), {
                    start: 0,
                    end: -1,
                    strictIndexing: false
                });
            }, null, disposables);
        }
        this.nvim.command(getAutocmdCommand(scheme), true);
        return protocol_1.Disposable.create(() => {
            this.providers.delete(scheme);
            (0, util_1.disposeAll)(disposables);
            this.resetAutocmds();
            this._onDidProviderChange.fire();
        });
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
        this._onDidProviderChange.dispose();
        this.providers.clear();
    }
}
exports.default = ContentProvider;
function getAutocmdCommand(scheme) {
    let rhs = `call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<afile>')]) | filetype detect`;
    return `autocmd! coc_dynamic_content BufReadCmd,FileReadCmd,SourceCmd ${scheme}:/* ${rhs}`;
}
//# sourceMappingURL=contentProvider.js.map