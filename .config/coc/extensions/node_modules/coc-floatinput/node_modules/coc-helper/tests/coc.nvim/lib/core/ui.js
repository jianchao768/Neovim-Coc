'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectRange = exports.getSelection = exports.toMessageLevel = exports.echoMessages = exports.echoLines = exports.getCursorScreenPosition = exports.getOffset = exports.moveTo = exports.showPrompt = exports.createFloatFactory = exports.getLineAndPosition = exports.getCursorPosition = exports.MessageLevel = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const floatFactory_1 = tslib_1.__importDefault(require("../model/floatFactory"));
const constants_1 = require("../util/constants");
const string_1 = require("../util/string");
const operateModes = ['char', 'line', 'block'];
var MessageLevel;
(function (MessageLevel) {
    MessageLevel[MessageLevel["More"] = 0] = "More";
    MessageLevel[MessageLevel["Warning"] = 1] = "Warning";
    MessageLevel[MessageLevel["Error"] = 2] = "Error";
})(MessageLevel = exports.MessageLevel || (exports.MessageLevel = {}));
async function getCursorPosition(nvim) {
    // vim can't count utf16
    let [line, content] = await nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
    return vscode_languageserver_types_1.Position.create(line, content.length);
}
exports.getCursorPosition = getCursorPosition;
async function getLineAndPosition(nvim) {
    let [text, lnum, content] = await nvim.eval(`[getline('.'), line('.'), strpart(getline('.'), 0, col('.') - 1)]`);
    return { text, line: lnum - 1, character: content.length };
}
exports.getLineAndPosition = getLineAndPosition;
function createFloatFactory(nvim, conf, defaults) {
    let opts = Object.assign({}, defaults, conf);
    let factory = new floatFactory_1.default(nvim);
    return {
        get window() {
            return factory.window;
        },
        show: (docs, option) => {
            return factory.show(docs, option ? Object.assign({}, opts, option) : opts);
        },
        activated: () => {
            return factory.activated();
        },
        dispose: () => {
            factory.dispose();
        },
        checkRetrigger: bufnr => {
            return factory.checkRetrigger(bufnr);
        },
        close: () => {
            factory.close();
        }
    };
}
exports.createFloatFactory = createFloatFactory;
/**
 * Prompt user for confirm, a float/popup window would be used when possible,
 * use vim's |confirm()| function as callback.
 *
 * @param title The prompt text.
 * @returns Result of confirm.
 */
async function showPrompt(nvim, title) {
    let res = await nvim.callAsync('coc#dialog#prompt_confirm', [title]);
    return res == 1;
}
exports.showPrompt = showPrompt;
/**
 * Move cursor to position.
 *
 * @param position LSP position.
 */
async function moveTo(nvim, position, redraw) {
    await nvim.call('coc#cursor#move_to', [position.line, position.character]);
    if (redraw)
        nvim.command('redraw', true);
}
exports.moveTo = moveTo;
/**
 * Get current cursor character offset in document,
 * length of line break would always be 1.
 *
 * @returns Character offset.
 */
async function getOffset(nvim) {
    return await nvim.call('coc#cursor#char_offset');
}
exports.getOffset = getOffset;
/**
 * Get screen position of current cursor(relative to editor),
 * both `row` and `col` are 0 based.
 *
 * @returns Cursor screen position.
 */
async function getCursorScreenPosition(nvim) {
    let [row, col] = await nvim.call('coc#cursor#screen_pos');
    return { row, col };
}
exports.getCursorScreenPosition = getCursorScreenPosition;
async function echoLines(nvim, env, lines, truncate) {
    let cmdHeight = env.cmdheight;
    if (lines.length > cmdHeight && truncate) {
        lines = lines.slice(0, cmdHeight);
    }
    let maxLen = env.columns - 12;
    lines = lines.map(line => {
        line = line.replace(/\n/g, ' ');
        if (truncate)
            line = line.slice(0, maxLen);
        return line;
    });
    if (truncate && lines.length == cmdHeight) {
        let last = lines[lines.length - 1];
        lines[cmdHeight - 1] = `${last.length >= maxLen ? last.slice(0, -4) : last} ...`;
    }
    await nvim.call('coc#ui#echo_lines', [lines]);
}
exports.echoLines = echoLines;
/**
 * Reveal message with highlight.
 */
function echoMessages(nvim, msg, messageType, messageLevel) {
    let hl = 'Error';
    let level = MessageLevel.Error;
    switch (messageType) {
        case 'more':
            level = MessageLevel.More;
            hl = 'MoreMsg';
            break;
        case 'warning':
            level = MessageLevel.Warning;
            hl = 'WarningMsg';
            break;
    }
    if (level >= toMessageLevel(messageLevel)) {
        let method = constants_1.isVim ? 'callTimer' : 'call';
        nvim[method]('coc#ui#echo_messages', [hl, ('[coc.nvim] ' + msg).split('\n')], true);
    }
}
exports.echoMessages = echoMessages;
function toMessageLevel(level) {
    switch (level) {
        case 'error':
            return MessageLevel.Error;
        case 'warning':
            return MessageLevel.Warning;
        default:
            return MessageLevel.More;
    }
}
exports.toMessageLevel = toMessageLevel;
/**
 * Mode could be 'char', 'line', 'cursor', 'v', 'V', '\x16'
 */
async function getSelection(nvim, mode) {
    if (mode === 'currline') {
        let line = await nvim.call('line', ['.']);
        return vscode_languageserver_types_1.Range.create(line - 1, 0, line, 0);
    }
    if (mode === 'cursor') {
        let position = await getCursorPosition(nvim);
        return vscode_languageserver_types_1.Range.create(position, position);
    }
    let res = await nvim.call('coc#cursor#get_selection', [operateModes.includes(mode) ? 1 : 0]);
    if (!res || res[0] == -1)
        return null;
    return vscode_languageserver_types_1.Range.create(res[0], res[1], res[2], res[3]);
}
exports.getSelection = getSelection;
async function selectRange(nvim, range, redraw) {
    let { start, end } = range;
    let [line, endLine] = await nvim.eval(`[getline(${start.line + 1}),getline(${end.line + 1})]`);
    let col = line.length > 0 ? (0, string_1.byteIndex)(line, start.character) : 0;
    let endCol;
    let endLnum;
    let toEnd = end.character == 0;
    if (toEnd) {
        endLnum = end.line == 0 ? 0 : end.line - 1;
        let pre = await nvim.call('getline', [endLnum + 1]);
        endCol = (0, string_1.byteLength)(pre);
    }
    else {
        endLnum = end.line;
        endCol = endLine.length > 0 ? (0, string_1.byteIndex)(endLine, end.character) : 0;
    }
    nvim.pauseNotification();
    nvim.command(`noa call cursor(${start.line + 1},${col + 1})`, true);
    nvim.command('normal! v', true);
    nvim.command(`noa call cursor(${endLnum + 1},${endCol})`, true);
    if (toEnd)
        nvim.command('normal! $', true);
    await nvim.resumeNotification(redraw);
}
exports.selectRange = selectRange;
//# sourceMappingURL=ui.js.map