'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const LocationsDataProvider_1 = tslib_1.__importDefault(require("../tree/LocationsDataProvider"));
const TreeView_1 = tslib_1.__importDefault(require("../tree/TreeView"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const lodash_1 = require("../util/lodash");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
var ShowHierarchyAction;
(function (ShowHierarchyAction) {
    ShowHierarchyAction["Incoming"] = "Show Incoming Calls";
    ShowHierarchyAction["Outgoing"] = "Show Outgoing Calls";
})(ShowHierarchyAction || (ShowHierarchyAction = {}));
/**
 * Cleanup properties used by treeview
 */
function toCallHierarchyItem(item) {
    return (0, lodash_1.omit)(item, ['children', 'parent', 'ranges', 'sourceUri']);
}
function isCallHierarchyItem(item) {
    if (item && typeof item.name === 'string' && item.kind && vscode_languageserver_types_1.Range.is(item.range))
        return true;
    return false;
}
class CallHierarchyHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = new Set();
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.disposables.push(commands_1.default.registerCommand(CallHierarchyHandler.commandId, async (winid, item, openCommand) => {
            var _a;
            let { nvim } = this;
            await nvim.call('win_gotoid', [winid]);
            await workspace_1.default.jumpTo(item.uri, item.selectionRange.start, openCommand);
            let win = await nvim.window;
            win.clearMatchGroup(CallHierarchyHandler.rangesHighlight);
            win.highlightRanges(CallHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
            if (!((_a = item.ranges) === null || _a === void 0 ? void 0 : _a.length))
                return;
            if (item.sourceUri) {
                let doc = workspace_1.default.getDocument(item.sourceUri);
                if (!doc)
                    return;
                let winid = await nvim.call('coc#compat#buf_win_id', [doc.bufnr]);
                if (winid == -1)
                    return;
                if (winid != win.id) {
                    win = nvim.createWindow(winid);
                    win.clearMatchGroup(CallHierarchyHandler.rangesHighlight);
                }
            }
            win.highlightRanges(CallHierarchyHandler.rangesHighlight, item.ranges, 100, true);
            this.highlightWinids.add(win.id);
        }, null, true));
        events_1.default.on('BufWinEnter', (_, winid) => {
            if (this.highlightWinids.has(winid)) {
                this.highlightWinids.delete(winid);
                let win = nvim.createWindow(winid);
                win.clearMatchGroup(CallHierarchyHandler.rangesHighlight);
            }
        }, null, this.disposables);
        commands_1.default.register({
            id: 'document.showIncomingCalls',
            execute: async () => {
                await this.showCallHierarchyTree('incoming');
            }
        }, false, 'show incoming calls in tree view.');
        commands_1.default.register({
            id: 'document.showOutgoingCalls',
            execute: async () => {
                await this.showCallHierarchyTree('outgoing');
            }
        }, false, 'show outgoing calls in tree view.');
    }
    loadConfiguration(e) {
        if (!e || e.affectsConfiguration('callHierarchy')) {
            let c = workspace_1.default.getConfiguration('callHierarchy', null);
            this.config = {
                splitCommand: c.get('splitCommand'),
                openCommand: c.get('openCommand'),
                enableTooltip: c.get('enableTooltip')
            };
        }
    }
    createProvider(rootItems, doc, winid, kind) {
        let provider = new LocationsDataProvider_1.default(kind, winid, this.config, CallHierarchyHandler.commandId, rootItems, kind => this.handler.getIcon(kind), (el, meta, token) => this.getChildren(doc, el, meta, token));
        for (let kind of ['incoming', 'outgoing']) {
            let name = kind === 'incoming' ? ShowHierarchyAction.Incoming : ShowHierarchyAction.Outgoing;
            provider.addAction(name, (el) => {
                provider.meta = kind;
                let rootItems = [toCallHierarchyItem(el)];
                provider.reset(rootItems);
            });
        }
        return provider;
    }
    async getChildren(doc, item, kind, token) {
        let items = [];
        let callHierarchyItem = toCallHierarchyItem(item);
        if (kind == 'incoming') {
            let res = await languages_1.default.provideIncomingCalls(doc, callHierarchyItem, token);
            if (res)
                items = res.map(o => Object.assign(o.from, { ranges: o.fromRanges }));
        }
        else {
            let res = await languages_1.default.provideOutgoingCalls(doc, callHierarchyItem, token);
            if (res)
                items = res.map(o => Object.assign(o.to, { ranges: o.fromRanges, sourceUri: item.uri }));
        }
        return items;
    }
    async prepare(doc, position, token) {
        this.handler.checkProvider(languages_1.ProviderName.CallHierarchy, doc);
        const res = await languages_1.default.prepareCallHierarchy(doc, position, token);
        return isCallHierarchyItem(res) ? [res] : res;
    }
    async getCallHierarchyItems(item, kind) {
        const { doc, position } = await this.handler.getCurrentState();
        const source = new protocol_1.CancellationTokenSource();
        if (!item) {
            await doc.synchronize();
            let res = await this.prepare(doc.textDocument, position, source.token);
            item = res ? res[0] : undefined;
            if (!res)
                throw new Error('Unable to getCallHierarchyItem at current position');
        }
        let method = kind == 'incoming' ? 'provideIncomingCalls' : 'provideOutgoingCalls';
        return await languages_1.default[method](doc.textDocument, item, source.token);
    }
    async getIncoming(item) {
        return await this.getCallHierarchyItems(item, 'incoming');
    }
    async getOutgoing(item) {
        return await this.getCallHierarchyItems(item, 'outgoing');
    }
    async showCallHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        if (!languages_1.default.hasProvider(languages_1.ProviderName.CallHierarchy, doc.textDocument)) {
            void window_1.default.showErrorMessage(`CallHierarchy provider not found for current document, it's not supported by your languageserver`);
            return;
        }
        const res = await languages_1.default.prepareCallHierarchy(doc.textDocument, position, protocol_1.CancellationToken.None);
        const rootItems = isCallHierarchyItem(res) ? [res] : res;
        if ((0, array_1.isFalsyOrEmpty)(rootItems)) {
            void window_1.default.showWarningMessage('Unable to get CallHierarchyItem at cursor position.');
            return;
        }
        let provider = this.createProvider(rootItems, doc.textDocument, winid, kind);
        let treeView = new TreeView_1.default('calls', { treeDataProvider: provider });
        treeView.title = getTitle(kind);
        provider.onDidChangeTreeData(e => {
            if (!e)
                treeView.title = getTitle(provider.meta);
        });
        treeView.onDidChangeVisibility(e => {
            if (!e.visible)
                provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
    }
    dispose() {
        this.highlightWinids.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = CallHierarchyHandler;
CallHierarchyHandler.commandId = 'callHierarchy.reveal';
CallHierarchyHandler.rangesHighlight = 'CocSelectedRange';
function getTitle(kind) {
    return `${kind.toUpperCase()} CALLS`;
}
//# sourceMappingURL=callHierarchy.js.map