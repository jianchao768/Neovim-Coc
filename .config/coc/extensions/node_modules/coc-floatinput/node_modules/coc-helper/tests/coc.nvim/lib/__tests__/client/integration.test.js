"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert = tslib_1.__importStar(require("assert"));
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const node_1 = require("vscode-languageserver-protocol/node");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const lsclient = tslib_1.__importStar(require("../../language-client"));
const language_client_1 = require("../../language-client");
const features_1 = require("../../language-client/features");
const util_1 = require("../../util");
const errors_1 = require("../../util/errors");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
});
afterEach(() => {
    (0, util_1.disposeAll)(disposables);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('SettingMonitor', () => {
    it('should setup SettingMonitor', async () => {
        let clientOptions = {};
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.ipc
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        client.onNotification('customNotification', () => {
        });
        client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, '4fb247f8-0ede-415d-a80a-6629b6a9eaf8', () => {
        });
        await client.start();
        let monitor = new lsclient.SettingMonitor(client, 'html.enabled');
        let disposable = monitor.start();
        helper_1.default.updateConfiguration('html.enabled', false);
        await helper_1.default.waitValue(() => {
            return client.state;
        }, lsclient.State.Stopped);
        await helper_1.default.wait(50);
        helper_1.default.updateConfiguration('html.enabled', true);
        await helper_1.default.waitValue(() => {
            return client.state != lsclient.State.Stopped;
        }, true);
        await client.onReady();
        await client.stop();
        disposable.dispose();
    });
});
describe('global functions', () => {
    it('should get working directory', async () => {
        let cwd = await lsclient.getServerWorkingDir();
        expect(cwd).toBeDefined();
        cwd = await lsclient.getServerWorkingDir({ cwd: 'not_exists' });
        expect(cwd).toBeUndefined();
    });
    it('should get main root', async () => {
        expect(lsclient.mainGetRootPath()).toBeUndefined();
        let uri = vscode_uri_1.URI.file(__filename);
        await workspace_1.default.openResource(uri.toString());
        expect(lsclient.mainGetRootPath()).toBeDefined();
        await workspace_1.default.nvim.command('bd!');
    });
    it('should get runtime path', async () => {
        expect(lsclient.getRuntimePath(__filename, undefined)).toBeDefined();
        let uri = vscode_uri_1.URI.file(__filename);
        await workspace_1.default.openResource(uri.toString());
        expect(lsclient.getRuntimePath('package.json', undefined)).toBeDefined();
        let name = path_1.default.basename(__filename);
        expect(lsclient.getRuntimePath(name, __dirname)).toBeDefined();
    });
    it('should check debug mode', async () => {
        expect(lsclient.startedInDebugMode(['--debug'])).toBe(true);
        expect(lsclient.startedInDebugMode(undefined)).toBe(false);
    });
});
describe('Client events', () => {
    it('should start server', async () => {
        let clientOptions = {};
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.ipc
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        disposables.push(client);
        await client.start();
    });
    it('should register events before server start', async () => {
        let clientOptions = {};
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.ipc
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        let n = 0;
        let disposable = client.onRequest('customRequest', () => {
            n++;
            disposable.dispose();
            return {};
        });
        let dispose = client.onNotification('customNotification', () => {
            n++;
            dispose.dispose();
        });
        let dis = client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, '4fb247f8-0ede-415d-a80a-6629b6a9eaf8', p => {
            expect(p).toEqual({ kind: 'end', message: 'end message' });
            n++;
            dis.dispose();
        });
        disposables.push(client);
        await client.start();
        await client.sendNotification('send');
        await helper_1.default.waitValue(() => {
            return n;
        }, 3);
        //   let client = await testEventServer({ initEvent: true })
    });
    it('should register events after server start', async () => {
        let clientOptions = {
            synchronize: {},
            initializationOptions: { initEvent: true }
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        disposables.push(client);
        await client.start();
        let n = 0;
        let disposable = client.onRequest('customRequest', () => {
            n++;
            disposable.dispose();
            return {};
        });
        let dispose = client.onNotification('customNotification', () => {
            n++;
            dispose.dispose();
        });
        let dis = client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, '4fb247f8-0ede-415d-a80a-6629b6a9eaf8', p => {
            expect(p).toEqual({ kind: 'end', message: 'end message' });
            n++;
            dis.dispose();
        });
        await client.sendNotification('send');
        await helper_1.default.waitValue(() => {
            return n;
        }, 3);
    });
    it('should send progress', async () => {
        let clientOptions = {
            synchronize: {},
            initializationOptions: { initEvent: true }
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        let called = false;
        client.onNotification('progressResult', res => {
            called = true;
            expect(res).toEqual({ kind: 'begin', title: 'begin progress' });
        });
        await client.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, '4b3a71d0-2b3f-46af-be2c-2827f548579f', { kind: 'begin', title: 'begin progress' });
        await client.start();
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        let spy = jest.spyOn(client._connection, 'sendProgress').mockImplementation(() => {
            throw new Error('error');
        });
        await expect(async () => {
            await client.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, '', { kind: 'begin', title: '' });
        }).rejects.toThrow(Error);
        spy.mockRestore();
        let p = client.stop();
        await expect(async () => {
            await client._start();
        }).rejects.toThrow(Error);
        await p;
    });
    it('should use custom errorHandler', async () => {
        let called = false;
        let clientOptions = {
            synchronize: {},
            errorHandler: {
                error: () => {
                    return language_client_1.ErrorAction.Shutdown;
                },
                closed: () => {
                    called = true;
                    return language_client_1.CloseAction.DoNotRestart;
                }
            },
            initializationOptions: { initEvent: true }
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        disposables.push(client);
        await client.sendRequest('doExit');
        await client.start();
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        client.handleConnectionError(new Error('error'), { jsonrpc: '' }, 1);
    });
    it('should handle message events', async () => {
        let clientOptions = {
            synchronize: {},
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        expect(client.hasPendingResponse).toBeUndefined();
        disposables.push(client);
        await client.start();
        await client.sendNotification('logMessage');
        await client.sendNotification('showMessage');
        let types = [vscode_languageserver_protocol_1.MessageType.Error, vscode_languageserver_protocol_1.MessageType.Warning, vscode_languageserver_protocol_1.MessageType.Info, vscode_languageserver_protocol_1.MessageType.Log];
        for (const t of types) {
            await client.sendNotification('requestMessage', { type: t });
            await helper_1.default.waitValue(async () => {
                let m = await workspace_1.default.nvim.mode;
                return m.blocking;
            }, true);
            if (t == vscode_languageserver_protocol_1.MessageType.Error) {
                await workspace_1.default.nvim.input('1');
            }
            else {
                await workspace_1.default.nvim.input('<cr>');
            }
        }
        let filename = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let uri = vscode_uri_1.URI.file(filename);
        fs_1.default.writeFileSync(filename, 'foo', 'utf8');
        let spy = jest.spyOn(workspace_1.default, 'openResource').mockImplementation(() => {
            return Promise.resolve();
        });
        let called = false;
        let s = jest.spyOn(window_1.default, 'selectRange').mockImplementation(() => {
            called = true;
            return Promise.reject(new Error('failed'));
        });
        await client.sendNotification('showDocument', { external: true, uri: 'lsptest:///1' });
        await client.sendNotification('showDocument', { uri: 'lsptest:///1', takeFocus: false });
        await client.sendNotification('showDocument', { uri: uri.toString() });
        await client.sendNotification('showDocument', { uri: uri.toString(), selection: vscode_languageserver_types_1.Range.create(0, 0, 1, 0) });
        await helper_1.default.waitValue(() => called, true);
        spy.mockRestore();
        s.mockRestore();
        fs_1.default.unlinkSync(filename);
        await helper_1.default.waitValue(() => {
            return client.hasPendingResponse;
        }, false);
    });
    it('should invoke showDocument middleware', async () => {
        let called = false;
        let clientOptions = {
            synchronize: {},
            middleware: {
                window: {
                    showDocument: async (params, next) => {
                        called = true;
                        let res = await next(params, vscode_languageserver_protocol_1.CancellationToken.None);
                        return res;
                    }
                }
            }
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        let uri = vscode_uri_1.URI.file(__filename);
        await client.start();
        await client.sendNotification('showDocument', { uri: uri.toString() });
        await helper_1.default.waitValue(() => called, true);
        await client.restart();
        await client.stop();
    });
});
describe('Client integration', () => {
    async function testLanguageServer(serverOptions, clientOpts) {
        let clientOptions = {
            documentSelector: ['css'],
            initializationOptions: {}
        };
        if (clientOpts)
            Object.assign(clientOptions, clientOpts);
        let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions);
        await client.start();
        expect(client.initializeResult).toBeDefined();
        expect(client.started).toBe(true);
        return client;
    }
    it('should initialize from function', async () => {
        async function testServer(serverOptions) {
            let clientOptions = {};
            let client = new lsclient.LanguageClient('HTML', serverOptions, clientOptions);
            await client.start();
            await client.dispose();
        }
        await testServer(() => {
            let module = path_1.default.join(__dirname, './server/eventServer.js');
            let sp = child_process_1.default.fork(module, ['--node-ipc'], { cwd: process.cwd() });
            return Promise.resolve({ reader: new node_1.IPCMessageReader(sp), writer: new node_1.IPCMessageWriter(sp) });
        });
        await testServer(() => {
            let module = path_1.default.join(__dirname, './server/eventServer.js');
            let sp = child_process_1.default.fork(module, ['--stdio'], {
                cwd: process.cwd(),
                execArgv: [],
                silent: true,
            });
            return Promise.resolve({ reader: sp.stdout, writer: sp.stdin });
        });
        await testServer(() => {
            let module = path_1.default.join(__dirname, './server/eventServer.js');
            let sp = child_process_1.default.fork(module, ['--stdio'], {
                cwd: process.cwd(),
                execArgv: [],
                silent: true,
            });
            return Promise.resolve({ process: sp, detached: false });
        });
        await testServer(() => {
            let module = path_1.default.join(__dirname, './server/eventServer.js');
            let sp = child_process_1.default.fork(module, ['--stdio'], {
                cwd: process.cwd(),
                execArgv: [],
                silent: true,
            });
            return Promise.resolve(sp);
        });
    });
    it('should initialize use IPC channel', async () => {
        helper_1.default.updateConfiguration('css.trace.server.verbosity', 'verbose');
        helper_1.default.updateConfiguration('css.trace.server.format', 'json');
        let uri = vscode_uri_1.URI.file(__filename);
        await workspace_1.default.loadFile(uri.toString());
        let serverModule = path_1.default.join(__dirname, './server/testInitializeResult.js');
        let serverOptions = {
            run: { module: serverModule, transport: lsclient.TransportKind.ipc },
            debug: { module: serverModule, transport: lsclient.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }
        };
        let clientOptions = {
            rootPatterns: ['.vim'],
            requireRootPattern: true,
            documentSelector: ['css'],
            synchronize: {}, initializationOptions: {},
            middleware: {
                handleDiagnostics: (uri, diagnostics, next) => {
                    assert.equal(uri, "uri:/test.ts");
                    assert.ok(Array.isArray(diagnostics));
                    assert.equal(diagnostics.length, 0);
                    next(uri, diagnostics);
                }
            }
        };
        let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions);
        await client.start();
        let expected = {
            capabilities: {
                textDocumentSync: 1,
                completionProvider: { resolveProvider: true, triggerCharacters: ['"', ':'] },
                hoverProvider: true,
                renameProvider: {
                    prepareProvider: true
                }
            },
            customResults: {
                hello: "world"
            }
        };
        assert.deepEqual(client.initializeResult, expected);
        await client.stop();
    });
    it('should initialize use stdio', async () => {
        helper_1.default.updateConfiguration('css.trace.server.verbosity', 'verbose');
        helper_1.default.updateConfiguration('css.trace.server.format', 'text');
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio
        };
        let client = await testLanguageServer(serverOptions, {
            workspaceFolder: { name: 'test', uri: vscode_uri_1.URI.file(__dirname).toString() },
            outputChannel: window_1.default.createOutputChannel('test'),
            markdown: {},
            disabledFeatures: ['pullDiagnostic'],
            revealOutputChannelOn: lsclient.RevealOutputChannelOn.Info,
            outputChannelName: 'custom',
            connectionOptions: {
                cancellationStrategy: {},
                maxRestartCount: 10,
            },
            stdioEncoding: 'utf8',
            errorHandler: {
                error: () => {
                    return lsclient.ErrorAction.Continue;
                },
                closed: () => {
                    return lsclient.CloseAction.DoNotRestart;
                }
            },
            progressOnInitialization: true,
            disableMarkdown: true,
            disableDiagnostics: true
        });
        assert.deepStrictEqual(client.supportedMarkupKind, [vscode_languageserver_types_1.MarkupKind.PlainText]);
        assert.strictEqual(client.name, 'Test Language Server');
        assert.strictEqual(client.diagnostics, undefined);
        client.trace = vscode_languageserver_protocol_1.Trace.Verbose;
        let d = client.start();
        let s = new vscode_languageserver_protocol_1.CancellationTokenSource();
        s.cancel();
        client.handleFailedRequest(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, s.token, undefined, '');
        await expect(async () => {
            let error = new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled, 'request cancelled');
            client.handleFailedRequest(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, undefined, error, '');
        }).rejects.toThrow(errors_1.CancellationError);
        await expect(async () => {
            let error = new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled, 'request cancelled', 'cancelled');
            client.handleFailedRequest(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, undefined, error, '');
        }).rejects.toThrow(features_1.LSPCancellationError);
        await expect(async () => {
            let error = new Error('failed');
            client.handleFailedRequest(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, undefined, error, '');
        }).rejects.toThrow(Error);
        let error = new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified, 'content changed');
        client.handleFailedRequest(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, undefined, error, '');
        error = new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected, '');
        client.handleFailedRequest(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, undefined, error, '');
        await expect(async () => {
            let error = new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified, 'content changed');
            client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, undefined, error, '');
        }).rejects.toThrow(errors_1.CancellationError);
        await client.stop();
        client.info('message', new Error('my error'), true);
        client.warn('message', 'error', true);
        client.warn('message', 0, true);
        client.logFailedRequest();
        assert.strictEqual(client.diagnostics, undefined);
        d.dispose();
    });
    it('should initialize use pipe', async () => {
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.pipe
        };
        let client = await testLanguageServer(serverOptions, {
            ignoredRootPaths: [workspace_1.default.root]
        });
        expect(client.serviceState).toBeDefined();
        await client.stop();
    });
    it('should initialize use socket', async () => {
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            options: {
                env: {
                    NODE_SOCKET_TEST: 1
                }
            },
            transport: {
                kind: lsclient.TransportKind.socket,
                port: 8088
            }
        };
        let client = await testLanguageServer(serverOptions);
        await client.stop();
    });
    it('should initialize as command', async () => {
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            command: 'node',
            args: [serverModule, '--stdio']
        };
        let client = await testLanguageServer(serverOptions);
        await client.stop();
    });
    it('should not throw as command', async () => {
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            command: 'not_exists',
            args: [serverModule, '--stdio']
        };
        let clientOptions = {
            documentSelector: ['css'],
            initializationOptions: {}
        };
        await expect(async () => {
            let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions);
            await client.start();
            await client.stop();
        }).rejects.toThrow(Error);
    });
    it('should logMessage', async () => {
        let called = false;
        let outputChannel = {
            name: 'empty',
            content: '',
            append: () => {
                called = true;
            },
            appendLine: () => { },
            clear: () => { },
            show: () => { },
            hide: () => { },
            dispose: () => { }
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            command: 'node',
            args: [serverModule, '--stdio']
        };
        let client = await testLanguageServer(serverOptions, { outputChannel });
        client.logMessage('message');
        client.logMessage(Buffer.from('message', 'utf8'));
        expect(called).toBe(true);
        await client.stop();
    });
    it('should use console for messages', async () => {
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            command: 'node',
            args: [serverModule, '--stdio']
        };
        let client = await testLanguageServer(serverOptions);
        let fn = jest.fn();
        let spy = jest.spyOn(console, 'log').mockImplementation(() => {
            fn();
        });
        let s = jest.spyOn(console, 'error').mockImplementation(() => {
            fn();
        });
        client.switchConsole();
        client.info('message', { info: 'info' });
        client.warn('message', { info: 'info' });
        client.error('message', { info: 'info' });
        client.info('message', { info: 'info' });
        client.switchConsole();
        s.mockRestore();
        spy.mockRestore();
        await client.stop();
        expect(fn).toBeCalled();
    });
    it('should separate diagnostics', async () => {
        async function startServer(disable, handleDiagnostics) {
            let clientOptions = {
                disableDiagnostics: disable,
                separateDiagnostics: true,
                initializationOptions: {},
                middleware: {
                    handleDiagnostics
                }
            };
            let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
            let serverOptions = {
                module: serverModule,
                transport: lsclient.TransportKind.stdio,
            };
            let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
            await client.start();
            return client;
        }
        let client = await startServer();
        await client.sendNotification('diagnostics');
        await helper_1.default.waitValue(() => {
            let collection = client.diagnostics;
            let res = collection.get('lsptest:/2');
            return res.length;
        }, 2);
        await client.stop();
        client = await startServer(true);
        await client.sendNotification('diagnostics');
        await helper_1.default.wait(50);
        let collection = client.diagnostics;
        expect(collection).toBeUndefined();
        await client.stop();
        let called = false;
        client = await startServer(false, (uri, diagnostics, next) => {
            called = true;
            next(uri, diagnostics);
        });
        await client.sendNotification('diagnostics');
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        await client.stop();
    });
    it('should check version on apply workspaceEdit', async () => {
        let uri = vscode_uri_1.URI.file(__filename);
        await workspace_1.default.loadFile(uri.toString());
        let clientOptions = {
            documentSelector: [{ scheme: 'file' }],
            initializationOptions: {},
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio,
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        let res;
        client.onNotification('result', p => {
            res = p;
        });
        await client.start();
        await client.sendNotification('edits');
        await helper_1.default.waitValue(() => {
            return res;
        }, { applied: false });
        await client.stop();
    });
    it('should apply simple workspaceEdit', async () => {
        let clientOptions = {
            initializationOptions: {},
        };
        let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.stdio,
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        let res;
        client.onNotification('result', p => {
            res = p;
        });
        await client.start();
        await client.sendNotification('simpleEdit');
        await helper_1.default.waitValue(() => {
            return res != null;
        }, true);
        expect(res).toEqual({ applied: true });
        await client.stop();
    });
    it('should handle error on initialize', async () => {
        let client;
        let progressOnInitialization = false;
        async function startServer(handler, key = 'throwError') {
            let clientOptions = {
                initializationFailedHandler: handler,
                progressOnInitialization,
                initializationOptions: {
                    [key]: true
                },
                connectionOptions: {
                    maxRestartCount: 1
                }
            };
            let serverModule = path_1.default.join(__dirname, './server/eventServer.js');
            let serverOptions = {
                module: serverModule,
                transport: lsclient.TransportKind.ipc,
            };
            client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
            await client.start();
            return client;
        }
        let spy = jest.spyOn(console, 'error').mockImplementation(() => {
            // noop
        });
        let n = 0;
        await expect(async () => {
            await startServer(() => {
                n++;
                return n == 1;
            });
        }).rejects.toThrow(Error);
        await helper_1.default.waitValue(() => {
            return n;
        }, 2);
        let promise = new Promise(resolve => {
            let spy = jest.spyOn(window_1.default, 'showErrorMessage').mockImplementation(() => {
                resolve();
                spy.mockRestore();
                return Promise.resolve({});
            });
        });
        await expect(async () => {
            await startServer(undefined);
        }).rejects.toThrow(Error);
        await promise;
        await expect(async () => {
            await startServer(undefined, 'normalThrow');
        }).rejects.toThrow(Error);
        progressOnInitialization = true;
        await expect(async () => {
            await startServer(undefined, 'utf8');
        }).rejects.toThrow(/Unsupported position encoding/);
        await expect(async () => {
            await client.stop();
        }).rejects.toThrow(Error);
        spy.mockRestore();
    });
});
//# sourceMappingURL=integration.test.js.map