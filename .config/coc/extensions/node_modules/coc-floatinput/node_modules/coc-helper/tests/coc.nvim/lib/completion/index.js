'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Completion = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const numbers_1 = require("../util/numbers");
const object_1 = require("../util/object");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const complete_1 = tslib_1.__importDefault(require("./complete"));
const floating_1 = tslib_1.__importDefault(require("./floating"));
const pum_1 = tslib_1.__importDefault(require("./pum"));
const sources_1 = tslib_1.__importDefault(require("./sources"));
const types_1 = require("./types");
const util_2 = require("./util");
const logger = (0, logger_1.createLogger)('completion');
const TRIGGER_TIMEOUT = (0, util_1.getConditionValue)(200, 20);
const CURSORMOVE_DEBOUNCE = (0, util_1.getConditionValue)(10, 0);
class Completion {
    constructor() {
        this.disposables = [];
        this.complete = null;
        // Ordered items shown in the pum
        this.activeItems = [];
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    init() {
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        window_1.default.onDidChangeActiveTextEditor(e => {
            this.loadLocalConfig(e.document);
        }, null, this.disposables);
        this._mru = new util_2.MruLoader();
        this.pum = new pum_1.default(this.staticConfig, this._mru);
        this.floating = new floating_1.default(this.staticConfig);
        this._debounced = (0, node_1.debounce)(this.onCursorMovedI.bind(this), CURSORMOVE_DEBOUNCE);
        events_1.default.on('CursorMoved', () => {
            this.stop(true);
        }, null, this.disposables);
        events_1.default.on('CursorMovedI', this._debounced, this, this.disposables);
        events_1.default.on('CursorMovedI', () => {
            clearTimeout(this.triggerTimer);
        }, null, this.disposables);
        events_1.default.on('CompleteStop', kind => {
            this.stop(false, kind);
        }, null, this.disposables);
        events_1.default.on('InsertEnter', this.onInsertEnter, this, this.disposables);
        events_1.default.on('TextChangedI', this.onTextChangedI, this, this.disposables);
        events_1.default.on('TextChangedP', this.onTextChangedP, this, this.disposables);
        events_1.default.on('MenuPopupChanged', async (ev) => {
            if (!this.option)
                return;
            this.popupEvent = ev;
            let resolved = this.complete.resolveItem(this.selectedItem);
            if (!resolved || (!ev.move && this.complete.isCompleting))
                return;
            let detailRendered = this.selectedItem.detailRendered;
            let showDocs = this.config.enableFloat;
            await this.floating.resolveItem(resolved.source, resolved.item, this.option, showDocs, detailRendered);
        }, null, this.disposables);
        this.nvim.call('coc#ui#check_pum_keymappings', [this.config.autoTrigger], true);
        commands_1.default.registerCommand('editor.action.triggerSuggest', async (source) => {
            await this.startCompletion({ source });
        }, this, true);
    }
    get mru() {
        return this._mru;
    }
    onCursorMovedI(bufnr, cursor, hasInsert) {
        if (hasInsert || !this.option || bufnr !== this.option.bufnr)
            return;
        let { linenr, colnr, col } = this.option;
        if (linenr === cursor[0]) {
            if (cursor[1] == colnr && cursor[1] === (0, string_1.byteLength)((0, string_1.toText)(this.pretext)) + 1) {
                return;
            }
            let line = this.document.getline(cursor[0] - 1);
            if (line.match(/^\s*/)[0] !== this.option.line.match(/^\s*/)[0]) {
                return;
            }
            let curr = (0, string_1.characterIndex)(line, cursor[1] - 1);
            let start = (0, string_1.characterIndex)(line, col);
            if (start < curr) {
                let text = line.substring(start, curr);
                if (!this.inserted && text === this.pum.search) {
                    return;
                }
            }
        }
        this.stop(true);
    }
    get option() {
        if (!this.complete)
            return null;
        return this.complete.option;
    }
    get isActivated() {
        return this.complete != null;
    }
    get inserted() {
        return this.popupEvent != null && this.popupEvent.inserted;
    }
    get document() {
        if (!this.option)
            return null;
        return workspace_1.default.getDocument(this.option.bufnr);
    }
    get selectedItem() {
        if (!this.popupEvent)
            return undefined;
        return this.activeItems[this.popupEvent.index];
    }
    /**
     * Configuration for current document
     */
    loadLocalConfig(doc) {
        let suggest = workspace_1.default.getConfiguration('suggest', doc);
        this.config = {
            autoTrigger: suggest.get('autoTrigger', 'always'),
            insertMode: suggest.get('insertMode', types_1.InsertMode.Repalce),
            filterGraceful: suggest.get('filterGraceful', true),
            enableFloat: suggest.get('enableFloat', true),
            languageSourcePriority: suggest.get('languageSourcePriority', 99),
            snippetsSupport: suggest.get('snippetsSupport', true),
            defaultSortMethod: suggest.get('defaultSortMethod', types_1.SortMethod.Length),
            removeDuplicateItems: suggest.get('removeDuplicateItems', false),
            acceptSuggestionOnCommitCharacter: suggest.get('acceptSuggestionOnCommitCharacter', false),
            triggerCompletionWait: suggest.get('triggerCompletionWait', 0),
            triggerAfterInsertEnter: suggest.get('triggerAfterInsertEnter', false),
            maxItemCount: suggest.get('maxCompleteItemCount', 256),
            timeout: suggest.get('timeout', 500),
            minTriggerInputLength: suggest.get('minTriggerInputLength', 1),
            localityBonus: suggest.get('localityBonus', true),
            highPrioritySourceLimit: suggest.get('highPrioritySourceLimit', null),
            lowPrioritySourceLimit: suggest.get('lowPrioritySourceLimit', null),
            ignoreRegexps: suggest.get('ignoreRegexps', []),
            asciiMatch: suggest.get('asciiMatch', true),
            asciiCharactersOnly: suggest.get('asciiCharactersOnly', false),
        };
    }
    loadConfiguration(e) {
        var _a;
        if (e && !e.affectsConfiguration('suggest'))
            return;
        if (e)
            this.pum.reset();
        let suggest = workspace_1.default.initialConfiguration.get('suggest');
        let labels = (0, util_1.defaultValue)(suggest.completionItemKindLabels, {});
        this.staticConfig = Object.assign((_a = this.staticConfig) !== null && _a !== void 0 ? _a : {}, {
            kindMap: (0, util_2.createKindMap)(labels),
            defaultKindText: (0, string_1.toText)(labels['default']),
            detailField: suggest.detailField,
            detailMaxLength: (0, numbers_1.toNumber)(suggest.detailMaxLength, 100),
            invalidInsertCharacters: (0, array_1.toArray)(suggest.invalidInsertCharacters),
            formatItems: suggest.formatItems,
            floatConfig: (0, object_1.toObject)(suggest.floatConfig),
            pumFloatConfig: suggest.pumFloatConfig,
            labelMaxLength: suggest.labelMaxLength,
            reversePumAboveCursor: !!suggest.reversePumAboveCursor,
            snippetIndicator: (0, string_1.toText)(suggest.snippetIndicator),
            noselect: !!suggest.noselect,
            enablePreselect: !!suggest.enablePreselect,
            virtualText: !!suggest.virtualText,
            selection: suggest.selection
        });
        let doc = workspace_1.default.getDocument(workspace_1.default.bufnr);
        this.loadLocalConfig(doc);
    }
    async startCompletion(opt) {
        clearTimeout(this.triggerTimer);
        let sourceList;
        if (Is.string(opt.source)) {
            sourceList = (0, array_1.toArray)(sources_1.default.getSource(opt.source));
        }
        let bufnr = await this.nvim.call('bufnr', ['%']);
        let doc = workspace_1.default.getAttachedDocument(bufnr);
        let info = await this.nvim.call('coc#util#change_info');
        info.pre = (0, string_1.byteSlice)(info.line, 0, info.col - 1);
        const option = this.getCompleteOption(doc, info, true);
        await this._startCompletion(option, sourceList);
    }
    async _startCompletion(option, sourceList) {
        this._debounced.clear();
        let doc = workspace_1.default.getAttachedDocument(option.bufnr);
        option.filetype = doc.filetype;
        logger.debug('trigger completion with', option);
        this.stop(true);
        this.pretext = (0, string_1.byteSlice)(option.line, 0, option.colnr - 1);
        sourceList = sourceList !== null && sourceList !== void 0 ? sourceList : sources_1.default.getSources(option);
        if ((0, array_1.isFalsyOrEmpty)(sourceList))
            return;
        let complete = this.complete = new complete_1.default(option, doc, this.config, sourceList);
        events_1.default.completing = true;
        complete.onDidRefresh(async () => {
            clearTimeout(this.triggerTimer);
            if (complete.isEmpty) {
                this.stop(false);
                return;
            }
            if (this.inserted)
                return;
            await this.filterResults();
        });
        let shouldStop = await complete.doComplete();
        if (shouldStop)
            this.stop(false);
    }
    async onTextChangedP(_bufnr, info) {
        // navigate item or finish completion
        if (!info.insertChar && this.complete) {
            this.complete.cancel();
        }
        this.pretext = info.pre;
    }
    async onTextChangedI(bufnr, info) {
        const doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached)
            return;
        const { option } = this;
        if (option != null) {
            // detect item word insert
            if (!info.insertChar) {
                let pre = (0, string_1.byteSlice)(option.line, 0, option.col);
                if (this.selectedItem) {
                    let { word, startcol } = this.popupEvent;
                    if ((0, string_1.byteSlice)(option.line, 0, startcol) + word == info.pre) {
                        this.pretext = info.pre;
                        return;
                    }
                }
                else if (pre + this.pum.search == info.pre) {
                    return;
                }
            }
            // retrigger after indent
            if (info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
                await this.triggerCompletion(doc, info);
                return;
            }
            if ((0, util_2.shouldStop)(bufnr, this.pretext, info, option)) {
                this.stop(true);
            }
        }
        if (info.pre === this.pretext)
            return;
        clearTimeout(this.triggerTimer);
        let pretext = this.pretext = info.pre;
        if (!info.insertChar) {
            if (this.complete)
                await this.filterResults();
            return;
        }
        // check commit
        if (this.config.acceptSuggestionOnCommitCharacter && this.selectedItem) {
            let last = pretext.slice(-1);
            let resolvedItem = this.selectedItem;
            let result = this.complete.resolveItem(resolvedItem);
            if (result && sources_1.default.shouldCommit(result.source, result.item, last)) {
                logger.debug('commit by commit character.');
                let startcol = (0, string_1.byteIndex)(this.option.line, resolvedItem.character) + 1;
                this.stop(true);
                this.nvim.call('coc#pum#repalce', [startcol, resolvedItem.word + info.insertChar], true);
                return;
            }
        }
        // trigger character
        if (!doc.chars.isKeywordChar(info.insertChar)) {
            let triggerSources = this.getTriggerSources(doc, pretext);
            if (triggerSources.length > 0) {
                await this.triggerCompletion(doc, info, triggerSources);
                return;
            }
        }
        // trigger by normal character
        if (!this.complete) {
            await this.triggerCompletion(doc, info);
            return;
        }
        if (this.complete.isEmpty) {
            // triggering without results
            this.triggerTimer = setTimeout(async () => {
                await this.triggerCompletion(doc, info);
            }, TRIGGER_TIMEOUT);
            return;
        }
        await this.filterResults(info);
    }
    getTriggerSources(doc, pretext) {
        let disabled = doc.getVar('disabled_sources', []);
        if (this.config.autoTrigger === 'none')
            return [];
        return sources_1.default.getTriggerSources(pretext, doc.filetype, doc.uri, disabled);
    }
    async triggerCompletion(doc, info, sources) {
        let { minTriggerInputLength, autoTrigger } = this.config;
        let { pre } = info;
        // check trigger
        if (autoTrigger === 'none')
            return false;
        if (!sources && !this.shouldTrigger(doc, pre))
            return false;
        const option = this.getCompleteOption(doc, info);
        if (sources == null && option.input.length < minTriggerInputLength) {
            logger.trace(`Suggest not triggered with input "${option.input}", minimal trigger input length: ${minTriggerInputLength}`);
            return false;
        }
        if ((0, util_2.checkIgnoreRegexps)(this.config.ignoreRegexps, option.input))
            return false;
        await this._startCompletion(option, sources);
        return true;
    }
    getCompleteOption(doc, info, manual = false) {
        let { pre } = info;
        let input = (0, util_2.getInput)(doc.chars, info.pre, this.config.asciiCharactersOnly);
        let followWord = doc.getStartWord(info.line.slice(info.pre.length));
        return {
            input,
            position: vscode_languageserver_types_1.Position.create(info.lnum - 1, info.pre.length),
            line: info.line,
            followWord,
            filetype: doc.filetype,
            linenr: info.lnum,
            col: info.col - 1 - (0, string_1.byteLength)(input),
            colnr: info.col,
            bufnr: doc.bufnr,
            word: input + followWord,
            changedtick: info.changedtick,
            synname: '',
            filepath: doc.schema === 'file' ? vscode_uri_1.URI.parse(doc.uri).fsPath : '',
            triggerCharacter: manual ? undefined : (0, string_1.toText)(pre[pre.length - 1])
        };
    }
    stop(close, kind = types_1.CompleteFinishKind.Normal) {
        var _a;
        let { complete } = this;
        if (complete == null)
            return;
        let inserted = kind === types_1.CompleteFinishKind.Confirm || (((_a = this.popupEvent) === null || _a === void 0 ? void 0 : _a.inserted) && kind != types_1.CompleteFinishKind.Cancel);
        let item = this.selectedItem;
        let character = item === null || item === void 0 ? void 0 : item.character;
        let resolved = complete.resolveItem(item);
        let option = complete.option;
        let input = complete.input;
        let doc = workspace_1.default.getDocument(option.bufnr);
        let line = option.line;
        let inputStart = (0, string_1.characterIndex)(line, option.col);
        events_1.default.completing = false;
        this.cancel();
        doc._forceSync();
        void events_1.default.fire('CompleteDone', [(0, util_2.toCompleteDoneItem)(item, resolved === null || resolved === void 0 ? void 0 : resolved.item)]);
        if (close)
            this.nvim.call('coc#pum#_close', [], true);
        if (resolved && inserted) {
            this._mru.add(line.slice(character, inputStart) + input, item);
        }
        if (kind == types_1.CompleteFinishKind.Confirm && resolved) {
            void this.confirmCompletion(resolved.source, resolved.item, option);
        }
    }
    async confirmCompletion(source, item, option) {
        await this.floating.resolveItem(source, item, option, false);
        if (!Is.func(source.onCompleteDone))
            return;
        let { insertMode, snippetsSupport } = this.config;
        let opt = Object.assign({ insertMode, snippetsSupport }, option);
        await Promise.resolve(source.onCompleteDone(item, opt));
    }
    async onInsertEnter(bufnr) {
        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== 'always')
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached)
            return;
        let change = await this.nvim.call('coc#util#change_info');
        change.pre = (0, string_1.byteSlice)(change.line, 0, change.col - 1);
        await this.triggerCompletion(doc, change);
    }
    shouldTrigger(doc, pre) {
        let { autoTrigger } = this.config;
        if (autoTrigger == 'none')
            return false;
        if (sources_1.default.shouldTrigger(pre, doc.filetype, doc.uri))
            return true;
        if (autoTrigger !== 'always')
            return false;
        return true;
    }
    async filterResults(info) {
        let { complete, option, pretext } = this;
        let search = (0, util_2.getResumeInput)(option, pretext);
        if (search == null) {
            this.stop(true);
            return;
        }
        let items = await complete.filterResults(search);
        // cancelled or have inserted text
        if (items === undefined || !this.option)
            return;
        let doc = workspace_1.default.getDocument(option.bufnr);
        // trigger completion when trigger source available
        if (info && info.insertChar && items.length == 0) {
            let triggerSources = this.getTriggerSources(doc, pretext);
            if (triggerSources.length > 0) {
                await this.triggerCompletion(doc, info, triggerSources);
                return;
            }
        }
        if (items.length == 0) {
            let last = search.slice(-1);
            if (!complete.isCompleting || last.length === 0 || !doc.chars.isKeywordChar(last)) {
                this.stop(true);
            }
            return;
        }
        this.activeItems = items;
        this.pum.show(items, search, this.option);
    }
    cancel() {
        if (this.complete != null) {
            this.complete.dispose();
            this.complete = null;
        }
        if (this.triggerTimer != null) {
            clearTimeout(this.triggerTimer);
            this.triggerTimer = null;
        }
        this.pretext = undefined;
        this.activeItems = [];
        this.popupEvent = undefined;
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.Completion = Completion;
exports.default = new Completion();
//# sourceMappingURL=index.js.map