'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnippetVariableResolver = exports.parseCommentstring = exports.parseComments = exports.padZero = void 0;
const uuid_1 = require("uuid");
const vscode_uri_1 = require("vscode-uri");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
function padZero(n) {
    return n < 10 ? '0' + n : n.toString();
}
exports.padZero = padZero;
function parseComments(comments) {
    let start;
    let end;
    let single;
    let parts = comments.split(',');
    for (let s of parts) {
        if (start && end && single)
            break;
        if (!s.includes(':'))
            continue;
        let [flag, str] = s.split(':');
        if (flag.includes('s')) {
            start = str;
        }
        else if (flag.includes('e')) {
            end = str;
        }
        else if (!single && flag == '') {
            single = str;
        }
    }
    return { start, end, single };
}
exports.parseComments = parseComments;
/*
 * Get single line comment text
 */
function parseCommentstring(commentstring) {
    if (commentstring.endsWith('%s'))
        return commentstring.slice(0, -2).trim();
    return undefined;
}
exports.parseCommentstring = parseCommentstring;
class SnippetVariableResolver {
    constructor(nvim, workspaceFolder) {
        this.nvim = nvim;
        this.workspaceFolder = workspaceFolder;
        this._variableToValue = {};
        const currentDate = new Date();
        const fullyear = currentDate.getFullYear().toString();
        Object.assign(this._variableToValue, {
            CURRENT_YEAR: fullyear,
            CURRENT_YEAR_SHORT: fullyear.slice(-2),
            CURRENT_MONTH: padZero(currentDate.getMonth() + 1),
            CURRENT_DATE: padZero(currentDate.getDate()),
            CURRENT_HOUR: padZero(currentDate.getHours()),
            CURRENT_MINUTE: padZero(currentDate.getMinutes()),
            CURRENT_SECOND: padZero(currentDate.getSeconds()),
            CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
            CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
            CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
            CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" }),
            TM_FILENAME: null,
            TM_FILENAME_BASE: null,
            TM_DIRECTORY: null,
            TM_FILEPATH: null,
            YANK: null,
            TM_LINE_INDEX: null,
            TM_LINE_NUMBER: null,
            TM_CURRENT_LINE: null,
            TM_CURRENT_WORD: null,
            TM_SELECTED_TEXT: null,
            VISUAL: null,
            CLIPBOARD: null,
            RELATIVE_FILEPATH: null,
            RANDOM: null,
            RANDOM_HEX: null,
            UUID: null,
            BLOCK_COMMENT_START: null,
            BLOCK_COMMENT_END: null,
            LINE_COMMENT: null,
            WORKSPACE_NAME: null,
            WORKSPACE_FOLDER: null
        });
    }
    async resolveValue(name) {
        let { nvim } = this;
        if (['TM_FILENAME', 'TM_FILENAME_BASE', 'TM_DIRECTORY', 'TM_FILEPATH'].includes(name)) {
            let filepath = await nvim.eval('expand("%:p")');
            if (name === 'TM_FILENAME')
                return node_1.path.basename(filepath);
            if (name === 'TM_FILENAME_BASE')
                return node_1.path.basename(filepath, node_1.path.extname(filepath));
            if (name === 'TM_DIRECTORY')
                return node_1.path.dirname(filepath);
            if (name === 'TM_FILEPATH')
                return filepath;
        }
        if (name === 'YANK') {
            return await nvim.call('getreg', ['""']);
        }
        if (name === 'TM_LINE_INDEX') {
            let lnum = await nvim.call('line', ['.']);
            return (lnum - 1).toString();
        }
        if (name === 'TM_LINE_NUMBER') {
            let lnum = await nvim.call('line', ['.']);
            return lnum.toString();
        }
        if (name === 'TM_CURRENT_LINE') {
            return await nvim.call('getline', ['.']);
        }
        if (name === 'TM_CURRENT_WORD') {
            return await nvim.eval(`expand('<cword>')`);
        }
        if (name === 'TM_SELECTED_TEXT' || name == 'VISUAL') {
            return await nvim.eval(`get(g:,'coc_selected_text', v:null)`);
        }
        if (name === 'CLIPBOARD') {
            return await nvim.eval('@*');
        }
        if (name === 'RANDOM') {
            return Math.random().toString().slice(-6);
        }
        if (name === 'RANDOM_HEX') {
            return Math.random().toString(16).slice(-6);
        }
        if (name === 'UUID') {
            return (0, uuid_1.v4)();
        }
        if (['RELATIVE_FILEPATH', 'WORKSPACE_NAME', 'WORKSPACE_FOLDER'].includes(name)) {
            let filepath = await nvim.eval('expand("%:p")');
            let folder = this.workspaceFolder.getWorkspaceFolder(vscode_uri_1.URI.file(filepath));
            if (name === 'RELATIVE_FILEPATH')
                return this.workspaceFolder.getRelativePath(filepath);
            if (name === 'WORKSPACE_NAME')
                return folder.name;
            if (name === 'WORKSPACE_FOLDER')
                return vscode_uri_1.URI.parse(folder.uri).fsPath;
        }
        if (name === 'LINE_COMMENT') {
            let commentstring = await nvim.eval('&commentstring');
            let s = parseCommentstring(commentstring);
            if (s)
                return s;
            let comments = await nvim.eval('&comments');
            let { single } = parseComments(comments);
            return single;
        }
        if (['BLOCK_COMMENT_START', 'BLOCK_COMMENT_END'].includes(name)) {
            let comments = await nvim.eval('&comments');
            let { start, end } = parseComments(comments);
            if (name === 'BLOCK_COMMENT_START')
                return start;
            if (name === 'BLOCK_COMMENT_END')
                return end;
        }
    }
    async resolve(variable) {
        const name = variable.name;
        let resolved = this._variableToValue[name];
        if (resolved != null)
            return resolved.toString();
        // resolve known value
        if ((0, object_1.hasOwnProperty)(this._variableToValue, name)) {
            let value = await this.resolveValue(name);
            if (!value && variable.children.length) {
                return variable.toString();
            }
            return value == null ? '' : value.toString();
        }
        if (variable.children.length)
            return variable.toString();
        // VSCode behavior
        return name;
    }
}
exports.SnippetVariableResolver = SnippetVariableResolver;
//# sourceMappingURL=variableResolve.js.map