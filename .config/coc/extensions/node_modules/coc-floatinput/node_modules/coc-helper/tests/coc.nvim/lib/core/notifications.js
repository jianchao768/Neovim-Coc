"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Notifications = void 0;
const tslib_1 = require("tslib");
const notification_1 = tslib_1.__importStar(require("../model/notification"));
const progress_1 = tslib_1.__importStar(require("../model/progress"));
const util_1 = require("../util");
const extensionRegistry_1 = require("../util/extensionRegistry");
const numbers_1 = require("../util/numbers");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const ui_1 = require("./ui");
class Notifications {
    constructor(dialogs) {
        this.dialogs = dialogs;
    }
    async _showMessage(kind, message, items, stack) {
        if (!this.enableMessageDialog)
            return await this.showConfirm(message, items, kind);
        if (items.length > 0) {
            let source = (0, extensionRegistry_1.parseExtensionName)(stack);
            return await this.showMessagePicker(`Choose action (${source})`, message, `Coc${kind}Float`, items);
        }
        await this.createNotification(kind.toLowerCase(), message, [], stack);
        return undefined;
    }
    createNotification(kind, message, items, stack) {
        return new Promise((resolve, reject) => {
            let config = {
                kind,
                content: message,
                buttons: (0, notification_1.toButtons)(items),
                callback: idx => {
                    resolve(idx);
                }
            };
            let notification = new notification_1.default(this.nvim, config);
            notification.show(this.getNotificationPreference(stack)).catch(reject);
        });
    }
    async showMessagePicker(title, content, hlGroup, items) {
        let texts = items.map(o => typeof o === 'string' ? o : o.title);
        let res = await this.dialogs.showMenuPicker(texts, {
            position: 'center',
            content,
            title: title.replace(/\r?\n/, ' '),
            borderhighlight: hlGroup
        });
        return items[res];
    }
    // fallback for vim without dialog
    async showConfirm(message, items, kind) {
        if (!items || items.length == 0) {
            let msgType = kind == 'Info' ? 'more' : kind == 'Error' ? 'error' : 'warning';
            this.echoMessages(message, msgType);
            return undefined;
        }
        let titles = (0, notification_1.toTitles)(items);
        let choices = titles.map((s, i) => `${i + 1}${s}`);
        let res = await this.nvim.callAsync('coc#util#with_callback', ['confirm', [message, choices.join('\n'), 0, kind]]);
        return items[res - 1];
    }
    echoMessages(msg, messageType) {
        let level = this.configuration.get('coc.preferences.messageLevel', 'more');
        (0, ui_1.echoMessages)(this.nvim, msg, messageType, level);
    }
    async showNotification(config, stack) {
        let notification = new notification_1.default(this.nvim, config);
        await notification.show(this.getNotificationPreference(stack));
    }
    async withProgress(options, task) {
        let config = this.configuration.get('notification');
        let stack = Error().stack;
        if (config.statusLineProgress) {
            return await this.createStatusLineProgress(options, task);
        }
        let progress = new progress_1.default(this.nvim, {
            task,
            title: options.title,
            cancellable: options.cancellable
        });
        let minWidth = (0, numbers_1.toNumber)(config.minProgressWidth, 30);
        let promise = new Promise(resolve => {
            progress.onDidFinish(resolve);
        });
        await progress.show(Object.assign(this.getNotificationPreference(stack, options.source), { minWidth }));
        return await promise;
    }
    async createStatusLineProgress(options, task) {
        let { title } = options;
        let statusItem = this.statusLine.createStatusBarItem(0, true);
        statusItem.text = (0, string_1.toText)(title);
        statusItem.show();
        let total = 0;
        let result = await task({
            report: p => {
                if (p.increment) {
                    total += p.increment;
                }
                statusItem.text = (0, progress_1.formatMessage)(title, p.message, total);
            }
        }, protocol_1.CancellationToken.None);
        statusItem.dispose();
        return result;
    }
    get enableMessageDialog() {
        return this.configuration.get('coc.preferences.enableMessageDialog', false);
    }
    getNotificationPreference(stack, source) {
        if (!source)
            source = (0, extensionRegistry_1.parseExtensionName)(stack);
        let config = this.configuration.get('notification');
        let disabledList = (0, util_1.defaultValue)(config.disabledProgressSources, []);
        let disabled = Array.isArray(disabledList) && (disabledList.includes('*') || disabledList.includes(source));
        return {
            border: config.border,
            focusable: config.focusable,
            marginRight: (0, numbers_1.toNumber)(config.marginRight, 10),
            timeout: (0, numbers_1.toNumber)(config.timeout, 10000),
            maxWidth: (0, numbers_1.toNumber)(config.maxWidth, 60),
            maxHeight: (0, numbers_1.toNumber)(config.maxHeight, 10),
            highlight: config.highlightGroup,
            winblend: (0, numbers_1.toNumber)(config.winblend, 30),
            disabled,
            source,
        };
    }
}
exports.Notifications = Notifications;
//# sourceMappingURL=notifications.js.map