'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const sequence_1 = require("../util/sequence");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const configuration_1 = tslib_1.__importDefault(require("./configuration"));
const debounceTime = (0, util_1.getConditionValue)(100, 20);
class ListUI {
    constructor(nvim, name, listOptions) {
        this.nvim = nvim;
        this.name = name;
        this.listOptions = listOptions;
        this.newTab = false;
        this.reversed = false;
        this.currIndex = 0;
        this.items = [];
        this.disposables = [];
        this.selected = new Set();
        this.sequence = new sequence_1.Sequence();
        this._onDidChangeLine = new protocol_1.Emitter();
        this._onDidOpen = new protocol_1.Emitter();
        this._onDidClose = new protocol_1.Emitter();
        this._onDidLineChange = new protocol_1.Emitter();
        this._onDoubleClick = new protocol_1.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.newTab = listOptions.position == 'tab';
        this.reversed = listOptions.reverse === true;
        events_1.default.on('BufWinLeave', async (bufnr) => {
            if (bufnr != this.bufnr || this.window == null)
                return;
            this.window = null;
            this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_1.default.on('CursorMoved', async (bufnr, cursor) => {
            if (bufnr != this.bufnr)
                return;
            let idx = this.lnumToIndex(cursor[0]);
            this.onLineChange(idx);
        }, null, this.disposables);
        let debounced = (0, node_1.debounce)(async (bufnr) => {
            if (bufnr != this.bufnr)
                return;
            let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
            if (end < 300 || winid != this.winid)
                return;
            let h = end - start + 1;
            let s = this.lnumToIndex(start);
            let e = this.lnumToIndex(start + h * 2);
            nvim.pauseNotification();
            this.doHighlight(s, e);
            nvim.command('redraw', true);
            nvim.resumeNotification(false, true);
        }, debounceTime);
        this.disposables.push({
            dispose: () => {
                debounced.clear();
            }
        });
        events_1.default.on('CursorMoved', debounced, null, this.disposables);
    }
    onDidChangeItems(ev) {
        if (!ev.append)
            this.clearSelection();
        this.sequence.run(async () => {
            let { items, reload, append, finished, sorted } = ev;
            if (this.shouldSort && !sorted) {
                // do sort
                items = append ? this.items.concat(items) : items;
                reload = append == true;
                append = false;
                items.sort((a, b) => {
                    if (a.score != b.score)
                        return b.score - a.score;
                    if (a.sortText > b.sortText)
                        return 1;
                    return -1;
                });
            }
            if (append) {
                await this.appendItems(items);
            }
            else {
                await this.drawItems(items, finished, reload);
            }
        });
    }
    lnumToIndex(lnum) {
        let { reversed, length } = this;
        if (!reversed)
            return lnum - 1;
        return Math.max(0, length - lnum);
    }
    indexToLnum(index) {
        let { reversed, length } = this;
        if (!reversed)
            return Math.min(index + 1, length);
        return Math.max(Math.min(length, length - index), 1);
    }
    get bufnr() {
        var _a;
        return (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.id;
    }
    get winid() {
        var _a;
        return (_a = this.window) === null || _a === void 0 ? void 0 : _a.id;
    }
    get limitLines() {
        return configuration_1.default.get('limitLines', Infinity);
    }
    onLineChange(index) {
        if (this.currIndex == index)
            return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
    }
    get index() {
        return this.currIndex;
    }
    getItem(index) {
        return this.items[index];
    }
    get item() {
        let { window } = this;
        if (!window)
            return Promise.resolve(null);
        return window.cursor.then(cursor => {
            this.currIndex = this.lnumToIndex(cursor[0]);
            return this.items[this.currIndex];
        });
    }
    async echoMessage(item) {
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${(0, string_1.toText)(item.label)}`;
        this.nvim.callTimer('coc#ui#echo_lines', [[msg]], true);
    }
    updateItem(item, index) {
        if (!this.buffer || index >= this.length)
            return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.buffer.setOption('modifiable', true, true);
        nvim.call('setbufline', [this.bufnr, lnum, item.label], true);
        this.doHighlight(index, index + 1);
        this.buffer.setOption('modifiable', false, true);
        nvim.resumeNotification(true, true);
    }
    async getItems() {
        if (this.length == 0 || !this.window)
            return [];
        let mode = await this.nvim.call('mode');
        if (mode == 'v' || mode == 'V') {
            let [start, end] = await this.getSelectedRange();
            let res = [];
            for (let i = start; i <= end; i++) {
                let idx = this.lnumToIndex(i);
                let item = this.items[idx];
                if (item)
                    res.push(item);
            }
            return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length)
            return selectedItems;
        let item = await this.item;
        return (0, array_1.toArray)(item);
    }
    async onMouse(event) {
        let { nvim, window } = this;
        if (!window)
            return;
        let [winid, lnum, col] = await nvim.eval(`[v:mouse_winid,v:mouse_lnum,v:mouse_col]`);
        if (event == 'mouseDown') {
            this.mouseDown = { winid, lnum, col, current: winid == window.id };
            return;
        }
        let current = winid == window.id;
        if (current && event == 'doubleClick') {
            this.setCursor(lnum);
            this._onDoubleClick.fire();
        }
        if (current && event == 'mouseDrag') {
            if (!this.mouseDown)
                return;
            await this.selectLines(this.mouseDown.lnum, lnum);
        }
        else if (current && event == 'mouseUp') {
            if (!this.mouseDown)
                return;
            if (this.mouseDown.lnum == lnum) {
                this.setCursor(lnum);
                nvim.command('redraw', true);
            }
            else {
                await this.selectLines(this.mouseDown.lnum, lnum);
            }
        }
        else if (!current && event == 'mouseUp') {
            nvim.pauseNotification();
            nvim.call('win_gotoid', winid, true);
            nvim.call('cursor', [lnum, col], true);
            nvim.command('redraw', true);
            nvim.resumeNotification(false, true);
        }
    }
    async resume() {
        let { items, selected, nvim } = this;
        await this.drawItems(items, true, true);
        if (!selected.size || !this.buffer)
            return;
        nvim.pauseNotification();
        for (let lnum of selected) {
            this.buffer.placeSign({ lnum, id: configuration_1.default.signOffset + lnum, name: 'CocSelected', group: 'coc-list' });
        }
        nvim.command('redraw', true);
        nvim.resumeNotification(false, true);
    }
    async toggleSelection() {
        let { nvim, reversed } = this;
        await nvim.call('win_gotoid', [this.winid]);
        let lnum = await nvim.call('line', '.');
        let mode = await nvim.call('mode');
        if (mode == 'v' || mode == 'V') {
            let [start, end] = await this.getSelectedRange();
            let reverse = start > end;
            if (reverse)
                [start, end] = [end, start];
            for (let i = start; i <= end; i++) {
                this.toggleLine(i);
            }
            this.setCursor(end);
            nvim.command('redraw', true);
            await nvim.resumeNotification();
            return;
        }
        nvim.pauseNotification();
        this.toggleLine(lnum);
        this.setCursor(reversed ? lnum - 1 : lnum + 1);
        nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    toggleLine(lnum) {
        let { selected, buffer } = this;
        let exists = selected.has(lnum);
        const signOffset = configuration_1.default.signOffset;
        if (!exists) {
            selected.add(lnum);
            buffer.placeSign({ lnum, id: signOffset + lnum, name: 'CocSelected', group: 'coc-list' });
        }
        else {
            selected.delete(lnum);
            buffer.unplaceSign({ id: signOffset + lnum, group: 'coc-list' });
        }
    }
    async selectLines(start, end) {
        let { nvim, buffer, length } = this;
        const signOffset = configuration_1.default.signOffset;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse)
            [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
            if (i > length)
                break;
            selected.add(i);
            buffer.placeSign({ lnum: i, id: signOffset + i, name: 'CocSelected', group: 'coc-list' });
        }
        this.setCursor(end);
        nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    async selectAll() {
        let { length } = this;
        if (length > 0)
            await this.selectLines(1, length);
    }
    clearSelection() {
        let { selected, buffer } = this;
        if (buffer && selected.size > 0) {
            buffer.unplaceSign({ group: 'coc-list' });
            this.selected.clear();
        }
    }
    get ready() {
        if (this.window)
            return Promise.resolve();
        return new Promise(resolve => {
            let disposable = this.onDidLineChange(() => {
                disposable.dispose();
                resolve();
            });
        });
    }
    getHeight(len, finished) {
        let { listOptions } = this;
        if (typeof listOptions.height === 'number')
            return listOptions.height;
        let height = configuration_1.default.get('height', 10);
        if (finished && !listOptions.interactive && listOptions.input.length == 0) {
            height = Math.min(len, height);
        }
        return Math.max(1, height);
    }
    async drawItems(items, finished, reload = false) {
        const { nvim, name, listOptions } = this;
        this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
        if (!this.window) {
            let height = this.getHeight(items.length, finished);
            let { position, numberSelect } = listOptions;
            let [bufnr, winid, tabnr] = await nvim.call('coc#list#create', [position, height, name, numberSelect]);
            this.tabnr = tabnr;
            this.height = height;
            this.buffer = nvim.createBuffer(bufnr);
            let win = this.window = nvim.createWindow(winid);
            let statusSegments = configuration_1.default.get('statusLineSegments');
            if (statusSegments)
                win.setOption('statusline', statusSegments.join(" "), true);
            this._onDidOpen.fire(this.bufnr);
        }
        const lines = [];
        let selectIndex = 0;
        this.items.forEach((item, idx) => {
            lines.push(item.label);
            if (!reload && selectIndex == 0 && item.preselect)
                selectIndex = idx;
        });
        let newIndex = reload ? this.currIndex : selectIndex;
        this.setLines(lines, 0, newIndex);
        this._onDidLineChange.fire();
    }
    async appendItems(items) {
        if (!this.window || items.length === 0)
            return;
        let curr = this.items.length;
        let remain = this.limitLines - curr;
        if (remain > 0) {
            let append = remain < items.length ? items.slice(0, remain) : items;
            this.items = this.items.concat(append);
            this.setLines(append.map(item => item.label), append.length, this.currIndex);
        }
    }
    get shouldSort() {
        let { matcher, interactive } = this.listOptions;
        if (interactive || matcher !== 'fuzzy')
            return false;
        return true;
    }
    setLines(lines, append, index) {
        let { nvim, buffer, window, reversed, newTab } = this;
        if (!buffer || !window)
            return;
        nvim.pauseNotification();
        if (!append) {
            nvim.call('coc#compat#clear_matches', [window.id], true);
            if (!lines.length) {
                lines = ['No results, press ? on normal mode to get help.'];
                nvim.call('coc#compat#matchaddpos', ['Comment', [[1]], 99, window.id], true);
            }
        }
        buffer.setOption('modifiable', true, true);
        if (reversed) {
            let replacement = lines.reverse();
            if (append) {
                nvim.call('coc#compat#prepend_lines', [buffer.id, replacement], true);
            }
            else {
                buffer.setLines(replacement, { start: 0, end: -1, strictIndexing: false }, true);
            }
        }
        else {
            buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        }
        buffer.setOption('modifiable', false, true);
        if (reversed && !newTab) {
            let maxHeight = configuration_1.default.get('height', 10);
            nvim.call('coc#window#set_height', [window.id, Math.max(Math.min(maxHeight, this.length), 1)], true);
        }
        if (index > this.items.length - 1)
            index = 0;
        if (index == 0) {
            if (append == 0) {
                this.doHighlight(0, 299);
            }
            else {
                let s = this.length - append - 1;
                if (s < 300)
                    this.doHighlight(s, Math.min(299, this.length - 1));
            }
        }
        else {
            let height = newTab ? workspace_1.default.env.lines : this.height;
            this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
            this.currIndex = index;
            let lnum = this.indexToLnum(index);
            window.setCursor([lnum, 0], true);
            nvim.call('coc#list#select', [buffer.id, lnum], true);
        }
        if (reversed)
            nvim.command('normal! zb', true);
        nvim.command('redraws', true);
        nvim.resumeNotification(true, true);
    }
    restoreWindow() {
        if (this.newTab)
            return;
        let { winid, height } = this;
        if (winid && height) {
            this.nvim.call('coc#window#set_height', [winid, height], true);
        }
    }
    get length() {
        return this.items.length;
    }
    get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
            let idx = this.lnumToIndex(i);
            if (items[i - 1])
                res.push(items[idx]);
        }
        return res;
    }
    doHighlight(start, end) {
        let { items, reversed, length, buffer } = this;
        const highlightItems = [];
        const iterate = (i) => {
            let lnum = this.indexToLnum(i) - 1;
            let { ansiHighlights } = items[i];
            if (ansiHighlights) {
                for (let hi of ansiHighlights) {
                    let { span, hlGroup } = hi;
                    highlightItems.push({ hlGroup, lnum, colStart: span[0], colEnd: span[1] });
                }
            }
        };
        if (reversed) {
            for (let i = Math.min(end, length - 1); i >= start; i--) {
                iterate(i);
            }
        }
        else {
            for (let i = start; i <= Math.min(end, length - 1); i++) {
                iterate(i);
            }
        }
        start = this.indexToLnum(start) - 1;
        end = this.indexToLnum(end) - 1;
        if (start > end) {
            [start, end] = [end, start];
        }
        if (!buffer || highlightItems.length == 0)
            return;
        buffer.updateHighlights('list', highlightItems, { start, end: end + 1, priority: 99 });
    }
    setCursor(lnum, col = 0, index) {
        var _a;
        let { items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max)
            return;
        // change index since CursorMoved event not fired (seems bug of neovim)!
        index = index == null ? this.lnumToIndex(lnum) : index;
        this.onLineChange(index);
        (_a = this.window) === null || _a === void 0 ? void 0 : _a.setCursor([lnum, col], true);
        this.nvim.call('coc#list#select', [this.bufnr, lnum], true);
    }
    async setIndex(index) {
        if (index < 0 || index >= this.items.length)
            return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.setCursor(lnum, 0, index);
        nvim.command('redraw', true);
        await nvim.resumeNotification(false);
    }
    async moveCursor(delta) {
        let { index, reversed } = this;
        await this.setIndex(reversed ? index - delta : index + delta);
    }
    async getSelectedRange() {
        let { nvim } = this;
        await nvim.call('coc#prompt#stop_prompt', ['list']);
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call('getpos', "'<");
        let [, end] = await nvim.call('getpos', "'>");
        this.nvim.call('coc#prompt#start_prompt', ['list'], true);
        return [start, end];
    }
    cancel() {
        this.sequence.cancel();
    }
    reset() {
        this.cancel();
        if (this.window) {
            this.window = null;
            this.buffer = null;
            this.tabnr = undefined;
        }
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
        this.nvim.call('coc#window#close', [(0, util_1.defaultValue)(this.winid, -1)], true);
        this.reset();
        this.items = [];
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
    }
}
exports.default = ListUI;
//# sourceMappingURL=ui.js.map