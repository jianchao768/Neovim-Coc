'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const highligher_1 = tslib_1.__importDefault(require("../../model/highligher"));
const util_1 = require("../../util");
const array_1 = require("../../util/array");
const string_1 = require("../../util/string");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const buffer_1 = tslib_1.__importStar(require("./buffer"));
const headGroup = 'Statement';
function getFiletypes() {
    return workspace_1.default.initialConfiguration.get('semanticTokens.filetypes', null);
}
let floatFactory;
class SemanticTokens {
    constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.staticConfig = {
            filetypes: getFiletypes(),
            highlightGroups: []
        };
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('semanticTokens')) {
                this.staticConfig.filetypes = getFiletypes();
                for (let item of this.highlighters.items) {
                    item.loadConfiguration();
                }
            }
        }, this, this.disposables);
        commands_1.default.register({
            id: 'semanticTokens.checkCurrent',
            execute: async () => {
                await this.showHighlightInfo();
            }
        }, false, 'show semantic tokens highlight information of current buffer');
        commands_1.default.register({
            id: 'semanticTokens.refreshCurrent',
            execute: () => {
                return this.highlightCurrent();
            }
        }, false, 'refresh semantic tokens highlight of current buffer.');
        commands_1.default.register({
            id: 'semanticTokens.inspect',
            execute: () => {
                return this.inspectSemanticToken();
            }
        }, false, 'Inspect semantic token information at cursor position.');
        commands_1.default.register({
            id: 'semanticTokens.clearCurrent',
            execute: async () => {
                let buf = await nvim.buffer;
                buf.clearNamespace(buffer_1.NAMESPACE, 0, -1);
            }
        }, false, 'clear semantic tokens highlight of current buffer');
        commands_1.default.register({
            id: 'semanticTokens.clearAll',
            execute: async () => {
                let bufs = await nvim.buffers;
                for (let buf of bufs) {
                    buf.clearNamespace(buffer_1.NAMESPACE, 0, -1);
                }
            }
        }, false, 'clear semantic tokens highlight of all buffers');
        this.highlighters = workspace_1.default.registerBufferSync(doc => {
            return new buffer_1.default(this.nvim, doc, this.staticConfig);
        });
        languages_1.default.onDidSemanticTokensRefresh(async (selector) => {
            if ((0, array_1.isFalsyOrEmpty)(this.staticConfig.highlightGroups))
                await this.fetchHighlightGroups();
            let visibleBufs = window_1.default.visibleTextEditors.map(o => o.document.bufnr);
            for (let item of this.highlighters.items) {
                if (!workspace_1.default.match(selector, item.doc))
                    continue;
                if (!item.hasProvider) {
                    item.clearHighlight();
                }
                else {
                    item.abandonResult();
                    if (visibleBufs.includes(item.bufnr)) {
                        item.highlight();
                    }
                }
            }
        }, null, this.disposables);
        events_1.default.on('BufWinEnter', async (bufnr) => {
            let item = this.highlighters.getItem(bufnr);
            if (item)
                await item.onShown();
        }, null, this.disposables);
        events_1.default.on('CursorMoved', async (bufnr) => {
            let item = this.highlighters.getItem(bufnr);
            if (item)
                await item.onCursorMoved();
        }, null, this.disposables);
    }
    async inspectSemanticToken() {
        let item = await this.getCurrentItem();
        if (!item || !item.enabled) {
            if (!item) {
                let doc = await workspace_1.default.document;
                void window_1.default.showErrorMessage(`Document not attached, ${doc.notAttachReason}`);
            }
            else {
                try {
                    item.checkState();
                }
                catch (e) {
                    void window_1.default.showErrorMessage(e.message);
                }
            }
            this.closeFloat();
            return;
        }
        let [_, line, col] = await this.nvim.call('getcurpos', []);
        let highlights = (0, array_1.toArray)(item.highlights);
        let highlight = highlights.find(o => {
            let column = col - 1;
            return o.range[0] === line - 1 && column >= o.range[1] && column < o.range[2];
        });
        if (highlight) {
            let modifiers = (0, array_1.toArray)(highlight.tokenModifiers);
            let highlights = [];
            if (highlight.hlGroup) {
                let s = 'Highlight group: '.length;
                highlights.push({
                    lnum: 2,
                    colStart: s,
                    colEnd: s + highlight.hlGroup.length,
                    hlGroup: highlight.hlGroup
                });
            }
            let docs = [{
                    filetype: 'txt',
                    content: `Type: ${highlight.tokenType}\nModifiers: ${modifiers.join(', ')}\nHighlight group: ${(0, string_1.toText)(highlight.hlGroup)}`,
                    highlights
                }];
            if (!floatFactory) {
                floatFactory = window_1.default.createFloatFactory({
                    title: 'Semantic token info',
                    highlight: 'Normal',
                    borderhighlight: 'MoreMsg',
                    border: [1, 1, 1, 1]
                });
            }
            await floatFactory.show(docs, { winblend: 0 });
        }
        else {
            this.closeFloat();
        }
    }
    closeFloat() {
        floatFactory === null || floatFactory === void 0 ? void 0 : floatFactory.close();
    }
    async fetchHighlightGroups() {
        let highlightGroups = await this.nvim.call('coc#util#semantic_hlgroups');
        this.staticConfig.highlightGroups = highlightGroups;
    }
    async getCurrentItem() {
        let buf = await this.nvim.buffer;
        return this.getItem(buf.id);
    }
    getItem(bufnr) {
        return this.highlighters.getItem(bufnr);
    }
    /**
     * Force highlight of current buffer
     */
    async highlightCurrent() {
        let item = await this.getCurrentItem();
        if (!item || !item.enabled)
            throw new Error(`Unable to perform semantic highlights for current buffer.`);
        await this.fetchHighlightGroups();
        await item.forceHighlight();
    }
    /**
     * Show semantic highlight info in temporarily buffer
     */
    async showHighlightInfo() {
        var _a, _b;
        let bufnr = await this.nvim.call('bufnr', ['%']);
        workspace_1.default.getAttachedDocument(bufnr);
        let { nvim } = this;
        let item = this.highlighters.getItem(bufnr);
        let hl = new highligher_1.default();
        nvim.pauseNotification();
        nvim.command(`vs +setl\\ buftype=nofile __coc_semantic_highlights_${bufnr}__`, true);
        nvim.command(`setl bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1`, true);
        nvim.call('bufnr', ['%'], true);
        let res = await nvim.resumeNotification();
        hl.addLine('Semantic highlights info', headGroup);
        hl.addLine('');
        try {
            item.checkState();
            let highlights = (_a = item.highlights) !== null && _a !== void 0 ? _a : [];
            hl.addLine('The number of semantic tokens: ');
            hl.addText(String(highlights.length), 'Number');
            hl.addLine('');
            hl.addLine('Semantic highlight groups used by current buffer', headGroup);
            hl.addLine('');
            const groups = (0, array_1.distinct)(highlights.filter(o => o.hlGroup != null).map(({ hlGroup }) => hlGroup));
            for (const hlGroup of groups) {
                hl.addTexts([{ text: '-', hlGroup: 'Comment' }, { text: ' ' }, { text: hlGroup, hlGroup }]);
            }
            hl.addLine('');
            hl.addLine('Tokens types that current Language Server supported:', headGroup);
            hl.addLine('');
            let doc = workspace_1.default.getDocument(item.bufnr);
            let legend = (_b = languages_1.default.getLegend(doc.textDocument)) !== null && _b !== void 0 ? _b : languages_1.default.getLegend(doc.textDocument, true);
            if (legend.tokenTypes.length) {
                for (const t of [...new Set(legend.tokenTypes)]) {
                    let text = buffer_1.HLGROUP_PREFIX + (0, string_1.upperFirst)(t);
                    hl.addTexts([{ text: '-', hlGroup: 'Comment' }, { text: ' ' }, { text, hlGroup: text }]);
                }
                hl.addLine('');
            }
            else {
                hl.addLine('No token types supported', 'Comment');
                hl.addLine('');
            }
            hl.addLine('Tokens modifiers that current Language Server supported:', headGroup);
            hl.addLine('');
            if (legend.tokenModifiers.length) {
                for (const t of [...new Set(legend.tokenModifiers)]) {
                    let text = buffer_1.HLGROUP_PREFIX + (0, string_1.upperFirst)(t);
                    hl.addTexts([{ text: '-', hlGroup: 'Comment' }, { text: ' ' }, { text, hlGroup: text }]);
                }
                hl.addLine('');
            }
            else {
                hl.addLine('No token modifiers exist', 'Comment');
                hl.addLine('');
            }
        }
        catch (e) {
            hl.addLine((0, string_1.toErrorText)(e));
        }
        nvim.pauseNotification();
        hl.render(nvim.createBuffer(res[0][2]));
        nvim.resumeNotification(true, true);
    }
    dispose() {
        this.highlighters.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = SemanticTokens;
//# sourceMappingURL=index.js.map