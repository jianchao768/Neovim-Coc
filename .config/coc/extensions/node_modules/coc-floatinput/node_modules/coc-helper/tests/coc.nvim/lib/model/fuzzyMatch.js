"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuzzyMatch = exports.matchSpansReverse = exports.toSpans = exports.initFuzzyWasm = void 0;
const constants_1 = require("../util/constants");
const filter_1 = require("../util/filter");
const node_1 = require("../util/node");
const string_1 = require("../util/string");
const wasmFile = node_1.path.join(constants_1.pluginRoot, 'bin/fuzzy.wasm');
async function initFuzzyWasm() {
    const buffer = await (0, node_1.promisify)(node_1.fs.readFile)(wasmFile);
    const res = await global.WebAssembly.instantiate(buffer, { env: {} });
    return res.instance.exports;
}
exports.initFuzzyWasm = initFuzzyWasm;
/**
 * Convert FuzzyScore to highlight byte spans.
 */
function toSpans(label, score) {
    let res = [];
    for (let span of matchSpansReverse(label, score, 2)) {
        res.push(span);
    }
    return res;
}
exports.toSpans = toSpans;
/**
 * Convert to spans from reversed list of utf16 code unit numbers
 * Positions should be sorted numbers from big to small
 */
function* matchSpansReverse(text, positions, endIndex = 0, max = Number.MAX_SAFE_INTEGER) {
    let len = positions.length;
    if (len <= endIndex)
        return;
    let byteIndex = (0, string_1.bytes)(text, Math.min(positions[endIndex] + 1, max));
    let start;
    let prev;
    for (let i = len - 1; i >= endIndex; i--) {
        let curr = positions[i];
        if (curr >= max) {
            if (start != null)
                yield [byteIndex(start), byteIndex(prev + 1)];
            break;
        }
        if (prev != undefined) {
            let d = curr - prev;
            if (d == 1) {
                prev = curr;
            }
            else if (d > 1) {
                yield [byteIndex(start), byteIndex(prev + 1)];
                start = curr;
            }
            else {
                // invalid number
                yield [byteIndex(start), byteIndex(prev + 1)];
                break;
            }
        }
        else {
            start = curr;
        }
        prev = curr;
        if (i == endIndex) {
            yield [byteIndex(start), byteIndex(prev + 1)];
        }
    }
}
exports.matchSpansReverse = matchSpansReverse;
function* matchSpans(text, positions, max) {
    max = max ? Math.min(max, text.length) : text.length;
    let byteIndex = (0, string_1.bytes)(text, Math.min(text.length, 4096));
    let start;
    let prev;
    let len = positions.length;
    for (let i = 0; i < len; i++) {
        let curr = positions[i];
        if (curr >= max) {
            if (start != null)
                yield [byteIndex(start), byteIndex(prev + 1)];
            break;
        }
        if (prev != undefined) {
            let d = curr - prev;
            if (d == 1) {
                prev = curr;
            }
            else if (d > 1) {
                yield [byteIndex(start), byteIndex(prev + 1)];
                start = curr;
            }
            else {
                // invalid number
                yield [byteIndex(start), byteIndex(prev + 1)];
                break;
            }
        }
        else {
            start = curr;
        }
        prev = curr;
        if (i == len - 1) {
            yield [byteIndex(start), byteIndex(prev + 1)];
        }
    }
}
class FuzzyMatch {
    constructor(exports) {
        this.exports = exports;
        this.patternLength = 0;
        this.matchSeq = false;
        this.sizes = [2048, 1024, 1024];
    }
    /**
     * Match character positions to column spans.
     */
    matchSpans(text, positions, max) {
        return matchSpans(text, positions, max);
    }
    /**
     * Create 0 index byte spans from matched text and FuzzyScore for highlights
     */
    matchScoreSpans(text, score) {
        return matchSpansReverse(text, score, 2);
    }
    /**
     * Create a score function
     */
    createScoreFunction(pattern, patternPos, options, kind) {
        let lowPattern = pattern.toLowerCase();
        let fn;
        if (kind === 'any') {
            fn = filter_1.anyScore;
        }
        else if (kind === 'aggressive') {
            fn = filter_1.fuzzyScoreGracefulAggressive;
        }
        else {
            fn = filter_1.fuzzyScore;
        }
        return (word, wordPos = 0) => {
            return fn(pattern, lowPattern, patternPos, word, word.toLowerCase(), wordPos, options);
        };
    }
    getSizes() {
        return this.sizes;
    }
    setPattern(pattern, matchSeq = false) {
        // Can't handle length > 256
        if (pattern.length > 256)
            pattern = pattern.slice(0, 256);
        this.matchSeq = matchSeq;
        this.patternLength = matchSeq ? pattern.length : pattern.replace(/(\s|\t)/g, '').length;
        if (this.patternPtr == null) {
            let { malloc } = this.exports;
            let { sizes } = this;
            this.contentPtr = malloc(sizes[0]);
            this.patternPtr = malloc(sizes[1]);
            this.resultPtr = malloc(sizes[2]);
        }
        let buf = Buffer.from(pattern, 'utf8');
        let len = buf.length;
        let bytes = new Uint8Array(this.exports.memory.buffer, this.patternPtr, len + 1);
        bytes.set(buf);
        bytes[len] = 0;
    }
    changeContent(text) {
        let { sizes } = this;
        if (text.length > 4096)
            text = text.slice(0, 4096);
        let buf = Buffer.from(text, 'utf8');
        let len = buf.length;
        if (len > sizes[0]) {
            let { malloc, free } = this.exports;
            free(this.contentPtr);
            let byteLength = len + 1;
            this.contentPtr = malloc(byteLength);
            sizes[0] = byteLength;
        }
        let bytes = new Uint8Array(this.exports.memory.buffer, this.contentPtr, len + 1);
        bytes.set(buf);
        bytes[len] = 0;
    }
    match(text) {
        if (this.patternPtr == null)
            throw new Error('setPattern not called before match');
        if (this.patternLength === 0)
            return { score: 100, positions: new Uint32Array() };
        this.changeContent(text);
        let { fuzzyMatch, memory } = this.exports;
        let { resultPtr } = this;
        let score = fuzzyMatch(this.contentPtr, this.patternPtr, resultPtr, this.matchSeq ? 1 : 0);
        if (!score)
            return undefined;
        const u32 = new Uint32Array(memory.buffer, resultPtr, this.patternLength);
        return { score, positions: u32.slice() };
    }
    matchHighlights(text, hlGroup) {
        let res = this.match(text);
        if (!res)
            return undefined;
        let highlights = [];
        for (let span of this.matchSpans(text, res.positions)) {
            highlights.push({ span, hlGroup });
        }
        return { score: res.score, highlights };
    }
    free() {
        let ptrs = [this.contentPtr, this.patternPtr, this.resultPtr];
        let { free } = this.exports;
        ptrs.forEach(p => {
            if (p != null)
                free(p);
        });
        this.contentPtr = this.patternPtr = this.resultPtr = undefined;
    }
}
exports.FuzzyMatch = FuzzyMatch;
//# sourceMappingURL=fuzzyMatch.js.map