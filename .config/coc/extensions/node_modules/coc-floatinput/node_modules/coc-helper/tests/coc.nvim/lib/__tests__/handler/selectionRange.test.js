"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const window_1 = tslib_1.__importDefault(require("../../window"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
let selection;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    selection = helper_1.default.plugin.getHandler().selectionRange;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
});
describe('selectionRange', () => {
    describe('getSelectionRanges()', () => {
        it('should throw error when selectionRange provider does not exist', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.synchronize();
            await expect(async () => {
                await helper_1.default.doAction('selectionRanges');
            }).rejects.toThrow(Error);
        });
        it('should return ranges', async () => {
            await helper_1.default.createDocument();
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)
                        }];
                }
            }));
            let res = await selection.getSelectionRanges();
            expect(res).toBeDefined();
            expect(Array.isArray(res)).toBe(true);
        });
    });
    describe('selectRange()', () => {
        async function getSelectedRange() {
            let m = await nvim.mode;
            expect(m.mode).toBe('v');
            let bufnr = await nvim.call('bufnr', ['%']);
            await nvim.input('<esc>');
            let res = await window_1.default.getSelectedRange('v');
            return res;
        }
        it('should select ranges forward', async () => {
            let doc = await helper_1.default.createDocument();
            let called = 0;
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo\nbar\ntest\n')]);
            await nvim.call('cursor', [1, 1]);
            await doc.synchronize();
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    called += 1;
                    let arr = [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)
                        }, {
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3)
                        }, {
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3)
                        }];
                    return arr;
                }
            }));
            await doc.synchronize();
            await helper_1.default.doAction('rangeSelect', '', false);
            await selection.selectRange('', true);
            expect(called).toBe(1);
            let res = await getSelectedRange();
            expect(res).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
            await selection.selectRange('v', true);
            expect(called).toBe(2);
            res = await getSelectedRange();
            expect(res).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            await selection.selectRange('v', true);
            expect(called).toBe(3);
            res = await getSelectedRange();
            expect(res).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3));
            await selection.selectRange('v', true);
            expect(called).toBe(4);
            let m = await nvim.mode;
            expect(m.mode).toBe('n');
        });
        it('should select ranges backward', async () => {
            let doc = await helper_1.default.createDocument();
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo\nbar\ntest\n')]);
            await nvim.call('cursor', [1, 1]);
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    let arr = [{
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)
                        }, {
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3)
                        }, {
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3)
                        }];
                    return arr;
                }
            }));
            await doc.synchronize();
            await selection.selectRange('', true);
            let mode = await nvim.call('mode');
            expect(mode).toBe('v');
            await nvim.input('<esc>');
            await window_1.default.selectRange(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3));
            await nvim.input('<esc>');
            await selection.selectRange('v', false);
            let r = await getSelectedRange();
            expect(r).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            await nvim.input('<esc>');
            await selection.selectRange('v', false);
            r = await getSelectedRange();
            expect(r).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
            await nvim.input('<esc>');
            await selection.selectRange('v', false);
            mode = await nvim.call('mode');
            expect(mode).toBe('n');
        });
    });
    describe('provideSelectionRanges()', () => {
        it('should return null when no provider available', async () => {
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.getSelectionRanges(doc.textDocument, [vscode_languageserver_protocol_1.Position.create(0, 0)], vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
        it('should return null when no result available', async () => {
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [];
                }
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.getSelectionRanges(doc.textDocument, [vscode_languageserver_protocol_1.Position.create(0, 0)], vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
        it('should append/prepend selection ranges', async () => {
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{ range: vscode_languageserver_protocol_1.Range.create(1, 1, 1, 4) }, { range: vscode_languageserver_protocol_1.Range.create(1, 0, 1, 6) }];
                }
            }));
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{ range: vscode_languageserver_protocol_1.Range.create(1, 2, 1, 3) }];
                }
            }));
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{ range: vscode_languageserver_protocol_1.Range.create(1, 2, 1, 3) }];
                }
            }));
            disposables.push(languages_1.default.registerSelectionRangeProvider([{ language: '*' }], {
                provideSelectionRanges: _doc => {
                    return [{ range: vscode_languageserver_protocol_1.Range.create(0, 0, 3, 0) }];
                }
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.getSelectionRanges(doc.textDocument, [vscode_languageserver_protocol_1.Position.create(0, 0)], vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(4);
            expect(res[0].range).toEqual(vscode_languageserver_protocol_1.Range.create(1, 2, 1, 3));
            expect(res[3].range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 3, 0));
        });
    });
});
//# sourceMappingURL=selectionRange.test.js.map