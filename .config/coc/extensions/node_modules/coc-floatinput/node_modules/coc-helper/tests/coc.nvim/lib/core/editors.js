'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.renamed = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const fs_1 = require("../util/fs");
const protocol_1 = require("../util/protocol");
const logger = (0, logger_1.createLogger)('core-editors');
function renamed(editor, info) {
    let { document, uri } = editor;
    if (document.bufnr != info.bufnr)
        return false;
    let u = vscode_uri_1.URI.parse(uri);
    if (u.scheme === 'file')
        return !(0, fs_1.sameFile)(u.fsPath, info.fullpath);
    return false;
}
exports.renamed = renamed;
class Editors {
    constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.editors = new Map();
        this.tabIds = new Set();
        this._onDidTabClose = new protocol_1.Emitter();
        this._onDidChangeActiveTextEditor = new protocol_1.Emitter();
        this._onDidChangeVisibleTextEditors = new protocol_1.Emitter();
        this.onDidTabClose = this._onDidTabClose.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
    }
    get activeTextEditor() {
        return this.editors.get(this.winid);
    }
    get visibleTextEditors() {
        return Array.from(this.editors.values());
    }
    isVisible(bufnr) {
        for (let editor of this.editors.values()) {
            if (editor.bufnr == bufnr)
                return true;
        }
        return false;
    }
    onChangeCurrent(editor) {
        let id = editor.id;
        if (id === this.previousId)
            return;
        this.previousId = id;
        this._onDidChangeActiveTextEditor.fire(editor);
    }
    async attach(nvim) {
        this.nvim = nvim;
        let [winid, infos] = await nvim.eval(`[win_getid(),coc#util#editor_infos()]`);
        this.winid = winid;
        await Promise.allSettled(infos.map(info => {
            return this.createTextEditor(info.winid);
        }));
        events_1.default.on('BufUnload', bufnr => {
            for (let [winid, editor] of this.editors.entries()) {
                if (bufnr == editor.bufnr) {
                    this.editors.delete(winid);
                }
            }
        }, null, this.disposables);
        events_1.default.on('CursorHold', this.checkEditors, this, this.disposables);
        events_1.default.on('TabNew', (tabid) => {
            this.tabIds.add(tabid);
        }, null, this.disposables);
        events_1.default.on('TabClosed', this.checkTabs, this, this.disposables);
        events_1.default.on('WinEnter', (winid) => {
            this.winid = winid;
            let editor = this.editors.get(winid);
            if (editor)
                this.onChangeCurrent(editor);
        }, null, this.disposables);
        events_1.default.on('WinClosed', (winid) => {
            if (this.editors.has(winid)) {
                this.editors.delete(winid);
                this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
            }
        }, null, this.disposables);
        events_1.default.on('BufWinEnter', async (_, winid) => {
            this.winid = winid;
            let changed = await this.createTextEditor(winid);
            if (changed)
                this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
        }, null, this.disposables);
    }
    checkTabs(ids) {
        let changed = false;
        for (let editor of this.editors.values()) {
            if (!ids.includes(editor.tabpageid)) {
                changed = true;
                this.editors.delete(editor.winid);
            }
        }
        for (let id of Array.from(this.tabIds)) {
            if (!ids.includes(id))
                this._onDidTabClose.fire(id);
        }
        this.tabIds = new Set(ids);
        if (changed)
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
    }
    checkUnloadedBuffers(bufnrs) {
        for (let bufnr of this.documents.bufnrs) {
            if (!bufnrs.includes(bufnr)) {
                void events_1.default.fire('BufUnload', [bufnr]);
            }
        }
    }
    async checkEditors() {
        let [winid, bufnrs, infos] = await this.nvim.eval(`[win_getid(),coc#util#get_loaded_bufs(),coc#util#editor_infos()]`);
        this.winid = winid;
        this.checkUnloadedBuffers(bufnrs);
        let changed = false;
        let winids = new Set();
        for (let info of infos) {
            let editor = this.editors.get(info.winid);
            let create = false;
            if (!editor) {
                create = true;
            }
            else if (renamed(editor, info)) {
                await events_1.default.fire('BufRename', [info.bufnr]);
                create = true;
            }
            else if (editor.document.bufnr != info.bufnr || editor.tabpageid != info.tabid) {
                create = true;
            }
            if (create) {
                await this.createTextEditor(info.winid);
                changed = true;
            }
            winids.add(info.winid);
        }
        if (this.cleanupEditors(winids)) {
            changed = true;
        }
        if (changed)
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
    }
    cleanupEditors(winids) {
        let changed = false;
        for (let winid of Array.from(this.editors.keys())) {
            if (!winids.has(winid)) {
                changed = true;
                this.editors.delete(winid);
            }
        }
        return changed;
    }
    async createTextEditor(winid) {
        let { documents, nvim } = this;
        let opts = await nvim.call('coc#util#get_editoroption', [winid]);
        if (!opts)
            return false;
        this.tabIds.add(opts.tabpageid);
        let doc = documents.getDocument(opts.bufnr);
        if (doc && doc.attached) {
            let editor = this.fromOptions(opts);
            this.editors.set(winid, editor);
            if (winid == this.winid)
                this.onChangeCurrent(editor);
            logger.debug('editor created winid & bufnr & tabpageid: ', winid, opts.bufnr, opts.tabpageid);
            return true;
        }
        else {
            this.editors.delete(opts.winid);
        }
        return false;
    }
    fromOptions(opts) {
        let { visibleRanges, bufnr } = opts;
        let document = this.documents.getDocument(bufnr);
        return {
            id: `${opts.tabpageid}-${opts.winid}-${document.uri}`,
            tabpageid: opts.tabpageid,
            winid: opts.winid,
            winnr: opts.winnr,
            uri: document.uri,
            bufnr: document.bufnr,
            document,
            visibleRanges: visibleRanges.map(o => vscode_languageserver_types_1.Range.create(o[0] - 1, 0, o[1], 0)),
            options: {
                tabSize: opts.tabSize,
                insertSpaces: !!opts.insertSpaces
            }
        };
    }
}
exports.default = Editors;
//# sourceMappingURL=editors.js.map