"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filter = void 0;
const defaultYieldTimeout = 15;
class Timer {
    constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        // start with a counter interval of 1.
        this.counterInterval = 1;
    }
    start() {
        this.startTime = Date.now();
    }
    shouldYield() {
        if (++this.counter >= this.counterInterval) {
            const timeTaken = Date.now() - this.startTime;
            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
            this.total += this.counter;
            this.counter = 0;
            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
                // Yield also if time left <= 1 since we compute the counter
                // for max < 2 ms.
                // Start with interval 1 again. We could do some calculation
                // with using 80% of the last counter however other things (GC)
                // affect the timing heavily since we have small timings (1 - 15ms).
                this.counterInterval = 1;
                this.total = 0;
                return true;
            }
            else {
                // Only increase the counter until we have spent <= 2 ms. Increasing
                // the counter further is very fragile since timing is influenced
                // by other things and can increase the counter too much. This will result
                // that we yield in average after [14 - 16]ms.
                switch (timeTaken) {
                    case 0:
                    case 1:
                        this.counterInterval = this.total * 2;
                        break;
                }
            }
        }
        return false;
    }
}
async function filter(items, isValid, onFilter, token) {
    if (items.length === 0)
        return;
    const timer = new Timer();
    const len = items.length;
    function convertBatch(start) {
        const result = [];
        timer.start();
        for (let i = start; i < len; i++) {
            let item = items[i];
            let res = isValid(item);
            if (res)
                typeof res === 'boolean' ? result.push(item) : result.push(Object.assign({}, item, res));
            if (timer.shouldYield()) {
                let done = i === len - 1;
                onFilter(result, done);
                return done ? -1 : i + 1;
            }
        }
        onFilter(result, true);
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = convertBatch(0);
    while (index !== -1) {
        if (token != null && token.isCancellationRequested) {
            break;
        }
        index = await new Promise(resolve => {
            setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
}
exports.filter = filter;
//# sourceMappingURL=async.js.map