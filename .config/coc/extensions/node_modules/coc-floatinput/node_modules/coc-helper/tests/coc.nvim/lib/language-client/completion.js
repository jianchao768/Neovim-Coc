'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletionItemFeature = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
const SupportedCompletionItemKinds = [
    vscode_languageserver_types_1.CompletionItemKind.Text,
    vscode_languageserver_types_1.CompletionItemKind.Method,
    vscode_languageserver_types_1.CompletionItemKind.Function,
    vscode_languageserver_types_1.CompletionItemKind.Constructor,
    vscode_languageserver_types_1.CompletionItemKind.Field,
    vscode_languageserver_types_1.CompletionItemKind.Variable,
    vscode_languageserver_types_1.CompletionItemKind.Class,
    vscode_languageserver_types_1.CompletionItemKind.Interface,
    vscode_languageserver_types_1.CompletionItemKind.Module,
    vscode_languageserver_types_1.CompletionItemKind.Property,
    vscode_languageserver_types_1.CompletionItemKind.Unit,
    vscode_languageserver_types_1.CompletionItemKind.Value,
    vscode_languageserver_types_1.CompletionItemKind.Enum,
    vscode_languageserver_types_1.CompletionItemKind.Keyword,
    vscode_languageserver_types_1.CompletionItemKind.Snippet,
    vscode_languageserver_types_1.CompletionItemKind.Color,
    vscode_languageserver_types_1.CompletionItemKind.File,
    vscode_languageserver_types_1.CompletionItemKind.Reference,
    vscode_languageserver_types_1.CompletionItemKind.Folder,
    vscode_languageserver_types_1.CompletionItemKind.EnumMember,
    vscode_languageserver_types_1.CompletionItemKind.Constant,
    vscode_languageserver_types_1.CompletionItemKind.Struct,
    vscode_languageserver_types_1.CompletionItemKind.Event,
    vscode_languageserver_types_1.CompletionItemKind.Operator,
    vscode_languageserver_types_1.CompletionItemKind.TypeParameter
];
class CompletionItemFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.CompletionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport,
            commitCharactersSupport: true,
            documentationFormat: this._client.supportedMarkupKind,
            deprecatedSupport: true,
            preselectSupport: true,
            insertReplaceSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_types_1.CompletionItemTag.Deprecated] },
            resolveSupport: { properties: ['documentation', 'detail', 'additionalTextEdits'] },
            labelDetailsSupport: true,
            insertTextModeSupport: { valueSet: [vscode_languageserver_types_1.InsertTextMode.asIs, vscode_languageserver_types_1.InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.insertTextMode = vscode_languageserver_types_1.InsertTextMode.adjustIndentation;
        completion.completionList = {
            itemDefaults: [
                'commitCharacters', 'editRange', 'insertTextFormat', 'insertTextMode'
            ]
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options)
            return;
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options, id) {
        let triggerCharacters = options.triggerCharacters || [];
        let allCommitCharacters = options.allCommitCharacters || [];
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const middleware = this._client.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return this.sendRequest(protocol_1.CompletionRequest.type, cv.asCompletionParams(document, position, context), token, []);
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const middleware = this._client.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return this.sendRequest(protocol_1.CompletionResolveRequest.type, item, token, item);
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                } : undefined
        };
        // index is needed since one language server could create many sources.
        let name = this._client.id + (this.registrationLength == 0 ? '' : '-' + id);
        const disposable = languages_1.default.registerCompletionItemProvider(name, 'LS', options.documentSelector, provider, triggerCharacters, options.priority, allCommitCharacters);
        return [disposable, provider];
    }
}
exports.CompletionItemFeature = CompletionItemFeature;
//# sourceMappingURL=completion.js.map