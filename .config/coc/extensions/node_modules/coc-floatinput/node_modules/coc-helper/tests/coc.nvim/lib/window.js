'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Window = void 0;
const tslib_1 = require("tslib");
const channels_1 = tslib_1.__importDefault(require("./core/channels"));
const dialogs_1 = require("./core/dialogs");
const highlights_1 = require("./core/highlights");
const notifications_1 = require("./core/notifications");
const terminals_1 = tslib_1.__importDefault(require("./core/terminals"));
const ui = tslib_1.__importStar(require("./core/ui"));
const object_1 = require("./util/object");
const protocol_1 = require("./util/protocol");
class Window {
    constructor() {
        this.highlights = new highlights_1.Highlights();
        this.terminalManager = new terminals_1.default();
        this.dialogs = new dialogs_1.Dialogs();
        this.notifications = new notifications_1.Notifications(this.dialogs);
        Object.defineProperty(this.highlights, 'nvim', {
            get: () => this.nvim
        });
        Object.defineProperty(this.dialogs, 'nvim', {
            get: () => this.nvim
        });
        Object.defineProperty(this.dialogs, 'configuration', {
            get: () => this.workspace.initialConfiguration
        });
        Object.defineProperty(this.notifications, 'nvim', {
            get: () => this.nvim
        });
        Object.defineProperty(this.notifications, 'configuration', {
            get: () => this.workspace.initialConfiguration
        });
        Object.defineProperty(this.notifications, 'statusLine', {
            get: () => this.workspace.statusLine
        });
    }
    init(env) {
        this.highlights.checkMarkers = this.workspace.has('nvim-0.5.1') || env.isVim;
    }
    get activeTextEditor() {
        return this.workspace.editors.activeTextEditor;
    }
    get visibleTextEditors() {
        return this.workspace.editors.visibleTextEditors;
    }
    get onDidTabClose() {
        return this.workspace.editors.onDidTabClose;
    }
    get onDidChangeActiveTextEditor() {
        return this.workspace.editors.onDidChangeActiveTextEditor;
    }
    get onDidChangeVisibleTextEditors() {
        return this.workspace.editors.onDidChangeVisibleTextEditors;
    }
    get terminals() {
        return this.terminalManager.terminals;
    }
    get onDidOpenTerminal() {
        return this.terminalManager.onDidOpenTerminal;
    }
    get onDidCloseTerminal() {
        return this.terminalManager.onDidCloseTerminal;
    }
    async createTerminal(opts) {
        return await this.terminalManager.createTerminal(this.nvim, opts);
    }
    /**
     * Run command in vim terminal for result
     *
     * @param cmd Command to run.
     * @param cwd Cwd of terminal, default to result of |getcwd()|.
     */
    async runTerminalCommand(cmd, cwd, keepfocus = false) {
        return await this.terminalManager.runTerminalCommand(this.nvim, cmd, cwd !== null && cwd !== void 0 ? cwd : this.workspace.cwd, keepfocus);
    }
    /**
     * Open terminal window.
     *
     * @param cmd Command to run.
     * @param opts Terminal option.
     * @returns number buffer number of terminal
     */
    async openTerminal(cmd, opts) {
        return await this.terminalManager.openTerminal(this.nvim, cmd, opts);
    }
    /**
     * Reveal message with message type.
     *
     * @param msg Message text to show.
     * @param messageType Type of message, could be `error` `warning` and `more`, default to `more`
     */
    showMessage(msg, messageType = 'more') {
        this.notifications.echoMessages(msg, messageType);
    }
    /**
     * Create a new output channel
     *
     * @param name Unique name of output channel.
     * @returns A new output channel.
     */
    createOutputChannel(name) {
        return channels_1.default.create(name, this.nvim);
    }
    /**
     * Reveal buffer of output channel.
     *
     * @param name Name of output channel.
     * @param preserveFocus Preserve window focus when true.
     */
    showOutputChannel(name, preserveFocus) {
        let command = this.configuration.get('workspace.openOutputCommand', 'vs');
        channels_1.default.show(name, command, preserveFocus);
    }
    /**
     * Echo lines at the bottom of vim.
     *
     * @param lines Line list.
     * @param truncate Truncate the lines to avoid 'press enter to continue' when true
     */
    async echoLines(lines, truncate = false) {
        await ui.echoLines(this.nvim, this.workspace.env, lines, truncate);
    }
    /**
     * Get current cursor position (line, character both 0 based).
     *
     * @returns Cursor position.
     */
    getCursorPosition() {
        return ui.getCursorPosition(this.nvim);
    }
    /**
     * Move cursor to position.
     *
     * @param position LSP position.
     */
    async moveTo(position) {
        await ui.moveTo(this.nvim, position, this.workspace.env.isVim);
    }
    /**
     * Get selected range for current document
     */
    getSelectedRange(mode) {
        return ui.getSelection(this.nvim, mode);
    }
    /**
     * Visual select range of current document
     */
    async selectRange(range) {
        await ui.selectRange(this.nvim, range, this.nvim.isVim);
    }
    /**
     * Get current cursor character offset in document,
     * length of line break would always be 1.
     *
     * @returns Character offset.
     */
    getOffset() {
        return ui.getOffset(this.nvim);
    }
    /**
     * Get screen position of current cursor(relative to editor),
     * both `row` and `col` are 0 based.
     *
     * @returns Cursor screen position.
     */
    getCursorScreenPosition() {
        return ui.getCursorScreenPosition(this.nvim);
    }
    /**
     * Create a {@link TreeView} instance.
     *
     * @param viewId Id of the view, used as title of TreeView when title doesn't exist.
     * @param options Options for creating the {@link TreeView}
     * @returns a {@link TreeView}.
     */
    createTreeView(viewId, options) {
        const BasicTreeView = require('./tree/TreeView').default;
        return new BasicTreeView(viewId, options);
    }
    /**
     * Create statusbar item that would be included in `g:coc_status`.
     *
     * @param priority Higher priority item would be shown right.
     * @param option
     * @return A new status bar item.
     */
    createStatusBarItem(priority = 0, option = {}) {
        return this.workspace.statusLine.createStatusBarItem(priority, option.progress);
    }
    /**
     * Get diff from highlight items and current highlights on vim.
     * Return null when buffer not loaded
     *
     * @param bufnr Buffer number
     * @param ns Highlight namespace
     * @param items Highlight items
     * @param region 0 based start and end line count (end exclusive)
     * @param token CancellationToken
     * @returns {Promise<HighlightDiff | null>}
     */
    async diffHighlights(bufnr, ns, items, region, token) {
        return this.highlights.diffHighlights(bufnr, ns, items, region, token);
    }
    /**
     * Create a FloatFactory, user's configurations are respected.
     *
     * @param {FloatWinConfig} conf - Float window configuration
     * @returns {FloatFactory}
     */
    createFloatFactory(conf) {
        let configuration = this.workspace.initialConfiguration;
        let defaults = (0, object_1.toObject)(configuration.get('floatFactory.floatConfig'));
        let markdownPreference = this.workspace.configurations.markdownPreference;
        return ui.createFloatFactory(this.workspace.nvim, Object.assign(Object.assign(Object.assign({}, markdownPreference), { maxWidth: 80 }), conf), defaults);
    }
    /**
     * Show quickpick for single item, use `window.menuPick` for menu at current current position.
     *
     * @deprecated Use 'window.showMenuPicker()' or `window.showQuickPick` instead.
     * @param items Label list.
     * @param placeholder Prompt text, default to 'choose by number'.
     * @returns Index of selected item, or -1 when canceled.
     */
    async showQuickpick(items, placeholder = 'Choose by number') {
        return await this.showMenuPicker(items, { title: placeholder, position: 'center' });
    }
    /**
     * Shows a selection list.
     */
    async showQuickPick(itemsOrItemsPromise, options, token = protocol_1.CancellationToken.None) {
        return await this.dialogs.showQuickPick(itemsOrItemsPromise, options, token);
    }
    /**
     * Creates a {@link QuickPick} to let the user pick an item or items from a
     * list of items of type T.
     *
     * Note that in many cases the more convenient {@link window.showQuickPick}
     * is easier to use. {@link window.createQuickPick} should be used
     * when {@link window.showQuickPick} does not offer the required flexibility.
     *
     * @return A new {@link QuickPick}.
     */
    async createQuickPick(config = {}) {
        return await this.dialogs.createQuickPick(config);
    }
    /**
     * Show menu picker at current cursor position, |inputlist()| is used as fallback.
     *
     * @param items Array of texts.
     * @param option Options for menu.
     * @param token A token that can be used to signal cancellation.
     * @returns Selected index (0 based), -1 when canceled.
     */
    async showMenuPicker(items, option, token) {
        return await this.dialogs.showMenuPicker(items, option, token);
    }
    /**
     * Prompt user for confirm, a float/popup window would be used when possible,
     * use vim's |confirm()| function as callback.
     *
     * @param title The prompt text.
     * @returns Result of confirm.
     */
    async showPrompt(title) {
        return await this.dialogs.showPrompt(title);
    }
    /**
     * Show dialog window at the center of screen.
     * Note that the dialog would always be closed after button click.
     *
     * @param config Dialog configuration.
     * @returns Dialog or null when dialog can't work.
     */
    async showDialog(config) {
        return await this.dialogs.showDialog(config);
    }
    /**
     * Request input from user
     *
     * @param title Title text of prompt window.
     * @param value Default value of input, empty text by default.
     * @param {InputOptions} option for input window
     * @returns {Promise<string>}
     */
    async requestInput(title, value, option) {
        return await this.dialogs.requestInput(title, this.workspace.env, value, option);
    }
    /**
     * Creates and show a {@link InputBox} to let the user enter some text input.
     *
     * @return A new {@link InputBox}.
     */
    async createInputBox(title, value, option) {
        return await this.dialogs.createInputBox(title, value, option);
    }
    async showPickerDialog(items, title, token) {
        return await this.dialogs.showPickerDialog(items, title, token);
    }
    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.
     *
     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return Promise that resolves to the selected item or `undefined` when being dismissed.
     */
    async showInformationMessage(message, ...items) {
        let stack = Error().stack;
        return await this.notifications._showMessage('Info', message, items, stack);
    }
    /**
     * Show an warning message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.
     *
     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return Promise that resolves to the selected item or `undefined` when being dismissed.
     */
    async showWarningMessage(message, ...items) {
        let stack = Error().stack;
        return await this.notifications._showMessage('Warning', message, items, stack);
    }
    /**
     * Show an error message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.
     *
     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return Promise that resolves to the selected item or `undefined` when being dismissed.
     */
    async showErrorMessage(message, ...items) {
        let stack = Error().stack;
        return await this.notifications._showMessage('Error', message, items, stack);
    }
    async showNotification(config) {
        let stack = Error().stack;
        await this.notifications.showNotification(config, stack);
    }
    /**
     * Show progress in the editor. Progress is shown while running the given callback
     * and while the promise it returned isn't resolved nor rejected.
     */
    async withProgress(options, task) {
        return this.notifications.withProgress(options, task);
    }
    /**
     * Apply highlight diffs, normally used with `window.diffHighlights`
     *
     * Timer is used to add highlights when there're too many highlight items to add,
     * the highlight process won't be finished on that case.
     *
     * @param {number} bufnr - Buffer name
     * @param {string} ns - Namespace
     * @param {number} priority
     * @param {HighlightDiff} diff
     * @param {boolean} notify - Use notification, default false.
     * @returns {Promise<void>}
     */
    async applyDiffHighlights(bufnr, ns, priority, diff, notify = false) {
        return this.highlights.applyDiffHighlights(bufnr, ns, priority, diff, notify);
    }
    get configuration() {
        return this.workspace.initialConfiguration;
    }
    dispose() {
        this.terminalManager.dispose();
    }
}
exports.Window = Window;
exports.default = new Window();
//# sourceMappingURL=window.js.map