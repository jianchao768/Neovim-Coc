"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const basic_1 = tslib_1.__importDefault(require("../../list/basic"));
const manager_1 = tslib_1.__importDefault(require("../../list/manager"));
const index_1 = require("../../util/index");
const configuration_1 = tslib_1.__importStar(require("../../list/configuration"));
const window_1 = tslib_1.__importDefault(require("../../window"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
class TestList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'test';
        this.timeout = 3000;
        this.text = 'test';
        this.detail = 'detail';
    }
    loadItems(_context, token) {
        return new Promise(resolve => {
            let timer = setTimeout(() => {
                resolve([{ label: this.text }]);
            }, this.timeout);
            token.onCancellationRequested(() => {
                if (timer) {
                    clearTimeout(timer);
                    resolve([]);
                }
            });
        });
    }
}
let nvim;
let disposables = [];
const locations = [{
        filename: __filename,
        col: 2,
        lnum: 1,
        text: 'foo'
    }, {
        filename: __filename,
        col: 1,
        lnum: 2,
        text: 'Bar'
    }, {
        filename: __filename,
        col: 1,
        lnum: 3,
        text: 'option'
    }];
async function waitPreviewWindow() {
    for (let i = 0; i < 40; i++) {
        await helper_1.default.wait(50);
        let has = await nvim.call('coc#list#has_preview');
        if (has > 0)
            return;
    }
    throw new Error('timeout after 2s');
}
const lineList = {
    name: 'lines',
    actions: [{
            name: 'open',
            execute: async (item) => {
                await window_1.default.moveTo({
                    line: item.data.line,
                    character: 0
                });
                // noop
            }
        }],
    defaultAction: 'open',
    async loadItems(_context, _token) {
        let lines = [];
        for (let i = 0; i < 100; i++) {
            lines.push(i.toString());
        }
        return lines.map((line, idx) => ({
            label: line,
            data: { line: idx }
        }));
    }
};
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    await nvim.setVar('coc_jump_locations', locations);
});
afterAll(async () => {
    (0, index_1.disposeAll)(disposables);
    await helper_1.default.shutdown();
});
afterEach(async () => {
    manager_1.default.reset();
    await helper_1.default.reset();
});
describe('isValidAction()', () => {
    it('should check invalid action', () => {
        let mappings = manager_1.default.mappings;
        expect(mappings.isValidAction('foo')).toBe(false);
        expect(mappings.isValidAction('do:switch')).toBe(true);
        expect(mappings.isValidAction('eval:@*')).toBe(true);
        expect(mappings.isValidAction('undefined:undefined')).toBe(false);
    });
});
describe('User mappings', () => {
    it('should not throw when session not exists', async () => {
        let mappings = manager_1.default.mappings;
        let res = await mappings.navigate(true);
        expect(res).toBe(false);
        res = await mappings.navigate(false);
        expect(res).toBe(false);
    });
    it('should show warning for invalid key', async () => {
        expect(configuration_1.ListConfiguration).toBeDefined();
        expect(configuration_1.default.fixKey('<c-a>')).toBe('<C-a>');
        configuration_1.default.fixKey('<a');
        let msg = await helper_1.default.getCmdline();
        expect(msg).toMatch('not supported');
        let revert = helper_1.default.updateConfiguration('list.insertMappings', {
            xy: 'action:tabe',
        });
        await helper_1.default.wait(30);
        msg = await helper_1.default.getCmdline();
        revert();
        await nvim.command('echo ""');
        expect(msg).toMatch('Invalid configuration');
        revert = helper_1.default.updateConfiguration('list.insertMappings', {
            '<M-x>': 'action:tabe',
        });
        await helper_1.default.wait(30);
        msg = await helper_1.default.getCmdline();
        revert();
        expect(msg).toMatch('Invalid configuration');
        revert = helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-a>': 'foo:bar',
        });
        await helper_1.default.wait(30);
        msg = await helper_1.default.getCmdline();
        revert();
        expect(msg).toMatch('Invalid configuration');
    });
    it('should execute action keymap', async () => {
        let revert = helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-d>': 'action:quickfix',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-d>');
        let buftype = await nvim.eval('&buftype');
        expect(buftype).toBe('quickfix');
        revert();
    });
    it('should execute expr keymap', async () => {
        await helper_1.default.mockFunction('TabOpen', 'quickfix');
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-t>': 'expr:TabOpen',
        });
        helper_1.default.updateConfiguration('list.normalMappings', {
            t: 'expr:TabOpen',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-t>');
        let buftype = await nvim.eval('&buftype');
        expect(buftype).toBe('quickfix');
        await nvim.command('close');
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('t');
        buftype = await nvim.eval('&buftype');
        expect(buftype).toBe('quickfix');
    });
    it('should execute do mappings', async () => {
        var _a, _b, _c, _d;
        helper_1.default.updateConfiguration('list.previousKeymap', '<C-j>');
        helper_1.default.updateConfiguration('list.nextKeymap', '<C-k>');
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-n>': 'do:next',
            '<C-p>': 'do:previous',
            '<C-d>': 'do:exit',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-n>');
        let item = await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.item);
        expect(item.label).toMatch(locations[1].text);
        await helper_1.default.listInput('<C-p>');
        item = await ((_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.item);
        expect(item.label).toMatch(locations[0].text);
        await helper_1.default.listInput('<C-k>');
        item = await ((_c = manager_1.default.session) === null || _c === void 0 ? void 0 : _c.ui.item);
        expect(item.label).toMatch(locations[1].text);
        await helper_1.default.listInput('<C-j>');
        item = await ((_d = manager_1.default.session) === null || _d === void 0 ? void 0 : _d.ui.item);
        expect(item.label).toMatch(locations[0].text);
        await helper_1.default.listInput('<C-d>');
        expect(manager_1.default.isActivated).toBe(false);
    });
    it('should execute prompt mappings', async () => {
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-p>': 'prompt:previous',
            '<C-n>': 'prompt:next',
            '<C-a>': 'prompt:start',
            '<C-e>': 'prompt:end',
            '<Left>': 'prompt:left',
            '<Right>': 'prompt:right',
            '<backspace>': 'prompt:deleteforward',
            '<C-x>': 'prompt:deletebackward',
            '<C-k>': 'prompt:removetail',
            '<C-u>': 'prompt:removeahead',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        for (let key of ['<C-p>', '<C-n>', '<C-a>', '<C-e>', '<Left>', '<Right>', '<backspace>', '<C-x>', '<C-k>', '<C-u>']) {
            await helper_1.default.listInput(key);
        }
        expect(manager_1.default.isActivated).toBe(true);
    });
    it('should execute feedkeys keymap', async () => {
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-f>': 'feedkeys:\\<C-f>',
            '<C-b>': 'feedkeys!:\\<C-b>',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-f>');
        await helper_1.default.waitFor('line', ['.'], locations.length);
        await helper_1.default.listInput('<C-b>');
    });
    it('should execute normal keymap', async () => {
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-g>': 'normal:G',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-g>');
        let line = await nvim.call('line', '.');
        expect(line).toBe(locations.length);
    });
    it('should execute command keymap', async () => {
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-w>': 'command:wincmd p',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-w>');
        expect(manager_1.default.isActivated).toBe(true);
        let winnr = await nvim.call('winnr');
        expect(winnr).toBe(1);
    });
    it('should execute call keymap', async () => {
        await helper_1.default.mockFunction('Test', 1);
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-t>': 'call:Test',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-t>');
        expect(manager_1.default.isActivated).toBe(true);
    });
    it('should insert clipboard register to prompt', async () => {
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-r>': 'prompt:paste',
        });
        await nvim.command('let @* = "foobar"');
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-r>');
        let { input } = manager_1.default.prompt;
        expect(input).toMatch('foobar');
        await nvim.command('let @* = ""');
        await helper_1.default.listInput('<C-r>');
        expect(manager_1.default.prompt.input).toMatch('foobar');
    });
    it('should insert text from default register to prompt', async () => {
        helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-v>': 'eval:@@',
        });
        await nvim.command('let @@ = "bar"');
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-v>');
        let { input } = manager_1.default.prompt;
        expect(input).toMatch('bar');
    });
});
describe('doAction()', () => {
    it('should throw when action not found', async () => {
        let mappings = manager_1.default.mappings;
        let fn = async () => {
            await mappings.doAction('foo:bar');
        };
        await expect(fn()).rejects.toThrow(/doesn't exist/);
    });
    it('should not throw when session does not exist', async () => {
        let mappings = manager_1.default.mappings;
        await mappings.doAction('do:selectall');
        await mappings.doAction('do:help');
        await mappings.doAction('do:refresh');
        await mappings.doAction('do:toggle');
        await mappings.doAction('do:jumpback');
        await mappings.doAction('prompt:previous');
        await mappings.doAction('prompt:next');
        await mappings.doAction('do:refresh');
    });
    it('should not throw when action name does not exist', async () => {
        await helper_1.default.mockFunction('MyExpr', '');
        let mappings = manager_1.default.mappings;
        await mappings.doAction('expr', 'MyExpr');
    });
});
describe('getAction()', () => {
    it('should throw for invalid action', async () => {
        let mappings = manager_1.default.mappings;
        let fn = () => {
            mappings.getAction('foo');
        };
        expect(fn).toThrow(Error);
        fn = () => {
            mappings.getAction('do:bar');
        };
        expect(fn).toThrow(Error);
    });
});
describe('Default normal mappings', () => {
    it('should invoke action', async () => {
        await manager_1.default.start(['--normal', '--no-quit', 'location']);
        await manager_1.default.session.ui.ready;
        let winid = manager_1.default.session.ui.winid;
        await helper_1.default.listInput('t');
        let nr = await nvim.call('tabpagenr');
        expect(nr).toBe(2);
        await nvim.call('win_gotoid', [winid]);
        await helper_1.default.listInput('s');
        let winnr = await nvim.call('winnr', ['$']);
        expect(winnr).toBe(3);
        await nvim.call('win_gotoid', [winid]);
        await helper_1.default.listInput('d');
        let filename = await nvim.call('expand', ['%']);
        expect(filename).toMatch(path_1.default.basename(__filename));
        await nvim.call('win_gotoid', [winid]);
        await helper_1.default.listInput('<cr>');
        filename = await nvim.call('expand', ['%']);
        expect(filename).toMatch(path_1.default.basename(__filename));
    });
    it('should select all items by <C-a>', async () => {
        var _a;
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-a>');
        let selected = (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.selectedItems;
        expect(selected.length).toBe(locations.length);
    });
    it('should stop by <C-b>', async () => {
        var _a;
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-b>');
        let loading = (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.worker.isLoading;
        expect(loading).toBe(false);
    });
    it('should jump back by <C-o>', async () => {
        let doc = await helper_1.default.createDocument();
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-o>');
        let bufnr = await nvim.call('bufnr', ['%']);
        expect(bufnr).toBe(doc.bufnr);
    });
    it('should scroll preview window by <C-e>, <C-y>', async () => {
        await helper_1.default.createDocument();
        await manager_1.default.start(['--auto-preview', '--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await waitPreviewWindow();
        let winnr = await nvim.call('coc#list#has_preview');
        let winid = await nvim.call('win_getid', [winnr]);
        await helper_1.default.listInput('<C-e>');
        let res = await nvim.call('getwininfo', [winid]);
        expect(res[0].topline).toBeGreaterThan(1);
        await helper_1.default.listInput('<C-y>');
        res = await nvim.call('getwininfo', [winid]);
        expect(res[0].topline).toBeLessThan(7);
    });
    it('should insert command by :', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput(':');
        await nvim.eval('feedkeys("let g:x = 1\\<cr>", "in")');
        let res = await nvim.getVar('x');
        expect(res).toBe(1);
    });
    it('should select action by <tab>', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        let p = helper_1.default.listInput('<tab>');
        await helper_1.default.wait(50);
        await nvim.input('t');
        await p;
        let nr = await nvim.call('tabpagenr');
        expect(nr).toBe(2);
    });
    it('should preview by p', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('p');
        let winnr = await nvim.call('coc#list#has_preview');
        expect(winnr).toBe(2);
    });
    it('should stop task by <C-c>', async () => {
        var _a;
        disposables.push(manager_1.default.registerList(new TestList()));
        let p = manager_1.default.start(['--normal', 'test']);
        await helper_1.default.wait(50);
        await nvim.input('<C-c>');
        await p;
        let len = (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.length;
        expect(len).toBe(0);
    });
    it('should cancel list by <esc>', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await nvim.eval('feedkeys("\\<esc>", "in")');
        await helper_1.default.waitValue(() => {
            return manager_1.default.isActivated;
        }, false);
    });
    it('should reload list by <C-l>', async () => {
        let list = new TestList();
        list.timeout = 0;
        disposables.push(manager_1.default.registerList(list));
        await manager_1.default.start(['--normal', 'test']);
        await manager_1.default.session.ui.ready;
        list.text = 'new';
        await helper_1.default.listInput('<C-l>');
        await helper_1.default.wait(30);
        let line = await nvim.line;
        expect(line).toMatch('new');
    });
    it('should toggle selection <space>', async () => {
        var _a, _b;
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput(' ');
        let selected = (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.selectedItems;
        expect(selected.length).toBe(1);
        await helper_1.default.listInput('k');
        await helper_1.default.listInput(' ');
        selected = (_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.ui.selectedItems;
        expect(selected.length).toBe(0);
    });
    it('should change to insert mode by i, o, a', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        let keys = ['i', 'I', 'o', 'O', 'a', 'A'];
        for (let key of keys) {
            await helper_1.default.listInput(key);
            let mode = manager_1.default.prompt.mode;
            expect(mode).toBe('insert');
            await helper_1.default.listInput('<C-o>');
            mode = manager_1.default.prompt.mode;
            expect(mode).toBe('normal');
        }
    });
    it('should show help by ?', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('?');
        let bufname = await nvim.call('bufname', '%');
        expect(bufname).toBe('[LIST HELP]');
    });
});
describe('list insert mappings', () => {
    it('should open by <cr>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<cr>');
        let bufname = await nvim.call('expand', ['%:p']);
        expect(bufname).toMatch('mappings.test.ts');
    });
    it('should paste input by <C-v>', async () => {
        await nvim.command('let @* = "foo"');
        await nvim.command('let @@ = "foo"');
        await nvim.call('setreg', ['*', 'foo']);
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-v>');
        let input = manager_1.default.prompt.input;
        expect(input).toBe('foo');
    });
    it('should insert register content by <C-r>', async () => {
        await nvim.command('let @* = "foo"');
        await nvim.command('let @@ = "foo"');
        await nvim.call('setreg', ['*', 'foo']);
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-r>');
        await helper_1.default.listInput('*');
        let input = manager_1.default.prompt.input;
        expect(input).toBe('foo');
        await helper_1.default.listInput('<C-r>');
        await helper_1.default.listInput('<');
        input = manager_1.default.prompt.input;
        expect(input).toBe('foo');
        manager_1.default.prompt.reset();
    });
    it('should cancel by <esc>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<esc>');
        expect(manager_1.default.isActivated).toBe(false);
    });
    it('should select action by insert <tab>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        let p = helper_1.default.listInput('<tab>');
        await helper_1.default.wait(50);
        await nvim.input('d');
        await p;
        let bufname = await nvim.call('bufname', ['%']);
        expect(bufname).toMatch(path_1.default.basename(__filename));
    });
    it('should select action for visual selected items', async () => {
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.waitPrompt();
        await nvim.input('V');
        await helper_1.default.wait(30);
        await nvim.input('2');
        await helper_1.default.wait(30);
        await nvim.input('j');
        await helper_1.default.wait(30);
        await manager_1.default.doAction('quickfix');
        let buftype = await nvim.eval('&buftype');
        expect(buftype).toBe('quickfix');
    });
    it('should stop loading by <C-c>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-c>');
        expect(manager_1.default.isActivated).toBe(true);
    });
    it('should reload by <C-l>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-l>');
        expect(manager_1.default.isActivated).toBe(true);
    });
    it('should change to normal mode by <C-o>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-o>');
        expect(manager_1.default.isActivated).toBe(true);
    });
    it('should select line by <down> and <up>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await nvim.eval('feedkeys("\\<down>", "in")');
        await nvim.eval('feedkeys("\\<up>", "in")');
        expect(manager_1.default.isActivated).toBe(true);
        let line = await nvim.line;
        expect(line).toMatch('foo');
    });
    it('should move cursor by <left> and <right>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('f');
        await helper_1.default.listInput('<left>');
        await helper_1.default.listInput('<left>');
        await helper_1.default.listInput('a');
        await helper_1.default.listInput('<right>');
        await helper_1.default.listInput('<right>');
        await helper_1.default.listInput('c');
        let input = manager_1.default.prompt.input;
        let mode = manager_1.default.prompt.mode;
        manager_1.default.prompt.input = input;
        manager_1.default.prompt.mode = mode;
        await helper_1.default.listInput('<home>');
        manager_1.default.prompt.removeNext();
        manager_1.default.prompt.removeNext();
        manager_1.default.prompt.removeNext();
        manager_1.default.prompt.removeNext();
        expect(input).toBe('afc');
    });
    it('should move cursor by <end> and <home>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('ff');
        await helper_1.default.listInput('<home>');
        await helper_1.default.listInput('<end>');
        await helper_1.default.listInput('<end>');
        let input = manager_1.default.prompt.input;
        manager_1.default.prompt.removeWord();
        manager_1.default.prompt.removeWord();
        manager_1.default.prompt.removeTail();
        manager_1.default.prompt.removeTail();
        expect(input).toBe('ff');
    });
    it('should move cursor by <PageUp> <PageDown> <C-d>', async () => {
        disposables.push(manager_1.default.registerList(lineList));
        await manager_1.default.start(['lines']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<PageDown>');
        await helper_1.default.listInput('<PageUp>');
        await helper_1.default.listInput('<C-d>');
    });
    it('should scroll window by <C-f> and <C-b>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-f>');
        await helper_1.default.listInput('<C-b>');
    });
    it('should change input by <Backspace>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('f');
        await helper_1.default.listInput('<backspace>');
        let input = manager_1.default.prompt.input;
        expect(input).toBe('');
    });
    it('should change input by <C-b>', async () => {
        let revert = helper_1.default.updateConfiguration('list.insertMappings', {
            '<C-b>': 'prompt:removetail',
        });
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('f');
        await helper_1.default.listInput('o');
        await helper_1.default.listInput('o');
        await helper_1.default.listInput('<C-a>');
        await helper_1.default.listInput('<C-b>');
        expect(manager_1.default.mappings.hasUserMapping('insert', '<C-b>')).toBe(true);
        let input = manager_1.default.prompt.input;
        revert();
        expect(input).toBe('');
    });
    it('should change input by <C-h>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('f');
        await helper_1.default.listInput('<C-h>');
        let input = manager_1.default.prompt.input;
        expect(input).toBe('');
    });
    it('should change input by <C-w>', async () => {
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('f');
        await helper_1.default.listInput('a');
        await helper_1.default.listInput('<C-w>');
        let input = manager_1.default.prompt.input;
        expect(input).toBe('');
    });
    it('should change input by <C-u>', async () => {
        await manager_1.default.start(['--input=a', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-u>');
        let input = manager_1.default.prompt.input;
        expect(input).toBe('');
    });
    it('should change input by <C-n> and <C-p>', async () => {
        async function session(input) {
            await manager_1.default.start(['location']);
            await manager_1.default.session.ui.ready;
            for (let ch of input) {
                await helper_1.default.listInput(ch);
            }
            await manager_1.default.cancel();
        }
        await session('foo');
        await session('bar');
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-n>');
        let input = manager_1.default.prompt.input;
        expect(input.length).toBeGreaterThan(0);
        await helper_1.default.listInput('<C-p>');
        input = manager_1.default.prompt.input;
        expect(input.length).toBeGreaterThan(0);
    });
    it('should change matcher by <C-s>', async () => {
        var _a, _b, _c;
        await manager_1.default.start(['location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('<C-s>');
        let matcher = (_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.listOptions.matcher;
        expect(matcher).toBe('strict');
        await helper_1.default.listInput('<C-s>');
        matcher = (_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.listOptions.matcher;
        expect(matcher).toBe('regex');
        await helper_1.default.listInput('f');
        let len = (_c = manager_1.default.session) === null || _c === void 0 ? void 0 : _c.ui.length;
        expect(len).toBeGreaterThan(0);
    });
});
describe('evalExpression', () => {
    it('should exit list', async () => {
        helper_1.default.updateConfiguration('list.normalMappings', {
            t: 'do:exit',
        });
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        expect(manager_1.default.mappings.hasUserMapping('normal', 't')).toBe(true);
        await helper_1.default.listInput('t');
        expect(manager_1.default.isActivated).toBe(false);
    });
    it('should cancel prompt', async () => {
        helper_1.default.updateConfiguration('list.normalMappings', {
            t: 'do:cancel',
        });
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('t');
        let res = await nvim.call('coc#prompt#activated');
        expect(res).toBe(0);
    });
    it('should invoke normal command', async () => {
        let revert = helper_1.default.updateConfiguration('list.normalMappings', {
            x: 'normal!:G'
        });
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('x');
        revert();
        let lnum = await nvim.call('line', ['.']);
        expect(lnum).toBeGreaterThan(1);
    });
    it('should toggle, scroll preview', async () => {
        let revert = helper_1.default.updateConfiguration('list.normalMappings', {
            '<space>': 'do:toggle',
            a: 'do:toggle',
            b: 'do:previewtoggle',
            c: 'do:previewup',
            d: 'do:previewdown',
            e: 'prompt:insertregister',
            f: 'do:stop',
            g: 'do:togglemode',
        });
        await manager_1.default.start(['--normal', 'location']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput(' ');
        for (let key of ['a', 'b', 'c', 'd', 'e', 'f', 'g']) {
            await helper_1.default.listInput(key);
        }
        revert();
        expect(manager_1.default.isActivated).toBe(true);
    });
});
//# sourceMappingURL=mappings.test.js.map