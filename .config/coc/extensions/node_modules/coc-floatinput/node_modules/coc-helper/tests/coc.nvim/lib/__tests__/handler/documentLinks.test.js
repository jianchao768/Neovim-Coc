"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const events_1 = tslib_1.__importDefault(require("../../events"));
const links_1 = require("../../handler/links");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let links;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    links = helper_1.default.plugin.getHandler().links;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('Links', () => {
    it('should check sameLinks', () => {
        expect((0, links_1.sameLinks)([], [])).toBe(true);
        expect((0, links_1.sameLinks)([{ range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1) }], [])).toBe(false);
        expect((0, links_1.sameLinks)([{ range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1) }], [{ range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0) }])).toBe(false);
    });
    it('should get document links', async () => {
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks: (_doc, _token) => {
                return [
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5), 'test:///foo'),
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5), 'test:///bar')
                ];
            }
        }));
        let res = await helper_1.default.doAction('links');
        expect(res.length).toBe(2);
    });
    it('should merge link results', async () => {
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks: () => {
                return [
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5), 'test:///foo'),
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5), 'test:///bar')
                ];
            }
        }));
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks: () => {
                return [
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5), 'test:///bar'),
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(2, 0, 2, 5), 'test:///x'),
                ];
            }
        }));
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks: () => {
                return null;
            }
        }));
        let res = await links.getLinks();
        expect(res.length).toBe(3);
        let link = await languages_1.default.resolveDocumentLink(res[0], vscode_languageserver_protocol_1.CancellationToken.None);
        expect(link).toBeDefined();
    });
    it('should throw error when link target not resolved', async () => {
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks(_doc, _token) {
                return [
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5))
                ];
            },
            resolveDocumentLink(link) {
                return link;
            }
        }));
        let res = await links.getLinks();
        let err;
        try {
            await links.openLink(res[0]);
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
    });
    it('should return link when resolve undefined', async () => {
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks(_doc, _token) {
                return [vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5), 'foo://1')];
            },
            resolveDocumentLink() {
                return undefined;
            }
        }));
        let res = await links.getLinks();
        let link = await languages_1.default.resolveDocumentLink(res[0], vscode_languageserver_protocol_1.CancellationToken.None);
        expect(link).toBeDefined();
    });
    it('should cancel resolve on InsertEnter', async () => {
        helper_1.default.updateConfiguration('links.tooltip', true);
        let doc = await workspace_1.default.document;
        let called = false;
        let cancelled = false;
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks(_doc, _token) {
                return [vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5))];
            },
            resolveDocumentLink(link, token) {
                called = true;
                return new Promise(resolve => {
                    token.onCancellationRequested(() => {
                        cancelled = true;
                        clearTimeout(timer);
                        resolve(undefined);
                    });
                    let timer = setTimeout(() => {
                        resolve(link);
                    }, 500);
                });
            }
        }));
        let p = links.showTooltip();
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        await events_1.default.fire('InsertEnter', [doc.bufnr]);
        await p;
        expect(cancelled).toBe(true);
    });
    it('should open link at current position', async () => {
        await nvim.setLine('foo');
        await nvim.command('normal! 0');
        disposables.push(workspace_1.default.registerTextDocumentContentProvider('test', {
            provideTextDocumentContent: () => {
                return 'test';
            }
        }));
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks(_doc, _token) {
                return [
                    vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5)),
                ];
            },
            resolveDocumentLink(link) {
                link.target = 'test:///foo';
                return link;
            }
        }));
        await helper_1.default.doAction('openLink');
        let bufname = await nvim.call('bufname', '%');
        expect(bufname).toBe('test:///foo');
        await nvim.call('setline', [1, ['a', 'b', 'c']]);
        await nvim.call('cursor', [3, 1]);
        let res = await links.openCurrentLink();
        expect(res).toBe(false);
    });
    it('should return false when current links not found', async () => {
        await nvim.setLine('foo');
        await nvim.command('normal! 0');
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks(_doc, _token) {
                return [];
            }
        }));
        let res = await links.openCurrentLink();
        expect(res).toBe(false);
    });
    it('should show tooltip', async () => {
        await nvim.setLine('foo');
        await nvim.call('cursor', [1, 1]);
        let resolve = false;
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks(_doc, _token) {
                let link = vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5));
                link.tooltip = 'test';
                return [link];
            },
            resolveDocumentLink(link) {
                if (!resolve)
                    return;
                link.target = 'http://example.com';
                return link;
            }
        }));
        await links.showTooltip();
        let win = await helper_1.default.getFloat();
        expect(win).toBeUndefined();
        helper_1.default.updateConfiguration('links.tooltip', true);
        await links.showTooltip();
        win = await helper_1.default.getFloat();
        expect(win).toBeUndefined();
        resolve = true;
        await links.showTooltip();
        win = await helper_1.default.getFloat();
        let buf = await win.buffer;
        let lines = await buf.lines;
        expect(lines[0]).toMatch('test');
    });
    it('should enable tooltip on CursorHold', async () => {
        let doc = await workspace_1.default.document;
        helper_1.default.updateConfiguration('links.tooltip', true);
        await nvim.setLine('http://www.baidu.com');
        await nvim.call('cursor', [1, 1]);
        let link = await links.getCurrentLink();
        expect(link).toBeDefined();
        await events_1.default.fire('CursorHold', [doc.bufnr]);
        let win = await helper_1.default.getFloat();
        let buf = await win.buffer;
        let lines = await buf.lines;
        expect(lines[0]).toMatch('baidu');
    });
});
describe('LinkBuffer', () => {
    it('should getLinks', async () => {
        let doc = await workspace_1.default.document;
        let buf = links.getBuffer(doc.bufnr);
        await buf.getLinks();
        expect(buf.links).toEqual([]);
        let timeout = 100;
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks: (_doc, token) => {
                return new Promise(resolve => {
                    token.onCancellationRequested(() => {
                        clearTimeout(timer);
                        resolve(undefined);
                    });
                    let timer = setTimeout(() => {
                        resolve([
                            vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5), 'test:///foo'),
                            vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5), 'test:///bar')
                        ]);
                    }, timeout);
                });
            }
        }));
        let p = buf.getLinks();
        p = buf.getLinks();
        buf.cancel();
        await p;
        expect(buf.links).toEqual([]);
    });
    it('should do highlight', async () => {
        let empty = false;
        disposables.push(languages_1.default.registerDocumentLinkProvider([{ language: '*' }], {
            provideDocumentLinks: (doc) => {
                if (empty)
                    return [];
                let links = [];
                for (let i = 0; i < doc.lineCount - 1; i++) {
                    links.push(vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(i, 0, i, 1), 'test:///bar'));
                }
                return links;
            }
        }));
        helper_1.default.updateConfiguration('links.highlight', true);
        let doc = await helper_1.default.createDocument();
        await nvim.setLine('foo');
        await doc.synchronize();
        let buf = links.getBuffer(doc.bufnr);
        await helper_1.default.waitValue(() => {
            var _a;
            return (_a = buf.links) === null || _a === void 0 ? void 0 : _a.length;
        }, 1);
        await nvim.call('append', [0, ['foo']]);
        doc._forceSync();
        await helper_1.default.waitValue(() => {
            var _a;
            return (_a = buf.links) === null || _a === void 0 ? void 0 : _a.length;
        }, 2);
        await nvim.setLine('foo');
        doc._forceSync();
        let hls = await buf.buffer.getHighlights('links');
        expect(hls.length).toBe(2);
        empty = true;
        await buf.getLinks();
        hls = await buf.buffer.getHighlights('links');
        expect(hls.length).toBe(0);
    });
});
//# sourceMappingURL=documentLinks.test.js.map