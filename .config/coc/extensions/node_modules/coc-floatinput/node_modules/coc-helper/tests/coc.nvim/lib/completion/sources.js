'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceType = exports.logError = exports.Sources = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const extension_1 = tslib_1.__importDefault(require("../extension"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const fs_1 = require("../util/fs");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const keywords_1 = require("./keywords");
const source_1 = tslib_1.__importDefault(require("./source"));
const source_language_1 = tslib_1.__importDefault(require("./source-language"));
const source_vim_1 = tslib_1.__importDefault(require("./source-vim"));
const types_1 = require("./types");
const util_2 = require("./util");
const logger = (0, logger_1.createLogger)('sources');
/**
 * For static words, must be triggered by source option.
 * Used for completion of snippet choices.
 */
class WordsSource {
    constructor() {
        this.name = '$words';
        this.shortcut = '';
        this.triggerOnly = true;
        this.words = [];
    }
    doComplete(opt) {
        return {
            items: this.words.map(s => {
                return { word: s, filterText: opt.input };
            })
        };
    }
}
class Sources {
    constructor() {
        this.sourceMap = new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
        this.wordsSource = new WordsSource();
    }
    init() {
        this.keywords = workspace_1.default.registerBufferSync(doc => {
            return new keywords_1.KeywordsBuffer(doc);
        });
        this.createNativeSources();
        this.createRemoteSources();
        events_1.default.on('BufEnter', this.onDocumentEnter, this, this.disposables);
        workspace_1.default.onDidRuntimePathChange(newPaths => {
            for (let p of newPaths) {
                this.createVimSources(p).catch(logError);
            }
        }, null, this.disposables);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    getKeywordsBuffer(bufnr) {
        return this.keywords.getItem(bufnr);
    }
    setWords(words) {
        this.wordsSource.words = words;
    }
    createNativeSources() {
        this.sourceMap.set(this.wordsSource.name, this.wordsSource);
        void Promise.all([
            Promise.resolve().then(() => tslib_1.__importStar(require('./native/around'))).then(module => { module.register(this.sourceMap, this.keywords); }),
            Promise.resolve().then(() => tslib_1.__importStar(require('./native/buffer'))).then(module => { module.register(this.sourceMap, this.keywords); }),
            Promise.resolve().then(() => tslib_1.__importStar(require('./native/file'))).then(module => { module.register(this.sourceMap); })
        ]);
    }
    createLanguageSource(name, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters) {
        let source = new source_language_1.default(name, shortcut, provider, selector, (0, array_1.toArray)(triggerCharacters), (0, array_1.toArray)(allCommitCharacters), priority);
        logger.trace('created service source', name);
        this.sourceMap.set(name, source);
        return {
            dispose: () => {
                this.sourceMap.delete(name);
            }
        };
    }
    async createVimSourceExtension(filepath) {
        var _a, _b, _c;
        let { nvim } = this;
        try {
            let name = node_1.path.basename(filepath, '.vim');
            await nvim.command(`source ${filepath}`);
            let fns = await nvim.call('coc#util#remote_fns', name);
            for (let fn of ['init', 'complete']) {
                if (!fns.includes(fn)) {
                    throw new Error(`function "coc#source#${name}#${fn}" not found`);
                }
            }
            let props = await nvim.call(`coc#source#${name}#init`, []);
            let packageJSON = {
                name: `coc-vim-source-${name}`,
                engines: {
                    coc: ">= 0.0.1"
                },
                activationEvents: props.filetypes ? props.filetypes.map(f => `onLanguage:${f}`) : ['*'],
                contributes: {
                    configuration: {
                        properties: {
                            [`coc.source.${name}.enable`]: {
                                type: 'boolean',
                                default: true
                            },
                            [`coc.source.${name}.firstMatch`]: {
                                type: 'boolean',
                                default: !!props.firstMatch
                            },
                            [`coc.source.${name}.triggerCharacters`]: {
                                type: 'number',
                                default: (_a = props.triggerCharacters) !== null && _a !== void 0 ? _a : []
                            },
                            [`coc.source.${name}.priority`]: {
                                type: 'number',
                                default: (_b = props.priority) !== null && _b !== void 0 ? _b : 9
                            },
                            [`coc.source.${name}.shortcut`]: {
                                type: 'string',
                                default: (_c = props.shortcut) !== null && _c !== void 0 ? _c : name.slice(0, 3).toUpperCase(),
                                description: 'Shortcut text shown in complete menu.'
                            },
                            [`coc.source.${name}.disableSyntaxes`]: {
                                type: 'array',
                                default: [],
                                items: {
                                    type: 'string'
                                }
                            },
                            [`coc.source.${name}.filetypes`]: {
                                type: 'array',
                                default: props.filetypes || null,
                                description: 'Enabled filetypes.',
                                items: {
                                    type: 'string'
                                }
                            }
                        }
                    }
                }
            };
            let isActive = false;
            let extension = {
                id: packageJSON.name,
                packageJSON,
                exports: void 0,
                extensionPath: filepath,
                activate: () => {
                    isActive = true;
                    let source = new source_vim_1.default({
                        name,
                        filepath,
                        isSnippet: props.isSnippet,
                        sourceType: types_1.SourceType.Remote,
                        triggerOnly: !!props.triggerOnly,
                        optionalFns: fns.filter(n => !['init', 'complete'].includes(n))
                    });
                    this.addSource(source);
                    return Promise.resolve();
                }
            };
            Object.defineProperty(extension, 'isActive', {
                get: () => isActive
            });
            await extension_1.default.manager.registerInternalExtension(extension, () => {
                isActive = false;
                this.removeSource(name);
            });
        }
        catch (e) {
            void window_1.default.showErrorMessage(`Error on create vim source from ${filepath}: ${e}`);
        }
    }
    createRemoteSources() {
        let paths = workspace_1.default.env.runtimepath.split(',');
        for (let path of paths) {
            this.createVimSources(path).catch(logError);
        }
    }
    async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath) || !pluginPath)
            return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = node_1.path.join(pluginPath, 'autoload/coc/source');
        let stat = await (0, fs_1.statAsync)(folder);
        if (stat && stat.isDirectory()) {
            let arr = await (0, node_1.promisify)(node_1.fs.readdir)(folder);
            let files = arr.filter(s => s.endsWith('.vim')).map(s => node_1.path.join(folder, s));
            await Promise.allSettled(files.map(p => this.createVimSourceExtension(p)));
        }
    }
    get names() {
        return Array.from(this.sourceMap.keys());
    }
    get sources() {
        return Array.from(this.sourceMap.values());
    }
    has(name) {
        return this.names.findIndex(o => o == name) != -1;
    }
    getSource(name) {
        var _a;
        return (_a = this.sourceMap.get(name)) !== null && _a !== void 0 ? _a : null;
    }
    shouldCommit(source, item, commitCharacter) {
        if (!item || source == null)
            return false;
        if (Is.func(source.shouldCommit)) {
            return source.shouldCommit(item, commitCharacter);
        }
        return false;
    }
    getSources(opt) {
        let { source } = opt;
        if (source)
            return (0, array_1.toArray)(this.getSource(source));
        let uri = workspace_1.default.getUri(opt.bufnr);
        return this.getNormalSources(opt.filetype, uri);
    }
    /**
     * Get sources should be used without trigger.
     *
     * @param {string} filetype
     * @returns {ISource[]}
     */
    getNormalSources(filetype, uri) {
        let languageIds = filetype.split('.');
        let res = this.sources.filter(source => {
            let { filetypes, triggerOnly, documentSelector, enable } = source;
            if (!enable || triggerOnly || (filetypes && !(0, array_1.intersect)(filetypes, languageIds)))
                return false;
            if (documentSelector && languageIds.every(filetype => workspace_1.default.match(documentSelector, { uri, languageId: filetype }) == 0))
                return false;
            return true;
        });
        return res;
    }
    checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if (!(0, array_1.isFalsyOrEmpty)(triggerCharacters) && triggerCharacters.includes(character)) {
            return true;
        }
        if (!(0, array_1.isFalsyOrEmpty)(triggerPatterns) && triggerPatterns.findIndex(p => p.test(pre)) !== -1) {
            return true;
        }
        return false;
    }
    shouldTrigger(pre, filetype, uri) {
        return this.getTriggerSources(pre, filetype, uri).length > 0;
    }
    getTriggerSources(pre, filetype, uri, disabled = []) {
        if (!pre)
            return [];
        let character = pre[pre.length - 1];
        let languageIds = filetype.split('.');
        return this.sources.filter(source => {
            let { filetypes, enable, documentSelector, name } = source;
            if (disabled.includes(name))
                return false;
            if (!enable || (filetypes && !(0, array_1.intersect)(filetypes, languageIds)))
                return false;
            if (documentSelector && languageIds.every(languageId => workspace_1.default.match(documentSelector, { uri, languageId }) == 0)) {
                return false;
            }
            return this.checkTrigger(source, pre, character);
        });
    }
    addSource(source) {
        let { name } = source;
        if (this.names.includes(name)) {
            logger.warn(`Recreate source ${name}`);
        }
        this.sourceMap.set(name, source);
        return protocol_1.Disposable.create(() => {
            this.removeSource(source);
        });
    }
    removeSource(source) {
        let name = typeof source == 'string' ? source : source.name;
        let obj = typeof source === 'string' ? this.sourceMap.get(source) : source;
        if (obj && typeof obj.dispose === 'function')
            obj.dispose();
        this.sourceMap.delete(name);
    }
    async refresh(name) {
        for (let source of this.sources) {
            if (!name || source.name == name) {
                if (typeof source.refresh === 'function') {
                    await Promise.resolve(source.refresh());
                }
            }
        }
    }
    toggleSource(name) {
        let source = this.getSource(name);
        if (source && typeof source.toggle === 'function') {
            source.toggle();
        }
    }
    sourceStats() {
        var _a, _b;
        let stats = [];
        let languageSourcePriority = workspace_1.default.initialConfiguration.get('suggest.languageSourcePriority');
        for (let item of this.sourceMap.values()) {
            if (item.name === '$words')
                continue;
            stats.push({
                name: item.name,
                priority: (0, util_2.getPriority)(item, languageSourcePriority),
                triggerCharacters: (0, array_1.toArray)(item.triggerCharacters),
                shortcut: (0, string_1.toText)(item.shortcut),
                filetypes: (0, array_1.toArray)((_a = item.filetypes) !== null && _a !== void 0 ? _a : (_b = item.documentSelector) === null || _b === void 0 ? void 0 : _b.map(o => Is.string(o) ? o : o.language)),
                filepath: (0, string_1.toText)(item.filepath),
                type: getSourceType(item.sourceType),
                disabled: !item.enable
            });
        }
        return stats;
    }
    onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
            if (s.enable && Is.func(s.onEnter)) {
                s.onEnter(bufnr);
            }
        }
    }
    createSource(config) {
        if (typeof config.name !== 'string' || typeof config.doComplete !== 'function') {
            logger.error(`Bad config for createSource:`, config);
            throw new TypeError(`name and doComplete required for createSource`);
        }
        let source = new source_1.default(Object.assign({ sourceType: types_1.SourceType.Service }, config));
        return this.addSource(source);
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.Sources = Sources;
function logError(err) {
    logger.error('Error on source create', err);
}
exports.logError = logError;
function getSourceType(sourceType) {
    if (sourceType === types_1.SourceType.Native)
        return 'native';
    if (sourceType === types_1.SourceType.Remote)
        return 'remote';
    return 'service';
}
exports.getSourceType = getSourceType;
exports.default = new Sources();
//# sourceMappingURL=sources.js.map