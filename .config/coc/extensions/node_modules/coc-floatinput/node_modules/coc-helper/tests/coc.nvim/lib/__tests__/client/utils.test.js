"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable */
const assert_1 = tslib_1.__importDefault(require("assert"));
const async_1 = require("../../language-client/utils/async");
const logger_1 = require("../../language-client/utils/logger");
const index_1 = require("../../util/index");
const errorHandler_1 = require("../../language-client/utils/errorHandler");
const utils_1 = require("../../language-client/utils");
test('Logger', () => {
    const logger = new logger_1.ConsoleLogger();
    logger.error('error');
    logger.warn('warn');
    logger.info('info');
    logger.log('log');
    const nullLogger = new logger_1.NullLogger();
    nullLogger.error('error');
    nullLogger.warn('warn');
    nullLogger.info('info');
    nullLogger.log('log');
});
test('getLocale', () => {
    process.env.LANG = '';
    expect((0, utils_1.getLocale)()).toBe('en');
    process.env.LANG = 'en_US.UTF-8';
    expect((0, utils_1.getLocale)()).toBe('en_US');
});
test('getTraceMessage', () => {
    expect((0, utils_1.getTraceMessage)({})).toMatch('Trace');
    expect((0, utils_1.getTraceMessage)({ isLSPMessage: true, type: 'request' })).toMatch('LSP');
});
test('data2String', () => {
    let err = new Error('my error');
    err.stack = undefined;
    let text = (0, utils_1.data2String)(err);
    expect(text).toMatch('error');
});
test('parseTraceData', () => {
    expect((0, utils_1.parseTraceData)('msg')).toMatch('msg');
    expect((0, utils_1.parseTraceData)('Params: data')).toMatch('data');
    expect((0, utils_1.parseTraceData)('Result: {"foo": bar}')).toMatch('bar');
});
test('DefaultErrorHandler', async () => {
    let spy = jest.spyOn(console, 'error').mockImplementation(() => {
        // ignore
    });
    const handler = new errorHandler_1.DefaultErrorHandler('test', 2);
    expect(handler.error(new Error('test'), { jsonrpc: '' }, 1)).toBe(errorHandler_1.ErrorAction.Continue);
    expect(handler.error(new Error('test'), { jsonrpc: '' }, 5)).toBe(errorHandler_1.ErrorAction.Shutdown);
    handler.closed();
    handler.milliseconds = 1;
    await (0, index_1.wait)(10);
    let res = handler.closed();
    expect(res).toBe(errorHandler_1.CloseAction.Restart);
    handler.milliseconds = 10 * 1000;
    res = handler.closed();
    expect(res).toBe(errorHandler_1.CloseAction.DoNotRestart);
    spy.mockRestore();
});
test('Delayer', () => {
    let count = 0;
    let factory = () => {
        return Promise.resolve(++count);
    };
    let delayer = new async_1.Delayer(0);
    let promises = [];
    (0, assert_1.default)(!delayer.isTriggered());
    promises.push(delayer.trigger(factory).then((result) => { assert_1.default.equal(result, 1); (0, assert_1.default)(!delayer.isTriggered()); }));
    (0, assert_1.default)(delayer.isTriggered());
    promises.push(delayer.trigger(factory).then((result) => { assert_1.default.equal(result, 1); (0, assert_1.default)(!delayer.isTriggered()); }));
    (0, assert_1.default)(delayer.isTriggered());
    promises.push(delayer.trigger(factory).then((result) => { assert_1.default.equal(result, 1); (0, assert_1.default)(!delayer.isTriggered()); }));
    (0, assert_1.default)(delayer.isTriggered());
    return Promise.all(promises).then(() => {
        (0, assert_1.default)(!delayer.isTriggered());
    }).finally(() => {
        delayer.dispose();
    });
});
test('Delayer - forceDelivery', async () => {
    let count = 0;
    let factory = () => {
        return Promise.resolve(++count);
    };
    let delayer = new async_1.Delayer(150);
    delayer.forceDelivery();
    delayer.trigger(factory).then((result) => { assert_1.default.equal(result, 1); (0, assert_1.default)(!delayer.isTriggered()); });
    await (0, index_1.wait)(10);
    delayer.forceDelivery();
    expect(count).toBe(1);
    void delayer.trigger(factory);
    delayer.trigger(factory, -1);
    await (0, index_1.wait)(10);
    delayer.cancel();
    expect(count).toBe(1);
});
test('Delayer - last task should be the one getting called', function () {
    let factoryFactory = (n) => () => {
        return Promise.resolve(n);
    };
    let delayer = new async_1.Delayer(0);
    let promises = [];
    (0, assert_1.default)(!delayer.isTriggered());
    promises.push(delayer.trigger(factoryFactory(1)).then((n) => { assert_1.default.equal(n, 3); }));
    promises.push(delayer.trigger(factoryFactory(2)).then((n) => { assert_1.default.equal(n, 3); }));
    promises.push(delayer.trigger(factoryFactory(3)).then((n) => { assert_1.default.equal(n, 3); }));
    const p = Promise.all(promises).then(() => {
        (0, assert_1.default)(!delayer.isTriggered());
    });
    (0, assert_1.default)(delayer.isTriggered());
    return p;
});
//# sourceMappingURL=utils.test.js.map