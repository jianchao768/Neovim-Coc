"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dialogs = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const dialog_1 = require("../model/dialog");
const input_1 = tslib_1.__importDefault(require("../model/input"));
const menu_1 = tslib_1.__importDefault(require("../model/menu"));
const picker_1 = tslib_1.__importStar(require("../model/picker"));
const quickpick_1 = tslib_1.__importDefault(require("../model/quickpick"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const mutex_1 = require("../util/mutex");
const numbers_1 = require("../util/numbers");
const platform_1 = require("../util/platform");
const string_1 = require("../util/string");
const funcs_1 = require("./funcs");
const ui_1 = require("./ui");
class Dialogs {
    constructor() {
        this.mutex = new mutex_1.Mutex();
    }
    async showDialog(config) {
        return await this.mutex.use(async () => {
            let dialog = new dialog_1.Dialog(this.nvim, config);
            await dialog.show(this.dialogPreference);
            return dialog;
        });
    }
    async showPrompt(title) {
        return await this.mutex.use(() => {
            return (0, ui_1.showPrompt)(this.nvim, title);
        });
    }
    async createQuickPick(config) {
        return await this.mutex.use(async () => {
            let quickpick = new quickpick_1.default(this.nvim, this.dialogPreference);
            Object.assign(quickpick, config);
            return quickpick;
        });
    }
    async showMenuPicker(items, option, token) {
        return await this.mutex.use(async () => {
            if (token && token.isCancellationRequested)
                return -1;
            option = option || {};
            if (typeof option === 'string')
                option = { title: option };
            let menu = new menu_1.default(this.nvim, Object.assign({ items }, option), token);
            let promise = new Promise(resolve => {
                menu.onDidClose(selected => {
                    events_1.default.race(['BufHidden'], 20).finally(() => {
                        resolve(selected);
                    });
                });
            });
            await menu.show(this.dialogPreference);
            return await promise;
        });
    }
    /**
     * Shows a selection list.
     */
    async showQuickPick(itemsOrItemsPromise, options, token) {
        if ((0, array_1.isFalsyOrEmpty)(itemsOrItemsPromise))
            return undefined;
        options = (0, util_1.defaultValue)(options, {});
        const items = await Promise.resolve(itemsOrItemsPromise);
        let isText = items.some(s => typeof s === 'string');
        return await this.mutex.use(() => {
            return new Promise((resolve, reject) => {
                if (token.isCancellationRequested)
                    return resolve(undefined);
                let quickpick = new quickpick_1.default(this.nvim, this.dialogPreference);
                quickpick.items = items.map(o => typeof o === 'string' ? { label: o } : o);
                quickpick.title = (0, string_1.toText)(options.title);
                quickpick.placeHolder = options.placeholder;
                quickpick.canSelectMany = !!options.canPickMany;
                quickpick.matchOnDescription = options.matchOnDescription;
                quickpick.onDidFinish(items => {
                    if (items == null)
                        return resolve(undefined);
                    let arr = isText ? items.map(o => o.label) : items;
                    if (options.canPickMany)
                        return resolve(arr);
                    resolve(arr[0]);
                });
                quickpick.show().catch(reject);
            });
        });
    }
    async showPickerDialog(items, title, token) {
        return await this.mutex.use(async () => {
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const picker = new picker_1.default(this.nvim, {
                title,
                items: (0, picker_1.toPickerItems)(items),
            }, token);
            let promise = new Promise(resolve => {
                picker.onDidClose(selected => {
                    resolve(selected);
                });
            });
            await picker.show(this.dialogPreference);
            let picked = await promise;
            return picked == undefined ? undefined : items.filter((_, i) => picked.includes(i));
        });
    }
    async requestInput(title, env, value, option) {
        let { nvim } = this;
        const promptInput = this.configuration.get('coc.preferences.promptInput');
        const inputSupported = !constants_1.isVim || ((0, funcs_1.has)(env, 'patch-8.2.750') && !platform_1.isWindows);
        if (promptInput && inputSupported) {
            return await this.mutex.use(async () => {
                let input = new input_1.default(nvim, (0, string_1.toText)(value));
                await input.show(title, Object.assign(this.inputPreference, (0, util_1.defaultValue)(option, {})));
                return await new Promise(resolve => {
                    input.onDidFinish(text => {
                        setTimeout(() => {
                            resolve(text);
                        }, 20);
                    });
                });
            });
        }
        else {
            return await this.mutex.use(async () => {
                let res = await (0, funcs_1.callAsync)(this.nvim, 'input', [title + ': ', (0, string_1.toText)(value)]);
                nvim.command('normal! :<C-u>', true);
                return res;
            });
        }
    }
    async createInputBox(title, value, option) {
        let input = new input_1.default(this.nvim, (0, string_1.toText)(value));
        await input.show(title, Object.assign(this.inputPreference, (0, util_1.defaultValue)(option, {})));
        return input;
    }
    get inputPreference() {
        let config = this.configuration.get('dialog');
        return {
            rounded: !!config.rounded,
            maxWidth: (0, numbers_1.toNumber)(config.maxWidth, 80),
            highlight: (0, util_1.defaultValue)(config.floatHighlight, constants_1.floatHighlightGroup),
            borderhighlight: (0, util_1.defaultValue)(config.floatBorderHighlight, constants_1.floatHighlightGroup)
        };
    }
    get dialogPreference() {
        let config = this.configuration.get('dialog');
        return {
            rounded: !!config.rounded,
            maxWidth: (0, numbers_1.toNumber)(config.maxWidth, 80),
            maxHeight: config.maxHeight,
            floatHighlight: (0, util_1.defaultValue)(config.floatHighlight, constants_1.floatHighlightGroup),
            floatBorderHighlight: (0, util_1.defaultValue)(config.floatBorderHighlight, constants_1.floatHighlightGroup),
            pickerButtons: config.pickerButtons,
            pickerButtonShortcut: config.pickerButtonShortcut,
            confirmKey: (0, string_1.toText)(config.confirmKey),
            shortcutHighlight: (0, string_1.toText)(config.shortcutHighlight)
        };
    }
}
exports.Dialogs = Dialogs;
//# sourceMappingURL=dialogs.js.map