'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const v8_1 = require("v8");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const workspaceFolder_1 = require("../core/workspaceFolder");
const extension_1 = tslib_1.__importDefault(require("../extension"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const logger_1 = require("../logger");
const highligher_1 = tslib_1.__importDefault(require("../model/highligher"));
const manager_1 = tslib_1.__importDefault(require("../snippets/manager"));
const util_1 = require("../util");
const constants_1 = require("../util/constants");
const errors_1 = require("../util/errors");
const fs_1 = require("../util/fs");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
class WorkspaceHandler {
    constructor(nvim) {
        this.nvim = nvim;
        // exported by window.
        Object.defineProperty(window_1.default, 'openLocalConfig', {
            get: () => this.openLocalConfig.bind(this)
        });
        commands_1.default.register({
            id: 'workspace.openLocation',
            execute: async (winid, loc, openCommand) => {
                if (winid)
                    await nvim.call('win_gotoid', [winid]);
                await workspace_1.default.jumpTo(loc.uri, loc.range.start, openCommand);
            }
        }, true);
        commands_1.default.register({
            id: 'workspace.undo',
            execute: async () => {
                await workspace_1.default.files.undoWorkspaceEdit();
            }
        }, false, 'Undo previous this.workspace edit');
        commands_1.default.register({
            id: 'workspace.redo',
            execute: async () => {
                await workspace_1.default.files.redoWorkspaceEdit();
            }
        }, false, 'Redo previous this.workspace edit');
        commands_1.default.register({
            id: 'workspace.inspectEdit',
            execute: async () => {
                await workspace_1.default.files.inspectEdit();
            }
        }, false, 'Inspect previous this.workspace edit in new tab');
        commands_1.default.register({
            id: 'workspace.renameCurrentFile',
            execute: async () => {
                await this.renameCurrent();
            }
        }, false, 'change current filename to a new name and reload it.');
        commands_1.default.register({
            id: 'document.checkBuffer',
            execute: async () => {
                await this.bufferCheck();
            }
        }, false, 'Check providers for current buffer.');
        commands_1.default.register({
            id: 'document.echoFiletype',
            execute: async () => {
                let bufnr = await nvim.call('bufnr', '%');
                let doc = workspace_1.default.getAttachedDocument(bufnr);
                await window_1.default.echoLines([doc.filetype]);
            }
        }, false, 'echo the mapped filetype of the current buffer');
        commands_1.default.register({
            id: 'workspace.workspaceFolders',
            execute: async () => {
                let folders = workspace_1.default.workspaceFolders;
                let lines = folders.map(folder => vscode_uri_1.URI.parse(folder.uri).fsPath);
                await window_1.default.echoLines(lines);
            }
        }, false, 'show opened workspaceFolders.');
        commands_1.default.register({
            id: 'workspace.writeHeapSnapshot',
            execute: async () => {
                let filepath = node_1.path.join(node_1.os.homedir(), `${(0, uuid_1.v4)()}-${process.pid}.heapsnapshot`);
                (0, v8_1.writeHeapSnapshot)(filepath);
                void window_1.default.showInformationMessage(`Create heapdump at: ${filepath}`);
                return filepath;
            }
        }, false, 'Generates a snapshot of the current V8 heap and writes it to a JSON file.');
        commands_1.default.register({
            id: 'workspace.showOutput',
            execute: async (name) => {
                if (!name)
                    name = await window_1.default.showQuickPick(workspace_1.default.channelNames, { title: 'Choose output name' });
                window_1.default.showOutputChannel((0, string_1.toText)(name));
            }
        }, false, 'open output buffer to show output from languageservers or extensions.');
        commands_1.default.register({
            id: 'workspace.clearWatchman',
            execute: async () => {
                let res = await window_1.default.runTerminalCommand('watchman watch-del-all');
                if (res.success)
                    void window_1.default.showInformationMessage('Cleared watchman watching directories.');
                return res.success;
            }
        }, false, 'run watch-del-all for watchman to free up memory.');
    }
    async openLog() {
        let file = (0, logger_1.getLoggerFile)();
        await workspace_1.default.jumpTo(vscode_uri_1.URI.file(file).toString());
    }
    /**
     * Open local config file
     */
    async openLocalConfig() {
        let fsPath = await this.nvim.call('expand', ['%:p']);
        let filetype = await this.nvim.eval('&filetype');
        if (!fsPath || !node_1.path.isAbsolute(fsPath)) {
            void window_1.default.showWarningMessage(`Current buffer doesn't have valid file path.`);
            return;
        }
        let folder = workspace_1.default.getWorkspaceFolder(vscode_uri_1.URI.file(fsPath).toString());
        if (!folder) {
            let c = workspace_1.default.initialConfiguration.get('workspace');
            let patterns = (0, util_1.defaultValue)(c.rootPatterns, []);
            let ignored = (0, util_1.defaultValue)(c.ignoredFiletypes, []);
            let msg;
            if (ignored.includes(filetype))
                msg = `Filetype '${filetype}' is ignored for workspace folder resolve.`;
            if (!msg)
                msg = `Can't resolve workspace folder for file '${fsPath}, consider create one of ${patterns.join(', ')} in your project root.'.`;
            void window_1.default.showWarningMessage(msg);
            return;
        }
        let root = vscode_uri_1.URI.parse(folder.uri).fsPath;
        let dir = node_1.path.join(root, '.vim');
        if (!node_1.fs.existsSync(dir)) {
            let res = await window_1.default.showPrompt(`Would you like to create folder'${root}/.vim'?`);
            if (!res)
                return;
            node_1.fs.mkdirSync(dir);
        }
        await workspace_1.default.jumpTo(vscode_uri_1.URI.file(node_1.path.join(dir, constants_1.CONFIG_FILE_NAME)));
    }
    async renameCurrent() {
        let { nvim } = this;
        let oldPath = await nvim.call('expand', ['%:p']);
        // await nvim.callAsync()
        let newPath = await nvim.callAsync('coc#util#with_callback', ['input', ['New path: ', oldPath, 'file']]);
        newPath = newPath ? newPath.trim() : null;
        if (newPath === oldPath || !newPath)
            return;
        if (oldPath.toLowerCase() != newPath.toLowerCase() && node_1.fs.existsSync(newPath)) {
            let overwrite = await window_1.default.showPrompt(`${newPath} exists, overwrite?`);
            if (!overwrite)
                return;
        }
        await workspace_1.default.renameFile(oldPath, newPath, { overwrite: true });
    }
    addWorkspaceFolder(folder) {
        if (!Is.string(folder))
            throw TypeError(`folder should be string`);
        folder = workspace_1.default.expand(folder);
        if (!(0, fs_1.isDirectory)(folder))
            throw (0, errors_1.directoryNotExists)(folder);
        workspace_1.default.workspaceFolderControl.addWorkspaceFolder(folder, true);
    }
    async bufferCheck() {
        let doc = await workspace_1.default.document;
        if (!doc.attached) {
            await window_1.default.showDialog({
                title: 'Buffer check result',
                content: `Document not attached, ${doc.notAttachReason}`,
                highlight: 'WarningMsg'
            });
            return;
        }
        let hi = new highligher_1.default();
        hi.addLine('Provider state', 'Title');
        hi.addLine('');
        for (let name of Object.values(languages_1.ProviderName)) {
            if (name === languages_1.ProviderName.OnTypeEdit)
                continue;
            let exists = languages_1.default.hasProvider(name, doc.textDocument);
            hi.addTexts([
                { text: '-', hlGroup: 'Comment' },
                { text: ' ' },
                exists ? { text: '✓', hlGroup: 'CocListFgGreen' } : { text: '✗', hlGroup: 'CocListFgRed' },
                { text: ' ' },
                { text: name, hlGroup: exists ? 'Normal' : 'CocFadeOut' }
            ]);
        }
        await window_1.default.showDialog({
            title: 'Buffer check result',
            content: hi.content,
            highlights: hi.highlights
        });
    }
    async doAutocmd(id, args) {
        await workspace_1.default.autocmds.doAutocmd(id, args);
    }
    async getConfiguration(key) {
        let document = await workspace_1.default.document;
        return workspace_1.default.getConfiguration(key, document ? document.uri : undefined);
    }
    getRootPatterns(bufnr) {
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return null;
        return {
            buffer: workspace_1.default.workspaceFolderControl.getRootPatterns(doc, workspaceFolder_1.PatternType.Buffer),
            server: workspace_1.default.workspaceFolderControl.getRootPatterns(doc, workspaceFolder_1.PatternType.LanguageServer) || [],
            global: workspace_1.default.workspaceFolderControl.getRootPatterns(doc, workspaceFolder_1.PatternType.Global)
        };
    }
    async ensureDocument() {
        let doc = await workspace_1.default.document;
        return doc && doc.attached;
    }
    async doKeymap(key, defaultReturn = '') {
        return await workspace_1.default.keymaps.doKeymap(key, defaultReturn);
    }
    async snippetCheck(checkExpand, checkJump) {
        if (checkJump) {
            let jumpable = manager_1.default.jumpable();
            if (jumpable)
                return true;
        }
        if (checkExpand) {
            let expandable = await Promise.resolve(extension_1.default.manager.call('coc-snippets', 'expandable', []));
            if (expandable)
                return true;
        }
        return false;
    }
    async showInfo() {
        let lines = [];
        let version = workspace_1.default.version + (typeof REVISION === 'string' ? '-' + REVISION : '');
        lines.push('## versions');
        lines.push('');
        let out = await this.nvim.call('execute', ['version']);
        let first = out.trim().split(/\r?\n/, 2)[0].replace(/\(.*\)/, '').trim();
        lines.push('vim version: ' + first + `${workspace_1.default.isVim ? ' ' + workspace_1.default.env.version : ''}`);
        lines.push('node version: ' + process.version);
        lines.push('coc.nvim version: ' + version);
        lines.push('coc.nvim directory: ' + node_1.path.dirname(__dirname));
        lines.push('term: ' + (process.env.TERM_PROGRAM || process.env.TERM));
        lines.push('platform: ' + process.platform);
        lines.push('');
        lines.push('## Log of coc.nvim');
        lines.push('');
        let file = (0, logger_1.getLoggerFile)();
        const stripAnsi = require('strip-ansi');
        if (node_1.fs.existsSync(file)) {
            let content = node_1.fs.readFileSync(file, { encoding: 'utf8' });
            lines.push(...content.split(/\r?\n/).map(line => stripAnsi(line)));
        }
        await this.nvim.command('vnew +setl\\ buftype=nofile\\ bufhidden=wipe\\ nobuflisted');
        let buf = await this.nvim.buffer;
        await buf.setLines(lines, { start: 0, end: -1, strictIndexing: false });
    }
}
exports.default = WorkspaceHandler;
//# sourceMappingURL=workspace.js.map