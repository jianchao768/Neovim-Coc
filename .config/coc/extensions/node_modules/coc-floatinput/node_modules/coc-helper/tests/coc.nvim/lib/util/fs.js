'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.isParentFolder = exports.normalizeFilePath = exports.parentDirs = exports.isFile = exports.writeFile = exports.fileStartsWith = exports.sameFile = exports.lineToLocation = exports.readFileLine = exports.readFileLines = exports.getFileLineCount = exports.readFile = exports.findUp = exports.findMatch = exports.inDirectory = exports.checkFolder = exports.resolveRoot = exports.isGitIgnored = exports.getFileType = exports.remove = exports.renameAsync = exports.isDirectory = exports.statAsync = exports.writeJson = exports.loadJson = exports.watchFile = exports.FileType = void 0;
const tslib_1 = require("tslib");
const jsonc_parser_1 = require("jsonc-parser");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const logger_1 = require("../logger");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const array_1 = require("./array");
const errors_1 = require("./errors");
const node_2 = require("./node");
const object_1 = require("./object");
const platform = tslib_1.__importStar(require("./platform"));
const logger = (0, logger_1.createLogger)('util-fs');
const exec = node_2.child_process.exec;
var FileType;
(function (FileType) {
    /**
     * The file type is unknown.
     */
    FileType[FileType["Unknown"] = 0] = "Unknown";
    /**
     * A regular file.
     */
    FileType[FileType["File"] = 1] = "File";
    /**
     * A directory.
     */
    FileType[FileType["Directory"] = 2] = "Directory";
    /**
     * A symbolic link to a file.
     */
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType = exports.FileType || (exports.FileType = {}));
function watchFile(filepath, onChange, immediate = false) {
    let callback = (0, node_2.debounce)(onChange, 100);
    try {
        let watcher = node_1.fs.watch(filepath, {
            persistent: true,
            recursive: false,
            encoding: 'utf8'
        }, () => {
            callback();
        });
        if (immediate) {
            setTimeout(onChange, 10);
        }
        return protocol_1.Disposable.create(() => {
            callback.clear();
            watcher.close();
        });
    }
    catch (e) {
        return protocol_1.Disposable.create(() => {
            callback.clear();
        });
    }
}
exports.watchFile = watchFile;
function loadJson(filepath) {
    try {
        let errors = [];
        let text = node_1.fs.readFileSync(filepath, 'utf8');
        let data = (0, jsonc_parser_1.parse)(text, errors, { allowTrailingComma: true });
        if (errors.length > 0) {
            logger.error(`Error on parse json file ${filepath}`, errors);
        }
        return data !== null && data !== void 0 ? data : {};
    }
    catch (e) {
        return {};
    }
}
exports.loadJson = loadJson;
function writeJson(filepath, obj) {
    let dir = node_1.path.dirname(filepath);
    if (!node_1.fs.existsSync(dir)) {
        node_1.fs.mkdirSync(dir, { recursive: true });
        logger.info(`Creating directory ${dir}`);
    }
    node_1.fs.writeFileSync(filepath, JSON.stringify((0, object_1.toObject)(obj), null, 2), 'utf8');
}
exports.writeJson = writeJson;
async function statAsync(filepath) {
    let stat = null;
    try {
        stat = await (0, node_1.promisify)(node_1.fs.stat)(filepath);
    }
    catch (e) { }
    return stat;
}
exports.statAsync = statAsync;
function isDirectory(filepath) {
    if (!filepath || !node_1.path.isAbsolute(filepath) || !node_1.fs.existsSync(filepath))
        return false;
    let stat = node_1.fs.statSync(filepath);
    return stat.isDirectory();
}
exports.isDirectory = isDirectory;
function renameAsync(oldPath, newPath) {
    return new Promise((resolve, reject) => {
        node_1.fs.rename(oldPath, newPath, err => {
            if (err)
                return reject(err);
            resolve();
        });
    });
}
exports.renameAsync = renameAsync;
async function remove(filepath) {
    if (!filepath)
        return;
    try {
        await (0, node_1.promisify)(node_1.fs.rm)(filepath, { force: true, recursive: true });
    }
    catch (e) {
        return;
    }
}
exports.remove = remove;
async function getFileType(filepath) {
    try {
        const stat = await (0, node_1.promisify)(node_1.fs.lstat)(filepath);
        if (stat.isFile()) {
            return FileType.File;
        }
        if (stat.isDirectory()) {
            return FileType.Directory;
        }
        if (stat.isSymbolicLink()) {
            return FileType.SymbolicLink;
        }
        return FileType.Unknown;
    }
    catch (e) {
        return undefined;
    }
}
exports.getFileType = getFileType;
async function isGitIgnored(fullpath) {
    if (!fullpath)
        return false;
    let stat = await statAsync(fullpath);
    if (!stat || !stat.isFile())
        return false;
    let root = null;
    try {
        let { stdout } = await (0, node_1.promisify)(exec)('git rev-parse --show-toplevel', { cwd: node_1.path.dirname(fullpath) });
        root = stdout.trim();
    }
    catch (e) { }
    if (!root)
        return false;
    let file = node_1.path.relative(root, fullpath);
    try {
        let { stdout } = await (0, node_1.promisify)(exec)(`git check-ignore ${file}`, { cwd: root });
        return stdout.trim() == file;
    }
    catch (e) { }
    return false;
}
exports.isGitIgnored = isGitIgnored;
function isFolderIgnored(folder, ignored) {
    if ((0, array_1.isFalsyOrEmpty)(ignored))
        return false;
    return ignored.some(p => (0, node_2.minimatch)(folder, p, { dot: true }));
}
function resolveRoot(folder, subs, cwd, bottomup = false, checkCwd = true, ignored = []) {
    let dir = normalizeFilePath(folder);
    if (checkCwd
        && cwd
        && isParentFolder(cwd, dir, true)
        && !isFolderIgnored(cwd, ignored)
        && inDirectory(cwd, subs))
        return cwd;
    let parts = dir.split(node_1.path.sep);
    if (bottomup) {
        while (parts.length > 0) {
            let dir = parts.join(node_1.path.sep);
            if (!isFolderIgnored(dir, ignored) && inDirectory(dir, subs)) {
                return dir;
            }
            parts.pop();
        }
        return null;
    }
    else {
        let curr = [parts.shift()];
        for (let part of parts) {
            curr.push(part);
            let dir = curr.join(node_1.path.sep);
            if (!isFolderIgnored(dir, ignored) && inDirectory(dir, subs)) {
                return dir;
            }
        }
        return null;
    }
}
exports.resolveRoot = resolveRoot;
function checkFolder(dir, patterns, token) {
    return new Promise((resolve, reject) => {
        if ((0, array_1.isFalsyOrEmpty)(patterns))
            return resolve(false);
        let disposable;
        if (token) {
            disposable = token.onCancellationRequested(() => {
                gl.abort();
                reject(new errors_1.CancellationError());
            });
        }
        let find = false;
        let pattern = patterns.length == 1 ? patterns[0] : `{${patterns.join(',')}}`;
        let gl = (0, node_2.glob)(pattern, {
            nosort: true,
            ignore: ['node_modules/**', '.git/**'],
            dot: true,
            cwd: dir,
            nodir: true,
            absolute: false
        }, _err => {
            if (disposable)
                disposable.dispose();
            resolve(find);
        });
        gl.on('match', () => {
            if (disposable)
                disposable.dispose();
            find = true;
            gl.abort();
            resolve(true);
        });
        gl.on('end', () => {
            if (disposable)
                disposable.dispose();
            resolve(find);
        });
    });
}
exports.checkFolder = checkFolder;
function inDirectory(dir, subs) {
    try {
        let files = node_1.fs.readdirSync(dir);
        for (let pattern of subs) {
            // note, only '*' expanded
            let is_wildcard = (pattern.includes('*'));
            let res = is_wildcard ?
                (node_2.minimatch.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0) :
                (files.includes(pattern));
            if (res)
                return true;
        }
    }
    catch (e) {
        // could be failed without permission
    }
    return false;
}
exports.inDirectory = inDirectory;
/**
 * Find a matched file inside directory.
 */
function findMatch(dir, subs) {
    try {
        let files = node_1.fs.readdirSync(dir);
        for (let pattern of subs) {
            // note, only '*' expanded
            let isWildcard = (pattern.includes('*'));
            if (isWildcard) {
                let filtered = files.filter(node_2.minimatch.filter(pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }));
                if (filtered.length > 0)
                    return filtered[0];
            }
            else {
                let file = files.find(s => s === pattern);
                if (file)
                    return file;
            }
        }
    }
    catch (e) {
        // could be failed without permission
    }
    return undefined;
}
exports.findMatch = findMatch;
function findUp(name, cwd) {
    let root = node_1.path.parse(cwd).root;
    let subs = (0, array_1.toArray)(name);
    while (cwd && cwd !== root) {
        let find = findMatch(cwd, subs);
        if (find)
            return node_1.path.join(cwd, find);
        cwd = node_1.path.dirname(cwd);
    }
    return null;
}
exports.findUp = findUp;
function readFile(fullpath, encoding) {
    return new Promise((resolve, reject) => {
        node_1.fs.readFile(fullpath, encoding, (err, content) => {
            if (err)
                reject(err);
            resolve(content);
        });
    });
}
exports.readFile = readFile;
function getFileLineCount(filepath) {
    let i;
    let count = 0;
    return new Promise((resolve, reject) => {
        node_1.fs.createReadStream(filepath)
            .on('error', e => reject(e))
            .on('data', chunk => {
            for (i = 0; i < chunk.length; ++i)
                if (chunk[i] == 10)
                    count++;
        })
            .on('end', () => resolve(count));
    });
}
exports.getFileLineCount = getFileLineCount;
function readFileLines(fullpath, start, end) {
    if (!node_1.fs.existsSync(fullpath)) {
        return Promise.reject(new Error(`file does not exist: ${fullpath}`));
    }
    let res = [];
    const input = node_1.fs.createReadStream(fullpath, { encoding: 'utf8' });
    const rl = node_2.readline.createInterface({
        input,
        crlfDelay: Infinity,
        terminal: false
    });
    let n = 0;
    return new Promise((resolve, reject) => {
        rl.on('line', line => {
            if (n >= start && n <= end) {
                res.push(line);
            }
            if (n == end) {
                rl.close();
            }
            n = n + 1;
        });
        rl.on('close', () => {
            resolve(res);
            input.close();
        });
        rl.on('error', reject);
    });
}
exports.readFileLines = readFileLines;
function readFileLine(fullpath, count) {
    if (!node_1.fs.existsSync(fullpath))
        return Promise.reject(new Error(`file does not exist: ${fullpath}`));
    const input = node_1.fs.createReadStream(fullpath, { encoding: 'utf8' });
    const rl = node_2.readline.createInterface({ input, crlfDelay: Infinity, terminal: false });
    let n = 0;
    let result = '';
    return new Promise((resolve, reject) => {
        rl.on('line', line => {
            if (n == count) {
                result = line;
                rl.close();
                input.close();
            }
            n = n + 1;
        });
        rl.on('close', () => {
            resolve(result);
        });
        rl.on('error', reject);
    });
}
exports.readFileLine = readFileLine;
async function lineToLocation(fsPath, match, text) {
    let uri = vscode_uri_1.URI.file(fsPath).toString();
    if (!node_1.fs.existsSync(fsPath))
        return vscode_languageserver_types_1.Location.create(uri, vscode_languageserver_types_1.Range.create(0, 0, 0, 0));
    const rl = node_2.readline.createInterface({
        input: node_1.fs.createReadStream(fsPath, { encoding: 'utf8' }),
    });
    let n = 0;
    let line = await new Promise(resolve => {
        let find = false;
        rl.on('line', line => {
            if (line.includes(match)) {
                find = true;
                rl.removeAllListeners();
                rl.close();
                resolve(line);
                return;
            }
            n = n + 1;
        });
        rl.on('close', () => {
            if (!find)
                resolve(undefined);
        });
    });
    if (line != null) {
        let character = text == null ? 0 : line.indexOf(text);
        if (character == 0)
            character = line.match(/^\s*/)[0].length;
        let end = vscode_languageserver_types_1.Position.create(n, character + (text ? text.length : 0));
        return vscode_languageserver_types_1.Location.create(uri, vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(n, character), end));
    }
    return vscode_languageserver_types_1.Location.create(uri, vscode_languageserver_types_1.Range.create(0, 0, 0, 0));
}
exports.lineToLocation = lineToLocation;
function sameFile(fullpath, other, caseInsensitive) {
    caseInsensitive = typeof caseInsensitive == 'boolean' ? caseInsensitive : platform.isWindows || platform.isMacintosh;
    if (!fullpath || !other)
        return false;
    fullpath = normalizeFilePath(fullpath);
    other = normalizeFilePath(other);
    if (caseInsensitive)
        return fullpath.toLowerCase() === other.toLowerCase();
    return fullpath === other;
}
exports.sameFile = sameFile;
function fileStartsWith(dir, pdir, caseInsensitive = platform.isWindows || platform.isMacintosh) {
    if (caseInsensitive)
        return dir.toLowerCase().startsWith(pdir.toLowerCase());
    return dir.startsWith(pdir);
}
exports.fileStartsWith = fileStartsWith;
async function writeFile(fullpath, content) {
    await (0, node_1.promisify)(node_1.fs.writeFile)(fullpath, content, { encoding: 'utf8' });
}
exports.writeFile = writeFile;
function isFile(uri) {
    return uri.startsWith('file:');
}
exports.isFile = isFile;
function parentDirs(pth) {
    let { root, dir } = node_1.path.parse(pth);
    if (dir === root)
        return [root];
    const dirs = [root];
    const parts = dir.slice(root.length).split(node_1.path.sep);
    for (let i = 1; i <= parts.length; i++) {
        dirs.push(node_1.path.join(root, parts.slice(0, i).join(node_1.path.sep)));
    }
    return dirs;
}
exports.parentDirs = parentDirs;
function normalizeFilePath(filepath) {
    return vscode_uri_1.URI.file(node_1.path.resolve(node_1.path.normalize(filepath))).fsPath;
}
exports.normalizeFilePath = normalizeFilePath;
function isParentFolder(folder, filepath, checkEqual = false) {
    let pdir = normalizeFilePath(folder);
    let dir = normalizeFilePath(filepath);
    if (sameFile(pdir, dir))
        return checkEqual ? true : false;
    return fileStartsWith(dir, pdir) && dir[pdir.length] == node_1.path.sep;
}
exports.isParentFolder = isParentFolder;
//# sourceMappingURL=fs.js.map