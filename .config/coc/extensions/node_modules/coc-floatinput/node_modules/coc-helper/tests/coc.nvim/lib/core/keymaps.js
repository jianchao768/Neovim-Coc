'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBufnr = exports.getKeymapModifier = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const logger = (0, logger_1.createLogger)('core-keymaps');
function getKeymapModifier(mode) {
    if (mode == 'n' || mode == 'o' || mode == 'x' || mode == 'v')
        return '<C-U>';
    if (mode == 'i')
        return '<C-o>';
    if (mode == 's')
        return '<Esc>';
    return '';
}
exports.getKeymapModifier = getKeymapModifier;
function getBufnr(buffer) {
    return typeof buffer === 'number' ? buffer : events_1.default.bufnr;
}
exports.getBufnr = getBufnr;
class Keymaps {
    constructor() {
        this.keymaps = new Map();
    }
    attach(nvim) {
        this.nvim = nvim;
    }
    async doKeymap(key, defaultReturn) {
        var _a;
        let keymap = (_a = this.keymaps.get(key)) !== null && _a !== void 0 ? _a : this.keymaps.get('coc-' + key);
        if (!keymap) {
            logger.error(`keymap for ${key} not found`);
            return defaultReturn;
        }
        let [fn, repeat] = keymap;
        let res = await Promise.resolve(fn());
        if (repeat)
            await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
        return res !== null && res !== void 0 ? res : defaultReturn;
    }
    /**
     * Register global <Plug>(coc-${key}) key mapping.
     */
    registerKeymap(modes, name, fn, opts = {}) {
        if (!name)
            throw new Error(`Invalid key ${name} of registerKeymap`);
        let key = `coc-${name}`;
        if (this.keymaps.has(key))
            throw new Error(`${name} already exists.`);
        let lhs = `<Plug>(${key})`;
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? 'request' : 'notify';
        let cancel = opts.cancel ? 1 : 0;
        for (let mode of modes) {
            if (mode == 'i') {
                nvim.setKeymap(mode, lhs, `coc#_insert_key('${method}', '${key}', ${cancel})`, {
                    expr: true,
                    noremap: true,
                    silent: opts.silent
                });
            }
            else {
                nvim.setKeymap(mode, lhs, `:${getKeymapModifier(mode)}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, {
                    noremap: true,
                    silent: opts.silent
                });
            }
        }
        return protocol_1.Disposable.create(() => {
            this.keymaps.delete(key);
            for (let m of modes) {
                nvim.deleteKeymap(m, lhs);
            }
        });
    }
    registerExprKeymap(mode, lhs, fn, buffer = false) {
        let bufnr = getBufnr(buffer);
        let id = `${mode}-${(0, string_1.toBase64)(lhs)}${buffer ? `-${bufnr}` : ''}`;
        let { nvim } = this;
        let rhs = mode == 'i' ? `coc#_insert_key('request', '${id}')` : `coc#rpc#request('doKeymap', ['${id}'])`;
        let opts = { noremap: true, silent: true, expr: true, nowait: true };
        if (buffer) {
            nvim.createBuffer(bufnr).setKeymap(mode, lhs, rhs, opts);
        }
        else {
            nvim.setKeymap(mode, lhs, rhs, opts);
        }
        this.keymaps.set(id, [fn, false]);
        return protocol_1.Disposable.create(() => {
            this.keymaps.delete(id);
            if (buffer) {
                nvim.createBuffer(bufnr).deleteKeymap(mode, lhs);
            }
            else {
                nvim.deleteKeymap(mode, lhs);
            }
        });
    }
    registerLocalKeymap(bufnr, mode, lhs, fn, notify) {
        let { nvim } = this;
        let buffer = nvim.createBuffer(bufnr);
        let id = `local-${bufnr}-${mode}-${(0, string_1.toBase64)(lhs)}`;
        this.keymaps.set(id, [fn, false]);
        let method = notify ? 'notify' : 'request';
        let modify = getKeymapModifier(mode);
        buffer.setKeymap(mode, lhs, `:${modify}call coc#rpc#${method}('doKeymap', ['${id}'])<CR>`, {
            silent: true,
            nowait: true,
            noremap: true
        });
        return protocol_1.Disposable.create(() => {
            this.keymaps.delete(id);
            buffer.deleteKeymap(mode, lhs);
        });
    }
}
exports.default = Keymaps;
//# sourceMappingURL=keymaps.js.map