'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const LocationsDataProvider_1 = tslib_1.__importDefault(require("../tree/LocationsDataProvider"));
const TreeView_1 = tslib_1.__importDefault(require("../tree/TreeView"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const lodash_1 = require("../util/lodash");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
/**
 * Cleanup properties used by treeview
 */
function toTypeHierarchyItem(item) {
    return (0, lodash_1.omit)(item, ['children', 'parent']);
}
class TypeHierarchyHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = new Set();
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_1.default.on('BufWinEnter', (_, winid) => {
            if (this.highlightWinids.has(winid)) {
                this.highlightWinids.delete(winid);
                let win = nvim.createWindow(winid);
                win.clearMatchGroup(TypeHierarchyHandler.rangesHighlight);
            }
        }, null, this.disposables);
        this.disposables.push(commands_1.default.registerCommand(TypeHierarchyHandler.commandId, async (winid, item, openCommand) => {
            let { nvim } = this;
            await nvim.call('win_gotoid', [winid]);
            await workspace_1.default.jumpTo(item.uri, item.range.start, openCommand);
            let win = await nvim.window;
            win.clearMatchGroup(TypeHierarchyHandler.rangesHighlight);
            win.highlightRanges(TypeHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
            this.highlightWinids.add(win.id);
        }, null, true));
    }
    loadConfiguration(e) {
        if (!e || e.affectsConfiguration('typeHierarchy')) {
            let c = workspace_1.default.getConfiguration('typeHierarchy', null);
            this.config = {
                splitCommand: c.get('splitCommand'),
                openCommand: c.get('openCommand'),
                enableTooltip: c.get('enableTooltip')
            };
        }
    }
    createProvider(rootItems, winid, kind) {
        let provider = new LocationsDataProvider_1.default(kind, winid, this.config, TypeHierarchyHandler.commandId, rootItems, kind => this.handler.getIcon(kind), (el, meta, token) => this.getChildren(el, meta, token));
        provider.addAction(`Show Super Types`, (el) => {
            provider.meta = 'supertypes';
            let rootItems = [(0, lodash_1.omit)(el, ['children', 'parent'])];
            provider.reset(rootItems);
        });
        provider.addAction(`Show Sub Types`, (el) => {
            provider.meta = 'subtypes';
            let rootItems = [(0, lodash_1.omit)(el, ['children', 'parent'])];
            provider.reset(rootItems);
        });
        return provider;
    }
    async getChildren(item, kind, token) {
        let res = [];
        let typeHierarchyItem = toTypeHierarchyItem(item);
        if (kind == 'supertypes') {
            res = await languages_1.default.provideTypeHierarchySupertypes(typeHierarchyItem, token);
        }
        else {
            res = await languages_1.default.provideTypeHierarchySubtypes(typeHierarchyItem, token);
        }
        return res;
    }
    async prepare(doc, position) {
        this.handler.checkProvider(languages_1.ProviderName.TypeHierarchy, doc);
        return await this.handler.withRequestToken('typeHierarchy', async (token) => {
            return await languages_1.default.prepareTypeHierarchy(doc, position, token);
        }, false);
    }
    async showTypeHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        const rootItems = await this.prepare(doc.textDocument, position);
        if ((0, array_1.isFalsyOrEmpty)(rootItems)) {
            void window_1.default.showWarningMessage('Unable to get TypeHierarchyItems at cursor position.');
            return;
        }
        let provider = this.createProvider(rootItems, winid, kind);
        let treeView = new TreeView_1.default('types', { treeDataProvider: provider });
        treeView.title = getTitle(kind);
        provider.onDidChangeTreeData(e => {
            if (!e)
                treeView.title = getTitle(provider.meta);
        });
        treeView.onDidChangeVisibility(e => {
            if (!e.visible)
                provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
    }
    dispose() {
        this.highlightWinids.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = TypeHierarchyHandler;
TypeHierarchyHandler.rangesHighlight = 'CocSelectedRange';
TypeHierarchyHandler.commandId = 'typeHierarchy.reveal';
function getTitle(kind) {
    return kind === 'supertypes' ? 'Super types' : 'Sub types';
}
//# sourceMappingURL=typeHierarchy.js.map