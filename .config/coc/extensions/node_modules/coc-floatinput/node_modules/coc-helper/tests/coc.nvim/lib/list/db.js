"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataBase = void 0;
/**
 * First byte tables length,
 * 4 * table_length each table byte length.
 */
const node_1 = require("../util/node");
const logger_1 = require("../logger");
const string_1 = require("../util/string");
const constants_1 = require("../util/constants");
const logger = (0, logger_1.createLogger)('list-db');
const DB_PATH = node_1.path.join(constants_1.dataHome, 'list_history.dat');
class DataBase {
    constructor() {
        this.folders = [];
        this.names = [];
        this.items = [];
        this._changed = false;
        try {
            this.load();
        }
        catch (e) {
            logger.error(`Error on load db`, e);
        }
    }
    get currItems() {
        return this.items;
    }
    getHistory(name, folder) {
        let nameIndex = this.names.indexOf(name);
        let folderIndex = this.folders.indexOf(folder);
        if (nameIndex == -1 || folderIndex == -1)
            return [];
        return this.items.reduce((p, c) => {
            if (c[1] == nameIndex && c[2] == folderIndex) {
                p.push(c[0]);
            }
            return p;
        }, []);
    }
    addItem(name, text, folder) {
        let { folders, names } = this;
        if ((0, string_1.byteLength)(text) > 255) {
            text = (0, string_1.byteSlice)(text, 0, 255);
        }
        if (!folders.includes(folder)) {
            folders.push(folder);
        }
        if (!names.includes(name)) {
            names.push(name);
        }
        let nameIndex = names.indexOf(name);
        let folderIndex = folders.indexOf(folder);
        let idx = this.items.findIndex(o => o[0] == text && o[1] == nameIndex && o[2] == folderIndex);
        if (idx != -1)
            this.items.splice(idx, 1);
        this.items.push([text, nameIndex, folderIndex]);
        this._changed = true;
    }
    save() {
        let { folders, items, names } = this;
        if (!this._changed)
            return;
        let bufs = folders.reduce((p, folder) => {
            p.push(Buffer.from(folder, 'utf8'), Buffer.alloc(1));
            return p;
        }, []);
        let folderBuf = Buffer.concat(bufs);
        bufs = names.reduce((p, name) => {
            p.push(Buffer.from(name, 'utf8'), Buffer.alloc(1));
            return p;
        }, []);
        let nameBuf = Buffer.concat(bufs);
        let buf = Buffer.allocUnsafe(9);
        buf.writeUInt8(2, 0);
        buf.writeUInt32BE(folderBuf.byteLength, 1);
        buf.writeUInt32BE(nameBuf.byteLength, 5);
        bufs = items.reduce((p, item) => {
            let b = Buffer.from(item[0], 'utf8');
            p.push(Buffer.from([b.byteLength]), b, Buffer.from([item[1], item[2]]));
            return p;
        }, []);
        let resultBuf = Buffer.concat([buf, folderBuf, nameBuf, ...bufs]);
        node_1.fs.writeFileSync(DB_PATH, resultBuf);
        this._changed = false;
    }
    load() {
        if (!node_1.fs.existsSync(DB_PATH))
            return;
        let buffer = node_1.fs.readFileSync(DB_PATH);
        let folder_length = buffer.readUInt32BE(1);
        let name_length = buffer.readUInt32BE(5);
        let folderBuf = buffer.slice(9, 9 + folder_length);
        let start = 0;
        let folders = [];
        let names = [];
        for (let i = 0; i < folderBuf.byteLength; i++) {
            if (folderBuf[i] === 0) {
                let text = folderBuf.slice(start, i).toString('utf8');
                folders.push(text);
                start = i + 1;
            }
        }
        let offset = 9 + folder_length;
        let nameBuf = buffer.slice(offset, offset + name_length);
        start = 0;
        for (let i = 0; i < nameBuf.byteLength; i++) {
            if (nameBuf[i] === 0) {
                let text = nameBuf.slice(start, i).toString('utf8');
                names.push(text);
                start = i + 1;
            }
        }
        let itemsBuf = buffer.slice(offset + name_length);
        start = 0;
        let total = itemsBuf.byteLength;
        while (start < total) {
            let len = itemsBuf.readUInt8(start);
            let end = start + 1 + len;
            let text = itemsBuf.slice(start + 1, end).toString('utf8');
            this.items.push([text, itemsBuf.readUInt8(end), itemsBuf.readUInt8(end + 1)]);
            start = end + 2;
        }
        this.names = names;
        this.folders = folders;
    }
}
exports.DataBase = DataBase;
exports.default = new DataBase();
//# sourceMappingURL=db.js.map