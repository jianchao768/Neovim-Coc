'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const document_1 = tslib_1.__importDefault(require("../model/document"));
const util_1 = require("../util");
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const platform = tslib_1.__importStar(require("../util/platform"));
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const logger = (0, logger_1.createLogger)('core-documents');
const cwd = (0, fs_1.normalizeFilePath)(process.cwd());
class Documents {
    constructor(configurations, workspaceFolder) {
        this.configurations = configurations;
        this.workspaceFolder = workspaceFolder;
        this._attached = false;
        this._currentResolve = false;
        this.disposables = [];
        this.creating = new Map();
        this.buffers = new Map();
        this.resolves = [];
        this._onDidOpenTextDocument = new protocol_1.Emitter();
        this._onDidCloseDocument = new protocol_1.Emitter();
        this._onDidChangeDocument = new protocol_1.Emitter();
        this._onDidSaveDocument = new protocol_1.Emitter();
        this._onWillSaveDocument = new protocol_1.Emitter();
        this.onDidOpenTextDocument = this._onDidOpenTextDocument.event;
        this.onDidCloseDocument = this._onDidCloseDocument.event;
        this.onDidChangeDocument = this._onDidChangeDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this._cwd = cwd;
        this.getConfiguration();
        this.configurations.onDidChange(this.getConfiguration, this, this.disposables);
    }
    async attach(nvim, env) {
        if (this._attached)
            return;
        this.nvim = nvim;
        this._env = env;
        this._attached = true;
        let { bufnrs, bufnr } = await this.nvim.call('coc#util#all_state');
        this._bufnr = bufnr;
        await Promise.all(bufnrs.map(bufnr => this.createDocument(bufnr)));
        events_1.default.on('BufDetach', this.onBufDetach, this, this.disposables);
        events_1.default.on('BufRename', async (bufnr) => {
            this.detachBuffer(bufnr);
            await this.createDocument(bufnr);
        }, null, this.disposables);
        events_1.default.on('DirChanged', cwd => {
            this._cwd = (0, fs_1.normalizeFilePath)(cwd);
        }, null, this.disposables);
        const checkCurrentBuffer = (bufnr) => {
            this._bufnr = bufnr;
            void this.createDocument(bufnr);
        };
        events_1.default.on('CursorMoved', checkCurrentBuffer, null, this.disposables);
        events_1.default.on('CursorMovedI', checkCurrentBuffer, null, this.disposables);
        events_1.default.on('BufUnload', this.onBufUnload, this, this.disposables);
        events_1.default.on('BufEnter', this.onBufEnter, this, this.disposables);
        events_1.default.on('BufCreate', this.onBufCreate, this, this.disposables);
        events_1.default.on('TermOpen', this.onBufCreate, this, this.disposables);
        events_1.default.on('BufWritePost', this.onBufWritePost, this, this.disposables);
        events_1.default.on('BufWritePre', this.onBufWritePre, this, this.disposables);
        events_1.default.on('FileType', this.onFileTypeChange, this, this.disposables);
        events_1.default.on('BufEnter', (bufnr) => {
            void this.createDocument(bufnr);
        }, null, this.disposables);
        if (this._env.isVim) {
            ['TextChangedP', 'TextChangedI', 'TextChanged'].forEach(event => {
                events_1.default.on(event, (bufnr, info) => {
                    let doc = this.buffers.get(bufnr);
                    if (doc && doc.attached)
                        doc.onTextChange(event, info);
                }, null, this.disposables);
            });
        }
    }
    getConfiguration(e) {
        if (!e || e.affectsConfiguration('coc.preferences')) {
            let config = this.configurations.initialConfiguration.get('coc.preferences');
            const bytes = require('bytes');
            this.config = {
                maxFileSize: bytes.parse(config.maxFileSize),
                willSaveHandlerTimeout: (0, util_1.defaultValue)(config.willSaveHandlerTimeout, 500),
                useQuickfixForLocations: config.useQuickfixForLocations
            };
        }
    }
    get bufnr() {
        return this._bufnr;
    }
    get root() {
        return this._root;
    }
    get cwd() {
        return this._cwd;
    }
    get documents() {
        return Array.from(this.buffers.values()).filter(o => o.attached);
    }
    async getCurrentUri() {
        let bufnr = await this.nvim.call('bufnr', ['%']);
        let doc = this.getDocument(bufnr);
        return doc ? doc.uri : undefined;
    }
    *attached(schema) {
        for (let doc of this.buffers.values()) {
            if (!doc.attached)
                continue;
            if (schema && doc.schema !== schema)
                continue;
            yield doc;
        }
    }
    get bufnrs() {
        return this.buffers.keys();
    }
    detach() {
        this._attached = false;
        for (let bufnr of this.buffers.keys()) {
            this.onBufUnload(bufnr);
        }
    }
    resolveRoot(rootPatterns, requireRootPattern = false) {
        let doc = this.getDocument(this.bufnr);
        let resolved;
        if (doc && doc.schema == 'file') {
            let dir = node_1.path.dirname(vscode_uri_1.URI.parse(doc.uri).fsPath);
            resolved = (0, fs_1.resolveRoot)(dir, rootPatterns, this.cwd);
        }
        else {
            resolved = (0, fs_1.resolveRoot)(this.cwd, rootPatterns);
        }
        if (requireRootPattern && !resolved) {
            throw new Error(`Required root pattern not resolved.`);
        }
        return resolved;
    }
    get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
            if (b.attached)
                docs.push(b.textDocument);
        }
        return docs;
    }
    getDocument(uri) {
        if (typeof uri === 'number') {
            return this.buffers.get(uri);
        }
        const caseInsensitive = platform.isWindows || platform.isMacintosh;
        let u = vscode_uri_1.URI.parse(uri);
        uri = u.toString();
        let isFile = u.scheme === 'file';
        for (let doc of this.buffers.values()) {
            if (doc.uri === uri)
                return doc;
            if (isFile && caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
                return doc;
        }
        return null;
    }
    /**
     * Expand filepath with `~` and/or environment placeholders
     */
    expand(input) {
        if (input.startsWith('~')) {
            input = node_1.os.homedir() + input.slice(1);
        }
        if (input.includes('$')) {
            let doc = this.getDocument(this.bufnr);
            let fsPath = doc ? vscode_uri_1.URI.parse(doc.uri).fsPath : '';
            const root = this._root || this._cwd;
            input = input.replace(/\$\{(.*?)\}/g, (match, name) => {
                if (name.startsWith('env:')) {
                    let key = name.split(':')[1];
                    let val = key ? process.env[key] : '';
                    return val;
                }
                switch (name) {
                    case 'userHome':
                        return node_1.os.homedir();
                    case 'workspace':
                    case 'workspaceRoot':
                    case 'workspaceFolder':
                        return root;
                    case 'workspaceFolderBasename':
                        return node_1.path.basename(root);
                    case 'cwd':
                        return this._cwd;
                    case 'file':
                        return fsPath;
                    case 'fileDirname':
                        return fsPath ? node_1.path.dirname(fsPath) : '';
                    case 'fileExtname':
                        return fsPath ? node_1.path.extname(fsPath) : '';
                    case 'fileBasename':
                        return fsPath ? node_1.path.basename(fsPath) : '';
                    case 'fileBasenameNoExtension': {
                        let base = fsPath ? node_1.path.basename(fsPath) : '';
                        return base ? base.slice(0, base.length - node_1.path.extname(base).length) : '';
                    }
                    default:
                        return match;
                }
            });
            input = input.replace(/\$[\w]+/g, match => {
                if (match == '$HOME')
                    return node_1.os.homedir();
                return process.env[match.slice(1)] || match;
            });
        }
        return input;
    }
    /**
     * Current document.
     */
    get document() {
        if (this._currentResolve) {
            return new Promise(resolve => {
                this.resolves.push(resolve);
            });
        }
        this._currentResolve = true;
        return new Promise(resolve => {
            this.nvim.eval(`coc#util#get_bufoptions(bufnr("%"),${this.config.maxFileSize})`).then((opts) => {
                let doc;
                if (opts != null) {
                    this.creating.delete(opts.bufnr);
                    doc = this._createDocument(opts);
                }
                this.resolveCurrent(doc);
                resolve(doc);
                this._currentResolve = false;
            }, () => {
                resolve(undefined);
                this._currentResolve = false;
            });
        });
    }
    resolveCurrent(document) {
        if (this.resolves.length > 0) {
            while (this.resolves.length) {
                const fn = this.resolves.pop();
                if (fn)
                    fn(document);
            }
        }
    }
    get uri() {
        let { bufnr } = this;
        if (bufnr) {
            let doc = this.getDocument(bufnr);
            if (doc)
                return doc.uri;
        }
        return null;
    }
    /**
     * Current filetypes.
     */
    get filetypes() {
        let res = new Set();
        for (let doc of this.attached()) {
            res.add(doc.filetype);
        }
        return res;
    }
    /**
     * Get filetype by check same extension name buffer.
     */
    getLanguageId(filepath) {
        let ext = node_1.path.extname(filepath);
        if (!ext)
            return '';
        for (let doc of this.attached()) {
            let fsPath = vscode_uri_1.URI.parse(doc.uri).fsPath;
            if (node_1.path.extname(fsPath) == ext) {
                return doc.languageId;
            }
        }
        return '';
    }
    async getLines(uri) {
        let doc = this.getDocument(uri);
        if (doc)
            return doc.textDocument.lines;
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme !== 'file')
            return [];
        try {
            let content = await (0, fs_1.readFile)(u.fsPath, 'utf8');
            return content.split(/\r?\n/);
        }
        catch (e) {
            return [];
        }
    }
    /**
     * Current languageIds.
     */
    get languageIds() {
        let res = new Set();
        for (let doc of this.attached()) {
            res.add(doc.languageId);
        }
        return res;
    }
    /**
     * Get format options
     */
    async getFormatOptions(uri) {
        let doc;
        if (uri)
            doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : 0;
        let res = await this.nvim.call('coc#util#get_format_opts', [bufnr]);
        let obj = { tabSize: res.tabsize, insertSpaces: res.expandtab == 1 };
        obj.insertFinalNewline = res.insertFinalNewline == 1;
        if (res.trimTrailingWhitespace)
            obj.trimTrailingWhitespace = true;
        if (res.trimFinalNewlines)
            obj.trimFinalNewlines = true;
        return obj;
    }
    /**
     * Create document by bufnr.
     */
    async createDocument(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (doc)
            return doc;
        if (this.creating.has(bufnr))
            return await this.creating.get(bufnr);
        let promise = new Promise(resolve => {
            this.nvim.call('coc#util#get_bufoptions', [bufnr, this.config.maxFileSize]).then(opts => {
                if (!this.creating.has(bufnr)) {
                    resolve(undefined);
                    return;
                }
                this.creating.delete(bufnr);
                if (!opts) {
                    resolve(undefined);
                    return;
                }
                doc = this._createDocument(opts);
                resolve(doc);
            }, () => {
                this.creating.delete(bufnr);
                resolve(undefined);
            });
        });
        this.creating.set(bufnr, promise);
        return await promise;
    }
    async onBufCreate(bufnr) {
        this.onBufUnload(bufnr);
        await this.createDocument(bufnr);
    }
    _createDocument(opts) {
        let { bufnr } = opts;
        if (this.buffers.has(bufnr))
            return this.buffers.get(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        let doc = new document_1.default(buffer, this._env, this.nvim, opts);
        if (opts.size > this.config.maxFileSize)
            logger.warn(`buffer ${opts.bufnr} size exceed maxFileSize ${this.config.maxFileSize}, not attached.`);
        this.buffers.set(bufnr, doc);
        if (doc.attached) {
            if (doc.schema == 'file') {
                // TODO use workspaceFolder for root when exists
                this.configurations.locateFolderConfigution(doc.uri);
                let root = this.workspaceFolder.resolveRoot(doc, this._cwd, true, this.expand.bind(this));
                if (root && bufnr == this._bufnr)
                    this.changeRoot(root);
            }
            this._onDidOpenTextDocument.fire(doc.textDocument);
            doc.onDocumentChange(e => this._onDidChangeDocument.fire(e));
        }
        logger.debug('buffer created', bufnr, doc.attached, doc.uri);
        return doc;
    }
    onBufEnter(bufnr) {
        this._bufnr = bufnr;
        let doc = this.buffers.get(bufnr);
        if (doc) {
            let workspaceFolder = this.workspaceFolder.getWorkspaceFolder(vscode_uri_1.URI.parse(doc.uri));
            if (workspaceFolder)
                this._root = vscode_uri_1.URI.parse(workspaceFolder.uri).fsPath;
        }
    }
    onBufUnload(bufnr) {
        this.creating.delete(bufnr);
        void this.onBufDetach(bufnr, false);
    }
    async onBufDetach(bufnr, checkReload = true) {
        this.detachBuffer(bufnr);
        if (checkReload) {
            let loaded = await this.nvim.call('bufloaded', [bufnr]);
            if (loaded)
                await this.createDocument(bufnr);
        }
    }
    detachBuffer(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
            return;
        logger.debug('document detach', bufnr, doc.uri);
        this._onDidCloseDocument.fire(doc.textDocument);
        this.buffers.delete(bufnr);
        doc.detach();
    }
    async onBufWritePost(bufnr, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (doc) {
            if (doc.changedtick != changedtick)
                await doc.patchChange();
            this._onDidSaveDocument.fire(doc.textDocument);
        }
    }
    async onBufWritePre(bufnr, bufname, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (!doc || !doc.attached)
            return;
        if (doc.bufname != bufname) {
            this.detachBuffer(bufnr);
            doc = await this.createDocument(bufnr);
            if (!doc.attached)
                return;
        }
        if (doc.changedtick != changedtick) {
            await doc.synchronize();
        }
        else {
            await doc.patchChange();
        }
        let firing = true;
        let thenables = [];
        let event = {
            document: doc.textDocument,
            reason: protocol_1.TextDocumentSaveReason.Manual,
            waitUntil: (thenable) => {
                if (!firing) {
                    this.nvim.echoError(`waitUntil can't be used in async manner, check log for details`);
                }
                else {
                    thenables.push(thenable);
                }
            }
        };
        this._onWillSaveDocument.fire(event);
        firing = false;
        let total = thenables.length;
        if (total) {
            let promise = new Promise(resolve => {
                const willSaveHandlerTimeout = this.config.willSaveHandlerTimeout;
                let timer = setTimeout(() => {
                    this.nvim.outWriteLine(`Will save handler timeout after ${willSaveHandlerTimeout}ms`);
                    resolve(undefined);
                }, willSaveHandlerTimeout);
                let i = 0;
                let called = false;
                for (let p of thenables) {
                    let cb = (res) => {
                        if (called)
                            return;
                        called = true;
                        clearTimeout(timer);
                        resolve(res);
                    };
                    p.then(res => {
                        if (Array.isArray(res) && res.length && vscode_languageserver_types_1.TextEdit.is(res[0])) {
                            return cb(res);
                        }
                        i = i + 1;
                        if (i == total)
                            cb(undefined);
                    }, e => {
                        logger.error(`Error on will save handler:`, e);
                        i = i + 1;
                        if (i == total)
                            cb(undefined);
                    });
                }
            });
            let edits = await promise;
            if (edits)
                await doc.applyEdits(edits, false, this.bufnr === doc.bufnr);
        }
    }
    onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc)
            return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype)
            return;
        this._onDidCloseDocument.fire(doc.textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenTextDocument.fire(doc.textDocument);
    }
    async getQuickfixList(locations) {
        let filesLines = {};
        let filepathList = locations.reduce((pre, curr) => {
            let u = vscode_uri_1.URI.parse(curr.uri);
            if (u.scheme == 'file' && !pre.includes(u.fsPath) && !this.getDocument(curr.uri)) {
                pre.push(u.fsPath);
            }
            return pre;
        }, []);
        await Promise.all(filepathList.map(fsPath => {
            return new Promise(resolve => {
                (0, fs_1.readFile)(fsPath, 'utf8').then(content => {
                    filesLines[fsPath] = content.split(/\r?\n/);
                    resolve(undefined);
                }, () => {
                    resolve();
                });
            });
        }));
        return await Promise.all(locations.map(loc => {
            let { uri, range } = loc;
            let { fsPath } = vscode_uri_1.URI.parse(uri);
            let text;
            let lines = filesLines[fsPath];
            if (lines)
                text = lines[range.start.line];
            return this.getQuickfixItem(loc, text);
        }));
    }
    /**
     * Populate locations to UI.
     */
    async showLocations(locations) {
        let { nvim } = this;
        let items = await this.getQuickfixList(locations);
        if (this.config.useQuickfixForLocations) {
            let openCommand = await nvim.getVar('coc_quickfix_open_command');
            if (typeof openCommand != 'string') {
                openCommand = items.length < 10 ? `copen ${items.length}` : 'copen';
            }
            nvim.pauseNotification();
            nvim.call('setqflist', [items], true);
            nvim.command(openCommand, true);
            nvim.resumeNotification(false, true);
        }
        else {
            await nvim.setVar('coc_jump_locations', items);
            if (this._env.locationlist) {
                nvim.command('CocList --normal --auto-preview location', true);
            }
            else {
                nvim.call('coc#util#do_autocmd', ['CocLocationsChange'], true);
            }
        }
    }
    /**
     * Convert location to quickfix item.
     */
    async getQuickfixItem(loc, text, type = '', module) {
        let targetRange = loc.targetRange;
        if (vscode_languageserver_types_1.LocationLink.is(loc)) {
            loc = vscode_languageserver_types_1.Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range } = loc;
        let { start, end } = range;
        let u = vscode_uri_1.URI.parse(uri);
        if (!text && u.scheme == 'file') {
            text = await this.getLine(uri, start.line);
        }
        let endLine = start.line == end.line ? text : await this.getLine(uri, end.line);
        let item = {
            uri,
            filename: u.scheme == 'file' ? u.fsPath : uri,
            lnum: start.line + 1,
            end_lnum: end.line + 1,
            col: text ? (0, string_1.byteIndex)(text, start.character) + 1 : start.character + 1,
            end_col: endLine ? (0, string_1.byteIndex)(endLine, end.character) + 1 : end.character + 1,
            text: text || '',
            range
        };
        if (targetRange)
            item.targetRange = targetRange;
        if (module)
            item.module = module;
        if (type)
            item.type = type;
        if (doc)
            item.bufnr = doc.bufnr;
        return item;
    }
    /**
     * Get content of line by uri and line.
     */
    async getLine(uri, line) {
        let document = this.getDocument(uri);
        if (document && document.attached)
            return document.getline(line) || '';
        if (!uri.startsWith('file:'))
            return '';
        let fsPath = vscode_uri_1.URI.parse(uri).fsPath;
        if (!node_1.fs.existsSync(fsPath))
            return '';
        return await (0, fs_1.readFileLine)(fsPath, line);
    }
    /**
     * Get content from buffer or file by uri.
     */
    async readFile(uri) {
        let document = this.getDocument(uri);
        if (document) {
            await document.patchChange();
            return document.content;
        }
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme != 'file')
            return '';
        let lines = await this.nvim.call('readfile', [u.fsPath]);
        return lines.join('\n') + '\n';
    }
    reset() {
        this.creating.clear();
        for (let bufnr of this.buffers.keys()) {
            this.onBufUnload(bufnr);
        }
        this.buffers.clear();
        this.changeRoot(process.cwd());
    }
    changeRoot(dir) {
        this._root = (0, fs_1.normalizeFilePath)(dir);
    }
    dispose() {
        for (let bufnr of this.buffers.keys()) {
            this.onBufUnload(bufnr);
        }
        this._attached = false;
        this.buffers.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Documents;
//# sourceMappingURL=documents.js.map