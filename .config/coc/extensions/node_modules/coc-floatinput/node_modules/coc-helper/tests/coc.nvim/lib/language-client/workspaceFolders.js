'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceFoldersFeature = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const fs_1 = require("../util/fs");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => !right.includes(element));
}
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    getValidWorkspaceFolders() {
        var _a;
        let { workspaceFolders } = workspace_1.default;
        if (!workspaceFolders || workspaceFolders.length == 0)
            return undefined;
        let ignoredRootPaths = (_a = this._client.clientOptions.ignoredRootPaths) !== null && _a !== void 0 ? _a : [];
        let arr = workspaceFolders.filter(o => {
            let fsPath = vscode_uri_1.URI.parse(o.uri).fsPath;
            return ignoredRootPaths.every(p => !(0, fs_1.sameFile)(p, fsPath));
        });
        return arr.length ? arr : undefined;
    }
    fillInitializeParams(params) {
        const folders = this.getValidWorkspaceFolders();
        this.initializeWithFolders(folders);
        if (folders === undefined) {
            this._client.warn(`No valid workspaceFolder exists`);
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        let client = this._client;
        client.onRequest(protocol_1.WorkspaceFoldersRequest.type, (token) => {
            let workspaceFolders = () => {
                let folders = this.getValidWorkspaceFolders();
                if (folders === void 0) {
                    return null;
                }
                let result = folders.map(folder => this.asProtocol(folder));
                return result;
            };
            const middleware = client.middleware.workspace;
            return (middleware === null || middleware === void 0 ? void 0 : middleware.workspaceFolders)
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register({
                id,
                registerOptions: undefined
            });
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        return this._client.sendNotification(protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                promise = this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            promise = this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise) {
            promise.catch(error => {
                this._client.error(`Sending notification ${protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        }
    }
    register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = workspace_1.default.onDidChangeWorkspaceFolders(event => {
            let didChangeWorkspaceFolders = (e) => {
                return this.doSendEvent(e.added, e.removed);
            };
            let middleware = client.middleware.workspace;
            const promise = (middleware === null || middleware === void 0 ? void 0 : middleware.didChangeWorkspaceFolders)
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
            if (promise) {
                promise.catch(error => {
                    this._client.error(`Sending notification ${protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
                });
            }
        });
        this._listeners.set(id, disposable);
        let workspaceFolders = this.getValidWorkspaceFolders();
        this.sendInitialEvent(workspaceFolders);
    }
    unregister(id) {
        // dynamic not supported
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder == null)
            return null;
        return { uri: workspaceFolder.uri, name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map