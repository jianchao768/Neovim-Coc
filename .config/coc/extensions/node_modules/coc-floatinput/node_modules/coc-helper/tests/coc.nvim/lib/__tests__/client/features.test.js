"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert = tslib_1.__importStar(require("assert"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const index_1 = require("../../language-client/index");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
beforeAll(async () => {
    await helper_1.default.setup();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('Client integration', () => {
    let client;
    let middleware;
    let uri;
    let document;
    let tokenSource;
    const position = vscode_languageserver_protocol_1.Position.create(1, 1);
    const range = vscode_languageserver_protocol_1.Range.create(1, 1, 1, 2);
    let contentProviderDisposable;
    function rangeEqual(range, sl, sc, el, ec) {
        assert.strictEqual(range.start.line, sl);
        assert.strictEqual(range.start.character, sc);
        assert.strictEqual(range.end.line, el);
        assert.strictEqual(range.end.character, ec);
    }
    function positionEqual(pos, l, c) {
        assert.strictEqual(pos.line, l);
        assert.strictEqual(pos.character, c);
    }
    function colorEqual(color, red, green, blue, alpha) {
        assert.strictEqual(color.red, red);
        assert.strictEqual(color.green, green);
        assert.strictEqual(color.blue, blue);
        assert.strictEqual(color.alpha, alpha);
    }
    function uriEqual(actual, expected) {
        assert.strictEqual(actual, expected);
    }
    function isArray(value, clazz, length = 1) {
        assert.ok(Array.isArray(value), `value is array`);
        assert.strictEqual(value.length, length, 'value has given length');
        if (clazz && typeof clazz.is === 'function') {
            for (let item of value) {
                assert.ok(clazz.is(item));
            }
        }
    }
    function isDefined(value) {
        if (value === undefined || value === null) {
            throw new Error(`Value is null or undefined`);
        }
    }
    function isFullDocumentDiagnosticReport(value) {
        assert.ok(value.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full);
    }
    beforeAll(async () => {
        contentProviderDisposable = workspace_1.default.registerTextDocumentContentProvider('lsptests', {
            provideTextDocumentContent: (_uri) => {
                return [
                    'REM @ECHO OFF',
                    'cd c:\\source',
                    'REM This is the location of the files that you want to sort',
                    'FOR %%f IN (*.doc *.txt) DO XCOPY c:\\source\\"%%f" c:\\text /m /y',
                    'REM This moves any files with a .doc or',
                    'REM .txt extension from c:\\source to c:\\text',
                    'REM %%f is a variable',
                    'FOR %%f IN (*.jpg *.png *.bmp) DO XCOPY C:\\source\\"%%f" c:\\images /m /y',
                    'REM This moves any files with a .jpg, .png,',
                    'REM or .bmp extension from c:\\source to c:\\images;;',
                ].join('\n');
            }
        });
        uri = vscode_uri_1.URI.parse('lsptests://localhost/test.bat').toString();
        let doc = await workspace_1.default.loadFile(uri.toString());
        document = doc.textDocument;
        tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        const serverModule = path_1.default.join(__dirname, './server/testServer.js');
        const serverOptions = {
            run: { module: serverModule, transport: index_1.TransportKind.ipc },
            debug: { module: serverModule, transport: index_1.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }
        };
        const documentSelector = [{ scheme: 'lsptests' }];
        middleware = {};
        const clientOptions = {
            documentSelector, synchronize: {}, initializationOptions: {}, middleware
        };
        client = new index_1.LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        let p = client.onReady();
        await client.start();
        await p;
    });
    afterAll(async () => {
        await client.sendNotification('unregister');
        await helper_1.default.wait(50);
        contentProviderDisposable.dispose();
        await client.stop();
    });
    test('InitializeResult', () => {
        let expected = {
            capabilities: {
                textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.Full,
                definitionProvider: true,
                hoverProvider: true,
                signatureHelpProvider: {
                    triggerCharacters: [','],
                    retriggerCharacters: [';']
                },
                completionProvider: { resolveProvider: true, triggerCharacters: ['"', ':'] },
                referencesProvider: true,
                documentHighlightProvider: true,
                codeActionProvider: {
                    resolveProvider: true
                },
                codeLensProvider: {
                    resolveProvider: true
                },
                documentFormattingProvider: true,
                documentRangeFormattingProvider: true,
                documentOnTypeFormattingProvider: {
                    firstTriggerCharacter: ':'
                },
                renameProvider: {
                    prepareProvider: true
                },
                documentLinkProvider: {
                    resolveProvider: true
                },
                colorProvider: true,
                declarationProvider: true,
                foldingRangeProvider: true,
                implementationProvider: {
                    documentSelector: [{ language: '*' }]
                },
                selectionRangeProvider: true,
                inlineValueProvider: {},
                inlayHintProvider: {
                    resolveProvider: true
                },
                typeDefinitionProvider: {
                    id: '82671a9a-2a69-4e9f-a8d7-e1034eaa0d2e',
                    documentSelector: [{ language: '*' }]
                },
                callHierarchyProvider: true,
                semanticTokensProvider: {
                    legend: {
                        tokenTypes: [],
                        tokenModifiers: []
                    },
                    range: true,
                    full: {
                        delta: true
                    }
                },
                workspace: {
                    fileOperations: {
                        didCreate: { filters: [{ scheme: 'file', pattern: { glob: '**/created-static/**{/,/*.txt}' } }] },
                        didRename: {
                            filters: [
                                { scheme: 'file', pattern: { glob: '**/renamed-static/**/', matches: 'folder' } },
                                { scheme: 'file', pattern: { glob: '**/renamed-static/**/*.txt', matches: 'file' } }
                            ]
                        },
                        didDelete: { filters: [{ scheme: 'file', pattern: { glob: '**/deleted-static/**{/,/*.txt}' } }] },
                        willCreate: { filters: [{ scheme: 'file', pattern: { glob: '**/created-static/**{/,/*.txt}' } }] },
                        willRename: {
                            filters: [
                                { scheme: 'file', pattern: { glob: '**/renamed-static/**/', matches: 'folder' } },
                                { scheme: 'file', pattern: { glob: '**/renamed-static/**/*.txt', matches: 'file' } }
                            ]
                        },
                        willDelete: { filters: [{ scheme: 'file', pattern: { glob: '**/deleted-static/**{/,/*.txt}' } }] },
                    },
                },
                linkedEditingRangeProvider: true,
                diagnosticProvider: {
                    identifier: 'da348dc5-c30a-4515-9d98-31ff3be38d14',
                    interFileDependencies: true,
                    workspaceDiagnostics: true
                },
                typeHierarchyProvider: true,
                workspaceSymbolProvider: {
                    resolveProvider: true
                },
                notebookDocumentSync: {
                    notebookSelector: [{
                            notebook: { notebookType: 'jupyter-notebook' },
                            cells: [{ language: 'python' }]
                        }]
                }
            },
            customResults: {
                hello: 'world'
            }
        };
        assert.deepEqual(client.initializeResult, expected);
    });
    test('feature.getState()', async () => {
        const testFeature = (method, kind) => {
            let feature = client.getFeature(method);
            assert.notStrictEqual(feature, undefined);
            let res = feature.getState();
            assert.strictEqual(res.kind, kind);
        };
        const testStaticFeature = (method, kind) => {
            let feature = client.getStaticFeature(method);
            assert.notStrictEqual(feature, undefined);
            let res = feature.getState();
            assert.strictEqual(res.kind, kind);
        };
        testStaticFeature(vscode_languageserver_protocol_1.ConfigurationRequest.method, 'static');
        testStaticFeature(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, 'window');
        testFeature(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method, 'document');
        testFeature(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.method, 'document');
        testFeature(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DidCreateFilesNotification.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.DidRenameFilesNotification.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.DidDeleteFilesNotification.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.WillCreateFilesRequest.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.WillRenameFilesRequest.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.WillDeleteFilesRequest.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.CompletionRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.HoverRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.SignatureHelpRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DefinitionRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.ReferencesRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentHighlightRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.CodeActionRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.CodeLensRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentFormattingRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.RenameRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentSymbolRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentLinkRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DocumentColorRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.DeclarationRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.FoldingRangeRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.ImplementationRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.SelectionRangeRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.TypeDefinitionRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.SemanticTokensRegistrationType.method, 'document');
        testFeature(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.InlineValueRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.InlayHintRequest.method, 'document');
        testFeature(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.method, 'workspace');
        testFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method, 'document');
    });
    test('Goto Definition', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DefinitionRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideDefinition(document, position, tokenSource.token));
        assert.strictEqual(vscode_languageserver_protocol_1.Location.is(result), true);
        uriEqual(result.uri, uri);
        rangeEqual(result.range, 0, 0, 0, 1);
        let middlewareCalled = false;
        middleware.provideDefinition = (document, position, token, next) => {
            middlewareCalled = true;
            return next(document, position, token);
        };
        await provider.provideDefinition(document, position, tokenSource.token);
        middleware.provideDefinition = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Hover', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.HoverRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideHover(document, position, tokenSource.token);
        assert.ok(vscode_languageserver_protocol_1.Hover.is(result));
        assert.strictEqual(result.contents.kind, 'plaintext');
        assert.strictEqual(result.contents.value, 'foo');
        let middlewareCalled = false;
        middleware.provideHover = (document, position, token, next) => {
            middlewareCalled = true;
            return next(document, position, token);
        };
        await provider.provideHover(document, position, tokenSource.token);
        middleware.provideHover = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Completion', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.CompletionRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideCompletionItems(document, position, tokenSource.token, { triggerKind: vscode_languageserver_protocol_1.CompletionTriggerKind.Invoked, triggerCharacter: ':' }));
        isArray(result, vscode_languageserver_protocol_1.CompletionItem);
        const item = result[0];
        assert.strictEqual(item.label, 'item');
        assert.strictEqual(item.insertText, 'text');
        assert.strictEqual(item.detail, undefined);
        isDefined(provider.resolveCompletionItem);
        const resolved = await provider.resolveCompletionItem(item, tokenSource.token);
        isDefined(resolved);
        assert.strictEqual(resolved.detail, 'detail');
        let middlewareCalled = 0;
        middleware.provideCompletionItem = (document, position, context, token, next) => {
            middlewareCalled++;
            return next(document, position, context, token);
        };
        middleware.resolveCompletionItem = (item, token, next) => {
            middlewareCalled++;
            return next(item, token);
        };
        await provider.provideCompletionItems(document, position, tokenSource.token, { triggerKind: vscode_languageserver_protocol_1.CompletionTriggerKind.Invoked, triggerCharacter: ':' });
        await provider.resolveCompletionItem(item, tokenSource.token);
        middleware.provideCompletionItem = undefined;
        middleware.resolveCompletionItem = undefined;
        assert.strictEqual(middlewareCalled, 2);
    });
    test('SignatureHelpRequest', async () => {
        await helper_1.default.wait(50);
        let provider = client.getFeature(vscode_languageserver_protocol_1.SignatureHelpRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideSignatureHelp(document, position, tokenSource.token, {
            isRetrigger: false,
            triggerKind: vscode_languageserver_protocol_1.SignatureHelpTriggerKind.Invoked,
            triggerCharacter: ':'
        });
        assert.strictEqual(result.activeSignature, 1);
        assert.strictEqual(result.activeParameter, 1);
        isArray(result.signatures, vscode_languageserver_protocol_1.SignatureInformation);
        const signature = result.signatures[0];
        assert.strictEqual(signature.label, 'label');
        assert.strictEqual(signature.documentation, 'doc');
        isArray(signature.parameters, vscode_languageserver_protocol_1.ParameterInformation);
        const parameter = signature.parameters[0];
        assert.strictEqual(parameter.label, 'label');
        assert.strictEqual(parameter.documentation, 'doc');
        let middlewareCalled = false;
        middleware.provideSignatureHelp = (d, p, c, t, n) => {
            middlewareCalled = true;
            return n(d, p, c, t);
        };
        await provider.provideSignatureHelp(document, position, tokenSource.token, {
            isRetrigger: false,
            triggerKind: vscode_languageserver_protocol_1.SignatureHelpTriggerKind.Invoked,
            triggerCharacter: ':'
        });
        middleware.provideSignatureHelp = undefined;
        assert.ok(middlewareCalled);
    });
    test('References', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.ReferencesRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideReferences(document, position, {
            includeDeclaration: true
        }, tokenSource.token);
        isArray(result, vscode_languageserver_protocol_1.Location, 2);
        for (let i = 0; i < result.length; i++) {
            const location = result[i];
            rangeEqual(location.range, i, i, i, i);
            assert.strictEqual(location.uri.toString(), document.uri.toString());
        }
        let middlewareCalled = false;
        middleware.provideReferences = (d, p, c, t, n) => {
            middlewareCalled = true;
            return n(d, p, c, t);
        };
        await provider.provideReferences(document, position, {
            includeDeclaration: true
        }, tokenSource.token);
        middleware.provideReferences = undefined;
        assert.ok(middlewareCalled);
    });
    test('Document Highlight', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DocumentHighlightRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideDocumentHighlights(document, position, tokenSource.token);
        isArray(result, vscode_languageserver_protocol_1.DocumentHighlight, 1);
        const highlight = result[0];
        assert.strictEqual(highlight.kind, vscode_languageserver_protocol_1.DocumentHighlightKind.Read);
        rangeEqual(highlight.range, 2, 2, 2, 2);
        let middlewareCalled = false;
        middleware.provideDocumentHighlights = (d, p, t, n) => {
            middlewareCalled = true;
            return n(d, p, t);
        };
        await provider.provideDocumentHighlights(document, position, tokenSource.token);
        middleware.provideDocumentHighlights = undefined;
        assert.ok(middlewareCalled);
    });
    test('Code Actions', async () => {
        var _a, _b;
        const provider = client.getFeature(vscode_languageserver_protocol_1.CodeActionRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideCodeActions(document, range, {
            diagnostics: []
        }, tokenSource.token));
        isArray(result, vscode_languageserver_protocol_1.CodeAction);
        const action = result[0];
        assert.strictEqual(action.title, 'title');
        assert.strictEqual((_a = action.command) === null || _a === void 0 ? void 0 : _a.title, 'title');
        assert.strictEqual((_b = action.command) === null || _b === void 0 ? void 0 : _b.command, 'test_command');
        let response = await commands_1.default.execute(action.command);
        expect(response).toEqual({ success: true });
        const resolved = (await provider.resolveCodeAction(result[0], tokenSource.token));
        assert.strictEqual(resolved === null || resolved === void 0 ? void 0 : resolved.title, 'resolved');
        let middlewareCalled = false;
        middleware.provideCodeActions = (d, r, c, t, n) => {
            middlewareCalled = true;
            return n(d, r, c, t);
        };
        await provider.provideCodeActions(document, range, { diagnostics: [] }, tokenSource.token);
        middleware.provideCodeActions = undefined;
        assert.ok(middlewareCalled);
        middlewareCalled = false;
        middleware.resolveCodeAction = (c, t, n) => {
            middlewareCalled = true;
            return n(c, t);
        };
        await provider.resolveCodeAction(result[0], tokenSource.token);
        middleware.resolveCodeAction = undefined;
        assert.ok(middlewareCalled);
        let uri = vscode_uri_1.URI.parse('lsptests://localhost/empty.bat').toString();
        let textDocument = vscode_languageserver_textdocument_1.TextDocument.create(uri, 'bat', 1, '\n');
        let res = (await provider.provideCodeActions(textDocument, range, {
            diagnostics: []
        }, tokenSource.token));
        expect(res).toBeUndefined();
    });
    test('CodeLens', async () => {
        let feature = client.getFeature(vscode_languageserver_protocol_1.CodeLensRequest.method);
        let state = feature.getState();
        expect(state.registrations).toBe(true);
        expect(state.matches).toBe(true);
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let codeLens = await languages_1.default.getCodeLens(document, tokenSource.token);
        expect(codeLens.length).toBe(2);
        let resolved = await languages_1.default.resolveCodeLens(codeLens[0], tokenSource.token);
        expect(resolved.command).toBeDefined();
        let fireRefresh = false;
        let provider = feature.getProvider(document);
        provider.onDidChangeCodeLensEmitter.event(() => {
            fireRefresh = true;
        });
        await client.sendNotification('fireCodeLensRefresh');
        await helper_1.default.wait(50);
        expect(fireRefresh).toBe(true);
    });
    test('Progress', async () => {
        const progressToken = 'TEST-PROGRESS-TOKEN';
        const middlewareEvents = [];
        let currentProgressResolver;
        // Set up middleware that calls the current resolve function when it gets its 'end' progress event.
        middleware.handleWorkDoneProgress = (token, params, next) => {
            if (token === progressToken) {
                middlewareEvents.push(params);
                if (params.kind === 'end') {
                    setImmediate(currentProgressResolver);
                }
            }
            return next(token, params);
        };
        // Trigger multiple sample progress events.
        for (let i = 0; i < 2; i++) {
            await new Promise((resolve, reject) => {
                currentProgressResolver = resolve;
                void client.sendRequest(new vscode_languageserver_protocol_1.ProtocolRequestType('testing/sendSampleProgress'), {}, tokenSource.token).catch(reject);
            });
        }
        middleware.handleWorkDoneProgress = undefined;
        // Ensure all events were handled.
        assert.deepStrictEqual(middlewareEvents.map(p => p.kind), ['begin', 'report', 'end', 'begin', 'report', 'end']);
        await client.sendRequest(new vscode_languageserver_protocol_1.ProtocolRequestType('testing/beginOnlyProgress'), {}, tokenSource.token);
    });
    test('Document Formatting', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DocumentFormattingRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideDocumentFormattingEdits(document, { tabSize: 4, insertSpaces: false }, tokenSource.token);
        isArray(result, vscode_languageserver_protocol_1.TextEdit);
        const edit = result[0];
        assert.strictEqual(edit.newText, 'insert');
        rangeEqual(edit.range, 0, 0, 0, 0);
        let middlewareCalled = true;
        middleware.provideDocumentFormattingEdits = (d, c, t, n) => {
            middlewareCalled = true;
            return n(d, c, t);
        };
        await provider.provideDocumentFormattingEdits(document, { tabSize: 4, insertSpaces: false }, tokenSource.token);
        middleware.provideDocumentFormattingEdits = undefined;
        assert.ok(middlewareCalled);
    });
    test('Document Range Formatting', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideDocumentRangeFormattingEdits(document, range, { tabSize: 4, insertSpaces: false }, tokenSource.token);
        isArray(result, vscode_languageserver_protocol_1.TextEdit);
        const edit = result[0];
        assert.strictEqual(edit.newText, '');
        rangeEqual(edit.range, 1, 1, 1, 2);
        let middlewareCalled = true;
        middleware.provideDocumentRangeFormattingEdits = (d, r, c, t, n) => {
            middlewareCalled = true;
            return n(d, r, c, t);
        };
        await provider.provideDocumentRangeFormattingEdits(document, range, { tabSize: 4, insertSpaces: false }, tokenSource.token);
        middleware.provideDocumentFormattingEdits = undefined;
        assert.ok(middlewareCalled);
    });
    test('Document on Type Formatting', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideOnTypeFormattingEdits(document, position, 'a', { tabSize: 4, insertSpaces: false }, tokenSource.token);
        isArray(result, vscode_languageserver_protocol_1.TextEdit);
        const edit = result[0];
        assert.strictEqual(edit.newText, 'replace');
        rangeEqual(edit.range, 2, 2, 2, 3);
        let middlewareCalled = true;
        middleware.provideOnTypeFormattingEdits = (d, p, s, c, t, n) => {
            middlewareCalled = true;
            return n(d, p, s, c, t);
        };
        await provider.provideOnTypeFormattingEdits(document, position, 'a', { tabSize: 4, insertSpaces: false }, tokenSource.token);
        middleware.provideDocumentFormattingEdits = undefined;
        assert.ok(middlewareCalled);
    });
    test('Rename', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.RenameRequest.method).getProvider(document);
        isDefined(provider);
        isDefined(provider.prepareRename);
        const prepareResult = await provider.prepareRename(document, position, tokenSource.token);
        rangeEqual(prepareResult, 1, 1, 1, 2);
        const renameResult = await provider.provideRenameEdits(document, position, 'newName', tokenSource.token);
        assert.ok(vscode_languageserver_protocol_1.WorkspaceEdit.is(renameResult));
        let middlewareCalled = 0;
        middleware.prepareRename = (d, p, t, n) => {
            middlewareCalled++;
            return n(d, p, t);
        };
        await provider.prepareRename(document, position, tokenSource.token);
        middleware.prepareRename = undefined;
        middleware.provideRenameEdits = (d, p, w, t, n) => {
            middlewareCalled++;
            return n(d, p, w, t);
        };
        await provider.provideRenameEdits(document, position, 'newName', tokenSource.token);
        middleware.provideRenameEdits = undefined;
        assert.strictEqual(middlewareCalled, 2);
    });
    test('Document Link', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DocumentLinkRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideDocumentLinks(document, tokenSource.token);
        isArray(result, vscode_languageserver_protocol_1.DocumentLink);
        const documentLink = result[0];
        rangeEqual(documentLink.range, 1, 1, 1, 2);
        let middlewareCalled = 0;
        middleware.provideDocumentLinks = (d, t, n) => {
            middlewareCalled++;
            return n(d, t);
        };
        await provider.provideDocumentLinks(document, tokenSource.token);
        middleware.provideDocumentLinks = undefined;
        isDefined(provider.resolveDocumentLink);
        const resolved = await provider.resolveDocumentLink(documentLink, tokenSource.token);
        isDefined(resolved.target);
        assert.strictEqual(resolved.target.toString(), vscode_uri_1.URI.file('/target.txt').toString());
        middleware.resolveDocumentLink = (i, t, n) => {
            middlewareCalled++;
            return n(i, t);
        };
        await provider.resolveDocumentLink(documentLink, tokenSource.token);
        middleware.resolveDocumentLink = undefined;
        assert.strictEqual(middlewareCalled, 2);
    });
    test('Document Color', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DocumentColorRequest.method).getProvider(document);
        isDefined(provider);
        const colors = await provider.provideDocumentColors(document, tokenSource.token);
        isArray(colors, vscode_languageserver_protocol_1.ColorInformation);
        const color = colors[0];
        rangeEqual(color.range, 1, 1, 1, 2);
        colorEqual(color.color, 1, 1, 1, 1);
        let middlewareCalled = 0;
        middleware.provideDocumentColors = (d, t, n) => {
            middlewareCalled++;
            return n(d, t);
        };
        await provider.provideDocumentColors(document, tokenSource.token);
        middleware.provideDocumentColors = undefined;
        const presentations = await provider.provideColorPresentations(color.color, { document, range }, tokenSource.token);
        isArray(presentations, vscode_languageserver_protocol_1.ColorPresentation);
        const presentation = presentations[0];
        assert.strictEqual(presentation.label, 'label');
        middleware.provideColorPresentations = (c, x, t, n) => {
            middlewareCalled++;
            return n(c, x, t);
        };
        await provider.provideColorPresentations(color.color, { document, range }, tokenSource.token);
        middleware.provideColorPresentations = undefined;
        assert.strictEqual(middlewareCalled, 2);
    });
    test('Goto Declaration', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.DeclarationRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideDeclaration(document, position, tokenSource.token));
        uriEqual(result.uri, uri);
        rangeEqual(result.range, 1, 1, 1, 2);
        let middlewareCalled = false;
        middleware.provideDeclaration = (document, position, token, next) => {
            middlewareCalled = true;
            return next(document, position, token);
        };
        await provider.provideDeclaration(document, position, tokenSource.token);
        middleware.provideDeclaration = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Folding Ranges', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.FoldingRangeRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideFoldingRanges(document, {}, tokenSource.token));
        isArray(result, vscode_languageserver_protocol_1.FoldingRange, 1);
        const range = result[0];
        assert.strictEqual(range.startLine, 1);
        assert.strictEqual(range.endLine, 2);
        let middlewareCalled = true;
        middleware.provideFoldingRanges = (d, c, t, n) => {
            middlewareCalled = true;
            return n(d, c, t);
        };
        await provider.provideFoldingRanges(document, {}, tokenSource.token);
        middleware.provideFoldingRanges = undefined;
        assert.ok(middlewareCalled);
    });
    test('Goto Implementation', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.ImplementationRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideImplementation(document, position, tokenSource.token));
        uriEqual(result.uri, uri);
        rangeEqual(result.range, 2, 2, 3, 3);
        let middlewareCalled = false;
        middleware.provideImplementation = (document, position, token, next) => {
            middlewareCalled = true;
            return next(document, position, token);
        };
        await provider.provideImplementation(document, position, tokenSource.token);
        middleware.provideImplementation = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Selection Range', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.SelectionRangeRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideSelectionRanges(document, [position], tokenSource.token));
        isArray(result, vscode_languageserver_protocol_1.SelectionRange, 1);
        const range = result[0];
        rangeEqual(range.range, 1, 2, 3, 4);
        let middlewareCalled = false;
        middleware.provideSelectionRanges = (d, p, t, n) => {
            middlewareCalled = true;
            return n(d, p, t);
        };
        await provider.provideSelectionRanges(document, [position], tokenSource.token);
        middleware.provideSelectionRanges = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Type Definition', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.TypeDefinitionRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.provideTypeDefinition(document, position, tokenSource.token));
        uriEqual(result.uri, uri);
        rangeEqual(result.range, 2, 2, 3, 3);
        let middlewareCalled = false;
        middleware.provideTypeDefinition = (document, position, token, next) => {
            middlewareCalled = true;
            return next(document, position, token);
        };
        await provider.provideTypeDefinition(document, position, tokenSource.token);
        middleware.provideTypeDefinition = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Call Hierarchy', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.method).getProvider(document);
        isDefined(provider);
        const result = (await provider.prepareCallHierarchy(document, position, tokenSource.token));
        expect(result.length).toBe(1);
        let middlewareCalled = false;
        middleware.prepareCallHierarchy = (d, p, t, n) => {
            middlewareCalled = true;
            return n(d, p, t);
        };
        await provider.prepareCallHierarchy(document, position, tokenSource.token);
        middleware.prepareCallHierarchy = undefined;
        assert.strictEqual(middlewareCalled, true);
        const item = result[0];
        const incoming = (await provider.provideCallHierarchyIncomingCalls(item, tokenSource.token));
        expect(incoming.length).toBe(1);
        assert.deepEqual(incoming[0].from, item);
        middlewareCalled = false;
        middleware.provideCallHierarchyIncomingCalls = (i, t, n) => {
            middlewareCalled = true;
            return n(i, t);
        };
        await provider.provideCallHierarchyIncomingCalls(item, tokenSource.token);
        middleware.provideCallHierarchyIncomingCalls = undefined;
        assert.strictEqual(middlewareCalled, true);
        const outgoing = (await provider.provideCallHierarchyOutgoingCalls(item, tokenSource.token));
        expect(outgoing.length).toBe(1);
        assert.deepEqual(outgoing[0].to, item);
        middlewareCalled = false;
        middleware.provideCallHierarchyOutgoingCalls = (i, t, n) => {
            middlewareCalled = true;
            return n(i, t);
        };
        await provider.provideCallHierarchyOutgoingCalls(item, tokenSource.token);
        middleware.provideCallHierarchyOutgoingCalls = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    const referenceFileUri = vscode_uri_1.URI.parse('/dummy-edit');
    function ensureReferenceEdit(edits, type, expectedLines) {
        var _a;
        // // Ensure the edits are as expected.
        assert.strictEqual((_a = edits.documentChanges) === null || _a === void 0 ? void 0 : _a.length, 1);
        const edit = edits.documentChanges[0];
        assert.strictEqual(edit.edits.length, 1);
        assert.strictEqual(edit.textDocument.uri, referenceFileUri.path);
        assert.strictEqual(edit.edits[0].newText.trim(), `${type}:\n${expectedLines.join('\n')}`.trim());
    }
    async function ensureNotificationReceived(type, params) {
        const result = await client.sendRequest(new vscode_languageserver_protocol_1.ProtocolRequestType('testing/lastFileOperationRequest'), {}, tokenSource.token);
        assert.strictEqual(result.type, type);
        assert.deepEqual(result.params, params);
        assert.deepEqual(result, {
            type,
            params
        });
    }
    const createFiles = [
        '/my/file.txt',
        '/my/file.js',
        '/my/folder/',
        // Static registration for tests is [operation]-static and *.txt
        '/my/created-static/file.txt',
        '/my/created-static/file.js',
        '/my/created-static/folder/',
        // Dynamic registration for tests is [operation]-dynamic and *.js
        '/my/created-dynamic/file.txt',
        '/my/created-dynamic/file.js',
        '/my/created-dynamic/folder/',
    ].map(p => vscode_uri_1.URI.file(p));
    const renameFiles = [
        ['/my/file.txt', '/my-new/file.txt'],
        ['/my/file.js', '/my-new/file.js'],
        ['/my/folder/', '/my-new/folder/'],
        // Static registration for tests is [operation]-static and *.txt
        ['/my/renamed-static/file.txt', '/my-new/renamed-static/file.txt'],
        ['/my/renamed-static/file.js', '/my-new/renamed-static/file.js'],
        ['/my/renamed-static/folder/', '/my-new/renamed-static/folder/'],
        // Dynamic registration for tests is [operation]-dynamic and *.js
        ['/my/renamed-dynamic/file.txt', '/my-new/renamed-dynamic/file.txt'],
        ['/my/renamed-dynamic/file.js', '/my-new/renamed-dynamic/file.js'],
        ['/my/renamed-dynamic/folder/', '/my-new/renamed-dynamic/folder/'],
    ].map(([o, n]) => ({ oldUri: vscode_uri_1.URI.file(o), newUri: vscode_uri_1.URI.file(n) }));
    const deleteFiles = [
        '/my/file.txt',
        '/my/file.js',
        '/my/folder/',
        // Static registration for tests is [operation]-static and *.txt
        '/my/deleted-static/file.txt',
        '/my/deleted-static/file.js',
        '/my/deleted-static/folder/',
        // Dynamic registration for tests is [operation]-dynamic and *.js
        '/my/deleted-dynamic/file.txt',
        '/my/deleted-dynamic/file.js',
        '/my/deleted-dynamic/folder/',
    ].map(p => vscode_uri_1.URI.file(p));
    test('File Operations - Will Create Files', async () => {
        const feature = client.getFeature(vscode_languageserver_protocol_1.WillCreateFilesRequest.method);
        isDefined(feature);
        const sendCreateRequest = () => new Promise(async (resolve, reject) => {
            void feature.send({ token: vscode_languageserver_protocol_1.CancellationToken.None, files: createFiles, waitUntil: resolve });
            // If feature.send didn't call waitUntil synchronously then something went wrong.
            reject(new Error('Feature unexpectedly did not call waitUntil synchronously'));
        });
        // Send the event and ensure the server responds with an edit referencing the
        // correct files.
        let edits = await sendCreateRequest();
        ensureReferenceEdit(edits, 'WILL CREATE', [
            'file:///my/created-static/file.txt',
            'file:///my/created-static/folder/',
            'file:///my/created-dynamic/file.js',
            'file:///my/created-dynamic/folder/',
        ]);
        // Add middleware that strips out any folders.
        middleware.workspace = middleware.workspace || {};
        middleware.workspace.willCreateFiles = (event, next) => next(Object.assign(Object.assign({}, event), { files: event.files.filter(f => !f.path.endsWith('/')) }));
        // Ensure we get the same results minus the folders that the middleware removed.
        edits = await sendCreateRequest();
        ensureReferenceEdit(edits, 'WILL CREATE', [
            'file:///my/created-static/file.txt',
            'file:///my/created-dynamic/file.js',
        ]);
        middleware.workspace.willCreateFiles = undefined;
    });
    test('File Operations - Did Create Files', async () => {
        const feature = client.getFeature(vscode_languageserver_protocol_1.DidCreateFilesNotification.method);
        isDefined(feature);
        // Send the event and ensure the server reports the notification was sent.
        await feature.send({ files: createFiles });
        await ensureNotificationReceived('create', {
            files: [
                { uri: 'file:///my/created-static/file.txt' },
                { uri: 'file:///my/created-static/folder/' },
                { uri: 'file:///my/created-dynamic/file.js' },
                { uri: 'file:///my/created-dynamic/folder/' },
            ],
        });
        // Add middleware that strips out any folders.
        middleware.workspace = middleware.workspace || {};
        middleware.workspace.didCreateFiles = (event, next) => next({
            files: event.files.filter(f => !f.path.endsWith('/')),
        });
        // Ensure we get the same results minus the folders that the middleware removed.
        await feature.send({ files: createFiles });
        await ensureNotificationReceived('create', {
            files: [
                { uri: 'file:///my/created-static/file.txt' },
                { uri: 'file:///my/created-dynamic/file.js' },
            ],
        });
        middleware.workspace.didCreateFiles = undefined;
    });
    test('File Operations - Will Rename Files', async () => {
        const feature = client.getFeature(vscode_languageserver_protocol_1.WillRenameFilesRequest.method);
        isDefined(feature);
        const sendRenameRequest = () => new Promise(async (resolve, reject) => {
            void feature.send({ files: renameFiles, waitUntil: resolve });
            // If feature.send didn't call waitUntil synchronously then something went wrong.
            reject(new Error('Feature unexpectedly did not call waitUntil synchronously'));
        });
        // Send the event and ensure the server responds with an edit referencing the
        // correct files.
        let edits = await sendRenameRequest();
        ensureReferenceEdit(edits, 'WILL RENAME', [
            'file:///my/renamed-static/file.txt -> file:///my-new/renamed-static/file.txt',
            'file:///my/renamed-static/folder/ -> file:///my-new/renamed-static/folder/',
            'file:///my/renamed-dynamic/file.js -> file:///my-new/renamed-dynamic/file.js',
            'file:///my/renamed-dynamic/folder/ -> file:///my-new/renamed-dynamic/folder/',
        ]);
        // Add middleware that strips out any folders.
        middleware.workspace = middleware.workspace || {};
        middleware.workspace.willRenameFiles = (event, next) => next(Object.assign(Object.assign({}, event), { files: event.files.filter(f => !f.oldUri.path.endsWith('/')) }));
        // Ensure we get the same results minus the folders that the middleware removed.
        edits = await sendRenameRequest();
        ensureReferenceEdit(edits, 'WILL RENAME', [
            'file:///my/renamed-static/file.txt -> file:///my-new/renamed-static/file.txt',
            'file:///my/renamed-dynamic/file.js -> file:///my-new/renamed-dynamic/file.js',
        ]);
        middleware.workspace.willRenameFiles = undefined;
    });
    test('File Operations - Did Rename Files', async () => {
        const feature = client.getFeature(vscode_languageserver_protocol_1.DidRenameFilesNotification.method);
        isDefined(feature);
        // Send the event and ensure the server reports the notification was sent.
        await feature.send({ files: renameFiles });
        await ensureNotificationReceived('rename', {
            files: [
                { oldUri: 'file:///my/renamed-static/file.txt', newUri: 'file:///my-new/renamed-static/file.txt' },
                { oldUri: 'file:///my/renamed-static/folder/', newUri: 'file:///my-new/renamed-static/folder/' },
                { oldUri: 'file:///my/renamed-dynamic/file.js', newUri: 'file:///my-new/renamed-dynamic/file.js' },
                { oldUri: 'file:///my/renamed-dynamic/folder/', newUri: 'file:///my-new/renamed-dynamic/folder/' },
            ],
        });
        // Add middleware that strips out any folders.
        middleware.workspace = middleware.workspace || {};
        middleware.workspace.didRenameFiles = (event, next) => next({
            files: event.files.filter(f => !f.oldUri.path.endsWith('/')),
        });
        // Ensure we get the same results minus the folders that the middleware removed.
        await feature.send({ files: renameFiles });
        await ensureNotificationReceived('rename', {
            files: [
                { oldUri: 'file:///my/renamed-static/file.txt', newUri: 'file:///my-new/renamed-static/file.txt' },
                { oldUri: 'file:///my/renamed-dynamic/file.js', newUri: 'file:///my-new/renamed-dynamic/file.js' },
            ],
        });
        middleware.workspace.didRenameFiles = undefined;
    });
    test('File Operations - Will Delete Files', async () => {
        const feature = client.getFeature(vscode_languageserver_protocol_1.WillDeleteFilesRequest.method);
        isDefined(feature);
        const sendDeleteRequest = () => new Promise(async (resolve, reject) => {
            void feature.send({ files: deleteFiles, waitUntil: resolve });
            // If feature.send didn't call waitUntil synchronously then something went wrong.
            reject(new Error('Feature unexpectedly did not call waitUntil synchronously'));
        });
        // Send the event and ensure the server responds with an edit referencing the
        // correct files.
        let edits = await sendDeleteRequest();
        ensureReferenceEdit(edits, 'WILL DELETE', [
            'file:///my/deleted-static/file.txt',
            'file:///my/deleted-static/folder/',
            'file:///my/deleted-dynamic/file.js',
            'file:///my/deleted-dynamic/folder/',
        ]);
        // Add middleware that strips out any folders.
        middleware.workspace = middleware.workspace || {};
        middleware.workspace.willDeleteFiles = (event, next) => next(Object.assign(Object.assign({}, event), { files: event.files.filter(f => !f.path.endsWith('/')) }));
        // Ensure we get the same results minus the folders that the middleware removed.
        edits = await sendDeleteRequest();
        ensureReferenceEdit(edits, 'WILL DELETE', [
            'file:///my/deleted-static/file.txt',
            'file:///my/deleted-dynamic/file.js',
        ]);
        middleware.workspace.willDeleteFiles = undefined;
    });
    test('File Operations - Did Delete Files', async () => {
        const feature = client.getFeature(vscode_languageserver_protocol_1.DidDeleteFilesNotification.method);
        isDefined(feature);
        // Send the event and ensure the server reports the notification was sent.
        await feature.send({ files: deleteFiles });
        await ensureNotificationReceived('delete', {
            files: [
                { uri: 'file:///my/deleted-static/file.txt' },
                { uri: 'file:///my/deleted-static/folder/' },
                { uri: 'file:///my/deleted-dynamic/file.js' },
                { uri: 'file:///my/deleted-dynamic/folder/' },
            ],
        });
        // Add middleware that strips out any folders.
        middleware.workspace = middleware.workspace || {};
        middleware.workspace.didDeleteFiles = (event, next) => next({
            files: event.files.filter(f => !f.path.endsWith('/')),
        });
        // Ensure we get the same results minus the folders that the middleware removed.
        await feature.send({ files: deleteFiles });
        await ensureNotificationReceived('delete', {
            files: [
                { uri: 'file:///my/deleted-static/file.txt' },
                { uri: 'file:///my/deleted-dynamic/file.js' },
            ],
        });
        middleware.workspace.didDeleteFiles = undefined;
    });
    test('Semantic Tokens', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.SemanticTokensRegistrationType.method).getProvider(document);
        const rangeProvider = provider === null || provider === void 0 ? void 0 : provider.range;
        isDefined(rangeProvider);
        const rangeResult = await rangeProvider.provideDocumentRangeSemanticTokens(document, range, tokenSource.token);
        assert.ok(rangeResult !== undefined);
        let middlewareCalled = false;
        middleware.provideDocumentRangeSemanticTokens = (d, r, t, n) => {
            middlewareCalled = true;
            return n(d, r, t);
        };
        await rangeProvider.provideDocumentRangeSemanticTokens(document, range, tokenSource.token);
        middleware.provideDocumentRangeSemanticTokens = undefined;
        assert.strictEqual(middlewareCalled, true);
        const fullProvider = provider === null || provider === void 0 ? void 0 : provider.full;
        isDefined(fullProvider);
        const fullResult = await fullProvider.provideDocumentSemanticTokens(document, tokenSource.token);
        assert.ok(fullResult !== undefined);
        middlewareCalled = false;
        middleware.provideDocumentSemanticTokens = (d, t, n) => {
            middlewareCalled = true;
            return n(d, t);
        };
        await fullProvider.provideDocumentSemanticTokens(document, tokenSource.token);
        middleware.provideDocumentSemanticTokens = undefined;
        assert.strictEqual(middlewareCalled, true);
        middlewareCalled = false;
        middleware.provideDocumentSemanticTokensEdits = (d, i, t, n) => {
            middlewareCalled = true;
            return n(d, i, t);
        };
        await fullProvider.provideDocumentSemanticTokensEdits(document, '2', tokenSource.token);
        middleware.provideDocumentSemanticTokensEdits = undefined;
        assert.strictEqual(middlewareCalled, true);
        let called = false;
        provider.onDidChangeSemanticTokensEmitter.event(() => {
            called = true;
        });
        await client.sendNotification('fireSemanticTokensRefresh');
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
    test('Linked Editing Ranges', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.provideLinkedEditingRanges(document, position, tokenSource.token);
        isArray(result.ranges, vscode_languageserver_protocol_1.Range, 1);
        rangeEqual(result.ranges[0], 1, 1, 1, 1);
        let middlewareCalled = false;
        middleware.provideLinkedEditingRange = (document, position, token, next) => {
            middlewareCalled = true;
            return next(document, position, token);
        };
        await provider.provideLinkedEditingRanges(document, position, tokenSource.token);
        middleware.provideTypeDefinition = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Document diagnostic pull', async () => {
        var _a;
        const provider = (_a = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method)) === null || _a === void 0 ? void 0 : _a.getProvider(document);
        isDefined(provider);
        const result = await provider.diagnostics.provideDiagnostics(document, undefined, tokenSource.token);
        isDefined(result);
        isFullDocumentDiagnosticReport(result);
        const diag = result.items[0];
        rangeEqual(diag.range, 1, 1, 1, 1);
        assert.strictEqual(diag.message, 'diagnostic');
        let middlewareCalled = false;
        middleware.provideDiagnostics = (document, previousResultId, token, next) => {
            middlewareCalled = true;
            return next(document, previousResultId, token);
        };
        await provider.diagnostics.provideDiagnostics(document, undefined, tokenSource.token);
        middleware.provideDiagnostics = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Workspace diagnostic pull', async () => {
        var _a;
        const provider = (_a = client.getFeature(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.method)) === null || _a === void 0 ? void 0 : _a.getProvider(document);
        isDefined(provider);
        isDefined(provider.diagnostics.provideWorkspaceDiagnostics);
        await provider.diagnostics.provideWorkspaceDiagnostics([], tokenSource.token, result => {
            isDefined(result);
            isArray(result.items, undefined, 1);
        });
        let middlewareCalled = false;
        middleware.provideWorkspaceDiagnostics = (resultIds, token, reporter, next) => {
            middlewareCalled = true;
            return next(resultIds, token, reporter);
        };
        await provider.diagnostics.provideWorkspaceDiagnostics([], tokenSource.token, () => { });
        middleware.provideWorkspaceDiagnostics = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Type Hierarchy', async () => {
        const provider = client.getFeature(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.method).getProvider(document);
        isDefined(provider);
        const result = await provider.prepareTypeHierarchy(document, position, tokenSource.token);
        isArray(result, undefined, 1);
        const item = result[0];
        let middlewareCalled = false;
        middleware.prepareTypeHierarchy = (d, p, t, n) => {
            middlewareCalled = true;
            return n(d, p, t);
        };
        await provider.prepareTypeHierarchy(document, position, tokenSource.token);
        middleware.prepareTypeHierarchy = undefined;
        assert.strictEqual(middlewareCalled, true);
        const incoming = await provider.provideTypeHierarchySupertypes(item, tokenSource.token);
        isArray(incoming, undefined, 1);
        middlewareCalled = false;
        middleware.provideTypeHierarchySupertypes = (i, t, n) => {
            middlewareCalled = true;
            return n(i, t);
        };
        await provider.provideTypeHierarchySupertypes(item, tokenSource.token);
        middleware.provideTypeHierarchySupertypes = undefined;
        assert.strictEqual(middlewareCalled, true);
        const outgoing = await provider.provideTypeHierarchySubtypes(item, tokenSource.token);
        isArray(outgoing, undefined, 1);
        middlewareCalled = false;
        middleware.provideTypeHierarchySubtypes = (i, t, n) => {
            middlewareCalled = true;
            return n(i, t);
        };
        await provider.provideTypeHierarchySubtypes(item, tokenSource.token);
        middleware.provideTypeHierarchySubtypes = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Inline Values', async () => {
        const providerData = client.getFeature(vscode_languageserver_protocol_1.InlineValueRequest.method).getProvider(document);
        isDefined(providerData);
        const provider = providerData.provider;
        const results = (await provider.provideInlineValues(document, range, { frameId: 1, stoppedLocation: range }, tokenSource.token));
        isArray(results, undefined, 3);
        for (const r of results) {
            rangeEqual(r.range, 1, 2, 3, 4);
        }
        // assert.ok(results[0] instanceof InlineValueText)
        assert.strictEqual(results[0].text, 'text');
        // assert.ok(results[1] instanceof InlineValueVariableLookup)
        assert.strictEqual(results[1].variableName, 'variableName');
        // assert.ok(results[2] instanceof InlineValueEvaluatableExpression)
        assert.strictEqual(results[2].expression, 'expression');
        let middlewareCalled = false;
        middleware.provideInlineValues = (d, r, c, t, n) => {
            middlewareCalled = true;
            return n(d, r, c, t);
        };
        await provider.provideInlineValues(document, range, { frameId: 1, stoppedLocation: range }, tokenSource.token);
        middleware.provideInlineValues = undefined;
        assert.strictEqual(middlewareCalled, true);
    });
    test('Inlay Hints', async () => {
        const providerData = client.getFeature(vscode_languageserver_protocol_1.InlayHintRequest.method).getProvider(document);
        isDefined(providerData);
        const provider = providerData.provider;
        const results = (await provider.provideInlayHints(document, range, tokenSource.token));
        isArray(results, undefined, 2);
        const hint = results[0];
        positionEqual(hint.position, 1, 1);
        assert.strictEqual(hint.kind, vscode_languageserver_protocol_1.InlayHintKind.Type);
        const label = hint.label;
        isArray(label, vscode_languageserver_protocol_1.InlayHintLabelPart, 1);
        assert.strictEqual(label[0].value, 'type');
        let middlewareCalled = false;
        middleware.provideInlayHints = (d, r, t, n) => {
            middlewareCalled = true;
            return n(d, r, t);
        };
        await provider.provideInlayHints(document, range, tokenSource.token);
        middleware.provideInlayHints = undefined;
        assert.strictEqual(middlewareCalled, true);
        assert.ok(typeof provider.resolveInlayHint === 'function');
        const resolvedHint = await provider.resolveInlayHint(hint, tokenSource.token);
        assert.strictEqual((resolvedHint === null || resolvedHint === void 0 ? void 0 : resolvedHint.label)[0].tooltip, 'tooltip');
        let called = false;
        await client.sendNotification('fireInlayHintsRefresh');
        provider.onDidChangeInlayHints(() => {
            called = true;
        });
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
    test('Workspace symbols', async () => {
        const providers = client.getFeature(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.method).getProviders();
        isDefined(providers);
        assert.strictEqual(providers.length, 2);
        const provider = providers[0];
        const results = await provider.provideWorkspaceSymbols('', tokenSource.token);
        isArray(results, undefined, 1);
        assert.strictEqual(results.length, 1);
        const symbol = await provider.resolveWorkspaceSymbol(results[0], tokenSource.token);
        isDefined(symbol);
        rangeEqual(symbol.location.range, 1, 2, 3, 4);
    });
});
var CrashNotification;
(function (CrashNotification) {
    CrashNotification.type = new vscode_languageserver_protocol_1.NotificationType0('test/crash');
})(CrashNotification || (CrashNotification = {}));
class CrashClient extends index_1.LanguageClient {
    constructor(id, name, serverOptions, clientOptions) {
        super(id, name, serverOptions, clientOptions);
        this.onCrash = new Promise(resolve => {
            this.resolve = resolve;
        });
    }
    handleConnectionClosed() {
        super.handleConnectionClosed();
        this.resolve();
    }
}
describe('sever tests', () => {
    test('Stop fails if server crashes after shutdown request', async () => {
        let file = path_1.default.join(__dirname, './server/crashOnShutdownServer.js');
        const serverOptions = {
            module: file,
            transport: index_1.TransportKind.ipc,
        };
        const clientOptions = {};
        const client = new index_1.LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        await client._start();
        await assert.rejects(async () => {
            await client.stop();
        }, /Pending response rejected since connection got disposed/);
        assert.strictEqual(client.needsStart(), true);
        assert.strictEqual(client.needsStop(), false);
        // Stopping again should be a no-op.
        await client.stop();
        assert.strictEqual(client.needsStart(), true);
        assert.strictEqual(client.needsStop(), false);
        await helper_1.default.wait(20);
    });
    test('Stop not throw if server shutdown request times out', async () => {
        const serverOptions = {
            module: path_1.default.join(__dirname, './server/timeoutOnShutdownServer.js'),
            transport: index_1.TransportKind.ipc,
        };
        const clientOptions = {};
        const client = new index_1.LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        await client._start();
        await client.stop(10);
    });
    test('Server can not be stopped right after start', async () => {
        const serverOptions = {
            module: path_1.default.join(__dirname, './server/startStopServer.js'),
            transport: index_1.TransportKind.ipc,
        };
        const clientOptions = {};
        const client = new index_1.LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        void client.start();
        await assert.rejects(async () => {
            await client.stop();
        }, /Client is not running and can't be stopped/);
        await client._start();
        await client.stop();
    });
    test('Test state change events', async () => {
        const serverOptions = {
            module: path_1.default.join(__dirname, './server/nullServer.js'),
            transport: index_1.TransportKind.ipc,
        };
        const clientOptions = {};
        const client = new index_1.LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        let state;
        client.onDidChangeState(event => {
            state = event.newState;
        });
        await client._start();
        assert.strictEqual(state, index_1.State.Running, 'First start');
        await client.stop();
        assert.strictEqual(state, index_1.State.Stopped, 'First stop');
        await client._start();
        assert.strictEqual(state, index_1.State.Running, 'Second start');
        await client.stop();
        assert.strictEqual(state, index_1.State.Stopped, 'Second stop');
    });
    test('Test state change events on crash', async () => {
        const serverOptions = {
            module: path_1.default.join(__dirname, './server/crashServer.js'),
            transport: index_1.TransportKind.ipc,
        };
        const clientOptions = {};
        const client = new CrashClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        let states = [];
        client.onDidChangeState(event => {
            states.push(event.newState);
        });
        await client._start();
        assert.strictEqual(states.length, 2, 'First start');
        assert.strictEqual(states[0], index_1.State.Starting);
        assert.strictEqual(states[1], index_1.State.Running);
        states = [];
        await client.sendNotification(CrashNotification.type);
        await client.onCrash;
        await client._start();
        assert.strictEqual(states.length, 3, 'Restart after crash');
        assert.strictEqual(states[0], index_1.State.Stopped);
        assert.strictEqual(states[1], index_1.State.Starting);
        assert.strictEqual(states[2], index_1.State.Running);
        states = [];
        await client.stop();
        assert.strictEqual(states.length, 1, 'After stop');
        assert.strictEqual(states[0], index_1.State.Stopped);
    });
});
describe('Server activation', () => {
    const uri = vscode_uri_1.URI.parse('lsptests://localhost/test.bat');
    const documentSelector = [{ scheme: 'lsptests', language: '*' }];
    const position = vscode_languageserver_protocol_1.Position.create(1, 1);
    let contentProviderDisposable;
    beforeAll(async () => {
        contentProviderDisposable = workspace_1.default.registerTextDocumentContentProvider('lsptests', {
            provideTextDocumentContent: (_uri) => {
                return [
                    'REM @ECHO OFF'
                ].join('\n');
            }
        });
    });
    afterAll(async () => {
        contentProviderDisposable.dispose();
    });
    function createClient() {
        const serverModule = path_1.default.join(__dirname, './server/customServer.js');
        const serverOptions = {
            run: { module: serverModule, transport: index_1.TransportKind.ipc },
            debug: { module: serverModule, transport: index_1.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }
        };
        const clientOptions = {
            documentSelector,
            synchronize: {},
            initializationOptions: {},
            middleware: {},
        };
        clientOptions.$testMode = true;
        const result = new index_1.LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions);
        result.registerProposedFeatures();
        return result;
    }
    test('Start server on request', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        const result = await client.sendRequest('request', { value: 10 });
        assert.strictEqual(client.state, index_1.State.Running);
        assert.strictEqual(result, 11);
        await client.stop();
    });
    test('Start server fails on request when stopped once', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        const result = await client.sendRequest('request', { value: 10 });
        assert.strictEqual(client.state, index_1.State.Running);
        assert.strictEqual(result, 11);
        await client.stop();
        await assert.rejects(async () => {
            await client.sendRequest('request', { value: 10 });
        }, /Client is not running/);
    });
    test('Start server on notification', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        await client.sendNotification('notification');
        assert.strictEqual(client.state, index_1.State.Running);
        await client.stop();
    });
    test('Not fails on notification when stopped once', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        await client.sendNotification('notification');
        assert.strictEqual(client.state, index_1.State.Running);
        await client.stop();
        await client.sendNotification('notification');
    });
    test('Add pending request handler', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        let requestReceived = false;
        client.onRequest('request', () => {
            requestReceived = true;
        });
        await client.sendRequest('triggerRequest');
        assert.strictEqual(requestReceived, true);
        await client.stop();
    });
    test('Add pending notification handler', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        let notificationReceived = false;
        client.onNotification('notification', () => {
            notificationReceived = true;
        });
        await client.sendRequest('triggerNotification');
        assert.strictEqual(notificationReceived, true);
        await client.stop();
    });
    test('Starting disposed server fails', async () => {
        const client = createClient();
        await client._start();
        await client.dispose();
        await assert.rejects(async () => {
            await client._start();
        }, /Client got disposed and can't be restarted./);
    });
    async function checkServerStart(client, disposable) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error(`Server didn't start in 1000 ms.`));
            }, 1000);
            client.onDidChangeState(event => {
                if (event.newState === index_1.State.Running) {
                    clearTimeout(timeout);
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    test('Start server on document open', async () => {
        await workspace_1.default.nvim.command('silent! %bwipeout!');
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        const started = checkServerStart(client, workspace_1.default.onDidOpenTextDocument(document => {
            if (workspace_1.default.match([{ scheme: 'lsptests', pattern: uri.fsPath }], document) > 0) {
                void client.start();
            }
        }));
        await workspace_1.default.openTextDocument(uri);
        await started;
        await client.stop();
    });
    test('Start server on language feature', async () => {
        const client = createClient();
        assert.strictEqual(client.state, index_1.State.Stopped);
        const started = checkServerStart(client, languages_1.default.registerDeclarationProvider(documentSelector, {
            provideDeclaration: async () => {
                await client._start();
                return undefined;
            }
        }));
        await workspace_1.default.openTextDocument(uri);
        await helper_1.default.doAction('declarations');
        await started;
        await client.stop();
    });
});
//# sourceMappingURL=features.test.js.map