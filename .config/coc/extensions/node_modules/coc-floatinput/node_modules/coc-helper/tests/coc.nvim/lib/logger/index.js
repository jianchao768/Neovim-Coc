'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogger = exports.getLoggerFile = exports.logger = exports.emptyFile = exports.resolveLogFilepath = exports.getTimestamp = void 0;
const log_1 = require("./log");
const node_1 = require("../util/node");
const util_1 = require("../util");
var log_2 = require("./log");
Object.defineProperty(exports, "getTimestamp", { enumerable: true, get: function () { return log_2.getTimestamp; } });
function resolveLogFilepath() {
    let file = process.env.NVIM_COC_LOG_FILE;
    if (file)
        return file;
    let dir = process.env.XDG_RUNTIME_DIR;
    if (dir) {
        try {
            node_1.fs.accessSync(dir, node_1.fs.constants.R_OK | node_1.fs.constants.W_OK);
            return node_1.path.join(dir, `coc-nvim-${process.pid}.log`);
        }
        catch (err) {
            // noop
        }
    }
    let tmpdir = node_1.os.tmpdir();
    dir = node_1.path.join(tmpdir, `coc.nvim-${process.pid}`);
    node_1.fs.mkdirSync(dir, { recursive: true });
    return node_1.path.join(dir, `coc-nvim.log`);
}
exports.resolveLogFilepath = resolveLogFilepath;
function emptyFile(filepath) {
    if (node_1.fs.existsSync(filepath)) {
        // cleanup if exists
        try {
            node_1.fs.writeFileSync(filepath, '', { encoding: 'utf8', mode: 0o666 });
        }
        catch (e) {
            // noop
        }
    }
}
exports.emptyFile = emptyFile;
const logfile = resolveLogFilepath();
emptyFile(logfile);
const level = (0, util_1.getConditionValue)(process.env.NVIM_COC_LOG_LEVEL || 'info', 'off');
exports.logger = new log_1.FileLogger(logfile, (0, log_1.textToLogLevel)(level), {
    color: !global.REVISION && process.platform !== 'win32',
    userFormatters: true
});
function getLoggerFile() {
    return logfile;
}
exports.getLoggerFile = getLoggerFile;
function createLogger(category = 'coc.nvim') {
    return exports.logger.createLogger(category);
}
exports.createLogger = createLogger;
//# sourceMappingURL=index.js.map