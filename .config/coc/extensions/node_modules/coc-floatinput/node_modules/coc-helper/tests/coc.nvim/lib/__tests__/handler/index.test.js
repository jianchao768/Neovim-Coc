"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = require("../../languages");
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let handler;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    handler = helper_1.default.plugin.handler;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    await helper_1.default.createDocument();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('Handler', () => {
    describe('hasProvider', () => {
        it('should check provider for document', async () => {
            let res = await helper_1.default.doAction('hasProvider', 'definition');
            expect(res).toBe(false);
        });
    });
    describe('commands', () => {
        it('should open url', async () => {
            let fn = jest.fn();
            let spy = jest.spyOn(nvim, 'call').mockImplementation(() => {
                fn();
                return null;
            });
            await commands_1.default.executeCommand('vscode.open', 'http://www.example.com');
            spy.mockRestore();
            expect(fn).toBeCalled();
        });
        it('should restart', async () => {
            let fn = jest.fn();
            let spy = jest.spyOn(nvim, 'command').mockImplementation(() => {
                fn();
                return null;
            });
            await commands_1.default.executeCommand('workbench.action.reloadWindow');
            spy.mockRestore();
            expect(fn).toBeCalled();
        });
    });
    describe('checkProvier', () => {
        it('should throw error when provider not found', async () => {
            let doc = await helper_1.default.createDocument();
            let err;
            try {
                handler.checkProvider(languages_1.ProviderName.Definition, doc.textDocument);
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeDefined();
        });
    });
    describe('withRequestToken', () => {
        it('should cancel previous request when called again', async () => {
            let cancelled = false;
            let p = handler.withRequestToken('test', token => {
                return new Promise(s => {
                    token.onCancellationRequested(() => {
                        cancelled = true;
                        clearTimeout(timer);
                        s(undefined);
                    });
                    let timer = setTimeout(() => {
                        s(undefined);
                    }, 3000);
                });
            }, false);
            setTimeout(async () => {
                await handler.withRequestToken('test', () => {
                    return Promise.resolve(undefined);
                }, false);
            }, 50);
            await p;
            expect(cancelled).toBe(true);
        });
        it('should cancel request on insert start', async () => {
            let cancelled = false;
            let p = handler.withRequestToken('test', token => {
                return new Promise(s => {
                    token.onCancellationRequested(() => {
                        cancelled = true;
                        clearTimeout(timer);
                        s(undefined);
                    });
                    let timer = setTimeout(() => {
                        s(undefined);
                    }, 3000);
                });
            }, false);
            await nvim.input('i');
            await p;
            expect(cancelled).toBe(true);
        });
    });
});
//# sourceMappingURL=index.test.js.map