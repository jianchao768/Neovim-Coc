'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.surrondChanges = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger_1 = require("../logger");
const util_1 = require("../util");
const node_1 = require("../util/node");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const textedit_1 = require("../util/textedit");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const textRange_1 = tslib_1.__importDefault(require("./textRange"));
const util_2 = require("./util");
const logger = (0, logger_1.createLogger)('cursors-session');
/**
 * Cursor session for single buffer
 */
class CursorSession {
    constructor(nvim, doc, config) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this._onDidCancel = new protocol_1.Emitter();
        this._onDidUpdate = new protocol_1.Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.disposables = [];
        this.ranges = [];
        this.activated = true;
        this.changing = false;
        let { bufnr } = doc;
        doc.buffer.setVar('coc_cursors_activated', 1, true);
        let { cancelKey, nextKey, previousKey } = this.config;
        this.disposables.push(workspace_1.default.registerLocalKeymap(bufnr, 'n', cancelKey, () => {
            this.cancel();
        }));
        this.disposables.push(workspace_1.default.registerLocalKeymap(bufnr, 'n', nextKey, async () => {
            let ranges = this.ranges.map(o => o.range);
            let curr = await window_1.default.getCursorPosition();
            for (let r of ranges) {
                if ((0, position_1.comparePosition)(r.start, curr) > 0) {
                    await window_1.default.moveTo(r.start);
                    return;
                }
            }
            let wrap = this.config.wrapscan;
            if (ranges.length && wrap)
                await window_1.default.moveTo(ranges[0].start);
        }));
        this.disposables.push(workspace_1.default.registerLocalKeymap(bufnr, 'n', previousKey, async () => {
            let ranges = this.ranges.map(o => o.range);
            let curr = await window_1.default.getCursorPosition();
            for (let i = ranges.length - 1; i >= 0; i--) {
                let r = ranges[i];
                if ((0, position_1.comparePosition)(r.end, curr) < 0) {
                    await window_1.default.moveTo(r.start);
                    return;
                }
            }
            let wrap = this.config.wrapscan;
            if (ranges.length && wrap)
                await window_1.default.moveTo(ranges[ranges.length - 1].start);
        }));
        this.doc.onDocumentChange(async (e) => {
            await this.onChange(e);
            if (this.activated && !this.changing) {
                this._onDidUpdate.fire();
            }
        }, this, this.disposables);
    }
    /**
     * Add or remove range.
     */
    addRange(range) {
        let { ranges } = this;
        let idx = ranges.findIndex(o => (0, position_1.rangeIntersect)(o.range, range));
        // remove range when intersect
        if (idx !== -1) {
            ranges.splice(idx, 1);
        }
        else {
            this.createRange(range);
            ranges.sort((a, b) => (0, position_1.comparePosition)(a.range.start, b.range.start));
        }
        if (this.ranges.length == 0) {
            this.cancel();
        }
        else {
            this.doHighlights();
        }
    }
    addRanges(ranges) {
        this.doc._forceSync();
        // filter overlap ranges
        this.ranges = this.ranges.filter(r => {
            return !ranges.some(range => (0, position_1.rangeOverlap)(range, r.range));
        });
        for (let range of ranges) {
            this.createRange(range);
        }
        this.ranges.sort((a, b) => (0, position_1.comparePosition)(a.range.start, b.range.start));
        this.doHighlights();
        return true;
    }
    createRange(range) {
        let { textDocument } = this.doc;
        let { line, character } = range.start;
        let text = textDocument.getText(range);
        this.ranges.push(new textRange_1.default(line, character, text));
    }
    async onChange(e) {
        if (!this.activated || this.changing)
            return;
        if (e.contentChanges.length === 0) {
            this.doHighlights();
            return;
        }
        let change = e.contentChanges[0];
        let { text, range } = change;
        let affected = this.ranges.filter(r => {
            if (!(0, position_1.rangeIntersect)(range, r.range))
                return false;
            if ((0, position_1.rangeAdjacent)(range, r.range)) {
                if (text.includes('\n') || !(0, position_1.emptyRange)(range))
                    return false;
            }
            return true;
        });
        if ((0, position_1.emptyRange)(range) && affected.length > 0) {
            affected = affected.slice(0, 1);
        }
        if (affected.length == 0) {
            logger.debug('no affected ranges');
            this.ranges.forEach(r => {
                r.adjustFromEdit({ range, newText: text });
            });
            this.doHighlights();
        }
        else if (affected.length == 1 && (0, position_1.rangeInRange)(range, affected[0].range)) {
            logger.debug('affected single range');
            if (text.includes('\n')) {
                this.cancel();
                return;
            }
            // change textRange
            await this.applySingleEdit(affected[0], { range, newText: text });
        }
        else if (!text.length || !this.validChange(range, text)) {
            logger.debug('filter affected ranges.');
            let ranges = this.ranges.filter(r => !affected.includes(r));
            if (ranges.length > 0) {
                this.ranges = ranges;
                ranges.forEach(r => {
                    r.adjustFromEdit({ range, newText: text });
                });
                this.doHighlights();
            }
            else {
                this.cancel();
            }
        }
        else {
            logger.debug('Check undo & redo');
            let first = this.ranges[0];
            let last = this.ranges[this.ranges.length - 1];
            let originalLines = e.originalLines.slice(first.line, last.line + 1);
            let newLines = this.doc.textDocument.lines.slice(first.line, last.line + 1);
            this.applyComposedEdit(originalLines, newLines);
        }
    }
    validChange(range, text) {
        if ((0, textedit_1.lineCountChange)(vscode_languageserver_types_1.TextEdit.replace(range, text)) != 0)
            return false;
        if (!(0, position_1.rangeInRange)(range, this.range))
            return false;
        let first = this.ranges[0];
        let last = this.ranges[this.ranges.length - 1];
        if (range.start.line != first.position.line || range.end.line != last.position.line)
            return false;
        return true;
    }
    get range() {
        let first = this.ranges[0];
        let last = this.ranges[this.ranges.length - 1];
        return vscode_languageserver_types_1.Range.create(first.position, last.range.end);
    }
    doHighlights() {
        let { nvim, ranges, doc } = this;
        let buffer = doc.buffer;
        let items = [];
        ranges.forEach(r => {
            doc.addHighlights(items, 'CocCursorRange', r.range, {
                combine: false,
                start_incl: true,
                end_incl: true
            });
        });
        items.sort((a, b) => {
            if (a.lnum != b.lnum)
                return a.lnum - b.lnum;
            if (a.colStart != b.colStart)
                return a.colStart - b.colStart;
            return 0;
        });
        buffer.updateHighlights('cursors', items, { priority: 4096 });
        nvim.redrawVim();
    }
    get currentRanges() {
        return this.ranges.map(r => r.range);
    }
    /**
     * Cancel session and highlights
     */
    cancel() {
        if (!this.activated)
            return;
        logger.debug('cursors cancel');
        let buffer = this.doc.buffer;
        this.activated = false;
        this.ranges = [];
        buffer.clearNamespace('cursors');
        buffer.setVar('coc_cursors_activated', 0, true);
        this._onDidUpdate.fire();
        this._onDidCancel.fire();
    }
    /**
     * Called on buffer unload or cancel
     */
    dispose() {
        if (!this.doc)
            return;
        this._onDidCancel.dispose();
        this._onDidUpdate.dispose();
        (0, util_1.disposeAll)(this.disposables);
        this.ranges = [];
        this.doc = null;
    }
    async applySingleEdit(textRange, edit) {
        // single range change, calculate & apply changes for all ranges
        let { doc, ranges } = this;
        let after = ranges.filter(r => r !== textRange && r.position.line == textRange.position.line);
        after.forEach(r => r.adjustFromEdit(edit));
        let change = (0, util_2.getChange)(textRange, edit.range, edit.newText);
        let delta = (0, util_2.getDelta)(change);
        ranges.forEach(r => r.applyChange(change));
        let edits = ranges.filter(r => r !== textRange).map(o => o.textEdit);
        // logger.debug('edits:', JSON.stringify(edits, null, 2))
        this.changing = true;
        await doc.applyEdits(edits, true, true);
        this.changing = false;
        if (delta != 0) {
            for (let r of ranges) {
                let n = (0, util_2.getBeforeCount)(r, this.ranges, textRange);
                r.move(n * delta);
            }
        }
        this.doHighlights();
    }
    applyComposedEdit(originalLines, newLines) {
        var _a, _b, _c;
        // check complex edit
        let diffs = (0, node_1.fastDiff)(originalLines[0], newLines[0]);
        let first = this.ranges[0];
        // let ranges = this.ranges.filter(o => o.line == first.line)
        let s = first.position.character;
        let firstLine = first.position.line;
        let len = first.text.length;
        let diff = diffs[0];
        if (s > 0 && (diff[0] != node_1.fastDiff.EQUAL || !diff[1].startsWith(originalLines[0].slice(0, s)))) {
            this.cancel();
            return false;
        }
        let used = 0;
        let invalid = false;
        let changes = [];
        for (let i = 0; i < diffs.length; i++) {
            let [kind, text] = diffs[i];
            if (i == 0 && s > 0) {
                text = text.slice(s);
            }
            if (kind == node_1.fastDiff.EQUAL) {
                used += text.length;
                if (used > len)
                    break;
            }
            else if (kind == node_1.fastDiff.DELETE) {
                let offset = used;
                used += text.length;
                if (used > len) {
                    invalid = true;
                    break;
                }
                changes.push({ offset, remove: text });
            }
            else {
                let prev = diffs[i - 1];
                if (prev && prev[0] == node_1.fastDiff.DELETE) {
                    changes[changes.length - 1].add = text;
                }
                else {
                    changes.push({ offset: used, add: text });
                }
            }
        }
        if (invalid || !changes.length) {
            this.cancel();
            return false;
        }
        let doc = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', '', 0, originalLines.join('\n'));
        let change;
        if (changes.length == 1) {
            change = {
                offset: changes[0].offset,
                remove: changes[0].remove ? changes[0].remove.length : 0,
                insert: (_a = changes[0].add) !== null && _a !== void 0 ? _a : ''
            };
        }
        else if (surrondChanges(changes, len)) {
            change = {
                prepend: [changes[0].remove ? changes[0].remove.length : 0, (_b = changes[0].add) !== null && _b !== void 0 ? _b : ''],
                append: [changes[1].remove ? changes[1].remove.length : 0, (_c = changes[1].add) !== null && _c !== void 0 ? _c : '']
            };
        }
        else {
            let text = first.text;
            let oldText = '';
            let newText = '';
            let offset = changes[0].offset;
            for (let c of changes) {
                if (c.offset > offset + oldText.length) {
                    let s = text.slice(offset + oldText.length, c.offset);
                    oldText += s;
                    newText += s;
                }
                if (c.add) {
                    newText += c.add;
                }
                if (c.remove) {
                    oldText += c.remove;
                }
            }
            change = {
                offset,
                remove: oldText.length,
                insert: newText
            };
        }
        let edits = this.ranges.map(o => {
            let line = o.position.line - firstLine;
            let { start, end } = o.range;
            let range = vscode_languageserver_types_1.Range.create(line, start.character, line, end.character);
            o.applyChange(change);
            return vscode_languageserver_types_1.TextEdit.replace(range, o.text);
        });
        let content = vscode_languageserver_textdocument_1.TextDocument.applyEdits(doc, edits);
        if (content !== newLines.join('\n')) {
            this.cancel();
            return false;
        }
        let delta = (0, util_2.getDelta)(change);
        if (delta != 0) {
            for (let r of this.ranges) {
                let n = (0, util_2.getBeforeCount)(r, this.ranges);
                r.move(n * delta);
            }
        }
        this.doHighlights();
        return true;
    }
}
exports.default = CursorSession;
function surrondChanges(changes, len) {
    if (changes.length != 2 || changes[0].offset != 0)
        return false;
    let end = changes[1].offset + (changes[1].remove ? changes[1].remove.length : 0);
    if (end !== len)
        return false;
    return true;
}
exports.surrondChanges = surrondChanges;
//# sourceMappingURL=session.js.map