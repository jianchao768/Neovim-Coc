'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const logger_1 = require("../../logger");
const util_1 = require("../../util");
const node_1 = require("../../util/node");
const protocol_1 = require("../../util/protocol");
const util_2 = require("../util");
const logger = (0, logger_1.createLogger)('symbols-buffer');
const DEBEBOUNCE_INTERVAL = (0, util_1.getConditionValue)(500, 10);
class SymbolsBuffer {
    constructor(doc, autoUpdateBufnrs) {
        this.doc = doc;
        this.autoUpdateBufnrs = autoUpdateBufnrs;
        this.disposables = [];
        this._onDidUpdate = new protocol_1.Emitter();
        this.onDidUpdate = this._onDidUpdate.event;
        this.fetchSymbols = (0, node_1.debounce)(() => {
            this._fetchSymbols().catch(util_2.handleError);
        }, DEBEBOUNCE_INTERVAL);
    }
    /**
     * Enable autoUpdate when invoked.
     */
    async getSymbols() {
        var _a;
        let { doc } = this;
        await doc.patchChange();
        this.autoUpdateBufnrs.add(doc.bufnr);
        // refresh for empty symbols since some languages server could be buggy first time.
        if (doc.version == this.version && ((_a = this.symbols) === null || _a === void 0 ? void 0 : _a.length))
            return this.symbols;
        this.cancel();
        await this._fetchSymbols();
        return this.symbols;
    }
    onChange(e) {
        if (e.contentChanges.length === 0)
            return;
        this.cancel();
        if (this.autoUpdateBufnrs.has(this.doc.bufnr)) {
            this.fetchSymbols();
        }
    }
    async _fetchSymbols() {
        let { textDocument } = this.doc;
        let { version } = textDocument;
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        let { token } = tokenSource;
        let symbols = await languages_1.default.getDocumentSymbol(textDocument, token);
        this.tokenSource = undefined;
        if (symbols == null || token.isCancellationRequested)
            return;
        this.version = version;
        this.symbols = symbols;
        this._onDidUpdate.fire(symbols);
    }
    cancel() {
        this.fetchSymbols.clear();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource.dispose();
            this.tokenSource = null;
        }
    }
    dispose() {
        this.cancel();
        this.symbols = undefined;
        this._onDidUpdate.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = SymbolsBuffer;
//# sourceMappingURL=buffer.js.map