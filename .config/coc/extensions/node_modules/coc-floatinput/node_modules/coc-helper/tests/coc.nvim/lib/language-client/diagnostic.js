'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticFeature = exports.BackgroundScheduler = exports.DiagnosticRequestor = exports.DocumentPullStateTracker = exports.PullState = exports.DiagnosticPullMode = void 0;
const tslib_1 = require("tslib");
const node_1 = require("../util/node");
const uuid_1 = require("uuid");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const errors_1 = require("../util/errors");
const map_1 = require("../util/map");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const features_1 = require("./features");
const util_1 = require("../util");
var DiagnosticPullMode;
(function (DiagnosticPullMode) {
    DiagnosticPullMode["onType"] = "onType";
    DiagnosticPullMode["onSave"] = "onSave";
})(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
var RequestStateKind;
(function (RequestStateKind) {
    RequestStateKind["active"] = "open";
    RequestStateKind["reschedule"] = "reschedule";
    RequestStateKind["outDated"] = "drop";
})(RequestStateKind || (RequestStateKind = {}));
var PullState;
(function (PullState) {
    PullState[PullState["document"] = 1] = "document";
    PullState[PullState["workspace"] = 2] = "workspace";
})(PullState = exports.PullState || (exports.PullState = {}));
const pullDebounce = (0, util_1.getConditionValue)(3000, 10);
class DocumentPullStateTracker {
    constructor() {
        this.documentPullStates = new Map();
        this.workspacePullStates = new Map();
    }
    track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document instanceof vscode_uri_1.URI
            ? [document.toString(), document, arg1]
            : [document.uri.toString(), vscode_uri_1.URI.parse(document.uri), document.version];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId: undefined };
            states.set(key, state);
        }
        return state;
    }
    update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document instanceof vscode_uri_1.URI
            ? [document.toString(), document, arg1, arg2]
            : [document.uri, vscode_uri_1.URI.parse(document.uri), document.version, arg1];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId };
            states.set(key, state);
        }
        else {
            state.pulledVersion = version;
            state.resultId = resultId;
        }
    }
    unTrack(kind, document) {
        const key = document instanceof vscode_uri_1.URI ? document.toString() : document.uri;
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
    }
    tracks(kind, document) {
        const key = document instanceof vscode_uri_1.URI ? document.toString() : document.uri;
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
    }
    trackingDocuments() {
        return Array.from(this.documentPullStates.keys());
    }
    getResultId(kind, document) {
        var _a;
        const key = document instanceof vscode_uri_1.URI ? document.toString() : document.uri;
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return (_a = states.get(key)) === null || _a === void 0 ? void 0 : _a.resultId;
    }
    getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
                value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== undefined) {
                result.push({ uri, value: value.resultId });
            }
        }
        return result;
    }
}
exports.DocumentPullStateTracker = DocumentPullStateTracker;
class DiagnosticRequestor extends features_1.BaseFeature {
    constructor(client, options) {
        var _a;
        super(client);
        this.client = client;
        this.options = options;
        this.enableWorkspace = options.workspaceDiagnostics && ((_a = this.client.clientOptions.diagnosticPullOptions) === null || _a === void 0 ? void 0 : _a.workspace) !== false;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new protocol_1.Emitter();
        this.provider = this.createProvider();
        this.diagnostics = languages_1.default.createDiagnosticCollection(options.identifier ? options.identifier : client.id);
        this.openRequests = new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
    }
    knows(kind, textDocument) {
        return this.documentStates.tracks(kind, textDocument);
    }
    trackingDocuments() {
        return this.documentStates.trackingDocuments();
    }
    forget(kind, document) {
        this.documentStates.unTrack(kind, document);
    }
    pull(document, cb) {
        this.pullAsync(document).then(() => {
            if (cb) {
                cb();
            }
        }, error => {
            this.client.error(`Document pull failed for text document ${document.uri}`, error);
        });
    }
    async pullAsync(document) {
        var _a;
        if (this.isDisposed)
            return;
        const uri = document.uri;
        const version = document.version;
        const currentRequestState = this.openRequests.get(uri);
        const documentState = this.documentStates.track(PullState.document, document);
        if (currentRequestState === undefined) {
            const tokenSource = new protocol_1.CancellationTokenSource();
            this.openRequests.set(uri, { state: RequestStateKind.active, document, version, tokenSource });
            let report;
            let afterState;
            try {
                report = (_a = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token)) !== null && _a !== void 0 ? _a : { kind: protocol_1.DocumentDiagnosticReportKind.Full, items: [] };
            }
            catch (error) {
                if (error instanceof features_1.LSPCancellationError && error.data && protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                    afterState = { state: RequestStateKind.outDated, document };
                }
                if (afterState === undefined && error instanceof errors_1.CancellationError) {
                    afterState = { state: RequestStateKind.reschedule, document };
                }
                else {
                    throw error;
                }
            }
            afterState = afterState !== null && afterState !== void 0 ? afterState : this.openRequests.get(uri);
            if (afterState === undefined) {
                // This shouldn't happen. Log it
                this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${uri}`);
                this.diagnostics.delete(uri);
                return;
            }
            this.openRequests.delete(uri);
            const visible = window_1.default.visibleTextEditors.some(editor => editor.document.uri === uri);
            if (!visible) {
                this.documentStates.unTrack(PullState.document, document);
                return;
            }
            if (afterState.state === RequestStateKind.outDated)
                return;
            // report is only undefined if the request has thrown.
            if (report !== undefined) {
                if (report.kind === protocol_1.DocumentDiagnosticReportKind.Full) {
                    this.diagnostics.set(uri, report.items);
                }
                documentState.pulledVersion = version;
                documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
                this.pull(document);
            }
        }
        else {
            if (currentRequestState.state === RequestStateKind.active) {
                // Cancel the current request and reschedule a new one when the old one returned.
                currentRequestState.tokenSource.cancel();
                this.openRequests.set(uri, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
            else if (currentRequestState.state === RequestStateKind.outDated) {
                this.openRequests.set(uri, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
        }
    }
    forgetDocument(document) {
        const uri = document.uri;
        const request = this.openRequests.get(uri);
        if (this.enableWorkspace) {
            // If we run workspace diagnostic pull a last time for the diagnostics
            // and the rely on getting them from the workspace result.
            if (request !== undefined) {
                this.openRequests.set(uri, { state: RequestStateKind.reschedule, document });
            }
            else {
                this.pull(document, () => {
                    this.forget(PullState.document, document);
                });
            }
        }
        else {
            // We have normal pull or inter file dependencies. In this case we
            // clear the diagnostics (to have the same start as after startup).
            // We also cancel outstanding requests.
            if (request !== undefined) {
                if (request.state === RequestStateKind.active) {
                    request.tokenSource.cancel();
                }
                this.openRequests.delete(uri);
            }
            this.diagnostics.delete(uri.toString());
            this.forget(PullState.document, document);
        }
    }
    pullWorkspace() {
        if (!this.enableWorkspace)
            return;
        this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = (0, protocol_1.RAL)().timer.setTimeout(() => {
                this.pullWorkspace();
            }, pullDebounce);
        }, error => {
            if (!(error instanceof features_1.LSPCancellationError) && !protocol_1.DiagnosticServerCancellationData.is(error.data)) {
                this.client.error(`Workspace diagnostic pull failed.`, error);
                this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
                this.workspaceTimeout = (0, protocol_1.RAL)().timer.setTimeout(() => {
                    this.pullWorkspace();
                }, pullDebounce);
            }
        });
    }
    async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics) {
            return;
        }
        if (this.workspaceCancellation !== undefined) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = undefined;
        }
        this.workspaceCancellation = new protocol_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds();
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, chunk => {
            var _a;
            if (!chunk || this.isDisposed) {
                return;
            }
            for (const item of chunk.items) {
                if (item.kind === protocol_1.DocumentDiagnosticReportKind.Full) {
                    // Favour document pull result over workspace results. So skip if it is tracked
                    // as a document result.
                    if (!this.documentStates.tracks(PullState.document, vscode_uri_1.URI.parse(item.uri))) {
                        this.diagnostics.set(item.uri.toString(), item.items);
                    }
                }
                this.documentStates.update(PullState.workspace, vscode_uri_1.URI.parse(item.uri), (_a = item.version) !== null && _a !== void 0 ? _a : undefined, item.resultId);
            }
        });
    }
    createProvider() {
        const provider = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (document, previousResultId, token) => {
                const middleware = this.client.middleware;
                const provideDiagnostics = (document, previousResultId, token) => {
                    const uri = document instanceof vscode_uri_1.URI ? document.toString() : document.uri;
                    const params = {
                        identifier: this.options.identifier,
                        textDocument: { uri },
                        previousResultId
                    };
                    return this.sendRequest(protocol_1.DocumentDiagnosticRequest.type, params, token, { kind: protocol_1.DocumentDiagnosticReportKind.Full, items: [] }).then(async (result) => {
                        if (result === undefined || result === null || this.isDisposed) {
                            return { kind: protocol_1.DocumentDiagnosticReportKind.Full, items: [] };
                        }
                        // make handleDiagnostics middleware works
                        if (middleware.handleDiagnostics && result.kind == protocol_1.DocumentDiagnosticReportKind.Full) {
                            middleware.handleDiagnostics(uri, result.items, (_, diagnostics) => {
                                result.items = diagnostics;
                            });
                        }
                        return result;
                    });
                };
                return middleware.provideDiagnostics
                    ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics)
                    : provideDiagnostics(document, previousResultId, token);
            }
        };
        if (this.options.workspaceDiagnostics) {
            provider.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
                const provideWorkspaceDiagnostics = (resultIds, token) => {
                    const partialResultToken = (0, uuid_1.v4)();
                    const disposable = this.client.onProgress(protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, partialResult => {
                        if (partialResult == undefined) {
                            resultReporter(null);
                            return;
                        }
                        resultReporter(partialResult);
                    });
                    const params = {
                        identifier: this.options.identifier,
                        previousResultIds: resultIds,
                        partialResultToken
                    };
                    return this.sendRequest(protocol_1.WorkspaceDiagnosticRequest.type, params, token, { items: [] }).then(async (result) => {
                        resultReporter(result);
                        return { items: [] };
                    }).finally(() => {
                        disposable.dispose();
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideWorkspaceDiagnostics
                    ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideWorkspaceDiagnostics)
                    : provideWorkspaceDiagnostics(resultIds, token, resultReporter);
            };
        }
        return provider;
    }
    dispose() {
        var _a, _b;
        this.isDisposed = true;
        // Cancel and clear workspace pull if present.
        (_a = this.workspaceCancellation) === null || _a === void 0 ? void 0 : _a.cancel();
        (_b = this.workspaceTimeout) === null || _b === void 0 ? void 0 : _b.dispose();
        // Cancel all request and mark open requests as outdated.
        for (const request of this.openRequests.values()) {
            if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
            }
        }
        this.openRequests.clear();
    }
}
exports.DiagnosticRequestor = DiagnosticRequestor;
class BackgroundScheduler {
    constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new map_1.LinkedMap();
    }
    add(document) {
        const key = document.uri;
        if (this.documents.has(key))
            return;
        this.documents.set(key, document, 2 /* Touch.AsNew */);
        this.trigger();
    }
    remove(document) {
        var _a;
        const key = document.uri;
        if (this.documents.has(key)) {
            this.documents.delete(key);
            // Do a last pull
            this.diagnosticRequestor.pull(document);
        }
        // No more documents. Stop background activity.
        if (this.documents.size === 0) {
            this.stop();
        }
        else if (document.uri === ((_a = this.endDocument) === null || _a === void 0 ? void 0 : _a.uri)) {
            // Make sure we have a correct last document. It could have
            this.endDocument = this.documents.last;
        }
    }
    trigger() {
        // We have a round running. So simply make sure we run up to the
        // last document
        if (this.intervalHandle !== undefined) {
            this.endDocument = this.documents.last;
            return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, protocol_1.RAL)().timer.setInterval(() => {
            const document = this.documents.first;
            if (document !== undefined) {
                const key = document.uri;
                this.diagnosticRequestor.pull(document);
                this.documents.set(key, document, 2 /* Touch.AsNew */);
                if (document === this.endDocument) {
                    this.stop();
                }
            }
        }, 200);
    }
    dispose() {
        this.stop();
        this.documents.clear();
    }
    stop() {
        var _a;
        (_a = this.intervalHandle) === null || _a === void 0 ? void 0 : _a.dispose();
        this.intervalHandle = undefined;
        this.endDocument = undefined;
    }
}
exports.BackgroundScheduler = BackgroundScheduler;
class DiagnosticFeatureProviderImpl {
    constructor(client, options) {
        var _a, _b;
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions;
        const documentSelector = options.documentSelector;
        const disposables = [];
        const ignored = (_a = diagnosticPullOptions.ignored) !== null && _a !== void 0 ? _a : [];
        const matches = (document) => {
            if (workspace_1.default.match(documentSelector, document) <= 0)
                return false;
            const visible = window_1.default.visibleTextEditors.some(editor => editor.document.uri === document.uri);
            if (!visible)
                return false;
            if (ignored.length > 0 && ignored.some(p => (0, node_1.minimatch)(vscode_uri_1.URI.parse(document.uri).fsPath, p, { dot: true })))
                return false;
            return true;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document) => {
            var _a;
            if (!matches(document) || !options.interFileDependencies || ((_a = this.activeTextDocument) === null || _a === void 0 ? void 0 : _a.uri) === document.uri)
                return;
            this.backgroundScheduler.add(document);
        };
        this.activeTextDocument = (_b = window_1.default.activeTextEditor) === null || _b === void 0 ? void 0 : _b.document.textDocument;
        window_1.default.onDidChangeActiveTextEditor(editor => {
            const oldActive = this.activeTextDocument;
            let textDocument = this.activeTextDocument = editor === null || editor === void 0 ? void 0 : editor.document.textDocument;
            if (oldActive !== undefined) {
                addToBackgroundIfNeeded(oldActive);
            }
            if (textDocument != null)
                this.backgroundScheduler.remove(textDocument);
        }, null, disposables);
        // We always pull on open.
        const openFeature = client.getFeature(protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent(event => {
            const textDocument = event.original;
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
            }
        }));
        const shouldPull = (textDocument, mode) => {
            if (diagnosticPullOptions.filter && diagnosticPullOptions.filter(textDocument, mode))
                return false;
            if (!this.diagnosticRequestor.knows(PullState.document, textDocument))
                return false;
            return true;
        };
        if (diagnosticPullOptions.onChange === true) {
            const changeFeature = client.getFeature(protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
                const textDocument = workspace_1.default.getDocument(event.original.bufnr).textDocument;
                if (event.original.contentChanges.length == 0)
                    return;
                if (shouldPull(textDocument, DiagnosticPullMode.onType)) {
                    this.diagnosticRequestor.pull(textDocument, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        if (diagnosticPullOptions.onSave === true) {
            const saveFeature = client.getFeature(protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent(event => {
                const textDocument = event.original;
                if (shouldPull(textDocument, DiagnosticPullMode.onSave)) {
                    this.diagnosticRequestor.pull(event.original, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        const closeFeature = client.getFeature(protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent(event => {
            this.cleanUpDocument(event.original);
        }));
        // We received a did change from the server.
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of workspace_1.default.textDocuments) {
                if (matches(textDocument)) {
                    this.diagnosticRequestor.pull(textDocument);
                }
            }
        });
        window_1.default.onDidChangeVisibleTextEditors(editors => {
            const handled = new Set();
            const tracking = this.diagnosticRequestor.trackingDocuments();
            editors.forEach(editor => {
                let { uri, textDocument } = editor.document;
                if (handled.has(uri))
                    return;
                handled.add(uri);
                if (matches(textDocument) && !tracking.includes(uri)) {
                    this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
                }
            });
            // cleanUp hidden documents
            tracking.forEach(uri => {
                if (handled.has(uri))
                    return;
                let doc = workspace_1.default.getDocument(uri);
                if (doc && doc.attached)
                    this.cleanUpDocument(doc.textDocument);
            });
        }, null, disposables);
        // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.
        if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {
            this.diagnosticRequestor.pullWorkspace();
        }
        // disposables.push(languages.registerDiagnosticsProvider(options.documentSelector, this.diagnosticRequestor.provider))
        this.disposable = protocol_1.Disposable.create(() => [...disposables, this.backgroundScheduler, this.diagnosticRequestor].forEach(d => d.dispose()));
    }
    get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
    }
    get diagnostics() {
        return this.diagnosticRequestor.provider;
    }
    knows(kind, textDocument) {
        return this.diagnosticRequestor.knows(kind, textDocument);
    }
    cleanUpDocument(document) {
        if (this.diagnosticRequestor.knows(PullState.document, document)) {
            this.diagnosticRequestor.forgetDocument(document);
            this.backgroundScheduler.remove(document);
        }
    }
}
class DiagnosticFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.DocumentDiagnosticRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'diagnostic');
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'diagnostics').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options)
            return;
        client.onRequest(protocol_1.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeDiagnosticsEmitter.fire();
            }
        });
        this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = new DiagnosticFeatureProviderImpl(this._client, options);
        return [provider.disposable, provider];
    }
}
exports.DiagnosticFeature = DiagnosticFeature;
//# sourceMappingURL=diagnostic.js.map