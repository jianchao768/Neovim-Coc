'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dialog = void 0;
const tslib_1 = require("tslib");
const protocol_1 = require("../util/protocol");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const array_1 = require("../util/array");
class Dialog {
    constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._onDidClose = new protocol_1.Emitter();
        this.onDidClose = this._onDidClose.event;
        events_1.default.on('BufWinLeave', bufnr => {
            if (bufnr == this.bufnr) {
                this.dispose();
                if (config.callback)
                    config.callback(-1);
            }
        }, null, this.disposables);
        let btns = (0, array_1.toArray)(config.buttons).filter(o => o.disabled != true);
        events_1.default.on('FloatBtnClick', (bufnr, idx) => {
            if (bufnr == this.bufnr) {
                this.dispose();
                if (config.callback)
                    config.callback(btns[idx].index);
            }
        }, null, this.disposables);
    }
    get lines() {
        return [...this.config.content.split(/\r?\n/)];
    }
    async show(preferences) {
        let { nvim } = this;
        let { title, close, highlights, buttons } = this.config;
        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
        let highlight = this.config.highlight || preferences.floatHighlight;
        let opts = { maxwidth: preferences.maxWidth || 80, };
        if (title)
            opts.title = title;
        if (close || typeof close === 'undefined')
            opts.close = 1;
        if (preferences.maxHeight)
            opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
            opts.maxWidth = preferences.maxWidth;
        if (highlight)
            opts.highlight = highlight;
        if (highlights)
            opts.highlights = highlights;
        if (borderhighlight)
            opts.borderhighlight = [borderhighlight];
        if (buttons)
            opts.buttons = buttons.filter(o => !o.disabled).map(o => o.text);
        if (preferences.rounded)
            opts.rounded = 1;
        if (Array.isArray(opts.buttons))
            opts.getchar = 1;
        let [_winid, bufnr] = await nvim.call('coc#dialog#create_dialog', [this.lines, opts]);
        this.bufnr = bufnr;
        nvim.command('redraw', true);
    }
    get winid() {
        if (!this.bufnr)
            return Promise.resolve(null);
        return this.nvim.call('bufwinid', [this.bufnr]);
    }
    dispose() {
        this._onDidClose.fire();
        this.bufnr = undefined;
        (0, util_1.disposeAll)(this.disposables);
        this.disposables = [];
    }
}
exports.Dialog = Dialog;
//# sourceMappingURL=dialog.js.map