'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
/**
 * Mru - manage string items as lines in mru file.
 */
class Mru {
    /**
     * @param {string} name unique name
     * @param {string} base? optional directory name, default to data root of coc.nvim
     */
    constructor(name, base, maximum = 5000) {
        this.maximum = maximum;
        this.file = node_1.path.join(base || constants_1.dataHome, name);
        let dir = node_1.path.dirname(this.file);
        node_1.fs.mkdirSync(dir, { recursive: true });
    }
    /**
     * Load lines from mru file
     */
    async load() {
        try {
            let lines = await (0, fs_1.readFileLines)(this.file, 0, this.maximum);
            if (lines.length > this.maximum) {
                let newLines = lines.slice(0, this.maximum);
                await (0, fs_1.writeFile)(this.file, newLines.join('\n'));
                return (0, array_1.distinct)(newLines);
            }
            return (0, array_1.distinct)(lines);
        }
        catch (e) {
            return [];
        }
    }
    loadSync() {
        try {
            let content = node_1.fs.readFileSync(this.file, 'utf8');
            content = content.trim();
            return content.length ? content.trim().split('\n') : [];
        }
        catch (e) {
            return [];
        }
    }
    /**
     * Add item to mru file.
     */
    async add(item) {
        let buf;
        try {
            buf = node_1.fs.readFileSync(this.file);
            if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) {
                buf = buf.slice(3);
            }
            buf = Buffer.concat([Buffer.from(item, 'utf8'), new Uint8Array([10]), buf]);
        }
        catch (e) {
            buf = Buffer.concat([Buffer.from(item, 'utf8'), new Uint8Array([10])]);
        }
        await (0, node_1.promisify)(node_1.fs.writeFile)(this.file, buf);
    }
    /**
     * Remove item from mru file.
     */
    async remove(item) {
        let items = await this.load();
        let len = items.length;
        items = items.filter(s => s != item);
        if (items.length != len) {
            await (0, fs_1.writeFile)(this.file, items.join('\n'));
        }
    }
    /**
     * Remove the data file.
     */
    async clean() {
        try {
            await (0, node_1.promisify)(node_1.fs.unlink)(this.file);
        }
        catch (e) {
            // noop
        }
    }
}
exports.default = Mru;
//# sourceMappingURL=mru.js.map