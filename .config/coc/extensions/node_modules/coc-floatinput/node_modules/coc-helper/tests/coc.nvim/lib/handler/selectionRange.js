'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languages_1 = tslib_1.__importStar(require("../languages"));
const object_1 = require("../util/object");
const position_1 = require("../util/position");
const window_1 = tslib_1.__importDefault(require("../window"));
class SelectionRangeHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.selectionRange = null;
    }
    async getSelectionRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.SelectionRange, doc.textDocument);
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken('selection ranges', token => {
            return languages_1.default.getSelectionRanges(doc.textDocument, [position], token);
        });
        return selectionRanges;
    }
    async selectRange(visualmode, forward) {
        var _a;
        let { nvim } = this;
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.SelectionRange, doc.textDocument);
        let positions = [];
        if (!forward && (!this.selectionRange || !visualmode))
            return;
        if (visualmode) {
            let range = await window_1.default.getSelectedRange(visualmode);
            positions.push(range.start, range.end);
        }
        else {
            let position = await window_1.default.getCursorPosition();
            positions.push(position);
        }
        if (!forward) {
            let curr = vscode_languageserver_types_1.Range.create(positions[0], positions[1]);
            let { selectionRange } = this;
            while (selectionRange && selectionRange.parent) {
                if ((0, object_1.equals)(selectionRange.parent.range, curr)) {
                    break;
                }
                selectionRange = selectionRange.parent;
            }
            if (selectionRange && selectionRange.parent) {
                await window_1.default.selectRange(selectionRange.range);
            }
            return;
        }
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken('selection ranges', token => {
            return languages_1.default.getSelectionRanges(doc.textDocument, positions, token);
        });
        if (!selectionRanges || selectionRanges.length == 0)
            return;
        let mode = await nvim.eval('mode()');
        if (mode != 'n')
            await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
        let selectionRange;
        if (selectionRanges.length == 1) {
            selectionRange = selectionRanges[0];
        }
        else {
            let end = (_a = positions[1]) !== null && _a !== void 0 ? _a : positions[0];
            let r = vscode_languageserver_types_1.Range.create(positions[0], end);
            selectionRange = selectionRanges[0];
            while (selectionRange) {
                if ((0, object_1.equals)(r, selectionRange.range)) {
                    selectionRange = selectionRange.parent;
                    continue;
                }
                if ((0, position_1.positionInRange)(positions[0], selectionRange.range) == 0 &&
                    (0, position_1.positionInRange)(end, selectionRange.range) == 0) {
                    break;
                }
                selectionRange = selectionRange.parent;
            }
        }
        if (!selectionRange)
            return;
        this.selectionRange = selectionRanges[0];
        await window_1.default.selectRange(selectionRange.range);
    }
}
exports.default = SelectionRangeHandler;
//# sourceMappingURL=selectionRange.js.map