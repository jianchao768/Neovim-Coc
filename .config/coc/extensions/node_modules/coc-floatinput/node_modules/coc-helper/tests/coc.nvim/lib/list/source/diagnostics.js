'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToLabel = void 0;
const tslib_1 = require("tslib");
const manager_1 = tslib_1.__importDefault(require("../../diagnostic/manager"));
const util_1 = require("../../util");
const fs_1 = require("../../util/fs");
const node_1 = require("../../util/node");
const formatting_1 = require("../formatting");
const location_1 = tslib_1.__importDefault(require("./location"));
function convertToLabel(item, cwd, includeCode, pathFormat = 'full') {
    const file = (0, fs_1.isParentFolder)(cwd, item.file) ? node_1.path.relative(cwd, item.file) : item.file;
    const formattedPath = (0, formatting_1.formatPath)(pathFormat, file);
    const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
    const source = includeCode ? `[${item.source} ${(0, util_1.defaultValue)(item.code, '')}]` : item.source;
    return [...formattedPosition, source, item.severity, item.message];
}
exports.convertToLabel = convertToLabel;
class DiagnosticsList extends location_1.default {
    constructor(manager) {
        super();
        this.defaultAction = 'open';
        this.description = 'diagnostics of current workspace';
        this.name = 'diagnostics';
        manager_1.default.onDidRefresh(async () => {
            let session = manager.getSession('diagnostics');
            if (session)
                await session.reloadItems();
        }, null, this.disposables);
    }
    async loadItems(context) {
        let list = await manager_1.default.getDiagnosticList();
        let { cwd } = context;
        const config = this.getConfig();
        const includeCode = config.get('includeCode', true);
        const pathFormat = config.get('pathFormat', "full");
        const unformatted = list.map(item => {
            return {
                label: convertToLabel(item, cwd, includeCode, pathFormat),
                location: item.location,
            };
        });
        return (0, formatting_1.formatListItems)(this.alignColumns, unformatted);
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine', true);
        nvim.command('highlight default link CocDiagnosticsFile Comment', true);
        nvim.command('highlight default link CocDiagnosticsError CocErrorSign', true);
        nvim.command('highlight default link CocDiagnosticsWarning CocWarningSign', true);
        nvim.command('highlight default link CocDiagnosticsInfo CocInfoSign', true);
        nvim.command('highlight default link CocDiagnosticsHint CocHintSign', true);
        nvim.resumeNotification(false, true);
    }
}
exports.default = DiagnosticsList;
//# sourceMappingURL=diagnostics.js.map