'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const util_1 = require("../../util");
const protocol_1 = require("../../util/protocol");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const buffer_1 = tslib_1.__importDefault(require("./buffer"));
class InlayHintHandler {
    constructor(nvim, handler) {
        this.disposables = [];
        this.buffers = workspace_1.default.registerBufferSync(doc => {
            if (!workspace_1.default.env.virtualText)
                return;
            return new buffer_1.default(nvim, doc);
        });
        this.disposables.push(this.buffers);
        workspace_1.default.onDidChangeConfiguration(e => {
            for (let item of this.buffers.items) {
                if (e.affectsConfiguration('inlayHint', item.doc)) {
                    item.loadConfiguration();
                }
            }
        }, null, this.disposables);
        languages_1.default.onDidInlayHintRefresh(async (e) => {
            for (let item of this.buffers.items) {
                if (workspace_1.default.match(e, item.doc.textDocument)) {
                    item.clearCache();
                    if (languages_1.default.hasProvider(languages_1.ProviderName.InlayHint, item.doc.textDocument)) {
                        item.render();
                    }
                    else {
                        item.clearVirtualText();
                    }
                }
            }
        }, null, this.disposables);
        events_1.default.on('InsertLeave', bufnr => {
            let item = this.buffers.getItem(bufnr);
            if (item)
                item.onInsertLeave();
        }, null, this.disposables);
        events_1.default.on('InsertEnter', bufnr => {
            let item = this.buffers.getItem(bufnr);
            if (item)
                item.onInsertEnter();
        }, null, this.disposables);
        events_1.default.on('CursorMoved', bufnr => {
            this.refresh(bufnr);
        }, null, this.disposables);
        events_1.default.on('WinScrolled', async (winid) => {
            let bufnr = await nvim.call('winbufnr', [winid]);
            if (bufnr != -1)
                this.refresh(bufnr);
        }, null, this.disposables);
        commands_1.default.register({
            id: 'document.toggleInlayHint',
            execute: (bufnr) => {
                return this.toggle(bufnr !== null && bufnr !== void 0 ? bufnr : workspace_1.default.bufnr);
            },
        }, false, 'toggle codeLens display of current buffer');
        handler.addDisposable(protocol_1.Disposable.create(() => {
            (0, util_1.disposeAll)(this.disposables);
        }));
    }
    toggle(bufnr) {
        let item = this.getItem(bufnr);
        try {
            workspace_1.default.getAttachedDocument(bufnr);
            item.toggle();
        }
        catch (e) {
            void window_1.default.showErrorMessage(e.message);
        }
    }
    getItem(bufnr) {
        return this.buffers.getItem(bufnr);
    }
    refresh(bufnr) {
        let buf = this.buffers.getItem(bufnr);
        if (buf)
            buf.render();
    }
}
exports.default = InlayHintHandler;
//# sourceMappingURL=index.js.map