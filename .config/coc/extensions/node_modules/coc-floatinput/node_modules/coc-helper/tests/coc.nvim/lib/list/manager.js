'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfigurationNode = exports.ListManager = void 0;
const tslib_1 = require("tslib");
const registry_1 = require("../configuration/registry");
const types_1 = require("../configuration/types");
const events_1 = tslib_1.__importDefault(require("../events"));
const index_1 = tslib_1.__importDefault(require("../extension/index"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const constants_1 = require("../util/constants");
const extensionRegistry_1 = require("../util/extensionRegistry");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const registry_2 = require("../util/registry");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const configuration_1 = tslib_1.__importDefault(require("./configuration"));
const history_1 = tslib_1.__importDefault(require("./history"));
const mappings_1 = tslib_1.__importDefault(require("./mappings"));
const prompt_1 = tslib_1.__importDefault(require("./prompt"));
const session_1 = tslib_1.__importDefault(require("./session"));
const commands_1 = tslib_1.__importDefault(require("./source/commands"));
const diagnostics_1 = tslib_1.__importDefault(require("./source/diagnostics"));
const extensions_1 = tslib_1.__importDefault(require("./source/extensions"));
const folders_1 = tslib_1.__importDefault(require("./source/folders"));
const links_1 = tslib_1.__importDefault(require("./source/links"));
const lists_1 = tslib_1.__importDefault(require("./source/lists"));
const location_1 = tslib_1.__importDefault(require("./source/location"));
const outline_1 = tslib_1.__importDefault(require("./source/outline"));
const services_1 = tslib_1.__importDefault(require("./source/services"));
const sources_1 = tslib_1.__importDefault(require("./source/sources"));
const symbols_1 = tslib_1.__importDefault(require("./source/symbols"));
const logger = (0, logger_1.createLogger)('list-manager');
const mouseKeys = ['<LeftMouse>', '<LeftDrag>', '<LeftRelease>', '<2-LeftMouse>'];
const winleaveDalay = constants_1.isVim ? 50 : 0;
class ListManager {
    constructor() {
        this.plugTs = 0;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.listMap = new Map();
        history_1.default.migrate(constants_1.dataHome);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    init(nvim) {
        this.prompt = new prompt_1.default(nvim);
        this.mappings = new mappings_1.default(this, nvim);
        let signText = configuration_1.default.get('selectedSignText', '*');
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_1.default.on('InputChar', this.onInputChar, this, this.disposables);
        events_1.default.on('FocusGained', async () => {
            let session = await this.getCurrentSession();
            if (session)
                this.prompt.drawPrompt();
        }, null, this.disposables);
        events_1.default.on('WinEnter', winid => {
            let session = this.getSessionByWinid(winid);
            if (session)
                this.prompt.start(session.listOptions);
        }, null, this.disposables);
        let timer;
        events_1.default.on('WinLeave', winid => {
            clearTimeout(timer);
            let session = this.getSessionByWinid(winid);
            if (session) {
                timer = setTimeout(() => {
                    this.prompt.cancel();
                }, winleaveDalay);
            }
        }, null, this.disposables);
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.source !== types_1.ConfigurationTarget.Default && e.affectsConfiguration('list')) {
                this.mappings.createMappings();
            }
        }, null, this.disposables);
        this.prompt.onDidChangeInput(() => {
            var _a;
            (_a = this.session) === null || _a === void 0 ? void 0 : _a.onInputChange();
        });
    }
    registerLists() {
        this.registerList(new links_1.default(), true);
        this.registerList(new location_1.default(), true);
        this.registerList(new symbols_1.default(), true);
        this.registerList(new outline_1.default(), true);
        this.registerList(new commands_1.default(), true);
        this.registerList(new extensions_1.default(index_1.default.manager), true);
        this.registerList(new diagnostics_1.default(this), true);
        this.registerList(new sources_1.default(), true);
        this.registerList(new services_1.default(), true);
        this.registerList(new lists_1.default(this.listMap), true);
        this.registerList(new folders_1.default(), true);
    }
    async start(args) {
        let res = this.parseArgs(args);
        if (!res)
            return;
        let { name } = res.list;
        let curr = this.sessionsMap.get(name);
        if (curr)
            curr.dispose();
        this.prompt.start(res.options);
        let session = new session_1.default(this.nvim, this.prompt, res.list, res.options, res.listArgs);
        this.sessionsMap.set(name, session);
        this.lastSession = session;
        try {
            await session.start(args);
        }
        catch (e) {
            this.nvim.command(`echo ""`, true);
            this.nvim.call('coc#prompt#stop_prompt', ['list'], true);
            void window_1.default.showErrorMessage(`Error on "CocList ${name}": ${(0, string_1.toErrorText)(e)}`);
            this.nvim.redrawVim();
            logger.error('Error on list start:', e);
        }
    }
    getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
            if (session && session.winid == winid) {
                this.lastSession = session;
                return session;
            }
        }
        return null;
    }
    async getCurrentSession() {
        let { id } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
            if (session && session.winid == id) {
                this.lastSession = session;
                return session;
            }
        }
        return null;
    }
    async resume(name) {
        var _a;
        if (!name) {
            await ((_a = this.session) === null || _a === void 0 ? void 0 : _a.resume());
        }
        else {
            let session = this.sessionsMap.get(name);
            if (!session) {
                void window_1.default.showWarningMessage(`Can't find exists ${name} list`);
                return;
            }
            await session.resume();
        }
    }
    async doAction(name) {
        let lastSession = this.lastSession;
        if (!lastSession)
            return;
        await lastSession.doAction(name);
    }
    async first(name) {
        let s = this.getSession(name);
        if (s)
            await s.first();
    }
    async last(name) {
        let s = this.getSession(name);
        if (s)
            await s.last();
    }
    async previous(name) {
        let s = this.getSession(name);
        if (s)
            await s.previous();
    }
    async next(name) {
        let s = this.getSession(name);
        if (s)
            await s.next();
    }
    getSession(name) {
        if (!name)
            return this.session;
        return this.sessionsMap.get(name);
    }
    async cancel(close = true) {
        this.prompt.cancel();
        if (!close)
            return;
        if (this.session)
            await this.session.hide();
    }
    /**
     * Clear all list sessions
     */
    reset() {
        this.prompt.cancel();
        this.lastSession = undefined;
        for (let session of this.sessionsMap.values()) {
            session.dispose();
        }
        this.sessionsMap.clear();
        this.nvim.call('coc#prompt#stop_prompt', ['list'], true);
    }
    async switchMatcher() {
        var _a;
        await ((_a = this.session) === null || _a === void 0 ? void 0 : _a.switchMatcher());
    }
    async togglePreview() {
        let { nvim } = this;
        let winid = await nvim.call('coc#list#get_preview', [0]);
        if (winid != -1) {
            await nvim.call('coc#list#close_preview', []);
            await nvim.command('redraw');
        }
        else {
            await this.doAction('preview');
        }
    }
    async chooseAction() {
        let { lastSession } = this;
        if (lastSession)
            await lastSession.chooseAction();
    }
    parseArgs(args) {
        let options = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let reverse = false;
        let name;
        let input = '';
        let matcher = 'fuzzy';
        let position = 'bottom';
        let listArgs = [];
        let listOptions = [];
        let height;
        for (let arg of args) {
            if (!name && arg.startsWith('-')) {
                listOptions.push(arg);
            }
            else if (!name) {
                if (!/^\w+$/.test(arg)) {
                    void window_1.default.showErrorMessage(`Invalid list option: "${arg}"`);
                    return null;
                }
                name = arg;
            }
            else {
                listArgs.push(arg);
            }
        }
        name = name || 'lists';
        let config = workspace_1.default.initialConfiguration.get(`list.source.${name}`);
        if (!listOptions.length && !listArgs.length)
            listOptions = (0, util_1.defaultValue)(config === null || config === void 0 ? void 0 : config.defaultOptions, []);
        if (!listArgs.length)
            listArgs = (0, util_1.defaultValue)(config === null || config === void 0 ? void 0 : config.defaultArgs, []);
        for (let opt of listOptions) {
            if (opt.startsWith('--input=')) {
                input = opt.slice(8);
            }
            else if (opt.startsWith('--height=')) {
                height = (0, string_1.toInteger)(opt.slice(9));
            }
            else if (opt == '--number-select' || opt == '-N') {
                numberSelect = true;
            }
            else if (opt == '--auto-preview' || opt == '-A') {
                autoPreview = true;
            }
            else if (opt == '--regex' || opt == '-R') {
                matcher = 'regex';
            }
            else if (opt == '--strict' || opt == '-S') {
                matcher = 'strict';
            }
            else if (opt == '--interactive' || opt == '-I') {
                interactive = true;
            }
            else if (opt == '--top') {
                position = 'top';
            }
            else if (opt == '--tab') {
                position = 'tab';
            }
            else if (opt == '--ignore-case' || opt == '--normal' || opt == '--no-sort') {
                options.push(opt.slice(2));
            }
            else if (opt == '--first') {
                first = true;
            }
            else if (opt == '--reverse') {
                reverse = true;
            }
            else if (opt == '--no-quit') {
                noQuit = true;
            }
            else {
                void window_1.default.showErrorMessage(`Invalid option "${opt}" of list`);
                return null;
            }
        }
        let list = this.listMap.get(name);
        if (!list) {
            void window_1.default.showErrorMessage(`List ${name} not found`);
            return null;
        }
        if (interactive && !list.interactive) {
            void window_1.default.showErrorMessage(`Interactive mode of "${name}" list not supported`);
            return null;
        }
        return {
            list,
            listArgs,
            options: {
                numberSelect,
                autoPreview,
                height,
                reverse,
                noQuit,
                first,
                input,
                interactive,
                matcher,
                position,
                ignorecase: options.includes('ignore-case') ? true : false,
                mode: !options.includes('normal') ? 'insert' : 'normal',
                sort: !options.includes('no-sort') ? true : false
            },
        };
    }
    async onInputChar(session, ch, charmod) {
        if (!ch || session != 'list')
            return;
        let { mode } = this.prompt;
        let now = Date.now();
        if (ch == '<plug>' || (this.plugTs && now - this.plugTs < 20)) {
            this.plugTs = now;
            return;
        }
        if (ch == '<esc>') {
            await this.cancel();
            return;
        }
        if (mode == 'insert') {
            await this.onInsertInput(ch, charmod);
        }
        else {
            await this.onNormalInput(ch, charmod);
        }
    }
    async onInsertInput(ch, charmod) {
        let { session } = this;
        if (mouseKeys.includes(ch)) {
            await this.onMouseEvent(ch);
            return;
        }
        if (!session)
            return;
        let n = await session.doNumberSelect(ch);
        if (n)
            return;
        let done = await this.mappings.doInsertKeymap(ch);
        if (done || charmod)
            return;
        if (ch.startsWith('<') && ch.endsWith('>')) {
            await this.feedkeys(ch, false);
            return;
        }
        for (let s of ch) {
            let code = s.codePointAt(0);
            if (code == 65533)
                return;
            // exclude control character
            if (code < 32 || code >= 127 && code <= 159)
                return;
            await this.prompt.acceptCharacter(s);
        }
    }
    async onNormalInput(ch, _charmod) {
        if (mouseKeys.includes(ch)) {
            await this.onMouseEvent(ch);
            return;
        }
        let used = await this.mappings.doNormalKeymap(ch);
        if (!used)
            await this.feedkeys(ch);
    }
    onMouseEvent(key) {
        var _a;
        return (_a = this.session) === null || _a === void 0 ? void 0 : _a.onMouseEvent(key);
    }
    async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith('<') && key.endsWith('>') ? `\\${key}` : key;
        await nvim.call('coc#prompt#stop_prompt', ['list']);
        await nvim.call('eval', [`feedkeys("${key}", "${remap ? 'i' : 'in'}")`]);
        this.triggerCursorMoved();
        this.prompt.start();
    }
    async command(command) {
        let { nvim } = this;
        await nvim.call('coc#prompt#stop_prompt', ['list']);
        await nvim.command(command);
        this.triggerCursorMoved();
        this.prompt.start();
    }
    async normal(command, bang) {
        let { nvim } = this;
        await nvim.call('coc#prompt#stop_prompt', ['list']);
        await nvim.command(`normal${bang ? '!' : ''} ${command}`);
        this.triggerCursorMoved();
        this.prompt.start();
    }
    triggerCursorMoved() {
        if (this.nvim.isVim)
            this.nvim.command('doautocmd <nomodeline> CursorMoved', true);
    }
    async call(fname) {
        if (this.session)
            return await this.session.call(fname);
    }
    get session() {
        return this.lastSession;
    }
    registerList(list, internal = false) {
        let { name, interactive } = list;
        let id;
        if (!internal)
            id = (0, util_1.getConditionValue)((0, extensionRegistry_1.parseExtensionName)(Error().stack), undefined);
        let removed = this.deregisterList(name);
        this.listMap.set(name, list);
        const configNode = createConfigurationNode(name, interactive, id);
        if (!removed)
            workspace_1.default.configurations.updateConfigurations([configNode]);
        return protocol_1.Disposable.create(() => {
            this.deregisterList(name);
            const configurationRegistry = registry_2.Registry.as(registry_1.Extensions.Configuration);
            configurationRegistry.deregisterConfigurations([configNode]);
        });
    }
    deregisterList(name) {
        let exists = this.listMap.get(name);
        if (exists) {
            if (typeof exists.dispose == 'function') {
                exists.dispose();
            }
            this.listMap.delete(name);
            return true;
        }
        return false;
    }
    get names() {
        return Array.from(this.listMap.keys());
    }
    get descriptions() {
        let d = {};
        for (let name of this.listMap.keys()) {
            let list = this.listMap.get(name);
            d[name] = list.description;
        }
        return d;
    }
    /**
     * Get items of {name} list
     *
     * @param {string} name
     * @returns {Promise<any>}
     */
    async loadItems(name) {
        let args = [name];
        let res = this.parseArgs(args);
        if (!res || !name)
            return;
        let { list, options, listArgs } = res;
        let source = new protocol_1.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list.loadItems({
            options,
            args: listArgs,
            input: '',
            cwd: workspace_1.default.cwd,
            window: this.nvim.createWindow(arr[0]),
            buffer: this.nvim.createBuffer(arr[1]),
            listWindow: null
        }, token);
        if (!items || Array.isArray(items)) {
            return items;
        }
        let task = items;
        let newItems = await new Promise((resolve, reject) => {
            let items = [];
            task.on('data', item => {
                item.label = (0, node_1.stripAnsi)(item.label);
                items.push(item);
            });
            task.on('end', () => {
                resolve(items);
            });
            task.on('error', msg => {
                reject(msg);
            });
        });
        return newItems;
    }
    toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession)
            lastSession.toggleMode();
    }
    get isActivated() {
        var _a;
        return ((_a = this.session) === null || _a === void 0 ? void 0 : _a.winid) != null;
    }
    stop() {
        let lastSession = this.lastSession;
        if (lastSession)
            lastSession.stop();
    }
    dispose() {
        for (let session of this.sessionsMap.values()) {
            session.dispose();
        }
        this.sessionsMap.clear();
        this.lastSession = undefined;
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.ListManager = ListManager;
exports.default = new ListManager();
function createConfigurationNode(name, interactive, id) {
    let properties = {};
    properties[`list.source.${name}.defaultAction`] = {
        type: 'string',
        default: null,
        description: `Default action of "${name}" list.`
    };
    properties[`list.source.${name}.defaultOptions`] = {
        type: 'array',
        default: interactive ? ['--interactive'] : [],
        description: `Default list options of "${name}" list, only used when both list option and argument are empty.`,
        uniqueItems: true,
        items: {
            type: 'string',
            enum: ['--top', '--normal', '--no-sort', '--input', '--height', '--tab',
                '--strict', '--regex', '--ignore-case', '--number-select',
                '--reverse', '--interactive', '--auto-preview', '--first', '--no-quit']
        }
    };
    properties[`list.source.${name}.defaultArgs`] = {
        type: 'array',
        default: [],
        description: `Default argument list of "${name}" list, only used when list argument is empty.`,
        uniqueItems: true,
        items: { type: 'string' }
    };
    let node = {
        scope: 1 /* ConfigurationScope.APPLICATION */,
        properties,
    };
    if (id)
        node.extensionInfo = { id };
    return node;
}
exports.createConfigurationNode = createConfigurationNode;
//# sourceMappingURL=manager.js.map