"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const keymaps_1 = require("../../core/keymaps");
const helper_1 = tslib_1.__importDefault(require("../helper"));
const util_1 = require("../../util");
const events_1 = tslib_1.__importDefault(require("../../events"));
let nvim;
let keymaps;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    keymaps = workspace_1.default.keymaps;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('doKeymap()', () => {
    it('should not throw when key not mapped', async () => {
        await keymaps.doKeymap('<C-a>', '');
    });
    it('should invoke exists keymap', async () => {
        let called = false;
        keymaps.registerKeymap(['i', 'n'], 'test-keymap', () => {
            called = true;
            return 'result';
        });
        let res = await keymaps.doKeymap('test-keymap', '');
        expect(res).toBe('result');
        expect(called).toBe(true);
    });
});
describe('registerKeymap()', () => {
    it('should getBufnr', () => {
        expect((0, keymaps_1.getBufnr)(3)).toBe(3);
        expect((0, keymaps_1.getBufnr)(true)).toBe(events_1.default.bufnr);
    });
    it('should getKeymapModifier', () => {
        expect((0, keymaps_1.getKeymapModifier)('i')).toBe('<C-o>');
        expect((0, keymaps_1.getKeymapModifier)('s')).toBe('<Esc>');
        expect((0, keymaps_1.getKeymapModifier)('x')).toBe('<C-U>');
        expect((0, keymaps_1.getKeymapModifier)('t')).toBe('');
    });
    it('should throw for invalid key', () => {
        let err;
        try {
            keymaps.registerKeymap(['i'], '', jest.fn());
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
    });
    it('should throw for duplicated key', async () => {
        keymaps.registerKeymap(['i'], 'tmp', jest.fn());
        let err;
        try {
            keymaps.registerKeymap(['i'], 'tmp', jest.fn());
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
    });
    it('should register insert key mapping', async () => {
        let fn = jest.fn();
        disposables.push(keymaps.registerKeymap(['i'], 'test', fn));
        let res = await nvim.call('execute', ['verbose imap <Plug>(coc-test)']);
        expect(res).toMatch('coc#_insert_key');
    });
    it('should register with different options', async () => {
        let called = false;
        let fn = () => {
            called = true;
            return '';
        };
        disposables.push(keymaps.registerKeymap(['n', 'v'], 'test', fn, {
            sync: false,
            cancel: false,
            silent: false,
            repeat: true
        }));
        let res = await nvim.exec(`verbose nmap <Plug>(coc-test)`, true);
        expect(res).toMatch('coc#rpc#notify');
        await nvim.eval(`feedkeys("\\<Plug>(coc-test)")`);
        await helper_1.default.waitValue(() => called, true);
    });
});
describe('registerExprKeymap()', () => {
    it('should visual key mapping', async () => {
        await nvim.setLine('foo');
        let called = false;
        let fn = () => {
            called = true;
            return '';
        };
        disposables.push(keymaps.registerExprKeymap('x', 'x', fn));
        await nvim.command('normal! viw');
        await nvim.input('x<esc>');
        await helper_1.default.waitValue(() => called, true);
    });
    it('should register insert key mapping', async () => {
        let buf = await nvim.buffer;
        let called = false;
        let fn = () => {
            called = true;
            return '';
        };
        let disposable = keymaps.registerExprKeymap('i', 'x', fn, buf.id);
        let res = await nvim.exec('imap x', true);
        expect(res).toMatch('coc#_insert_key');
        await nvim.input('i');
        await nvim.input('x');
        await helper_1.default.waitValue(() => called, true);
        disposable.dispose();
        res = await nvim.exec('imap x', true);
        expect(res).toMatch('No mapping found');
    });
});
describe('registerLocalKeymap', () => {
    it('should register local keymap by notification', async () => {
        let bufnr = await nvim.call('bufnr', ['%']);
        let called = false;
        let disposable = keymaps.registerLocalKeymap(bufnr, 'n', 'n', () => {
            called = true;
        }, true);
        let res = await nvim.exec('nmap n', true);
        await nvim.input('n');
        await helper_1.default.waitValue(() => called, true);
        disposable.dispose();
        res = await nvim.exec('nmap n', true);
        expect(res).toMatch('No mapping found');
    });
});
//# sourceMappingURL=keymaps.test.js.map