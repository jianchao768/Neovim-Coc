"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const log_1 = require("../../logger/log");
const index_1 = require("../../logger/index");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const uuid_1 = require("uuid");
let filepath;
afterEach(() => {
    if (fs_1.default.existsSync(filepath))
        fs_1.default.unlinkSync(filepath);
});
describe('FileLogger', () => {
    it('should have DEFAULT_LOG_LEVEL', () => {
        expect(log_1.DEFAULT_LOG_LEVEL).toBeDefined();
        expect(index_1.logger).toBeDefined();
    });
    it('should get LogLevel', () => {
        expect((0, log_1.stringifyLogLevel)('')).toBe('');
    });
    it('should getTimestamp', () => {
        let res = (0, index_1.getTimestamp)(new Date());
        expect(res).toBeDefined();
    });
    it('should convert digits', () => {
        expect((0, log_1.toTwoDigits)(1)).toBe('01');
        expect((0, log_1.toTwoDigits)(11)).toBe('11');
        expect((0, log_1.toThreeDigits)(1)).toBe('001');
        expect((0, log_1.toThreeDigits)(10)).toBe('010');
        expect((0, log_1.toThreeDigits)(100)).toBe('100');
    });
    it('should get level from text', () => {
        expect((0, log_1.textToLogLevel)('trace')).toBe(log_1.LogLevel.Trace);
        expect((0, log_1.textToLogLevel)('debug')).toBe(log_1.LogLevel.Debug);
        expect((0, log_1.textToLogLevel)('info')).toBe(log_1.LogLevel.Info);
        expect((0, log_1.textToLogLevel)('error')).toBe(log_1.LogLevel.Error);
        expect((0, log_1.textToLogLevel)('warning')).toBe(log_1.LogLevel.Warning);
        expect((0, log_1.textToLogLevel)('warn')).toBe(log_1.LogLevel.Warning);
        expect((0, log_1.textToLogLevel)('off')).toBe(log_1.LogLevel.Off);
        expect((0, log_1.textToLogLevel)('')).toBe(log_1.LogLevel.Info);
    });
    it('should format', () => {
        let obj = {
            x: 1,
            y: '2',
            z: {}
        };
        obj.z.parent = obj;
        let res = (0, log_1.format)([obj], 2, true, false);
        expect(res).toBeDefined();
        res = (0, log_1.format)([obj]);
        expect(res).toBeDefined();
    });
    it('should create logger', async () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Trace, {
            color: false,
            depth: 2,
            showHidden: false,
            userFormatters: true
        });
        let logger = fileLogger.createLogger('scope');
        logger.log('msg');
        logger.trace('trace', 'data', {}, 1, true);
        logger.debug('debug');
        logger.info('info');
        logger.warn('warn');
        logger.error('error');
        logger.fatal('fatal');
        logger.mark('mark');
        await logger.flush();
        let content = fs_1.default.readFileSync(filepath, 'utf8');
        let lines = content.split(/\n/);
        expect(lines.length).toBe(8);
        expect(logger.category).toBeDefined();
        expect(logger.getLevel()).toBeDefined();
    });
    it('should switch to console', () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Trace, {});
        let logger = fileLogger.createLogger('scope');
        fileLogger.switchConsole();
        let fn = jest.fn();
        let spy = jest.spyOn(console, 'error').mockImplementation(() => {
            fn();
        });
        logger.error('error');
        spy.mockRestore();
        expect(fn).toBeCalled();
        fn = jest.fn();
        spy = jest.spyOn(console, 'log').mockImplementation(() => {
            fn();
        });
        logger.info('info');
        spy.mockRestore();
        expect(fn).toBeCalled();
    });
    it('should enable color', async () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Trace, {
            color: true
        });
        let logger = fileLogger.createLogger('scope');
        logger.info('msg', 1, true, { foo: 'bar' });
        await logger.flush();
        let content = fs_1.default.readFileSync(filepath, 'utf8');
        expect(content.indexOf('\x33')).toBeGreaterThan(-1);
    });
    it('should change level', () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Off, {});
        fileLogger.setLevel(log_1.LogLevel.Debug);
        fileLogger.setLevel(log_1.LogLevel.Debug);
    });
    it('should work with off level', async () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Off, {
            color: false,
            depth: 2,
            showHidden: false,
            userFormatters: true
        });
        let logger = fileLogger.createLogger('scope');
        logger.log('msg');
        logger.trace('trace');
        logger.debug('debug');
        logger.info('info');
        logger.warn('warn');
        logger.error('error');
        logger.fatal('fatal');
        logger.mark('mark');
        await logger.flush();
        expect(fs_1.default.existsSync(filepath)).toBe(false);
    });
    it('should work without formatter', async () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Trace, {
            userFormatters: false
        });
        let logger = fileLogger.createLogger('scope');
        logger.log('msg\n');
        await logger.flush();
        let content = fs_1.default.readFileSync(filepath, 'utf8');
        let lines = content.split(/\n/);
        expect(lines.length).toBe(2);
    });
    it('should use backup file', async () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Trace, {
            userFormatters: true
        });
        let logger = fileLogger.createLogger('scope');
        let spy = jest.spyOn(fileLogger, 'shouldBackup').mockImplementation(() => {
            return true;
        });
        for (let i = 0; i < 6; i++) {
            logger.log(1);
        }
        await logger.flush();
        spy.mockRestore();
        let newFile = filepath + `_1`;
        expect(fs_1.default.existsSync(newFile)).toBe(true);
    });
    it('should not throw on error', async () => {
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let fileLogger = new log_1.FileLogger(filepath, log_1.LogLevel.Trace, {
            userFormatters: false
        });
        let logger = fileLogger.createLogger('scope');
        let fn = jest.fn();
        let s = jest.spyOn(console, 'error').mockImplementation(() => {
            fn();
        });
        let spy = jest.spyOn(fileLogger, 'shouldBackup').mockImplementation(() => {
            throw new Error('my error');
        });
        logger.log('msg\n');
        await logger.flush();
        expect(fn).toBeCalled();
        s.mockRestore();
        spy.mockRestore();
    });
    it('should create default logger', () => {
        expect((0, index_1.createLogger)()).toBeDefined();
    });
    it('should resolveLogFilepath from env', () => {
        let filepath = '/tmp/log';
        process.env.NVIM_COC_LOG_FILE = filepath;
        expect((0, index_1.resolveLogFilepath)()).toBe(filepath);
        process.env.NVIM_COC_LOG_FILE = '';
        process.env.XDG_RUNTIME_DIR = os_1.default.tmpdir();
        expect((0, index_1.resolveLogFilepath)()).toBeDefined();
        process.env.XDG_RUNTIME_DIR = '/dir_not_exists';
        expect((0, index_1.resolveLogFilepath)()).toBeDefined();
        process.env.XDG_RUNTIME_DIR = '';
        expect((0, index_1.resolveLogFilepath)()).toBeDefined();
    });
    it('should empty file', async () => {
        (0, index_1.emptyFile)('/file_not_exists');
        filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        fs_1.default.writeFileSync(filepath, 'data', 'utf8');
        (0, index_1.emptyFile)(filepath);
        let content = fs_1.default.readFileSync(filepath, 'utf8');
        expect(content.trim().length).toBe(0);
    });
});
//# sourceMappingURL=logger.test.js.map