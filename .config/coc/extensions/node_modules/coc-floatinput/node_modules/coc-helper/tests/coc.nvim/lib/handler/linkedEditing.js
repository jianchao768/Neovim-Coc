'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const textRange_1 = tslib_1.__importDefault(require("../cursors/textRange"));
const util_1 = require("../cursors/util");
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const util_2 = require("../util");
const node_1 = require("../util/node");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const debounceTime = (0, util_2.getConditionValue)(200, 10);
class LinkedEditingHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.changing = false;
        this.checkPosition = (0, node_1.debounce)(this._checkPosition, debounceTime);
        handler.addDisposable(events_1.default.on('CursorMoved', (bufnr, cursor) => {
            this.cancel();
            this.checkPosition(bufnr, [cursor[0], cursor[1]]);
        }));
        handler.addDisposable(events_1.default.on('CursorMovedI', (bufnr, cursor) => {
            this.cancel();
            this.checkPosition(bufnr, [cursor[0], cursor[1]]);
        }));
        handler.addDisposable(window_1.default.onDidChangeActiveTextEditor(() => {
            this.cancel();
            this.cancelEdit();
        }));
        handler.addDisposable(events_1.default.on('InsertCharPre', (character, bufnr) => {
            if (bufnr !== this.bufnr)
                return;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!this.wordPattern) {
                if (!doc.isWord(character) && character !== '-')
                    this.cancelEdit();
            }
            else {
                let r = new RegExp(this.wordPattern);
                if (!r.test(character))
                    this.cancelEdit();
            }
        }));
        handler.addDisposable(workspace_1.default.onDidChangeTextDocument(async (e) => {
            await this.onChange(e);
        }));
    }
    cancelEdit() {
        var _a;
        (_a = this.window) === null || _a === void 0 ? void 0 : _a.clearMatchGroup('^CocLinkedEditing');
        this.ranges = undefined;
        this.window = undefined;
        this.bufnr = undefined;
    }
    async onChange(e) {
        if (e.bufnr !== this.bufnr || this.changing || !this.ranges)
            return;
        if (e.contentChanges.length === 0) {
            this.doHighlights();
            return;
        }
        let change = e.contentChanges[0];
        let { text, range } = change;
        let affected = this.ranges.filter(r => {
            if (!(0, position_1.rangeIntersect)(range, r.range))
                return false;
            if ((0, position_1.rangeAdjacent)(range, r.range)) {
                if (text.includes('\n') || !(0, position_1.emptyRange)(range))
                    return false;
            }
            return true;
        });
        if (affected.length == 1 && (0, position_1.rangeInRange)(range, affected[0].range)) {
            if (text.includes('\n')) {
                this.cancelEdit();
                return;
            }
            // change textRange
            await this.applySingleEdit(affected[0], { range, newText: text });
        }
        else {
            this.cancelEdit();
        }
    }
    async applySingleEdit(textRange, edit) {
        // single range change, calculate & apply changes for all ranges
        let { bufnr, ranges } = this;
        let doc = workspace_1.default.getDocument(bufnr);
        let after = ranges.filter(r => r !== textRange && r.position.line == textRange.position.line);
        after.forEach(r => r.adjustFromEdit(edit));
        let change = (0, util_1.getChange)(textRange, edit.range, edit.newText);
        let delta = (0, util_1.getDelta)(change);
        ranges.forEach(r => r.applyChange(change));
        let edits = ranges.filter(r => r !== textRange).map(o => o.textEdit);
        // logger.debug('edits:', JSON.stringify(edits, null, 2))
        this.changing = true;
        await doc.applyEdits(edits, true, true);
        this.changing = false;
        if (delta != 0) {
            for (let r of ranges) {
                let n = (0, util_1.getBeforeCount)(r, this.ranges, textRange);
                r.move(n * delta);
            }
        }
        this.doHighlights();
    }
    doHighlights() {
        let { window, ranges, nvim } = this;
        if (window && ranges) {
            nvim.pauseNotification();
            window.clearMatchGroup('^CocLinkedEditing');
            window.highlightRanges('CocLinkedEditing', ranges.map(o => o.range), 99, true);
            nvim.resumeNotification(true, true);
        }
    }
    _checkPosition(bufnr, cursor) {
        if (events_1.default.pumvisible || !workspace_1.default.isAttached(bufnr))
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        let config = workspace_1.default.getConfiguration('coc.preferences', doc);
        let enabled = config.get('enableLinkedEditing', false);
        if (!enabled || !languages_1.default.hasProvider(languages_1.ProviderName.LinkedEditing, doc.textDocument))
            return;
        let character = (0, string_1.characterIndex)(doc.getline(cursor[0] - 1), cursor[1] - 1);
        let position = vscode_languageserver_types_1.Position.create(cursor[0] - 1, character);
        if (this.ranges) {
            if (this.ranges.some(r => (0, position_1.positionInRange)(position, r.range) == 0)) {
                return;
            }
            this.cancelEdit();
        }
        void this.enable(doc, position);
    }
    async enable(doc, position) {
        let textDocument = doc.textDocument;
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        let win = await this.nvim.window;
        let linkedRanges = await languages_1.default.provideLinkedEdits(textDocument, position, token);
        if (token.isCancellationRequested || !linkedRanges || linkedRanges.ranges.length == 0)
            return;
        let ranges = linkedRanges.ranges.map(o => new textRange_1.default(o.start.line, o.start.character, textDocument.getText(o)));
        this.wordPattern = linkedRanges.wordPattern;
        this.bufnr = doc.bufnr;
        this.window = win;
        this.ranges = ranges;
        this.doHighlights();
    }
    cancel() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
}
exports.default = LinkedEditingHandler;
//# sourceMappingURL=linkedEditing.js.map