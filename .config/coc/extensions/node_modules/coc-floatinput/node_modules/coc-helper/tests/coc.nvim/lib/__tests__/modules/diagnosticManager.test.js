"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const manager_1 = tslib_1.__importDefault(require("../../diagnostic/manager"));
const util_1 = require("../../diagnostic/util");
const window_1 = tslib_1.__importDefault(require("../../window"));
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
function createDiagnostic(msg, range, severity) {
    range = range ? range : vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1);
    return vscode_languageserver_protocol_1.Diagnostic.create(range, msg, severity || vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
}
let virtualTextSrcId;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    virtualTextSrcId = await nvim.createNamespace('coc-diagnostic-virtualText');
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    manager_1.default.reset();
    await helper_1.default.reset();
});
async function createDocument(name) {
    let doc = await helper_1.default.createDocument(name);
    let collection = manager_1.default.create('test');
    let diagnostics = [];
    await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {
        start: 0,
        end: -1,
        strictIndexing: false
    });
    await doc.synchronize();
    diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 2, 0, 4), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
    diagnostics.push(createDiagnostic('warning', vscode_languageserver_protocol_1.Range.create(0, 5, 0, 6), vscode_languageserver_protocol_1.DiagnosticSeverity.Warning));
    diagnostics.push(createDiagnostic('information', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 1), vscode_languageserver_protocol_1.DiagnosticSeverity.Information));
    diagnostics.push(createDiagnostic('hint', vscode_languageserver_protocol_1.Range.create(1, 2, 1, 3), vscode_languageserver_protocol_1.DiagnosticSeverity.Hint));
    diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(2, 0, 2, 2), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
    collection.set(doc.uri, diagnostics);
    await helper_1.default.waitValue(() => {
        let buf = manager_1.default.getItem(doc.bufnr);
        if (!buf.config.autoRefresh)
            return true;
        return buf.getDiagnosticsAt(vscode_languageserver_protocol_1.Position.create(0, 0), true).length > 0;
    }, true);
    return doc;
}
describe('diagnostic manager', () => {
    describe('defineSigns', () => {
        it('should defineSigns', () => {
            manager_1.default.defineSigns({
                enableHighlightLineNumber: false
            });
        });
    });
    describe('setLocationlist()', () => {
        it('should set location list', async () => {
            let doc = await createDocument();
            await helper_1.default.doAction('fillDiagnostics', doc.bufnr);
            let res = await nvim.call('getloclist', [doc.bufnr]);
            expect(res.length).toBeGreaterThan(2);
            helper_1.default.updateConfiguration('diagnostic.locationlistLevel', 'error');
            await manager_1.default.setLocationlist(doc.bufnr);
            res = await nvim.call('getloclist', [doc.bufnr]);
            expect(res.length).toBe(2);
        });
        it('should throw when buffer not attached', async () => {
            await nvim.command(`vnew +setl\\ buftype=nofile`);
            let doc = await workspace_1.default.document;
            let fn = async () => {
                await manager_1.default.setLocationlist(doc.bufnr);
            };
            await expect(fn()).rejects.toThrow(/not/);
        });
    });
    describe('events', () => {
        it('should delay refresh when buffer visible', async () => {
            let doc = await helper_1.default.createDocument();
            await nvim.command('edit tmp');
            let collection = manager_1.default.create('foo');
            let diagnostics = [];
            await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {
                start: 0,
                end: -1,
                strictIndexing: false
            });
            await doc.synchronize();
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 2, 0, 4), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
            collection.set(doc.uri, diagnostics);
            let buf = doc.buffer;
            let val = await buf.getVar('coc_diagnostic_info');
            expect(val == null).toBe(true);
            let ns = await nvim.createNamespace('coc-diagnosticfoo');
            let markers = await buf.getExtMarks(ns, 0, -1);
            expect(markers.length).toBe(0);
            await nvim.command(`b ${buf.id}`);
            await helper_1.default.waitFor('eval', ['empty(get(b:,"coc_diagnostic_info",{}))'], 0);
            collection.dispose();
        });
        it('should delay refresh on InsertLeave', async () => {
            let doc = await workspace_1.default.document;
            await nvim.input('i');
            let collection = manager_1.default.create('foo');
            let diagnostics = [];
            await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {
                start: 0,
                end: -1,
                strictIndexing: false
            });
            await doc.synchronize();
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 2, 0, 4), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
            collection.set(doc.uri, diagnostics);
            let buf = doc.buffer;
            await helper_1.default.waitValue(async () => {
                let val = await buf.getVar('coc_diagnostic_info');
                return val == null;
            }, true);
            let ns = await nvim.createNamespace('coc-diagnosticfoo');
            let markers = await buf.getExtMarks(ns, 0, -1);
            expect(markers.length).toBe(0);
            await nvim.input('<esc>');
            await helper_1.default.waitValue(async () => {
                let markers = await buf.getExtMarks(ns, 0, -1);
                return markers.length;
            }, 1);
        });
        it('should show diagnostic virtual text on CursorMoved', async () => {
            helper_1.default.updateConfiguration('diagnostic.virtualText', true);
            helper_1.default.updateConfiguration('diagnostic.virtualTextCurrentLineOnly', true);
            let doc = await createDocument();
            await helper_1.default.wait(30);
            let markers = await doc.buffer.getExtMarks(virtualTextSrcId, 0, -1, { details: true });
            await manager_1.default.toggleDiagnosticBuffer(doc.bufnr);
            await nvim.call('cursor', [1, 3]);
            await helper_1.default.wait(30);
            markers = await doc.buffer.getExtMarks(virtualTextSrcId, 0, -1, { details: true });
            expect(markers.length).toBe(0);
        });
    });
    describe('refresh()', () => {
        it('should refresh on buffer create', async () => {
            let uri = vscode_uri_1.URI.file(path_1.default.join(path_1.default.dirname(__dirname), 'doc')).toString();
            let fn = jest.fn();
            let disposable = manager_1.default.onDidRefresh(() => {
                fn();
            });
            let collection = manager_1.default.create('tmp');
            let diagnostic = createDiagnostic('My Error');
            collection.set(uri, [diagnostic]);
            let doc = await helper_1.default.createDocument('doc');
            await helper_1.default.wait(30);
            let val = await doc.buffer.getVar('coc_diagnostic_info');
            expect(fn).toBeCalled();
            expect(val).toBeDefined();
            expect(val.error).toBe(1);
            collection.dispose();
            disposable.dispose();
        });
    });
    describe('toggleDiagnostic()', () => {
        it('should toggle diagnostics for all buffer', async () => {
            await createDocument();
            let doc = await createDocument();
            await helper_1.default.doAction('diagnosticToggle');
            let item = manager_1.default.getItem(doc.bufnr);
            expect(item.config.enable).toBe(false);
            await manager_1.default.toggleDiagnostic(1);
            expect(item.config.enable).toBe(true);
        });
    });
    describe('getDiagnosticList()', () => {
        it('should get all diagnostics', async () => {
            await createDocument();
            let collection = manager_1.default.create('test');
            let fsPath = await (0, helper_1.createTmpFile)('foo');
            let doc = await helper_1.default.createDocument(fsPath);
            let diagnostics = [];
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 1, 0, 2), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 2, 0, 3), vscode_languageserver_protocol_1.DiagnosticSeverity.Warning));
            collection.set(doc.uri, diagnostics);
            collection.set('file:///1', []);
            let list = await helper_1.default.doAction('diagnosticList');
            expect(list).toBeDefined();
            expect(list.length).toBeGreaterThanOrEqual(5);
            expect(list[0].severity).toBe('Error');
            expect(list[1].severity).toBe('Error');
            expect(list[2].severity).toBe('Error');
        });
        it('should filter diagnostics by configuration', async () => {
            helper_1.default.updateConfiguration('diagnostic.level', 'warning');
            helper_1.default.updateConfiguration('diagnostic.showUnused', false);
            helper_1.default.updateConfiguration('diagnostic.showDeprecated', false);
            let doc = await createDocument();
            let buf = manager_1.default.getItem(doc.bufnr);
            let diagnostics = manager_1.default.getDiagnostics(buf)['test'];
            diagnostics[0].tags = [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary];
            diagnostics[2].tags = [vscode_languageserver_protocol_1.DiagnosticTag.Deprecated];
            let list = await manager_1.default.getDiagnosticList();
            expect(list.length).toBe(3);
            let res = manager_1.default.getDiagnostics(buf)['test'];
            expect(res.length).toBe(1);
            let ranges = manager_1.default.getSortedRanges(doc.uri, buf.config.level);
            expect(ranges.length).toBe(3);
        });
        it('should load file from disk ', async () => {
            let fsPath = __filename;
            let collection = manager_1.default.create('test');
            let diagnostics = [];
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
            let uri = vscode_uri_1.URI.file(fsPath).toString();
            collection.set(uri, diagnostics);
            let arr = [];
            arr.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 1), undefined));
            collection.set('test:1', arr);
            let list = await manager_1.default.getDiagnosticList();
            expect(list.length).toBe(2);
        });
    });
    describe('preview()', () => {
        it('should not throw with empty diagnostics', async () => {
            await helper_1.default.doAction('diagnosticPreview');
            let tabpage = await nvim.tabpage;
            let wins = await tabpage.windows;
            expect(wins.length).toBe(1);
        });
        it('should open preview window', async () => {
            await createDocument();
            await nvim.call('cursor', [1, 3]);
            await manager_1.default.preview();
            let res = await nvim.call('coc#window#find', ['&previewwindow', 1]);
            expect(res).toBeDefined();
        });
    });
    describe('setConfigurationErrors()', () => {
        it('should set configuration errors on refresh', async () => {
            let file = path_1.default.join(os_1.default.tmpdir(), '69075963-48d6-4427-92db-287a09d5e976');
            fs_1.default.writeFileSync(file, ']', 'utf8');
            workspace_1.default.configurations.parseConfigurationModel(file);
            let errors = workspace_1.default.configurations.errors;
            expect(errors.size).toBeGreaterThan(0);
            let list = await manager_1.default.getDiagnosticList();
            expect(list.length).toBe(1);
            expect(list[0].file).toBe(file);
            manager_1.default.checkConfigurationErrors();
            fs_1.default.unlinkSync(file);
        });
    });
    describe('create()', () => {
        it('should create diagnostic collection', async () => {
            let doc = await workspace_1.default.document;
            let collection = manager_1.default.create('test');
            collection.set(doc.uri, [createDiagnostic('foo')]);
            await helper_1.default.waitValue(async () => {
                let info = await doc.buffer.getVar('coc_diagnostic_info');
                return info != null;
            }, true);
        });
    });
    describe('getSortedRanges()', () => {
        it('should get sorted ranges of document', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['a', 'b', 'c']]);
            let collection = manager_1.default.create('test');
            let diagnostics = [];
            diagnostics.push(createDiagnostic('x', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)));
            diagnostics.push(createDiagnostic('y', vscode_languageserver_protocol_1.Range.create(0, 1, 0, 2)));
            diagnostics.push(createDiagnostic('z', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 2)));
            collection.set(doc.uri, diagnostics);
            let item = manager_1.default.getItem(doc.bufnr);
            let level = item.config.level;
            let ranges = manager_1.default.getSortedRanges(doc.uri, level);
            expect(ranges[0]).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
            expect(ranges[1]).toEqual(vscode_languageserver_protocol_1.Range.create(0, 1, 0, 2));
            expect(ranges[2]).toEqual(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 2));
            ranges = manager_1.default.getSortedRanges(doc.uri, level, 'error');
            expect(ranges.length).toBe(3);
            expect(manager_1.default.getSortedRanges(doc.uri, level, 'warning').length).toBe(0);
        });
    });
    describe('getDiagnosticsInRange', () => {
        it('should get diagnostics in range', async () => {
            let doc = await createDocument();
            let res = manager_1.default.getDiagnosticsInRange(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0));
            expect(res.length).toBe(3);
            doc = await helper_1.default.createDocument();
            res = manager_1.default.getDiagnosticsInRange(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0));
            expect(res.length).toBe(0);
        });
    });
    describe('getCurrentDiagnostics', () => {
        it('should get undefined when buffer not attached', async () => {
            await nvim.command(`edit +setl\\ buftype=nofile tmp`);
            let res = await manager_1.default.getCurrentDiagnostics();
            await helper_1.default.doAction('diagnosticInfo');
            expect(res).toBeUndefined();
        });
        it('should get diagnostics under cursor', async () => {
            await createDocument();
            let diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBe(0);
            await nvim.call('cursor', [1, 4]);
            diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBe(1);
            helper_1.default.updateConfiguration('diagnostic.checkCurrentLine', true);
            await nvim.call('cursor', [1, 2]);
            diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBe(2);
        });
        it('should get empty diagnostic at end of line', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setLine('foo');
            doc.forceSync();
            await nvim.command('normal! $');
            let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(vscode_languageserver_protocol_1.Range.create(0, 3, 1, 0), 'error', vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
            let collection = manager_1.default.create('empty');
            collection.set(doc.uri, [diagnostic]);
            await manager_1.default.refreshBuffer(doc.bufnr);
            let diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBeGreaterThanOrEqual(1);
            expect(diagnostics[0].message).toBe('error');
            collection.dispose();
            await manager_1.default.refreshBuffer(99);
        });
        it('should get diagnostic next to end of line', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setLine('foo');
            doc.forceSync();
            await nvim.command('normal! $');
            let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(vscode_languageserver_protocol_1.Range.create(0, 3, 0, 4), 'error', vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
            let collection = manager_1.default.create('empty');
            collection.set(doc.uri, [diagnostic]);
            await manager_1.default.refreshBuffer(doc.bufnr);
            let diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBeGreaterThanOrEqual(1);
            expect(diagnostics[0].message).toBe('error');
            collection.dispose();
        });
        it('should get diagnostic with empty range at end of line', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setLine('foo');
            doc.forceSync();
            await nvim.command('normal! $');
            let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(vscode_languageserver_protocol_1.Range.create(0, 3, 1, 0), 'error', vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
            let collection = manager_1.default.create('empty');
            collection.set(doc.uri, [diagnostic]);
            await manager_1.default.refreshBuffer(doc.bufnr);
            let diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBeGreaterThanOrEqual(1);
            expect(diagnostics[0].message).toBe('error');
            collection.dispose();
        });
        it('should get diagnostic pass end of the buffer lines', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setLine('foo');
            doc.forceSync();
            await nvim.command('normal! ^');
            let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 0), 'error', vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
            let collection = manager_1.default.create('empty');
            collection.set(doc.uri, [diagnostic]);
            await manager_1.default.refreshBuffer(doc.bufnr);
            let diagnostics = await manager_1.default.getCurrentDiagnostics();
            expect(diagnostics.length).toBeGreaterThanOrEqual(1);
            expect(diagnostics[0].message).toBe('error');
            collection.dispose();
        });
    });
    describe('jumpRelated', () => {
        it('should does nothing when no diagnostic exists', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('cursor', [1, 1]);
            await commands_1.default.executeCommand('workspace.diagnosticRelated');
            let bufnr = await nvim.eval('bufnr("%")');
            expect(bufnr).toBe(doc.bufnr);
        });
        it('should does nothing when no related information exists', async () => {
            let doc = await createDocument();
            await nvim.call('cursor', [1, 4]);
            await manager_1.default.jumpRelated();
            let bufnr = await nvim.eval('bufnr("%")');
            expect(bufnr).toBe(doc.bufnr);
        });
        it('should jump to related position', async () => {
            let doc = await workspace_1.default.document;
            let range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10);
            let location = vscode_languageserver_protocol_1.Location.create(vscode_uri_1.URI.file(__filename).toString(), range);
            let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(range, 'msg', vscode_languageserver_protocol_1.DiagnosticSeverity.Error, 1000, 'test', [{ location, message: 'test' }]);
            let collection = manager_1.default.create('positions');
            collection.set(doc.uri, [diagnostic]);
            await manager_1.default.refreshBuffer(doc.uri);
            await nvim.call('cursor', [1, 1]);
            await manager_1.default.jumpRelated();
            let bufname = await nvim.call('bufname', '%');
            expect(bufname).toMatch('diagnosticManager');
        });
        it('should open location list', async () => {
            let doc = await workspace_1.default.document;
            let range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10);
            let diagnostic = vscode_languageserver_protocol_1.Diagnostic.create(range, 'msg', vscode_languageserver_protocol_1.DiagnosticSeverity.Error, 1000, 'test', [{
                    location: vscode_languageserver_protocol_1.Location.create(vscode_uri_1.URI.file(__filename).toString(), vscode_languageserver_protocol_1.Range.create(1, 0, 1, 10)),
                    message: 'foo'
                }, {
                    location: vscode_languageserver_protocol_1.Location.create(vscode_uri_1.URI.file(__filename).toString(), vscode_languageserver_protocol_1.Range.create(2, 0, 2, 10)),
                    message: 'bar'
                }]);
            let collection = manager_1.default.create('positions');
            collection.set(doc.uri, [diagnostic]);
            await manager_1.default.refreshBuffer(doc.uri);
            await nvim.call('cursor', [1, 1]);
            await manager_1.default.jumpRelated();
            await helper_1.default.waitFor('bufname', ['%'], 'list:///location');
            await nvim.input('<esc>');
        });
    });
    describe('jumpPrevious & jumpNext', () => {
        it('should jump to previous', async () => {
            let doc = await createDocument();
            await nvim.command('normal! G$');
            let ranges = manager_1.default.getSortedRanges(doc.uri, undefined);
            ranges.reverse();
            for (let i = 0; i < ranges.length; i++) {
                await manager_1.default.jumpPrevious();
                let pos = await window_1.default.getCursorPosition();
                expect(pos).toEqual(ranges[i].start);
            }
            await helper_1.default.doAction('diagnosticPrevious');
        });
        it('should jump to next', async () => {
            let doc = await createDocument();
            await nvim.call('cursor', [0, 0]);
            let ranges = manager_1.default.getSortedRanges(doc.uri, undefined);
            for (let i = 0; i < ranges.length; i++) {
                await manager_1.default.jumpNext();
                let pos = await window_1.default.getCursorPosition();
                expect(pos).toEqual(ranges[i].start);
            }
            await helper_1.default.doAction('diagnosticNext');
        });
        it('should consider invalid position', async () => {
            let doc = await helper_1.default.createDocument('foo.js');
            let collection = manager_1.default.create('foo');
            let diagnostics = [];
            await doc.buffer.setLines(['foo bar', '', 'foo', 'bar'], {
                start: 0,
                end: -1,
                strictIndexing: false
            });
            await nvim.call('cursor', [2, 0]);
            await doc.synchronize();
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 1, 0, 2), vscode_languageserver_protocol_1.DiagnosticSeverity.Error));
            diagnostics.push(createDiagnostic('warning', vscode_languageserver_protocol_1.Range.create(1, 1, 1, 1), vscode_languageserver_protocol_1.DiagnosticSeverity.Warning));
            diagnostics.push(createDiagnostic('warning', vscode_languageserver_protocol_1.Range.create(2, 1, 2, 1), vscode_languageserver_protocol_1.DiagnosticSeverity.Warning));
            collection.set(doc.uri, diagnostics);
            await manager_1.default.jumpNext();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual(vscode_languageserver_protocol_1.Position.create(2, 1));
        });
        it('should not throw when buffer not attached', async () => {
            let doc = await workspace_1.default.document;
            await manager_1.default.jumpNext();
            await nvim.command('edit foo | setl buftype=nofile');
            doc = await workspace_1.default.document;
            expect(doc.attached).toBe(false);
            await manager_1.default.jumpNext();
        });
        it('should respect wrapscan', async () => {
            await createDocument();
            await nvim.command('setl nowrapscan');
            await nvim.command('normal! G$');
            await manager_1.default.jumpNext();
            let pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 3, character: 2 });
            await nvim.command('normal! gg0');
            await manager_1.default.jumpPrevious();
            pos = await window_1.default.getCursorPosition();
            expect(pos).toEqual({ line: 0, character: 0 });
        });
    });
    describe('diagnostic configuration', () => {
        it('should use filetype map from config', async () => {
            helper_1.default.updateConfiguration('diagnostic.filetypeMap', { default: 'bufferType' });
            helper_1.default.updateConfiguration('diagnostic.messageDelay', 10);
            let doc = await createDocument('foo.js');
            await nvim.setLine('foo');
            await doc.synchronize();
            let collection = manager_1.default.getCollectionByName('test');
            let diagnostic = createDiagnostic('99', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
            diagnostic.codeDescription = {
                href: 'http://www.example.com'
            };
            let diagnostics = [diagnostic];
            collection.set(doc.uri, diagnostics);
            await nvim.call('cursor', [1, 2]);
            await manager_1.default.echoCurrentMessage();
            let win = await helper_1.default.getFloat();
            let bufnr = await nvim.call('winbufnr', [win.id]);
            let buf = nvim.createBuffer(bufnr);
            let lines = await buf.lines;
            expect(lines.join('\n')).toMatch('www.example.com');
        });
        it('should show floating window on cursor hold', async () => {
            helper_1.default.updateConfiguration('diagnostic.messageTarget', 'float');
            helper_1.default.updateConfiguration('diagnostic.messageDelay', 10);
            await createDocument();
            await nvim.call('cursor', [1, 3]);
            let winid = await helper_1.default.waitFloat();
            let bufnr = await nvim.call('nvim_win_get_buf', winid);
            let buf = nvim.createBuffer(bufnr);
            let lines = await buf.lines;
            expect(lines.join('\n')).toMatch('error');
        });
        it('should filter diagnostics by messageLevel', async () => {
            helper_1.default.updateConfiguration('diagnostic.messageLevel', 'error');
            helper_1.default.updateConfiguration('diagnostic.messageTarget', 'echo');
            await createDocument();
            await nvim.call('cursor', [1, 6]);
            await manager_1.default.echoCurrentMessage();
            let line = await helper_1.default.getCmdline();
            expect(line.indexOf('warning')).toBe(-1);
        });
        it('should echo messages on CursorHold', async () => {
            helper_1.default.updateConfiguration('diagnostic.messageTarget', 'echo');
            await createDocument();
            await nvim.call('cursor', [1, 3]);
            await helper_1.default.waitValue(async () => {
                let line = await helper_1.default.getCmdline();
                return line.length > 0;
            }, true);
        });
        it('should not echo messages on CursorHold', async () => {
            await nvim.command('echo ""');
            helper_1.default.updateConfiguration('diagnostic.enableMessage', 'never');
            await createDocument();
            await nvim.call('cursor', [1, 3]);
            await helper_1.default.wait(30);
            let line = await helper_1.default.getCmdline();
            expect(line).toBe('');
        });
        it('should show diagnostics of current line', async () => {
            helper_1.default.updateConfiguration('diagnostic.checkCurrentLine', true);
            await createDocument();
            await nvim.call('cursor', [1, 3]);
            let winid = await helper_1.default.waitFloat();
            let win = nvim.createWindow(winid);
            let buf = await win.buffer;
            let lines = await buf.lines;
            expect(lines.length).toBe(3);
        });
        it('should filter diagnostics by level', async () => {
            helper_1.default.updateConfiguration('diagnostic.level', 'warning');
            let doc = await createDocument();
            let item = manager_1.default.getItem(doc.bufnr);
            let diagnosticsMap = manager_1.default.getDiagnostics(item);
            for (let diagnostics of Object.values(diagnosticsMap)) {
                for (let diagnostic of diagnostics) {
                    expect(diagnostic.severity != vscode_languageserver_protocol_1.DiagnosticSeverity.Hint).toBe(true);
                    expect(diagnostic.severity != vscode_languageserver_protocol_1.DiagnosticSeverity.Information).toBe(true);
                }
            }
        });
        it('should send ale diagnostic items', async () => {
            helper_1.default.updateConfiguration('diagnostic.displayByAle', true);
            let content = `
    function! MockAleResults(bufnr, collection, items)
      let g:collection = a:collection
      let g:items = a:items
    endfunction
    `;
            let file = await (0, helper_1.createTmpFile)(content);
            await nvim.command(`source ${file}`);
            await createDocument();
            await helper_1.default.waitValue(async () => {
                let items = await nvim.getVar('items');
                return Array.isArray(items);
            }, true);
            await nvim.command('bd!');
            await helper_1.default.waitFor('eval', ['get(g:,"items",[])'], []);
        });
    });
    describe('severityLevel & getNameFromSeverity', () => {
        it('should get severity level', () => {
            expect((0, util_1.severityLevel)('hint')).toBe(vscode_languageserver_protocol_1.DiagnosticSeverity.Hint);
            expect((0, util_1.severityLevel)('error')).toBe(vscode_languageserver_protocol_1.DiagnosticSeverity.Error);
            expect((0, util_1.severityLevel)('warning')).toBe(vscode_languageserver_protocol_1.DiagnosticSeverity.Warning);
            expect((0, util_1.severityLevel)('information')).toBe(vscode_languageserver_protocol_1.DiagnosticSeverity.Information);
            expect((0, util_1.severityLevel)('')).toBe(vscode_languageserver_protocol_1.DiagnosticSeverity.Hint);
        });
        it('should get severity name', () => {
            expect((0, util_1.getNameFromSeverity)(null)).toBe('CocError');
        });
    });
    describe('toggleDiagnosticBuffer', () => {
        it('should not throw when bufnr is invliad or disabled', async () => {
            let doc = await workspace_1.default.document;
            await helper_1.default.doAction('diagnosticToggleBuffer', 99);
            helper_1.default.updateConfiguration('diagnostic.enable', false);
            await manager_1.default.toggleDiagnosticBuffer(doc.bufnr);
        });
        it('should toggle current buffer', async () => {
            let doc = await workspace_1.default.document;
            await manager_1.default.toggleDiagnosticBuffer();
            let buf = nvim.createBuffer(doc.bufnr);
            let res = await buf.getVar('coc_diagnostic_disable');
            expect(res).toBe(1);
        });
        it('should toggle diagnostics for buffer', async () => {
            let doc = await createDocument();
            await manager_1.default.toggleDiagnosticBuffer(doc.bufnr);
            let buf = nvim.createBuffer(doc.bufnr);
            let res = await buf.getVar('coc_diagnostic_info');
            expect(res == null).toBe(true);
            await manager_1.default.toggleDiagnosticBuffer(doc.bufnr, 1);
            res = await buf.getVar('coc_diagnostic_info');
            expect(res.error).toBe(2);
        });
    });
    describe('refresh', () => {
        beforeEach(() => {
            helper_1.default.updateConfiguration('diagnostic.autoRefresh', false);
        });
        it('should refresh by bufnr', async () => {
            let doc = await createDocument();
            let buf = nvim.createBuffer(doc.bufnr);
            let res = await buf.getVar('coc_diagnostic_info');
            // should not refresh
            expect(res == null).toBe(true);
            await manager_1.default.refresh(doc.bufnr);
            await helper_1.default.waitValue(async () => {
                let res = await buf.getVar('coc_diagnostic_info');
                return res === null || res === void 0 ? void 0 : res.error;
            }, 2);
            await manager_1.default.refresh(99);
        });
        it('should refresh all buffers', async () => {
            let uris = ['one', 'two'].map(s => vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), s)).toString());
            await workspace_1.default.loadFile(uris[0], 'tabe');
            await workspace_1.default.loadFile(uris[1], 'tabe');
            let collection = manager_1.default.create('tmp');
            collection.set([[uris[0], [createDiagnostic('Error one')]], [uris[1], [createDiagnostic('Error two')]]]);
            await helper_1.default.doAction('diagnosticRefresh');
            let bufnrs = [workspace_1.default.getDocument(uris[0]).bufnr, workspace_1.default.getDocument(uris[1]).bufnr];
            for (let bufnr of bufnrs) {
                let buf = nvim.createBuffer(bufnr);
                let res = await buf.getVar('coc_diagnostic_info');
                expect(res === null || res === void 0 ? void 0 : res.error).toBe(1);
            }
            collection.dispose();
        });
    });
});
//# sourceMappingURL=diagnosticManager.test.js.map