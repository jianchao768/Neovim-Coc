'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatternType = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const errors_1 = require("../util/errors");
const extensionRegistry_1 = require("../util/extensionRegistry");
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const registry_1 = require("../util/registry");
var PatternType;
(function (PatternType) {
    PatternType[PatternType["Buffer"] = 0] = "Buffer";
    PatternType[PatternType["LanguageServer"] = 1] = "LanguageServer";
    PatternType[PatternType["Global"] = 2] = "Global";
})(PatternType = exports.PatternType || (exports.PatternType = {}));
const logger = (0, logger_1.createLogger)('core-workspaceFolder');
const PatternTypes = [PatternType.Buffer, PatternType.LanguageServer, PatternType.Global];
const checkPatternTimeout = (0, util_1.getConditionValue)(5000, 50);
function toWorkspaceFolder(fsPath) {
    if (!fsPath || !node_1.path.isAbsolute(fsPath))
        return undefined;
    return {
        name: node_1.path.basename(fsPath),
        uri: vscode_uri_1.URI.file(fsPath).toString()
    };
}
const extensionRegistry = registry_1.Registry.as(extensionRegistry_1.Extensions.ExtensionContribution);
class WorkspaceFolderController {
    constructor(configurations) {
        this.configurations = configurations;
        this._onDidChangeWorkspaceFolders = new protocol_1.Emitter();
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        // filetype => patterns
        this.rootPatterns = new Map();
        this._workspaceFolders = [];
        this._tokenSources = new Set();
        events_1.default.on('VimLeavePre', this.cancelAll, this);
        this.updateConfiguration(true);
        this.configurations.onDidChange(e => {
            if (e.affectsConfiguration('workspace') || e.affectsConfiguration('coc.preferences')) {
                this.updateConfiguration(false);
            }
        });
    }
    updateConfiguration(init) {
        const allConfig = this.configurations.initialConfiguration;
        let config = allConfig.get('workspace');
        let oldConfig = allConfig.get('coc.preferences.rootPatterns');
        this.config = {
            rootPatterns: (0, array_1.isFalsyOrEmpty)(oldConfig) ? (0, array_1.toArray)(config.rootPatterns) : oldConfig,
            ignoredFiletypes: (0, array_1.toArray)(config.ignoredFiletypes),
            bottomUpFiletypes: (0, array_1.toArray)(config.bottomUpFiletypes),
            ignoredFolders: (0, array_1.toArray)(config.ignoredFolders),
            workspaceFolderCheckCwd: !!config.workspaceFolderCheckCwd,
            workspaceFolderFallbackCwd: !!config.workspaceFolderFallbackCwd
        };
        if (init) {
            const lspConfig = allConfig.get('languageserver', {});
            this.addServerRootPatterns(lspConfig);
        }
    }
    addServerRootPatterns(lspConfig) {
        for (let key of Object.keys((0, object_1.toObject)(lspConfig))) {
            let config = lspConfig[key];
            let { filetypes, rootPatterns } = config;
            if (Array.isArray(filetypes) && !(0, array_1.isFalsyOrEmpty)(rootPatterns)) {
                filetypes.filter(s => typeof s === 'string').forEach(filetype => {
                    this.addRootPattern(filetype, rootPatterns);
                });
            }
        }
    }
    cancelAll() {
        for (let tokenSource of this._tokenSources) {
            tokenSource.cancel();
        }
    }
    setWorkspaceFolders(folders) {
        if (!folders || !Array.isArray(folders))
            return;
        let arr = folders.map(f => toWorkspaceFolder(f));
        this._workspaceFolders = arr.filter(o => o != null);
    }
    getWorkspaceFolder(uri) {
        if (uri.scheme !== 'file')
            return undefined;
        let folders = Array.from(this._workspaceFolders).map(o => vscode_uri_1.URI.parse(o.uri).fsPath);
        folders.sort((a, b) => b.length - a.length);
        let fsPath = uri.fsPath;
        let folder = folders.find(f => (0, fs_1.isParentFolder)(f, fsPath, true));
        return toWorkspaceFolder(folder);
    }
    getRelativePath(pathOrUri, includeWorkspace) {
        let resource;
        let p = '';
        if (typeof pathOrUri === 'string') {
            resource = vscode_uri_1.URI.file(pathOrUri);
            p = pathOrUri;
        }
        else if (typeof pathOrUri !== 'undefined') {
            resource = pathOrUri;
            p = pathOrUri.fsPath;
        }
        if (!resource)
            return p;
        const folder = this.getWorkspaceFolder(resource);
        if (!folder)
            return p;
        if (typeof includeWorkspace === 'undefined' && this._workspaceFolders) {
            includeWorkspace = this._workspaceFolders.length > 1;
        }
        let result = node_1.path.relative(vscode_uri_1.URI.parse(folder.uri).fsPath, resource.fsPath);
        result = result == '' ? resource.fsPath : result;
        if (includeWorkspace && folder.name) {
            result = `${folder.name}/${result}`;
        }
        return result;
    }
    get workspaceFolders() {
        return this._workspaceFolders;
    }
    addRootPattern(filetype, rootPatterns) {
        var _a;
        let patterns = (_a = this.rootPatterns.get(filetype)) !== null && _a !== void 0 ? _a : [];
        for (let p of rootPatterns) {
            if (!patterns.includes(p)) {
                patterns.push(p);
            }
        }
        this.rootPatterns.set(filetype, patterns);
    }
    resolveRoot(document, cwd, fireEvent, expand) {
        if (document.buftype !== '' || document.schema !== 'file')
            return null;
        let u = vscode_uri_1.URI.parse(document.uri);
        let curr = this.getWorkspaceFolder(u);
        if (curr)
            return vscode_uri_1.URI.parse(curr.uri).fsPath;
        let dir = node_1.path.dirname(u.fsPath);
        let { ignoredFiletypes, ignoredFolders, workspaceFolderCheckCwd, workspaceFolderFallbackCwd, bottomUpFiletypes } = this.config;
        if (ignoredFiletypes === null || ignoredFiletypes === void 0 ? void 0 : ignoredFiletypes.includes(document.filetype))
            return null;
        ignoredFolders = Array.isArray(ignoredFolders) ? ignoredFolders.filter(s => s && s.length > 0).map(s => expand(s)) : [];
        let res = null;
        for (let patternType of PatternTypes) {
            let patterns = this.getRootPatterns(document, patternType);
            if (patterns && patterns.length) {
                let isBottomUp = bottomUpFiletypes.includes('*') || bottomUpFiletypes.includes(document.filetype);
                let root = (0, fs_1.resolveRoot)(dir, patterns, cwd, isBottomUp, workspaceFolderCheckCwd, ignoredFolders);
                if (root) {
                    res = root;
                    break;
                }
            }
        }
        if (workspaceFolderFallbackCwd && !res && !ignoredFolders.includes(cwd) && (0, fs_1.isParentFolder)(cwd, dir, true)) {
            res = cwd;
        }
        if (res)
            this.addWorkspaceFolder(res, fireEvent);
        return res;
    }
    addWorkspaceFolder(folder, fireEvent) {
        let workspaceFolder = toWorkspaceFolder(folder);
        if (!workspaceFolder)
            return undefined;
        if (this._workspaceFolders.findIndex(o => o.uri == workspaceFolder.uri) == -1) {
            this._workspaceFolders.push(workspaceFolder);
            if (fireEvent) {
                this._onDidChangeWorkspaceFolders.fire({
                    added: [workspaceFolder],
                    removed: []
                });
            }
        }
        return workspaceFolder;
    }
    renameWorkspaceFolder(oldPath, newPath) {
        let added = toWorkspaceFolder(newPath);
        if (!added)
            return;
        let idx = this._workspaceFolders.findIndex(f => vscode_uri_1.URI.parse(f.uri).fsPath == oldPath);
        if (idx == -1)
            return;
        let removed = this.workspaceFolders[idx];
        this._workspaceFolders.splice(idx, 1, added);
        this._onDidChangeWorkspaceFolders.fire({
            removed: [removed],
            added: [added]
        });
    }
    removeWorkspaceFolder(fsPath) {
        let removed = toWorkspaceFolder(fsPath);
        if (!removed)
            return;
        let idx = this._workspaceFolders.findIndex(f => f.uri == removed.uri);
        if (idx == -1)
            return;
        this._workspaceFolders.splice(idx, 1);
        this._onDidChangeWorkspaceFolders.fire({
            removed: [removed],
            added: []
        });
    }
    getRootPatterns(document, patternType) {
        if (patternType == PatternType.Buffer)
            return document.getVar('root_patterns', []) || [];
        if (patternType == PatternType.LanguageServer)
            return this.getServerRootPatterns(document.languageId);
        return this.config.rootPatterns;
    }
    reset() {
        this.rootPatterns.clear();
        this._workspaceFolders = [];
    }
    /**
     * Get rootPatterns of filetype by languageserver configuration and extension configuration.
     */
    getServerRootPatterns(filetype) {
        let patterns = extensionRegistry.getRootPatternsByFiletype(filetype);
        patterns = patterns.concat((0, array_1.toArray)(this.rootPatterns.get(filetype)));
        return (0, array_1.distinct)(patterns);
    }
    checkFolder(dir, patterns, token) {
        return (0, fs_1.checkFolder)(dir, patterns, token);
    }
    async checkPatterns(folders, patterns) {
        if ((0, array_1.isFalsyOrEmpty)(folders))
            return false;
        let dirs = folders.map(f => vscode_uri_1.URI.parse(f.uri).fsPath);
        let find = false;
        let tokenSource = new protocol_1.CancellationTokenSource();
        this._tokenSources.add(tokenSource);
        let token = tokenSource.token;
        let timer = setTimeout(() => {
            tokenSource.cancel();
        }, checkPatternTimeout);
        let results = await Promise.allSettled(dirs.map(dir => {
            return this.checkFolder(dir, patterns, token).then(checked => {
                this._tokenSources.delete(tokenSource);
                if (checked) {
                    find = true;
                    clearTimeout(timer);
                    tokenSource.cancel();
                }
            });
        }));
        clearTimeout(timer);
        results.forEach(res => {
            if (res.status === 'rejected' && !(0, errors_1.isCancellationError)(res.reason)) {
                logger.error(`checkPatterns error:`, patterns, res.reason);
            }
        });
        return find;
    }
}
exports.default = WorkspaceFolderController;
//# sourceMappingURL=workspaceFolder.js.map