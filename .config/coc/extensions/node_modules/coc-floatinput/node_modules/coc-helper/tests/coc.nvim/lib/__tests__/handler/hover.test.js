"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const hover_1 = require("../../handler/hover");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importStar(require("../helper"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
let nvim;
let hover;
let disposables = [];
let hoverResult;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    hover = helper_1.default.plugin.getHandler().hover;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    await helper_1.default.createDocument();
    disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
        provideHover: (_doc, _pos, _token) => {
            return hoverResult;
        }
    }));
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
async function getDocumentText() {
    let lines = await nvim.call('getbufline', ['coc://document', 1, '$']);
    return lines.join('\n');
}
describe('Hover', () => {
    describe('utils', () => {
        it('should addDocument', async () => {
            let docs = [];
            (0, hover_1.addDocument)(docs, '', '');
            expect(docs.length).toBe(0);
        });
        it('should check documentation', async () => {
            expect((0, hover_1.isDocumentation)({})).toBe(false);
            expect((0, hover_1.isDocumentation)({ filetype: '', content: '' })).toBe(true);
        });
        it('should readLines', async () => {
            let res = await (0, hover_1.readLines)('file:///not_exists', 0, 1);
            expect(res).toEqual([]);
        });
        it('should addDefinitions', async () => {
            let hovers = [];
            let range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0);
            await (0, hover_1.addDefinitions)(hovers, [undefined, {}, { targetUri: 'file:///not_exists', targetRange: range, targetSelectionRange: range }], '');
            expect(hovers.length).toBe(0);
            let file = await (0, helper_1.createTmpFile)('  foo\n  bar\n', disposables);
            range = vscode_languageserver_protocol_1.Range.create(0, 0, 300, 0);
            await (0, hover_1.addDefinitions)(hovers, [{ targetUri: vscode_uri_1.URI.file(file).toString(), targetRange: range, targetSelectionRange: range }], '');
            expect(hovers.length).toBe(1);
        });
    });
    describe('onHover', () => {
        it('should return false when hover not found', async () => {
            hoverResult = null;
            let res = await hover.onHover('preview');
            expect(res).toBe(false);
        });
        it('should show MarkupContent hover', async () => {
            helper_1.default.updateConfiguration('hover.target', 'preview');
            hoverResult = { contents: { kind: 'plaintext', value: 'my hover' } };
            await helper_1.default.doAction('doHover');
            let res = await getDocumentText();
            expect(res).toMatch('my hover');
        });
        it('should merge hover results', async () => {
            hoverResult = { contents: { kind: 'plaintext', value: 'my hover' } };
            disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
                provideHover: (_doc, _pos, _token) => {
                    return null;
                }
            }));
            disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
                provideHover: (_doc, _pos, _token) => {
                    return { contents: { kind: 'plaintext', value: 'my hover' } };
                }
            }));
            let doc = await workspace_1.default.document;
            let hovers = await languages_1.default.getHover(doc.textDocument, vscode_languageserver_protocol_1.Position.create(0, 0), vscode_languageserver_protocol_1.CancellationToken.None);
            expect(hovers.length).toBe(1);
        });
        it('should show MarkedString hover', async () => {
            hoverResult = { contents: 'string hover' };
            disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
                provideHover: (_doc, _pos, _token) => {
                    return { contents: { language: 'typescript', value: 'language hover' } };
                }
            }));
            await hover.onHover('preview');
            let res = await getDocumentText();
            expect(res).toMatch('string hover');
            expect(res).toMatch('language hover');
        });
        it('should show MarkedString hover array', async () => {
            hoverResult = { contents: ['foo', { language: 'typescript', value: 'bar' }] };
            await hover.onHover('preview');
            let res = await getDocumentText();
            expect(res).toMatch('foo');
            expect(res).toMatch('bar');
        });
        it('should highlight hover range', async () => {
            await nvim.setLine('var');
            await nvim.command('normal! 0');
            hoverResult = { contents: ['foo'], range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3) };
            await hover.onHover('preview');
            let res = await nvim.call('getmatches');
            expect(res.length).toBe(1);
            expect(res[0].group).toBe('CocHoverRange');
            await helper_1.default.waitValue(async () => {
                let res = await nvim.call('getmatches');
                return res.length;
            }, 0);
        });
    });
    describe('previewHover', () => {
        it('should echo hover message', async () => {
            hoverResult = { contents: ['foo'] };
            let res = await hover.onHover('echo');
            expect(res).toBe(true);
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch('foo');
        });
        it('should show hover in float window', async () => {
            hoverResult = { contents: { kind: 'markdown', value: '```typescript\nconst foo:number\n```' } };
            await hover.onHover('float');
            let win = await helper_1.default.getFloat();
            expect(win).toBeDefined();
            let lines = await nvim.eval(`getbufline(winbufnr(${win.id}),1,'$')`);
            expect(lines).toEqual(['const foo:number']);
        });
    });
    describe('getHover', () => {
        it('should get hover from MarkedString array', async () => {
            hoverResult = { contents: ['foo', { language: 'typescript', value: 'bar' }] };
            disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
                provideHover: (_doc, _pos, _token) => {
                    return { contents: { language: 'typescript', value: 'MarkupContent hover' } };
                }
            }));
            disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
                provideHover: (_doc, _pos, _token) => {
                    return { contents: vscode_languageserver_protocol_1.MarkedString.fromPlainText('MarkedString hover') };
                }
            }));
            let res = await helper_1.default.doAction('getHover');
            expect(res.includes('foo')).toBe(true);
            expect(res.includes('bar')).toBe(true);
            expect(res.includes('MarkupContent hover')).toBe(true);
            expect(res.includes('MarkedString hover')).toBe(true);
        });
        it('should filter empty hover message', async () => {
            hoverResult = { contents: [''] };
            disposables.push(languages_1.default.registerHoverProvider([{ language: '*' }], {
                provideHover: (_doc, _pos, _token) => {
                    return { contents: { kind: vscode_languageserver_protocol_1.MarkupKind.PlainText, value: 'value' } };
                }
            }));
            let res = await hover.getHover({ line: 1, col: 2 });
            expect(res).toEqual(['value']);
        });
        it('should throw when buffer not attached', async () => {
            await expect(async () => {
                await hover.getHover({ bufnr: 999, line: 1, col: 2 });
            }).rejects.toThrow(/not created/);
        });
    });
    describe('definitionHover', () => {
        it('should load definition from buffer', async () => {
            hoverResult = { contents: 'string hover' };
            let doc = await helper_1.default.createDocument();
            await nvim.call('cursor', [1, 1]);
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo\nbar')]);
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition() {
                    return [{
                            targetUri: doc.uri,
                            targetRange: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3),
                            targetSelectionRange: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
                        }];
                }
            }));
            await helper_1.default.doAction('definitionHover', 'preview');
            let res = await getDocumentText();
            expect(res).toBe('string hover\n\nfoo\nbar');
        });
        it('should load definition link from file', async () => {
            let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\n');
            hoverResult = { contents: 'string hover', range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3) };
            let doc = await helper_1.default.createDocument();
            await nvim.call('cursor', [1, 1]);
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo\nbar')]);
            disposables.push(languages_1.default.registerDefinitionProvider([{ language: '*' }], {
                provideDefinition() {
                    return [{
                            targetUri: vscode_uri_1.URI.file(fsPath).toString(),
                            targetRange: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3),
                            targetSelectionRange: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
                        }];
                }
            }));
            await hover.definitionHover('preview');
            let res = await getDocumentText();
            expect(res).toBe('string hover\n\nfoo\nbar');
        });
        it('should return false when hover not found', async () => {
            hoverResult = undefined;
            let res = await hover.definitionHover('float');
            expect(res).toBe(false);
        });
    });
});
//# sourceMappingURL=hover.test.js.map