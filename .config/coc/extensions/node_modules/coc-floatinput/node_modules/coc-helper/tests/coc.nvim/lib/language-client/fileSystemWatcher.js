'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemWatcherFeature = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../util");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
const debounceTime = (0, util_1.getConditionValue)(200, 20);
class FileSystemWatcherFeature {
    constructor(_client) {
        this._client = _client;
        this._watchers = new Map();
        this._fileEventsMap = new Map();
        this.debouncedFileNotify = (0, node_1.debounce)(() => {
            void this._notifyFileEvent();
        }, debounceTime);
    }
    async _notifyFileEvent() {
        let map = this._fileEventsMap;
        if (map.size == 0)
            return;
        await this._client.forceDocumentSync();
        this._client.sendNotification(protocol_1.DidChangeWatchedFilesNotification.type, { changes: Array.from(map.values()) }).catch(error => {
            this._client.error(`Notify file events failed.`, error);
        });
        map.clear();
    }
    notifyFileEvent(event) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let self = this;
        function didChangeWatchedFile(event) {
            self._fileEventsMap.set(event.uri, event);
            self.debouncedFileNotify();
        }
        const workSpaceMiddleware = this._client.middleware.workspace;
        if (workSpaceMiddleware === null || workSpaceMiddleware === void 0 ? void 0 : workSpaceMiddleware.didChangeWatchedFile) {
            void workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile);
        }
        else {
            didChangeWatchedFile(event);
        }
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._watchers.size > 0 };
    }
    get registrationType() {
        return protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').relativePatternSupport = true;
    }
    initialize(_capabilities, _documentSelector) {
        var _a;
        let fileEvents = (_a = this._client.clientOptions.synchronize) === null || _a === void 0 ? void 0 : _a.fileEvents;
        if (!fileEvents)
            return;
        let watchers = Array.isArray(fileEvents) ? fileEvents : [fileEvents];
        let disposables = [];
        for (let fileSystemWatcher of watchers) {
            disposables.push(fileSystemWatcher);
            this.hookListeners(fileSystemWatcher, !fileSystemWatcher.ignoreCreateEvents, !fileSystemWatcher.ignoreChangeEvents, !fileSystemWatcher.ignoreDeleteEvents, disposables);
        }
        this._watchers.set(UUID.generateUuid(), disposables);
    }
    register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
            let globPattern;
            if (Is.string(watcher.globPattern)) {
                globPattern = watcher.globPattern;
            }
            else if (protocol_1.RelativePattern.is(watcher.globPattern)) {
                globPattern = cv.asRelativePattern(watcher.globPattern);
            }
            else {
                continue;
            }
            let watchCreate = true;
            let watchChange = true;
            let watchDelete = true;
            if (watcher.kind != null) {
                watchCreate = (watcher.kind & protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & protocol_1.WatchKind.Delete) !== 0;
            }
            let fileSystemWatcher = workspace_1.default.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        // TODO rename support
        if (watchCreate) {
            fileSystemWatcher.onDidCreate(resource => this.notifyFileEvent({
                uri: cv.asUri(resource),
                type: protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange(resource => this.notifyFileEvent({
                uri: cv.asUri(resource),
                type: protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete(resource => this.notifyFileEvent({
                uri: cv.asUri(resource),
                type: protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
            this._watchers.delete(id);
        }
    }
    dispose() {
        this._fileEventsMap.clear();
        this.debouncedFileNotify.clear();
        this._watchers.forEach(disposables => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
exports.FileSystemWatcherFeature = FileSystemWatcherFeature;
//# sourceMappingURL=fileSystemWatcher.js.map