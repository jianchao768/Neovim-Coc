"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ansi_styles_1 = tslib_1.__importDefault(require("ansi-styles"));
const events_1 = require("events");
const basic_1 = tslib_1.__importDefault(require("../../list/basic"));
const manager_1 = tslib_1.__importDefault(require("../../list/manager"));
const worker_1 = require("../../list/worker");
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let items = [];
class DataList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'data';
    }
    loadItems() {
        return Promise.resolve(items);
    }
}
class EmptyList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'empty';
    }
    loadItems() {
        let emitter = new events_1.EventEmitter();
        setTimeout(() => {
            emitter.emit('end');
        }, 20);
        return emitter;
    }
}
class IntervalTaskList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'task';
        this.timeout = 3000;
    }
    loadItems(_context, token) {
        let emitter = new events_1.EventEmitter();
        let i = 0;
        let interval = setInterval(() => {
            emitter.emit('data', { label: i.toFixed() });
            i++;
        }, 20);
        emitter.dispose = () => {
            clearInterval(interval);
            emitter.emit('end');
        };
        token.onCancellationRequested(() => {
            emitter.dispose();
        });
        return emitter;
    }
}
class DelayTask extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'delay';
        this.interactive = true;
    }
    loadItems(_context, token) {
        let emitter = new events_1.EventEmitter();
        let disposed = false;
        setTimeout(() => {
            if (disposed)
                return;
            emitter.emit('data', { label: 'ahead' });
        }, 10);
        setTimeout(() => {
            if (disposed)
                return;
            emitter.emit('data', { label: 'abort' });
        }, 20);
        emitter.dispose = () => {
            disposed = true;
            emitter.emit('end');
        };
        token.onCancellationRequested(() => {
            emitter.dispose();
        });
        return emitter;
    }
}
class InteractiveList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'test';
        this.interactive = true;
    }
    loadItems(context, _token) {
        return Promise.resolve([{
                label: ansi_styles_1.default.magenta.open + (context.input || '') + ansi_styles_1.default.magenta.close
            }]);
    }
}
class ErrorList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'error';
        this.interactive = true;
    }
    loadItems(_context, _token) {
        return Promise.reject(new Error('test error'));
    }
}
class ErrorTaskList extends basic_1.default {
    constructor() {
        super(...arguments);
        this.name = 'task';
    }
    loadItems(_context, _token) {
        let emitter = new events_1.EventEmitter();
        let timeout = setTimeout(() => {
            emitter.emit('error', new Error('task error'));
        }, 100);
        emitter.dispose = () => {
            clearTimeout(timeout);
        };
        return emitter;
    }
}
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    manager_1.default.reset();
    await helper_1.default.reset();
});
describe('util', () => {
    it('should get index', () => {
        expect((0, worker_1.indexOf)('Abc', 'a', true, false)).toBe(0);
        expect((0, worker_1.indexOf)('Abc', 'A', false, false)).toBe(0);
        expect((0, worker_1.indexOf)('abc', 'A', false, true)).toBe(0);
    });
    it('should parse input with space', () => {
        let res = (0, worker_1.parseInput)('a b');
        expect(res).toEqual(['a', 'b']);
        res = (0, worker_1.parseInput)('a b ');
        expect(res).toEqual(['a', 'b']);
        res = (0, worker_1.parseInput)('ab ');
        expect(res).toEqual(['ab']);
    });
    it('should parse input with escaped space', () => {
        let res = (0, worker_1.parseInput)('a\\ b');
        expect(res).toEqual(['a b']);
    });
    it('should convert item label', () => {
        expect((0, worker_1.convertItemLabel)({ label: 'foo\nbar\nx' }).label).toBe('foo');
        const redOpen = '\x1B[31m';
        const redClose = '\x1B[39m';
        let label = redOpen + 'foo' + redClose;
        expect((0, worker_1.convertItemLabel)({ label }).label).toBe('foo');
    });
    it('should convert input', () => {
        expect((0, worker_1.toInputs)('foo bar', false)).toEqual(['foo bar']);
    });
});
describe('list worker', () => {
    it('should work with long running task', async () => {
        disposables.push(manager_1.default.registerList(new IntervalTaskList()));
        await manager_1.default.start(['task']);
        await manager_1.default.session.worker.drawItems();
        await manager_1.default.session.ui.ready;
        await helper_1.default.waitValue(() => {
            var _a;
            return ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.length) > 2;
        }, true);
        await manager_1.default.cancel();
    });
    it('should sort by sortText', async () => {
        items = [{
                label: 'abc',
                sortText: 'b'
            }, {
                label: 'ade',
                sortText: 'a'
            }];
        disposables.push(manager_1.default.registerList(new DataList()));
        await manager_1.default.start(['data']);
        await manager_1.default.session.ui.ready;
        await helper_1.default.listInput('a');
        await helper_1.default.waitFor('getline', ['.'], 'ade');
        await manager_1.default.cancel();
    });
    it('should ready with undefined result', async () => {
        items = undefined;
        disposables.push(manager_1.default.registerList(new DataList()));
        await manager_1.default.start(['data']);
        await manager_1.default.session.ui.ready;
        await manager_1.default.cancel();
    });
    it('should show empty line for empty task', async () => {
        disposables.push(manager_1.default.registerList(new EmptyList()));
        await manager_1.default.start(['empty']);
        await manager_1.default.session.ui.ready;
        let line = await nvim.call('getline', [1]);
        expect(line).toMatch('No results');
        await manager_1.default.cancel();
    });
    it('should cancel task by use CancellationToken', async () => {
        var _a, _b, _c;
        disposables.push(manager_1.default.registerList(new IntervalTaskList()));
        await manager_1.default.start(['task']);
        expect((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.worker.isLoading).toBe(true);
        await helper_1.default.listInput('1');
        await helper_1.default.wait(50);
        (_b = manager_1.default.session) === null || _b === void 0 ? void 0 : _b.stop();
        expect((_c = manager_1.default.session) === null || _c === void 0 ? void 0 : _c.worker.isLoading).toBe(false);
    });
    it('should render slow interactive list', async () => {
        disposables.push(manager_1.default.registerList(new DelayTask()));
        await manager_1.default.start(['delay']);
        await helper_1.default.listInput('a');
        await helper_1.default.waitFor('getline', [2], 'abort');
    });
    it('should work with interactive list', async () => {
        var _a;
        disposables.push(manager_1.default.registerList(new InteractiveList()));
        await manager_1.default.start(['-I', 'test']);
        await ((_a = manager_1.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
        expect(manager_1.default.isActivated).toBe(true);
        await helper_1.default.listInput('f');
        await helper_1.default.listInput('a');
        await helper_1.default.listInput('x');
        await helper_1.default.waitFor('getline', ['.'], 'fax');
        await manager_1.default.cancel(true);
    });
    it('should not activate on load error', async () => {
        disposables.push(manager_1.default.registerList(new ErrorList()));
        await manager_1.default.start(['test']);
        expect(manager_1.default.isActivated).toBe(false);
    });
    it('should deactivate on task error', async () => {
        disposables.push(manager_1.default.registerList(new ErrorTaskList()));
        await manager_1.default.start(['task']);
        await helper_1.default.waitValue(() => {
            return manager_1.default.isActivated;
        }, false);
    });
});
//# sourceMappingURL=worker.test.js.map