'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTimestamp = exports.stringifyLogLevel = exports.FileLogger = exports.format = exports.textToLogLevel = exports.toThreeDigits = exports.toTwoDigits = exports.DEFAULT_LOG_LEVEL = exports.LogLevel = void 0;
const node_1 = require("../util/node");
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Off"] = 5] = "Off";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
const yellowOpen = '\x1B[33m';
const yellowClose = '\x1B[39m';
exports.DEFAULT_LOG_LEVEL = LogLevel.Info;
const toTwoDigits = (v) => v < 10 ? `0${v}` : v.toString();
exports.toTwoDigits = toTwoDigits;
const toThreeDigits = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v.toString();
exports.toThreeDigits = toThreeDigits;
function textToLogLevel(level) {
    let str = level.toLowerCase();
    switch (str) {
        case 'trace':
            return LogLevel.Trace;
        case 'debug':
            return LogLevel.Debug;
        case 'info':
            return LogLevel.Info;
        case 'error':
            return LogLevel.Error;
        case 'warn':
        case 'warning':
            return LogLevel.Warning;
        case 'off':
            return LogLevel.Off;
        default:
            return LogLevel.Info;
    }
}
exports.textToLogLevel = textToLogLevel;
function format(args, depth = 2, color = false, hidden = false) {
    let result = '';
    for (let i = 0; i < args.length; i++) {
        let a = args[i];
        if (typeof a === 'object') {
            try {
                a = (0, node_1.inspect)(a, hidden, depth, color);
            }
            catch (e) { }
        }
        if (color && (typeof a === 'boolean' || typeof a === 'number')) {
            a = `${yellowOpen}${a}${yellowClose}`;
        }
        result += (i > 0 ? ' ' : '') + a;
    }
    return result;
}
exports.format = format;
class AbstractLogger {
    constructor() {
        this.level = exports.DEFAULT_LOG_LEVEL;
    }
    setLevel(level) {
        if (this.level !== level) {
            this.level = level;
        }
    }
    getLevel() {
        return this.level;
    }
}
class FileLogger extends AbstractLogger {
    constructor(fsPath, level, config) {
        super();
        this.fsPath = fsPath;
        this.backupIndex = 1;
        this.useConsole = false;
        this.loggers = new Map();
        this.config = Object.assign({
            userFormatters: true,
            color: false,
            depth: 2,
            showHidden: false
        }, config);
        this.setLevel(level);
        this.promise = this.initialize();
    }
    switchConsole() {
        this.useConsole = !this.useConsole;
    }
    format(args) {
        let { color, showHidden, depth } = this.config;
        return format(args, depth, color, showHidden);
    }
    createLogger(scope) {
        let logger = this.loggers.has(scope) ? this.loggers.get(scope) : {
            category: scope,
            mark: () => {
                // not used
            },
            getLevel: () => {
                return this.getLevel();
            },
            trace: (...args) => {
                if (this.level <= LogLevel.Trace) {
                    this._log(LogLevel.Trace, scope, args, this.getCurrentTimestamp());
                }
            },
            debug: (...args) => {
                if (this.level <= LogLevel.Debug) {
                    this._log(LogLevel.Debug, scope, args, this.getCurrentTimestamp());
                }
            },
            log: (...args) => {
                if (this.level <= LogLevel.Info) {
                    this._log(LogLevel.Info, scope, args, this.getCurrentTimestamp());
                }
            },
            info: (...args) => {
                if (this.level <= LogLevel.Info) {
                    this._log(LogLevel.Info, scope, args, this.getCurrentTimestamp());
                }
            },
            warn: (...args) => {
                if (this.level <= LogLevel.Warning) {
                    this._log(LogLevel.Warning, scope, args, this.getCurrentTimestamp());
                }
            },
            error: (...args) => {
                if (this.level <= LogLevel.Error) {
                    this._log(LogLevel.Error, scope, args, this.getCurrentTimestamp());
                }
            },
            fatal: (...args) => {
                if (this.level <= LogLevel.Error) {
                    this._log(LogLevel.Error, scope, args, this.getCurrentTimestamp());
                }
            },
            /**
             * An operation to flush the contents. Can be synchronous.
             */
            flush: () => {
                return this.promise;
            }
        };
        this.loggers.set(scope, logger);
        return logger;
    }
    async initialize() {
        return Promise.resolve();
    }
    shouldBackup(size) {
        return size > MAX_FILE_SIZE;
    }
    _log(level, scope, args, time) {
        if (this.useConsole) {
            let method = level === LogLevel.Error ? 'error' : 'log';
            console[method](`${stringifyLogLevel(level)} [${scope}]`, format(args, null, true));
        }
        else {
            let message = this.format(args);
            this.promise = this.promise.then(() => {
                let fn = async () => {
                    let text;
                    if (this.config.userFormatters !== false) {
                        let parts = [time, stringifyLogLevel(level), `(pid:${process.pid})`, `[${scope}]`];
                        text = `${parts.join(' ')} - ${message}\n`;
                    }
                    else {
                        text = message;
                    }
                    await (0, node_1.promisify)(node_1.fs.appendFile)(this.fsPath, text, { encoding: 'utf8', flag: 'a+' });
                    let stat = await (0, node_1.promisify)(node_1.fs.stat)(this.fsPath);
                    if (this.shouldBackup(stat.size)) {
                        let newFile = this.getBackupResource();
                        await (0, node_1.promisify)(node_1.fs.rename)(this.fsPath, newFile);
                    }
                };
                return fn();
            }).catch(err => {
                !global.REVISION && console.error(err);
            });
        }
    }
    getCurrentTimestamp() {
        const currentTime = new Date();
        return `${currentTime.getFullYear()}-${(0, exports.toTwoDigits)(currentTime.getMonth() + 1)}-${(0, exports.toTwoDigits)(currentTime.getDate())}T${getTimestamp(currentTime)}`;
    }
    getBackupResource() {
        this.backupIndex = this.backupIndex > 5 ? 1 : this.backupIndex;
        return node_1.path.join(node_1.path.dirname(this.fsPath), `${node_1.path.basename(this.fsPath)}_${this.backupIndex++}`);
    }
}
exports.FileLogger = FileLogger;
function stringifyLogLevel(level) {
    switch (level) {
        case LogLevel.Debug: return 'DEBUG';
        case LogLevel.Error: return 'ERROR';
        case LogLevel.Info: return 'INFO';
        case LogLevel.Trace: return 'TRACE';
        case LogLevel.Warning: return 'WARN';
    }
    return '';
}
exports.stringifyLogLevel = stringifyLogLevel;
function getTimestamp(date) {
    return `${(0, exports.toTwoDigits)(date.getHours())}:${(0, exports.toTwoDigits)(date.getMinutes())}:${(0, exports.toTwoDigits)(date.getSeconds())}.${(0, exports.toThreeDigits)(date.getMilliseconds())}`;
}
exports.getTimestamp = getTimestamp;
//# sourceMappingURL=log.js.map