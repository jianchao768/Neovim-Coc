'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHighlightPart = exports.NAMESPACE = exports.HLGROUP_PREFIX = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languages_1 = tslib_1.__importStar(require("../../languages"));
const logger_1 = require("../../logger");
const regions_1 = tslib_1.__importDefault(require("../../model/regions"));
const util_1 = require("../../util");
const array_1 = require("../../util/array");
const errors_1 = require("../../util/errors");
const index_1 = require("../../util/index");
const numbers_1 = require("../../util/numbers");
const protocol_1 = require("../../util/protocol");
const string_1 = require("../../util/string");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const logger = (0, logger_1.createLogger)('semanticTokens-buffer');
const yieldEveryMilliseconds = (0, util_1.getConditionValue)(15, 5);
exports.HLGROUP_PREFIX = 'CocSem';
exports.NAMESPACE = 'semanticTokens';
// should be higher than document debounce
const debounceInterval = (0, util_1.getConditionValue)(100, 20);
const requestDelay = (0, util_1.getConditionValue)(500, 20);
const highlightGroupMap = new Map();
class SemanticTokensBuffer {
    constructor(nvim, doc, staticConfig) {
        this.nvim = nvim;
        this.doc = doc;
        this.staticConfig = staticConfig;
        this._dirty = false;
        this.regions = new regions_1.default();
        this._onDidRefresh = new protocol_1.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.highlight = (0, util_1.delay)(() => {
            void this.doHighlight();
        }, debounceInterval);
        if (this.hasProvider)
            this.highlight();
    }
    get config() {
        if (this._config)
            return this._config;
        this.loadConfiguration();
        return this._config;
    }
    loadConfiguration() {
        let config = workspace_1.default.getConfiguration('semanticTokens', this.doc);
        let changed = this._config != null && this._config.enable != config.enable;
        this._config = {
            enable: config.get('enable'),
            highlightPriority: config.get('highlightPriority'),
            incrementTypes: config.get('incrementTypes'),
            combinedModifiers: config.get('combinedModifiers')
        };
        if (changed) {
            if (this._config.enable) {
                this.highlight();
            }
            else {
                this.clearHighlight();
            }
        }
    }
    get configEnabled() {
        let { enable } = this.config;
        let { filetypes } = this.staticConfig;
        // should be null when not specified
        if (Array.isArray(filetypes))
            return filetypes.includes('*') || filetypes.includes(this.doc.filetype);
        return enable;
    }
    get bufnr() {
        return this.doc.bufnr;
    }
    onChange() {
        // need debounce for document synchronize
        this.highlight();
    }
    onTextChange() {
        this.cancel();
    }
    async forceHighlight() {
        this.clearHighlight();
        this.cancel();
        await this.doHighlight(true);
    }
    async onShown() {
        // Should be refreshed by onCursorMoved
        if (this.shouldRangeHighlight)
            return;
        const { doc } = this;
        if (doc.dirty || doc.version === this._version)
            return;
        await this.doHighlight(false, true);
    }
    get hasProvider() {
        return languages_1.default.hasProvider(languages_1.ProviderName.SemanticTokens, this.doc)
            || languages_1.default.hasProvider(languages_1.ProviderName.SemanticTokensRange, this.doc);
    }
    get hasLegend() {
        let { textDocument } = this.doc;
        return languages_1.default.getLegend(textDocument) != null || languages_1.default.getLegend(textDocument, true) != null;
    }
    get rangeProviderOnly() {
        return !languages_1.default.hasProvider(languages_1.ProviderName.SemanticTokens, this.doc)
            && languages_1.default.hasProvider(languages_1.ProviderName.SemanticTokensRange, this.doc);
    }
    get shouldRangeHighlight() {
        let { textDocument } = this.doc;
        return languages_1.default.hasProvider(languages_1.ProviderName.SemanticTokensRange, textDocument) && this.previousResults == null;
    }
    get lineCount() {
        return this.doc.lineCount;
    }
    /**
     * Get current highlight items
     */
    get highlights() {
        if (!this._highlights)
            return undefined;
        return this._highlights[1];
    }
    get buffer() {
        return this.nvim.createBuffer(this.bufnr);
    }
    get enabled() {
        if (!this.configEnabled || !workspace_1.default.env.updateHighlight || !this.hasLegend)
            return false;
        return this.hasProvider;
    }
    checkState() {
        if (!workspace_1.default.env.updateHighlight)
            throw new Error(`Can't perform highlight update, highlight update requires vim >= 8.1.1719 or neovim >= 0.5.0`);
        if (!this.configEnabled)
            throw new Error(`Semantic tokens highlight not enabled for current filetype: ${this.doc.filetype}`);
        if (this.staticConfig.highlightGroups.length === 0)
            throw new Error(`Unable to find highlight groups starts with CocSem`);
        if (!this.hasProvider || !this.hasLegend)
            throw new Error(`SemanticTokens provider not found for ${this.doc.uri}`);
    }
    async getTokenRanges(tokens, legend, token) {
        let currentLine = 0;
        let currentCharacter = 0;
        let highlights = [];
        let toBytes;
        let textDocument = this.doc.textDocument;
        let tickStart = Date.now();
        for (let i = 0; i < tokens.length; i += 5) {
            if (i == 0 || Date.now() - tickStart > yieldEveryMilliseconds) {
                await (0, index_1.waitImmediate)();
                if (token.isCancellationRequested)
                    break;
                tickStart = Date.now();
            }
            const deltaLine = tokens[i];
            const deltaCharacter = tokens[i + 1];
            const length = tokens[i + 2];
            const tokenType = legend.tokenTypes[tokens[i + 3]];
            const tokenModifiers = legend.tokenModifiers.filter((_, m) => tokens[i + 4] & (1 << m));
            const lnum = currentLine + deltaLine;
            if (deltaLine != 0 || !toBytes) {
                toBytes = (0, string_1.bytes)((0, string_1.toText)(textDocument.lines[lnum]));
            }
            const sc = deltaLine === 0 ? currentCharacter + deltaCharacter : deltaCharacter;
            const ec = sc + length;
            currentLine = lnum;
            currentCharacter = sc;
            this.addHighlightItems(highlights, [lnum, toBytes(sc), toBytes(ec)], tokenType, tokenModifiers);
        }
        if (token.isCancellationRequested)
            return null;
        return highlights;
    }
    /**
     * Single line only.
     */
    addHighlightItems(highlights, range, tokenType, tokenModifiers) {
        let { combinedModifiers } = this.config;
        let { highlightGroups } = this.staticConfig;
        let highlightGroup;
        let combine = false;
        // Compose highlight group CocSem + modifier + type
        for (let item of tokenModifiers) {
            let hlGroup = exports.HLGROUP_PREFIX + toHighlightPart(item) + toHighlightPart(tokenType);
            if (highlightGroups.includes(hlGroup)) {
                combine = combinedModifiers.includes(item);
                highlightGroup = hlGroup;
                break;
            }
        }
        if (!highlightGroup) {
            for (let modifier of tokenModifiers) {
                let hlGroup = exports.HLGROUP_PREFIX + toHighlightPart(modifier);
                if (highlightGroups.includes(hlGroup)) {
                    highlightGroup = hlGroup;
                    combine = combinedModifiers.includes(modifier);
                    break;
                }
            }
        }
        if (!highlightGroup) {
            let hlGroup = exports.HLGROUP_PREFIX + toHighlightPart(tokenType);
            if (highlightGroups.includes(hlGroup)) {
                highlightGroup = hlGroup;
            }
        }
        highlights.push({
            range,
            tokenType,
            combine,
            hlGroup: highlightGroup,
            tokenModifiers,
        });
    }
    toHighlightItems(highlights, startLine, endLine) {
        let { incrementTypes } = this.config;
        let filter = typeof startLine === 'number' && typeof endLine === 'number';
        let res = [];
        for (let hi of highlights) {
            if (!hi.hlGroup)
                continue;
            let lnum = hi.range[0];
            if (filter && (lnum < startLine || lnum >= endLine))
                continue;
            let item = {
                lnum,
                hlGroup: hi.hlGroup,
                colStart: hi.range[1],
                colEnd: hi.range[2],
                combine: hi.combine
            };
            if (incrementTypes.includes(hi.tokenType)) {
                item.end_incl = true;
                item.start_incl = true;
            }
            res.push(item);
        }
        return res;
    }
    async doHighlight(forceFull = false, onShown = false) {
        var _a;
        this.cancel();
        if (!this.enabled || (!onShown && !workspace_1.default.editors.isVisible(this.bufnr)))
            return;
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        if (this.shouldRangeHighlight) {
            let rangeTokenSource = this.rangeTokenSource = new protocol_1.CancellationTokenSource();
            let rangeToken = rangeTokenSource.token;
            await this.doRangeHighlight(rangeToken);
            if (!rangeToken.isCancellationRequested)
                this.rangeTokenSource = undefined;
            if (rangeToken.isCancellationRequested && this.rangeProviderOnly)
                return;
        }
        if (token.isCancellationRequested)
            return;
        const { doc } = this;
        const version = doc.version;
        let tokenRanges;
        // TextDocument not changed, need perform highlight since lines possible replaced.
        if (version === ((_a = this.previousResults) === null || _a === void 0 ? void 0 : _a.version)) {
            if (this._highlights && this._highlights[0] == version) {
                tokenRanges = this._highlights[1];
            }
            else {
                // possible cancelled.
                const tokens = this.previousResults.tokens;
                const legend = languages_1.default.getLegend(doc.textDocument);
                tokenRanges = await this.getTokenRanges(tokens, legend, token);
            }
        }
        else {
            tokenRanges = await this.sendRequest(() => {
                return this.requestAllHighlights(token, forceFull);
            }, token);
        }
        // request cancelled or can't work
        if (token.isCancellationRequested || !tokenRanges)
            return;
        this._highlights = [version, tokenRanges];
        if (!this._dirty || tokenRanges.length < 200) {
            let items = this.toHighlightItems(tokenRanges);
            let diff = await window_1.default.diffHighlights(this.bufnr, exports.NAMESPACE, items, undefined, token);
            if (token.isCancellationRequested || !diff)
                return;
            this._dirty = true;
            this._version = version;
            const priority = this.config.highlightPriority;
            await window_1.default.applyDiffHighlights(this.bufnr, exports.NAMESPACE, priority, diff);
        }
        else {
            this.regions.clear();
            await this.highlightRegions(token);
        }
        if (!token.isCancellationRequested)
            this.tokenSource = undefined;
        this._onDidRefresh.fire();
    }
    async sendRequest(fn, token) {
        try {
            return await fn();
        }
        catch (e) {
            if (!token.isCancellationRequested) {
                if (e instanceof errors_1.CancellationError) {
                    this.highlight(requestDelay);
                }
                else {
                    logger.error('Error on request semanticTokens: ', e);
                }
            }
            return undefined;
        }
    }
    /**
     * Perform range highlight request and update.
     */
    async doRangeHighlight(token) {
        let { version } = this.doc;
        let res = await this.sendRequest(() => {
            return this.requestRangeHighlights(token);
        }, token);
        if (res == null || token.isCancellationRequested)
            return;
        const { highlights, start, end } = res;
        if (this.rangeProviderOnly || !this.previousResults) {
            if (!this._highlights || version !== this._highlights[0]) {
                this._highlights = [version, []];
            }
            let tokenRanges = this._highlights[1];
            let usedLines = tokenRanges.reduce((p, c) => p.add(c.range[0]), new Set());
            highlights.forEach(hi => {
                if (!usedLines.has(hi.range[0])) {
                    tokenRanges.push(hi);
                }
            });
        }
        const items = this.toHighlightItems(highlights);
        let diff = await window_1.default.diffHighlights(this.bufnr, exports.NAMESPACE, items, [start, end], token);
        if (diff) {
            const priority = this.config.highlightPriority;
            await window_1.default.applyDiffHighlights(this.bufnr, exports.NAMESPACE, priority, diff, true);
            this._dirty = true;
        }
    }
    /**
     * highlight current visible regions
     */
    async highlightRegions(token, skipCheck = false) {
        let { regions, highlights, config, lineCount, bufnr } = this;
        if (!highlights)
            return;
        let spans = await this.nvim.call('coc#window#visible_ranges', [bufnr]);
        if (token.isCancellationRequested || spans.length === 0)
            return;
        let height = workspace_1.default.env.lines;
        spans.forEach(o => {
            let s = o[0];
            o[0] = Math.max(0, Math.floor(s - height * 1.5));
            o[1] = Math.min(lineCount, Math.ceil(o[1] + height * 1.5), s + height * 2);
        });
        for (let [start, end] of regions_1.default.mergeSpans(spans)) {
            if (!skipCheck && regions.has(start, end))
                continue;
            let items = this.toHighlightItems(highlights, start, end);
            let diff = await window_1.default.diffHighlights(bufnr, exports.NAMESPACE, items, [start, end], token);
            if (token.isCancellationRequested)
                break;
            regions.add(start, end);
            let priority = config.highlightPriority;
            if (diff)
                void window_1.default.applyDiffHighlights(bufnr, exports.NAMESPACE, priority, diff, true);
        }
    }
    async onCursorMoved() {
        this.cancel(true);
        if (!this.enabled || this.doc.dirty)
            return;
        let rangeTokenSource = this.rangeTokenSource = new protocol_1.CancellationTokenSource();
        let token = rangeTokenSource.token;
        await (0, index_1.wait)(debounceInterval);
        if (token.isCancellationRequested)
            return;
        if (this.shouldRangeHighlight) {
            await this.doRangeHighlight(token);
        }
        else {
            await this.highlightRegions(token);
        }
        if (!token.isCancellationRequested)
            this.rangeTokenSource = undefined;
    }
    /**
     * Request highlights for visible range.
     */
    async requestRangeHighlights(token) {
        let { nvim, doc } = this;
        let region = await nvim.call('coc#window#visible_range', [this.bufnr]);
        if (!region || token.isCancellationRequested)
            return null;
        let endLine = Math.min(region[0] + workspace_1.default.env.lines * 2, region[1] + workspace_1.default.env.lines, doc.lineCount);
        let range = vscode_languageserver_types_1.Range.create(region[0] - 1, 0, endLine, 0);
        let res = await languages_1.default.provideDocumentRangeSemanticTokens(doc.textDocument, range, token);
        if (!res || !vscode_languageserver_types_1.SemanticTokens.is(res) || token.isCancellationRequested)
            return null;
        let legend = languages_1.default.getLegend(doc.textDocument, true);
        let highlights = await this.getTokenRanges(res.data, legend, token);
        if (!highlights)
            return null;
        return { highlights, start: region[0] - 1, end: region[1] };
    }
    /**
     * Request highlights from provider, return undefined when can't request or request cancelled
     * Use range provider only when not semanticTokens provider exists.
     */
    async requestAllHighlights(token, forceFull) {
        const textDocument = this.doc.textDocument;
        const legend = languages_1.default.getLegend(textDocument);
        const hasEditProvider = languages_1.default.hasSemanticTokensEdits(textDocument);
        const previousResult = forceFull ? null : this.previousResults;
        const version = textDocument.version;
        let result;
        if (hasEditProvider && (previousResult === null || previousResult === void 0 ? void 0 : previousResult.resultId)) {
            result = await languages_1.default.provideDocumentSemanticTokensEdits(textDocument, previousResult.resultId, token);
        }
        else {
            result = await languages_1.default.provideDocumentSemanticTokens(textDocument, token);
        }
        if (token.isCancellationRequested || result == null)
            return;
        let tokens = [];
        if (vscode_languageserver_types_1.SemanticTokens.is(result)) {
            tokens = result.data;
        }
        else if (previousResult && Array.isArray(result.edits)) {
            tokens = previousResult.tokens;
            result.edits.forEach(e => {
                tokens.splice(e.start, (0, numbers_1.toNumber)(e.deleteCount), ...(0, array_1.toArray)(e.data));
            });
        }
        this.previousResults = { resultId: result.resultId, tokens, version };
        return await this.getTokenRanges(tokens, legend, token);
    }
    clearHighlight() {
        this.previousResults = undefined;
        this._highlights = undefined;
        this.regions.clear();
        this.buffer.clearNamespace(exports.NAMESPACE);
    }
    abandonResult() {
        this.previousResults = undefined;
    }
    cancel(rangeOnly = false) {
        if (this.rangeTokenSource) {
            this.rangeTokenSource.cancel();
            this.rangeTokenSource = null;
        }
        if (rangeOnly)
            return;
        this.regions.clear();
        this.highlight.clear();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    dispose() {
        this.cancel();
        this.clearHighlight();
        this._onDidRefresh.dispose();
    }
}
exports.default = SemanticTokensBuffer;
function toHighlightPart(token) {
    if (!token)
        return '';
    if (highlightGroupMap.has(token))
        return highlightGroupMap.get(token);
    let chars = [];
    for (let i = 0; i < token.length; i++) {
        let ch = token[i];
        ch = (0, string_1.isHighlightGroupCharCode)(ch.charCodeAt(0)) ? ch : '_';
        chars.push(i == 0 ? ch.toUpperCase() : ch);
    }
    let part = chars.join('');
    highlightGroupMap.set(token, part);
    return part;
}
exports.toHighlightPart = toHighlightPart;
//# sourceMappingURL=buffer.js.map