'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldAutoApply = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const manager_1 = tslib_1.__importDefault(require("../diagnostic/manager"));
const languages_1 = tslib_1.__importDefault(require("../languages"));
const numbers_1 = require("../util/numbers");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
/**
 * Handle codeActions related methods.
 */
class CodeActions {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        handler.addDisposable(commands_1.default.registerCommand('editor.action.organizeImport', async () => {
            let succeed = await this.organizeImport();
            if (!succeed)
                void window_1.default.showWarningMessage(`Organize import action not found`);
        }));
        commands_1.default.titles.set('editor.action.organizeImport', 'Run organize import code action, show warning when not exists');
    }
    async codeActionRange(start, end, only) {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let line = doc.getline(end - 1);
        let range = vscode_languageserver_types_1.Range.create(start - 1, 0, end - 1, line.length);
        let codeActions = await this.getCodeActions(doc, range, only ? [only] : null);
        codeActions = codeActions.filter(o => !o.disabled);
        if (!codeActions || codeActions.length == 0) {
            void window_1.default.showWarningMessage(`No${only ? ' ' + only : ''} code action available`);
            return;
        }
        let idx = await window_1.default.showMenuPicker(codeActions.map(o => o.title), 'Choose action');
        let action = codeActions[idx];
        if (action)
            await this.applyCodeAction(action);
    }
    async organizeImport() {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let actions = await this.getCodeActions(doc, undefined, [vscode_languageserver_types_1.CodeActionKind.SourceOrganizeImports]);
        if (actions && actions.length) {
            await this.applyCodeAction(actions[0]);
            return true;
        }
        return false;
    }
    async getCodeActions(doc, range, only) {
        range = range !== null && range !== void 0 ? range : vscode_languageserver_types_1.Range.create(0, 0, doc.lineCount, 0);
        let diagnostics = manager_1.default.getDiagnosticsInRange(doc.textDocument, range);
        let context = { diagnostics, triggerKind: vscode_languageserver_types_1.CodeActionTriggerKind.Invoked };
        if (only && Array.isArray(only))
            context.only = only;
        let codeActions = await this.handler.withRequestToken('code action', token => {
            return languages_1.default.getCodeActions(doc.textDocument, range, context, token);
        });
        if (!codeActions || codeActions.length == 0)
            return [];
        codeActions.sort((a, b) => {
            if (a.disabled && !b.disabled)
                return 1;
            if (b.disabled && !a.disabled)
                return -1;
            if (a.isPreferred != b.isPreferred)
                return (0, numbers_1.boolToNumber)(b.isPreferred) - (0, numbers_1.boolToNumber)(a.isPreferred);
            return 0;
        });
        return codeActions;
    }
    get floatActions() {
        if (!workspace_1.default.floatSupported)
            return false;
        let config = workspace_1.default.getConfiguration('coc.preferences', null);
        return config.get('floatActions', true);
    }
    async doCodeAction(mode, only, noExclude = false) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode)
            range = await window_1.default.getSelectedRange(mode);
        await doc.synchronize();
        let codeActions = await this.getCodeActions(doc, range, Array.isArray(only) ? only : null);
        if (typeof only == 'string') {
            codeActions = codeActions.filter(o => o.title == only || (o.command && o.command.title == only));
        }
        else if (Array.isArray(only)) {
            codeActions = codeActions.filter(o => only.some(k => o.kind && o.kind.startsWith(k)));
        }
        if (!this.floatActions || !noExclude)
            codeActions = codeActions.filter(o => !o.disabled);
        if (!codeActions || codeActions.length == 0) {
            void window_1.default.showWarningMessage(`No${only ? ' ' + only : ''} code action available`);
            return;
        }
        if (codeActions.length == 1 && !codeActions[0].disabled && shouldAutoApply(only)) {
            await this.applyCodeAction(codeActions[0]);
            return;
        }
        let idx = this.floatActions
            ? await window_1.default.showMenuPicker(codeActions.map(o => {
                return { text: o.title, disabled: o.disabled };
            }), 'Choose action')
            : await window_1.default.showQuickpick(codeActions.map(o => o.title));
        let action = codeActions[idx];
        if (action)
            await this.applyCodeAction(action);
    }
    /**
     * Get current codeActions
     */
    async getCurrentCodeActions(mode, only) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode)
            range = await window_1.default.getSelectedRange(mode);
        let codeActions = await this.getCodeActions(doc, range, only);
        return codeActions.filter(o => !o.disabled);
    }
    /**
     * Invoke preferred quickfix at current position
     */
    async doQuickfix() {
        let actions = await this.getCurrentCodeActions('currline', [vscode_languageserver_types_1.CodeActionKind.QuickFix]);
        if (!actions || actions.length == 0) {
            void window_1.default.showWarningMessage(`No quickfix action available`);
            return;
        }
        await this.applyCodeAction(actions[0]);
        this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`, true);
    }
    async applyCodeAction(action) {
        if (action.disabled) {
            throw new Error(`Action "${action.title}" is disabled: ${action.disabled.reason}`);
        }
        let resolved = await this.handler.withRequestToken('resolve codeAction', token => {
            return languages_1.default.resolveCodeAction(action, token);
        });
        let { edit, command } = resolved;
        if (edit)
            await workspace_1.default.applyEdit(edit);
        if (command)
            await commands_1.default.execute(command);
    }
}
exports.default = CodeActions;
function shouldAutoApply(only) {
    if (!only)
        return false;
    if (typeof only === 'string' || only[0] === vscode_languageserver_types_1.CodeActionKind.QuickFix || only[0] === vscode_languageserver_types_1.CodeActionKind.SourceFixAll)
        return true;
    return false;
}
exports.shouldAutoApply = shouldAutoApply;
//# sourceMappingURL=codeActions.js.map