"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Highlights = exports.convertHighlightItem = void 0;
const util_1 = require("../util");
const object_1 = require("../util/object");
function convertHighlightItem(item) {
    return [item.hlGroup, item.lnum, item.colStart, item.colEnd, item.combine ? 1 : 0, item.start_incl ? 1 : 0, item.end_incl ? 1 : 0];
}
exports.convertHighlightItem = convertHighlightItem;
function isSame(item, curr) {
    let arr = [item.hlGroup, item.lnum, item.colStart, item.colEnd];
    return (0, object_1.equals)(arr, curr.slice(0, 4));
}
class Highlights {
    async diffHighlights(bufnr, ns, items, region, token) {
        let args = [bufnr, ns];
        if (Array.isArray(region))
            args.push(region[0], region[1] - 1);
        let curr = await this.nvim.call('coc#highlight#get_highlights', args);
        if (!curr || (token === null || token === void 0 ? void 0 : token.isCancellationRequested))
            return null;
        items.sort((a, b) => a.lnum - b.lnum);
        let linesToRemove = [];
        // let checkMarkers = this.workspace.has('nvim-0.5.1') || this.workspace.isVim
        let removeMarkers = [];
        let newItems = [];
        let itemIndex = 0;
        let maxIndex = items.length - 1;
        let maxLnum = 0;
        // highlights on vim
        let map = new Map();
        curr.forEach(o => {
            maxLnum = Math.max(maxLnum, o[1]);
            let arr = map.get(o[1]);
            if (arr) {
                arr.push(o);
            }
            else {
                map.set(o[1], [o]);
            }
        });
        if (curr.length > 0) {
            let start = Array.isArray(region) ? region[0] : 0;
            for (let i = start; i <= maxLnum; i++) {
                let exists = (0, util_1.defaultValue)(map.get(i), []);
                let added = [];
                for (let j = itemIndex; j <= maxIndex; j++) {
                    let o = items[j];
                    if (o.lnum == i) {
                        itemIndex = j + 1;
                        added.push(o);
                    }
                    else {
                        itemIndex = j;
                        break;
                    }
                }
                if (added.length == 0) {
                    if (exists.length > 0) {
                        if (this.checkMarkers) {
                            removeMarkers.push(...exists.map(o => o[4]));
                        }
                        else {
                            linesToRemove.push(i);
                        }
                    }
                }
                else {
                    if (exists.length == 0) {
                        newItems.push(...added.map(o => convertHighlightItem(o)));
                    }
                    else {
                        if (this.checkMarkers) {
                            // skip same markers at beginning of exists and removeMarkers
                            let skip = 0;
                            let min = Math.min(exists.length, added.length);
                            while (skip < min) {
                                if (isSame(added[skip], exists[skip])) {
                                    skip++;
                                }
                                else {
                                    break;
                                }
                            }
                            removeMarkers.push(...exists.slice(skip).map(o => o[4]));
                            newItems.push(...added.slice(skip).map(o => convertHighlightItem(o)));
                        }
                        else if (added.length != exists.length || !(added.every((o, i) => isSame(o, exists[i])))) {
                            linesToRemove.push(i);
                            newItems.push(...added.map(o => convertHighlightItem(o)));
                        }
                    }
                }
            }
        }
        for (let i = itemIndex; i <= maxIndex; i++) {
            newItems.push(convertHighlightItem(items[i]));
        }
        return { remove: linesToRemove, add: newItems, removeMarkers };
    }
    async applyDiffHighlights(bufnr, ns, priority, diff, notify) {
        let { nvim } = this;
        let { remove, add, removeMarkers } = diff;
        if (remove.length === 0 && add.length === 0 && removeMarkers.length === 0)
            return;
        nvim.pauseNotification();
        if (removeMarkers.length) {
            nvim.call('coc#highlight#del_markers', [bufnr, ns, removeMarkers], true);
        }
        if (remove.length) {
            nvim.call('coc#highlight#clear', [bufnr, ns, remove], true);
        }
        if (add.length) {
            nvim.call('coc#highlight#set', [bufnr, ns, add, priority], true);
        }
        if (notify) {
            nvim.resumeNotification(true, true);
        }
        else {
            await nvim.resumeNotification(true);
        }
    }
}
exports.Highlights = Highlights;
//# sourceMappingURL=highlights.js.map