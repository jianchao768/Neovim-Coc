'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemanticTokensFeature = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const Is = tslib_1.__importStar(require("../util/is"));
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
class SemanticTokensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_types_1.SemanticTokenTypes.namespace,
            vscode_languageserver_types_1.SemanticTokenTypes.type,
            vscode_languageserver_types_1.SemanticTokenTypes.class,
            vscode_languageserver_types_1.SemanticTokenTypes.enum,
            vscode_languageserver_types_1.SemanticTokenTypes.interface,
            vscode_languageserver_types_1.SemanticTokenTypes.struct,
            vscode_languageserver_types_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_types_1.SemanticTokenTypes.parameter,
            vscode_languageserver_types_1.SemanticTokenTypes.variable,
            vscode_languageserver_types_1.SemanticTokenTypes.property,
            vscode_languageserver_types_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_types_1.SemanticTokenTypes.event,
            vscode_languageserver_types_1.SemanticTokenTypes.function,
            vscode_languageserver_types_1.SemanticTokenTypes.method,
            vscode_languageserver_types_1.SemanticTokenTypes.macro,
            vscode_languageserver_types_1.SemanticTokenTypes.keyword,
            vscode_languageserver_types_1.SemanticTokenTypes.modifier,
            vscode_languageserver_types_1.SemanticTokenTypes.comment,
            vscode_languageserver_types_1.SemanticTokenTypes.string,
            vscode_languageserver_types_1.SemanticTokenTypes.number,
            vscode_languageserver_types_1.SemanticTokenTypes.regexp,
            vscode_languageserver_types_1.SemanticTokenTypes.decorator,
            vscode_languageserver_types_1.SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
            vscode_languageserver_types_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_types_1.SemanticTokenModifiers.definition,
            vscode_languageserver_types_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_types_1.SemanticTokenModifiers.static,
            vscode_languageserver_types_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_types_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_types_1.SemanticTokenModifiers.async,
            vscode_languageserver_types_1.SemanticTokenModifiers.modification,
            vscode_languageserver_types_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_types_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [protocol_1.TokenFormat.Relative];
        capability.requests = {
            range: true,
            full: {
                delta: true
            }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'semanticTokens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeSemanticTokensEmitter.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== undefined;
        const hasEditProvider = options.full !== undefined && typeof options.full !== 'boolean' && options.full.delta === true;
        const eventEmitter = new protocol_1.Emitter();
        const documentProvider = fullProvider
            ? {
                onDidChangeSemanticTokens: eventEmitter.event,
                provideDocumentSemanticTokens: (document, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentSemanticTokens = (document, token) => {
                        const params = {
                            textDocument: cv.asTextDocumentIdentifier(document)
                        };
                        return this.sendRequest(protocol_1.SemanticTokensRequest.type, params, token);
                    };
                    return middleware.provideDocumentSemanticTokens
                        ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                        : provideDocumentSemanticTokens(document, token);
                },
                provideDocumentSemanticTokensEdits: hasEditProvider
                    ? (document, previousResultId, token) => {
                        const client = this._client;
                        const middleware = client.middleware;
                        const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                            const params = {
                                textDocument: cv.asTextDocumentIdentifier(document),
                                previousResultId
                            };
                            return this.sendRequest(protocol_1.SemanticTokensDeltaRequest.type, params, token);
                        };
                        return middleware.provideDocumentSemanticTokensEdits
                            ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                            : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                    }
                    : undefined
            }
            : undefined;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: cv.asTextDocumentIdentifier(document),
                            range
                        };
                        return this.sendRequest(protocol_1.SemanticTokensRangeRequest.type, params, token);
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        if (documentProvider !== undefined) {
            disposables.push(languages_1.default.registerDocumentSemanticTokensProvider(options.documentSelector, documentProvider, options.legend));
        }
        if (rangeProvider !== undefined) {
            disposables.push(languages_1.default.registerDocumentRangeSemanticTokensProvider(options.documentSelector, rangeProvider, options.legend));
        }
        return [protocol_1.Disposable.create(() => disposables.forEach(item => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;
//# sourceMappingURL=semanticTokens.js.map