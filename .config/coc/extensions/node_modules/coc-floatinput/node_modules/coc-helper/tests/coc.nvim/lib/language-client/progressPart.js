'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressPart = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../util");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
class ProgressPart {
    constructor(client, token, done) {
        this.client = client;
        this.token = token;
        this.disposables = [];
        this._cancelled = false;
        this._percent = 0;
        this._started = false;
        this.disposables.push(client.onProgress(protocol_1.WorkDoneProgress.type, this.token, value => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done(value.message);
                    done && done(this);
                    break;
            }
        }));
    }
    begin(params) {
        if (this._started || this._cancelled)
            return false;
        this._started = true;
        void window_1.default.withProgress({
            source: `language-client-${this.client.id}`,
            cancellable: params.cancellable,
            title: params.title,
        }, (progress, token) => {
            this.progress = progress;
            this.report(params);
            if (this._cancelled)
                return Promise.resolve();
            this.disposables.push(token.onCancellationRequested(() => {
                this.client.sendNotification(protocol_1.WorkDoneProgressCancelNotification.type, { token: this.token });
                this.cancel();
            }));
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
        return true;
    }
    report(params) {
        if (!this.progress)
            return;
        let msg = {};
        if (params.message)
            msg.message = params.message;
        if (validPercent(params.percentage)) {
            msg.increment = params.percentage - this._percent;
            this._percent = params.percentage;
        }
        if (Object.keys(msg).length > 0) {
            this.progress.report(msg);
        }
    }
    cancel() {
        if (this._cancelled)
            return;
        this.cleanUp();
        if (this._reject !== undefined) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done(message) {
        if (this.progress) {
            let msg = {};
            if (message)
                msg.message = message;
            if (typeof this._percent === 'number' && this._percent > 0)
                msg.increment = 100 - this._percent;
            this.progress.report(msg);
        }
        this.cleanUp();
        if (this._resolve) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    cleanUp() {
        this._cancelled = true;
        this.progress = undefined;
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.ProgressPart = ProgressPart;
function validPercent(n) {
    if (typeof n !== 'number')
        return false;
    return n >= 0 && n <= 100;
}
//# sourceMappingURL=progressPart.js.map