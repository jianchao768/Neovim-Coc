'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const ansiparse_1 = require("../util/ansiparse");
const string_1 = require("../util/string");
/**
 * Build highlights, with lines and highlights
 */
class Highlighter {
    constructor() {
        this.lines = [];
        this._highlights = [];
    }
    addLine(line, hlGroup) {
        if (line.includes('\n')) {
            for (let content of line.split(/\r?\n/)) {
                this.addLine(content, hlGroup);
            }
            return;
        }
        if (hlGroup) {
            this._highlights.push({
                lnum: this.lines.length,
                colStart: line.match(/^\s*/)[0].length,
                colEnd: (0, string_1.byteLength)(line),
                hlGroup
            });
        } // '\x1b'
        if (line.includes('\x1b')) {
            let res = (0, ansiparse_1.parseAnsiHighlights)(line);
            for (let hl of res.highlights) {
                let { span, hlGroup } = hl;
                this._highlights.push({
                    lnum: this.lines.length,
                    colStart: span[0],
                    colEnd: span[1],
                    hlGroup
                });
            }
            this.lines.push(res.line);
        }
        else {
            this.lines.push(line);
        }
    }
    addLines(lines) {
        this.lines.push(...lines);
    }
    /**
     * Add texts to new Lines
     */
    addTexts(items) {
        let len = this.lines.length;
        let text = '';
        for (let item of items) {
            let colStart = (0, string_1.byteLength)(text);
            if (item.hlGroup) {
                this._highlights.push({
                    lnum: len,
                    colStart,
                    colEnd: colStart + (0, string_1.byteLength)(item.text),
                    hlGroup: item.hlGroup
                });
            }
            text += item.text;
        }
        this.lines.push(text);
    }
    addText(text, hlGroup) {
        if (!text)
            return;
        let { lines } = this;
        let pre = lines[lines.length - 1] || '';
        if (text.includes('\n')) {
            let parts = text.split('\n');
            this.addText(parts[0], hlGroup);
            for (let line of parts.slice(1)) {
                this.addLine(line, hlGroup);
            }
            return;
        }
        if (hlGroup) {
            let colStart = (0, string_1.byteLength)(pre);
            this._highlights.push({
                lnum: lines.length ? lines.length - 1 : 0,
                colStart,
                colEnd: colStart + (0, string_1.byteLength)(text),
                hlGroup
            });
        }
        if (lines.length) {
            lines[lines.length - 1] = `${pre}${text}`;
        }
        else {
            lines.push(text);
        }
    }
    get length() {
        return this.lines.length;
    }
    getline(line) {
        return this.lines[line] || '';
    }
    get highlights() {
        return this._highlights;
    }
    get content() {
        return this.lines.join('\n');
    }
    // default to replace
    render(buffer, start = 0, end = -1) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this._highlights) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            buffer.addHighlight({
                hlGroup: item.hlGroup,
                colStart: item.colStart,
                colEnd: item.colEnd,
                line: start + item.lnum,
                srcId: -1
            });
        }
    }
}
exports.default = Highlighter;
//# sourceMappingURL=highligher.js.map