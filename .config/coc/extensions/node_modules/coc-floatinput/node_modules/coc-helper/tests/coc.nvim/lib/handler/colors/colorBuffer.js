'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const languages_1 = tslib_1.__importStar(require("../../languages"));
const util_1 = require("../../util");
const color_1 = require("../../util/color");
const Is = tslib_1.__importStar(require("../../util/is"));
const node_1 = require("../../util/node");
const position_1 = require("../../util/position");
const protocol_1 = require("../../util/protocol");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const NAMESPACE = 'color';
const debounceTime = (0, util_1.getConditionValue)(200, 10);
class ColorBuffer {
    // last highlight version
    constructor(nvim, doc, config, usedColors) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this.usedColors = usedColors;
        this._colors = [];
        this.highlight = (0, node_1.debounce)(() => {
            void this.doHighlight();
        }, debounceTime);
        if (this.hasProvider)
            this.highlight();
    }
    get enable() {
        if (Is.boolean(this._enable))
            return this._enable;
        this._enable = workspace_1.default.getConfiguration('colors', this.doc).get('enable', false);
        return this._enable;
    }
    updateDocumentConfig() {
        let enable = this.enabled;
        this._enable = workspace_1.default.getConfiguration('colors', this.doc).get('enable', false);
        if (enable != this.enabled) {
            if (enable) {
                this.clearHighlight();
            }
            else {
                void this.doHighlight();
            }
        }
    }
    toggle() {
        if (this._enable) {
            this._enable = false;
            this.clearHighlight();
        }
        else {
            this._enable = true;
            void this.doHighlight();
        }
    }
    get hasProvider() {
        return languages_1.default.hasProvider(languages_1.ProviderName.DocumentColor, this.doc);
    }
    get enabled() {
        let { filetypes } = this.config;
        let { filetype } = this.doc;
        if (!workspace_1.default.env.updateHighlight || !this.hasProvider)
            return false;
        if (Array.isArray(filetypes) && (filetypes.includes('*') || filetypes.includes(filetype)))
            return true;
        return this.enable;
    }
    onChange() {
        this.cancel();
        this.highlight();
    }
    get buffer() {
        return this.doc.buffer;
    }
    get colors() {
        return this._colors;
    }
    hasColor() {
        return this._colors.length > 0;
    }
    async doHighlight() {
        if (!this.enabled)
            return;
        let { nvim, doc } = this;
        this.tokenSource = new protocol_1.CancellationTokenSource();
        let { token } = this.tokenSource;
        let colors;
        colors = await languages_1.default.provideDocumentColors(doc.textDocument, token);
        if (token.isCancellationRequested)
            return;
        colors = colors || [];
        colors.sort((a, b) => (0, position_1.comparePosition)(a.range.start, b.range.start));
        this._colors = colors;
        let items = [];
        colors.forEach(o => {
            let hlGroup = getHighlightGroup(o.color);
            doc.addHighlights(items, hlGroup, o.range, { combine: false });
        });
        let diff = await window_1.default.diffHighlights(doc.bufnr, NAMESPACE, items);
        if (token.isCancellationRequested || !diff)
            return;
        nvim.pauseNotification();
        this.defineColors(colors);
        nvim.resumeNotification(false, true);
        await window_1.default.applyDiffHighlights(doc.bufnr, NAMESPACE, this.config.highlightPriority, diff, true);
    }
    defineColors(colors) {
        for (let color of colors) {
            let hex = (0, color_1.toHexString)(color.color);
            if (!this.usedColors.has(hex)) {
                this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${(0, color_1.isDark)(color.color) ? 'ffffff' : '000000'}`, true);
                this.usedColors.add(hex);
            }
        }
    }
    hasColorAtPosition(position) {
        return this.colors.some(o => (0, position_1.positionInRange)(position, o.range) == 0);
    }
    clearHighlight() {
        this.highlight.clear();
        this._colors = [];
        this.buffer.clearNamespace('color');
    }
    cancel() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    dispose() {
        this._colors = [];
        this.highlight.clear();
        this.cancel();
    }
}
exports.default = ColorBuffer;
function getHighlightGroup(color) {
    return `BG${(0, color_1.toHexString)(color)}`;
}
//# sourceMappingURL=colorBuffer.js.map