'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUrl = exports.Extensions = void 0;
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const types_1 = require("../configuration/types");
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const is_1 = require("../util/is");
const node_1 = require("../util/node");
const processes_1 = require("../util/processes");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const installer_1 = require("./installer");
const manager_1 = require("./manager");
const stat_1 = require("./stat");
const ui_1 = require("./ui");
const logger = (0, logger_1.createLogger)('extensions-index');
const EXTENSIONS_FOLDER = node_1.path.join(constants_1.dataHome, 'extensions');
// global local file native
class Extensions {
    constructor() {
        this.modulesFolder = node_1.path.join(EXTENSIONS_FOLDER, 'node_modules');
        (0, stat_1.checkExtensionRoot)(EXTENSIONS_FOLDER);
        this.states = new stat_1.ExtensionStat(EXTENSIONS_FOLDER);
        this.manager = new manager_1.ExtensionManager(this.states, EXTENSIONS_FOLDER);
        commands_1.default.register({
            id: 'extensions.forceUpdateAll',
            execute: async () => {
                let arr = await this.manager.cleanExtensions();
                logger.info(`Force update extensions: ${arr}`);
                await this.installExtensions(arr);
            }
        }, false, 'remove all global extensions and install them');
        this.globalPromise = this.globalExtensions();
        commands_1.default.register({
            id: 'extensions.toggleAutoUpdate',
            execute: async () => {
                let config = workspace_1.default.getConfiguration('coc.preferences', null);
                let interval = config.get('extensionUpdateCheck', 'daily');
                let target = types_1.ConfigurationUpdateTarget.Global;
                if (interval == 'never') {
                    await config.update('extensionUpdateCheck', 'daily', target);
                    void window_1.default.showInformationMessage('Extension auto update enabled.');
                }
                else {
                    await config.update('extensionUpdateCheck', 'never', target);
                    void window_1.default.showInformationMessage('Extension auto update disabled.');
                }
            }
        }, false, 'toggle auto update of extensions.');
    }
    async init(runtimepath) {
        if (process.env.COC_NO_PLUGINS == '1')
            return;
        let stats = await this.globalPromise;
        this.manager.registerExtensions(stats);
        let localStats = this.runtimeExtensionStats(runtimepath);
        this.manager.registerExtensions(localStats);
        void this.manager.loadFileExtensions();
    }
    async activateExtensions() {
        await this.manager.activateExtensions();
        if (process.env.COC_NO_PLUGINS == '1')
            return;
        let names = this.states.filterGlobalExtensions(workspace_1.default.env.globalExtensions);
        void this.installExtensions(names);
        // check extensions need watch & install
        let config = workspace_1.default.initialConfiguration.get('coc.preferences');
        let interval = config.extensionUpdateCheck;
        let silent = config.silentAutoupdate;
        if (this.states.shouldUpdate(interval)) {
            this.outputChannel.appendLine('Start auto update...');
            this.updateExtensions(silent).catch(e => {
                this.outputChannel.appendLine(`Error on updateExtensions ${e}`);
            });
        }
    }
    get onDidLoadExtension() {
        return this.manager.onDidLoadExtension;
    }
    get onDidActiveExtension() {
        return this.manager.onDidActiveExtension;
    }
    get onDidUnloadExtension() {
        return this.manager.onDidUnloadExtension;
    }
    get outputChannel() {
        return window_1.default.createOutputChannel('extensions');
    }
    /**
     * Get all loaded extensions.
     */
    get all() {
        return this.manager.all;
    }
    has(id) {
        return this.manager.has(id);
    }
    getExtension(id) {
        return this.manager.getExtension(id);
    }
    getExtensionById(extensionId) {
        let item = this.manager.getExtension(extensionId);
        return item ? item.extension : undefined;
    }
    /**
     * @deprecated Used by old version coc-json.
     */
    get schemes() {
        return {};
    }
    /**
     * @deprecated Used by old version coc-json.
     */
    addSchemeProperty(key, def) {
        // workspace.configurations.extendsDefaults({ [key]: def.default }, id)
    }
    /**
     * @public Get state of extension
     */
    getExtensionState(id) {
        return this.manager.getExtensionState(id);
    }
    isActivated(id) {
        let item = this.manager.getExtension(id);
        return item != null && item.extension.isActive;
    }
    async call(id, method, args) {
        return await this.manager.call(id, method, args);
    }
    get npm() {
        let npm = workspace_1.default.initialConfiguration.get('npm.binPath');
        npm = workspace_1.default.expand(npm);
        for (let exe of [npm, 'yarnpkg', 'yarn', 'npm']) {
            if ((0, processes_1.executable)(exe))
                return node_1.which.sync(exe);
        }
        void window_1.default.showErrorMessage(`Can't find npm or yarn in your $PATH`);
        return null;
    }
    createInstallerUI(isUpdate, silent) {
        return silent ? new ui_1.InstallChannel(isUpdate, this.outputChannel) : new ui_1.InstallBuffer(isUpdate);
    }
    creteInstaller(npm, def) {
        return new installer_1.Installer(this.modulesFolder, npm, def);
    }
    /**
     * Install extensions, can be called without initialize.
     */
    async installExtensions(list) {
        if ((0, array_1.isFalsyOrEmpty)(list) || !this.npm)
            return;
        let { npm } = this;
        list = (0, array_1.distinct)(list);
        let installBuffer = this.createInstallerUI(false, false);
        await Promise.resolve(installBuffer.start(list));
        let fn = async (key) => {
            try {
                installBuffer.startProgress(key);
                let installer = this.creteInstaller(npm, key);
                installer.on('message', (msg, isProgress) => {
                    installBuffer.addMessage(key, msg, isProgress);
                });
                let result = await installer.install();
                installBuffer.finishProgress(key, true);
                this.states.addExtension(result.name, result.url ? result.url : `>=${result.version}`);
                let ms = key.match(/@[\d.]+$/);
                if (ms != null)
                    this.states.setLocked(result.name, true);
                await this.manager.loadExtension(result.folder);
            }
            catch (err) {
                installBuffer.addMessage(key, err.message);
                installBuffer.finishProgress(key, false);
                void window_1.default.showErrorMessage(`Error on install ${key}: ${err}`);
                logger.error(`Error on install ${key}`, err);
            }
        };
        await (0, util_1.concurrent)(list, fn);
    }
    /**
     * Update global extensions
     */
    async updateExtensions(silent = false) {
        let { npm } = this;
        if (!npm)
            return;
        let stats = this.globalExtensionStats();
        stats = stats.filter(s => {
            if (s.isLocked || s.state === 'disabled') {
                this.outputChannel.appendLine(`Skipped update for ${s.isLocked ? 'locked' : 'disabled'} extension "${s.id}"`);
                return false;
            }
            return true;
        });
        this.states.setLastUpdate();
        this.cleanModulesFolder();
        let installBuffer = this.createInstallerUI(true, silent);
        await Promise.resolve(installBuffer.start(stats.map(o => o.id)));
        let fn = async (stat) => {
            let { id } = stat;
            try {
                installBuffer.startProgress(id);
                let url = stat.exotic ? stat.uri : null;
                let installer = this.creteInstaller(npm, id);
                installer.on('message', (msg, isProgress) => {
                    installBuffer.addMessage(id, msg, isProgress);
                });
                let directory = await installer.update(url);
                installBuffer.finishProgress(id, true);
                if (directory)
                    await this.manager.loadExtension(directory);
            }
            catch (err) {
                installBuffer.addMessage(id, err.message);
                installBuffer.finishProgress(id, false);
                void window_1.default.showErrorMessage(`Error on update ${id}: ${err}`);
                logger.error(`Error on update ${id}`, err);
            }
        };
        await (0, util_1.concurrent)(stats, fn, silent ? 1 : 3);
    }
    /**
     * Get all extension states
     */
    async getExtensionStates() {
        let runtimepath = await workspace_1.default.nvim.eval('join(globpath(&runtimepath, "", 0, 1), ",")');
        let localStats = this.runtimeExtensionStats(runtimepath);
        let globalStats = this.globalExtensionStats();
        return localStats.concat(globalStats);
    }
    async globalExtensions() {
        if (process.env.COC_NO_PLUGINS == '1')
            return [];
        let res = [];
        for (let key of this.states.activated()) {
            let root = node_1.path.join(this.modulesFolder, key);
            try {
                let json = await (0, stat_1.loadGlobalJsonAsync)(root, constants_1.VERSION);
                res.push({ root, isLocal: false, packageJSON: json });
            }
            catch (err) {
                logger.error(`Error on load package.json of ${key}`, err);
            }
        }
        return res;
    }
    globalExtensionStats() {
        let dependencies = this.states.dependencies;
        let lockedExtensions = this.states.lockedExtensions;
        let infos = [];
        Object.entries(dependencies).map(([key, val]) => {
            var _a;
            let root = node_1.path.join(this.modulesFolder, key);
            let errors = [];
            let obj = (0, stat_1.loadExtensionJson)(root, constants_1.VERSION, errors);
            if (errors.length > 0) {
                this.outputChannel.appendLine(`Error on load ${key} at ${root}: ${errors.join('\n')}`);
                return;
            }
            obj.name = key;
            infos.push({
                id: key,
                root,
                isLocal: false,
                version: obj.version,
                description: (_a = obj.description) !== null && _a !== void 0 ? _a : '',
                isLocked: lockedExtensions.includes(key),
                exotic: /^https?:/.test(val),
                uri: toUrl(val),
                state: this.getExtensionState(key),
                packageJSON: obj
            });
        });
        logger.debug('globalExtensionStats:', infos.length);
        return infos;
    }
    runtimeExtensionStats(runtimepath) {
        let lockedExtensions = this.states.lockedExtensions;
        let paths = runtimepath.split(',');
        let infos = [];
        let localIds = new Set();
        paths.map(root => {
            var _a;
            let errors = [];
            let obj = (0, stat_1.loadExtensionJson)(root, workspace_1.default.version, errors);
            if (errors.length > 0)
                return;
            let { name } = obj;
            if (!name || this.states.hasExtension(name) || localIds.has(name))
                return;
            this.states.addLocalExtension(name, root);
            localIds.add(name);
            infos.push(({
                id: obj.name,
                isLocal: true,
                isLocked: lockedExtensions.includes(name),
                version: obj.version,
                description: (_a = obj.description) !== null && _a !== void 0 ? _a : '',
                exotic: false,
                root,
                state: this.getExtensionState(obj.name),
                packageJSON: Object.freeze(obj)
            }));
        });
        return infos;
    }
    /**
     * Remove unnecessary folders in node_modules
     */
    cleanModulesFolder() {
        let globalIds = this.states.globalIds;
        let folders = globalIds.map(s => s.replace(/\/.*$/, ''));
        if (!node_1.fs.existsSync(this.modulesFolder))
            return;
        let files = node_1.fs.readdirSync(this.modulesFolder);
        for (let file of files) {
            if (folders.includes(file))
                continue;
            let p = node_1.path.join(this.modulesFolder, file);
            let stat = node_1.fs.lstatSync(p);
            if (stat.isSymbolicLink()) {
                node_1.fs.unlinkSync(p);
            }
            else if (stat.isDirectory()) {
                node_1.fs.rmSync(p, { recursive: true, force: true });
            }
        }
    }
    dispose() {
        this.manager.dispose();
    }
}
exports.Extensions = Extensions;
function toUrl(val) {
    return (0, is_1.isUrl)(val) ? val.replace(/\.git(#master|#main)?$/, '') : '';
}
exports.toUrl = toUrl;
exports.default = new Extensions();
//# sourceMappingURL=index.js.map