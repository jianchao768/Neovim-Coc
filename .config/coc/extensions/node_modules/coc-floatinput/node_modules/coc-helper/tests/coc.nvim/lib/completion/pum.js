"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixWord = exports.getInsertWord = exports.PumItems = exports.HighlightGroups = void 0;
const tslib_1 = require("tslib");
const fuzzyMatch_1 = require("../model/fuzzyMatch");
const array_1 = require("../util/array");
const filter_1 = require("../util/filter");
const Is = tslib_1.__importStar(require("../util/is"));
const numbers_1 = require("../util/numbers");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const util_1 = require("./util");
var HighlightGroups;
(function (HighlightGroups) {
    HighlightGroups["PumDetail"] = "CocPumDetail";
    HighlightGroups["PumDeprecated"] = "CocPumDeprecated";
    HighlightGroups["PumMenu"] = "CocPumMenu";
    HighlightGroups["PumShortcut"] = "CocPumShortcut";
    HighlightGroups["PumSearch"] = "CocPumSearch";
})(HighlightGroups = exports.HighlightGroups || (exports.HighlightGroups = {}));
var PumItems;
(function (PumItems) {
    PumItems["Abbr"] = "abbr";
    PumItems["Menu"] = "menu";
    PumItems["Kind"] = "kind";
    PumItems["Shortcut"] = "shortcut";
})(PumItems = exports.PumItems || (exports.PumItems = {}));
class PopupMenu {
    constructor(config, mruLoader) {
        this.config = config;
        this.mruLoader = mruLoader;
        this._search = '';
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    get search() {
        return this._search;
    }
    reset() {
        this._search = '';
        this._pumConfig = undefined;
    }
    get pumConfig() {
        var _a;
        if (this._pumConfig)
            return this._pumConfig;
        let { floatConfig, pumFloatConfig, reversePumAboveCursor } = this.config;
        if (!pumFloatConfig)
            pumFloatConfig = floatConfig;
        let obj = {};
        if (Is.string(pumFloatConfig.highlight))
            obj.highlight = pumFloatConfig.highlight;
        if (Is.number(pumFloatConfig.winblend))
            obj.winblend = pumFloatConfig.winblend;
        if (pumFloatConfig.shadow)
            obj.shadow = pumFloatConfig.shadow;
        if (pumFloatConfig.border) {
            obj.border = [1, 1, 1, 1];
            obj.rounded = pumFloatConfig.rounded ? 1 : 0;
            obj.borderhighlight = (_a = pumFloatConfig.borderhighlight) !== null && _a !== void 0 ? _a : 'CocFloating';
        }
        obj.reverse = reversePumAboveCursor === true;
        this._pumConfig = obj;
        return obj;
    }
    stringWidth(text, cache = false) {
        return workspace_1.default.getDisplayWidth(text, cache);
    }
    show(items, search, option) {
        this._search = search;
        let { noselect, enablePreselect, invalidInsertCharacters, selection, virtualText, kindMap, defaultKindText } = this.config;
        const invalidInsertCodes = invalidInsertCharacters.map(ch => ch.charCodeAt(0));
        let selectedIndex = enablePreselect ? items.findIndex(o => o.preselect) : -1;
        let maxMru = -1;
        let abbrWidth = 0;
        let menuWidth = 0;
        let kindWidth = 0;
        let shortcutWidth = 0;
        let checkMru = selectedIndex == -1 && !noselect && selection !== util_1.Selection.First;
        let labels = [];
        let baseCharacter = (0, string_1.characterIndex)(option.line, option.col);
        let minCharacter = baseCharacter;
        // abbr kind, menu
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            if (checkMru) {
                let n = this.mruLoader.getScore(search, item, selection);
                if (n > maxMru) {
                    maxMru = n;
                    selectedIndex = i;
                }
            }
            if (Is.number(item.character) && item.character < minCharacter) {
                minCharacter = item.character;
            }
            let label = this.getLabel(item);
            labels.push(label);
            abbrWidth = Math.max(this.stringWidth(label.text, true), abbrWidth);
            if (item.kind)
                kindWidth = Math.max(this.stringWidth((0, util_1.getKindText)(item.kind, kindMap, defaultKindText), true), kindWidth);
            if (item.menu)
                menuWidth = Math.max(this.stringWidth(item.menu, true), menuWidth);
            if (item.shortcut)
                shortcutWidth = Math.max(this.stringWidth(item.shortcut, true) + 2, shortcutWidth);
        }
        if (selectedIndex !== -1 && search.length > 0) {
            let item = items[selectedIndex];
            if (!item.word.startsWith(search)) {
                selectedIndex = -1;
            }
        }
        if (!noselect) {
            selectedIndex = selectedIndex == -1 ? 0 : selectedIndex;
        }
        else {
            if (selectedIndex > 0) {
                let [item] = items.splice(selectedIndex, 1);
                items.unshift(item);
                let [label] = labels.splice(selectedIndex, 1);
                labels.unshift(label);
            }
            selectedIndex = -1;
        }
        let opt = {
            input: search,
            index: selectedIndex,
            bufnr: option.bufnr,
            line: option.linenr,
            // col for pum
            col: option.col,
            // col for word insert
            startcol: (0, string_1.byteIndex)(option.line, minCharacter),
            virtualText,
            words: items.map(o => {
                let character = o.character;
                let start = Math.max(1, option.position.character - character + 1);
                let word = getInsertWord(o.word, invalidInsertCodes, start);
                return prefixWord(word, character, option.line, minCharacter);
            })
        };
        let pumConfig = this.pumConfig;
        let lines = [];
        let highlights = [];
        // create lines and highlights
        let width = 0;
        let buildConfig = { border: !!pumConfig.border, menuWidth, abbrWidth, kindWidth, shortcutWidth };
        this.adjustAbbrWidth(buildConfig);
        let lowInput = search.toLowerCase();
        for (let index = 0; index < items.length; index++) {
            let [displayWidth, text] = this.buildItem(search, lowInput, items[index], labels[index], highlights, index, buildConfig);
            width = Math.max(width, displayWidth);
            lines.push(text);
        }
        let config = Object.assign({ width, highlights }, pumConfig);
        this.nvim.call('coc#pum#create', [lines, opt, config], true);
        this.nvim.redrawVim();
    }
    getLabel(item) {
        var _a;
        let { labelDetails, detail } = item;
        let { snippetIndicator, labelMaxLength, detailField, detailMaxLength } = this.config;
        let label = item.abbr;
        let hls = [];
        if (item.isSnippet && !label.endsWith(snippetIndicator)) {
            label = label + snippetIndicator;
        }
        if (detailField === 'abbr' && detail && !labelDetails && detail.length < detailMaxLength) {
            labelDetails = { detail: ' ' + detail.replace(/\r?\n\s*/g, ' ') };
        }
        if (labelDetails) {
            let added = ((_a = labelDetails.detail) !== null && _a !== void 0 ? _a : '') + (labelDetails.description ? ` ${labelDetails.description}` : '');
            if (label.length + added.length <= labelMaxLength) {
                let start = (0, string_1.byteLength)(label);
                hls.push({ start, end: start + (0, string_1.byteLength)(added), hlGroup: HighlightGroups.PumDetail });
                label = label + added;
                item.detailRendered = true;
            }
        }
        if (label.length > labelMaxLength) {
            label = label.slice(0, labelMaxLength - 1) + '.';
        }
        return { text: label, highlights: hls };
    }
    adjustAbbrWidth(config) {
        let { formatItems } = this.config;
        let pumwidth = (0, numbers_1.toNumber)(workspace_1.default.env.pumwidth, 15);
        let len = 0;
        for (const item of formatItems) {
            if (item == PumItems.Abbr) {
                len += config.abbrWidth + 1;
            }
            else if (item == PumItems.Menu && config.menuWidth) {
                len += config.menuWidth + 1;
            }
            else if (item == PumItems.Kind && config.kindWidth) {
                len += config.kindWidth + 1;
            }
            else if (item == PumItems.Shortcut && config.shortcutWidth) {
                len += config.shortcutWidth + 1;
            }
        }
        if (len < pumwidth) {
            config.abbrWidth = config.abbrWidth + pumwidth - len;
        }
    }
    buildItem(input, lowInput, item, label, hls, index, config) {
        // abbr menu kind shortcut
        let { labelMaxLength, formatItems, kindMap, defaultKindText } = this.config;
        let text = config.border ? '' : ' ';
        let len = (0, string_1.byteLength)(text);
        let displayWidth = text.length;
        let append = (str, width) => {
            let s = this.fillWidth(str, width);
            displayWidth += width;
            len += (0, string_1.byteLength)(s);
            text += s;
        };
        for (const name of formatItems) {
            switch (name) {
                case 'abbr': {
                    if (!(0, array_1.isFalsyOrEmpty)(item.positions)) {
                        let pre = (0, util_1.highlightOffert)(len, item);
                        if (pre != -1) {
                            positionHighlights(hls, item.abbr, item.positions, pre, index, labelMaxLength);
                        }
                        else {
                            let score = (0, filter_1.anyScore)(input, lowInput, 0, item.abbr, item.abbr.toLowerCase(), 0);
                            positionHighlights(hls, item.abbr, score, 0, index, labelMaxLength);
                        }
                    }
                    let abbr = label.text;
                    let start = len;
                    append(abbr, config.abbrWidth + 1);
                    label.highlights.forEach(hl => {
                        hls.push({
                            hlGroup: hl.hlGroup,
                            lnum: index,
                            colStart: start + hl.start,
                            colEnd: start + hl.end
                        });
                    });
                    if (item.deprecated) {
                        hls.push({
                            hlGroup: HighlightGroups.PumDeprecated,
                            lnum: index,
                            colStart: start,
                            colEnd: len - 1,
                        });
                    }
                    break;
                }
                case 'menu': {
                    if (config.menuWidth > 0) {
                        let colStart = len;
                        append((0, string_1.toText)(item.menu), config.menuWidth + 1);
                        if (item.menu) {
                            hls.push({
                                hlGroup: HighlightGroups.PumMenu,
                                lnum: index,
                                colStart,
                                colEnd: colStart + (0, string_1.byteLength)(item.menu)
                            });
                        }
                    }
                    break;
                }
                case 'kind':
                    if (config.kindWidth > 0) {
                        let { kind } = item;
                        let kindText = (0, util_1.getKindText)(kind, kindMap, defaultKindText);
                        let colStart = len;
                        append((0, string_1.toText)(kindText), config.kindWidth + 1);
                        if (kindText) {
                            hls.push({
                                hlGroup: (0, util_1.getKindHighlight)(kind),
                                lnum: index,
                                colStart,
                                colEnd: colStart + (0, string_1.byteLength)(kindText)
                            });
                        }
                    }
                    break;
                case 'shortcut':
                    if (config.shortcutWidth > 0) {
                        let colStart = len;
                        let shortcut = item.shortcut;
                        append(shortcut ? `[${shortcut}]` : '', config.shortcutWidth + 1);
                        if (shortcut) {
                            hls.push({
                                hlGroup: HighlightGroups.PumShortcut,
                                lnum: index,
                                colStart,
                                colEnd: colStart + (0, string_1.byteLength)(shortcut) + 2
                            });
                        }
                    }
                    break;
            }
        }
        return [displayWidth, text];
    }
    fillWidth(text, width) {
        let n = width - this.stringWidth(text);
        return text + ' '.repeat(Math.max(n, 0));
    }
}
exports.default = PopupMenu;
/**
 * positions is FuzzyScore
 */
function positionHighlights(hls, label, positions, pre, line, max) {
    for (let span of (0, fuzzyMatch_1.matchSpansReverse)(label, positions, 2, max)) {
        hls.push({
            hlGroup: HighlightGroups.PumSearch,
            lnum: line,
            colStart: pre + span[0],
            colEnd: pre + span[1],
        });
    }
}
/**
 * Exclude part with invalid characters.
 */
function getInsertWord(word, codes, start) {
    if (codes.length === 0)
        return word;
    for (let i = start; i < word.length; i++) {
        if (codes.includes(word.charCodeAt(i))) {
            return word.slice(0, i);
        }
    }
    return word;
}
exports.getInsertWord = getInsertWord;
/**
 * Append previous text to word when necessary
 */
function prefixWord(word, character, line, minCharacter) {
    return minCharacter < character ? line.slice(minCharacter, character) + word : word;
}
exports.prefixWord = prefixWord;
//# sourceMappingURL=pum.js.map