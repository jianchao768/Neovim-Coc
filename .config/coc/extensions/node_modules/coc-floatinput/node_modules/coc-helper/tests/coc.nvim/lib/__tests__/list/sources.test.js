"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const manager_1 = tslib_1.__importDefault(require("../../diagnostic/manager"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const index_1 = tslib_1.__importDefault(require("../../extension/index"));
const manager_2 = require("../../extension/manager");
const stat_1 = require("../../extension/stat");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const basic_1 = tslib_1.__importStar(require("../../list/basic"));
const formatting_1 = require("../../list/formatting");
const manager_3 = tslib_1.__importDefault(require("../../list/manager"));
const diagnostics_1 = require("../../list/source/diagnostics");
const extensions_1 = tslib_1.__importStar(require("../../list/source/extensions"));
const folders_1 = tslib_1.__importDefault(require("../../list/source/folders"));
const lists_1 = require("../../list/source/lists");
const outline_1 = tslib_1.__importStar(require("../../list/source/outline"));
const symbols_1 = tslib_1.__importStar(require("../../list/source/symbols"));
const services_1 = tslib_1.__importStar(require("../../services"));
const util_1 = require("../../util");
const extension = tslib_1.__importStar(require("../../util/extensionRegistry"));
const node_1 = require("../../util/node");
const registry_1 = require("../../util/registry");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const parser_1 = tslib_1.__importDefault(require("../handler/parser"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let listItems = [];
class OptionList extends basic_1.default {
    constructor() {
        super();
        this.name = 'option';
        this.options = [{
                name: '-w, -word',
                description: 'word'
            }, {
                name: '-i, -input INPUT',
                hasValue: true,
                description: 'input'
            }, {
                key: 'name',
                description: '',
                name: '-name'
            }];
        this.addLocationActions();
    }
    loadItems(_context, _token) {
        return Promise.resolve(listItems);
    }
}
let previewOptions;
class SimpleList extends basic_1.default {
    constructor() {
        super();
        this.name = 'simple';
        this.addAction('preview', async (_item, context) => {
            await this.preview(previewOptions, context);
        });
    }
    loadItems() {
        return Promise.resolve(['a', 'b', 'c'].map((s, idx) => {
            return { label: s, location: vscode_languageserver_protocol_1.Location.create('test:///a', vscode_languageserver_protocol_1.Range.create(idx, 0, idx + 1, 0)) };
        }));
    }
}
async function createContext(option) {
    let buffer = await nvim.buffer;
    let window = await nvim.window;
    return {
        args: [],
        buffer,
        cwd: process.cwd(),
        input: '',
        listWindow: nvim.createWindow(1002),
        options: Object.assign({
            position: 'bottom',
            reverse: false,
            input: '',
            ignorecase: false,
            smartcase: false,
            interactive: false,
            sort: false,
            mode: 'normal',
            matcher: 'strict',
            autoPreview: false,
            numberSelect: false,
            noQuit: false,
            first: false
        }, option),
        window
    };
}
let disposables = [];
let nvim;
const locations = [{
        filename: __filename,
        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 6),
        targetRange: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 6),
        text: 'foo',
        type: 'Error'
    }, {
        filename: __filename,
        range: vscode_languageserver_protocol_1.Range.create(2, 0, 2, 6),
        text: 'Bar',
        type: 'Warning'
    }, {
        filename: __filename,
        range: vscode_languageserver_protocol_1.Range.create(3, 0, 4, 6),
        text: 'multiple'
    }, {
        filename: node_1.path.join(os_1.default.tmpdir(), '3195369f-5b9f-4c46-99cd-6007c0224595'),
        range: vscode_languageserver_protocol_1.Range.create(3, 0, 4, 6),
        text: 'tmpdir'
    }];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    manager_3.default.dispose();
    await helper_1.default.shutdown();
});
afterEach(async () => {
    listItems = [];
    (0, util_1.disposeAll)(disposables);
    manager_3.default.reset();
    await helper_1.default.reset();
});
describe('formatting', () => {
    it('should format path', () => {
        expect((0, formatting_1.formatPath)('short', 'home')).toMatch('home');
        expect((0, formatting_1.formatPath)('hidden', 'path')).toBe('');
        expect((0, formatting_1.formatPath)('full', __filename)).toMatch('sources.test.ts');
        expect((0, formatting_1.formatPath)('short', __filename)).toMatch('sources.test.ts');
        expect((0, formatting_1.formatPath)('filename', __filename)).toMatch('sources.test.ts');
    });
    it('should format uri', () => {
        let cwd = process.cwd();
        expect((0, formatting_1.formatUri)('http://www.example.com', cwd)).toMatch('http');
        expect((0, formatting_1.formatUri)(vscode_uri_1.URI.file(__filename).toString(), cwd)).toMatch('sources');
        expect((0, formatting_1.formatUri)(vscode_uri_1.URI.file(os_1.default.tmpdir()).toString(), cwd)).toMatch(os_1.default.tmpdir());
    });
    it('should fixWidth', () => {
        expect((0, formatting_1.fixWidth)('a'.repeat(10), 2)).toBe('a.');
    });
    it('should sort symbols', () => {
        const assert = (a, b, n) => {
            expect((0, symbols_1.sortSymbolItems)(a, b)).toBe(n);
        };
        assert({ data: { score: 1 } }, { data: { score: 2 } }, 1);
        assert({ data: { kind: 1 } }, { data: { kind: 2 } }, -1);
        assert({ data: { file: 'aa' } }, { data: { file: 'b' } }, 1);
    });
    it('should format list items', () => {
        expect((0, formatting_1.formatListItems)(false, [])).toEqual([]);
        let items = [{
                label: ['a', 'b', 'c']
            }];
        expect((0, formatting_1.formatListItems)(false, items)).toEqual([{
                label: 'a\tb\tc'
            }]);
        items = [{
                label: ['a', 'b', 'c']
            }, {
                label: ['foo', 'bar', 'go']
            }];
        expect((0, formatting_1.formatListItems)(true, items)).toEqual([{
                label: 'a  \tb  \tc '
            }, {
                label: 'foo\tbar\tgo'
            }]);
    });
});
describe('Extensions util', () => {
    it('should sortExtensionItem', () => {
        expect((0, extensions_1.sortExtensionItem)({ data: { priority: 1 } }, { data: { priority: 0 } })).toBe(-1);
        expect((0, extensions_1.sortExtensionItem)({ data: { id: 'a' } }, { data: { id: 'b' } })).toBe(1);
        expect((0, extensions_1.sortExtensionItem)({ data: { id: 'b' } }, { data: { id: 'a' } })).toBe(-1);
    });
    it('should get extension prefix', () => {
        expect((0, extensions_1.getExtensionPrefix)('')).toBe('+');
        expect((0, extensions_1.getExtensionPrefix)('disabled')).toBe('-');
        expect((0, extensions_1.getExtensionPrefix)('activated')).toBe('*');
        expect((0, extensions_1.getExtensionPrefix)('unknown')).toBe('?');
    });
    it('should get extension priority', () => {
        expect((0, extensions_1.getExtensionPriority)('')).toBe(0);
        expect((0, extensions_1.getExtensionPriority)('unknown')).toBe(2);
        expect((0, extensions_1.getExtensionPriority)('activated')).toBe(1);
        expect((0, extensions_1.getExtensionPriority)('disabled')).toBe(-1);
    });
});
describe('Outline util', () => {
    it('should getFilterText', () => {
        expect((0, outline_1.getFilterText)(vscode_languageserver_protocol_1.DocumentSymbol.create('name', '', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1), vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)), 'kind')).toBe('name');
        expect((0, outline_1.getFilterText)(vscode_languageserver_protocol_1.DocumentSymbol.create('name', '', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1), vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)), '')).toBe('nameFunction');
    });
    it('should load items by ctags', async () => {
        let doc = await workspace_1.default.document;
        let spy = jest.spyOn(node_1.which, 'sync').mockImplementation(() => {
            return '';
        });
        let items = await (0, outline_1.loadCtagsSymbols)(doc, nvim);
        expect(items).toEqual([]);
        spy.mockRestore();
        doc = await helper_1.default.createDocument(__filename);
        items = await (0, outline_1.loadCtagsSymbols)(doc, nvim);
        expect(Array.isArray(items)).toBe(true);
    });
    it('should convert to list items', async () => {
        let doc = await workspace_1.default.document;
        expect((0, outline_1.contentToItems)('a\tb\t2\td\n\n', doc).length).toBe(1);
    });
});
describe('configuration', () => {
    beforeEach(() => {
        let list = new OptionList();
        manager_3.default.registerList(list);
    });
    it('should change default options', async () => {
        helper_1.default.updateConfiguration('list.source.option.defaultOptions', ['--normal']);
        await manager_3.default.start(['option']);
        await manager_3.default.session.ui.ready;
        const mode = manager_3.default.prompt.mode;
        expect(mode).toBe('normal');
    });
    it('should change default action', async () => {
        helper_1.default.updateConfiguration('list.source.option.defaultAction', 'split');
        await manager_3.default.start(['option']);
        await manager_3.default.session.ui.ready;
        const action = manager_3.default.session.defaultAction;
        expect(action.name).toBe('split');
        await manager_3.default.session.doAction();
        let tab = await nvim.tabpage;
        let wins = await tab.windows;
        expect(wins.length).toBeGreaterThan(1);
    });
    it('should change default arguments', async () => {
        helper_1.default.updateConfiguration('list.source.option.defaultArgs', ['-word']);
        await manager_3.default.start(['option']);
        await manager_3.default.session.ui.ready;
        const context = manager_3.default.session.context;
        expect(context.args).toEqual(['-word']);
    });
});
describe('BasicList', () => {
    describe('getFiletype()', () => {
        it('should get filetype', async () => {
            expect((0, basic_1.toVimFiletype)('latex')).toBe('tex');
            expect((0, basic_1.toVimFiletype)('foo')).toBe('foo');
        });
    });
    describe('parse arguments', () => {
        it('should parse args #1', () => {
            let list = new OptionList();
            let res = list.parseArguments(['-w']);
            expect(res).toEqual({ word: true });
        });
        it('should parse args #2', () => {
            let list = new OptionList();
            let res = list.parseArguments(['-word']);
            expect(res).toEqual({ word: true });
        });
        it('should parse args #3', () => {
            let list = new OptionList();
            let res = list.parseArguments(['-input', 'foo']);
            expect(res).toEqual({ input: 'foo' });
        });
    });
    describe('jumpTo()', () => {
        let list;
        beforeAll(() => {
            list = new OptionList();
        });
        it('should jump to uri', async () => {
            let uri = vscode_uri_1.URI.file(__filename).toString();
            let ctx = await createContext({ position: 'tab' });
            await list.jumpTo(uri, null, ctx);
            let bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toMatch('sources.test.ts');
        });
        it('should jump to location', async () => {
            let uri = vscode_uri_1.URI.file(__filename).toString();
            let loc = vscode_languageserver_protocol_1.Location.create(uri, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0));
            await list.jumpTo(loc, 'edit');
            let bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toMatch('sources.test.ts');
        });
        it('should jump to location with empty range', async () => {
            let uri = vscode_uri_1.URI.file(__filename).toString();
            let loc = vscode_languageserver_protocol_1.Location.create(uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
            await list.jumpTo(loc, 'edit');
            let bufname = await nvim.call('bufname', ['%']);
            expect(bufname).toMatch('sources.test.ts');
        });
    });
    describe('convertLocation()', () => {
        let list;
        beforeAll(() => {
            list = new OptionList();
        });
        it('should convert uri', async () => {
            let uri = vscode_uri_1.URI.file(__filename).toString();
            let res = await list.convertLocation(uri);
            expect(res.uri).toBe(uri);
        });
        it('should convert location with line', async () => {
            let uri = vscode_uri_1.URI.file(__filename).toString();
            let res = await list.convertLocation({ uri, line: 'convertLocation()', text: 'convertLocation' });
            expect(res.uri).toBe(uri);
            res = await list.convertLocation({ uri, line: 'convertLocation()' });
            expect(res.uri).toBe(uri);
        });
        it('should convert location with custom schema', async () => {
            let uri = 'test:///foo';
            let res = await list.convertLocation({ uri, line: 'convertLocation()' });
            expect(res.uri).toBe(uri);
        });
    });
    describe('createAction()', () => {
        it('should overwrite action', async () => {
            let idx;
            let list = new OptionList();
            listItems.push({
                label: 'foo',
                location: vscode_languageserver_protocol_1.Location.create('untitled:///1', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0))
            });
            list.createAction({
                name: 'foo',
                execute: () => { idx = 0; }
            });
            list.createAction({
                name: 'foo',
                execute: () => { idx = 1; }
            });
            disposables.push(manager_3.default.registerList(list));
            await manager_3.default.start(['--normal', 'option']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('foo');
            expect(idx).toBe(1);
        });
    });
    describe('preview()', () => {
        beforeEach(() => {
            let list = new SimpleList();
            disposables.push(manager_3.default.registerList(list));
        });
        async function doPreview(opts) {
            previewOptions = opts;
            await manager_3.default.start(['--normal', 'simple']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('preview');
            let res = await nvim.call('coc#list#has_preview');
            expect(res).toBeGreaterThan(0);
            let winid = await nvim.call('win_getid', [res]);
            return winid;
        }
        it('should preview lines', async () => {
            await doPreview({ filetype: '', lines: ['foo', 'bar'] });
        });
        it('should preview with bufname', async () => {
            await doPreview({
                bufname: 't.js',
                filetype: 'typescript',
                lines: ['foo', 'bar']
            });
        });
        it('should preview with range highlight', async () => {
            let winid = await doPreview({
                bufname: 't.js',
                filetype: 'typescript',
                lines: ['foo', 'bar'],
                range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3)
            });
            let res = await nvim.call('getmatches', [winid]);
            expect(res.length).toBeGreaterThan(0);
        });
    });
    describe('previewLocation()', () => {
        it('should preview sketch buffer', async () => {
            await nvim.command('new');
            await nvim.setLine('foo');
            let doc = await workspace_1.default.document;
            expect(doc.uri).toMatch('untitled');
            let list = new OptionList();
            listItems.push({
                label: 'foo',
                location: vscode_languageserver_protocol_1.Location.create(doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0))
            });
            disposables.push(manager_3.default.registerList(list));
            await manager_3.default.start(['option']);
            await manager_3.default.session.ui.ready;
            await helper_1.default.wait(30);
            await manager_3.default.doAction('preview');
            await nvim.command('wincmd p');
            let win = await nvim.window;
            let isPreview = await win.getVar('previewwindow');
            expect(isPreview).toBe(1);
            let line = await nvim.line;
            expect(line).toBe('foo');
        });
    });
});
describe('list sources', () => {
    beforeEach(async () => {
        await nvim.setVar('coc_jump_locations', locations);
    });
    describe('locations', () => {
        it('should highlight ranges', async () => {
            await manager_3.default.start(['--normal', '--auto-preview', 'location']);
            await manager_3.default.session.ui.ready;
            await helper_1.default.waitFor('winnr', ['$'], 3);
            manager_3.default.prompt.cancel();
            await nvim.command('wincmd k');
            let name = await nvim.eval('bufname("%")');
            expect(name).toMatch('sources.test.ts');
            let res = await nvim.call('getmatches');
            expect(res.length).toBe(1);
        });
        it('should not use filename when current buffer only', async () => {
            let filepath = node_1.path.join(os_1.default.tmpdir(), 'b7d9e548-00ec-4419-98a8-dc03874e405c');
            let doc = await helper_1.default.createDocument(filepath);
            let locations = [{
                    filename: filepath,
                    bufnr: doc.bufnr,
                    lnum: 1,
                    col: 1,
                    text: 'multiple'
                }, {
                    filename: filepath,
                    bufnr: doc.bufnr,
                    lnum: 1,
                    col: 1,
                    end_lnum: 2,
                    end_col: 1,
                    text: 'multiple'
                }];
            await nvim.setVar('coc_jump_locations', locations);
            await manager_3.default.start(['--normal', '--auto-preview', 'location']);
            await manager_3.default.session.ui.ready;
        });
        it('should change highlight on cursor move', async () => {
            await manager_3.default.start(['--normal', '--auto-preview', 'location']);
            await manager_3.default.session.ui.ready;
            await nvim.command('exe 2');
            let bufnr = await nvim.eval('bufnr("%")');
            await events_1.default.fire('CursorMoved', [bufnr, [2, 1]]);
            await helper_1.default.waitFor('winnr', ['$'], 3);
            await nvim.command('wincmd k');
            let res = await nvim.call('getmatches');
            expect(res.length).toBe(1);
            expect(res[0]['pos1']).toEqual([3, 1, 6]);
        });
        it('should highlight multiple line range', async () => {
            await manager_3.default.start(['--normal', '--auto-preview', 'location']);
            await manager_3.default.session.ui.ready;
            await nvim.command('exe 3');
            let bufnr = await nvim.eval('bufnr("%")');
            await events_1.default.fire('CursorMoved', [bufnr, [2, 1]]);
            await helper_1.default.waitFor('winnr', ['$'], 3);
            await nvim.command('wincmd k');
            let res = await nvim.call('getmatches');
            expect(res.length).toBe(1);
            expect(res[0]['pos1']).toBeDefined();
            expect(res[0]['pos2']).toBeDefined();
        });
        it('should do open action', async () => {
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('open');
            let name = await nvim.eval('bufname("%")');
            expect(name).toMatch('sources.test.ts');
        });
        it('should do quickfix action', async () => {
            await nvim.setVar('coc_quickfix_open_command', 'copen', false);
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.session.ui.selectAll();
            await manager_3.default.doAction('quickfix');
            let buftype = await nvim.eval('&buftype');
            expect(buftype).toBe('quickfix');
        });
        it('should do refactor action', async () => {
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('refactor');
            let name = await nvim.eval('bufname("%")');
            expect(name).toMatch('coc_refactor');
        });
        it('should do tabe action', async () => {
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('tabe');
            let tabs = await nvim.tabpages;
            expect(tabs.length).toBe(2);
        });
        it('should do drop action', async () => {
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('drop');
            let name = await nvim.eval('bufname("%")');
            expect(name).toMatch('sources.test.ts');
        });
        it('should do vsplit action', async () => {
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('vsplit');
            let name = await nvim.eval('bufname("%")');
            expect(name).toMatch('sources.test.ts');
        });
        it('should do split action', async () => {
            await manager_3.default.start(['--normal', 'location']);
            await manager_3.default.session.ui.ready;
            await manager_3.default.doAction('split');
            let name = await nvim.eval('bufname("%")');
            expect(name).toMatch('sources.test.ts');
        });
    });
    describe('commands', () => {
        it('should do run action', async () => {
            var _a;
            await manager_3.default.start(['commands']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            await manager_3.default.doAction();
        });
        it('should load commands source', async () => {
            var _a;
            let registry = registry_1.Registry.as(extension.Extensions.ExtensionContribution);
            registry.registerExtension('single', {
                name: 'single',
                directory: os_1.default.tmpdir(),
                onCommands: ['cmd', 'cmd'],
                commands: [{ command: 'cmd', title: 'title' }]
            });
            await manager_3.default.start(['commands']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            await manager_3.default.doAction('append');
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch(':CocCommand');
            registry.unregistExtension('single');
        });
    });
    describe('diagnostics', () => {
        function createDiagnostic(msg, range, severity, code) {
            range = range ? range : vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1);
            return vscode_languageserver_protocol_1.Diagnostic.create(range, msg, severity || vscode_languageserver_protocol_1.DiagnosticSeverity.Error, code);
        }
        async function createDocument(name) {
            let doc = await helper_1.default.createDocument(name);
            let collection = manager_1.default.create('test');
            disposables.push({
                dispose: () => {
                    collection.clear();
                    collection.dispose();
                }
            });
            let diagnostics = [];
            await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {
                start: 0,
                end: -1,
                strictIndexing: false
            });
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(0, 2, 0, 4), vscode_languageserver_protocol_1.DiagnosticSeverity.Error, 1001));
            diagnostics.push(createDiagnostic('warning', vscode_languageserver_protocol_1.Range.create(0, 5, 0, 6), vscode_languageserver_protocol_1.DiagnosticSeverity.Warning, 1002));
            diagnostics.push(createDiagnostic('information', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 1), vscode_languageserver_protocol_1.DiagnosticSeverity.Information, 1003));
            diagnostics.push(createDiagnostic('hint', vscode_languageserver_protocol_1.Range.create(1, 2, 1, 3), vscode_languageserver_protocol_1.DiagnosticSeverity.Hint, 1004));
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(2, 0, 2, 2), vscode_languageserver_protocol_1.DiagnosticSeverity.Error, 1005));
            collection.set(doc.uri, diagnostics);
            await doc.synchronize();
            return doc;
        }
        it('should get label', async () => {
            let item = {
                code: 1000,
                col: 0,
                end_col: 1,
                end_lnum: 1,
                file: os_1.default.tmpdir(),
                level: 0,
                lnum: 1,
                location: vscode_languageserver_protocol_1.Location.create('file:///1', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)),
                message: 'message',
                severity: 'error',
                source: 'source'
            };
            expect((0, diagnostics_1.convertToLabel)(item, process.cwd(), false).indexOf('1000')).toBe(-1);
            expect((0, diagnostics_1.convertToLabel)(item, process.cwd(), true, 'hidden').includes('[source 1000]')).toBe(true);
        });
        it('should load diagnostics source', async () => {
            var _a;
            await createDocument('a');
            await manager_3.default.start(['diagnostics']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
        });
        it('should refresh on diagnostics refresh', async () => {
            var _a;
            let doc = await createDocument('bar');
            await manager_3.default.start(['diagnostics']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            let diagnostics = [];
            let collection = manager_1.default.create('test');
            diagnostics.push(createDiagnostic('error', vscode_languageserver_protocol_1.Range.create(2, 0, 2, 2), vscode_languageserver_protocol_1.DiagnosticSeverity.Error, 1009));
            collection.set(doc.uri, diagnostics);
            await helper_1.default.wait(50);
            let buf = await nvim.buffer;
            let lines = await buf.lines;
            expect(lines.length).toBeGreaterThan(0);
        });
    });
    describe('extensions', () => {
        it('should load extensions source', async () => {
            let folder = node_1.path.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_1.default.mkdirSync(node_1.path.join(folder, 'foo'), { recursive: true });
            fs_1.default.mkdirSync(node_1.path.join(folder, 'bar'), { recursive: true });
            let infos = [];
            infos.push({
                id: 'foo',
                version: '1.0.0',
                description: 'foo',
                root: node_1.path.join(folder, 'foo'),
                exotic: false,
                state: 'activated',
                isLocal: false,
                isLocked: true,
                packageJSON: { name: 'foo', engines: {} }
            });
            infos.push({
                id: 'bar',
                version: '1.0.0',
                description: 'bar',
                root: node_1.path.join(folder, 'bar'),
                exotic: false,
                state: 'activated',
                isLocal: true,
                isLocked: false,
                packageJSON: { name: 'bar', engines: {} }
            });
            let spy = jest.spyOn(index_1.default, 'getExtensionStates').mockImplementation(() => {
                return Promise.resolve(infos);
            });
            const doAction = async (name, item) => {
                let action = source.actions.find(o => o.name == name);
                await action.execute(item);
            };
            let states = new stat_1.ExtensionStat(folder);
            let manager = new manager_2.ExtensionManager(states, folder);
            let source = new extensions_1.default(manager);
            let items = await source.loadItems();
            expect(items.length).toBe(2);
            items[0].data.state = 'disabled';
            await doAction('toggle', items[0]);
            await doAction('toggle', items[1]);
            items[1].data.state = 'loaded';
            await expect(async () => {
                await doAction('toggle', items[1]);
            }).rejects.toThrow(Error);
            await doAction('configuration', items[0]);
            let jsonfile = node_1.path.join(folder, 'bar/package.json');
            fs_1.default.writeFileSync(jsonfile, '{}', 'utf8');
            await doAction('configuration', items[1]);
            fs_1.default.writeFileSync(jsonfile, '{"contributes": {}}', 'utf8');
            await doAction('configuration', items[1]);
            await helper_1.default.mockFunction('coc#ui#open_url', 0);
            await doAction('open', items[1]);
            await doAction('disable', items[0]);
            await doAction('disable', items[1]);
            await doAction('enable', items[0]);
            await doAction('enable', items[1]);
            await doAction('lock', items[0]);
            await expect(async () => {
                await doAction('reload', items[0]);
            }).rejects.toThrow(Error);
            await doAction('uninstall', items);
            await doAction('help', items[0]);
            let helpfile = node_1.path.join(folder, 'bar/readme.md');
            fs_1.default.writeFileSync(helpfile, '', 'utf8');
            await doAction('help', items[1]);
            let bufname = await nvim.eval('bufname("%")');
            expect(bufname).toMatch('readme');
            source.doHighlight();
            spy.mockRestore();
        });
    });
    describe('folders', () => {
        it('should load folders source', async () => {
            await helper_1.default.createDocument(__filename);
            let uid = (0, uuid_1.v4)();
            let source = new folders_1.default();
            const doAction = async (name, item) => {
                let action = source.actions.find(o => o.name == name);
                await action.execute(item);
            };
            let res = await source.loadItems();
            expect(res.length).toBe(1);
            await doAction('delete', res[0]);
            expect(workspace_1.default.folderPaths.length).toBe(0);
            let p = doAction('edit', res[0]);
            await helper_1.default.waitFor('mode', [], 'c');
            await nvim.input('<cr>');
            await p;
            p = doAction('edit', res[0]);
            await helper_1.default.waitFor('mode', [], 'c');
            await nvim.input('<C-u>');
            await nvim.input('<cr>');
            await p;
            p = doAction('newfile', res[0]);
            await helper_1.default.waitFloat();
            await helper_1.default.wait(30);
            await nvim.input('<C-u>');
            await nvim.input('<cr>');
            await p;
            fs_1.default.rmSync(node_1.path.join(os_1.default.tmpdir(), uid), { recursive: true, force: true });
            let filepath = node_1.path.join(os_1.default.tmpdir(), uid, 'bar');
            let spy = jest.spyOn(window_1.default, 'requestInput').mockImplementation(() => {
                return Promise.resolve(filepath);
            });
            await doAction('newfile', res[0]);
            let exists = fs_1.default.existsSync(filepath);
            expect(exists).toBe(true);
            spy.mockRestore();
            workspace_1.default.reset();
        });
    });
    describe('lists', () => {
        it('should get list score', () => {
            expect((0, lists_1.mruScore)(['foo'], 'foo')).toBe(1);
            expect((0, lists_1.mruScore)([], 'foo')).toBe(-1);
        });
        it('should load lists source', async () => {
            var _a;
            await manager_3.default.start(['lists']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            await manager_3.default.doAction();
            await helper_1.default.waitValue(() => {
                let s = manager_3.default.getSession();
                return s && s.name !== 'lists';
            }, true);
        });
    });
    describe('outline', () => {
        it('should load items from provider', async () => {
            let doc = await workspace_1.default.document;
            disposables.push(languages_1.default.registerDocumentSymbolProvider([{ language: '*' }], {
                provideDocumentSymbols: document => {
                    let text = document.getText();
                    let parser = new parser_1.default(text, text.includes('detail'));
                    let res = parser.parse();
                    return Promise.resolve(res);
                }
            }));
            let source = new outline_1.default();
            let context = await createContext({});
            let res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toEqual([]);
            let code = `class myClass {
      fun1() {
      }
    }`;
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), code)]);
            res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(2);
            source.doHighlight();
        });
        it('should load items by ctags', async () => {
            helper_1.default.updateConfiguration('list.source.outline.ctagsFiletypes', ['vim']);
            await nvim.command('edit +setl\\ filetype=vim foo');
            let doc = await workspace_1.default.document;
            expect(doc.filetype).toBe('vim');
            let source = new outline_1.default();
            let context = await createContext({});
            context.args = ['-kind', 'function', '-name', 'name'];
            let res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toEqual([]);
            res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.Cancelled);
            expect(res).toEqual([]);
        });
    });
    describe('services', () => {
        function createService(name) {
            let _onServiceReady = new vscode_languageserver_protocol_1.Emitter();
            // public readonly onServiceReady: Event<void> = this.
            let service = {
                id: name,
                name,
                selector: [{ language: 'vim' }],
                state: services_1.ServiceStat.Initial,
                start() {
                    service.state = services_1.ServiceStat.Running;
                    _onServiceReady.fire();
                    return Promise.resolve();
                },
                dispose() {
                    service.state = services_1.ServiceStat.Stopped;
                },
                stop() {
                    service.state = services_1.ServiceStat.Stopped;
                },
                restart() {
                    service.state = services_1.ServiceStat.Running;
                    _onServiceReady.fire();
                },
                onServiceReady: _onServiceReady.event
            };
            disposables.push(services_1.default.register(service));
            return service;
        }
        it('should load services source', async () => {
            var _a;
            createService('foo');
            createService('bar');
            await manager_3.default.start(['services']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            let lines = await nvim.call('getline', [1, '$']);
            expect(lines.length).toBe(2);
        });
        it('should toggle service state', async () => {
            var _a;
            let service = createService('foo');
            await service.start();
            await manager_3.default.start(['services']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            let ses = manager_3.default.session;
            expect(ses.name).toBe('services');
            await ses.doAction('toggle');
            expect(service.state).toBe(services_1.ServiceStat.Stopped);
            await ses.doAction('toggle');
        });
    });
    describe('sources', () => {
        it('should load sources source', async () => {
            var _a;
            await manager_3.default.start(['sources']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            let session = manager_3.default.getSession();
            await session.doAction('open');
            let bufname = await nvim.call('bufname', '%');
            expect(bufname).toMatch(/native/);
        });
        it('should toggle source state', async () => {
            var _a;
            await manager_3.default.start(['sources']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            let session = manager_3.default.getSession();
            await session.doAction('toggle');
            await session.doAction('toggle');
        });
        it('should refresh source', async () => {
            var _a;
            await manager_3.default.start(['sources']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            let session = manager_3.default.getSession();
            await session.doAction('refresh');
        });
    });
    describe('symbols', () => {
        it('should create list item', () => {
            let source = new symbols_1.default();
            let symbolItem = vscode_languageserver_protocol_1.SymbolInformation.create('root', vscode_languageserver_protocol_1.SymbolKind.Method, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), '');
            let item = source.createListItem('', symbolItem, 'kind', './foo');
            expect(item).toBeDefined();
            symbolItem.tags = [vscode_languageserver_protocol_1.SymbolTag.Deprecated];
            item = source.createListItem('', symbolItem, 'kind', './foo');
            let highlights = item.ansiHighlights;
            let find = highlights.find(o => o.hlGroup == 'CocDeprecatedHighlight');
            expect(find).toBeDefined();
            source.fuzzyMatch.setPattern('a');
            item = source.createListItem('a', symbolItem, 'kind', './foo');
            expect(item).toBeDefined();
            source.fuzzyMatch.setPattern('r');
            item = source.createListItem('r', symbolItem, 'kind', './foo');
            highlights = item.ansiHighlights;
            find = highlights.find(o => o.hlGroup == 'CocListSearch');
            expect(find).toBeDefined();
        });
        it('should resolve item', async () => {
            let source = new symbols_1.default();
            let res = await source.resolveItem({ label: 'label', data: {} });
            expect(res).toBeNull();
            let haveResult = false;
            let disposable = languages_1.default.registerWorkspaceSymbolProvider({
                provideWorkspaceSymbols: () => [
                    vscode_languageserver_protocol_1.SymbolInformation.create('root', vscode_languageserver_protocol_1.SymbolKind.Method, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), '')
                ],
                resolveWorkspaceSymbol: symbolItem => {
                    symbolItem.location = vscode_languageserver_protocol_1.Location.create('lsp:///1', vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0));
                    return haveResult ? symbolItem : null;
                }
            });
            disposables.push(disposable);
            let symbols = await languages_1.default.getWorkspaceSymbols('', vscode_languageserver_protocol_1.CancellationToken.None);
            res = await source.resolveItem({ label: 'label', data: { original: symbols[0] } });
            expect(res).toBeNull();
            haveResult = true;
            res = await source.resolveItem({ label: 'label', data: { original: symbols[0] } });
            expect(vscode_languageserver_protocol_1.Location.is(res.location)).toBe(true);
            if (vscode_languageserver_protocol_1.Location.is(res.location)) {
                expect(res.location.uri).toBe('lsp:///1');
            }
        });
        it('should load items', async () => {
            let source = new symbols_1.default();
            let context = await createContext({ interactive: true });
            await expect(async () => {
                await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            }).rejects.toThrow(Error);
            disposables.push(languages_1.default.registerWorkspaceSymbolProvider({
                provideWorkspaceSymbols: () => [
                    vscode_languageserver_protocol_1.SymbolInformation.create('root', vscode_languageserver_protocol_1.SymbolKind.Method, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), vscode_uri_1.URI.file(__filename).toString())
                ]
            }));
            let res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.Cancelled);
            expect(res).toEqual([]);
            context.args = ['-kind', 'function'];
            res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toEqual([]);
            context.args = [];
            helper_1.default.updateConfiguration('list.source.symbols.excludes', ['**/*.ts']);
            res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toEqual([]);
            helper_1.default.updateConfiguration('list.source.symbols.excludes', []);
            res = await source.loadItems(context, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(1);
        });
        it('should load symbols source', async () => {
            var _a;
            await helper_1.default.createDocument();
            disposables.push(languages_1.default.registerWorkspaceSymbolProvider({
                provideWorkspaceSymbols: () => []
            }));
            await manager_3.default.start(['--interactive', 'symbols']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
        });
    });
    describe('links', () => {
        it('should load links source', async () => {
            var _a;
            let disposable = languages_1.default.registerDocumentLinkProvider([{ scheme: 'file' }, { scheme: 'untitled' }], {
                provideDocumentLinks: () => {
                    return [
                        vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5), 'file:///foo'),
                        vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5), 'file:///bar')
                    ];
                }
            });
            await manager_3.default.start(['links']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            await manager_3.default.doAction('jump');
            disposable.dispose();
        });
        it('should resolve target', async () => {
            var _a;
            let disposable = languages_1.default.registerDocumentLinkProvider([{ scheme: 'file' }, { scheme: 'untitled' }], {
                provideDocumentLinks: () => {
                    return [
                        vscode_languageserver_protocol_1.DocumentLink.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5)),
                    ];
                },
                resolveDocumentLink: link => {
                    link.target = 'file:///foo';
                    return link;
                }
            });
            await manager_3.default.start(['links']);
            await ((_a = manager_3.default.session) === null || _a === void 0 ? void 0 : _a.ui.ready);
            expect(manager_3.default.isActivated).toBe(true);
            await manager_3.default.doAction('open');
            disposable.dispose();
        });
    });
});
//# sourceMappingURL=sources.test.js.map