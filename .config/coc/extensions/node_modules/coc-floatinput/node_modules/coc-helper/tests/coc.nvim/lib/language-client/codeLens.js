'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeLensFeature = void 0;
const tslib_1 = require("tslib");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
class CodeLensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeLens').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'codeLens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeCodeLensEmitter.fire();
            }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options)
            return;
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const emitter = new protocol_1.Emitter();
        const provider = {
            onDidChangeCodeLenses: emitter.event,
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return this.sendRequest(protocol_1.CodeLensRequest.type, cv.asCodeLensParams(document), token);
                };
                const middleware = client.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return this.sendRequest(protocol_1.CodeLensResolveRequest.type, codeLens, token, codeLens);
                    };
                    const middleware = client.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [languages_1.default.registerCodeLensProvider(options.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: emitter }];
    }
}
exports.CodeLensFeature = CodeLensFeature;
//# sourceMappingURL=codeLens.js.map