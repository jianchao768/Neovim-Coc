'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languages_1 = tslib_1.__importStar(require("../languages"));
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
class Rename {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
    }
    async getWordEdit() {
        let { doc, position } = await this.handler.getCurrentState();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || (0, position_1.emptyRange)(range))
            return null;
        let curname = doc.textDocument.getText(range);
        if (languages_1.default.hasProvider(languages_1.ProviderName.Rename, doc.textDocument)) {
            await doc.synchronize();
            let requestTokenSource = new protocol_1.CancellationTokenSource();
            let res = await languages_1.default.prepareRename(doc.textDocument, position, requestTokenSource.token);
            if (res !== false) {
                let newName = curname.startsWith('a') ? 'b' : 'a';
                let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, newName, requestTokenSource.token);
                if (edit)
                    return edit;
            }
        }
        void window_1.default.showInformationMessage('Rename provider not found, extract word ranges from current buffer');
        let ranges = doc.getSymbolRanges(curname);
        return {
            changes: {
                [doc.uri]: ranges.map(r => ({ range: r, newText: curname }))
            }
        };
    }
    async rename(newName) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.Rename, doc.textDocument);
        await doc.synchronize();
        let token = (new protocol_1.CancellationTokenSource()).token;
        let res = await languages_1.default.prepareRename(doc.textDocument, position, token);
        if (res === false) {
            void window_1.default.showWarningMessage('Invalid position for rename');
            return false;
        }
        let curname;
        if (!newName) {
            if (vscode_languageserver_types_1.Range.is(res)) {
                curname = doc.textDocument.getText(res);
                await window_1.default.moveTo(res.start);
            }
            else if (res && typeof res.placeholder === 'string') {
                curname = res.placeholder;
            }
            else {
                curname = await this.nvim.eval('expand("<cword>")');
            }
            const config = workspace_1.default.getConfiguration('coc.preferences', null);
            newName = await window_1.default.requestInput('New name', config.get('renameFillCurrent', true) ? curname : undefined);
        }
        if (newName === '')
            void window_1.default.showWarningMessage('Empty word, rename canceled');
        if (!newName)
            return false;
        let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, newName, token);
        if (token.isCancellationRequested || !edit)
            return false;
        await workspace_1.default.applyEdit(edit);
        this.nvim.redrawVim();
        return true;
    }
}
exports.default = Rename;
//# sourceMappingURL=rename.js.map