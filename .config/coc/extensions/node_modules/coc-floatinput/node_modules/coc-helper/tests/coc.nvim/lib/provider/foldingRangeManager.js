'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const manager_1 = tslib_1.__importDefault(require("./manager"));
class FoldingRangeManager extends manager_1.default {
    register(selector, provider) {
        return this.addProvider({
            id: (0, uuid_1.v4)(),
            selector,
            provider
        });
    }
    /**
     * Multiple providers can be registered for a language. In that case providers are asked in
     * parallel and the results are merged.
     * If multiple folding ranges start at the same position, only the range of the first registered provider is used.
     * If a folding range overlaps with an other range that has a smaller position, it is also ignored.
     */
    async provideFoldingRanges(document, context, token) {
        let items = this.getProviders(document);
        let ranges = [];
        let results = await Promise.allSettled(items.map(item => {
            return Promise.resolve(item.provider.provideFoldingRanges(document, context, token)).then(res => {
                if (Array.isArray(res) && res.length > 0) {
                    if (ranges.length == 0) {
                        ranges.push(...res);
                    }
                    else {
                        for (let r of res) {
                            let sp = getParent(r.startLine, ranges);
                            if ((sp === null || sp === void 0 ? void 0 : sp.startLine) === r.startLine)
                                continue;
                            let ep = getParent(r.endLine, ranges);
                            if (sp === ep) {
                                ranges.push(r);
                            }
                        }
                    }
                    ranges.sort((a, b) => a.startLine - b.startLine);
                }
            });
        }));
        this.handleResults(results, 'provideFoldingRanges');
        return ranges;
    }
}
exports.default = FoldingRangeManager;
function getParent(line, sortedRanges) {
    for (let r of sortedRanges) {
        if (line >= r.startLine) {
            if (line <= r.endLine) {
                return r;
            }
            else {
                continue;
            }
        }
        else {
            break;
        }
    }
    return undefined;
}
//# sourceMappingURL=foldingRangeManager.js.map