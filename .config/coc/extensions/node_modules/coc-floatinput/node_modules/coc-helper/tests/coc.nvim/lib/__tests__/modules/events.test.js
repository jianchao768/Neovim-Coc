"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const events_1 = tslib_1.__importDefault(require("../../events"));
const util_1 = require("../../util");
const errors_1 = require("../../util/errors");
const disposables = [];
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
});
describe('register handler', () => {
    it('should fire InsertEnter and InsertLeave when necessary', async () => {
        let fn = jest.fn();
        events_1.default.on('InsertEnter', fn, null, disposables);
        events_1.default.on('InsertLeave', fn, null, disposables);
        expect(events_1.default.insertMode).toBe(false);
        await events_1.default.fire('CursorMovedI', [1, [1, 1]]);
        expect(events_1.default.insertMode).toBe(true);
        await events_1.default.fire('CursorMoved', [1, [1, 1]]);
        expect(events_1.default.insertMode).toBe(false);
        expect(fn).toBeCalledTimes(2);
    });
    it('should not add insertChar with TextChangedI after PumInsert', async () => {
        await events_1.default.fire('PumInsert', ['foo']);
        let pre;
        events_1.default.on('TextChangedP', (_bufnr, info) => {
            pre = info.pre;
        });
        await events_1.default.fire('TextChangedI', [1, {
                lnum: 1,
                col: 4,
                line: 'foo',
                changedtick: 1,
            }]);
        expect(pre).toBe('foo');
    });
    it('should track slow handler', async () => {
        let fn = jest.fn();
        let spy = jest.spyOn(console, 'error').mockImplementation(() => {
            fn();
        });
        events_1.default.on('BufWritePre', async () => {
            await (0, util_1.wait)(50);
        }, null, disposables);
        events_1.default.timeout = 20;
        events_1.default.requesting = true;
        await events_1.default.fire('BufWritePre', [1, '', 1]);
        spy.mockRestore();
        events_1.default.requesting = false;
        events_1.default.timeout = 1000;
        expect(fn).toBeCalled();
    });
    it('should on throw on handler error', async () => {
        events_1.default.on('BufWritePre', async () => {
            throw new Error('test error');
        }, null, disposables);
        events_1.default.on('BufWritePre', () => {
            throw new errors_1.CancellationError();
        }, null, disposables);
        await events_1.default.fire('BufWritePre', [1, '', 1]);
    });
    it('should register single handler', async () => {
        let fn = jest.fn();
        let obj = {};
        let disposable = events_1.default.on('BufEnter', fn, obj);
        disposables.push(disposable);
        await events_1.default.fire('BufEnter', ['a', 'b']);
        expect(fn).toBeCalledWith('a', 'b');
    });
    it('should register multiple events', async () => {
        let fn = jest.fn();
        let disposable = events_1.default.on(['TaskExit', 'TaskStderr'], fn);
        disposables.push(disposable);
        await events_1.default.fire('TaskExit', []);
        await events_1.default.fire('TaskStderr', []);
        expect(fn).toBeCalledTimes(2);
    });
    it('should resolve after timeout', async () => {
        let fn = () => new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, 20);
        });
        let disposable = events_1.default.on('FocusGained', fn, {});
        disposables.push(disposable);
        let ts = Date.now();
        await events_1.default.fire('FocusGained', []);
        expect(Date.now() - ts >= 10).toBe(true);
    });
    it('should emit TextInsert after TextChangedI', async () => {
        let arr = [];
        events_1.default.on('TextInsert', () => {
            arr.push('insert');
        }, null, disposables);
        events_1.default.on('TextChangedI', () => {
            arr.push('change');
        }, null, disposables);
        await events_1.default.fire('InsertCharPre', ['i', 1]);
        await events_1.default.fire('TextChangedI', [1, {
                lnum: 1,
                col: 2,
                pre: 'i',
                changedtick: 1,
                line: 'i'
            }]);
        expect(events_1.default.lastChangeTs).toBeDefined();
        await events_1.default.race(['TextInsert']);
        expect(arr).toEqual(['change', 'insert']);
    });
    it('should race events', async () => {
        let p = events_1.default.race(['InsertCharPre', 'TextChangedI', 'MenuPopupChanged']);
        await events_1.default.fire('InsertCharPre', ['i', 1]);
        await events_1.default.fire('TextChangedI', [1, {
                lnum: 1,
                col: 2,
                pre: 'i',
                changedtick: 1
            }]);
        let res = await p;
        expect(res.name).toBe('InsertCharPre');
        res = await events_1.default.race(['TextChanged'], 50);
        expect(res).toBeUndefined();
    });
    it('should race same events', async () => {
        let arr = [];
        void events_1.default.race(['TextChangedI'], 200).then(res => {
            arr.push(res);
        });
        void events_1.default.race(['TextChangedI'], 200).then(res => {
            arr.push(res);
        });
        await events_1.default.fire('TextChangedI', [2, {}]);
        expect(arr.length).toBe(2);
        expect(arr.map(o => o.name)).toEqual(['TextChangedI', 'TextChangedI']);
    });
    it('should cancel race by CancellationToken', async () => {
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        setTimeout(() => {
            tokenSource.cancel();
        }, 20);
        let res = await events_1.default.race(['TextChanged'], tokenSource.token);
        expect(res).toBeUndefined();
    });
});
//# sourceMappingURL=events.test.js.map