"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const inlayHintManager_1 = require("../../provider/inlayHintManager");
const util_1 = require("../../util");
const errors_1 = require("../../util/errors");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let handler;
let disposables = [];
let ns;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    handler = helper_1.default.plugin.getHandler().inlayHintHandler;
    ns = await nvim.createNamespace('coc-inlayHint');
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
async function registerProvider(content) {
    let doc = await workspace_1.default.document;
    let disposable = languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
        provideInlayHints: (document, range) => {
            let content = document.getText(range);
            let lines = content.split(/\r?\n/);
            let hints = [];
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                if (!line.length)
                    continue;
                let parts = line.split(/\s+/);
                let kind = i == 0 ? vscode_languageserver_protocol_1.InlayHintKind.Type : vscode_languageserver_protocol_1.InlayHintKind.Parameter;
                hints.push(...parts.map(s => vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(range.start.line + i, line.length), s, kind)));
            }
            return hints;
        }
    });
    await doc.buffer.setLines(content.split(/\n/), { start: 0, end: -1 });
    await doc.synchronize();
    return disposable;
}
async function waitRefresh(bufnr) {
    let buf = handler.getItem(bufnr);
    return new Promise((resolve, reject) => {
        let timer = setTimeout(() => {
            reject(new Error('not refresh after 1s'));
        }, 1000);
        buf.onDidRefresh(() => {
            clearTimeout(timer);
            resolve();
        });
    });
}
describe('InlayHint', () => {
    describe('utils', () => {
        it('should check same hint', () => {
            let hint = vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo');
            expect((0, inlayHintManager_1.sameHint)(hint, vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar'))).toBe(false);
            expect((0, inlayHintManager_1.sameHint)(hint, vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), [{ value: 'foo' }]))).toBe(true);
        });
        it('should check valid hint', () => {
            let hint = vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo');
            expect((0, inlayHintManager_1.isValidInlayHint)(hint, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0))).toBe(true);
            expect((0, inlayHintManager_1.isValidInlayHint)(vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), ''), vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0))).toBe(false);
            expect((0, inlayHintManager_1.isValidInlayHint)(vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(3, 0), 'foo'), vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0))).toBe(false);
            expect((0, inlayHintManager_1.isValidInlayHint)({ label: 'f' }, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0))).toBe(false);
        });
        it('should check inlayHint instance', async () => {
            expect((0, inlayHintManager_1.isInlayHint)(null)).toBe(false);
            let position = vscode_languageserver_protocol_1.Position.create(0, 0);
            expect((0, inlayHintManager_1.isInlayHint)({ position, label: null })).toBe(false);
            expect((0, inlayHintManager_1.isInlayHint)({ position, label: [{ value: '' }] })).toBe(true);
        });
    });
    describe('provideInlayHints', () => {
        it('should throw when failed', async () => {
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
                provideInlayHints: () => {
                    return Promise.reject(new Error('Test failure'));
                }
            }));
            let doc = await workspace_1.default.document;
            let fn = async () => {
                let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
                await languages_1.default.provideInlayHints(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0), tokenSource.token);
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should merge provide results', async () => {
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
                provideInlayHints: () => {
                    return [vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')];
                }
            }));
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
                provideInlayHints: () => {
                    return [
                        vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo'),
                        vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(1, 0), 'bar'),
                        vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(5, 0), 'bad')
                    ];
                }
            }));
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
                provideInlayHints: () => {
                    return null;
                }
            }));
            let doc = await workspace_1.default.document;
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await languages_1.default.provideInlayHints(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 3, 0), tokenSource.token);
            expect(res.length).toBe(2);
        });
        it('should resolve inlay hint', async () => {
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
                provideInlayHints: () => {
                    return [vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')];
                },
                resolveInlayHint: hint => {
                    hint.tooltip = 'tooltip';
                    return hint;
                }
            }));
            let doc = await workspace_1.default.document;
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await languages_1.default.provideInlayHints(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0), tokenSource.token);
            let resolved = await languages_1.default.resolveInlayHint(res[0], tokenSource.token);
            expect(resolved.tooltip).toBe('tooltip');
            resolved = await languages_1.default.resolveInlayHint(resolved, tokenSource.token);
            expect(resolved.tooltip).toBe('tooltip');
        });
        it('should not resolve when cancelled', async () => {
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: '*' }], {
                provideInlayHints: () => {
                    return [vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo')];
                },
                resolveInlayHint: (hint, token) => {
                    return new Promise(resolve => {
                        token.onCancellationRequested(() => {
                            clearTimeout(timer);
                            resolve(null);
                        });
                        let timer = setTimeout(() => {
                            resolve(Object.assign({}, hint, { tooltip: 'tooltip' }));
                        }, 200);
                    });
                }
            }));
            let doc = await workspace_1.default.document;
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let res = await languages_1.default.provideInlayHints(doc.textDocument, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0), tokenSource.token);
            let p = languages_1.default.resolveInlayHint(res[0], tokenSource.token);
            tokenSource.cancel();
            let resolved = await p;
            expect(resolved.tooltip).toBeUndefined();
        });
    });
    describe('env & options', () => {
        it('should not create when virtualText not supported', async () => {
            Object.assign(workspace_1.default.env, {
                virtualText: false
            });
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                Object.assign(workspace_1.default.env, {
                    virtualText: true
                });
            }));
            let doc = await helper_1.default.createDocument();
            let item = handler.getItem(doc.bufnr);
            expect(item).toBeUndefined();
        });
        it('should not enabled when disabled by configuration', async () => {
            helper_1.default.updateConfiguration('inlayHint.filetypes', []);
            let doc = await workspace_1.default.document;
            let item = handler.getItem(doc.bufnr);
            item.clearVirtualText();
            expect(item.enabled).toBe(false);
            helper_1.default.updateConfiguration('inlayHint.filetypes', ['dos']);
            doc = await helper_1.default.createDocument();
            item = handler.getItem(doc.bufnr);
            expect(item.enabled).toBe(false);
        });
    });
    describe('configuration', () => {
        it('should refresh on insert mode', async () => {
            helper_1.default.updateConfiguration('inlayHint.refreshOnInsertMode', true);
            let doc = await helper_1.default.createDocument();
            let disposable = await registerProvider('foo\nbar');
            disposables.push(disposable);
            await nvim.input('i');
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'baz\n')]);
            await waitRefresh(doc.bufnr);
            let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true });
            let obj = markers[0][3].virt_text;
            expect(obj).toEqual([['baz', 'CocInlayHintType']]);
            expect(markers[1][3].virt_text).toEqual([['foo', 'CocInlayHintParameter']]);
        });
        it('should disable parameter inlayHint', async () => {
            helper_1.default.updateConfiguration('inlayHint.enableParameter', false);
            let doc = await helper_1.default.createDocument();
            let disposable = await registerProvider('foo\nbar');
            disposables.push(disposable);
            await waitRefresh(doc.bufnr);
            let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(1);
        });
        it('should use custom subseparator', async () => {
            helper_1.default.updateConfiguration('inlayHint.subSeparator', '|');
            let doc = await helper_1.default.createDocument();
            let disposable = await registerProvider('foo bar');
            disposables.push(disposable);
            await waitRefresh(doc.bufnr);
            let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true });
            let virt_text = markers[0][3].virt_text;
            expect(virt_text[1]).toEqual(['|', 'CocInlayHintType']);
        });
    });
    describe('toggle inlayHint', () => {
        it('should not throw when buffer not exists', async () => {
            handler.toggle(9);
            await commands_1.default.executeCommand('document.toggleInlayHint', 9);
        });
        it('should show message when inlayHint not supported', async () => {
            let doc = await workspace_1.default.document;
            handler.toggle(doc.bufnr);
            let cmdline = await helper_1.default.getCmdline();
            expect(cmdline).toMatch(/not\sfound/);
        });
        it('should show message when not enabled', async () => {
            helper_1.default.updateConfiguration('inlayHint.filetypes', []);
            let doc = await helper_1.default.createDocument();
            let disposable = await registerProvider('');
            disposables.push(disposable);
            handler.toggle(doc.bufnr);
            let cmdline = await helper_1.default.getCmdline();
            expect(cmdline).toMatch(/not\senabled/);
        });
        it('should toggle inlayHints', async () => {
            let doc = await helper_1.default.createDocument();
            let disposable = await registerProvider('foo\nbar');
            disposables.push(disposable);
            handler.toggle(doc.bufnr);
            handler.toggle(doc.bufnr);
            await helper_1.default.waitValue(async () => {
                let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true });
                return markers.length;
            }, 2);
        });
    });
    describe('render()', () => {
        it('should refresh on vim mode', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setLine('foo bar');
            let item = handler.getItem(doc.bufnr);
            let r = vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0);
            item.setVirtualText(r, [], true);
            let hint = {
                label: 'string',
                position: vscode_languageserver_protocol_1.Position.create(0, 0),
                providerId: ''
            };
            let paddingHint = {
                label: 'string',
                position: vscode_languageserver_protocol_1.Position.create(0, 3),
                providerId: '',
                paddingLeft: true,
                paddingRight: true
            };
            item.setVirtualText(r, [hint, paddingHint], true);
            await helper_1.default.waitValue(async () => {
                let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true });
                return markers.length;
            }, 2);
        });
        it('should not refresh when languageId not match', async () => {
            let doc = await workspace_1.default.document;
            disposables.push(languages_1.default.registerInlayHintsProvider([{ language: 'javascript' }], {
                provideInlayHints: () => {
                    let hint = vscode_languageserver_protocol_1.InlayHint.create(vscode_languageserver_protocol_1.Position.create(0, 0), 'foo');
                    return [hint];
                }
            }));
            await nvim.setLine('foo');
            await doc.synchronize();
            await helper_1.default.wait(30);
            let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(0);
        });
        it('should refresh on text change', async () => {
            let buf = await nvim.buffer;
            let disposable = await registerProvider('foo');
            disposables.push(disposable);
            await waitRefresh(buf.id);
            await buf.setLines(['a', 'b', 'c'], { start: 0, end: -1 });
            await waitRefresh(buf.id);
            let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(3);
            let item = handler.getItem(buf.id);
            await item.renderRange();
            expect(item.current.length).toBe(3);
        });
        it('should refresh on insert leave', async () => {
            let doc = await helper_1.default.createDocument();
            let buf = doc.buffer;
            let disposable = await registerProvider('foo');
            disposables.push(disposable);
            await nvim.input('i');
            await helper_1.default.wait(10);
            await buf.setLines(['a', 'b', 'c'], { start: 0, end: -1 });
            await helper_1.default.wait(30);
            let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(0);
            await nvim.input('<esc>');
            await waitRefresh(doc.bufnr);
            markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(3);
        });
        it('should refresh on provider dispose', async () => {
            let buf = await nvim.buffer;
            let disposable = await registerProvider('foo bar');
            await waitRefresh(buf.id);
            disposable.dispose();
            let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBe(0);
            let item = handler.getItem(buf.id);
            expect(item.current.length).toBe(0);
            await item.renderRange();
            expect(item.current.length).toBe(0);
        });
        it('should refresh on scroll', async () => {
            let arr = new Array(200);
            let content = arr.fill('foo').join('\n');
            let buf = await nvim.buffer;
            let disposable = await registerProvider(content);
            disposables.push(disposable);
            await waitRefresh(buf.id);
            let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            let len = markers.length;
            await nvim.command('normal! G');
            await waitRefresh(buf.id);
            await nvim.input('<C-y>');
            await waitRefresh(buf.id);
            markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            expect(markers.length).toBeGreaterThan(len);
        });
        it('should cancel previous render', async () => {
            let buf = await nvim.buffer;
            let disposable = await registerProvider('foo');
            disposables.push(disposable);
            await waitRefresh(buf.id);
            let item = handler.getItem(buf.id);
            await item.renderRange();
            await item.renderRange();
            expect(item.current.length).toBe(1);
        });
        it('should resend request on CancellationError', async () => {
            let called = 0;
            let disposable = languages_1.default.registerInlayHintsProvider([{ language: 'vim' }], {
                provideInlayHints: () => {
                    if (called == 0) {
                        called++;
                        throw new errors_1.CancellationError();
                    }
                    return [];
                }
            });
            disposables.push(disposable);
            let filepath = await (0, helper_1.createTmpFile)('a\n\b\nc\n', disposables);
            let doc = await helper_1.default.createDocument(filepath);
            await nvim.command('setfiletype vim');
            await waitRefresh(doc.buffer.id);
            expect(called).toBe(1);
        });
    });
});
//# sourceMappingURL=inlayHint.test.js.map