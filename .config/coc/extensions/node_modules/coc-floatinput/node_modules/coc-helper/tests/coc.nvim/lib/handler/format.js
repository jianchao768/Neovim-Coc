'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const languages_1 = tslib_1.__importStar(require("../languages"));
const logger_1 = require("../logger");
const manager_1 = tslib_1.__importDefault(require("../snippets/manager"));
const array_1 = require("../util/array");
const index_1 = require("../util/index");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const logger = (0, logger_1.createLogger)('handler-format');
class FormatHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.setConfiguration();
        handler.addDisposable(workspace_1.default.onDidChangeConfiguration(this.setConfiguration, this));
        handler.addDisposable(window_1.default.onDidChangeActiveTextEditor(() => {
            this.setConfiguration();
        }));
        handler.addDisposable(workspace_1.default.onWillSaveTextDocument(event => {
            // the document could be not current one.
            if (this.shouldFormatOnSave(event.document)) {
                let willSaveWaitUntil = async () => {
                    if (!languages_1.default.hasFormatProvider(event.document)) {
                        logger.warn(`Format provider not found for ${event.document.uri}`);
                        return undefined;
                    }
                    let options = await workspace_1.default.getFormatOptions(event.document.uri);
                    let tokenSource = new protocol_1.CancellationTokenSource();
                    let timer;
                    const tp = new Promise(c => {
                        timer = setTimeout(() => {
                            logger.warn(`Format on save ${event.document.uri} timeout after 0.5s`);
                            tokenSource.cancel();
                            c(undefined);
                        }, 500);
                    });
                    const provideEdits = languages_1.default.provideDocumentFormattingEdits(event.document, options, tokenSource.token);
                    let textEdits = await Promise.race([tp, provideEdits]);
                    clearTimeout(timer);
                    return Array.isArray(textEdits) ? textEdits : undefined;
                };
                event.waitUntil(willSaveWaitUntil());
            }
        }));
        handler.addDisposable(events_1.default.on('Enter', async (bufnr) => {
            let res = await events_1.default.race(['CursorMovedI'], 100);
            if (res.args && res.args[0] === bufnr) {
                await this.handleEnter(bufnr);
            }
        }));
        handler.addDisposable(events_1.default.on('TextInsert', async (bufnr, _info, character) => {
            if (!events_1.default.pumvisible)
                await this.tryFormatOnType(character, bufnr);
        }));
        handler.addDisposable(commands_1.default.registerCommand('editor.action.formatDocument', async (uri) => {
            const doc = uri ? workspace_1.default.getDocument(uri) : (await this.handler.getCurrentState()).doc;
            await this.documentFormat(doc);
        }));
        commands_1.default.titles.set('editor.action.formatDocument', 'Format Document');
    }
    shouldFormatOnSave(doc) {
        let { languageId, uri } = doc;
        // the document could be not current one.
        let config = workspace_1.default.getConfiguration('coc.preferences', { uri, languageId });
        let filetypes = config.get('formatOnSaveFiletypes', null);
        let formatOnSave = config.get('formatOnSave', false);
        if (Array.isArray(filetypes))
            return filetypes.includes('*') || filetypes.includes(languageId);
        return formatOnSave;
    }
    setConfiguration(e) {
        var _a;
        if (!e || e.affectsConfiguration('coc.preferences')) {
            let doc = (_a = window_1.default.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document;
            let config = workspace_1.default.getConfiguration('coc.preferences', doc);
            this.preferences = {
                formatOnType: config.get('formatOnType', false),
                formatOnTypeFiletypes: config.get('formatOnTypeFiletypes', null),
                bracketEnterImprove: config.get('bracketEnterImprove', true),
            };
        }
    }
    shouldFormatOnType(filetype) {
        const filetypes = this.preferences.formatOnTypeFiletypes;
        return (0, array_1.isFalsyOrEmpty)(filetype) || filetypes.includes(filetype) || filetypes.includes('*');
    }
    async tryFormatOnType(ch, bufnr, newLine = false) {
        if (!ch || (0, string_1.isAlphabet)(ch.charCodeAt(0)) || !this.preferences.formatOnType)
            return;
        if (manager_1.default.getSession(bufnr) != null)
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || !doc.attached || !this.shouldFormatOnType(doc.filetype))
            return;
        if (!languages_1.default.hasProvider(languages_1.ProviderName.FormatOnType, doc.textDocument)) {
            logger.warn(`Format on type provider not found for buffer: ${doc.uri}`);
            return;
        }
        if (!languages_1.default.canFormatOnType(ch, doc.textDocument))
            return;
        let position;
        let edits = await this.handler.withRequestToken('Format on type', async (token) => {
            position = await window_1.default.getCursorPosition();
            let origLine = doc.getline(position.line - 1);
            // not format for empty line.
            if (newLine && /^\s*$/.test(origLine))
                return;
            await doc.synchronize();
            return await languages_1.default.provideDocumentOnTypeEdits(ch, doc.textDocument, position, token);
        });
        if ((0, array_1.isFalsyOrEmpty)(edits))
            return;
        await doc.applyEdits(edits, false, true);
    }
    async formatCurrentBuffer() {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentFormat(doc);
    }
    async formatCurrentRange(mode) {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentRangeFormat(doc, mode);
    }
    async documentFormat(doc) {
        await doc.synchronize();
        if (!languages_1.default.hasFormatProvider(doc.textDocument)) {
            throw new Error(`Format provider not found for buffer: ${doc.bufnr}`);
        }
        let options = await workspace_1.default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken('format', token => {
            return languages_1.default.provideDocumentFormattingEdits(doc.textDocument, options, token);
        });
        if (textEdits && textEdits.length > 0) {
            await doc.applyEdits(textEdits, false, true);
            return true;
        }
        return false;
    }
    async handleEnter(bufnr) {
        let { nvim } = this;
        let { bracketEnterImprove } = this.preferences;
        await this.tryFormatOnType('\n', bufnr);
        if (bracketEnterImprove) {
            let line = await nvim.call('line', '.') - 1;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc)
                return;
            await doc.patchChange();
            let pre = doc.getline(line - 1);
            let curr = doc.getline(line);
            let prevChar = pre[pre.length - 1];
            if (prevChar && index_1.pariedCharacters.has(prevChar)) {
                let nextChar = curr.trim()[0];
                if (nextChar && index_1.pariedCharacters.get(prevChar) == nextChar) {
                    let edits = [];
                    let opts = await workspace_1.default.getFormatOptions(doc.uri);
                    let space = opts.insertSpaces ? ' '.repeat(opts.tabSize) : '\t';
                    let currIndent = curr.match(/^\s*/)[0];
                    let pos = vscode_languageserver_types_1.Position.create(line - 1, pre.length);
                    // make sure indent of current line
                    if (doc.filetype == 'vim') {
                        let newText = '\n' + currIndent + space;
                        edits.push({ range: vscode_languageserver_types_1.Range.create(line, currIndent.length, line, currIndent.length), newText: '  \\ ' });
                        newText = newText + '\\ ';
                        edits.push({ range: vscode_languageserver_types_1.Range.create(pos, pos), newText });
                        await doc.applyEdits(edits);
                        await window_1.default.moveTo(vscode_languageserver_types_1.Position.create(line, newText.length - 1));
                    }
                    else {
                        await nvim.eval(`feedkeys("\\<Esc>O", 'in')`);
                    }
                }
            }
        }
    }
    async documentRangeFormat(doc, mode) {
        this.handler.checkProvider(languages_1.ProviderName.FormatRange, doc.textDocument);
        await doc.synchronize();
        let range;
        if (mode) {
            range = await window_1.default.getSelectedRange(mode);
            if (!range)
                return -1;
        }
        else {
            let [lnum, count, mode] = await this.nvim.eval("[v:lnum,v:count,mode()]");
            // we can't handle
            if (count == 0 || mode == 'i' || mode == 'R')
                return -1;
            range = vscode_languageserver_types_1.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options = await workspace_1.default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken('Format range', token => {
            return languages_1.default.provideDocumentRangeFormattingEdits(doc.textDocument, range, options, token);
        });
        if (!(0, array_1.isFalsyOrEmpty)(textEdits)) {
            await doc.applyEdits(textEdits, false, true);
            return 0;
        }
        return -1;
    }
}
exports.default = FormatHandler;
//# sourceMappingURL=format.js.map