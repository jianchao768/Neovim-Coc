"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const editors_1 = require("../../core/editors");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const window_1 = tslib_1.__importDefault(require("../../window"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const util_1 = require("../../util");
const vscode_uri_1 = require("vscode-uri");
let editors;
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    editors = workspace_1.default.editors;
});
afterEach(async () => {
    await helper_1.default.reset();
});
afterAll(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.shutdown();
});
describe('util', () => {
    it('should check renamed', async () => {
        await helper_1.default.edit('foo');
        let editor = editors.activeTextEditor;
        expect((0, editors_1.renamed)(editor, {
            bufnr: 0,
            fullpath: '',
            tabid: 1,
            winid: 1000,
        })).toBe(false);
        expect((0, editors_1.renamed)(editor, {
            bufnr: editor.document.bufnr,
            fullpath: '',
            tabid: 1,
            winid: 1000,
        })).toBe(true);
        expect((0, editors_1.renamed)(editor, {
            bufnr: editor.document.bufnr,
            fullpath: vscode_uri_1.URI.parse(editor.document.uri).fsPath,
            tabid: 1,
            winid: 1000,
        })).toBe(false);
        Object.assign(editor, { uri: 'lsp:///1' });
        expect((0, editors_1.renamed)(editor, {
            bufnr: editor.document.bufnr,
            fullpath: '',
            tabid: 1,
            winid: 1000,
        })).toBe(false);
    });
});
describe('editors', () => {
    function assertEditor(editor, tabpagenr, winid) {
        expect(editor).toBeDefined();
        expect(editor.tabpageid).toBe(tabpagenr);
        expect(editor.winid).toBe(winid);
    }
    it('should have active editor', async () => {
        let winid = await nvim.call('win_getid');
        let editor = window_1.default.activeTextEditor;
        assertEditor(editor, 1, winid);
        let editors = window_1.default.visibleTextEditors;
        expect(editors.length).toBe(1);
        workspace_1.default.editors.checkTabs([]);
        workspace_1.default.editors.checkUnloadedBuffers([]);
    });
    it('should create editor not created', async () => {
        await nvim.command(`edit +setl\\ buftype=nofile foo`);
        let doc = await workspace_1.default.document;
        await nvim.command('setl buftype=');
        await events_1.default.fire('BufDetach', [doc.bufnr]);
        await events_1.default.fire('CursorHold', [doc.bufnr]);
        expect(window_1.default.activeTextEditor).toBeDefined();
        expect(window_1.default.visibleTextEditors.length).toBe(1);
    });
    it('should detect buffer rename', async () => {
        let doc = await helper_1.default.createDocument('foo');
        await doc.buffer.setName('bar');
        await events_1.default.fire('CursorHold', [doc.bufnr]);
        expect(window_1.default.activeTextEditor).toBeDefined();
        expect(window_1.default.activeTextEditor.id).toMatch(/bar$/);
    });
    it('should detect buffer switch', async () => {
        let doc = await helper_1.default.createDocument('foo');
        await helper_1.default.createDocument('bar');
        await nvim.command('noa b ' + doc.bufnr);
        await events_1.default.fire('CursorHold', [doc.bufnr]);
        expect(window_1.default.activeTextEditor).toBeDefined();
        expect(window_1.default.activeTextEditor.id).toMatch(/foo$/);
    });
    it('should change active editor on split', async () => {
        let promise = new Promise(resolve => {
            editors.onDidChangeActiveTextEditor(e => {
                resolve(e);
            }, null, disposables);
        });
        await nvim.command('vnew');
        let editor = await promise;
        let winid = await nvim.call('win_getid');
        expect(editor.winid).toBe(winid);
    });
    it('should change active editor on tabe', async () => {
        let promise = new Promise(resolve => {
            editors.onDidChangeActiveTextEditor(e => {
                if (e.document.uri.includes('foo')) {
                    resolve(e);
                }
            }, null, disposables);
        });
        await nvim.command('tabe a | tabe b | tabe foo');
        let editor = await promise;
        let winid = await nvim.call('win_getid');
        expect(editor.winid).toBe(winid);
    });
    it('should change active editor on edit', async () => {
        await nvim.call('win_getid');
        let n = 0;
        let promise = new Promise(resolve => {
            window_1.default.onDidChangeVisibleTextEditors(() => {
                n++;
            }, null, disposables);
            editors.onDidChangeActiveTextEditor(e => {
                n++;
                resolve(e);
            });
        });
        await nvim.command('edit foo');
        let editor = await promise;
        expect(editor.document.uri).toMatch('foo');
        await helper_1.default.waitValue(() => {
            return n;
        }, 2);
    });
    it('should change active editor on window switch', async () => {
        let winid = await nvim.call('win_getid');
        await nvim.command('vs foo');
        await nvim.command('wincmd p');
        let curr = editors.activeTextEditor;
        expect(curr.winid).toBe(winid);
        expect(editors.visibleTextEditors.length).toBe(2);
    });
    it('should cleanup on CursorHold', async () => {
        let promise = new Promise(resolve => {
            editors.onDidChangeActiveTextEditor(e => {
                if (e.document.uri.includes('foo')) {
                    resolve(e);
                }
            }, null, disposables);
        });
        await nvim.command('sp foo');
        await promise;
        await nvim.command('noa close');
        let bufnr = await nvim.eval("bufnr('%')");
        await events_1.default.fire('CursorHold', [bufnr]);
        expect(editors.visibleTextEditors.length).toBe(1);
    });
    it('should cleanup on create', async () => {
        let winid = await nvim.call('win_getid');
        let promise = new Promise(resolve => {
            editors.onDidChangeActiveTextEditor(e => {
                if (e.document.uri.includes('foo')) {
                    resolve(e);
                }
            }, null, disposables);
        });
        await nvim.command('tabe foo');
        await promise;
        await nvim.call('win_execute', [winid, 'noa close']);
        await nvim.command('edit bar');
        expect(editors.visibleTextEditors.length).toBe(2);
    });
    it('should have current tabpageid after tab changed', async () => {
        await nvim.command('tabe|doautocmd CursorHold');
        await helper_1.default.waitValue(() => {
            return editors.visibleTextEditors.length;
        }, 2);
        let ids = [];
        editors.visibleTextEditors.forEach(editor => {
            ids.push(editor.tabpageid);
        });
        let editor = editors.visibleTextEditors[editors.visibleTextEditors.length - 1];
        let previousId = editor.tabpageid;
        await nvim.command('normal! 1gt');
        await nvim.command('tabe');
        await helper_1.default.waitValue(() => {
            return editors.visibleTextEditors.length;
        }, 3);
        expect(editor.tabpageid).toBe(previousId);
        let tid;
        let disposable = editors.onDidTabClose(id => {
            tid = id;
        });
        await nvim.command('tabc');
        await helper_1.default.waitValue(() => {
            return editors.visibleTextEditors.length;
        }, 2);
        disposable.dispose();
        expect(editor.tabpageid).toBe(previousId);
        expect(tid).toBeDefined();
        editor = editors.visibleTextEditors.find(o => o.tabpageid == tid);
        expect(editor).toBeUndefined();
    });
});
//# sourceMappingURL=editors.test.js.map