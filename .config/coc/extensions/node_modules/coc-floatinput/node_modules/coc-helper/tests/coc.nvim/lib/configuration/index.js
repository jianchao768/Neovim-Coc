'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.folderSettingsSchemaId = exports.userSettingsSchemaId = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const schema_json_1 = tslib_1.__importDefault(require("../../data/schema.json"));
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const extensionRegistry_1 = require("../util/extensionRegistry");
const fs_1 = require("../util/fs");
const is_1 = require("../util/is");
const jsonRegistry_1 = require("../util/jsonRegistry");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const registry_1 = require("../util/registry");
const configuration_1 = require("./configuration");
const event_1 = require("./event");
const model_1 = require("./model");
const parser_1 = require("./parser");
const registry_2 = require("./registry");
const types_1 = require("./types");
const util_2 = require("./util");
const logger = (0, logger_1.createLogger)('configurations');
exports.userSettingsSchemaId = 'vscode://schemas/settings/user';
exports.folderSettingsSchemaId = 'vscode://schemas/settings/folder';
const jsonRegistry = registry_1.Registry.as(jsonRegistry_1.Extensions.JSONContribution);
const configuration = registry_1.Registry.as(registry_2.Extensions.Configuration);
class Configurations {
    constructor(userConfigFile, _proxy, noWatch = global.__TEST__, cwd = process.cwd()) {
        this.userConfigFile = userConfigFile;
        this._proxy = _proxy;
        this.noWatch = noWatch;
        this._watchedFiles = new Set();
        this._errors = new Map();
        this._onError = new protocol_1.Emitter();
        this._onChange = new protocol_1.Emitter();
        this.disposables = [];
        this._initialized = false;
        this.cached = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let defaultConfiguration = this.loadDefaultConfigurations();
        let userConfiguration = this.parseConfigurationModel(this.userConfigFile);
        this._configuration = new configuration_1.Configuration(defaultConfiguration, userConfiguration);
        this.watchFile(this.userConfigFile, types_1.ConfigurationTarget.User);
        let filepath = this.folderToConfigfile(cwd);
        if (filepath)
            this.addFolderFile(filepath, true);
        this._initialConfiguration = this.getConfiguration(undefined, null);
    }
    /**
     * Contains default and user configuration only
     */
    get initialConfiguration() {
        return this._initialConfiguration;
    }
    get markdownPreference() {
        let preferences = this._initialConfiguration.get('coc.preferences');
        return {
            excludeImages: preferences.excludeImageLinksInMarkdownDocument,
            breaks: preferences.enableGFMBreaksInMarkdownDocument
        };
    }
    get errors() {
        return this._errors;
    }
    get configuration() {
        return this._configuration;
    }
    flushConfigurations() {
        this._initialized = true;
        configuration.registerConfigurations(this.cached);
        this.cached = [];
    }
    updateConfigurations(add, remove) {
        if (this._initialized) {
            if (!(0, array_1.isFalsyOrEmpty)(remove)) {
                configuration.updateConfigurations({ add, remove });
            }
            else {
                configuration.registerConfigurations(add);
            }
        }
        else {
            this.cached.push(...add);
        }
    }
    loadDefaultConfigurations() {
        // register properties and listen events
        let node = { properties: (0, registry_1.convertProperties)(schema_json_1.default.properties) };
        configuration.registerConfiguration(node);
        configuration.onDidUpdateConfiguration(e => {
            if (e.properties.length === 0)
                return;
            // update default configuration with new value
            const dict = configuration.getConfigurationProperties();
            const toRemove = [];
            const root = Object.create(null);
            const keys = [];
            for (let key of e.properties) {
                let def = dict[key];
                if (def) {
                    keys.push(key);
                    let val = def.default;
                    (0, util_2.addToValueTree)(root, key, val, msg => {
                        logger.error(`Conflict configuration: ${msg}`);
                    });
                }
                else {
                    toRemove.push(key);
                }
            }
            const model = this._configuration.defaults.merge(new model_1.ConfigurationModel(root, keys));
            toRemove.forEach(key => { model.removeValue(key); });
            if (!this._initialized) {
                // no change event fired
                this._configuration.updateDefaultConfiguration(model);
                this._initialConfiguration = this.getConfiguration(undefined, null);
            }
            else {
                this.changeConfiguration(types_1.ConfigurationTarget.Default, model, undefined, e.properties);
            }
        }, null, this.disposables);
        let properties = configuration.getConfigurationProperties();
        let config = {};
        let keys = [];
        Object.keys(properties).forEach(key => {
            let value = properties[key].default;
            keys.push(key);
            (0, util_2.addToValueTree)(config, key, value, undefined);
        });
        let model = new model_1.ConfigurationModel(config, keys);
        return model;
    }
    getDescription(key) {
        let property = registry_2.allSettings.properties[key];
        return property ? property.description : undefined;
    }
    getJSONSchema(uri) {
        if (uri === exports.userSettingsSchemaId) {
            return {
                properties: registry_2.allSettings.properties,
                patternProperties: registry_2.allSettings.patternProperties,
                definitions: Object.assign((0, extensionRegistry_1.getExtensionDefinitions)(), schema_json_1.default.definitions),
                additionalProperties: false,
                allowTrailingCommas: true,
                allowComments: true
            };
        }
        if (uri === exports.folderSettingsSchemaId) {
            return {
                properties: registry_2.resourceSettings.properties,
                patternProperties: registry_2.resourceSettings.patternProperties,
                definitions: Object.assign((0, extensionRegistry_1.getExtensionDefinitions)(), schema_json_1.default.definitions),
                errorMessage: 'Configuration property may not work as folder configuration',
                additionalProperties: false,
                allowTrailingCommas: true,
                allowComments: true
            };
        }
        let schemas = jsonRegistry.getSchemaContributions().schemas;
        if ((0, object_1.hasOwnProperty)(schemas, uri))
            return schemas[uri];
        return undefined;
    }
    parseConfigurationModel(filepath) {
        if (!filepath || !node_1.fs.existsSync(filepath))
            return new model_1.ConfigurationModel();
        let parser = new parser_1.ConfigurationModelParser(filepath);
        let content = node_1.fs.readFileSync(filepath, 'utf8');
        let uri = vscode_uri_1.URI.file(filepath).toString();
        parser.parse(content);
        if (!(0, array_1.isFalsyOrEmpty)(parser.errors)) {
            this._errors.set(uri, parser.errors);
            this._onError.fire({ uri, diagnostics: parser.errors });
        }
        else {
            this._errors.delete(uri);
            this._onError.fire({ uri, diagnostics: [] });
        }
        return parser.configurationModel;
    }
    folderToConfigfile(folder) {
        if ((0, fs_1.sameFile)(folder, node_1.os.homedir()))
            return undefined;
        let filepath = node_1.path.join(folder, `.vim/${constants_1.CONFIG_FILE_NAME}`);
        if ((0, fs_1.sameFile)(filepath, this.userConfigFile))
            return undefined;
        return filepath;
    }
    // change memory configuration
    updateMemoryConfig(props) {
        let keys = Object.keys(props);
        if (!props || keys.length == 0)
            return;
        let memoryModel = this._configuration.memory.clone();
        let properties = configuration.getConfigurationProperties();
        keys.forEach(key => {
            let val = props[key];
            if (val === undefined) {
                memoryModel.removeValue(key);
            }
            else if (properties[key] != null) {
                memoryModel.setValue(key, val);
            }
            else if ((0, is_1.objectLiteral)(val)) {
                for (let k of Object.keys(val)) {
                    memoryModel.setValue(`${key}.${k}`, val[k]);
                }
            }
            else {
                memoryModel.setValue(key, val);
            }
        });
        this.changeConfiguration(types_1.ConfigurationTarget.Memory, memoryModel, undefined, keys);
    }
    /**
     * Add new folder config file.
     */
    addFolderFile(configFilePath, fromCwd = false, resource) {
        let folder = (0, fs_1.normalizeFilePath)(node_1.path.resolve(configFilePath, '../..'));
        if (this._configuration.hasFolder(folder) || !node_1.fs.existsSync(configFilePath))
            return false;
        this.watchFile(configFilePath, types_1.ConfigurationTarget.WorkspaceFolder);
        let model = this.parseConfigurationModel(configFilePath);
        this._configuration.addFolderConfiguration(folder, model, resource);
        logger.info(`Add folder configuration from ${fromCwd ? 'cwd' : 'file'}:`, configFilePath);
        return true;
    }
    watchFile(filepath, target) {
        if (!node_1.fs.existsSync(filepath) || this._watchedFiles.has(filepath) || this.noWatch)
            return;
        this._watchedFiles.add(filepath);
        const folder = types_1.ConfigurationTarget.WorkspaceFolder ? (0, fs_1.normalizeFilePath)(node_1.path.resolve(filepath, '../..')) : undefined;
        let disposable = (0, fs_1.watchFile)(filepath, () => {
            let model = this.parseConfigurationModel(filepath);
            this.changeConfiguration(target, model, folder);
        });
        this.disposables.push(disposable);
    }
    /**
     * Update ConfigurationModel and fire event.
     */
    changeConfiguration(target, model, folder, keys) {
        const listOnly = target === types_1.ConfigurationTarget.Default && keys && keys.every(key => key.startsWith('list.source'));
        let configuration = this._configuration;
        let previous = listOnly ? undefined : configuration.toData();
        let change;
        if (target === types_1.ConfigurationTarget.Default) {
            change = configuration.compareAndUpdateDefaultConfiguration(model, keys);
        }
        else if (target === types_1.ConfigurationTarget.User) {
            change = configuration.compareAndUpdateUserConfiguration(model);
        }
        else if (target === types_1.ConfigurationTarget.Workspace) {
            change = configuration.compareAndUpdateWorkspaceConfiguration(model);
        }
        else if (target === types_1.ConfigurationTarget.WorkspaceFolder) {
            change = configuration.compareAndUpdateFolderConfiguration(folder, model);
        }
        else {
            change = configuration.compareAndUpdateMemoryConfiguration(model);
        }
        if (!change || change.keys.length == 0)
            return;
        if (target !== types_1.ConfigurationTarget.WorkspaceFolder) {
            this._initialConfiguration = this.getConfiguration(undefined, null);
        }
        if (listOnly)
            return;
        let ev = new event_1.ConfigurationChangeEvent(change, previous, configuration);
        ev.source = target;
        this._onChange.fire(ev);
    }
    getDefaultResource() {
        var _a;
        let root = (_a = this._proxy) === null || _a === void 0 ? void 0 : _a.root;
        if (!root)
            return undefined;
        return vscode_uri_1.URI.file(root).toString();
    }
    /**
     * Get workspace configuration
     */
    getConfiguration(section, scope) {
        let configuration = this._configuration;
        let overrides = scope ? (0, util_2.scopeToOverrides)(scope) : { resource: scope === null ? undefined : this.getDefaultResource() };
        const config = Object.freeze((0, util_2.lookUp)(configuration.getValue(undefined, overrides), section));
        const result = {
            has(key) {
                return typeof (0, util_2.lookUp)(config, key) !== 'undefined';
            },
            get: (key, defaultValue) => {
                let result = (0, util_2.lookUp)(config, key);
                if (result == null)
                    return defaultValue;
                return result;
            },
            update: (key, value, updateTarget = false) => {
                var _a, _b;
                const resource = overrides.resource;
                let entry = section ? `${section}.${key}` : key;
                let target;
                if (typeof updateTarget === 'boolean') {
                    target = updateTarget ? types_1.ConfigurationTarget.User : types_1.ConfigurationTarget.WorkspaceFolder;
                }
                else {
                    target = (0, util_2.convertTarget)(updateTarget);
                }
                // let folderConfigFile: string | undefined
                let folder;
                if (target === types_1.ConfigurationTarget.WorkspaceFolder) {
                    folder = (_a = this._configuration.resolveFolder(resource)) !== null && _a !== void 0 ? _a : this.resolveWorkspaceFolderForResource(resource);
                    if (!folder) {
                        console.error(`Unable to locate workspace folder configuration for ${resource}`);
                        logger.error(`Unable to locate workspace folder configuration`, resource, Error().stack);
                        return;
                    }
                }
                let model = this._configuration.getConfigurationModel(target, folder).clone();
                if (value === undefined) {
                    model.removeValue(entry);
                }
                else {
                    model.setValue(entry, value);
                }
                this.changeConfiguration(target, model, folder);
                let fsPath;
                if (target === types_1.ConfigurationTarget.WorkspaceFolder) {
                    fsPath = this.folderToConfigfile(folder);
                }
                else if (target === types_1.ConfigurationTarget.User) {
                    fsPath = this.userConfigFile;
                }
                return fsPath ? (_b = this._proxy) === null || _b === void 0 ? void 0 : _b.modifyConfiguration(fsPath, entry, value) : Promise.resolve();
            },
            inspect: (key) => {
                key = section ? `${section}.${key}` : key;
                const config = this._configuration.inspect(key, overrides);
                return {
                    key,
                    defaultValue: config.defaultValue,
                    globalValue: config.userValue,
                    workspaceValue: config.workspaceValue,
                    workspaceFolderValue: config.workspaceFolderValue
                };
            }
        };
        Object.defineProperty(result, 'has', {
            enumerable: false
        });
        Object.defineProperty(result, 'get', {
            enumerable: false
        });
        Object.defineProperty(result, 'update', {
            enumerable: false
        });
        Object.defineProperty(result, 'inspect', {
            enumerable: false
        });
        if (typeof config === 'object') {
            (0, object_1.mixin)(result, config, false);
        }
        return (0, object_1.deepFreeze)(result);
    }
    /**
     * Resolve folder configuration from uri.
     */
    locateFolderConfigution(uri) {
        let folder = this._configuration.resolveFolder(uri);
        if (folder)
            return true;
        let u = vscode_uri_1.URI.parse(uri);
        if (u.scheme !== 'file')
            return false;
        let dir = folder = (0, fs_1.findUp)('.vim', u.fsPath);
        if (!dir)
            return false;
        folder = node_1.path.dirname(dir);
        let filepath = this.folderToConfigfile(folder);
        if (filepath) {
            this.addFolderFile(filepath, false, uri);
            return true;
        }
        return false;
    }
    /**
     * Resolve workspace folder config file path.
     */
    resolveWorkspaceFolderForResource(resource) {
        if (this._proxy && typeof this._proxy.getWorkspaceFolder === 'function') {
            // fallback to check workspace folder.
            let uri = this._proxy.getWorkspaceFolder(resource);
            if (!uri)
                return undefined;
            let fsPath = uri.fsPath;
            let configFilePath = this.folderToConfigfile(fsPath);
            if (configFilePath) {
                if (!node_1.fs.existsSync(configFilePath)) {
                    node_1.fs.mkdirSync(node_1.path.dirname(configFilePath), { recursive: true });
                    node_1.fs.writeFileSync(configFilePath, '{}', 'utf8');
                }
                this.addFolderFile(configFilePath, false, resource);
                return fsPath;
            }
        }
        return undefined;
    }
    /**
     * Reset configurations for test
     */
    reset() {
        this._errors.clear();
        let model = new model_1.ConfigurationModel();
        this.changeConfiguration(types_1.ConfigurationTarget.Memory, model, undefined);
    }
    dispose() {
        this._onError.dispose();
        this._onChange.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Configurations;
//# sourceMappingURL=index.js.map