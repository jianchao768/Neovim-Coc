"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../../events"));
const dialog_1 = require("../../model/dialog");
const progress_1 = tslib_1.__importDefault(require("../../model/progress"));
const notification_1 = tslib_1.__importDefault(require("../../model/notification"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
});
describe('Dialog module', () => {
    it('should show dialog', async () => {
        let dialog = new dialog_1.Dialog(nvim, { content: '你好' });
        expect(await dialog.winid).toBeNull();
        await dialog.show({});
        let winid = await dialog.winid;
        let win = nvim.createWindow(winid);
        let width = await win.width;
        expect(width).toBe(4);
        await nvim.call('coc#float#close', [winid]);
    });
    it('should invoke callback with index -1', async () => {
        let callback = jest.fn();
        let dialog = new dialog_1.Dialog(nvim, { content: '你好', callback, highlights: [] });
        await dialog.show({});
        let winid = await dialog.winid;
        await nvim.call('coc#float#close', [winid]);
        await helper_1.default.wait(50);
        expect(callback).toHaveBeenCalledWith(-1);
    });
    it('should invoke callback on click', async () => {
        let callback = jest.fn();
        let buttons = [{
                index: 0,
                text: 'yes'
            }, {
                index: 1,
                text: 'no'
            }];
        let dialog = new dialog_1.Dialog(nvim, { content: '你好', buttons, callback });
        await dialog.show({});
        let winid = await dialog.winid;
        let btnwin = await nvim.call('coc#float#get_related', [winid, 'buttons']);
        await nvim.call('win_gotoid', [btnwin]);
        await nvim.call('cursor', [2, 1]);
        await nvim.call('coc#float#nvim_float_click', []);
        await helper_1.default.wait(20);
        expect(callback).toHaveBeenCalledWith(0);
    });
});
describe('Notification', () => {
    it('should invoke callback', async () => {
        let n = new notification_1.default(nvim, { content: 'foo\nbar' });
        await n.show({});
        await events_1.default.fire('FloatBtnClick', [n.bufnr, 1]);
        n.dispose();
        let called = false;
        n = new notification_1.default(nvim, {
            content: 'foo\nbar',
            buttons: [{ index: 1, text: 'text' }],
            callback: () => {
                called = true;
            }
        });
        await events_1.default.fire('FloatBtnClick', [n.bufnr, 0]);
        expect(called).toBe(true);
    });
});
describe('ProgressNotification', () => {
    it('should cancel on cancel click', async () => {
        let n = new progress_1.default(nvim, {
            cancellable: true,
            task: (_progress, token) => {
                return new Promise(resolve => {
                    token.onCancellationRequested(() => {
                        resolve(undefined);
                    });
                });
            }
        });
        await n.show({});
        let p = new Promise(resolve => {
            n.onDidFinish(e => {
                resolve(e);
            });
        });
        await events_1.default.fire('FloatBtnClick', [n.bufnr, 0]);
        await events_1.default.fire('FloatBtnClick', [n.bufnr, -1]);
        let res = await p;
        expect(res).toBeUndefined();
    });
    it('should not fire event when disposed', async () => {
        let fn = async (success) => {
            let n = new progress_1.default(nvim, {
                cancellable: true,
                task: () => {
                    return new Promise((resolve, reject) => {
                        if (success) {
                            setTimeout(resolve, 20);
                        }
                        else {
                            setTimeout(() => {
                                reject(new Error('timeout'));
                            }, 20);
                        }
                    });
                }
            });
            let times = 0;
            n.onDidFinish(() => {
                times++;
            });
            await n.show({});
            n.dispose();
            await helper_1.default.wait(20);
            expect(times).toBe(0);
        };
        await fn(true);
        await fn(false);
    });
});
//# sourceMappingURL=dialog.test.js.map