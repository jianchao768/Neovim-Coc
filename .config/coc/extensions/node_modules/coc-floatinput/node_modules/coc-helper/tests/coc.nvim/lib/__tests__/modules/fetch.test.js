"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPort = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const net_1 = tslib_1.__importDefault(require("net"));
const url_1 = require("url");
const uuid_1 = require("uuid");
const util_1 = require("util");
const http_1 = tslib_1.__importDefault(require("http"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const download_1 = tslib_1.__importStar(require("../../model/download"));
const fetch_1 = tslib_1.__importStar(require("../../model/fetch"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
process.env.NO_PROXY = '*';
let port;
beforeAll(async () => {
    await helper_1.default.setup();
    port = await createServer();
});
afterAll(async () => {
    await helper_1.default.shutdown();
    for (let server of servers) {
        server.close();
    }
    servers = [];
});
afterEach(() => {
    helper_1.default.workspace.configurations.reset();
});
let httpPort = 7000;
function getPort() {
    let port = httpPort;
    let fn = cb => {
        let server = net_1.default.createServer();
        server.listen(port, () => {
            server.once('close', () => {
                httpPort = port + 1;
                cb(port);
            });
            server.close();
        });
        server.on('error', () => {
            port += 1;
            fn(cb);
        });
    };
    return new Promise(resolve => {
        fn(resolve);
    });
}
exports.getPort = getPort;
let servers = [];
async function createServer() {
    let port = await getPort();
    return await new Promise(resolve => {
        const server = http_1.default.createServer((req, res) => {
            if (req.url === '/bad_json') {
                res.writeHead(200, { 'Content-Type': 'application/json;charset=utf8' });
                res.end('{"x"');
            }
            if (req.url === '/slow') {
                setTimeout(() => {
                    res.writeHead(200);
                    res.end('abc');
                }, 50);
            }
            if (req.url === '/json') {
                res.writeHead(200, { 'Content-Type': 'application/json;charset=utf8' });
                res.end(JSON.stringify({ result: 'succeed' }));
            }
            if (req.url === '/text') {
                res.writeHead(200, { 'Content-Type': 'text/plain' });
                res.end('text');
            }
            if (req.url === '/404') {
                res.writeHead(404, { 'Content-Type': 'text/plain' });
                res.end('not found');
            }
            if (req.url === '/reject') {
                setTimeout(() => {
                    res.socket.destroy(new Error('Rejected'));
                }, 20);
            }
            if (req.url === '/close') {
                res.writeHead(200, { 'Content-Type': 'text/plain' });
                res.write("foo");
                setTimeout(() => {
                    res.destroy(new Error('closed'));
                }, 20);
            }
            if (req.url === '/binary') {
                let file = path_1.default.join(os_1.default.tmpdir(), 'binary_file');
                if (!fs_1.default.existsSync(file)) {
                    res.writeHead(404);
                    res.end();
                    return;
                }
                let stat = fs_1.default.statSync(file);
                res.setHeader('Content-Length', stat.size);
                res.setHeader('Etag', '"4c6426ac7ef186464ecbb0d81cbfcb1e"');
                res.writeHead(200);
                let stream = fs_1.default.createReadStream(file, { highWaterMark: 10 * 1024 });
                stream.pipe(res);
            }
            if (req.url.startsWith('/zip')) {
                let zipfile = path_1.default.resolve(__dirname, '../test.zip');
                if (req.url.indexOf('nolength=1') == -1) {
                    let stat = fs_1.default.statSync(zipfile);
                    res.setHeader('Content-Length', stat.size);
                    res.setHeader('Content-Disposition', 'attachment');
                }
                res.setHeader('Content-Type', 'application/zip');
                res.writeHead(200);
                let stream = fs_1.default.createReadStream(zipfile, { highWaterMark: 1 * 1024 });
                stream.pipe(res);
            }
            if (req.url === '/tgz') {
                res.setHeader('Content-Disposition', 'attachment; filename="file.tgz"');
                res.setHeader('Content-Type', 'application/octet-stream');
                let tarfile = path_1.default.resolve(__dirname, '../test.tar.gz');
                let stat = fs_1.default.statSync(tarfile);
                res.setHeader('Content-Length', stat.size);
                res.writeHead(200);
                let stream = fs_1.default.createReadStream(tarfile);
                stream.pipe(res);
            }
        });
        servers.push(server);
        server.unref();
        server.listen(port, () => {
            resolve(port);
        });
    });
}
describe('utils', () => {
    it('should getText', () => {
        expect((0, fetch_1.getText)({ x: 1 })).toBe('{"x":1}');
    });
    it('should getExtname', () => {
        let res = (0, download_1.getExtname)('attachment; x="y"');
        expect(res).toBeUndefined();
    });
    it('should getPort', async () => {
        expect((0, fetch_1.toPort)(80, 'http')).toBe(80);
        expect((0, fetch_1.toPort)('80', 'http')).toBe(80);
        expect((0, fetch_1.toPort)('x', 'http')).toBe(80);
        expect((0, fetch_1.toPort)('', 'https')).toBe(443);
    });
    it('should getEtag', () => {
        expect((0, download_1.getEtag)({})).toBeUndefined();
        expect((0, download_1.getEtag)({ etag: '"abc"' })).toBe('abc');
        expect((0, download_1.getEtag)({ etag: 'W/"abc"' })).toBe('abc');
        expect((0, download_1.getEtag)({ etag: 'Wabc"' })).toBeUndefined();
    });
    it('should get data type', () => {
        expect((0, fetch_1.getDataType)(null)).toBe('null');
        expect((0, fetch_1.getDataType)(undefined)).toBe('undefined');
        expect((0, fetch_1.getDataType)('s')).toBe('string');
        let b = Buffer.from('abc', 'utf8');
        expect((0, fetch_1.getDataType)(b)).toBe('buffer');
        expect((0, fetch_1.getDataType)({})).toBe('object');
        expect((0, fetch_1.getDataType)(new Date())).toBe('unknown');
    });
    it('should getRequestModule', () => {
        let url = (0, fetch_1.toURL)('https://www.baidu.com');
        expect((0, fetch_1.getRequestModule)(url)).toBeDefined();
    });
    it('should convert to URL', () => {
        expect(() => { (0, fetch_1.toURL)(''); }).toThrow();
        expect(() => { (0, fetch_1.toURL)('file:///1'); }).toThrow();
        expect(() => { (0, fetch_1.toURL)(undefined); }).toThrow();
        expect((0, fetch_1.toURL)('https://www.baidu.com').toString()).toBe('https://www.baidu.com/');
        let u = new url_1.URL('http://www.baidu.com');
        expect((0, fetch_1.toURL)(u)).toBe(u);
    });
    it('should report valid proxy', () => {
        let agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'domain.com:1234' });
        expect(agent).toBe(null);
        agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'ftp://domain.com:1234' });
        expect(agent).toBe(null);
        agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: '' });
        expect(agent).toBe(null);
        agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'domain.com' });
        expect(agent).toBe(null);
        agent = (0, fetch_1.getAgent)(new url_1.URL('https://google.com'), { proxy: 'https://domain.com' });
        let proxy = agent.proxy;
        expect(proxy.port).toBe(443);
        agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'http://domain.com', proxyStrictSSL: true });
        proxy = agent.proxy;
        expect(proxy.port).toBe(80);
        agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'https://domain.com:1234' });
        proxy = agent.proxy;
        expect(proxy.host).toBe('domain.com');
        expect(proxy.port).toBe(1234);
        agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'http://user:pass@domain.com:1234' });
        proxy = agent.proxy;
        expect(proxy.host).toBe('domain.com');
        expect(proxy.port).toBe(1234);
        expect(proxy.auth).toBe('user:pass');
    });
    it('should getAgent from proxy', () => {
        let agent = (0, fetch_1.getAgent)(new url_1.URL('http://google.com'), { proxy: 'http://user:@domain.com' });
        let proxy = agent.proxy;
        expect(proxy.host).toBe('domain.com');
        expect(proxy.auth).toBe('user:');
        expect(proxy.port).toBe(80);
    });
    it('should getSystemProxyURI', () => {
        let url = new url_1.URL('http://www.example.com');
        let http_proxy = 'http://127.0.0.1:7070';
        expect((0, fetch_1.getSystemProxyURI)(url, { NO_PROXY: '*', HTTP_PROXY: http_proxy })).toBeNull();
        expect((0, fetch_1.getSystemProxyURI)(url, { no_proxy: '*', HTTP_PROXY: http_proxy })).toBeNull();
        expect((0, fetch_1.getSystemProxyURI)(new url_1.URL('http://www.example.com:80'), {
            NO_PROXY: 'xyz:33,example.com:80',
            HTTP_PROXY: http_proxy
        })).toBeNull();
        expect((0, fetch_1.getSystemProxyURI)(url, {
            NO_PROXY: 'baidu.com,example.com',
            HTTP_PROXY: http_proxy
        })).toBeNull();
        expect((0, fetch_1.getSystemProxyURI)(url, { HTTP_PROXY: http_proxy })).toBe(http_proxy);
        expect((0, fetch_1.getSystemProxyURI)(url, { http_proxy })).toBe(http_proxy);
        expect((0, fetch_1.getSystemProxyURI)(url, {})).toBe(null);
        url = new url_1.URL('https://www.example.com');
        let https_proxy = 'https://127.0.0.1:7070';
        expect((0, fetch_1.getSystemProxyURI)(url, { HTTPS_PROXY: https_proxy })).toBe(https_proxy);
        expect((0, fetch_1.getSystemProxyURI)(url, { https_proxy })).toBe(https_proxy);
        expect((0, fetch_1.getSystemProxyURI)(url, { HTTP_PROXY: http_proxy })).toBe(http_proxy);
        expect((0, fetch_1.getSystemProxyURI)(url, { http_proxy })).toBe(http_proxy);
        expect((0, fetch_1.getSystemProxyURI)(url, {})).toBe(null);
    });
    it('should resolve request options #1', async () => {
        let file = path_1.default.join(os_1.default.tmpdir(), `${(0, uuid_1.v4)()}/ca`);
        fs_1.default.mkdirSync(path_1.default.dirname(file));
        fs_1.default.writeFileSync(file, 'ca', 'utf8');
        helper_1.default.updateConfiguration('http.proxyAuthorization', 'authorization');
        helper_1.default.updateConfiguration('http.proxyCA', file);
        let url = new url_1.URL('http://www.example.com:7070');
        let res = (0, fetch_1.resolveRequestOptions)(url, {
            query: { x: 1 },
            method: 'POST',
            headers: {
                'Custom-X': '1'
            },
            user: 'user',
            password: 'password',
            timeout: 1000,
            data: { foo: '1' },
            buffer: true,
        });
        expect(res.path).toBe('/?x=1');
        expect(Buffer.isBuffer(res.ca)).toBe(true);
    });
    it('should resolve request options #2', async () => {
        let url = new url_1.URL('https://abc:123@www.example.com');
        let res = (0, fetch_1.resolveRequestOptions)(url, {
            user: 'user',
            data: 'data'
        });
        expect(res.port).toBe(443);
        expect(res.path).toBe('/');
        expect(res.auth).toBe('abc:123');
    });
});
describe('fetch', () => {
    it('should fetch json', async () => {
        let res = await (0, fetch_1.default)(`http://127.0.0.1:${port}/json`, {
            method: 'POST',
            data: 'data'
        });
        expect(res).toEqual({ result: 'succeed' });
        res = await (0, fetch_1.default)(`http://127.0.0.1:${port}/json`, { buffer: true });
        expect(Buffer.isBuffer(res)).toBe(true);
        let fn = async () => {
            await (0, fetch_1.default)(`http://127.0.0.1:${port}/bad_json`);
        };
        await expect(fn()).rejects.toThrow(Error);
    });
    it('should catch error on reject or abnormal response', async () => {
        let fn = async () => {
            await (0, fetch_1.default)(`http://127.0.0.1:${port}/reject`);
        };
        await expect(fn()).rejects.toThrow();
    });
    it('should catch abnormal close', async () => {
        let version = semver_1.default.parse(process.version);
        if (version.major >= 16) {
            let fn = async () => {
                await (0, fetch_1.default)(`http://127.0.0.1:${port}/close`);
            };
            await expect(fn()).rejects.toThrow();
            fn = async () => {
                await (0, download_1.default)(`http://127.0.0.1:${port}/close`, { dest: os_1.default.tmpdir() });
            };
            await expect(fn()).rejects.toThrow();
        }
    });
    it('should throw on 404 response', async () => {
        let fn = async () => {
            await (0, fetch_1.default)(`http://127.0.0.1:${port}/404`);
        };
        await expect(fn()).rejects.toThrow(Error);
    });
    it('should catch proxy error', async () => {
        delete process.env.NO_PROXY;
        process.env.HTTP_PROXY = `http://127.0.0.1`;
        let fn = async () => {
            await (0, fetch_1.default)(`http://127.0.0.1:${port}/json`);
        };
        await expect(fn()).rejects.toThrow();
        delete process.env.HTTP_PROXY;
    });
    it('should fetch text', async () => {
        let res = await (0, fetch_1.default)(`http://127.0.0.1:${port}/text`);
        expect(res).toBe('text');
        let fn = async () => {
            let port = await getPort();
            res = await (0, fetch_1.default)(`http://127.0.0.1:${port}/not_exists`, { timeout: 2000 });
        };
        await expect(fn()).rejects.toThrow();
    });
    it('should throw on timeout', async () => {
        let fn = async () => {
            await (0, fetch_1.default)(`http://127.0.0.1:${port}/slow`, { timeout: 50 });
        };
        await expect(fn()).rejects.toThrow(Error);
        let url = new url_1.URL(`http://127.0.0.1:${port}/slow`);
        let opts = {
            method: 'GET',
            hostname: '127.0.0.1',
            port,
            path: '/slow',
            rejectUnauthorized: true,
            maxRedirects: 3,
            headers: {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)',
                'Accept-Encoding': 'gzip, deflate'
            },
            timeout: 50,
            agent: new http_1.default.Agent({ keepAlive: true })
        };
        fn = async () => {
            await (0, fetch_1.request)(url, undefined, opts);
        };
        await expect(fn()).rejects.toThrow(Error);
        fn = async () => {
            await (0, download_1.default)(url, Object.assign(opts, { dest: os_1.default.tmpdir() }));
        };
        await expect(fn()).rejects.toThrow(Error);
        opts.agent.destroy();
    });
    it('should cancel by CancellationToken', async () => {
        let fn = async () => {
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let p = (0, fetch_1.default)(`http://127.0.0.1:${port}/slow`, { timeout: 50 }, tokenSource.token);
            await helper_1.default.wait(1);
            tokenSource.cancel();
            await p;
        };
        await expect(fn()).rejects.toThrow(Error);
    });
});
describe('download', () => {
    let binary_file;
    let tempdir = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
    beforeAll(async () => {
        binary_file = path_1.default.join(os_1.default.tmpdir(), 'binary_file');
        if (!fs_1.default.existsSync(binary_file)) {
            let data = Buffer.alloc(100 * 1024, 0);
            await (0, util_1.promisify)(fs_1.default.writeFile)(binary_file, data);
        }
        // create binary files
    });
    it('should throw for bad option', async () => {
        let url = 'https://127.0.0.1';
        let fn = async () => {
            await (0, download_1.default)(url, { dest: 'a/b' });
        };
        await expect(fn()).rejects.toThrow(Error);
        fn = async () => {
            await (0, download_1.default)(url, { dest: __filename });
        };
        await expect(fn()).rejects.toThrow(/not directory/);
    });
    it('should throw when unable to extract', async () => {
        let url = `http://127.0.0.1:${port}/text`;
        let fn = async () => {
            await (0, download_1.default)(url, { dest: tempdir, extract: true });
        };
        await expect(fn()).rejects.toThrow(/extract method/);
    });
    it('should throw for bad response', async () => {
        let fn = async () => {
            await (0, download_1.default)(`http://127.0.0.1:${port}/404`, { dest: tempdir });
        };
        await expect(fn()).rejects.toThrow(Error);
        fn = async () => {
            await (0, download_1.default)(`http://127.0.0.1:${port}/reject`, { dest: tempdir });
        };
        await expect(fn()).rejects.toThrow();
        fn = async () => {
            let port = await getPort();
            await (0, download_1.default)(`http://127.0.0.1:${port}/not_exists`, { dest: tempdir, timeout: 2000 });
        };
        await expect(fn()).rejects.toThrow();
    });
    it('should throw on timeout', async () => {
        let fn = async () => {
            await (0, download_1.default)(`http://127.0.0.1:${port}/slow`, { dest: tempdir, timeout: 50 });
        };
        await expect(fn()).rejects.toThrow();
    });
    it('should download binary file', async () => {
        let url = `http://127.0.0.1:${port}/binary`;
        let called = false;
        let res = await (0, download_1.default)(url, {
            etagAlgorithm: 'md5',
            dest: tempdir, onProgress: p => {
                expect(typeof p).toBe('string');
                called = true;
            }
        });
        expect(called).toBe(true);
        let exists = fs_1.default.existsSync(res);
        expect(exists).toBe(true);
    });
    it('should throw when etag check failed', async () => {
        let url = `http://127.0.0.1:${port}/binary`;
        let called = false;
        let fn = async () => {
            await (0, download_1.default)(url, {
                etagAlgorithm: 'sha256',
                dest: tempdir, onProgress: p => {
                    expect(typeof p).toBe('string');
                    called = true;
                }
            });
        };
        await expect(fn()).rejects.toThrow(/Etag check failed/);
    });
    it('should download zip file', async () => {
        let url = `http://127.0.0.1:${port}/zip`;
        let res = await (0, download_1.default)(url, {
            dest: tempdir,
            extract: true
        });
        let file = path_1.default.join(tempdir, 'log.txt');
        let exists = fs_1.default.existsSync(file);
        expect(exists).toBe(true);
        res = await (0, download_1.default)(url + '?nolength=1', {
            dest: tempdir,
            extract: true
        });
        exists = fs_1.default.existsSync(file);
        expect(exists).toBe(true);
    });
    it('should download tgz', async () => {
        let url = `http://127.0.0.1:${port}/tgz`;
        let opts = {
            dest: tempdir,
            extract: true,
            timeout: 3000,
            strip: 0
        };
        let res = await (0, download_1.default)(url, opts);
        let file = path_1.default.join(res, 'test.js');
        let exists = fs_1.default.existsSync(file);
        expect(exists).toBe(true);
        opts.strip = undefined;
        res = await (0, download_1.default)(url, opts);
        expect(res).toBeDefined();
    });
    it('should cancel download by CancellationToken', async () => {
        let fn = async () => {
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let p = (0, download_1.default)(`http://127.0.0.1:${port}/slow`, { dest: tempdir }, tokenSource.token);
            await helper_1.default.wait(10);
            tokenSource.cancel();
            await p;
        };
        await expect(fn()).rejects.toThrow(Error);
    });
    it('should throw on agent error', async () => {
        delete process.env.NO_PROXY;
        process.env.HTTP_PROXY = `http://127.0.0.1`;
        let fn = async () => {
            await (0, download_1.default)(`http://127.0.0.1:${port}/json`, { dest: tempdir });
        };
        await expect(fn()).rejects.toThrow(/using proxy/);
        delete process.env.HTTP_PROXY;
        process.env.NO_PROXY = '*';
        fn = async () => {
            let agent = new http_1.default.Agent({ keepAlive: true });
            let p = (0, download_1.default)(`http://127.0.0.1:${port}/slow`, { dest: tempdir, timeout: 50, agent });
            await p;
            agent.destroy();
        };
        await expect(fn()).rejects.toThrow(/timeout/);
    });
});
//# sourceMappingURL=fetch.test.js.map