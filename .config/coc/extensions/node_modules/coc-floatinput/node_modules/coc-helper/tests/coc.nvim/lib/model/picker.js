'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPickerItems = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const popup_1 = tslib_1.__importDefault(require("./popup"));
function toPickerItems(items) {
    return items.map(item => typeof item === 'string' ? { label: item } : item);
}
exports.toPickerItems = toPickerItems;
/**
 * Pick multiple items from dialog
 */
class Picker {
    constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.picked = new Set();
        this.disposables = [];
        this.keyMappings = new Map();
        this._onDidClose = new protocol_1.Emitter();
        this.onDidClose = this._onDidClose.event;
        for (let i = 0; i < config.items.length; i++) {
            let item = config.items[i];
            if (item.picked)
                this.picked.add(i);
        }
        this.total = config.items.length;
        if (token) {
            token.onCancellationRequested(() => {
                var _a;
                (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();
            });
        }
        this.disposables.push(this._onDidClose);
    }
    get currIndex() {
        return this.win ? this.win.currIndex : 0;
    }
    attachEvents() {
        events_1.default.on('InputChar', this.onInputChar.bind(this), null, this.disposables);
        events_1.default.on('BufWinLeave', bufnr => {
            if (bufnr == this.bufnr) {
                this._onDidClose.fire(undefined);
                this.bufnr = undefined;
                this.win = undefined;
                this.dispose();
            }
        }, null, this.disposables);
        events_1.default.on('FloatBtnClick', (bufnr, idx) => {
            if (bufnr != this.bufnr)
                return;
            if (idx == 0) {
                let selected = Array.from(this.picked);
                this._onDidClose.fire(selected.length > 0 ? selected : undefined);
            }
            else {
                this._onDidClose.fire(undefined);
            }
            this.dispose();
        }, null, this.disposables);
        this.addKeymappings();
    }
    addKeymappings() {
        let { nvim } = this;
        const toggleSelect = idx => {
            if (this.picked.has(idx)) {
                this.picked.delete(idx);
            }
            else {
                this.picked.add(idx);
            }
        };
        this.addKeys('<LeftRelease>', async () => {
            // not work on vim
            // if (isVim) return
            let [winid, lnum, col] = await nvim.call('coc#ui#get_mouse');
            nvim.pauseNotification();
            if (winid == this.win.winid) {
                if (col <= 3) {
                    toggleSelect(lnum - 1);
                    this.changeLine(lnum - 1);
                }
                else {
                    this.win.setCursor(lnum - 1);
                }
            }
            nvim.call('win_gotoid', [winid], true);
            nvim.call('cursor', [lnum, col], true);
            nvim.call('coc#float#nvim_float_click', [], true);
            nvim.command('redraw', true);
            await nvim.resumeNotification();
        });
        this.addKeys(['<esc>', '<C-c>'], () => {
            this._onDidClose.fire(undefined);
            this.dispose();
        });
        this.addKeys('<cr>', () => {
            if (this.picked.size == 0) {
                this._onDidClose.fire(undefined);
            }
            else {
                let selected = Array.from(this.picked);
                this._onDidClose.fire(selected);
            }
            this.dispose();
        });
        this.addKeys(['j', '<down>', '<tab>', '<C-n>'], () => {
            this.win.setCursor(this.currIndex + 1, true);
        });
        this.addKeys(['k', '<up>', '<s-tab>', '<C-p>'], () => {
            this.win.setCursor(this.currIndex - 1, true);
        });
        this.addKeys(['g'], () => {
            this.win.setCursor(0, true);
        });
        this.addKeys(['G'], () => {
            this.win.setCursor(this.total - 1, true);
        });
        this.addKeys(' ', async () => {
            let idx = this.currIndex;
            toggleSelect(idx);
            nvim.pauseNotification();
            this.changeLine(idx);
            this.win.setCursor(this.currIndex + 1);
            nvim.command('redraw', true);
            await nvim.resumeNotification();
        });
        this.addKeys('<C-f>', async () => {
            await this.win.scrollForward();
        });
        this.addKeys('<C-b>', async () => {
            await this.win.scrollBackward();
        });
    }
    async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = { close: 1, cursorline: 1 };
        if (preferences.maxHeight)
            opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
            opts.maxWidth = preferences.maxWidth;
        if (title)
            opts.title = title;
        if (preferences.floatHighlight)
            opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
            opts.borderhighlight = [preferences.floatBorderHighlight];
        if (preferences.pickerButtons) {
            let shortcut = preferences.pickerButtonShortcut;
            opts.buttons = ['Submit' + (shortcut ? ' <cr>' : ''), 'Cancel' + (shortcut ? ' <esc>' : '')];
        }
        if (preferences.rounded)
            opts.rounded = 1;
        if (preferences.confirmKey && preferences.confirmKey != '<cr>') {
            this.addKeys(preferences.confirmKey, () => {
                this._onDidClose.fire(undefined);
                this.dispose();
            });
        }
        let lines = [];
        let highlights = [];
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            let line = `[${item.picked ? 'x' : ' '}] ${item.label}`;
            if (item.description) {
                let start = (0, string_1.byteLength)(line);
                line = line + ` ${item.description}`;
                highlights.push({ hlGroup: 'Comment', lnum: i, colStart: start, colEnd: (0, string_1.byteLength)(line) });
            }
            lines.push(line);
        }
        if (highlights.length)
            opts.highlights = highlights;
        let res = await nvim.call('coc#dialog#create_dialog', [lines, opts]);
        this.win = new popup_1.default(nvim, res[0], res[1], lines.length);
        this.bufnr = res[1];
        nvim.call('coc#prompt#start_prompt', ['picker'], true);
        this.attachEvents();
        this.win.setCursor(0, true);
        return res[0];
    }
    get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : undefined;
    }
    dispose() {
        var _a;
        this.picked.clear();
        this.keyMappings.clear();
        (0, util_1.disposeAll)(this.disposables);
        this.nvim.call('coc#prompt#stop_prompt', ['picker'], true);
        (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();
        this.win = undefined;
    }
    async onInputChar(session, character) {
        if (session != 'picker' || !this.win)
            return;
        let fn = this.keyMappings.get(character);
        if (fn)
            await Promise.resolve(fn(character));
    }
    changeLine(index) {
        let { nvim } = this;
        let item = this.config.items[index];
        if (!item)
            return;
        let line = `[${this.picked.has(index) ? 'x' : ' '}] ${item.label}`;
        let col = (0, string_1.byteLength)(line);
        if (item.description)
            line = line + ` ${item.description}`;
        nvim.call('setbufline', [this.bufnr, index + 1, line], true);
        let buf = nvim.createBuffer(this.bufnr);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        buf.addHighlight({ hlGroup: 'Comment', line: index, srcId: 1, colStart: col, colEnd: -1 });
    }
    addKeys(keys, fn) {
        if (Array.isArray(keys)) {
            for (let key of keys) {
                this.keyMappings.set(key, fn);
            }
        }
        else {
            this.keyMappings.set(keys, fn);
        }
    }
}
exports.default = Picker;
//# sourceMappingURL=picker.js.map