'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_1 = require("../..//util/node");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const protocol_1 = require("../../util/protocol");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const buffer_1 = tslib_1.__importDefault(require("./buffer"));
const debounceTime = (0, util_1.getConditionValue)(200, 0);
/**
 * Show codeLens of document
 */
class CodeLensManager {
    constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('codeLens')) {
                for (let item of this.buffers.items) {
                    item.loadConfiguration();
                }
            }
        }, this, this.disposables);
        this.buffers = workspace_1.default.registerBufferSync(doc => {
            if (doc.buftype != '')
                return undefined;
            return new buffer_1.default(nvim, doc);
        });
        this.disposables.push(this.buffers);
        events_1.default.on('CursorHold', async (bufnr) => {
            let item = this.buffers.getItem(bufnr);
            if (item && item.config.enabled && !item.currentCodeLens)
                await item.forceFetch();
        }, null, this.disposables);
        events_1.default.on('CursorMoved', bufnr => {
            let buf = this.buffers.getItem(bufnr);
            if (buf)
                buf.resolveCodeLens();
        }, null, this.disposables);
        let debounced = (0, node_1.debounce)(async (selector) => {
            for (let item of this.buffers.items) {
                if (!workspace_1.default.match(selector, item.document))
                    continue;
                item.abandonResult();
                await item.forceFetch();
            }
        }, debounceTime);
        this.disposables.push(protocol_1.Disposable.create(() => {
            debounced.clear();
        }));
        languages_1.default.onDidCodeLensRefresh(debounced, null, this.disposables);
        commands_1.default.register({
            id: 'document.toggleCodeLens',
            execute: () => {
                return this.toggle(workspace_1.default.bufnr);
            },
        }, false, 'toggle codeLens display of current buffer');
    }
    async toggle(bufnr) {
        let item = this.buffers.getItem(bufnr);
        try {
            workspace_1.default.getAttachedDocument(bufnr);
            await item.toggleDisplay();
        }
        catch (e) {
            void window_1.default.showErrorMessage(e.message);
        }
    }
    /**
     * Check provider for buf that not fetched
     */
    async checkProvider() {
        for (let buf of this.buffers.items) {
            await buf.forceFetch();
        }
    }
    async doAction() {
        let [bufnr, line] = await this.nvim.eval(`[bufnr("%"),line(".")-1]`);
        let buf = this.buffers.getItem(bufnr);
        if (buf)
            await buf.doAction(line);
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = CodeLensManager;
//# sourceMappingURL=index.js.map