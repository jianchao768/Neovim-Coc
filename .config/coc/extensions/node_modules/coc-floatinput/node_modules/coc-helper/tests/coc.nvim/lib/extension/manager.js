"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toWorkspaceContinsPatterns = exports.getActivationEvents = exports.checkFileSystem = exports.checkCommand = exports.checkLanguageId = exports.getOnCommandList = exports.getEvents = exports.ExtensionManager = exports.ActivateEvents = exports.ExtensionType = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const registry_1 = require("../configuration/registry");
const watchman_1 = tslib_1.__importDefault(require("../core/watchman"));
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const memos_1 = tslib_1.__importDefault(require("../model/memos"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const extensionRegistry_1 = require("../util/extensionRegistry");
const factory_1 = require("../util/factory");
const fs_1 = require("../util/fs");
const Is = tslib_1.__importStar(require("../util/is"));
const lodash_1 = require("../util/lodash");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const registry_2 = require("../util/registry");
const timing_1 = require("../util/timing");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const stat_1 = require("./stat");
const logger = (0, logger_1.createLogger)('extensions-manager');
var ExtensionType;
(function (ExtensionType) {
    ExtensionType[ExtensionType["Global"] = 0] = "Global";
    ExtensionType[ExtensionType["Local"] = 1] = "Local";
    ExtensionType[ExtensionType["SingleFile"] = 2] = "SingleFile";
    ExtensionType[ExtensionType["Internal"] = 3] = "Internal";
})(ExtensionType = exports.ExtensionType || (exports.ExtensionType = {}));
var ActivateEvents;
(function (ActivateEvents) {
    ActivateEvents["OnLanguage"] = "onLanguage";
    ActivateEvents["OnFileSystem"] = "onFileSystem";
    ActivateEvents["OnCommand"] = "onCommand";
    ActivateEvents["WorkspaceContains"] = "workspaceContains";
})(ActivateEvents = exports.ActivateEvents || (exports.ActivateEvents = {}));
const extensionRegistry = registry_2.Registry.as(extensionRegistry_1.Extensions.ExtensionContribution);
const memos = new memos_1.default(node_1.path.resolve(constants_1.dataHome, 'memos.json'));
memos.merge(node_1.path.resolve(constants_1.dataHome, '../memos.json'));
const configurationRegistry = registry_2.Registry.as(registry_1.Extensions.Configuration);
/**
 * Manage loaded extensions
 */
class ExtensionManager {
    constructor(states, folder) {
        this.states = states;
        this.folder = folder;
        this.activated = false;
        this.disposables = [];
        this.configurationNodes = [];
        this.extensions = new Map();
        this._onDidLoadExtension = new protocol_1.Emitter();
        this._onDidActiveExtension = new protocol_1.Emitter();
        this._onDidUnloadExtension = new protocol_1.Emitter();
        this.singleExtensionsRoot = node_1.path.join(constants_1.configHome, 'coc-extensions');
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        this.modulesFolder = node_1.path.join(this.folder, 'node_modules');
    }
    activateExtensions() {
        this.activated = true;
        if (process.env.COC_NO_PLUGINS == '1')
            return;
        configurationRegistry.registerConfigurations(this.configurationNodes);
        this.attachEvents();
        let promises = [];
        for (let key of this.extensions.keys()) {
            // wait extensions that always activated only
            const { extension } = this.extensions.get(key);
            const activationEvents = extension.packageJSON.activationEvents;
            if (!activationEvents || activationEvents.includes('*')) {
                promises.push(void extension.activate());
            }
            else {
                void this.autoActiavte(key, extension);
            }
        }
        return Promise.allSettled(promises);
    }
    async loadFileExtensions() {
        let folder = this.singleExtensionsRoot;
        let files = await (0, stat_1.getJsFiles)(folder);
        await Promise.allSettled(files.map(file => {
            return this.loadExtensionFile(node_1.path.join(folder, file));
        }));
    }
    attachEvents() {
        workspace_1.default.onDidRuntimePathChange(async (paths) => {
            let folders = paths.filter(p => p && (0, stat_1.validExtensionFolder)(p, workspace_1.default.version));
            let outputChannel = window_1.default.createOutputChannel('extensions');
            await Promise.allSettled(folders.map(folder => {
                outputChannel.appendLine(`Loading extension from runtimepath: ${folder}`);
                return this.loadExtension(folder);
            }));
        }, null, this.disposables);
        workspace_1.default.onDidOpenTextDocument(document => {
            let doc = workspace_1.default.getDocument(document.bufnr);
            this.tryActivateExtensions(ActivateEvents.OnLanguage, events => {
                return checkLanguageId(doc, events);
            });
            this.tryActivateExtensions(ActivateEvents.OnFileSystem, events => {
                return checkFileSystem(doc.uri, events);
            });
        }, null, this.disposables);
        events_1.default.on('Command', async (command) => {
            let fired = false;
            this.tryActivateExtensions(ActivateEvents.OnCommand, events => {
                let result = checkCommand(command, events);
                if (result)
                    fired = true;
                return result;
            });
            if (fired)
                await (0, util_1.wait)(50);
        }, null, this.disposables);
        workspace_1.default.onDidChangeWorkspaceFolders(e => {
            if (e.added.length > 0) {
                this.tryActivateExtensions(ActivateEvents.WorkspaceContains, events => {
                    let patterns = toWorkspaceContinsPatterns(events);
                    return workspace_1.default.checkPatterns(patterns, e.added);
                });
            }
        }, null, this.disposables);
    }
    /**
     * Unload & remove all global extensions, return removed extensions.
     */
    async cleanExtensions() {
        let { globalIds } = this.states;
        await (0, fs_1.remove)(this.modulesFolder);
        return globalIds.filter(id => !this.states.isDisabled(id));
    }
    tryActivateExtensions(event, check) {
        for (let item of this.extensions.values()) {
            if (item.extension.isActive)
                continue;
            let events = item.events;
            if (!events.includes(event))
                continue;
            let { extension } = item;
            let activationEvents = getActivationEvents(extension.packageJSON);
            void Promise.resolve(check(activationEvents)).then(checked => {
                if (checked)
                    void Promise.resolve(extension.activate());
            });
        }
    }
    async checkAutoActivate(packageJSON) {
        let activationEvents = getActivationEvents(packageJSON);
        if (activationEvents.length === 0 || activationEvents.includes('*')) {
            return true;
        }
        let patterns = [];
        for (let eventName of activationEvents) {
            let parts = eventName.split(':');
            let ev = parts[0];
            if (ev === ActivateEvents.OnLanguage) {
                if (workspace_1.default.languageIds.has(parts[1]) || workspace_1.default.filetypes.has(parts[1])) {
                    return true;
                }
            }
            else if (ev === ActivateEvents.WorkspaceContains && parts[1]) {
                patterns.push(parts[1]);
            }
            else if (ev === ActivateEvents.OnFileSystem) {
                for (let doc of workspace_1.default.documents) {
                    let u = vscode_uri_1.URI.parse(doc.uri);
                    if (u.scheme == parts[1]) {
                        return true;
                    }
                }
            }
        }
        if (patterns.length > 0) {
            let res = await workspace_1.default.checkPatterns(patterns);
            if (res)
                return true;
        }
        return false;
    }
    has(id) {
        return this.extensions.has(id);
    }
    getExtension(id) {
        return this.extensions.get(id);
    }
    get loadedExtensions() {
        return Array.from(this.extensions.keys());
    }
    get all() {
        return Array.from(this.extensions.values()).map(o => o.extension);
    }
    /**
     * Activate extension, throw error if disabled or doesn't exist.
     * Returns true if extension successfully activated.
     */
    async activate(id) {
        let item = this.extensions.get(id);
        if (!item)
            throw new Error(`Extension ${id} not registered!`);
        let { extension } = item;
        if (extension.isActive)
            return true;
        await Promise.resolve(extension.activate());
        return extension.isActive === true;
    }
    async deactivate(id) {
        let item = this.extensions.get(id);
        if (!item || !item.extension.isActive)
            return;
        await Promise.resolve(item.deactivate());
    }
    /**
     * Load extension from folder, folder should contains coc extension.
     */
    async loadExtension(folder, noActive = false) {
        if (Array.isArray(folder)) {
            let results = await Promise.allSettled(folder.map(f => {
                return this.loadExtension(f, noActive);
            }));
            results.forEach(res => {
                if (res.status === 'rejected')
                    throw new Error(`Error on loadExtension ${res.reason}`);
            });
            return true;
        }
        let errors = [];
        let obj = (0, stat_1.loadExtensionJson)(folder, workspace_1.default.version, errors);
        if (errors.length > 0)
            throw new Error(errors[0]);
        let { name } = obj;
        if (this.states.isDisabled(name))
            return false;
        // unload if loaded
        await this.unloadExtension(name);
        let isLocal = !this.states.hasExtension(name);
        if (isLocal)
            this.states.addLocalExtension(name, folder);
        await this.registerExtension(folder, Object.freeze(obj), isLocal ? ExtensionType.Local : ExtensionType.Global, noActive);
        return true;
    }
    /**
     * Deactivate & unregist extension
     */
    async unloadExtension(id) {
        let item = this.extensions.get(id);
        if (item) {
            await this.deactivate(id);
            this.extensions.delete(id);
            this._onDidUnloadExtension.fire(id);
        }
    }
    async reloadExtension(id) {
        let item = this.extensions.get(id);
        if (!item || item.type == ExtensionType.Internal) {
            throw new Error(`Extension ${id} not registered`);
        }
        if (item.type == ExtensionType.SingleFile) {
            await this.loadExtensionFile(item.filepath);
        }
        else {
            await this.loadExtension(item.directory);
        }
    }
    async call(id, method, args) {
        let item = this.extensions.get(id);
        if (!item)
            throw new Error(`extension ${id} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
            await this.activate(id);
        }
        let { exports } = extension;
        if (!exports || typeof exports[method] !== 'function') {
            throw new Error(`method ${method} not found on extension ${id}`);
        }
        return await Promise.resolve(exports[method].apply(null, args));
    }
    registContribution(id, packageJSON, directory, filepath) {
        let { contributes, activationEvents } = packageJSON;
        let { configuration, rootPatterns, commands } = contributes !== null && contributes !== void 0 ? contributes : {};
        let definitions;
        let props = (0, extensionRegistry_1.getProperties)(configuration !== null && configuration !== void 0 ? configuration : {});
        if (!(0, object_1.isEmpty)(props)) {
            // /configuration
            let properties = (0, registry_2.convertProperties)(props, 2 /* ConfigurationScope.WINDOW */);
            if (Is.objectLiteral(configuration.definitions)) {
                let prefix = id.replace(/[^\w]/g, '');
                const addPrefix = (obj, key) => {
                    if (key == '$ref') {
                        let val = obj[key];
                        if (Is.string(val) && val.startsWith('#/definitions/')) {
                            obj[key] = val.slice(0, 14) + prefix + '.' + val.slice(14);
                        }
                    }
                };
                (0, object_1.deepIterate)(properties, addPrefix);
                definitions = {};
                Object.entries((0, object_1.deepClone)(configuration.definitions)).forEach(([key, val]) => {
                    if (Is.objectLiteral(val)) {
                        definitions[prefix + '.' + key] = val;
                        (0, object_1.deepIterate)(val, addPrefix);
                    }
                });
            }
            let node = { properties, extensionInfo: { id, displayName: packageJSON.displayName } };
            this.configurationNodes.push(node);
            if (this.activated) {
                let toRemove = [];
                let idx = this.configurationNodes.findIndex(o => o.extensionInfo.id === id);
                if (idx !== -1) {
                    toRemove.push(this.configurationNodes[idx]);
                    this.configurationNodes.splice(idx, 1);
                }
                workspace_1.default.configurations.updateConfigurations([node], toRemove);
            }
        }
        extensionRegistry.registerExtension(id, {
            name: id,
            directory,
            filepath,
            commands,
            definitions,
            rootPatterns,
            onCommands: getOnCommandList(activationEvents)
        });
    }
    getExtensionState(id) {
        let disabled = this.states.isDisabled(id);
        if (disabled)
            return 'disabled';
        let item = this.getExtension(id);
        if (!item)
            return 'unknown';
        let { extension } = item;
        return extension.isActive ? 'activated' : 'loaded';
    }
    async autoActiavte(id, extension) {
        try {
            let checked = await this.checkAutoActivate(extension.packageJSON);
            if (checked)
                await Promise.resolve(extension.activate());
        }
        catch (e) {
            logger.error(`Error on activate ${id}`, e);
        }
    }
    async loadExtensionFile(filepath, noActive = false) {
        let stat = await (0, fs_1.statAsync)(filepath);
        if (!stat || !stat.isFile())
            return;
        let filename = node_1.path.basename(filepath);
        let basename = node_1.path.basename(filepath, '.js');
        let name = 'single-' + basename;
        let root = node_1.path.dirname(filepath);
        let packageJSON = { name, main: filename, engines: { coc: '>=0.0.82' } };
        let confpath = node_1.path.join(root, basename + '.json');
        let obj = (0, fs_1.loadJson)(confpath);
        for (const attr of ['activationEvents', 'contributes']) {
            packageJSON[attr] = obj[attr];
        }
        await this.unloadExtension(name);
        await this.registerExtension(root, packageJSON, ExtensionType.SingleFile, noActive);
        return name;
    }
    registerExtensions(stats) {
        for (let stat of stats) {
            try {
                let extensionType = stat.isLocal ? ExtensionType.Local : ExtensionType.Global;
                void this.registerExtension(stat.root, stat.packageJSON, extensionType);
            }
            catch (e) {
                logger.error(`Error on regist extension from ${stat.root}: `, e);
            }
        }
    }
    async registerExtension(root, packageJSON, extensionType, noActive = false) {
        let id = packageJSON.name;
        if (this.states.isDisabled(id))
            return;
        let isActive = false;
        let result;
        let filename = node_1.path.join(root, packageJSON.main || 'index.js');
        let extensionPath = extensionType === ExtensionType.SingleFile ? filename : root;
        let exports;
        let ext;
        let subscriptions = [];
        const timing = (0, timing_1.createTiming)(`activate ${id}`, 5000);
        let extension = {
            activate: () => {
                if (result)
                    return result;
                result = new Promise(async (resolve, reject) => {
                    timing.start();
                    try {
                        let isEmpty = typeof packageJSON.engines.coc === 'undefined';
                        ext = (0, factory_1.createExtension)(id, filename, isEmpty);
                        let context = {
                            subscriptions,
                            extensionPath,
                            globalState: memos.createMemento(`${id}|global`),
                            workspaceState: memos.createMemento(`${id}|${workspace_1.default.rootPath}`),
                            asAbsolutePath: relativePath => node_1.path.join(root, relativePath),
                            storagePath: node_1.path.join(this.folder, `${id}-data`),
                            logger: (0, logger_1.createLogger)(`extension:${id}`)
                        };
                        let res = await Promise.resolve(ext.activate(context));
                        isActive = true;
                        exports = res;
                        this._onDidActiveExtension.fire(extension);
                        timing.stop();
                        resolve(res);
                    }
                    catch (e) {
                        logger.error(`Error on active extension ${id}:`, e);
                        reject(e);
                    }
                });
                return result;
            },
            id,
            packageJSON,
            extensionPath,
            get isActive() {
                return isActive;
            },
            get module() {
                return ext;
            },
            get exports() {
                if (!isActive)
                    throw new Error(`Invalid access to exports, extension "${id}" not activated`);
                return exports;
            }
        };
        Object.freeze(extension);
        this.extensions.set(id, {
            id,
            type: extensionType,
            isLocal: extensionType == ExtensionType.Local,
            extension,
            directory: root,
            filepath: filename,
            events: getEvents(packageJSON.activationEvents),
            deactivate: async () => {
                if (!isActive)
                    return;
                isActive = false;
                result = undefined;
                exports = undefined;
                (0, util_1.disposeAll)(subscriptions);
                if (ext && typeof ext.deactivate === 'function') {
                    try {
                        await Promise.resolve(ext.deactivate());
                        ext = undefined;
                    }
                    catch (e) {
                        logger.error(`Error on ${id} deactivate: `, e);
                    }
                }
            }
        });
        this.registContribution(id, packageJSON, root, filename);
        this._onDidLoadExtension.fire(extension);
        if (this.activated && !noActive)
            await this.autoActiavte(id, extension);
    }
    unregistContribution(id) {
        let idx = this.configurationNodes.findIndex(o => o.extensionInfo.id === id);
        extensionRegistry.unregistExtension(id);
        if (idx !== -1) {
            let node = this.configurationNodes[idx];
            this.configurationNodes.splice(idx, 1);
            configurationRegistry.deregisterConfigurations([node]);
        }
    }
    async registerInternalExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.extensions.set(id, {
            id,
            directory: __dirname,
            type: ExtensionType.Internal,
            events: getEvents(packageJSON.activationEvents),
            extension,
            deactivate,
            isLocal: true
        });
        this.registContribution(id, packageJSON, __dirname);
        this._onDidLoadExtension.fire(extension);
        await this.autoActiavte(id, extension);
    }
    /**
     * Only global extensions can be uninstalled
     */
    async uninstallExtensions(ids) {
        let [globals, filtered] = (0, array_1.splitArray)(ids, id => this.states.hasExtension(id));
        for (let id of globals) {
            await this.unloadExtension(id);
            this.states.removeExtension(id);
            extensionRegistry.unregistExtension(id);
            await (0, fs_1.remove)(node_1.path.join(this.modulesFolder, id));
        }
        if (filtered.length > 0) {
            void window_1.default.showWarningMessage(`Global extensions ${filtered.join(', ')} not found`);
        }
        if (globals.length > 0) {
            void window_1.default.showInformationMessage(`Removed extensions: ${globals.join(' ')}`);
        }
    }
    async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == 'activated')
            await this.deactivate(id);
        if (state != 'disabled') {
            this.states.setDisable(id, true);
            this.unregistContribution(id);
            await this.unloadExtension(id);
        }
        else {
            this.states.setDisable(id, false);
            if (id.startsWith('single-')) {
                let filepath = node_1.path.join(this.singleExtensionsRoot, `${id.replace(/^single-/, '')}.js`);
                await this.loadExtensionFile(filepath);
            }
            else {
                let folder = this.states.getFolder(id);
                if (folder) {
                    await this.loadExtension(folder);
                }
                else {
                    void window_1.default.showWarningMessage(`Extension ${id} not found`);
                }
            }
        }
    }
    async watchExtension(id) {
        let item = this.getExtension(id);
        if (!item)
            throw new Error(`extension ${id} not found`);
        if (id.startsWith('single-')) {
            void window_1.default.showInformationMessage(`watching ${item.filepath}`);
            this.disposables.push((0, fs_1.watchFile)(item.filepath, async () => {
                await this.loadExtensionFile(item.filepath);
                void window_1.default.showInformationMessage(`reloaded ${id}`);
            }, global.__TEST__ === true));
        }
        else {
            let watchmanPath = workspace_1.default.getWatchmanPath();
            if (!watchmanPath)
                throw new Error('watchman not found');
            let client = await watchman_1.default.createClient(watchmanPath, item.directory);
            this.disposables.push(client);
            void window_1.default.showInformationMessage(`watching ${item.directory}`);
            await client.subscribe('**/*.js', async () => {
                await this.reloadExtension(id);
                void window_1.default.showInformationMessage(`reloaded ${id}`);
            });
        }
    }
    /**
     * load extension in folder or file
     */
    async load(filepath, active) {
        let name;
        if ((0, fs_1.isDirectory)(filepath)) {
            let obj = (0, fs_1.loadJson)(node_1.path.join(filepath, 'package.json'));
            name = obj.name;
            await this.loadExtension(filepath, true);
        }
        else {
            name = await this.loadExtensionFile(filepath, true);
        }
        if (!name)
            throw new Error(`Unable to load extension at ${filepath}`);
        let disabled = this.states.isDisabled(name);
        if (disabled)
            throw new Error(`extension ${name} is disabled`);
        let item = this.getExtension(name);
        if (active)
            await item.extension.activate();
        return {
            get isActive() {
                return item.extension.isActive;
            },
            get name() {
                return name;
            },
            get api() {
                return item.extension.exports;
            },
            get exports() {
                var _a;
                let module = (_a = item.extension.module) !== null && _a !== void 0 ? _a : {};
                return (0, lodash_1.omit)(module, ['activate']);
            },
            unload: () => {
                return this.unloadExtension(name);
            }
        };
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.ExtensionManager = ExtensionManager;
function getEvents(activationEvents) {
    let res = [];
    for (let ev of (0, array_1.toArray)(activationEvents)) {
        let [name] = ev.split(':', 2);
        if (name && !res.includes(name))
            res.push(name);
    }
    return res;
}
exports.getEvents = getEvents;
function getOnCommandList(activationEvents) {
    let res = [];
    for (let ev of (0, array_1.toArray)(activationEvents)) {
        let [name, command] = ev.split(':', 2);
        if (name === ActivateEvents.OnCommand && command)
            res.push(command);
    }
    return res;
}
exports.getOnCommandList = getOnCommandList;
function checkLanguageId(document, activationEvents) {
    for (let eventName of activationEvents) {
        let parts = eventName.split(':');
        let ev = parts[0];
        if (ev == ActivateEvents.OnLanguage && (document.languageId == parts[1] || document.filetype == parts[1])) {
            return true;
        }
    }
    return false;
}
exports.checkLanguageId = checkLanguageId;
function checkCommand(command, activationEvents) {
    for (let eventName of activationEvents) {
        let parts = eventName.split(':');
        let ev = parts[0];
        if (ev == ActivateEvents.OnCommand && command == parts[1]) {
            return true;
        }
    }
    return false;
}
exports.checkCommand = checkCommand;
function checkFileSystem(uri, activationEvents) {
    let scheme = vscode_uri_1.URI.parse(uri).scheme;
    for (let eventName of activationEvents) {
        let parts = eventName.split(':');
        let ev = parts[0];
        if (ev == ActivateEvents.OnFileSystem && scheme == parts[1]) {
            return true;
        }
    }
    return false;
}
exports.checkFileSystem = checkFileSystem;
function getActivationEvents(json) {
    return (0, array_1.toArray)(json.activationEvents).filter(key => typeof key === 'string' && key.length > 0);
}
exports.getActivationEvents = getActivationEvents;
/**
 * Convert globl patterns
 */
function toWorkspaceContinsPatterns(activationEvents) {
    let patterns = [];
    for (let eventName of activationEvents) {
        let parts = eventName.split(':');
        if (parts[0] == ActivateEvents.WorkspaceContains && parts[1]) {
            patterns.push(parts[1]);
        }
    }
    return patterns;
}
exports.toWorkspaceContinsPatterns = toWorkspaceContinsPatterns;
//# sourceMappingURL=manager.js.map