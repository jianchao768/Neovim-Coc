"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const filter_1 = require("../../util/filter");
const assert = tslib_1.__importStar(require("assert"));
describe('filter functions', () => {
    function assertMatches(pattern, word, decoratedWord, filter, opts = {}) {
        var _a;
        const r = filter(pattern, pattern.toLowerCase(), opts.patternPos || 0, word, word.toLowerCase(), opts.wordPos || 0, { firstMatchCanBeWeak: (_a = opts.firstMatchCanBeWeak) !== null && _a !== void 0 ? _a : false, boostFullMatch: true });
        assert.ok(!decoratedWord === !r);
        if (r) {
            const matches = (0, filter_1.createMatches)(r);
            let actualWord = '';
            let pos = 0;
            for (const match of matches) {
                actualWord += word.substring(pos, match.start);
                actualWord += '^' + word.substring(match.start, match.end).split('').join('^');
                pos = match.end;
            }
            actualWord += word.substring(pos);
            assert.strictEqual(actualWord, decoratedWord);
        }
    }
    function assertTopScore(filter, pattern, expected, ...words) {
        let topScore = -(100 * 10);
        let topIdx = 0;
        for (let i = 0; i < words.length; i++) {
            const word = words[i];
            const m = filter(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0);
            if (m) {
                const [score] = m;
                if (score > topScore) {
                    topScore = score;
                    topIdx = i;
                }
            }
        }
        assert.strictEqual(topIdx, expected, `${pattern} -> actual=${words[topIdx]} <> expected=${words[expected]}`);
    }
    test('isWhitespaceAtPos()', () => {
        expect((0, filter_1.isWhitespaceAtPos)('abc', -1)).toBe(false);
        expect((0, filter_1.isWhitespaceAtPos)('abc', 0)).toBe(false);
        expect((0, filter_1.isWhitespaceAtPos)(' bc', 0)).toBe(true);
    });
    test('isSeparatorAtPos()', () => {
        expect((0, filter_1.isSeparatorAtPos)('abc', -1)).toBe(false);
        expect((0, filter_1.isSeparatorAtPos)('abc', 6)).toBe(false);
        expect((0, filter_1.isSeparatorAtPos)('abc', 0)).toBe(false);
        expect((0, filter_1.isSeparatorAtPos)(' abc', 0)).toBe(true);
        expect((0, filter_1.isSeparatorAtPos)('ðŸ˜•abc', 0)).toBe(true);
    });
    test('isPatternInWord()', () => {
        const check = (pattern, word, patternPos = 0, wordPos = 0, result) => {
            let res = (0, filter_1.isPatternInWord)(pattern.toLowerCase(), patternPos, pattern.length, word.toLowerCase(), wordPos, word.length);
            expect(res).toBe(result);
        };
        check('abc', 'defabc', 0, 0, true);
        check('abc', 'defabc', 0, 4, false);
        check('abc', 'defab/c', 0, 0, true);
    });
    test('fuzzyScore, #23215', function () {
        assertMatches('tit', 'win.tit', 'win.^t^i^t', filter_1.fuzzyScore);
        assertMatches('title', 'win.title', 'win.^t^i^t^l^e', filter_1.fuzzyScore);
        assertMatches('WordCla', 'WordCharacterClassifier', '^W^o^r^dCharacter^C^l^assifier', filter_1.fuzzyScore);
        assertMatches('WordCCla', 'WordCharacterClassifier', '^W^o^r^d^Character^C^l^assifier', filter_1.fuzzyScore);
    });
    test('fuzzyScore, #23332', function () {
        assertMatches('dete', '"editor.quickSuggestionsDelay"', undefined, filter_1.fuzzyScore);
    });
    test('fuzzyScore, #23190', function () {
        assertMatches('c:\\do', '& \'C:\\Documents and Settings\'', '& \'^C^:^\\^D^ocuments and Settings\'', filter_1.fuzzyScore);
        assertMatches('c:\\do', '& \'c:\\Documents and Settings\'', '& \'^c^:^\\^D^ocuments and Settings\'', filter_1.fuzzyScore);
    });
    test('fuzzyScore, #23581', function () {
        assertMatches('close', 'css.lint.importStatement', '^css.^lint.imp^ort^Stat^ement', filter_1.fuzzyScore);
        assertMatches('close', 'css.colorDecorators.enable', '^css.co^l^orDecorator^s.^enable', filter_1.fuzzyScore);
        assertMatches('close', 'workbench.quickOpen.closeOnFocusOut', 'workbench.quickOpen.^c^l^o^s^eOnFocusOut', filter_1.fuzzyScore);
        assertTopScore(filter_1.fuzzyScore, 'close', 2, 'css.lint.importStatement', 'css.colorDecorators.enable', 'workbench.quickOpen.closeOnFocusOut');
    });
    test('fuzzyScore, #23458', function () {
        assertMatches('highlight', 'editorHoverHighlight', 'editorHover^H^i^g^h^l^i^g^h^t', filter_1.fuzzyScore);
        assertMatches('hhighlight', 'editorHoverHighlight', 'editor^Hover^H^i^g^h^l^i^g^h^t', filter_1.fuzzyScore);
        assertMatches('dhhighlight', 'editorHoverHighlight', undefined, filter_1.fuzzyScore);
    });
    test('fuzzyScore, #23746', function () {
        assertMatches('-moz', '-moz-foo', '^-^m^o^z-foo', filter_1.fuzzyScore);
        assertMatches('moz', '-moz-foo', '-^m^o^z-foo', filter_1.fuzzyScore);
        assertMatches('moz', '-moz-animation', '-^m^o^z-animation', filter_1.fuzzyScore);
        assertMatches('moza', '-moz-animation', '-^m^o^z-^animation', filter_1.fuzzyScore);
    });
    test('fuzzyScore', () => {
        assertMatches('ab', 'abA', '^a^bA', filter_1.fuzzyScore);
        assertMatches('ccm', 'cacmelCase', '^ca^c^melCase', filter_1.fuzzyScore);
        assertMatches('bti', 'the_black_knight', undefined, filter_1.fuzzyScore);
        assertMatches('ccm', 'camelCase', undefined, filter_1.fuzzyScore);
        assertMatches('cmcm', 'camelCase', undefined, filter_1.fuzzyScore);
        assertMatches('BK', 'the_black_knight', 'the_^black_^knight', filter_1.fuzzyScore);
        assertMatches('KeyboardLayout=', 'KeyboardLayout', undefined, filter_1.fuzzyScore);
        assertMatches('LLL', 'SVisualLoggerLogsList', 'SVisual^Logger^Logs^List', filter_1.fuzzyScore);
        assertMatches('LLLL', 'SVilLoLosLi', undefined, filter_1.fuzzyScore);
        assertMatches('LLLL', 'SVisualLoggerLogsList', undefined, filter_1.fuzzyScore);
        assertMatches('TEdit', 'TextEdit', '^Text^E^d^i^t', filter_1.fuzzyScore);
        assertMatches('TEdit', 'TextEditor', '^Text^E^d^i^tor', filter_1.fuzzyScore);
        assertMatches('TEdit', 'Textedit', '^Text^e^d^i^t', filter_1.fuzzyScore);
        assertMatches('TEdit', 'text_edit', '^text_^e^d^i^t', filter_1.fuzzyScore);
        assertMatches('TEditDit', 'TextEditorDecorationType', '^Text^E^d^i^tor^Decorat^ion^Type', filter_1.fuzzyScore);
        assertMatches('TEdit', 'TextEditorDecorationType', '^Text^E^d^i^torDecorationType', filter_1.fuzzyScore);
        assertMatches('Tedit', 'TextEdit', '^Text^E^d^i^t', filter_1.fuzzyScore);
        assertMatches('ba', '?AB?', undefined, filter_1.fuzzyScore);
        assertMatches('bkn', 'the_black_knight', 'the_^black_^k^night', filter_1.fuzzyScore);
        assertMatches('bt', 'the_black_knight', 'the_^black_knigh^t', filter_1.fuzzyScore);
        assertMatches('ccm', 'camelCasecm', '^camel^Casec^m', filter_1.fuzzyScore);
        assertMatches('fdm', 'findModel', '^fin^d^Model', filter_1.fuzzyScore);
        assertMatches('fob', 'foobar', '^f^oo^bar', filter_1.fuzzyScore);
        assertMatches('fobz', 'foobar', undefined, filter_1.fuzzyScore);
        assertMatches('foobar', 'foobar', '^f^o^o^b^a^r', filter_1.fuzzyScore);
        assertMatches('form', 'editor.formatOnSave', 'editor.^f^o^r^matOnSave', filter_1.fuzzyScore);
        assertMatches('g p', 'Git: Pull', '^Git:^ ^Pull', filter_1.fuzzyScore);
        assertMatches('g p', 'Git: Pull', '^Git:^ ^Pull', filter_1.fuzzyScore);
        assertMatches('gip', 'Git: Pull', '^G^it: ^Pull', filter_1.fuzzyScore);
        assertMatches('gip', 'Git: Pull', '^G^it: ^Pull', filter_1.fuzzyScore);
        assertMatches('gp', 'Git: Pull', '^Git: ^Pull', filter_1.fuzzyScore);
        assertMatches('gp', 'Git_Git_Pull', '^Git_Git_^Pull', filter_1.fuzzyScore);
        assertMatches('is', 'ImportStatement', '^Import^Statement', filter_1.fuzzyScore);
        assertMatches('is', 'isValid', '^i^sValid', filter_1.fuzzyScore);
        assertMatches('lowrd', 'lowWord', '^l^o^wWo^r^d', filter_1.fuzzyScore);
        assertMatches('myvable', 'myvariable', '^m^y^v^aria^b^l^e', filter_1.fuzzyScore);
        assertMatches('no', '', undefined, filter_1.fuzzyScore);
        assertMatches('no', 'match', undefined, filter_1.fuzzyScore);
        assertMatches('ob', 'foobar', undefined, filter_1.fuzzyScore);
        assertMatches('sl', 'SVisualLoggerLogsList', '^SVisual^LoggerLogsList', filter_1.fuzzyScore);
        assertMatches('sllll', 'SVisualLoggerLogsList', '^SVisua^l^Logger^Logs^List', filter_1.fuzzyScore);
        assertMatches('Three', 'HTMLHRElement', undefined, filter_1.fuzzyScore);
        assertMatches('Three', 'Three', '^T^h^r^e^e', filter_1.fuzzyScore);
        assertMatches('fo', 'barfoo', undefined, filter_1.fuzzyScore);
        assertMatches('fo', 'bar_foo', 'bar_^f^oo', filter_1.fuzzyScore);
        assertMatches('fo', 'bar_Foo', 'bar_^F^oo', filter_1.fuzzyScore);
        assertMatches('fo', 'bar foo', 'bar ^f^oo', filter_1.fuzzyScore);
        assertMatches('fo', 'bar.foo', 'bar.^f^oo', filter_1.fuzzyScore);
        assertMatches('fo', 'bar/foo', 'bar/^f^oo', filter_1.fuzzyScore);
        assertMatches('fo', 'bar\\foo', 'bar\\^f^oo', filter_1.fuzzyScore);
    });
    test('fuzzyScore (first match can be weak)', function () {
        assertMatches('Three', 'HTMLHRElement', 'H^TML^H^R^El^ement', filter_1.fuzzyScore, { firstMatchCanBeWeak: true });
        assertMatches('tor', 'constructor', 'construc^t^o^r', filter_1.fuzzyScore, { firstMatchCanBeWeak: true });
        assertMatches('ur', 'constructor', 'constr^ucto^r', filter_1.fuzzyScore, { firstMatchCanBeWeak: true });
        assertTopScore(filter_1.fuzzyScore, 'tor', 2, 'constructor', 'Thor', 'cTor');
    });
    test('fuzzyScore, many matches', function () {
        assertMatches('aaaaaa', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', '^a^a^a^a^a^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', filter_1.fuzzyScore);
        let res = (0, filter_1.fuzzyScore)('a'.repeat(1024), 'a'.repeat(1024), 0, 'word', 'word', 0);
        expect(res).toBeUndefined();
    });
    test('Freeze when fjfj -> jfjf, https://github.com/microsoft/vscode/issues/91807', function () {
        assertMatches('jfjfj', 'fjfjfjfjfjfjfjfjfjfjfj', undefined, filter_1.fuzzyScore);
        assertMatches('jfjfjfjfjfjfjfjfjfj', 'fjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfj', undefined, filter_1.fuzzyScore);
        assertMatches('jfjfjfjfjfjfjfjfjfjjfjfjfjfjfjfjfjfjfjjfjfjfjfjfjfjfjfjfjjfjfjfjfjfjfjfjfjfjjfjfjfjfjfjfjfjfjfjjfjfjfjfjfjfjfjfjfj', 'fjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfj', undefined, filter_1.fuzzyScore);
        assertMatches('jfjfjfjfjfjfjfjfjfj', 'fJfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfj', 'f^J^f^j^f^j^f^j^f^j^f^j^f^j^f^j^f^j^f^jfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfj', // strong match
        filter_1.fuzzyScore);
        assertMatches('jfjfjfjfjfjfjfjfjfj', 'fjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfj', 'f^j^f^j^f^j^f^j^f^j^f^j^f^j^f^j^f^j^f^jfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfjfj', // any match
        filter_1.fuzzyScore, { firstMatchCanBeWeak: true });
    });
    test('fuzzyScore, issue #26423', function () {
        assertMatches('baba', 'abababab', undefined, filter_1.fuzzyScore);
        assertMatches('fsfsfs', 'dsafdsafdsafdsafdsafdsafdsafasdfdsa', undefined, filter_1.fuzzyScore);
        assertMatches('fsfsfsfsfsfsfsf', 'dsafdsafdsafdsafdsafdsafdsafasdfdsafdsafdsafdsafdsfdsafdsfdfdfasdnfdsajfndsjnafjndsajlknfdsa', undefined, filter_1.fuzzyScore);
    });
    test('Fuzzy IntelliSense matching vs Haxe metadata completion, #26995', function () {
        assertMatches('f', ':Foo', ':^Foo', filter_1.fuzzyScore);
        assertMatches('f', ':foo', ':^foo', filter_1.fuzzyScore);
    });
    test('Separator only match should not be weak #79558', function () {
        assertMatches('.', 'foo.bar', 'foo^.bar', filter_1.fuzzyScore);
    });
    test('Cannot set property \'1\' of undefined, #26511', function () {
        const word = new Array(123).join('a');
        const pattern = new Array(120).join('a');
        (0, filter_1.fuzzyScore)(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0);
        assert.ok(true); // must not explode
    });
    test('Vscode 1.12 no longer obeys \'sortText\' in completion items (from language server), #26096', function () {
        assertMatches('  ', '  group', undefined, filter_1.fuzzyScore, { patternPos: 2 });
        assertMatches('  g', '  group', '  ^group', filter_1.fuzzyScore, { patternPos: 2 });
        assertMatches('g', '  group', '  ^group', filter_1.fuzzyScore);
        assertMatches('g g', '  groupGroup', undefined, filter_1.fuzzyScore);
        assertMatches('g g', '  group Group', '  ^group^ ^Group', filter_1.fuzzyScore);
        assertMatches(' g g', '  group Group', '  ^group^ ^Group', filter_1.fuzzyScore, { patternPos: 1 });
        assertMatches('zz', 'zzGroup', '^z^zGroup', filter_1.fuzzyScore);
        assertMatches('zzg', 'zzGroup', '^z^z^Group', filter_1.fuzzyScore);
        assertMatches('g', 'zzGroup', 'zz^Group', filter_1.fuzzyScore);
    });
    test('patternPos isn\'t working correctly #79815', function () {
        assertMatches(':p'.substr(1), 'prop', '^prop', filter_1.fuzzyScore, { patternPos: 0 });
        assertMatches(':p', 'prop', '^prop', filter_1.fuzzyScore, { patternPos: 1 });
        assertMatches(':p', 'prop', undefined, filter_1.fuzzyScore, { patternPos: 2 });
        assertMatches(':p', 'proP', 'pro^P', filter_1.fuzzyScore, { patternPos: 1, wordPos: 1 });
        assertMatches(':p', 'aprop', 'a^prop', filter_1.fuzzyScore, { patternPos: 1, firstMatchCanBeWeak: true });
        assertMatches(':p', 'aprop', undefined, filter_1.fuzzyScore, { patternPos: 1, firstMatchCanBeWeak: false });
    });
    test('topScore - fuzzyScore', function () {
        assertTopScore(filter_1.fuzzyScore, 'cons', 2, 'ArrayBufferConstructor', 'Console', 'console');
        assertTopScore(filter_1.fuzzyScore, 'Foo', 1, 'foo', 'Foo', 'foo');
        // #24904
        assertTopScore(filter_1.fuzzyScore, 'onMess', 1, 'onmessage', 'onMessage', 'onThisMegaEscape');
        assertTopScore(filter_1.fuzzyScore, 'CC', 1, 'camelCase', 'CamelCase');
        assertTopScore(filter_1.fuzzyScore, 'cC', 0, 'camelCase', 'CamelCase');
        // assertTopScore(fuzzyScore, 'cC', 1, 'ccfoo', 'camelCase');
        // assertTopScore(fuzzyScore, 'cC', 1, 'ccfoo', 'camelCase', 'foo-cC-bar');
        // issue #17836
        // assertTopScore(fuzzyScore, 'TEdit', 1, 'TextEditorDecorationType', 'TextEdit', 'TextEditor');
        assertTopScore(filter_1.fuzzyScore, 'p', 4, 'parse', 'posix', 'pafdsa', 'path', 'p');
        assertTopScore(filter_1.fuzzyScore, 'pa', 0, 'parse', 'pafdsa', 'path');
        // issue #14583
        assertTopScore(filter_1.fuzzyScore, 'log', 3, 'HTMLOptGroupElement', 'ScrollLogicalPosition', 'SVGFEMorphologyElement', 'log', 'logger');
        assertTopScore(filter_1.fuzzyScore, 'e', 2, 'AbstractWorker', 'ActiveXObject', 'else');
        // issue #14446
        assertTopScore(filter_1.fuzzyScore, 'workbench.sideb', 1, 'workbench.editor.defaultSideBySideLayout', 'workbench.sideBar.location');
        // issue #11423
        assertTopScore(filter_1.fuzzyScore, 'editor.r', 2, 'diffEditor.renderSideBySide', 'editor.overviewRulerlanes', 'editor.renderControlCharacter', 'editor.renderWhitespace');
        // assertTopScore(fuzzyScore, 'editor.R', 1, 'diffEditor.renderSideBySide', 'editor.overviewRulerlanes', 'editor.renderControlCharacter', 'editor.renderWhitespace');
        // assertTopScore(fuzzyScore, 'Editor.r', 0, 'diffEditor.renderSideBySide', 'editor.overviewRulerlanes', 'editor.renderControlCharacter', 'editor.renderWhitespace');
        assertTopScore(filter_1.fuzzyScore, '-mo', 1, '-ms-ime-mode', '-moz-columns');
        // dupe, issue #14861
        assertTopScore(filter_1.fuzzyScore, 'convertModelPosition', 0, 'convertModelPositionToViewPosition', 'convertViewToModelPosition');
        // dupe, issue #14942
        assertTopScore(filter_1.fuzzyScore, 'is', 0, 'isValidViewletId', 'import statement');
        assertTopScore(filter_1.fuzzyScore, 'title', 1, 'files.trimTrailingWhitespace', 'window.title');
        assertTopScore(filter_1.fuzzyScore, 'const', 1, 'constructor', 'const', 'cuOnstrul');
    });
    test('Unexpected suggestion scoring, #28791', function () {
        assertTopScore(filter_1.fuzzyScore, '_lines', 1, '_lineStarts', '_lines');
        assertTopScore(filter_1.fuzzyScore, '_lines', 1, '_lineS', '_lines');
        assertTopScore(filter_1.fuzzyScore, '_lineS', 0, '_lineS', '_lines');
    });
    test('HTML closing tag proposal filtered out #38880', function () {
        assertMatches('\t\t<', '\t\t</body>', '^\t^\t^</body>', filter_1.fuzzyScore, { patternPos: 0 });
        assertMatches('\t\t<', '\t\t</body>', '\t\t^</body>', filter_1.fuzzyScore, { patternPos: 2 });
        assertMatches('\t<', '\t</body>', '\t^</body>', filter_1.fuzzyScore, { patternPos: 1 });
    });
    test('fuzzyScoreGraceful', () => {
        assertMatches('rlut', 'result', undefined, filter_1.fuzzyScore);
        assertMatches('rlut', 'result', '^res^u^l^t', filter_1.fuzzyScoreGraceful);
        assertMatches('cno', 'console', '^co^ns^ole', filter_1.fuzzyScore);
        assertMatches('cno', 'console', '^co^ns^ole', filter_1.fuzzyScoreGraceful);
        assertMatches('cno', 'console', '^c^o^nsole', filter_1.fuzzyScoreGracefulAggressive);
        assertMatches('cno', 'co_new', '^c^o_^new', filter_1.fuzzyScoreGraceful);
        assertMatches('cno', 'co_new', '^c^o_^new', filter_1.fuzzyScoreGracefulAggressive);
    });
    test('List highlight filter: Not all characters from match are highlighterd #66923', () => {
        assertMatches('foo', 'barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_foo', 'barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_^f^o^o', filter_1.fuzzyScore);
    });
    test('Autocompletion is matched against truncated filterText to 54 characters #74133', () => {
        assertMatches('foo', 'ffffffffffffffffffffffffffffbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_foo', 'ffffffffffffffffffffffffffffbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_^f^o^o', filter_1.fuzzyScore);
        assertMatches('Aoo', 'Affffffffffffffffffffffffffffbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_foo', '^Affffffffffffffffffffffffffffbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_f^o^o', filter_1.fuzzyScore);
        assertMatches('foo', 'Gffffffffffffffffffffffffffffbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar_foo', undefined, filter_1.fuzzyScore);
    });
    test('"Go to Symbol" with the exact method name doesn\'t work as expected #84787', function () {
        const match = (0, filter_1.fuzzyScore)(':get', ':get', 1, 'get', 'get', 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
        assert.ok(Boolean(match));
    });
    test('Wrong highlight after emoji #113404', function () {
        assertMatches('di', 'âœ¨div classname=""></div>', 'âœ¨^d^iv classname=""></div>', filter_1.fuzzyScore);
        assertMatches('di', 'adiv classname=""></div>', 'adiv classname=""></^d^iv>', filter_1.fuzzyScore);
    });
    test('Suggestion is not highlighted #85826', function () {
        assertMatches('SemanticTokens', 'SemanticTokensEdits', '^S^e^m^a^n^t^i^c^T^o^k^e^n^sEdits', filter_1.fuzzyScore);
        assertMatches('SemanticTokens', 'SemanticTokensEdits', '^S^e^m^a^n^t^i^c^T^o^k^e^n^sEdits', filter_1.fuzzyScoreGracefulAggressive);
    });
    test('IntelliSense completion not correctly highlighting text in front of cursor #115250', function () {
        assertMatches('lo', 'log', '^l^og', filter_1.fuzzyScore);
        assertMatches('.lo', 'log', '^l^og', filter_1.anyScore);
        assertMatches('.', 'log', 'log', filter_1.anyScore);
    });
    test('configurable full match boost', function () {
        const prefix = 'create';
        const a = 'createModelServices';
        const b = 'create';
        const aBoost = (0, filter_1.fuzzyScore)(prefix, prefix, 0, a, a.toLowerCase(), 0, { boostFullMatch: true, firstMatchCanBeWeak: true });
        const bBoost = (0, filter_1.fuzzyScore)(prefix, prefix, 0, b, b.toLowerCase(), 0, { boostFullMatch: true, firstMatchCanBeWeak: true });
        assert.ok(aBoost);
        assert.ok(bBoost);
        assert.ok(aBoost[0] < bBoost[0]);
        const aScore = (0, filter_1.fuzzyScore)(prefix, prefix, 0, a, a.toLowerCase(), 0, { boostFullMatch: false, firstMatchCanBeWeak: true });
        const bScore = (0, filter_1.fuzzyScore)(prefix, prefix, 0, b, b.toLowerCase(), 0, { boostFullMatch: false, firstMatchCanBeWeak: true });
        assert.ok(aScore);
        assert.ok(bScore);
        assert.ok(aScore[0] === bScore[0]);
    });
    test('Unexpected suggest highlighting ignores whole word match in favor of matching first letter#147423', function () {
        assertMatches('i', 'machine/{id}', 'machine/{^id}', filter_1.fuzzyScore);
        assertMatches('ok', 'obobobf{ok}/user', '^obobobf{o^k}/user', filter_1.fuzzyScore);
    });
    test('nextTypoPermutation', () => {
        expect((0, filter_1.nextTypoPermutation)('abc', 2)).toBeUndefined();
    });
    test('createMatches()', () => {
        expect((0, filter_1.createMatches)(undefined)).toEqual([]);
    });
});
//# sourceMappingURL=filter.test.js.map