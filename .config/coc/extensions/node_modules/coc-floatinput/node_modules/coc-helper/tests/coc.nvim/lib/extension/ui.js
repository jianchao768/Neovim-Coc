'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstallBuffer = exports.InstallChannel = exports.State = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const status_1 = require("../model/status");
const util_1 = require("../util");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const interval = (0, util_1.getConditionValue)(100, 1);
var State;
(function (State) {
    State[State["Waiting"] = 0] = "Waiting";
    State[State["Failed"] = 1] = "Failed";
    State[State["Progressing"] = 2] = "Progressing";
    State[State["Success"] = 3] = "Success";
})(State = exports.State || (exports.State = {}));
class InstallChannel {
    constructor(isUpdate, channel) {
        this.isUpdate = isUpdate;
        this.channel = channel;
    }
    start(names) {
        this.channel.appendLine(`${this.isUpdate ? 'Updating' : 'Installing'} ${names.join(', ')}`);
    }
    addMessage(name, msg, isProgress) {
        if (!isProgress) {
            this.channel.appendLine(`${name} - ${msg}`);
        }
    }
    startProgress(name) {
        this.channel.appendLine(`Start ${this.isUpdate ? 'update' : 'install'} ${name}`);
    }
    finishProgress(name, succeed) {
        if (succeed) {
            this.channel.appendLine(`${name} ${this.isUpdate ? 'update' : 'install'} succeed!`);
        }
        else {
            this.channel.appendLine(`${name} ${this.isUpdate ? 'update' : 'install'} failed!`);
        }
    }
}
exports.InstallChannel = InstallChannel;
const debounceTime = (0, util_1.getConditionValue)(500, 10);
class InstallBuffer {
    constructor(isUpdate) {
        this.isUpdate = isUpdate;
        this.statMap = new Map();
        this.updated = new Set();
        this.messagesMap = new Map();
        this.disposables = [];
        this.names = [];
        let floatFactory = window_1.default.createFloatFactory({ modes: ['n'] });
        this.disposables.push(floatFactory);
        let fn = (0, node_1.debounce)(async (bufnr, cursor) => {
            if (bufnr == this.bufnr) {
                let msgs = this.getMessages(cursor[0] - 1);
                let docs = msgs.length > 0 ? [{ content: msgs.join('\n'), filetype: 'txt' }] : [];
                await floatFactory.show(docs);
            }
        }, debounceTime);
        this.disposables.push(protocol_1.Disposable.create(() => {
            fn.clear();
        }));
        events_1.default.on('CursorMoved', fn, this.disposables);
        events_1.default.on('BufUnload', bufnr => {
            if (bufnr === this.bufnr) {
                this.dispose();
            }
        }, null, this.disposables);
    }
    async start(names) {
        this.statMap.clear();
        this.names = names;
        for (let name of names) {
            this.statMap.set(name, State.Waiting);
        }
        await this.show();
    }
    addMessage(name, msg) {
        let lines = this.messagesMap.get(name) || [];
        this.messagesMap.set(name, lines.concat(msg.trim().split(/\r?\n/)));
        if ((msg.startsWith('Updated to') || msg.startsWith('Installed extension'))) {
            this.updated.add(name);
        }
    }
    startProgress(name) {
        this.statMap.set(name, State.Progressing);
    }
    finishProgress(name, succeed) {
        this.statMap.set(name, succeed ? State.Success : State.Failed);
    }
    get remains() {
        let count = 0;
        for (let name of this.names) {
            let stat = this.statMap.get(name);
            if (![State.Success, State.Failed].includes(stat)) {
                count = count + 1;
            }
        }
        return count;
    }
    getLinesAndHighlights(start) {
        let lines = [];
        let highlights = [];
        for (let name of this.names) {
            let state = this.statMap.get(name);
            let processText = '*';
            let hlGroup;
            let lnum = start + lines.length;
            switch (state) {
                case State.Progressing: {
                    let d = new Date();
                    let idx = Math.floor(d.getMilliseconds() / 100);
                    processText = status_1.frames[idx];
                    hlGroup = undefined;
                    break;
                }
                case State.Failed:
                    processText = '✗';
                    hlGroup = 'ErrorMsg';
                    break;
                case State.Success:
                    processText = '✓';
                    hlGroup = this.updated.has(name) ? 'MoreMsg' : 'Comment';
                    break;
            }
            let msgs = this.messagesMap.get(name) || [];
            let pre = `- ${processText} `;
            let len = (0, string_1.byteLength)(pre);
            if (hlGroup) {
                highlights.push({ hlGroup, lnum, colStart: len, colEnd: len + (0, string_1.byteLength)(name) });
            }
            lines.push(`${pre}${name} ${msgs.length ? msgs[msgs.length - 1] : ''}`);
        }
        return { lines, highlights };
    }
    getMessages(line) {
        var _a;
        let name = this.names[line - 2];
        return (_a = this.messagesMap.get(name)) !== null && _a !== void 0 ? _a : [];
    }
    get stopped() {
        return this.interval == null;
    }
    // draw frame
    draw() {
        let { remains, bufnr } = this;
        let { nvim } = workspace_1.default;
        if (!bufnr)
            return;
        let buffer = nvim.createBuffer(bufnr);
        let first = remains == 0 ? `${this.isUpdate ? 'Update' : 'Install'} finished` : `Installing, ${remains} remaining...`;
        let { lines, highlights } = this.getLinesAndHighlights(2);
        nvim.pauseNotification();
        buffer.setLines([first, '', ...lines], { start: 0, end: -1, strictIndexing: false }, true);
        buffer.updateHighlights('coc-extensions', highlights, { priority: 99 });
        if (remains == 0 && this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        nvim.resumeNotification(true, true);
    }
    highlight() {
        let { nvim } = workspace_1.default;
        nvim.call('matchadd', ['CocListFgCyan', '^\\-\\s\\zs\\*'], true);
        nvim.call('matchadd', ['CocListFgGreen', '^\\-\\s\\zs✓'], true);
        nvim.call('matchadd', ['CocListFgRed', '^\\-\\s\\zs✗'], true);
    }
    async show() {
        let isSync = events_1.default.requesting === true;
        let { nvim } = workspace_1.default;
        nvim.pauseNotification();
        nvim.command(isSync ? 'enew' : 'vs +enew', true);
        nvim.call('bufnr', ['%'], true);
        nvim.command('setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1', true);
        if (!isSync)
            nvim.command('nnoremap <silent><nowait><buffer> q :q<CR>', true);
        this.highlight();
        let res = await nvim.resumeNotification();
        this.bufnr = res[0][1];
        this.interval = setInterval(() => {
            this.draw();
        }, interval);
    }
    dispose() {
        this.bufnr = undefined;
        this.messagesMap.clear();
        this.statMap.clear();
        (0, util_1.disposeAll)(this.disposables);
        clearInterval(this.interval);
        this.interval = null;
    }
}
exports.InstallBuffer = InstallBuffer;
//# sourceMappingURL=ui.js.map