'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const fuzzyMatch_1 = require("../model/fuzzyMatch");
const util_1 = require("../util");
const array_1 = require("../util/array");
const filter_1 = require("../util/filter");
const mutex_1 = require("../util/mutex");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const filter_2 = tslib_1.__importStar(require("./filter"));
const TreeItem_1 = require("./TreeItem");
const logger = (0, logger_1.createLogger)('BasicTreeView');
const retryTimeout = (0, util_1.getConditionValue)(500, 10);
const maxRetry = (0, util_1.getConditionValue)(5, 1);
const highlightNamespace = 'tree';
const signOffset = 3000;
let globalId = 1;
/**
 * Basic TreeView implementation
 */
class BasicTreeView {
    constructor(viewId, opts) {
        this.viewId = viewId;
        this.opts = opts;
        this._selection = [];
        this._keymapDefs = [];
        this._onDispose = new protocol_1.Emitter();
        this._onDidRefrash = new protocol_1.Emitter();
        this._onDidExpandElement = new protocol_1.Emitter();
        this._onDidCollapseElement = new protocol_1.Emitter();
        this._onDidChangeSelection = new protocol_1.Emitter();
        this._onDidChangeVisibility = new protocol_1.Emitter();
        this._onDidFilterStateChange = new protocol_1.Emitter();
        this._onDidCursorMoved = new protocol_1.Emitter();
        this.onDidRefrash = this._onDidRefrash.event;
        this.onDispose = this._onDispose.event;
        this.onDidExpandElement = this._onDidExpandElement.event;
        this.onDidCollapseElement = this._onDidCollapseElement.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.onDidFilterStateChange = this._onDidFilterStateChange.event;
        this.onDidCursorMoved = this._onDidCursorMoved.event;
        this.retryTimers = 0;
        this.renderedItems = [];
        this.nodesMap = new Map();
        this.mutex = new mutex_1.Mutex();
        this.disposables = [];
        this.lineState = { titleCount: 0, messageCount: 0 };
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        if (opts.enableFilter) {
            this.filter = new filter_2.default(this.nvim, [this.keys.selectNext, this.keys.selectPrevious, this.keys.invoke]);
        }
        let id = globalId;
        globalId = globalId + 1;
        this.bufname = `CocTree${id}`;
        this.tooltipFactory = window_1.default.createFloatFactory({ modes: ['n'] });
        this.provider = opts.treeDataProvider;
        this.leafIndent = opts.disableLeafIndent !== true;
        this.winfixwidth = opts.winfixwidth !== false;
        this.autoWidth = opts.autoWidth === true;
        let message;
        Object.defineProperty(this, 'message', {
            set: (msg) => {
                message = msg ? msg.replace(/\r?\n/g, ' ') : undefined;
                this.updateHeadLines();
            },
            get: () => {
                return message;
            }
        });
        let title = viewId.replace(/\r?\n/g, ' ');
        Object.defineProperty(this, 'title', {
            set: (newTitle) => {
                title = newTitle ? newTitle.replace(/\r?\n/g, ' ') : undefined;
                this.updateHeadLines();
            },
            get: () => {
                return title;
            }
        });
        let description;
        Object.defineProperty(this, 'description', {
            set: (desc) => {
                description = desc ? desc.replace(/\r?\n/g, ' ') : undefined;
                this.updateHeadLines();
            },
            get: () => {
                return description;
            }
        });
        let filterText;
        Object.defineProperty(this, 'filterText', {
            set: (text) => {
                let { titleCount, messageCount } = this.lineState;
                let start = titleCount + messageCount;
                if (text != null) {
                    let highlights = [{
                            lnum: start,
                            colStart: (0, string_1.byteLength)(text),
                            colEnd: (0, string_1.byteLength)(text) + 1,
                            hlGroup: 'Cursor'
                        }];
                    this.renderedItems = [];
                    this.updateUI([text + ' '], highlights, start, -1, true);
                    void this.doFilter(text);
                }
                else if (filterText != null) {
                    this.updateUI([], [], start, start + 1);
                }
                filterText = text;
            },
            get: () => {
                return filterText;
            }
        });
        if (this.provider.onDidChangeTreeData) {
            this.provider.onDidChangeTreeData(this.onDataChange, this, this.disposables);
        }
        events_1.default.on('BufUnload', bufnr => {
            if (bufnr != this.bufnr)
                return;
            let isVisible = this.winid != null;
            this.winid = undefined;
            this.bufnr = undefined;
            if (isVisible)
                this._onDidChangeVisibility.fire({ visible: false });
            this.dispose();
        }, null, this.disposables);
        events_1.default.on('WinClosed', winid => {
            if (this.winid === winid) {
                this.winid = undefined;
                this._onDidChangeVisibility.fire({ visible: false });
            }
        }, null, this.disposables);
        // switched to another buffer
        events_1.default.on('BufWinLeave', (bufnr, winid) => {
            if (bufnr == this.bufnr && winid == this.winid) {
                this.winid = undefined;
                this._onDidChangeVisibility.fire({ visible: false });
            }
        }, null, this.disposables);
        window_1.default.onDidTabClose(id => {
            if (this._targetTabId === id) {
                this.dispose();
            }
        }, null, this.disposables);
        events_1.default.on('CursorHold', async (bufnr, cursor) => {
            if (bufnr != this.bufnr)
                return;
            await this.onHover(cursor[0]);
        }, null, this.disposables);
        events_1.default.on(['CursorMoved', 'BufEnter'], () => {
            this.cancelResolve();
        }, null, this.disposables);
        events_1.default.on('CursorMoved', (bufnr, cursor) => {
            if (bufnr == this.bufnr) {
                let element = this.getElementByLnum(cursor[0] - 1);
                this._onDidCursorMoved.fire(element);
            }
        }, null, this.disposables);
        events_1.default.on('WinEnter', winid => {
            if (winid != this.windowId || !this.filtering)
                return;
            let buf = this.nvim.createBuffer(this.bufnr);
            let line = this.startLnum - 1;
            let len = (0, string_1.toText)(this.filterText).length;
            let range = vscode_languageserver_types_1.Range.create(line, len, line, len + 1);
            buf.highlightRanges(highlightNamespace, 'Cursor', [range]);
            this.nvim.call('coc#prompt#start_prompt', [filter_2.sessionKey], true);
            this.redraw();
        }, null, this.disposables);
        events_1.default.on('WinLeave', winid => {
            if (winid != this.windowId || !this.filtering)
                return;
            let buf = this.nvim.createBuffer(this.bufnr);
            this.nvim.call('coc#prompt#stop_prompt', [filter_2.sessionKey], true);
            buf.clearNamespace(highlightNamespace, this.startLnum - 1, this.startLnum);
        }, null, this.disposables);
        this.disposables.push(this._onDidChangeVisibility, this._onDidCursorMoved, this._onDidChangeSelection, this._onDidCollapseElement, this._onDidExpandElement);
        if (this.filter) {
            this.filter.onDidExit(node => {
                this.nodesMap.clear();
                this.filterText = undefined;
                this.itemsToFilter = undefined;
                if (node && typeof this.provider.getParent === 'function') {
                    this.renderedItems = [];
                    void this.reveal(node, { focus: true });
                }
                else {
                    this.clearSelection();
                    void this.render();
                }
                this._onDidFilterStateChange.fire(false);
            });
            this.filter.onDidUpdate(text => {
                this.filterText = text;
            });
            this.filter.onDidKeyPress(async (character) => {
                var _a, _b;
                let items = (0, array_1.toArray)(this.renderedItems);
                let curr = this.selection[0];
                if (character == '<up>' || character == this.keys.selectPrevious) {
                    let idx = items.findIndex(o => o.node == curr);
                    let index = idx == -1 || idx == 0 ? items.length - 1 : idx - 1;
                    let node = (_a = items[index]) === null || _a === void 0 ? void 0 : _a.node;
                    if (node)
                        this.selectItem(node, true);
                }
                if (character == '<down>' || character == this.keys.selectNext) {
                    let idx = items.findIndex(o => o.node == curr);
                    let index = idx == -1 || idx == items.length - 1 ? 0 : idx + 1;
                    let node = (_b = items[index]) === null || _b === void 0 ? void 0 : _b.node;
                    if (node)
                        this.selectItem(node, true);
                }
                if (character == '<cr>' || character == this.keys.invoke) {
                    if (!curr)
                        return;
                    await this.invokeCommand(curr);
                    this.filter.deactivate(curr);
                }
            });
        }
    }
    get windowId() {
        return this.winid;
    }
    get targetTabId() {
        return this._targetTabId;
    }
    get targetWinId() {
        return this._targetWinId;
    }
    get targetBufnr() {
        return this._targetBufnr;
    }
    get startLnum() {
        let filterCount = this.filterText == null ? 0 : 1;
        return this.lineState.messageCount + this.lineState.titleCount + filterCount;
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    get filtering() {
        return this.filter != null && this.filter.activated;
    }
    loadConfiguration(e) {
        if (!e || e.affectsConfiguration('tree')) {
            let config = workspace_1.default.getConfiguration('tree', null);
            this.config = {
                openedIcon: config.get('openedIcon', ' '),
                closedIcon: config.get('closedIcon', ' ')
            };
            this.keys = {
                close: config.get('key.close'),
                invoke: config.get('key.invoke'),
                toggle: config.get('key.toggle'),
                actions: config.get('key.actions'),
                collapseAll: config.get('key.collapseAll'),
                toggleSelection: config.get('key.toggleSelection'),
                activeFilter: config.get('key.activeFilter'),
                selectNext: config.get('key.selectNext'),
                selectPrevious: config.get('key.selectPrevious')
            };
            if (e && this.visible) {
                void this.render();
            }
        }
    }
    async doFilter(text) {
        let items = [];
        let index = 0;
        let release = await this.mutex.acquire();
        try {
            if (!this.itemsToFilter) {
                let itemsToFilter = [];
                const addNodes = async (nodes) => {
                    for (let n of nodes) {
                        itemsToFilter.push(n);
                        let arr = await Promise.resolve(this.provider.getChildren(n));
                        if (!(0, array_1.isFalsyOrEmpty)(arr))
                            await addNodes(arr);
                    }
                };
                let nodes = await Promise.resolve(this.provider.getChildren());
                await addNodes(nodes);
                this.itemsToFilter = itemsToFilter;
            }
            let lowInput = text.toLowerCase();
            let emptyInput = text.length === 0;
            for (let n of this.itemsToFilter) {
                let item = await this.getTreeItem(n);
                let label = (0, TreeItem_1.getItemLabel)(item);
                let score = 0;
                if (!emptyInput) {
                    let res = (0, filter_1.fuzzyScoreGracefulAggressive)(text, lowInput, 0, label, label.toLowerCase(), 0, { boostFullMatch: true, firstMatchCanBeWeak: true });
                    if (!res)
                        continue;
                    score = res[0];
                    item.label = { label, highlights: (0, fuzzyMatch_1.toSpans)(label, res) };
                }
                else {
                    item.label = { label, highlights: [] };
                }
                item.collapsibleState = TreeItem_1.TreeItemCollapsibleState.None;
                let { line, highlights } = this.getRenderedLine(item, index, 0);
                items.push({
                    level: 0,
                    node: n,
                    line,
                    index,
                    score,
                    highlights
                });
                index += 1;
            }
            items.sort((a, b) => {
                if (a.score != b.score)
                    return b.score - a.score;
                return a.index - b.index;
            });
            let lnum = this.startLnum;
            let highlights = [];
            let renderedItems = this.renderedItems = items.map((o, idx) => {
                highlights.push(...o.highlights.map(h => {
                    h.lnum = lnum + idx;
                    return h;
                }));
                delete o.index;
                delete o.score;
                delete o.highlights;
                return o;
            });
            this.updateUI(renderedItems.map(o => o.line), highlights, lnum, -1, true);
            if (renderedItems.length) {
                this.selectItem(renderedItems[0].node, true);
            }
            else {
                this.clearSelection();
            }
            this.redraw();
            release();
        }
        catch (e) {
            release();
            logger.error(`Error on tree filter:`, e);
        }
    }
    async onHover(lnum) {
        let element = this.getElementByLnum(lnum - 1);
        if (!element || !this.nodesMap.has(element))
            return;
        let obj = this.nodesMap.get(element);
        let item = obj.item;
        if (!item.tooltip && !obj.resolved)
            item = await this.resolveItem(element, item);
        if (!item.tooltip)
            return;
        let isMarkdown = vscode_languageserver_types_1.MarkupContent.is(item.tooltip) && item.tooltip.kind == vscode_languageserver_types_1.MarkupKind.Markdown;
        let doc = {
            filetype: isMarkdown ? 'markdown' : 'txt',
            content: vscode_languageserver_types_1.MarkupContent.is(item.tooltip) ? item.tooltip.value : item.tooltip
        };
        await this.tooltipFactory.show([doc]);
    }
    async onClick(element) {
        let { nvim } = this;
        let [line, col] = await nvim.eval(`[getline('.'),col('.')]`);
        let pre = (0, string_1.byteSlice)(line, 0, col - 1);
        let character = line[pre.length];
        let { openedIcon, closedIcon } = this.config;
        if (/^\s*$/.test(pre) && [openedIcon, closedIcon].includes(character)) {
            await this.toggleExpand(element);
        }
        else {
            await this.invokeCommand(element);
        }
    }
    async invokeCommand(element) {
        let obj = this.nodesMap.get(element);
        if (!obj)
            return;
        this.selectItem(element);
        let item = obj.item;
        if (!item.command)
            item = await this.resolveItem(element, item);
        if (!item || !item.command)
            throw new Error(`Failed to resolve command from TreeItem.`);
        await commands_1.default.execute(item.command);
    }
    async invokeActions(element) {
        if (!element)
            return;
        this.selectItem(element);
        if (typeof this.provider.resolveActions !== 'function') {
            await window_1.default.showWarningMessage('No actions');
            return;
        }
        let obj = this.nodesMap.get(element);
        let actions = await Promise.resolve(this.provider.resolveActions(obj.item, element));
        if (!actions || actions.length == 0) {
            await window_1.default.showWarningMessage('No actions available');
            return;
        }
        let keys = actions.map(o => o.title);
        let res = await window_1.default.showMenuPicker(keys, 'Choose action');
        if (res == -1)
            return;
        await Promise.resolve(actions[res].handler(element));
    }
    async onDataChange(node) {
        if (this.filtering) {
            this.itemsToFilter = undefined;
            await this.doFilter((0, string_1.toText)(this.filterText));
            return;
        }
        this.clearSelection();
        if (!node) {
            await this.render();
            return;
        }
        let release = await this.mutex.acquire();
        try {
            let items = this.renderedItems;
            let idx = items.findIndex(o => o.node === node);
            if (idx != -1 && this.bufnr) {
                let obj = items[idx];
                let level = obj.level;
                let removeCount = 0;
                for (let i = idx; i < items.length; i++) {
                    let o = items[i];
                    if (i == idx || o && o.level > level) {
                        removeCount += 1;
                    }
                }
                let appendItems = [];
                let highlights = [];
                let start = idx + this.startLnum;
                await this.appendTreeNode(node, level, start, appendItems, highlights);
                items.splice(idx, removeCount, ...appendItems);
                this.updateUI(appendItems.map(o => o.line), highlights, start, start + removeCount);
            }
            release();
        }
        catch (e) {
            let errMsg = `Error on tree refresh: ${e}`;
            logger.error(errMsg, e);
            this.nvim.errWriteLine('[coc.nvim] ' + errMsg);
            release();
        }
    }
    async resolveItem(element, item) {
        if (typeof this.provider.resolveTreeItem === 'function') {
            let tokenSource = this.resolveTokenSource = new protocol_1.CancellationTokenSource();
            let token = tokenSource.token;
            item = await Promise.resolve(this.provider.resolveTreeItem(item, element, token));
            tokenSource.dispose();
            this.resolveTokenSource = undefined;
            if (token.isCancellationRequested)
                return undefined;
        }
        this.nodesMap.set(element, { item, resolved: true });
        return item;
    }
    get visible() {
        if (!this.bufnr)
            return false;
        return this.winid != null;
    }
    get valid() {
        return typeof this.bufnr === 'number';
    }
    get selection() {
        return this._selection.slice();
    }
    async checkLines() {
        if (!this.bufnr)
            return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let curr = await buf.lines;
        let { titleCount, messageCount } = this.lineState;
        curr = curr.slice(titleCount + messageCount);
        let lines = this.renderedItems.map(o => o.line);
        return (0, object_1.equals)(curr, lines);
    }
    /**
     * Expand/collapse TreeItem.
     */
    async toggleExpand(element) {
        let o = this.nodesMap.get(element);
        if (!o)
            return;
        let treeItem = o.item;
        let lnum = this.getItemLnum(element);
        let nodeIdx = lnum - this.startLnum;
        let obj = this.renderedItems[nodeIdx];
        if (!obj || treeItem.collapsibleState == TreeItem_1.TreeItemCollapsibleState.None) {
            if (typeof this.provider.getParent === 'function') {
                let node = await Promise.resolve(this.provider.getParent(element));
                if (node) {
                    await this.toggleExpand(node);
                    this.focusItem(node);
                }
            }
            return;
        }
        // remove lines
        let removeCount = 0;
        if (treeItem.collapsibleState == TreeItem_1.TreeItemCollapsibleState.Expanded) {
            let level = obj.level;
            for (let i = nodeIdx + 1; i < this.renderedItems.length; i++) {
                let o = this.renderedItems[i];
                if (!o || o.level <= level)
                    break;
                removeCount += 1;
            }
            treeItem.collapsibleState = TreeItem_1.TreeItemCollapsibleState.Collapsed;
        }
        else if (treeItem.collapsibleState == TreeItem_1.TreeItemCollapsibleState.Collapsed) {
            treeItem.collapsibleState = TreeItem_1.TreeItemCollapsibleState.Expanded;
        }
        let newItems = [];
        let newHighlights = [];
        await this.appendTreeNode(obj.node, obj.level, lnum, newItems, newHighlights);
        this.renderedItems.splice(nodeIdx, removeCount + 1, ...newItems);
        this.updateUI(newItems.map(o => o.line), newHighlights, lnum, lnum + removeCount + 1);
        this.refreshSigns();
        if (treeItem.collapsibleState == TreeItem_1.TreeItemCollapsibleState.Collapsed) {
            this._onDidCollapseElement.fire({ element });
        }
        else {
            this._onDidExpandElement.fire({ element });
        }
    }
    toggleSelection(element) {
        if (!element)
            return;
        let idx = this._selection.findIndex(o => o === element);
        if (idx !== -1) {
            this.unselectItem(idx);
        }
        else {
            this.selectItem(element);
        }
    }
    clearSelection() {
        if (!this.bufnr)
            return;
        this._selection = [];
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: 'CocTree' });
        this._onDidChangeSelection.fire({ selection: [] });
    }
    selectItem(item, forceSingle, noRedraw) {
        let { nvim } = this;
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr)
            return;
        let buf = nvim.createBuffer(this.bufnr);
        let exists = this._selection.includes(item);
        if (!this.opts.canSelectMany || forceSingle) {
            this._selection = [item];
        }
        else if (!exists) {
            this._selection.push(item);
        }
        nvim.pauseNotification();
        if (!this.opts.canSelectMany || forceSingle) {
            buf.unplaceSign({ group: 'CocTree' });
        }
        nvim.call('coc#compat#execute', [this.winid, `normal! ${row + 1}G`], true);
        buf.placeSign({ id: signOffset + row, lnum: row + 1, name: 'CocTreeSelected', group: 'CocTree' });
        if (!noRedraw)
            this.redraw();
        nvim.resumeNotification(false, true);
        if (!exists)
            this._onDidChangeSelection.fire({ selection: this._selection });
    }
    unselectItem(idx) {
        let item = this._selection[idx];
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr)
            return;
        this._selection.splice(idx, 1);
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: 'CocTree', id: signOffset + row });
        this._onDidChangeSelection.fire({ selection: this._selection });
    }
    focusItem(element) {
        if (!this.winid)
            return;
        let lnum = this.getItemLnum(element);
        if (lnum == null)
            return;
        this.nvim.call('coc#compat#execute', [this.winid, `exe ${lnum + 1}`], true);
    }
    getElementByLnum(lnum) {
        let item = this.renderedItems[lnum - this.startLnum];
        return item ? item.node : undefined;
    }
    getItemLnum(item) {
        let idx = this.renderedItems.findIndex(o => o.node === item);
        if (idx == -1)
            return undefined;
        return this.startLnum + idx;
    }
    async getTreeItem(element) {
        let exists;
        let resolved = false;
        let obj = this.nodesMap.get(element);
        if (obj != null) {
            exists = obj.item;
            resolved = obj.resolved;
        }
        let item = await Promise.resolve(this.provider.getTreeItem(element));
        if (exists
            && exists.collapsibleState != TreeItem_1.TreeItemCollapsibleState.None
            && item.collapsibleState != TreeItem_1.TreeItemCollapsibleState.None) {
            item.collapsibleState = exists.collapsibleState;
        }
        this.nodesMap.set(element, { item, resolved });
        return item;
    }
    getRenderedLine(treeItem, lnum, level) {
        let { openedIcon, closedIcon } = this.config;
        const highlights = [];
        const { label, deprecated, description } = treeItem;
        let prefix = '  '.repeat(level);
        const addHighlight = (text, hlGroup) => {
            let colStart = (0, string_1.byteLength)(prefix);
            highlights.push({
                lnum,
                hlGroup,
                colStart,
                colEnd: colStart + (0, string_1.byteLength)(text),
            });
        };
        switch (treeItem.collapsibleState) {
            case TreeItem_1.TreeItemCollapsibleState.Expanded: {
                addHighlight(openedIcon, 'CocTreeOpenClose');
                prefix += openedIcon + ' ';
                break;
            }
            case TreeItem_1.TreeItemCollapsibleState.Collapsed: {
                addHighlight(closedIcon, 'CocTreeOpenClose');
                prefix += closedIcon + ' ';
                break;
            }
            default:
                prefix += this.leafIndent ? '  ' : '';
        }
        if (treeItem.icon) {
            let { text, hlGroup } = treeItem.icon;
            addHighlight(text, hlGroup);
            prefix += text + ' ';
        }
        if (TreeItem_1.TreeItemLabel.is(label) && Array.isArray(label.highlights)) {
            let colStart = (0, string_1.byteLength)(prefix);
            for (let o of label.highlights) {
                highlights.push({
                    lnum,
                    hlGroup: 'CocSearch',
                    colStart: colStart + o[0],
                    colEnd: colStart + o[1]
                });
            }
        }
        let labelText = (0, TreeItem_1.getItemLabel)(treeItem);
        if (deprecated) {
            addHighlight(labelText, 'CocDeprecatedHighlight');
        }
        prefix += labelText;
        if (description && description.indexOf('\n') == -1) {
            prefix += ' ';
            addHighlight(description, 'CocTreeDescription');
            prefix += description;
        }
        return { line: prefix, highlights };
    }
    async appendTreeNode(element, level, lnum, items, highlights) {
        let takes = 1;
        let treeItem = await this.getTreeItem(element);
        let res = this.getRenderedLine(treeItem, lnum, level);
        highlights.push(...res.highlights);
        items.push({ level, line: res.line, node: element });
        if (treeItem.collapsibleState == TreeItem_1.TreeItemCollapsibleState.Expanded) {
            let l = level + 1;
            let children = await Promise.resolve(this.provider.getChildren(element));
            for (let el of (0, array_1.toArray)(children)) {
                let n = await this.appendTreeNode(el, l, lnum + takes, items, highlights);
                takes = takes + n;
            }
        }
        return takes;
    }
    updateUI(lines, highlights, start = 0, end = -1, noRedraw = false) {
        if (!this.bufnr)
            return;
        let { nvim, winid } = this;
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        buf.setOption('modifiable', true, true);
        void buf.setLines(lines, { start, end, strictIndexing: false }, true);
        if (this.autoWidth)
            this.nvim.call('coc#window#adjust_width', [winid], true);
        if (highlights.length) {
            let highlightEnd = end == -1 ? -1 : start + lines.length;
            nvim.call('coc#highlight#update_highlights', [this.bufnr, highlightNamespace, highlights, start, highlightEnd], true);
        }
        buf.setOption('modifiable', false, true);
        if (!noRedraw)
            this.redraw();
        nvim.resumeNotification(false, true);
    }
    async reveal(element, options = {}) {
        if (this.filtering)
            return;
        let isShown = this.getItemLnum(element) != null;
        let { select, focus, expand } = options;
        let curr = element;
        if (typeof this.provider.getParent !== 'function') {
            throw new Error('missing getParent function from provider for reveal.');
        }
        if (!isShown) {
            while (curr) {
                let parentNode = await Promise.resolve(this.provider.getParent(curr));
                if (parentNode) {
                    let item = await this.getTreeItem(parentNode);
                    item.collapsibleState = TreeItem_1.TreeItemCollapsibleState.Expanded;
                    curr = parentNode;
                }
                else {
                    break;
                }
            }
        }
        if (expand) {
            let item = await this.getTreeItem(element);
            // Unable to expand
            if (item.collapsibleState != TreeItem_1.TreeItemCollapsibleState.None) {
                item.collapsibleState = TreeItem_1.TreeItemCollapsibleState.Expanded;
                if (typeof expand === 'boolean')
                    expand = 1;
                if (expand > 1) {
                    let curr = Math.min(expand, 2);
                    let nodes = await Promise.resolve(this.provider.getChildren(element));
                    while (!(0, array_1.isFalsyOrEmpty)(nodes)) {
                        let arr = [];
                        for (let n of nodes) {
                            let item = await this.getTreeItem(n);
                            if (item.collapsibleState == TreeItem_1.TreeItemCollapsibleState.None)
                                continue;
                            item.collapsibleState = TreeItem_1.TreeItemCollapsibleState.Expanded;
                            if (curr > 1) {
                                let res = await Promise.resolve(this.provider.getChildren(n));
                                arr.push(...res);
                            }
                        }
                        nodes = arr;
                        curr = curr - 1;
                    }
                }
            }
        }
        if (!isShown || expand) {
            await this.render();
        }
        if (select !== false)
            this.selectItem(element);
        if (focus)
            this.focusItem(element);
    }
    updateHeadLines(initialize = false) {
        let { titleCount, messageCount } = this.lineState;
        let end = initialize ? -1 : titleCount + messageCount;
        let lines = [];
        let highlights = [];
        if (this.message) {
            highlights.push({ hlGroup: 'MoreMsg', colStart: 0, colEnd: (0, string_1.byteLength)(this.message), lnum: 0 });
            lines.push(this.message);
            lines.push('');
        }
        if (this.title) {
            highlights.push({ hlGroup: 'CocTreeTitle', colStart: 0, colEnd: (0, string_1.byteLength)(this.title), lnum: lines.length });
            if (this.description) {
                let colStart = (0, string_1.byteLength)(this.title) + 1;
                highlights.push({ hlGroup: 'Comment', colStart, colEnd: colStart + (0, string_1.byteLength)(this.description), lnum: lines.length });
            }
            lines.push(this.title + (this.description ? ' ' + this.description : ''));
        }
        this.lineState.messageCount = this.message ? 2 : 0;
        this.lineState.titleCount = this.title ? 1 : 0;
        this.updateUI(lines, highlights, 0, end);
        if (!initialize) {
            this.refreshSigns();
        }
    }
    /**
     * Update signs after collapse/expand or head change
     */
    refreshSigns() {
        let { selection, nvim, bufnr } = this;
        if (!selection.length || !bufnr)
            return;
        let buf = nvim.createBuffer(bufnr);
        nvim.pauseNotification();
        buf.unplaceSign({ group: 'CocTree' });
        for (let n of selection) {
            let row = this.getItemLnum(n);
            if (row == null)
                continue;
            buf.placeSign({ id: signOffset + row, lnum: row + 1, name: 'CocTreeSelected', group: 'CocTree' });
        }
        nvim.resumeNotification(false, true);
    }
    // Render all tree items
    async render() {
        if (!this.bufnr)
            return;
        let release = await this.mutex.acquire();
        try {
            let lines = [];
            let highlights = [];
            let { startLnum } = this;
            let nodes = await Promise.resolve(this.provider.getChildren());
            let level = 0;
            let lnum = startLnum;
            let renderedItems = [];
            if ((0, array_1.isFalsyOrEmpty)(nodes)) {
                this.message = 'No results';
            }
            else {
                if (this.message == 'No results')
                    this.message = '';
                for (let node of nodes) {
                    let n = await this.appendTreeNode(node, level, lnum, renderedItems, highlights);
                    lnum += n;
                }
            }
            lines.push(...renderedItems.map(o => o.line));
            this.renderedItems = renderedItems;
            let delta = this.startLnum - startLnum;
            highlights.forEach(o => o.lnum = o.lnum + delta);
            this.updateUI(lines, highlights, this.startLnum, -1);
            this._onDidRefrash.fire();
            this.retryTimers = 0;
            release();
        }
        catch (e) {
            this.renderedItems = [];
            this.nodesMap.clear();
            this.lineState = { titleCount: 0, messageCount: 1 };
            release();
            let errMsg = `${e}`.replace(/\r?\n/g, ' ');
            this.updateUI([errMsg], [{ hlGroup: 'WarningMsg', colStart: 0, colEnd: (0, string_1.byteLength)(errMsg), lnum: 0 }]);
            if (this.retryTimers == maxRetry)
                return;
            this.timer = setTimeout(() => {
                this.retryTimers = this.retryTimers + 1;
                void this.render();
            }, retryTimeout);
        }
    }
    async show(splitCommand = 'belowright 30vs', waitRender = true) {
        let { nvim } = this;
        let [targetBufnr, windowId] = await nvim.eval(`[bufnr("%"),win_getid()]`);
        this._targetBufnr = targetBufnr;
        this._targetWinId = windowId;
        let opts = {
            command: splitCommand,
            bufname: this.bufname,
            viewId: this.viewId.replace(/"/g, '\\"'),
            bufnr: (0, util_1.defaultValue)(this.bufnr, -1),
            winid: (0, util_1.defaultValue)(this.winid, -1),
            bufhidden: (0, util_1.defaultValue)(this.opts.bufhidden, 'wipe'),
            canSelectMany: this.opts.canSelectMany === true,
            winfixwidth: this.winfixwidth === true
        };
        let [bufnr, winid, tabId] = await nvim.call('coc#ui#create_tree', [opts]);
        this.bufnr = bufnr;
        this.winid = winid;
        this._targetTabId = tabId;
        if (winid != opts.winid)
            this._onDidChangeVisibility.fire({ visible: true });
        if (bufnr == opts.bufnr)
            return true;
        this.registerKeymaps();
        this.updateHeadLines(true);
        let promise = this.render();
        if (waitRender)
            await promise;
        return true;
    }
    registerLocalKeymap(mode, key, fn, notify = false) {
        if (!this.bufnr) {
            this._keymapDefs.push({ mode, key, fn, notify });
        }
        else {
            this.addLocalKeymap(mode, key, fn, notify);
        }
    }
    addLocalKeymap(mode, key, fn, notify = true) {
        if (!key)
            return;
        workspace_1.default.registerLocalKeymap(this.bufnr, mode, key, async () => {
            let lnum = await this.nvim.call('line', ['.']);
            let element = this.getElementByLnum(lnum - 1);
            await Promise.resolve(fn(element));
        }, notify);
    }
    registerKeymaps() {
        let { toggleSelection, actions, close, invoke, toggle, collapseAll, activeFilter } = this.keys;
        let { nvim, _keymapDefs } = this;
        this.disposables.push(workspace_1.default.registerLocalKeymap(this.bufnr, 'n', '<C-o>', () => {
            nvim.call('win_gotoid', [this._targetWinId], true);
        }, true));
        this.addLocalKeymap('n', '<LeftRelease>', async (element) => {
            if (element)
                await this.onClick(element);
        });
        this.filter && this.addLocalKeymap('n', activeFilter, async () => {
            this.nvim.command(`exe ${this.startLnum}`, true);
            this.filter.active();
            this.filterText = '';
            this._onDidFilterStateChange.fire(true);
        });
        this.addLocalKeymap('n', toggleSelection, element => this.toggleSelection(element));
        this.addLocalKeymap('n', invoke, element => this.invokeCommand(element));
        this.addLocalKeymap('n', actions, element => this.invokeActions(element));
        this.addLocalKeymap('n', toggle, element => this.toggleExpand(element));
        this.addLocalKeymap('n', collapseAll, () => this.collapseAll());
        this.addLocalKeymap('n', close, () => this.hide());
        while (_keymapDefs.length) {
            const def = _keymapDefs.pop();
            this.addLocalKeymap(def.mode, def.key, def.fn, def.notify);
        }
    }
    hide() {
        this.nvim.call('coc#window#close', [this.winid], true);
        this.redraw();
        this.winid = undefined;
        this._onDidChangeVisibility.fire({ visible: false });
    }
    redraw() {
        var _a;
        if (workspace_1.default.isVim || ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.activated)) {
            this.nvim.command('redraw', true);
        }
    }
    async collapseAll() {
        for (let obj of this.nodesMap.values()) {
            let item = obj.item;
            if (item.collapsibleState == TreeItem_1.TreeItemCollapsibleState.Expanded) {
                item.collapsibleState = TreeItem_1.TreeItemCollapsibleState.Collapsed;
            }
        }
        await this.render();
    }
    cancelResolve() {
        if (this.resolveTokenSource) {
            this.resolveTokenSource.cancel();
            this.resolveTokenSource = undefined;
        }
    }
    dispose() {
        var _a;
        if (!this.provider)
            return;
        if (this.timer)
            clearTimeout(this.timer);
        this.cancelResolve();
        let { bufnr } = this;
        if (this.winid)
            this._onDidChangeVisibility.fire({ visible: false });
        if (bufnr)
            this.nvim.command(`silent! bwipeout! ${bufnr}`, true);
        this._keymapDefs = [];
        this.winid = undefined;
        this.bufnr = undefined;
        (_a = this.filter) === null || _a === void 0 ? void 0 : _a.dispose();
        this._selection = [];
        this.itemsToFilter = [];
        this.tooltipFactory.dispose();
        this.renderedItems = [];
        this.nodesMap.clear();
        this.provider = undefined;
        this._onDispose.fire();
        this._onDispose.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = BasicTreeView;
//# sourceMappingURL=TreeView.js.map