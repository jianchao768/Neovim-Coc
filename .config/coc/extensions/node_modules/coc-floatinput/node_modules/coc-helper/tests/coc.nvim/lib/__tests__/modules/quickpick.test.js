"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const util_1 = require("../../util");
const events_1 = tslib_1.__importDefault(require("../../events"));
const window_1 = tslib_1.__importDefault(require("../../window"));
const quickpick_1 = tslib_1.__importDefault(require("../../model/quickpick"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
let ns;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    ns = await nvim.createNamespace('coc-input-box');
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    disposables = [];
});
async function getTitleLine() {
    let winids = await nvim.call('coc#float#get_float_win_list');
    let winid = Math.min(...winids);
    let id = await nvim.call('coc#float#get_related', [winid, 'border']);
    let win = nvim.createWindow(id);
    let buf = await win.buffer;
    let lines = await buf.lines;
    return lines[0];
}
describe('InputBox', () => {
    it('should request input', async () => {
        let winid = await nvim.call('win_getid');
        let p = window_1.default.requestInput('Name');
        await helper_1.default.waitFloat();
        await nvim.input('bar<enter>');
        let res = await p;
        let curr = await nvim.call('win_getid');
        expect(curr).toBe(winid);
        expect(res).toBe('bar');
    });
    it('should use input method of vim', async () => {
        helper_1.default.updateConfiguration('coc.preferences.promptInput', false);
        let defaultValue = 'default';
        let p = window_1.default.requestInput('Name', defaultValue);
        await helper_1.default.wait(50);
        await nvim.input('<enter>');
        let res = await p;
        expect(res).toBe(defaultValue);
    });
    it('should return empty string when input empty', async () => {
        let p = window_1.default.requestInput('Name');
        await helper_1.default.wait(30);
        await nvim.input('<enter>');
        let res = await p;
        expect(res).toBe('');
    });
    it('should emit change event', async () => {
        let input = await window_1.default.createInputBox('', '', {});
        disposables.push(input);
        let curr;
        input.onDidChange(text => {
            curr = text;
        });
        await nvim.input('abc');
        await helper_1.default.waitValue((() => {
            return curr;
        }), 'abc');
        input.title = 'foo';
        expect(input.title).toBe('foo');
        input.loading = true;
        expect(input.loading).toBe(true);
        input.borderhighlight = 'WarningMsg';
        expect(input.borderhighlight).toBe('WarningMsg');
    });
    it('should not check bufnr for events', async () => {
        let input = await window_1.default.createInputBox('', undefined, {});
        disposables.push(input);
        let bufnr = input.bufnr;
        let called = false;
        input.onDidChange(() => {
            called = true;
        });
        await events_1.default.fire('BufWinLeave', [bufnr + 1]);
        await events_1.default.fire('PromptInsert', ['', bufnr + 1]);
        await events_1.default.fire('TextChangedI', [bufnr + 1, {
                lnum: 1,
                col: 1,
                line: '',
                changedtick: 0,
                pre: ''
            }]);
        expect(called).toBe(false);
        expect(input.bufnr).toBeDefined();
        expect(input.dimension).toBeDefined();
    });
    it('should change input value', async () => {
        let input = await window_1.default.createInputBox('', undefined, {});
        disposables.push(input);
        let called = false;
        input.onDidChange(() => {
            called = true;
        });
        input.value = 'foo';
        await helper_1.default.waitValue(async () => {
            let lines = await nvim.call('getbufline', [input.bufnr, 1]);
            return lines[0];
        }, 'foo');
        expect(called).toBe(true);
        expect(input.value).toBe('foo');
    });
    it('should show and hide placeHolder', async () => {
        let input = await window_1.default.createInputBox('title', undefined, { placeHolder: 'placeHolder' });
        disposables.push(input);
        let buf = nvim.createBuffer(input.bufnr);
        let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
        expect(markers.length).toBe(1);
        let blocks = markers[0][3].virt_text;
        expect(blocks).toEqual([['placeHolder', 'CocInputBoxVirtualText']]);
        await nvim.input('a');
        await helper_1.default.waitValue(async () => {
            let markers = await buf.getExtMarks(ns, 0, -1, { details: true });
            return markers.length;
        }, 0);
    });
});
describe('QuickPick', () => {
    it('should not thrown when window not shown', async () => {
        let q = new quickpick_1.default(nvim);
        q.items = undefined;
        expect(q.winid).toBeUndefined();
        expect(q.activeItems).toEqual([]);
        q.title = 'title';
        expect(q.title).toBe('title');
        q.loading = true;
        expect(q.loading).toBe(true);
        q.value = 'value';
        expect(q.value).toBe('value');
        expect(q.buffer).toBeUndefined();
        expect(q.currIndex).toBe(0);
        q.setCursor(0);
        q.filterItems('a');
        q.showFilteredItems();
        q.toggePicked(0);
        q.dispose();
    });
    it('should show picker items on filter', async () => {
        let q = new quickpick_1.default(nvim, {});
        q.items = [{
                label: 'foo',
                picked: true
            }, {
                label: 'bar',
                picked: true
            }, {
                label: 'asdf',
                picked: false
            }];
        q.canSelectMany = true;
        await q.show();
        await nvim.input('f');
        await helper_1.default.waitValue(() => {
            return q.activeItems.length;
        }, 2);
        expect(q.value).toBe('f');
        expect(q.selectedItems.length).toBe(2);
        await nvim.input('<C-space>');
        await helper_1.default.waitValue(() => {
            return q.selectedItems.length;
        }, 1);
        q.showFilteredItems();
        await events_1.default.fire('BufWinLeave', [q.buffer.id]);
        q.dispose();
    });
});
describe('showQuickPick', () => {
    async function testQuickPick(items, canPickMany, cancel, res) {
        let p = window_1.default.showQuickPick(items, { canPickMany });
        await helper_1.default.waitFloat();
        await nvim.input('b');
        await nvim.input('<C-space>');
        await helper_1.default.wait(50);
        if (cancel) {
            await nvim.input('<esc>');
        }
        else {
            await nvim.input('<cr>');
        }
        let result = await p;
        if (res == null) {
            expect(result).toBe(res);
        }
        else {
            expect(res).toEqual(res);
        }
    }
    it('should resolve for empty list', async () => {
        let res = await window_1.default.showQuickPick([], { title: 'title' });
        expect(res).toBeUndefined();
    });
    it('should resolve undefined when token cancelled', async () => {
        let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        tokenSource.cancel();
        let res = await window_1.default.showQuickPick(['foo', 'bar'], undefined, token);
        expect(res).toBeUndefined();
        await helper_1.default.wait(20);
        tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        token = tokenSource.token;
        let p = window_1.default.showQuickPick(['foo', 'bar'], undefined, token);
        tokenSource.cancel();
        res = await p;
        expect(res).toBeUndefined();
    });
    it('should show quickfix with items or texts', async () => {
        await testQuickPick(['foo', 'bar'], false, false, 'bar');
        await testQuickPick(['foo', 'bar'], true, false, ['bar']);
        await testQuickPick(['foo', 'bar'], false, true, undefined);
        let items = [{ label: 'foo', description: 'desc' }, { label: 'bar', picked: true }];
        await testQuickPick(items, false, false, { label: 'bar', picked: true });
        await testQuickPick(items, true, false, [{ label: 'bar', picked: true }]);
    });
    it('should use title option', async () => {
        let p = window_1.default.showQuickPick(['foo', 'bar'], { title: 'title' });
        await helper_1.default.waitFloat();
        let line = await getTitleLine();
        expect(line).toMatch('title');
        await nvim.input('<esc>');
        await p;
    });
    it('should match on description', async () => {
        let items = [{ label: 'foo', description: 'desc' }, { label: 'bar', picked: true }];
        let p = window_1.default.showQuickPick(items, { matchOnDescription: true });
        await helper_1.default.waitFloat();
        await nvim.input('d');
        await helper_1.default.wait(10);
        await nvim.input('<cr>');
        let res = await p;
        expect(res).toBeDefined();
    });
});
describe('QuickPick configuration', () => {
    afterEach(() => {
        helper_1.default.workspace.configurations.reset();
    });
    it('should respect width of quickpick', async () => {
        helper_1.default.updateConfiguration('dialog.maxWidth', null);
        let quickpick = await window_1.default.createQuickPick();
        disposables.push(quickpick);
        quickpick.items = [{ label: 'foo' }, { label: 'bar' }];
        quickpick.width = 50;
        quickpick.value = '';
        await quickpick.show();
        let win = nvim.createWindow(quickpick.winid);
        let width = await win.width;
        expect(width).toBe(50);
    });
    it('should scroll by <C-f> and <C-b>', async () => {
        helper_1.default.updateConfiguration('dialog.maxHeight', 2);
        let quickpick = await window_1.default.createQuickPick();
        quickpick.value = '';
        quickpick.items = [{ label: 'one' }, { label: 'two' }, { label: 'three' }];
        disposables.push(quickpick);
        await quickpick.show();
        let winid = quickpick.winid;
        await nvim.input('<C-f>');
        await helper_1.default.wait(1);
        await nvim.input('<C-f>');
        await helper_1.default.waitValue(async () => {
            let info = await nvim.call('getwininfo', [winid]);
            return info[0].topline;
        }, 2);
        await nvim.input('<C-b>');
        await nvim.input('<C-x>');
        await helper_1.default.wait(1);
        await nvim.input('<C-b>');
        await helper_1.default.waitValue(async () => {
            let info = await nvim.call('getwininfo', [winid]);
            return info[0].topline;
        }, 1);
    });
    it('should respect configurations', async () => {
        helper_1.default.updateConfiguration('dialog.maxWidth', 30);
        helper_1.default.updateConfiguration('dialog.rounded', false);
        helper_1.default.updateConfiguration('dialog.floatHighlight', 'Normal');
        helper_1.default.updateConfiguration('dialog.floatBorderHighlight', 'Normal');
        helper_1.default.updateConfiguration('dialog.maxHeight', 2);
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }, { label: 'two' }, { label: 'three' }];
        await quickpick.show();
        let winids = await nvim.call('coc#float#get_float_win_list');
        let winid = Math.max(...winids);
        let win = nvim.createWindow(winid);
        let h = await win.height;
        expect(h).toBe(2);
        await nvim.input('<esc>');
    });
});
describe('createQuickPick', () => {
    it('should throw when unable to open input window', async () => {
        let fn = nvim.call;
        nvim.call = (...args) => {
            if (args[0] === 'coc#dialog#create_prompt_win')
                return undefined;
            return fn.apply(nvim, args);
        };
        disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            nvim.call = fn;
        }));
        let fun = async () => {
            let quickpick = await window_1.default.createQuickPick({
                items: [{ label: 'foo' }, { label: 'bar' }],
            });
            await quickpick.show();
        };
        await expect(fun()).rejects.toThrow(/Unable to open/);
    });
    it('should throw when unable to open list window', async () => {
        let fn = nvim.call;
        let spy = jest.spyOn(nvim, 'call').mockImplementation((...args) => {
            if (args[0] === 'coc#dialog#create_list')
                return undefined;
            return fn.apply(nvim, args);
        });
        let fun = async () => {
            let quickpick = await window_1.default.createQuickPick({
                items: [{ label: 'foo' }, { label: 'bar' }],
            });
            disposables.push(quickpick);
            await quickpick.show();
        };
        await expect(fun()).rejects.toThrow(/Unable to open/);
        spy.mockRestore();
        await nvim.call('feedkeys', [String.fromCharCode(27), 'in']);
    });
    it('should respect initial value', async () => {
        let q = await window_1.default.createQuickPick();
        q.items = [{ label: 'foo' }, { label: 'bar' }];
        q.value = 'value';
        await q.show();
        let winids = await nvim.call('coc#float#get_float_win_list');
        let winid = Math.min(...winids);
        let buf = await (nvim.createWindow(winid)).buffer;
        let lines = await buf.lines;
        expect(lines[0]).toBe('value');
        await nvim.input('<esc>');
    });
    it('should change current line by <C-j> and <C-k>', async () => {
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }, { label: 'two' }, { label: 'three' }];
        await quickpick.show();
        disposables.push(quickpick);
        await nvim.input('<C-j>');
        await helper_1.default.wait(1);
        await nvim.input('<C-j>');
        await helper_1.default.waitValue(() => {
            return quickpick.currIndex;
        }, 2);
        await nvim.input('<C-k>');
        await helper_1.default.wait(1);
        await nvim.input('<C-k>');
        await helper_1.default.waitValue(() => {
            return quickpick.currIndex;
        }, 0);
    });
    it('should toggle selected item by <C-space>', async () => {
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }, { label: 'two' }, { label: 'three' }];
        await quickpick.show();
        disposables.push(quickpick);
        await nvim.input('<C-sapce>');
        await helper_1.default.wait(10);
        await nvim.input('<C-k>');
        await helper_1.default.wait(10);
        await nvim.input('<C-sapce>');
        await helper_1.default.waitValue(() => {
            return quickpick.selectedItems.length;
        }, 0);
    });
    it('should not handle events from other buffer', async () => {
        let quickpick = await window_1.default.createQuickPick({
            items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],
        });
        await quickpick.show();
        disposables.push(quickpick);
        await events_1.default.fire('BufWinLeave', [quickpick.buffer.id + 1]);
        await events_1.default.fire('PromptKeyPress', [quickpick.buffer.id + 1, 'C-f']);
        expect(quickpick.currIndex).toBe(0);
    });
    it('should change title', async () => {
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }, { label: 'two' }];
        quickpick.title = 'from';
        disposables.push(quickpick);
        quickpick.title = 'to';
        expect(quickpick.title).toBe('to');
        await quickpick.show();
        let line = await getTitleLine();
        expect(line).toMatch(/to/);
    });
    it('should change loading', async () => {
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }, { label: 'two' }];
        disposables.push(quickpick);
        await quickpick.show();
        quickpick.loading = true;
        expect(quickpick.loading).toBe(true);
        quickpick.loading = false;
        expect(quickpick.loading).toBe(false);
    });
    it('should change items', async () => {
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }, { label: 'two' }];
        await quickpick.show();
        disposables.push(quickpick);
        quickpick.onDidChangeValue(val => {
            if (val == '>') {
                quickpick.items = [{ label: 'three' }];
            }
        });
        await nvim.input('>');
        await helper_1.default.waitValue(async () => {
            let lines = await quickpick.buffer.lines;
            return lines;
        }, ['three']);
    });
    it('should change activeItems', async () => {
        let quickpick = await window_1.default.createQuickPick();
        quickpick.items = [{ label: 'one' }];
        disposables.push(quickpick);
        await quickpick.show();
        quickpick.onDidChangeValue(val => {
            if (val == 'f') {
                quickpick.activeItems = [{ label: 'foo', description: 'description' }, { label: 'foot' }, { label: 'bar' }];
            }
        });
        await nvim.input('f');
        await helper_1.default.waitValue(async () => {
            let lines = await quickpick.buffer.lines;
            return lines;
        }, ['foo description', 'foot', 'bar']);
    });
});
//# sourceMappingURL=quickpick.test.js.map