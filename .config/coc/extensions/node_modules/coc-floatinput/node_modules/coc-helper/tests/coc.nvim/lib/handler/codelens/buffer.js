'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommands = exports.getTextAlign = exports.TextAlign = void 0;
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const logger_1 = require("../../logger");
const util_1 = require("../../util");
const array_1 = require("../../util/array");
const is_1 = require("../../util/is");
const node_1 = require("../../util/node");
const protocol_1 = require("../../util/protocol");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const util_2 = require("../util");
const logger = (0, logger_1.createLogger)('codelens-buffer');
var TextAlign;
(function (TextAlign) {
    TextAlign["After"] = "after";
    TextAlign["Right"] = "right";
    TextAlign["Below"] = "below";
    TextAlign["Above"] = "above";
})(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
let srcId;
const debounceTime = (0, util_1.getConditionValue)(200, 20);
const CODELENS_HL = 'CocCodeLens';
const NORMAL_HL = 'Normal';
/**
 * CodeLens buffer
 */
class CodeLensBuffer {
    constructor(nvim, document) {
        this.nvim = nvim;
        this.document = document;
        this.display = true;
        this.resolveCodeLens = (0, node_1.debounce)(() => {
            this._resolveCodeLenses().catch(util_2.handleError);
        }, debounceTime);
        this.debounceFetch = (0, node_1.debounce)(() => {
            this.fetchCodeLenses().catch(util_2.handleError);
        }, debounceTime);
        if (this.hasProvider)
            this.debounceFetch();
    }
    get config() {
        if (this._config)
            return this._config;
        this.loadConfiguration();
        return this._config;
    }
    loadConfiguration() {
        let config = workspace_1.default.getConfiguration('codeLens', this.document);
        this._config = {
            enabled: config.get('enable', false),
            position: config.get('position', 'top'),
            separator: config.get('separator', ''),
            subseparator: config.get('subseparator', ' ')
        };
    }
    async toggleDisplay() {
        if (this.display) {
            this.display = false;
            this.clear();
        }
        else {
            this.display = true;
            this.resolveCodeLens.clear();
            await this._resolveCodeLenses();
        }
    }
    get bufnr() {
        return this.document.bufnr;
    }
    onChange(e) {
        if (e.contentChanges.length === 0 && this.codeLenses != null) {
            this.resolveCodeLens.clear();
            this._resolveCodeLenses().catch(util_2.handleError);
        }
        else {
            this.cancel();
            this.debounceFetch();
        }
    }
    get currentCodeLens() {
        var _a;
        return (_a = this.codeLenses) === null || _a === void 0 ? void 0 : _a.codeLenses;
    }
    get hasProvider() {
        return languages_1.default.hasProvider(languages_1.ProviderName.CodeLens, this.document);
    }
    async forceFetch() {
        if (!this.config.enabled || !this.hasProvider)
            return;
        await this.document.synchronize();
        this.cancel();
        await this.fetchCodeLenses();
    }
    async fetchCodeLenses() {
        var _a;
        if (!this.hasProvider || !this.config.enabled)
            return;
        let noFetch = ((_a = this.codeLenses) === null || _a === void 0 ? void 0 : _a.version) == this.document.version;
        if (!noFetch) {
            let empty = this.codeLenses == null;
            let { textDocument } = this.document;
            let version = textDocument.version;
            this.cancelFetch();
            let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
            let token = tokenSource.token;
            if (!srcId)
                srcId = await this.nvim.createNamespace('coc-codelens');
            let codeLenses = await languages_1.default.getCodeLens(textDocument, token);
            if (token.isCancellationRequested)
                return;
            codeLenses = (0, util_1.defaultValue)(codeLenses, []);
            codeLenses = codeLenses.filter(o => o != null);
            if ((0, array_1.isFalsyOrEmpty)(codeLenses)) {
                this.clear();
                return;
            }
            this.codeLenses = { version, codeLenses };
            if (empty)
                this.setVirtualText(codeLenses);
        }
        this.resolveCodeLens.clear();
        await this._resolveCodeLenses();
    }
    /**
     * Resolve visible codeLens
     */
    async _resolveCodeLenses() {
        if (!this.codeLenses || this.isChanged)
            return;
        let { codeLenses } = this.codeLenses;
        let [bufnr, start, end, total] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$'),line('$')]`);
        // only resolve current buffer
        if (this.isChanged || bufnr != this.bufnr)
            return;
        this.cancel();
        codeLenses = codeLenses.filter(o => {
            let lnum = o.range.start.line + 1;
            return lnum >= start && lnum <= end;
        });
        if (codeLenses.length) {
            let tokenSource = this.resolveTokenSource = new protocol_1.CancellationTokenSource();
            let token = tokenSource.token;
            await Promise.all(codeLenses.map(codeLens => {
                if ((0, is_1.isCommand)(codeLens.command))
                    return Promise.resolve();
                codeLens.command = undefined;
                return languages_1.default.resolveCodeLens(codeLens, token);
            }));
            this.resolveTokenSource = undefined;
            if (token.isCancellationRequested || this.isChanged)
                return;
        }
        // nvim could have extmarks exceeded last line.
        if (end == total)
            end = -1;
        this.nvim.pauseNotification();
        this.clear(start - 1, end);
        this.setVirtualText(codeLenses);
        this.nvim.resumeNotification(true, true);
    }
    get isChanged() {
        if (!this.codeLenses || this.document.dirty)
            return true;
        let { version } = this.codeLenses;
        return this.document.textDocument.version !== version;
    }
    /**
     * Attach resolved codeLens
     */
    setVirtualText(codeLenses) {
        var _a;
        let { document } = this;
        if (!srcId || !document || !codeLenses.length || !this.display)
            return;
        let top = this.config.position === 'top';
        let list = new Map();
        for (let codeLens of codeLenses) {
            let { line } = codeLens.range.start;
            let curr = (_a = list.get(line)) !== null && _a !== void 0 ? _a : [];
            curr.push(codeLens);
            list.set(line, curr);
        }
        for (let lnum of list.keys()) {
            let codeLenses = list.get(lnum);
            let commands = codeLenses.reduce((p, c) => {
                if (c && c.command && c.command.title)
                    p.push(c.command.title.replace(/\s+/g, ' '));
                return p;
            }, []);
            let chunks = [];
            let len = commands.length;
            for (let i = 0; i < len; i++) {
                let title = commands[i];
                chunks.push([title, CODELENS_HL]);
                if (i != len - 1) {
                    chunks.push([this.config.subseparator, CODELENS_HL]);
                }
            }
            if (chunks.length > 0 && this.config.separator) {
                chunks.unshift([`${this.config.separator} `, CODELENS_HL]);
            }
            if (top && chunks.length == 0) {
                chunks.push([' ', NORMAL_HL]);
            }
            if (chunks.length > 0) {
                document.buffer.setVirtualText(srcId, lnum, chunks, {
                    text_align: getTextAlign(this.config.position),
                    indent: true
                });
            }
        }
    }
    clear(start = 0, end = -1) {
        if (!srcId)
            return;
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.clearNamespace(srcId, start, end);
    }
    async doAction(line) {
        var _a;
        let commands = getCommands(line, (_a = this.codeLenses) === null || _a === void 0 ? void 0 : _a.codeLenses);
        if (commands.length == 1) {
            await commands_1.default.execute(commands[0]);
        }
        else if (commands.length > 1) {
            let res = await window_1.default.showMenuPicker(commands.map(c => c.title));
            if (res != -1)
                await commands_1.default.execute(commands[res]);
        }
    }
    cancelFetch() {
        this.debounceFetch.clear();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    cancelResolve() {
        if (this.resolveTokenSource) {
            this.resolveTokenSource.cancel();
            this.resolveTokenSource = null;
        }
    }
    cancel() {
        this.resolveCodeLens.clear();
        this.cancelResolve();
        this.cancelFetch();
    }
    abandonResult() {
        this.codeLenses = undefined;
    }
    dispose() {
        this.cancel();
        this.codeLenses = undefined;
    }
}
exports.default = CodeLensBuffer;
function getTextAlign(position) {
    if (position == 'top')
        return TextAlign.Above;
    if (position == 'eol')
        return TextAlign.After;
    if (position === 'right_align')
        return TextAlign.Right;
    return TextAlign.Above;
}
exports.getTextAlign = getTextAlign;
function getCommands(line, codeLenses) {
    if (!(codeLenses === null || codeLenses === void 0 ? void 0 : codeLenses.length))
        return [];
    let commands = [];
    for (let codeLens of codeLenses) {
        let { range, command } = codeLens;
        if (!(0, is_1.isCommand)(command))
            continue;
        if (line == range.start.line) {
            commands.push(command);
        }
    }
    return commands;
}
exports.getCommands = getCommands;
//# sourceMappingURL=buffer.js.map