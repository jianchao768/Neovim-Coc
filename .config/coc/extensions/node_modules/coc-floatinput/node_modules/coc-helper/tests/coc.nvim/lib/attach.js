'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.pathReplace = void 0;
const tslib_1 = require("tslib");
const neovim_1 = require("@chemzqm/neovim");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("./events"));
const logger_1 = require("./logger");
const plugin_1 = tslib_1.__importDefault(require("./plugin"));
const constants_1 = require("./util/constants");
const is_1 = require("./util/is");
const node_1 = require("./util/node");
const string_1 = require("./util/string");
const timing_1 = require("./util/timing");
const logger = (0, logger_1.createLogger)('attach');
/**
 * Request actions that not need plugin ready
 */
const ACTIONS_NO_WAIT = ['installExtensions', 'updateExtensions'];
const semVer = node_1.semver.parse(constants_1.VERSION);
let pendingNotifications = [];
function pathReplace(patterns) {
    if ((0, is_1.objectLiteral)(patterns)) {
        const old_uri = vscode_uri_1.URI.file;
        vscode_uri_1.URI.file = (path) => {
            path = path.replace(/\\/g, '/');
            Object.keys(patterns).forEach(k => path = path.replace(new RegExp('^' + k), patterns[k]));
            return old_uri(path);
        };
    }
}
exports.pathReplace = pathReplace;
exports.default = (opts, requestApi = false) => {
    const nvim = (0, neovim_1.attach)(opts, (0, logger_1.createLogger)('node-client'), requestApi);
    nvim.setVar('coc_process_pid', process.pid, true);
    nvim.setClientInfo('coc', { major: semVer.major, minor: semVer.minor, patch: semVer.patch }, 'remote', {}, {});
    const plugin = new plugin_1.default(nvim);
    let disposable = events_1.default.on('ready', () => {
        disposable.dispose();
        for (let [method, args] of pendingNotifications) {
            plugin.cocAction(method, ...args).catch(e => {
                console.error(`Error on notification "${method}": ${e}`);
                logger.error(`Error on notification ${method}`, e);
            });
        }
        pendingNotifications = [];
    });
    nvim.on('notification', async (method, args) => {
        switch (method) {
            case 'VimEnter': {
                pathReplace(args[0]);
                await plugin.init(args[1]);
                break;
            }
            case 'Log': {
                logger.debug('Vim log', ...args);
                break;
            }
            case 'TaskExit':
            case 'TaskStderr':
            case 'TaskStdout':
            case 'GlobalChange':
            case 'PromptInsert':
            case 'InputChar':
            case 'MenuInput':
            case 'OptionSet':
            case 'PromptKeyPress':
            case 'FloatBtnClick':
            case 'CompleteStop':
            case 'PumInsert':
                logger.trace('Event: ', method, ...args);
                await events_1.default.fire(method, args);
                break;
            case 'CocAutocmd':
                logger.trace('Notification autocmd:', ...args);
                await events_1.default.fire(args[0], args.slice(1));
                break;
            case 'redraw':
                break;
            default: {
                try {
                    logger.info('receive notification:', method, args);
                    if (!plugin.isReady) {
                        pendingNotifications.push([method, args]);
                        return;
                    }
                    await plugin.cocAction(method, ...args);
                }
                catch (e) {
                    console.error(`Error on notification "${method}": ${(0, string_1.toErrorText)(e)}`);
                    logger.error(`Error on notification ${method}`, e);
                }
            }
        }
    });
    let timing = (0, timing_1.createTiming)('Request', 3000);
    nvim.on('request', async (method, args, resp) => {
        timing.start(method);
        try {
            events_1.default.requesting = true;
            if (method == 'CocAutocmd') {
                logger.trace('Request autocmd:', ...args);
                await events_1.default.fire(args[0], args.slice(1));
                resp.send(undefined);
            }
            else {
                if (!plugin.isReady && !ACTIONS_NO_WAIT.includes(method)) {
                    logger.warn(`Plugin not ready on request "${method}"`, args);
                    resp.send('Plugin not ready', true);
                }
                else {
                    logger.info('Request action:', method, args);
                    let res = await plugin.cocAction(method, ...args);
                    resp.send(res);
                }
            }
            events_1.default.requesting = false;
        }
        catch (e) {
            events_1.default.requesting = false;
            resp.send((0, string_1.toErrorText)(e), true);
            logger.error(`Request error:`, method, args, e);
        }
        timing.stop();
    });
    return plugin;
};
//# sourceMappingURL=attach.js.map