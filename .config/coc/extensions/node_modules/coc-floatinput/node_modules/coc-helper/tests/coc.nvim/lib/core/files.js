'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const logger_1 = require("../logger");
const editInspect_1 = tslib_1.__importDefault(require("../model/editInspect"));
const errors = tslib_1.__importStar(require("../util/errors"));
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const textedit_1 = require("../util/textedit");
const logger = (0, logger_1.createLogger)('core-files');
class Files {
    constructor(documents, configurations, workspaceFolderControl, keymaps) {
        this.documents = documents;
        this.configurations = configurations;
        this.workspaceFolderControl = workspaceFolderControl;
        this.keymaps = keymaps;
        this.operationTimeout = 500;
        this._onDidCreateFiles = new protocol_1.Emitter();
        this._onDidRenameFiles = new protocol_1.Emitter();
        this._onDidDeleteFiles = new protocol_1.Emitter();
        this._onWillCreateFiles = new protocol_1.Emitter();
        this._onWillRenameFiles = new protocol_1.Emitter();
        this._onWillDeleteFiles = new protocol_1.Emitter();
        this.onDidCreateFiles = this._onDidCreateFiles.event;
        this.onDidRenameFiles = this._onDidRenameFiles.event;
        this.onDidDeleteFiles = this._onDidDeleteFiles.event;
        this.onWillCreateFiles = this._onWillCreateFiles.event;
        this.onWillRenameFiles = this._onWillRenameFiles.event;
        this.onWillDeleteFiles = this._onWillDeleteFiles.event;
    }
    attach(nvim, env, window) {
        this.nvim = nvim;
        this.env = env;
        this.window = window;
    }
    async openTextDocument(uri) {
        uri = typeof uri === 'string' ? vscode_uri_1.URI.file(uri) : uri;
        let doc = this.documents.getDocument(uri.toString());
        if (doc) {
            await this.jumpTo(uri, null, 'drop');
            return doc;
        }
        const scheme = uri.scheme;
        if (scheme == 'file') {
            if (!node_1.fs.existsSync(uri.fsPath))
                throw errors.fileNotExists(uri.fsPath);
            node_1.fs.accessSync(uri.fsPath, node_1.fs.constants.R_OK);
        }
        if (scheme == 'untitled') {
            await this.nvim.call('coc#util#open_file', ['tab drop', uri.path]);
            return await this.documents.document;
        }
        return await this.loadResource(uri.toString());
    }
    async jumpTo(uri, position, openCommand) {
        if (!openCommand)
            openCommand = this.configurations.initialConfiguration.get('coc.preferences.jumpCommand', 'edit');
        let { nvim } = this;
        let u = uri instanceof vscode_uri_1.URI ? uri : vscode_uri_1.URI.parse(uri);
        let doc = this.documents.getDocument(u.with({ fragment: '' }).toString());
        let bufnr = doc ? doc.bufnr : -1;
        if (!position && u.scheme === 'file' && u.fragment) {
            let parts = u.fragment.split(',');
            let lnum = parseInt(parts[0], 10);
            if (!isNaN(lnum)) {
                let col = parts.length > 0 && /^\d+$/.test(parts[1]) ? parseInt(parts[1], 10) : undefined;
                position = vscode_languageserver_types_1.Position.create(lnum - 1, col == null ? 0 : col - 1);
            }
        }
        if (bufnr != -1 && openCommand == 'edit') {
            // use buffer command since edit command would reload the buffer
            nvim.pauseNotification();
            nvim.command(`silent! normal! m'`, true);
            nvim.command(`buffer ${bufnr}`, true);
            nvim.command(`if &filetype ==# '' | filetype detect | endif`, true);
            if (position) {
                let line = doc.getline(position.line);
                let col = (0, string_1.byteIndex)(line, position.character) + 1;
                nvim.call('cursor', [position.line + 1, col], true);
            }
            await nvim.resumeNotification(true);
        }
        else {
            let { fsPath, scheme } = u;
            let pos = position == null ? null : [position.line, position.character];
            if (scheme == 'file') {
                let bufname = (0, fs_1.normalizeFilePath)(fsPath);
                await this.nvim.call('coc#util#jump', [openCommand, bufname, pos]);
            }
            else {
                await this.nvim.call('coc#util#jump', [openCommand, uri.toString(), pos]);
            }
        }
    }
    /**
     * Open resource by uri
     */
    async openResource(uri) {
        let { nvim } = this;
        let u = vscode_uri_1.URI.parse(uri);
        if (/^https?/.test(u.scheme)) {
            await nvim.call('coc#ui#open_url', uri);
            return;
        }
        await this.jumpTo(uri);
        await this.documents.document;
    }
    /**
     * Load uri as document.
     */
    async loadResource(uri, cmd) {
        let doc = this.documents.getDocument(uri);
        if (doc)
            return doc;
        if (!cmd) {
            const preferences = this.configurations.getConfiguration('workspace');
            cmd = preferences.get('openResourceCommand', 'tab drop');
        }
        let u = vscode_uri_1.URI.parse(uri);
        let bufname = u.scheme === 'file' ? u.fsPath : uri;
        let bufnr;
        if (cmd) {
            let winid = await this.nvim.call('win_getid');
            bufnr = await this.nvim.call('coc#util#open_file', [cmd, bufname]);
            await this.nvim.call('win_gotoid', [winid]);
        }
        else {
            let arr = await this.nvim.call('coc#ui#open_files', [[bufname]]);
            bufnr = arr[0];
        }
        return await this.documents.createDocument(bufnr);
    }
    /**
     * Load the files that not loaded
     */
    async loadResources(uris) {
        let { documents } = this;
        let files = uris.map(uri => {
            let u = vscode_uri_1.URI.parse(uri);
            return u.scheme == 'file' ? u.fsPath : uri;
        });
        let bufnrs = await this.nvim.call('coc#ui#open_files', [files]);
        return await Promise.all(bufnrs.map(bufnr => {
            return documents.createDocument(bufnr);
        }));
    }
    /**
     * Create a file in vim and disk
     */
    async createFile(filepath, opts = {}, recovers) {
        let { nvim } = this;
        let exists = node_1.fs.existsSync(filepath);
        if (exists && !opts.overwrite && !opts.ignoreIfExists) {
            throw errors.fileExists(filepath);
        }
        if (!exists || opts.overwrite) {
            let tokenSource = new protocol_1.CancellationTokenSource();
            await this.fireWaitUntilEvent(this._onWillCreateFiles, {
                files: [vscode_uri_1.URI.file(filepath)],
                token: tokenSource.token
            }, recovers);
            tokenSource.cancel();
            let dir = node_1.path.dirname(filepath);
            if (!node_1.fs.existsSync(dir)) {
                let folder;
                let curr = dir;
                while (!['.', '/', node_1.path.parse(dir).root].includes(curr)) {
                    if (node_1.fs.existsSync(node_1.path.dirname(curr))) {
                        folder = curr;
                        break;
                    }
                    curr = node_1.path.dirname(curr);
                }
                node_1.fs.mkdirSync(dir, { recursive: true });
                recovers && recovers.push(() => {
                    node_1.fs.rmSync(folder, { force: true, recursive: true });
                });
            }
            node_1.fs.writeFileSync(filepath, '', 'utf8');
            recovers && recovers.push(() => {
                node_1.fs.rmSync(filepath, { force: true, recursive: true });
            });
            let doc = await this.loadResource(filepath);
            let bufnr = doc.bufnr;
            recovers && recovers.push(() => {
                void events_1.default.fire('BufUnload', [bufnr]);
                return nvim.command(`silent! bd! ${bufnr}`);
            });
            this._onDidCreateFiles.fire({ files: [vscode_uri_1.URI.file(filepath)] });
        }
    }
    /**
     * Delete a file or folder from vim and disk.
     */
    async deleteFile(filepath, opts = {}, recovers) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await (0, fs_1.statAsync)(filepath);
        let isDir = stat && stat.isDirectory();
        if (!stat && !ignoreIfNotExists) {
            throw errors.fileNotExists(filepath);
        }
        if (stat == null)
            return;
        let uri = vscode_uri_1.URI.file(filepath);
        await this.fireWaitUntilEvent(this._onWillDeleteFiles, { files: [uri] }, recovers);
        if (!isDir) {
            let bufnr = await this.nvim.call('bufnr', [filepath]);
            if (bufnr) {
                void events_1.default.fire('BufUnload', [bufnr]);
                await this.nvim.command(`silent! bwipeout ${bufnr}`);
                recovers && recovers.push(() => {
                    return this.loadResource(uri.toString());
                });
            }
        }
        let folder = node_1.path.join(node_1.os.tmpdir(), 'coc-' + process.pid);
        node_1.fs.mkdirSync(folder, { recursive: true });
        let md5 = node_1.crypto.createHash('md5').update(filepath).digest('hex');
        if (isDir && recursive) {
            let dest = node_1.path.join(folder, md5);
            let dir = node_1.path.dirname(filepath);
            node_1.fs.renameSync(filepath, dest);
            recovers && recovers.push(async () => {
                node_1.fs.mkdirSync(dir, { recursive: true });
                node_1.fs.renameSync(dest, filepath);
            });
        }
        else if (isDir) {
            node_1.fs.rmdirSync(filepath);
            recovers && recovers.push(() => {
                node_1.fs.mkdirSync(filepath);
            });
        }
        else {
            let dest = node_1.path.join(folder, md5);
            let dir = node_1.path.dirname(filepath);
            node_1.fs.renameSync(filepath, dest);
            recovers && recovers.push(() => {
                node_1.fs.mkdirSync(dir, { recursive: true });
                node_1.fs.renameSync(dest, filepath);
            });
        }
        this._onDidDeleteFiles.fire({ files: [uri] });
    }
    /**
     * Rename a file or folder on vim and disk
     */
    async renameFile(oldPath, newPath, opts = {}, recovers) {
        let { nvim } = this;
        let { overwrite, ignoreIfExists } = opts;
        if (newPath === oldPath)
            return;
        let exists = node_1.fs.existsSync(newPath);
        if (exists && ignoreIfExists && !overwrite)
            return;
        if (exists && !overwrite)
            throw errors.fileExists(newPath);
        let oldStat = await (0, fs_1.statAsync)(oldPath);
        let loaded = (oldStat && oldStat.isDirectory()) ? 0 : await nvim.call('bufloaded', [oldPath]);
        if (!loaded && !oldStat)
            throw errors.fileNotExists(oldPath);
        let file = { newUri: vscode_uri_1.URI.parse(newPath), oldUri: vscode_uri_1.URI.parse(oldPath) };
        if (!opts.skipEvent)
            await this.fireWaitUntilEvent(this._onWillRenameFiles, { files: [file] }, recovers);
        if (loaded) {
            let bufnr = await nvim.call('coc#ui#rename_file', [oldPath, newPath, oldStat != null]);
            await this.documents.onBufCreate(bufnr);
        }
        else {
            if (oldStat.isDirectory()) {
                for (let doc of this.documents.attached('file')) {
                    let u = vscode_uri_1.URI.parse(doc.uri);
                    if ((0, fs_1.isParentFolder)(oldPath, u.fsPath, false)) {
                        let filepath = u.fsPath.replace(oldPath, newPath);
                        let bufnr = await nvim.call('coc#ui#rename_file', [u.fsPath, filepath, false]);
                        await this.documents.onBufCreate(bufnr);
                    }
                }
            }
            node_1.fs.renameSync(oldPath, newPath);
        }
        recovers && recovers.push(() => {
            return this.renameFile(newPath, oldPath, { skipEvent: true });
        });
        if (!opts.skipEvent)
            this._onDidRenameFiles.fire({ files: [file] });
    }
    /**
     * Return denied annotations
     */
    async promptAnotations(documentChanges, changeAnnotations) {
        let toConfirm = changeAnnotations ? (0, textedit_1.getConfirmAnnotations)(documentChanges, changeAnnotations) : [];
        let denied = [];
        for (let key of toConfirm) {
            let annotation = changeAnnotations[key];
            let res = await this.window.showMenuPicker(['Yes', 'No'], {
                position: 'center',
                title: 'Confirm edits',
                content: annotation.label + (annotation.description ? ' ' + annotation.description : '')
            });
            if (res !== 0)
                denied.push(key);
        }
        return denied;
    }
    /**
     * Apply WorkspaceEdit.
     */
    async applyEdit(edit, nested) {
        let documentChanges = (0, textedit_1.toDocumentChanges)(edit);
        let recovers = [];
        let currentOnly = false;
        try {
            let denied = await this.promptAnotations(documentChanges, edit.changeAnnotations);
            if (denied.length > 0)
                documentChanges = (0, textedit_1.createFilteredChanges)(documentChanges, denied);
            let changes = {};
            let currentUri = await this.documents.getCurrentUri();
            currentOnly = documentChanges.every(o => vscode_languageserver_types_1.TextDocumentEdit.is(o) && o.textDocument.uri === currentUri);
            this.validateChanges(documentChanges);
            for (const change of documentChanges) {
                if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
                    let { textDocument, edits } = change;
                    let { uri } = textDocument;
                    let doc = await this.loadResource(uri);
                    let revertEdit = await doc.applyEdits(edits, false, uri === currentUri);
                    if (revertEdit) {
                        let version = doc.version;
                        let { newText, range } = revertEdit;
                        changes[uri] = {
                            uri,
                            lnum: range.start.line + 1,
                            newLines: doc.getLines(range.start.line, range.end.line),
                            oldLines: newText.endsWith('\n') ? newText.slice(0, -1).split('\n') : newText.split('\n')
                        };
                        recovers.push(async () => {
                            let doc = this.documents.getDocument(uri);
                            if (!doc || !doc.attached || doc.version !== version)
                                return;
                            await doc.applyEdits([revertEdit]);
                            textDocument.version = doc.version;
                        });
                    }
                }
                else if (vscode_languageserver_types_1.CreateFile.is(change)) {
                    await this.createFile(fsPath(change.uri), change.options, recovers);
                }
                else if (vscode_languageserver_types_1.DeleteFile.is(change)) {
                    await this.deleteFile(fsPath(change.uri), change.options, recovers);
                }
                else if (vscode_languageserver_types_1.RenameFile.is(change)) {
                    await this.renameFile(fsPath(change.oldUri), fsPath(change.newUri), change.options, recovers);
                }
            }
            // nothing changed
            if (recovers.length === 0)
                return true;
            if (!nested)
                this.editState = { edit: { documentChanges, changeAnnotations: edit.changeAnnotations }, changes, recovers, applied: true };
            this.nvim.redrawVim();
        }
        catch (e) {
            logger.error('Error on applyEdits:', edit, e);
            if (!nested)
                void this.window.showErrorMessage(`Error on applyEdits: ${e}`);
            await this.undoChanges(recovers);
            return false;
        }
        // avoid message when change current file only.
        if (nested || currentOnly)
            return true;
        void this.window.showInformationMessage(`Use ':wa' to save changes or ':CocCommand workspace.inspectEdit' to inspect.`);
        return true;
    }
    async undoChanges(recovers) {
        while (recovers.length > 0) {
            let fn = recovers.pop();
            await Promise.resolve(fn());
        }
    }
    async inspectEdit() {
        if (!this.editState) {
            void this.window.showWarningMessage('No workspace edit to inspect');
            return;
        }
        let inspect = new editInspect_1.default(this.nvim, this.keymaps);
        await inspect.show(this.editState);
    }
    async undoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || !editState.applied) {
            void this.window.showWarningMessage(`No workspace edit to undo`);
            return;
        }
        editState.applied = false;
        await this.undoChanges(editState.recovers);
    }
    async redoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || editState.applied) {
            void this.window.showWarningMessage(`No workspace edit to redo`);
            return;
        }
        this.editState = undefined;
        await this.applyEdit(editState.edit);
    }
    validateChanges(documentChanges) {
        let { documents } = this;
        for (let change of documentChanges) {
            if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
                let { uri, version } = change.textDocument;
                let doc = documents.getDocument(uri);
                if (typeof version === 'number' && version > 0) {
                    if (!doc)
                        throw errors.notLoaded(uri);
                    if (doc.version != version)
                        throw new Error(`${uri} changed before apply edit`);
                }
                else if (!doc && !(0, fs_1.isFile)(uri)) {
                    throw errors.badScheme(uri);
                }
            }
            else if (vscode_languageserver_types_1.CreateFile.is(change) || vscode_languageserver_types_1.DeleteFile.is(change)) {
                if (!(0, fs_1.isFile)(change.uri))
                    throw errors.badScheme(change.uri);
            }
            else if (vscode_languageserver_types_1.RenameFile.is(change)) {
                if (!(0, fs_1.isFile)(change.oldUri) || !(0, fs_1.isFile)(change.newUri)) {
                    throw errors.badScheme(change.oldUri);
                }
            }
        }
    }
    async findFiles(include, exclude, maxResults, token) {
        let folders = this.workspaceFolderControl.workspaceFolders;
        if ((token === null || token === void 0 ? void 0 : token.isCancellationRequested) || !folders.length || maxResults === 0)
            return [];
        maxResults = maxResults !== null && maxResults !== void 0 ? maxResults : Infinity;
        let roots = folders.map(o => vscode_uri_1.URI.parse(o.uri).fsPath);
        let pattern;
        if (typeof include !== 'string') {
            pattern = include.pattern;
            roots = [include.baseUri.fsPath];
        }
        else {
            pattern = include;
        }
        let res = [];
        let exceed = false;
        for (let root of roots) {
            let files = await (0, node_1.promisify)(node_1.glob)(pattern, {
                dot: true,
                cwd: root,
                nodir: true,
                absolute: false
            });
            if (token === null || token === void 0 ? void 0 : token.isCancellationRequested)
                return [];
            for (let file of files) {
                if (exclude && fileMatch(root, file, exclude))
                    continue;
                res.push(vscode_uri_1.URI.file(node_1.path.join(root, file)));
                if (res.length === maxResults) {
                    exceed = true;
                    break;
                }
            }
            if (exceed)
                break;
        }
        return res;
    }
    async fireWaitUntilEvent(emitter, properties, recovers) {
        let firing = true;
        let promises = [];
        emitter.fire(Object.assign(Object.assign({}, properties), { waitUntil: thenable => {
                if (!firing)
                    throw errors.shouldNotAsync('waitUntil');
                let tp = new Promise(resolve => {
                    setTimeout(resolve, this.operationTimeout);
                });
                let promise = Promise.race([thenable, tp]).then(edit => {
                    if (edit && vscode_languageserver_types_1.WorkspaceEdit.is(edit)) {
                        return this.applyEdit(edit, true);
                    }
                });
                promises.push(promise);
            } }));
        firing = false;
        await Promise.all(promises);
    }
}
exports.default = Files;
function fileMatch(root, relpath, pattern) {
    let filepath = node_1.path.join(root, relpath);
    if (typeof pattern !== 'string') {
        let base = pattern.baseUri.fsPath;
        if (!(0, fs_1.isParentFolder)(base, filepath))
            return false;
        let rp = node_1.path.relative(base, filepath);
        return (0, node_1.minimatch)(rp, pattern.pattern, { dot: true });
    }
    return (0, node_1.minimatch)(relpath, pattern, { dot: true });
}
function fsPath(uri) {
    return vscode_uri_1.URI.parse(uri).fsPath;
}
//# sourceMappingURL=files.js.map