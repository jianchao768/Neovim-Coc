'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.toVimFiletype = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const util_1 = require("../util");
const fs_1 = require("../util/fs");
const position_1 = require("../util/position");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const commandTask_1 = tslib_1.__importDefault(require("./commandTask"));
const configuration_1 = tslib_1.__importDefault(require("./configuration"));
class BasicList {
    constructor() {
        this.defaultAction = 'open';
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.nvim = workspace_1.default.nvim;
        this.config = configuration_1.default;
    }
    get alignColumns() {
        return configuration_1.default.get('alignColumns', false);
    }
    get floatPreview() {
        return configuration_1.default.get('floatPreview', false);
    }
    get hlGroup() {
        return configuration_1.default.get('previewHighlightGroup', 'Search');
    }
    get previewHeight() {
        return configuration_1.default.get('maxPreviewHeight', 12);
    }
    get splitRight() {
        return configuration_1.default.get('previewSplitRight', false);
    }
    get toplineStyle() {
        return configuration_1.default.get('previewToplineStyle', 'offset');
    }
    get toplineOffset() {
        return configuration_1.default.get('previewToplineOffset', 3);
    }
    parseArguments(args) {
        if (!this.optionMap) {
            this.optionMap = new Map();
            for (let opt of this.options) {
                let parts = opt.name.split(/,\s*/g).map(s => s.replace(/\s+.*/g, ''));
                let name = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, '');
                for (let p of parts) {
                    this.optionMap.set(p, { name, hasValue: opt.hasValue });
                }
            }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
            let arg = args[i];
            let def = this.optionMap.get(arg);
            if (!def)
                continue;
            let value = true;
            if (def.hasValue) {
                value = (0, string_1.toText)(args[i + 1]);
                i = i + 1;
            }
            res[def.name] = value;
        }
        return res;
    }
    /**
     * Get configuration of current list
     */
    getConfig() {
        return workspace_1.default.getConfiguration(`list.source.${this.name}`);
    }
    addAction(name, fn, options) {
        this.createAction(Object.assign({
            name,
            execute: fn
        }, options || {}));
    }
    addMultipleAction(name, fn, options) {
        this.createAction(Object.assign({
            name,
            multiple: true,
            execute: fn
        }, options || {}));
    }
    createCommandTask(opt) {
        return new commandTask_1.default(opt);
    }
    addLocationActions() {
        this.createAction({
            name: 'preview',
            execute: async (item, context) => {
                let loc = await this.convertLocation(item.location);
                await this.previewLocation(loc, context);
            }
        });
        let { nvim } = this;
        this.createAction({
            name: 'quickfix',
            multiple: true,
            execute: async (items) => {
                let quickfixItems = await Promise.all(items.map(item => this.convertLocation(item.location).then(loc => workspace_1.default.getQuickfixItem(loc))));
                await nvim.call('setqflist', [quickfixItems]);
                let openCommand = await nvim.getVar('coc_quickfix_open_command');
                nvim.command(typeof openCommand === 'string' ? openCommand : 'copen', true);
            }
        });
        for (let name of ['open', 'tabe', 'drop', 'vsplit', 'split']) {
            this.createAction({
                name,
                execute: async (item, context) => {
                    await this.jumpTo(item.location, name == 'open' ? null : name, context);
                },
                tabPersist: name === 'open'
            });
        }
    }
    async convertLocation(location) {
        if (typeof location == 'string')
            return vscode_languageserver_types_1.Location.create(location, vscode_languageserver_types_1.Range.create(0, 0, 0, 0));
        if (vscode_languageserver_types_1.Location.is(location))
            return location;
        let u = vscode_uri_1.URI.parse(location.uri);
        if (u.scheme != 'file')
            return vscode_languageserver_types_1.Location.create(location.uri, vscode_languageserver_types_1.Range.create(0, 0, 0, 0));
        return await (0, fs_1.lineToLocation)(u.fsPath, location.line, location.text);
    }
    async jumpTo(location, command, context) {
        if (command == null && context && context.options.position === 'tab') {
            command = 'tabe';
        }
        if (typeof location == 'string') {
            await workspace_1.default.jumpTo(location, null, command);
            return;
        }
        let { range, uri } = await this.convertLocation(location);
        let position = range.start;
        if (position.line == 0 && position.character == 0 && (0, position_1.comparePosition)(position, range.end) == 0) {
            // allow plugin that remember position.
            position = null;
        }
        await workspace_1.default.jumpTo(uri, position, command);
    }
    createAction(action) {
        let { name } = action;
        let idx = this.actions.findIndex(o => o.name == name);
        // allow override
        if (idx !== -1)
            this.actions.splice(idx, 1);
        this.actions.push(action);
    }
    async previewLocation(location, context) {
        let { uri, range } = location;
        let doc = workspace_1.default.getDocument(location.uri);
        let u = vscode_uri_1.URI.parse(uri);
        let lines = await workspace_1.default.documentsManager.getLines(uri);
        let config = {
            bufnr: doc ? doc.bufnr : undefined,
            winid: context.window.id,
            range: (0, position_1.emptyRange)(range) ? null : range,
            lnum: range.start.line + 1,
            name: u.scheme == 'file' ? u.fsPath : uri,
            filetype: toVimFiletype(doc ? doc.languageId : workspace_1.default.documentsManager.getLanguageId(u.fsPath)),
            position: context.options.position,
            maxHeight: this.previewHeight,
            splitRight: this.splitRight,
            hlGroup: this.hlGroup,
            scheme: u.scheme,
            toplineStyle: this.toplineStyle,
            toplineOffset: this.toplineOffset,
            targetRange: location.targetRange
        };
        await this.openPreview(lines, config);
    }
    async preview(options, context) {
        let { bufname, filetype, range, lines, lnum } = options;
        let config = {
            winid: context.window.id,
            lnum: range ? range.start.line + 1 : lnum || 1,
            filetype,
            position: context.options.position,
            maxHeight: this.previewHeight,
            splitRight: this.splitRight,
            hlGroup: this.hlGroup,
            toplineStyle: this.toplineStyle,
            toplineOffset: this.toplineOffset,
        };
        if (bufname)
            config.name = bufname;
        if (range)
            config.range = range;
        await this.openPreview(lines, config);
    }
    async openPreview(lines, config) {
        let { nvim } = this;
        if (this.floatPreview && config.position !== 'tab') {
            await nvim.call('coc#list#float_preview', [lines, config]);
        }
        else {
            await nvim.call('coc#list#preview', [lines, config]);
        }
        nvim.command('redraw', true);
    }
    doHighlight() {
        // noop
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = BasicList;
function toVimFiletype(filetype) {
    switch (filetype) {
        case 'latex':
            // LaTeX (LSP language ID 'latex') has Vim filetype 'tex'
            return 'tex';
        default:
            return filetype;
    }
}
exports.toVimFiletype = toVimFiletype;
//# sourceMappingURL=basic.js.map