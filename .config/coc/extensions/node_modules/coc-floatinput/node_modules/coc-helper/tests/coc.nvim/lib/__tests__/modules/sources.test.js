"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const sources_1 = tslib_1.__importDefault(require("../../completion/sources"));
const types_1 = require("../../completion/types");
const events_1 = tslib_1.__importDefault(require("../../events"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
});
describe('sources', () => {
    it('should check commit', () => {
        expect(sources_1.default.shouldCommit(undefined, undefined, '')).toBe(false);
        let source = sources_1.default.getSource('$words');
        expect(sources_1.default.shouldCommit(source, { word: '' }, '.')).toBe(false);
    });
    it('should get normal sources', () => {
        sources_1.default.createSource({
            name: 'name',
            documentSelector: [{ language: 'vim' }],
            doComplete: () => null
        });
        let arr = sources_1.default.getNormalSources('', 'test:///1');
        let res = arr.find(o => o.name === 'name');
        expect(res).toBeUndefined();
        sources_1.default.createSource({
            name: 'name',
            documentSelector: [{ language: '*' }],
            doComplete: () => null
        });
        arr = sources_1.default.getNormalSources('x', 'test:///1');
        res = arr.find(o => o.name === 'name');
        expect(res).toBeDefined();
    });
    it('should get trigger sources', () => {
        let res = sources_1.default.getTriggerSources('', 'vim', 'test:///1');
        expect(res).toEqual([]);
        let arr = ['around', 'buffer', 'file'];
        res = sources_1.default.getTriggerSources('', 'vim', 'test:///1', arr);
        let find = res.find(o => arr.includes(o.name));
        expect(find).toBeUndefined();
        sources_1.default.createSource({
            name: 'name',
            documentSelector: [{ language: 'vim' }],
            doComplete: () => null
        });
        helper_1.default.updateConfiguration('coc.source.name.triggerCharacters', ['.']);
        res = sources_1.default.getTriggerSources('.', 'vim', 'test:///1', arr);
        find = res.find(o => o.name === 'name');
        expect(find).toBeDefined();
        res = sources_1.default.getTriggerSources('.', 'txt', 'test:///1', arr);
        find = res.find(o => o.name === 'name');
        expect(find).toBeUndefined();
    });
    it('should do document enter', async () => {
        let fn = jest.fn();
        let source = {
            name: 'enter',
            enable: true,
            priority: 0,
            sourceType: types_1.SourceType.Service,
            triggerCharacters: [],
            doComplete: () => Promise.resolve({ items: [] }),
            onEnter: fn
        };
        disposables.push(sources_1.default.addSource(source));
        let buffer = await nvim.buffer;
        await events_1.default.fire('BufEnter', [buffer.id]);
        expect(fn).toBeCalled();
    });
    it('should get sources by split filetypes', async () => {
        disposables.push(sources_1.default.addSource({
            name: 'foo',
            filetypes: ['foo'],
            enable: true,
            doComplete: () => Promise.resolve({ items: [] }),
        }));
        disposables.push(sources_1.default.addSource({
            name: 'bar',
            filetypes: ['bar'],
            enable: true,
            doComplete: () => Promise.resolve({ items: [] }),
        }));
        let arr = sources_1.default.getNormalSources('foo.bar', 'file:///a');
        let names = arr.map(s => s.name);
        expect(names.includes('foo')).toBe(true);
        expect(names.includes('bar')).toBe(true);
    });
    it('should return source states', async () => {
        let stats = await helper_1.default.doAction('sourceStat');
        expect(stats.length > 1).toBe(true);
    });
    it('should toggle source state', async () => {
        await helper_1.default.doAction('toggleSource', 'around');
        let s = sources_1.default.getSource('around');
        expect(s.enable).toBe(false);
        sources_1.default.toggleSource('around');
    });
});
describe('sources#has', () => {
    it('should has source', () => {
        expect(sources_1.default.has('around')).toBe(true);
    });
    it('should not has source', () => {
        expect(sources_1.default.has('NotExists')).toBe(false);
    });
});
describe('sources#refresh', () => {
    it('should refresh if possible', async () => {
        let fn = jest.fn();
        let source = {
            name: 'refresh',
            enable: true,
            priority: 0,
            sourceType: types_1.SourceType.Service,
            triggerCharacters: [],
            doComplete: () => Promise.resolve({ items: [] }),
            refresh: fn
        };
        disposables.push(sources_1.default.addSource(source));
        await helper_1.default.doAction('refreshSource', 'refresh');
        expect(fn).toBeCalled();
    });
    it('should work if refresh not defined', async () => {
        let source = {
            name: 'refresh',
            enable: true,
            priority: 0,
            sourceType: types_1.SourceType.Service,
            triggerCharacters: [],
            doComplete: () => Promise.resolve({ items: [] })
        };
        disposables.push(sources_1.default.addSource(source));
        await sources_1.default.refresh('refresh');
    });
});
describe('sources#createSource', () => {
    it('should throw on create source', async () => {
        expect(() => {
            sources_1.default.createSource({
                doComplete: () => Promise.resolve({
                    items: [{
                            word: 'custom'
                        }]
                })
            });
        }).toThrow();
    });
    it('should create vim source', async () => {
        let folder = path_1.default.resolve(__dirname, '..');
        await nvim.command(`set runtimepath+=${folder}`);
        disposables.push({
            dispose: () => {
                sources_1.default.removeSource('email');
            }
        });
        await helper_1.default.waitValue(() => {
            return sources_1.default.has('email');
        }, true);
        await helper_1.default.createDocument();
        await nvim.input('i@');
        await helper_1.default.visible('foo@gmail.com');
    });
});
describe('sources#getTriggerSources()', () => {
    it('should filter by filetypes', async () => {
        let source = {
            name: 'test',
            enable: true,
            priority: 0,
            filetypes: ['javascript'],
            sourceType: types_1.SourceType.Service,
            triggerCharacters: ['#'],
            doComplete: () => Promise.resolve({ items: [] })
        };
        disposables.push(sources_1.default.addSource(source));
        let res = sources_1.default.getTriggerSources('#', 'javascript', 'file:///tmp.js');
        expect(res.find(o => o.name == 'test')).toBeDefined();
    });
    it('should filter by documentSelector', async () => {
        let source = {
            name: 'test',
            enable: true,
            priority: 0,
            documentSelector: [{ language: 'javascript' }],
            sourceType: types_1.SourceType.Service,
            triggerCharacters: ['#'],
            doComplete: () => Promise.resolve({ items: [] })
        };
        disposables.push(sources_1.default.addSource(source));
        let res = sources_1.default.getTriggerSources('#', 'javascript', 'file:///tmp.js');
        expect(res.find(o => o.name == 'test')).toBeDefined();
    });
    it('should filter disabled sources', async () => {
        await nvim.setLine('foo bar ');
        let buf = await nvim.buffer;
        await buf.setVar('coc_disabled_sources', ['around', 'buffer', 'file']);
        await nvim.input('Af');
        await helper_1.default.wait(30);
        await nvim.input('/');
        await helper_1.default.wait(100);
        let visible = await nvim.call('pumvisible');
        expect(visible).toBe(0);
    });
});
//# sourceMappingURL=sources.test.js.map