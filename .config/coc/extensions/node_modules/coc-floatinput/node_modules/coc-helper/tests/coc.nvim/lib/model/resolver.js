'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_1 = require("../util/node");
const fs_1 = require("../util/fs");
const processes_1 = require("../util/processes");
const strip_ansi_1 = tslib_1.__importDefault(require("strip-ansi"));
class Resolver {
    get nodeFolder() {
        if (!(0, processes_1.executable)('npm'))
            return Promise.resolve('');
        if (this._npmFolder)
            return Promise.resolve(this._npmFolder);
        return (0, processes_1.runCommand)('npm --loglevel silent root -g', {}, 3000).then(root => {
            this._npmFolder = (0, strip_ansi_1.default)(root).trim();
            return this._npmFolder;
        });
    }
    get yarnFolder() {
        if (!(0, processes_1.executable)('yarnpkg'))
            return Promise.resolve('');
        if (this._yarnFolder)
            return Promise.resolve(this._yarnFolder);
        return (0, processes_1.runCommand)('yarnpkg global dir', {}, 3000).then(root => {
            let folder = node_1.path.join((0, strip_ansi_1.default)(root).trim(), 'node_modules');
            let exists = node_1.fs.existsSync(folder);
            if (exists)
                this._yarnFolder = folder;
            return exists ? folder : '';
        });
    }
    async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
            let s = await (0, fs_1.statAsync)(node_1.path.join(yarnFolder, mod, 'package.json'));
            if (s && s.isFile())
                return node_1.path.join(yarnFolder, mod);
        }
        if (nodeFolder) {
            let s = await (0, fs_1.statAsync)(node_1.path.join(nodeFolder, mod, 'package.json'));
            if (s && s.isFile())
                return node_1.path.join(nodeFolder, mod);
        }
        return null;
    }
}
exports.default = Resolver;
//# sourceMappingURL=resolver.js.map