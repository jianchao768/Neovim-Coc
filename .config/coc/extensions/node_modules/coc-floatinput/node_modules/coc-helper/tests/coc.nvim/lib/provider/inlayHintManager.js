'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLabel = exports.isValidInlayHint = exports.isInlayHint = exports.sameHint = void 0;
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger_1 = require("../logger");
const position_1 = require("../util/position");
const manager_1 = tslib_1.__importDefault(require("./manager"));
const logger = (0, logger_1.createLogger)('inlayHintManger');
class InlayHintManger extends manager_1.default {
    register(selector, provider) {
        return this.addProvider({
            id: (0, uuid_1.v4)(),
            selector,
            provider
        });
    }
    /**
     * Multiple providers can be registered for a language. In that case providers are asked in
     * parallel and the results are merged. A failing provider (rejected promise or exception) will
     * not cause a failure of the whole operation.
     */
    async provideInlayHints(document, range, token) {
        let items = this.getProviders(document);
        let inlayHints = [];
        await Promise.all(items.map(item => {
            let { id, provider } = item;
            return Promise.resolve(provider.provideInlayHints(document, range, token)).then(hints => {
                if (!Array.isArray(hints) || token.isCancellationRequested)
                    return;
                let noCheck = inlayHints.length == 0;
                for (let hint of hints) {
                    if (!isValidInlayHint(hint, range))
                        continue;
                    if (!noCheck && inlayHints.findIndex(o => sameHint(o, hint)) != -1)
                        continue;
                    inlayHints.push(Object.assign({ providerId: id }, hint));
                }
            });
        }));
        return inlayHints;
    }
    async resolveInlayHint(hint, token) {
        let provider = this.getProviderById(hint.providerId);
        if (!provider || typeof provider.resolveInlayHint !== 'function' || hint.resolved === true)
            return hint;
        let res = await Promise.resolve(provider.resolveInlayHint(hint, token));
        if (token.isCancellationRequested)
            return hint;
        return Object.assign(hint, res, { resolved: true });
    }
}
exports.default = InlayHintManger;
function sameHint(one, other) {
    if ((0, position_1.comparePosition)(one.position, other.position) !== 0)
        return false;
    return getLabel(one) === getLabel(other);
}
exports.sameHint = sameHint;
function isInlayHint(obj) {
    if (!obj || !vscode_languageserver_types_1.Position.is(obj.position) || obj.label == null)
        return false;
    if (typeof obj.label !== 'string')
        return Array.isArray(obj.label) && obj.label.every(p => typeof p.value === 'string');
    return true;
}
exports.isInlayHint = isInlayHint;
function isValidInlayHint(hint, range) {
    if (hint.label.length === 0 || (Array.isArray(hint.label) && hint.label.every(part => part.value.length === 0))) {
        logger.warn('INVALID inlay hint, empty label', hint);
        return false;
    }
    if (!isInlayHint(hint)) {
        logger.warn('INVALID inlay hint', hint);
        return false;
    }
    if (range && (0, position_1.positionInRange)(hint.position, range) !== 0) {
        // console.log('INVALID inlay hint, position outside range', range, hint);
        return false;
    }
    return true;
}
exports.isValidInlayHint = isValidInlayHint;
function getLabel(hint) {
    if (typeof hint.label === 'string')
        return hint.label;
    return hint.label.map(o => o.value).join('');
}
exports.getLabel = getLabel;
//# sourceMappingURL=inlayHintManager.js.map