"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJsFiles = exports.checkExtensionRoot = exports.getExtensionName = exports.loadExtensionJson = exports.loadGlobalJsonAsync = exports.validExtensionFolder = exports.toInterval = exports.ExtensionStat = exports.ExtensionStatus = void 0;
const logger_1 = require("../logger");
const array_1 = require("../util/array");
const fs_1 = require("../util/fs");
const is_1 = require("../util/is");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const logger = (0, logger_1.createLogger)('extension-stat');
var ExtensionStatus;
(function (ExtensionStatus) {
    ExtensionStatus[ExtensionStatus["Normal"] = 0] = "Normal";
    ExtensionStatus[ExtensionStatus["Disabled"] = 1] = "Disabled";
    ExtensionStatus[ExtensionStatus["Locked"] = 2] = "Locked";
})(ExtensionStatus = exports.ExtensionStatus || (exports.ExtensionStatus = {}));
const ONE_DAY = 24 * 60 * 60 * 1000;
/**
 * Stat for global extensions
 */
class ExtensionStat {
    constructor(folder) {
        this.folder = folder;
        this.disabled = new Set();
        this.locked = new Set();
        this.extensions = new Set();
        this.localExtensions = new Map();
        try {
            this.migrate();
        }
        catch (e) {
            logger.error(`Error on update package.json at ${folder}`, e);
        }
    }
    migrate() {
        var _a, _b, _c, _d;
        let curr = loadJson(this.jsonFile);
        let db = node_1.path.join(this.folder, 'db.json');
        let changed = false;
        if (node_1.fs.existsSync(db)) {
            let obj = loadJson(db);
            let def = (_a = obj.extension) !== null && _a !== void 0 ? _a : {};
            for (let [key, o] of Object.entries(def)) {
                if (o.disabled)
                    this.disabled.add(key);
                if (o.locked)
                    this.locked.add(key);
            }
            curr.disabled = Array.from(this.disabled);
            curr.locked = Array.from(this.locked);
            curr.lastUpdate - obj.lastUpdate;
            node_1.fs.unlinkSync(db);
            changed = true;
        }
        else {
            this.disabled = new Set((_b = curr.disabled) !== null && _b !== void 0 ? _b : []);
            this.locked = new Set((_c = curr.locked) !== null && _c !== void 0 ? _c : []);
        }
        if (changed)
            (0, fs_1.writeJson)(this.jsonFile, curr);
        let ids = Object.keys((_d = curr.dependencies) !== null && _d !== void 0 ? _d : {});
        this.extensions = new Set(ids);
    }
    *activated() {
        let { disabled } = this;
        for (let key of Object.keys(this.dependencies)) {
            if (!disabled.has(key)) {
                yield key;
            }
        }
    }
    addLocalExtension(name, folder) {
        this.localExtensions.set(name, folder);
    }
    getFolder(name) {
        if (this.extensions.has(name))
            return node_1.path.join(this.folder, 'node_modules', name);
        return this.localExtensions.get(name);
    }
    getExtensionsStat() {
        let res = {};
        for (let id of this.extensions) {
            if (this.disabled.has(id)) {
                res[id] = ExtensionStatus.Disabled;
            }
            else if (this.locked.has(id)) {
                res[id] = ExtensionStatus.Locked;
            }
            else {
                res[id] = ExtensionStatus.Normal;
            }
        }
        return res;
    }
    hasExtension(id) {
        return this.extensions.has(id);
    }
    addExtension(id, val) {
        var _a;
        let curr = loadJson(this.jsonFile);
        curr.dependencies = (_a = curr.dependencies) !== null && _a !== void 0 ? _a : {};
        curr.dependencies[id] = val;
        this.extensions.add(id);
        (0, fs_1.writeJson)(this.jsonFile, curr);
    }
    removeExtension(id) {
        var _a;
        let curr = loadJson(this.jsonFile);
        if (curr.disabled)
            curr.disabled = curr.disabled.filter(key => key !== id);
        if (curr.locked)
            curr.locked = curr.locked.filter(key => key !== id);
        curr.dependencies = (_a = curr.dependencies) !== null && _a !== void 0 ? _a : {};
        delete curr.dependencies[id];
        this.extensions.delete(id);
        (0, fs_1.writeJson)(this.jsonFile, curr);
    }
    isDisabled(id) {
        return this.disabled.has(id);
    }
    get lockedExtensions() {
        return Array.from(this.locked);
    }
    get disabledExtensions() {
        return Array.from(this.disabled);
    }
    get dependencies() {
        var _a;
        let curr = loadJson(this.jsonFile);
        return (_a = curr.dependencies) !== null && _a !== void 0 ? _a : {};
    }
    setDisable(id, disable) {
        if (disable) {
            this.disabled.add(id);
        }
        else {
            this.disabled.delete(id);
        }
        this.update('disabled', Array.from(this.disabled));
    }
    setLocked(id, locked) {
        if (locked) {
            this.locked.add(id);
        }
        else {
            this.locked.delete(id);
        }
        this.update('locked', Array.from(this.disabled));
    }
    setLastUpdate() {
        this.update('lastUpdate', Date.now());
    }
    shouldUpdate(opt) {
        if (opt === 'never')
            return false;
        let interval = toInterval(opt);
        let curr = loadJson(this.jsonFile);
        return curr.lastUpdate == null || (Date.now() - curr.lastUpdate) > interval;
    }
    get globalIds() {
        var _a;
        let curr = loadJson(this.jsonFile);
        return Object.keys((_a = curr.dependencies) !== null && _a !== void 0 ? _a : {});
    }
    /**
     * Filter out global extensions that needs install
     */
    filterGlobalExtensions(names) {
        let disabledExtensions = this.disabledExtensions;
        let dependencies = this.dependencies;
        let map = new Map();
        (0, array_1.toArray)(names).forEach(def => {
            if (!def || typeof def !== 'string')
                return;
            let name = getExtensionName(def);
            map.set(name, def);
        });
        let currentUrls = [];
        let exists = [];
        for (let [key, val] of Object.entries(dependencies)) {
            if (node_1.fs.existsSync(node_1.path.join(this.folder, 'node_modules', key, 'package.json'))) {
                exists.push(key);
                if (typeof val === 'string' && /^https?:/.test(val)) {
                    currentUrls.push(val);
                }
            }
        }
        for (let name of map.keys()) {
            if (disabledExtensions.includes(name) || this.extensions.has(name)) {
                map.delete(name);
                continue;
            }
            if ((/^https?:/.test(name) && currentUrls.some(url => url.startsWith(name))) || exists.includes(name)) {
                map.delete(name);
            }
        }
        return Array.from(map.values());
    }
    update(key, value) {
        let curr = loadJson(this.jsonFile);
        curr[key] = value;
        (0, fs_1.writeJson)(this.jsonFile, curr);
    }
    get jsonFile() {
        return node_1.path.join(this.folder, 'package.json');
    }
}
exports.ExtensionStat = ExtensionStat;
function toInterval(opt) {
    return opt === 'daily' ? ONE_DAY : ONE_DAY * 7;
}
exports.toInterval = toInterval;
function validExtensionFolder(folder, version) {
    let errors = [];
    let res = loadExtensionJson(folder, version, errors);
    return res != null && errors.length == 0;
}
exports.validExtensionFolder = validExtensionFolder;
function getEntryFile(main) {
    if (!main)
        return 'index.js';
    if (!main.endsWith('.js'))
        return main + '.js';
    return main;
}
async function loadGlobalJsonAsync(folder, version) {
    let jsonFile = node_1.path.join(folder, 'package.json');
    let content = await (0, fs_1.readFile)(jsonFile, 'utf8');
    let packageJSON = JSON.parse(content);
    let { engines } = packageJSON;
    let main = getEntryFile(packageJSON.main);
    if (!engines || (typeof engines.coc !== 'string' && typeof engines.vscode !== 'string'))
        throw new Error('Invalid engines field');
    let keys = Object.keys(engines);
    if (keys.includes('coc') && !node_1.semver.satisfies(version, engines['coc'].replace(/^\^/, '>='))) {
        throw new Error(`coc.nvim version not match, required ${engines['coc']}`);
    }
    if (!engines.vscode && !node_1.fs.existsSync(node_1.path.join(folder, main))) {
        throw new Error(`main file ${main} not found, you may need to build the project.`);
    }
    return packageJSON;
}
exports.loadGlobalJsonAsync = loadGlobalJsonAsync;
function loadExtensionJson(folder, version, errors) {
    let jsonFile = node_1.path.join(folder, 'package.json');
    if (!node_1.fs.existsSync(jsonFile)) {
        errors.push(`package.json not found in ${folder}`);
        return undefined;
    }
    let packageJSON = loadJson(jsonFile);
    let { name, engines } = packageJSON;
    let main = getEntryFile(packageJSON.main);
    if (!name)
        errors.push(`can't find name in package.json`);
    if (!engines || !(0, is_1.objectLiteral)(engines)) {
        errors.push(`invalid engines in ${jsonFile}`);
    }
    if (engines && !engines.vscode && !node_1.fs.existsSync(node_1.path.join(folder, main))) {
        errors.push(`main file ${main} not found, you may need to build the project.`);
    }
    if (engines) {
        let keys = Object.keys(engines);
        if (!keys.includes('coc') && !keys.includes('vscode')) {
            errors.push(`Engines in package.json doesn't have coc or vscode`);
        }
        if (keys.includes('coc')) {
            let required = engines['coc'].replace(/^\^/, '>=');
            if (!node_1.semver.satisfies(version, required)) {
                errors.push(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines['coc']}`);
            }
        }
    }
    return packageJSON;
}
exports.loadExtensionJson = loadExtensionJson;
/**
 * Name of extension
 */
function getExtensionName(def) {
    if (/^https?:/.test(def))
        return def;
    if (!def.includes('@'))
        return def;
    return def.replace(/@[\d.]+$/, '');
}
exports.getExtensionName = getExtensionName;
function checkExtensionRoot(root) {
    try {
        if (!node_1.fs.existsSync(root)) {
            node_1.fs.mkdirSync(root, { recursive: true });
        }
        let stat = node_1.fs.statSync(root);
        if (!stat.isDirectory()) {
            logger.info(`Trying to delete ${root}`);
            node_1.fs.unlinkSync(root);
            node_1.fs.mkdirSync(root, { recursive: true });
        }
        let jsonFile = node_1.path.join(root, 'package.json');
        if (!node_1.fs.existsSync(jsonFile)) {
            node_1.fs.writeFileSync(jsonFile, '{"dependencies":{}}', 'utf8');
        }
    }
    catch (e) {
        console.error(`Unexpected error when check data home ${root}: ${e}`);
        return false;
    }
    return true;
}
exports.checkExtensionRoot = checkExtensionRoot;
async function getJsFiles(folder) {
    if (!node_1.fs.existsSync(folder))
        return [];
    let files = await (0, node_1.promisify)(node_1.fs.readdir)(folder);
    return files.filter(f => f.endsWith('.js'));
}
exports.getJsFiles = getJsFiles;
function loadJson(filepath) {
    try {
        let text = node_1.fs.readFileSync(filepath, 'utf8');
        let data = JSON.parse(text);
        return (0, object_1.toObject)(data);
    }
    catch (e) {
        logger.error(`Error on parse json file ${filepath}`, e);
        return {};
    }
}
//# sourceMappingURL=stat.js.map