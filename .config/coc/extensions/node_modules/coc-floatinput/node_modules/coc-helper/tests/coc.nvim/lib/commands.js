'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("./events"));
const logger_1 = require("./logger");
const mru_1 = tslib_1.__importDefault(require("./model/mru"));
const array_1 = require("./util/array");
const extensionRegistry_1 = require("./util/extensionRegistry");
const protocol_1 = require("./util/protocol");
const registry_1 = require("./util/registry");
const string_1 = require("./util/string");
const logger = (0, logger_1.createLogger)('commands');
class CommandItem {
    constructor(id, impl, thisArg, internal) {
        this.id = id;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
    }
    execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, (0, array_1.toArray)(args));
    }
    dispose() {
        this.thisArg = null;
        this.impl = null;
    }
}
const extensionRegistry = registry_1.Registry.as(extensionRegistry_1.Extensions.ExtensionContribution);
class CommandManager {
    constructor() {
        this.commands = new Map();
        this.titles = new Map();
        this.mru = new mru_1.default('commands');
    }
    get commandList() {
        var _a;
        let res = [];
        for (let item of this.commands.values()) {
            if (!item.internal) {
                let { id } = item;
                let title = (_a = this.titles.get(id)) !== null && _a !== void 0 ? _a : extensionRegistry.getCommandTitle(id);
                res.push({ id, title: (0, string_1.toText)(title) });
            }
        }
        return res;
    }
    dispose() {
        for (const registration of this.commands.values()) {
            registration.dispose();
        }
        this.commands.clear();
    }
    execute(command) {
        var _a;
        return this.executeCommand(command.command, ...((_a = command.arguments) !== null && _a !== void 0 ? _a : []));
    }
    register(command, internal, description) {
        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
            this.registerCommand(id, command.execute, command, internal);
            if (description)
                this.titles.set(id, description);
        }
        return command;
    }
    has(id) {
        return this.commands.has(id);
    }
    unregister(id) {
        let item = this.commands.get(id);
        if (!item)
            return;
        item.dispose();
        this.commands.delete(id);
    }
    /**
     * Registers a command that can be invoked via a keyboard shortcut,
     * a menu item, an action, or directly.
     *
     * Registering a command with an existing command identifier twice
     * will cause an error.
     *
     * @param command A unique identifier for the command.
     * @param impl A command handler function.
     * @param thisArg The `this` context used when invoking the handler function.
     * @return Disposable which unregisters this command on disposal.
     */
    registerCommand(id, impl, thisArg, internal = false) {
        if (id.startsWith("_"))
            internal = true;
        if (this.commands.has(id))
            logger.warn(`Command ${id} already registered`);
        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
        return protocol_1.Disposable.create(() => {
            this.commands.delete(id);
        });
    }
    /**
     * Executes the command denoted by the given command identifier.
     *
     * * *Note 1:* When executing an editor command not all types are allowed to
     * be passed as arguments. Allowed are the primitive types `string`, `boolean`,
     * `number`, `undefined`, and `null`, as well as [`Position`](#Position), [`Range`](#Range), [`URI`](#URI) and [`Location`](#Location).
     * * *Note 2:* There are no restrictions when executing commands that have been contributed
     * by extensions.
     *
     * @param command Identifier of the command to execute.
     * @param rest Parameters passed to the command function.
     * @return A promise that resolves to the returned value of the given command. `undefined` when
     * the command handler function doesn't return anything.
     */
    executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd)
            throw new Error(`Command: ${command} not found`);
        return Promise.resolve(cmd.execute.apply(cmd, rest));
    }
    /**
     * Used for user invoked command.
     */
    async fireCommand(id, ...args) {
        // needed to load onCommand extensions
        await events_1.default.fire('Command', [id]);
        let start = Date.now();
        let res = await this.executeCommand(id, ...args);
        if (args.length == 0) {
            await this.addRecent(id, events_1.default.lastChangeTs > start);
        }
        return res;
    }
    async addRecent(cmd, repeat) {
        await this.mru.add(cmd);
        if (repeat)
            this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`, true);
    }
    async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
            await this.executeCommand(first);
            await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
    }
}
exports.default = new CommandManager();
//# sourceMappingURL=commands.js.map