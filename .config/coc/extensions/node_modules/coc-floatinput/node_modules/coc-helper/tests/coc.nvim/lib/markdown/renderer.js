'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTableRow = exports.numberedLine = exports.bulletPointLine = exports.toSpaces = exports.identify = exports.fixHardReturn = void 0;
const tslib_1 = require("tslib");
const object_1 = require("../util/object");
/**
 * Renderer for convert markdown to terminal string
 */
const styles = tslib_1.__importStar(require("./styles"));
let TABLE_CELL_SPLIT = '^*||*^';
let TABLE_ROW_WRAP = '*|*|*|*';
let TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), 'g');
let COLON_REPLACER = '*#COLON|*';
let COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), 'g');
// HARD_RETURN holds a character sequence used to indicate text has a
// hard (no-reflowing) line break.  Previously \r and \r\n were turned
// into \n in marked's lexer- preprocessing step. So \r is safe to use
// to indicate a hard (non-reflowed) return.
let HARD_RETURN = /\r/g;
function identity(str) {
    return str;
}
function cleanUpHtml(input) {
    return styles.gray(input.replace(/(<([^>]+)>)/ig, ''));
}
let defaultOptions = {
    code: identity,
    blockquote: identity,
    html: cleanUpHtml,
    heading: styles.magenta,
    firstHeading: styles.magenta,
    hr: identity,
    listitem: identity,
    list,
    table: identity,
    paragraph: identity,
    strong: styles.bold,
    em: styles.italic,
    codespan: styles.yellow,
    del: styles.strikethrough,
    link: styles.underline,
    href: styles.underline,
    text: identity,
    unescape: true,
    emoji: false,
    width: 80,
    showSectionPrefix: false,
    tab: 2,
    tableOptions: {}
};
function fixHardReturn(text, reflow) {
    return reflow ? text.replace(HARD_RETURN, '\n') : text;
}
exports.fixHardReturn = fixHardReturn;
function indentLines(indent, text) {
    return text.replace(/(^|\n)(.+)/g, '$1' + indent + '$2');
}
function identify(indent, text) {
    if (!text)
        return text;
    return indent + text.split('\n').join('\n' + indent);
}
exports.identify = identify;
let BULLET_POINT_REGEX = '\\*';
let NUMBERED_POINT_REGEX = '\\d+\\.';
let POINT_REGEX = '(?:' + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join('|') + ')';
// Prevents nested lists from joining their parent list's last line
function fixNestedLists(body, indent) {
    let regex = new RegExp('' +
        '(\\S(?: |  )?)' + // Last char of current point, plus one or two spaces
        // to allow trailing spaces
        '((?:' +
        indent +
        ')+)' + // Indentation of sub point
        '(' +
        POINT_REGEX +
        '(?:.*)+)$', 'gm'); // Body of subpoint
    return body.replace(regex, '$1\n' + indent + '$2$3');
}
let isPointedLine = function (line, indent) {
    return line.match('^(?:' + indent + ')*' + POINT_REGEX) != null;
};
function toSpaces(str) {
    return ' '.repeat(str.length);
}
exports.toSpaces = toSpaces;
let BULLET_POINT = '* ';
function bulletPointLine(indent, line) {
    return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
}
exports.bulletPointLine = bulletPointLine;
function bulletPointLines(lines, indent) {
    let transform = bulletPointLine.bind(null, indent);
    return lines
        .split('\n')
        .filter(identity)
        .map(transform)
        .join('\n');
}
let numberedPoint = function (n) {
    return n + '. ';
};
function numberedLine(indent, line, num) {
    return isPointedLine(line, indent)
        ? {
            num: num + 1,
            line: line.replace(BULLET_POINT, numberedPoint(num + 1))
        }
        : {
            num,
            line: toSpaces(numberedPoint(num)) + line
        };
}
exports.numberedLine = numberedLine;
function numberedLines(lines, indent) {
    let transform = numberedLine.bind(null, indent);
    let num = 0;
    return lines
        .split('\n')
        .filter(identity)
        .map(line => {
        const numbered = transform(line, num);
        num = numbered.num;
        return numbered.line;
    })
        .join('\n');
}
function list(body, ordered, indent) {
    body = body.trim();
    body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
    return body;
}
function section(text) {
    return text + '\n\n';
}
function undoColon(str) {
    return str.replace(COLON_REPLACER_REGEXP, ':');
}
function generateTableRow(text, escape = null) {
    if (!text)
        return [];
    escape = escape || identity;
    let lines = escape(text).split('\n');
    let data = [];
    lines.forEach(function (line) {
        if (!line)
            return;
        let parsed = line
            .replace(TABLE_ROW_WRAP_REGEXP, '')
            .split(TABLE_CELL_SPLIT);
        data.push(parsed.splice(0, parsed.length - 1));
    });
    return data;
}
exports.generateTableRow = generateTableRow;
function escapeRegExp(str) {
    // eslint-disable-next-line no-useless-escape
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
function unescapeEntities(html) {
    return html
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
}
const links = new Map();
class Renderer {
    constructor(options = {}, highlightOptions = {}) {
        this.options = options;
        this.highlightOptions = highlightOptions;
        this.o = Object.assign({}, defaultOptions, options);
        this.tab = '  ';
        this.tableSettings = this.o.tableOptions;
        // this.emoji = identity
        this.unescape = unescapeEntities;
        this.highlightOptions = (0, object_1.toObject)(highlightOptions);
        this.transform = this.compose(undoColon, this.unescape);
    }
    text(t) {
        return this.o.text(t);
    }
    code(code, lang, _escaped) {
        return '``` ' + lang + '\n' + code + '\n```\n';
    }
    blockquote(quote) {
        return section(this.o.blockquote(identify(this.tab, quote.trim())));
    }
    html(html) {
        return this.o.html(html);
    }
    heading(text, level, _raw) {
        text = this.transform(text);
        return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));
    }
    hr() {
        // NOTE: the '─' character is conveniently translated into a window-wide
        // horizontal rule by coc.nvim/autoload/coc/float.vim. Using this character
        // causes the horizontal rule to appear like a proper hr separator. In case
        // the user isn't benefiting from a floating window, we provide three
        // characters so that the hr doesn't deviate too significantly from
        // Markdown's normal '-'.
        return `───\n`;
    }
    list(body, ordered) {
        body = this.o.list(body, ordered, this.tab);
        return section(fixNestedLists(indentLines(this.tab, body), this.tab));
    }
    listitem(text) {
        let transform = this.compose(this.o.listitem, this.transform);
        let isNested = text.indexOf('\n') !== -1;
        if (isNested)
            text = text.trim();
        // Use BULLET_POINT as a marker for ordered or unordered list item
        return '\n' + BULLET_POINT + transform(text);
    }
    checkbox(checked) {
        return '[' + (checked ? 'X' : ' ') + '] ';
    }
    paragraph(text) {
        let transform = this.compose(this.o.paragraph, this.transform);
        text = transform(text);
        return section(text);
    }
    table(header, body) {
        const Table = require('cli-table');
        let table = new Table(Object.assign({}, {
            head: generateTableRow(header)[0]
        }, this.tableSettings));
        generateTableRow(body, this.transform).forEach(function (row) {
            table.push(row);
        });
        return section(this.o.table(table.toString()));
    }
    tablerow(content) {
        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + '\n';
    }
    tablecell(content, _flags) {
        return content + TABLE_CELL_SPLIT;
    }
    strong(text) {
        return this.o.strong(text);
    }
    em(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.em(text);
    }
    codespan(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
    }
    br() {
        return '\n';
    }
    del(text) {
        return this.o.del(text);
    }
    link(href, title, text) {
        let prot;
        try {
            prot = decodeURIComponent(unescape(href))
                .replace(/[^\w:]/g, '')
                .toLowerCase();
        }
        catch (e) {
            return '';
        }
        if (prot.startsWith('javascript:')) {
            return '';
        }
        if (text && href && text != href) {
            links.set(text, href);
        }
        if (text && text != href)
            return styles.blue(text);
        let out = this.o.href(href);
        return this.o.link(out);
    }
    image(href, title, text) {
        let out = '![' + text;
        return out + '](' + href + ')';
    }
    compose(...funcs) {
        return (...args) => {
            for (let i = funcs.length; i-- > 0;) {
                args = [funcs[i].apply(this, args)];
            }
            return args[0];
        };
    }
    static getLinks() {
        let res = [];
        for (let [text, href] of links.entries()) {
            res.push(`${styles.blue(text)}: ${href}`);
        }
        links.clear();
        return res;
    }
}
exports.default = Renderer;
//# sourceMappingURL=renderer.js.map