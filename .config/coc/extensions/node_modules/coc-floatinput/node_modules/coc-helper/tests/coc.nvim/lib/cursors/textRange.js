'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const position_1 = require("../util/position");
const textedit_1 = require("../util/textedit");
const util_1 = require("./util");
class TextRange {
    constructor(line, character, text) {
        this.start = vscode_languageserver_types_1.Position.create(line, character);
        this._text = text;
        this.end = (0, position_1.getEnd)(this.start, this._text);
    }
    get position() {
        return this.start;
    }
    get line() {
        return this.start.line;
    }
    get text() {
        return this._text;
    }
    get range() {
        return vscode_languageserver_types_1.Range.create(this.start, this.end);
    }
    get textEdit() {
        return {
            range: this.range,
            newText: this.text
        };
    }
    applyChange(change) {
        if ((0, util_1.isSurrondChange)(change)) {
            this.applySurrondChange(change);
        }
        else {
            this.applyTextChange(change);
        }
    }
    applySurrondChange(change) {
        let { prepend, append } = change;
        let len = this._text.length;
        let text = this._text.substring(prepend[0], len - append[0]);
        this._text = `${prepend[1]}${text}${append[1]}`;
    }
    applyTextChange(change) {
        let { text } = this;
        let { offset, remove, fromEnd, insert } = change;
        if (fromEnd)
            offset = -offset;
        let pre = text.slice(0, fromEnd && offset == 0 ? text.length : offset);
        let after = text.slice(pre.length);
        if (remove)
            after = after.slice(remove);
        this._text = `${pre}${insert || ''}${after}`;
    }
    /**
     * Adjust range
     */
    move(delta) {
        if (delta != 0) {
            let { line, character } = this.start;
            this.start = vscode_languageserver_types_1.Position.create(line, character + delta);
        }
        this.end = (0, position_1.getEnd)(this.start, this._text);
    }
    adjustFromEdit(edit) {
        let changed = (0, textedit_1.getChangedPosition)(this.start, edit);
        if (changed.line || changed.character) {
            let { line, character } = this.start;
            this.start = vscode_languageserver_types_1.Position.create(line + changed.line, character + changed.character);
            this.end = (0, position_1.getEnd)(this.start, this._text);
        }
        return changed.character;
    }
    isBefore(range) {
        let { position } = range;
        let { line, character } = this.start;
        return position.line == line && position.character > character;
    }
}
exports.default = TextRange;
//# sourceMappingURL=textRange.js.map