'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.MruLoader = exports.Converter = exports.getReplaceRange = exports.getWord = exports.hasAction = exports.isSnippetItem = exports.emptLabelDetails = exports.highlightOffert = exports.shouldIndent = exports.isWordCode = exports.getInput = exports.shouldStop = exports.indentChanged = exports.createKindMap = exports.checkIgnoreRegexps = exports.getResumeInput = exports.getDocumentaions = exports.toCompleteDoneItem = exports.getDetail = exports.getPriority = exports.getKindHighlight = exports.getKindText = exports.useAscii = exports.Selection = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const chars_1 = require("../model/chars");
const parser_1 = require("../snippets/parser");
const array_1 = require("../util/array");
const constants_1 = require("../util/constants");
const Is = tslib_1.__importStar(require("../util/is"));
const map_1 = require("../util/map");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const string_1 = require("../util/string");
const types_1 = require("./types");
var Selection;
(function (Selection) {
    Selection["First"] = "first";
    Selection["RecentlyUsed"] = "recentlyUsed";
    Selection["RecentlyUsedByPrefix"] = "recentlyUsedByPrefix";
})(Selection = exports.Selection || (exports.Selection = {}));
const INVALID_WORD_CHARS = [10 /* CharCode.LineFeed */, 13 /* CharCode.CarriageReturn */];
const DollarSign = '$';
const QuestionMark = '?';
const MAX_CODE_POINT = 1114111;
const MAX_MRU_ITEMS = 100;
const DEFAULT_HL_GROUP = 'CocSymbolDefault';
const highlightsMap = {
    [vscode_languageserver_types_1.CompletionItemKind.Text]: 'CocSymbolText',
    [vscode_languageserver_types_1.CompletionItemKind.Method]: 'CocSymbolMethod',
    [vscode_languageserver_types_1.CompletionItemKind.Function]: 'CocSymbolFunction',
    [vscode_languageserver_types_1.CompletionItemKind.Constructor]: 'CocSymbolConstructor',
    [vscode_languageserver_types_1.CompletionItemKind.Field]: 'CocSymbolField',
    [vscode_languageserver_types_1.CompletionItemKind.Variable]: 'CocSymbolVariable',
    [vscode_languageserver_types_1.CompletionItemKind.Class]: 'CocSymbolClass',
    [vscode_languageserver_types_1.CompletionItemKind.Interface]: 'CocSymbolInterface',
    [vscode_languageserver_types_1.CompletionItemKind.Module]: 'CocSymbolModule',
    [vscode_languageserver_types_1.CompletionItemKind.Property]: 'CocSymbolProperty',
    [vscode_languageserver_types_1.CompletionItemKind.Unit]: 'CocSymbolUnit',
    [vscode_languageserver_types_1.CompletionItemKind.Value]: 'CocSymbolValue',
    [vscode_languageserver_types_1.CompletionItemKind.Enum]: 'CocSymbolEnum',
    [vscode_languageserver_types_1.CompletionItemKind.Keyword]: 'CocSymbolKeyword',
    [vscode_languageserver_types_1.CompletionItemKind.Snippet]: 'CocSymbolSnippet',
    [vscode_languageserver_types_1.CompletionItemKind.Color]: 'CocSymbolColor',
    [vscode_languageserver_types_1.CompletionItemKind.File]: 'CocSymbolFile',
    [vscode_languageserver_types_1.CompletionItemKind.Reference]: 'CocSymbolReference',
    [vscode_languageserver_types_1.CompletionItemKind.Folder]: 'CocSymbolFolder',
    [vscode_languageserver_types_1.CompletionItemKind.EnumMember]: 'CocSymbolEnumMember',
    [vscode_languageserver_types_1.CompletionItemKind.Constant]: 'CocSymbolConstant',
    [vscode_languageserver_types_1.CompletionItemKind.Struct]: 'CocSymbolStruct',
    [vscode_languageserver_types_1.CompletionItemKind.Event]: 'CocSymbolEvent',
    [vscode_languageserver_types_1.CompletionItemKind.Operator]: 'CocSymbolOperator',
    [vscode_languageserver_types_1.CompletionItemKind.TypeParameter]: 'CocSymbolTypeParameter',
};
function useAscii(input) {
    return input.length > 0 && input.charCodeAt(0) < constants_1.ASCII_END;
}
exports.useAscii = useAscii;
function getKindText(kind, kindMap, defaultKindText) {
    var _a;
    return Is.number(kind) ? (_a = kindMap.get(kind)) !== null && _a !== void 0 ? _a : defaultKindText : kind;
}
exports.getKindText = getKindText;
function getKindHighlight(kind) {
    var _a;
    return Is.number(kind) ? (_a = highlightsMap[kind]) !== null && _a !== void 0 ? _a : DEFAULT_HL_GROUP : DEFAULT_HL_GROUP;
}
exports.getKindHighlight = getKindHighlight;
function getPriority(source, defaultValue) {
    if (Is.number(source.priority)) {
        return source.priority;
    }
    return defaultValue;
}
exports.getPriority = getPriority;
function getDetail(item, filetype) {
    var _a;
    const { detail, labelDetails, label } = item;
    if (!(0, object_1.isEmpty)(labelDetails)) {
        let content = ((_a = labelDetails.detail) !== null && _a !== void 0 ? _a : '') + (labelDetails.description ? ` ${labelDetails.description}` : '');
        return { filetype: 'txt', content };
    }
    if (detail && detail !== label) {
        let isText = /^[\w-\s.,\t\n]+$/.test(detail);
        return { filetype: isText ? 'txt' : filetype, content: detail };
    }
    return undefined;
}
exports.getDetail = getDetail;
function toCompleteDoneItem(selected, item) {
    if (!item || !selected)
        return {};
    return Object.assign({
        word: selected.word,
        source: selected.source.name,
        user_data: `${selected.source.name}:0`
    }, item);
}
exports.toCompleteDoneItem = toCompleteDoneItem;
function getDocumentaions(completeItem, filetype, detailRendered = false) {
    let docs = [];
    if (Is.isCompletionItem(completeItem)) {
        let { documentation } = completeItem;
        if (!detailRendered) {
            let doc = getDetail(completeItem, filetype);
            if (doc)
                docs.push(doc);
        }
        if (documentation) {
            if (typeof documentation == 'string') {
                docs.push({ filetype: 'txt', content: documentation });
            }
            else if (documentation.value) {
                docs.push({
                    filetype: documentation.kind == 'markdown' ? 'markdown' : 'txt',
                    content: documentation.value
                });
            }
        }
    }
    else {
        if (completeItem.documentation) {
            docs = completeItem.documentation;
        }
        else if (completeItem.info) {
            docs.push({ content: completeItem.info, filetype: 'txt' });
        }
    }
    return docs;
}
exports.getDocumentaions = getDocumentaions;
function getResumeInput(option, pretext) {
    const { line, position } = option;
    const cursor = position.character;
    const pl = pretext.length;
    if (pl < cursor)
        return null;
    for (let i = 0; i < pl; i++) {
        if (i < cursor) {
            // should not change content before cursor.
            if (pretext.charCodeAt(i) !== line.charCodeAt(i)) {
                return null;
            }
            // should not have white space.
        }
        else if (pretext.charCodeAt(i) === 32 /* CharCode.Space */) {
            return null;
        }
    }
    return (0, string_1.byteSlice)(pretext, option.col);
}
exports.getResumeInput = getResumeInput;
function checkIgnoreRegexps(ignoreRegexps, input) {
    if (!ignoreRegexps || ignoreRegexps.length == 0 || input.length == 0)
        return false;
    return ignoreRegexps.some(regexp => {
        try {
            return new RegExp(regexp).test(input);
        }
        catch (e) {
            return false;
        }
    });
}
exports.checkIgnoreRegexps = checkIgnoreRegexps;
function createKindMap(labels) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    return new Map([
        [vscode_languageserver_types_1.CompletionItemKind.Text, (_a = labels['text']) !== null && _a !== void 0 ? _a : 'v'],
        [vscode_languageserver_types_1.CompletionItemKind.Method, (_b = labels['method']) !== null && _b !== void 0 ? _b : 'f'],
        [vscode_languageserver_types_1.CompletionItemKind.Function, (_c = labels['function']) !== null && _c !== void 0 ? _c : 'f'],
        [vscode_languageserver_types_1.CompletionItemKind.Constructor, typeof labels['constructor'] == 'function' ? 'f' : (_d = labels['con' + 'structor']) !== null && _d !== void 0 ? _d : ''],
        [vscode_languageserver_types_1.CompletionItemKind.Field, (_e = labels['field']) !== null && _e !== void 0 ? _e : 'm'],
        [vscode_languageserver_types_1.CompletionItemKind.Variable, (_f = labels['variable']) !== null && _f !== void 0 ? _f : 'v'],
        [vscode_languageserver_types_1.CompletionItemKind.Class, (_g = labels['class']) !== null && _g !== void 0 ? _g : 'C'],
        [vscode_languageserver_types_1.CompletionItemKind.Interface, (_h = labels['interface']) !== null && _h !== void 0 ? _h : 'I'],
        [vscode_languageserver_types_1.CompletionItemKind.Module, (_j = labels['module']) !== null && _j !== void 0 ? _j : 'M'],
        [vscode_languageserver_types_1.CompletionItemKind.Property, (_k = labels['property']) !== null && _k !== void 0 ? _k : 'm'],
        [vscode_languageserver_types_1.CompletionItemKind.Unit, (_l = labels['unit']) !== null && _l !== void 0 ? _l : 'U'],
        [vscode_languageserver_types_1.CompletionItemKind.Value, (_m = labels['value']) !== null && _m !== void 0 ? _m : 'v'],
        [vscode_languageserver_types_1.CompletionItemKind.Enum, (_o = labels['enum']) !== null && _o !== void 0 ? _o : 'E'],
        [vscode_languageserver_types_1.CompletionItemKind.Keyword, (_p = labels['keyword']) !== null && _p !== void 0 ? _p : 'k'],
        [vscode_languageserver_types_1.CompletionItemKind.Snippet, (_q = labels['snippet']) !== null && _q !== void 0 ? _q : 'S'],
        [vscode_languageserver_types_1.CompletionItemKind.Color, (_r = labels['color']) !== null && _r !== void 0 ? _r : 'v'],
        [vscode_languageserver_types_1.CompletionItemKind.File, (_s = labels['file']) !== null && _s !== void 0 ? _s : 'F'],
        [vscode_languageserver_types_1.CompletionItemKind.Reference, (_t = labels['reference']) !== null && _t !== void 0 ? _t : 'r'],
        [vscode_languageserver_types_1.CompletionItemKind.Folder, (_u = labels['folder']) !== null && _u !== void 0 ? _u : 'F'],
        [vscode_languageserver_types_1.CompletionItemKind.EnumMember, (_v = labels['enumMember']) !== null && _v !== void 0 ? _v : 'm'],
        [vscode_languageserver_types_1.CompletionItemKind.Constant, (_w = labels['constant']) !== null && _w !== void 0 ? _w : 'v'],
        [vscode_languageserver_types_1.CompletionItemKind.Struct, (_x = labels['struct']) !== null && _x !== void 0 ? _x : 'S'],
        [vscode_languageserver_types_1.CompletionItemKind.Event, (_y = labels['event']) !== null && _y !== void 0 ? _y : 'E'],
        [vscode_languageserver_types_1.CompletionItemKind.Operator, (_z = labels['operator']) !== null && _z !== void 0 ? _z : 'O'],
        [vscode_languageserver_types_1.CompletionItemKind.TypeParameter, (_0 = labels['typeParameter']) !== null && _0 !== void 0 ? _0 : 'T'],
    ]);
}
exports.createKindMap = createKindMap;
function indentChanged(event, cursor, line) {
    if (!event)
        return false;
    let pre = (0, string_1.byteSlice)(cursor[2], 0, cursor[1] - 1);
    if (pre.endsWith(event.word) && pre.match(/^\s*/)[0] != line.match(/^\s*/)[0]) {
        return true;
    }
    return false;
}
exports.indentChanged = indentChanged;
function shouldStop(bufnr, pretext, info, option) {
    let { pre } = info;
    if (pre.length === 0 || pre[pre.length - 1] === ' ' || pre.length < pretext.length)
        return true;
    if (option.bufnr != bufnr)
        return true;
    let text = (0, string_1.byteSlice)(option.line, 0, option.colnr - 1);
    if (option.linenr != info.lnum || !pre.startsWith(text))
        return true;
    return false;
}
exports.shouldStop = shouldStop;
function getInput(chars, pre, asciiCharactersOnly) {
    let len = 0;
    let prev;
    for (let i = pre.length - 1; i >= 0; i--) {
        let code = pre.charCodeAt(i);
        let word = isWordCode(chars, code, asciiCharactersOnly);
        if (!word || (prev !== undefined && !(0, chars_1.sameScope)(prev, code))) {
            break;
        }
        len += 1;
        prev = code;
    }
    return len == 0 ? '' : pre.slice(-len);
}
exports.getInput = getInput;
function isWordCode(chars, code, asciiCharactersOnly) {
    if (!chars.isKeywordCode(code))
        return false;
    if ((0, string_1.isLowSurrogate)(code))
        return false;
    if (asciiCharactersOnly && code >= 255)
        return false;
    return true;
}
exports.isWordCode = isWordCode;
function shouldIndent(indentkeys, pretext) {
    if (!indentkeys || pretext.trim().includes(' '))
        return false;
    for (let part of indentkeys.split(',')) {
        if (part.indexOf('=') > -1) {
            let [pre, post] = part.split('=');
            let word = post.startsWith('~') ? post.slice(1) : post;
            if (pretext.length < word.length ||
                (pretext.length > word.length && !/^\s/.test(pretext.slice(-word.length - 1)))) {
                continue;
            }
            let matched = post.startsWith('~') ? pretext.toLowerCase().endsWith(word) : pretext.endsWith(word);
            if (!matched) {
                continue;
            }
            if (pre == '')
                return true;
            if (pre == '0' && /^\s*$/.test(pretext.slice(0, pretext.length - word.length))) {
                return true;
            }
        }
    }
    return false;
}
exports.shouldIndent = shouldIndent;
function highlightOffert(pre, item) {
    let { filterText, abbr } = item;
    let idx = abbr.indexOf(filterText);
    if (idx == -1)
        return -1;
    let n = idx == 0 ? 0 : (0, string_1.byteIndex)(abbr, idx);
    return pre + n;
}
exports.highlightOffert = highlightOffert;
function emptLabelDetails(labelDetails) {
    if (!labelDetails)
        return true;
    return !labelDetails.detail && !labelDetails.description;
}
exports.emptLabelDetails = emptLabelDetails;
function isSnippetItem(item, itemDefaults) {
    var _a;
    let insertTextFormat = (_a = item.insertTextFormat) !== null && _a !== void 0 ? _a : itemDefaults.insertTextFormat;
    return insertTextFormat === vscode_languageserver_types_1.InsertTextFormat.Snippet;
}
exports.isSnippetItem = isSnippetItem;
/**
 * Snippet or have additionalTextEdits
 */
function hasAction(item, itemDefaults) {
    return isSnippetItem(item, itemDefaults) || !(0, array_1.isFalsyOrEmpty)(item.additionalTextEdits);
}
exports.hasAction = hasAction;
function toValidWord(snippet, excludes) {
    for (let i = 0; i < snippet.length; i++) {
        let code = snippet.charCodeAt(i);
        if (excludes.includes(code)) {
            return snippet.slice(0, i);
        }
    }
    return snippet;
}
function snippetToWord(text, kind) {
    if (kind === vscode_languageserver_types_1.CompletionItemKind.Function || kind === vscode_languageserver_types_1.CompletionItemKind.Method || kind === vscode_languageserver_types_1.CompletionItemKind.Class) {
        text = text.replace(/\(.+/, '');
    }
    if (!text.includes(DollarSign))
        return text;
    return toValidWord((new parser_1.SnippetParser()).text(text), INVALID_WORD_CHARS);
}
/**
 * Get the word to insert, it's the word to insert from range or input start position,
 * may not the actual word to insert
 */
function getWord(item, itemDefaults) {
    let { label, data, kind } = item;
    if (data && Is.string(data.word))
        return data.word;
    let textToInsert = item.textEdit ? item.textEdit.newText : item.insertText;
    if (!Is.string(textToInsert))
        return label;
    return isSnippetItem(item, itemDefaults) ? snippetToWord(textToInsert, kind) : toValidWord(textToInsert, INVALID_WORD_CHARS);
}
exports.getWord = getWord;
function getReplaceRange(item, itemDefaults, character, insertMode) {
    let editRange;
    if (item.textEdit) {
        editRange = vscode_languageserver_types_1.InsertReplaceEdit.is(item.textEdit) ? item.textEdit : item.textEdit.range;
    }
    else if (itemDefaults.editRange) {
        editRange = itemDefaults.editRange;
    }
    let range;
    if (editRange) {
        if (vscode_languageserver_types_1.Range.is(editRange)) {
            range = editRange;
        }
        else {
            range = insertMode == types_1.InsertMode.Insert ? editRange.insert : editRange.replace;
        }
    }
    // start character must contains character for completion
    if (range && Is.number(character) && range.start.character > character)
        range.start.character = character;
    return range;
}
exports.getReplaceRange = getReplaceRange;
class Converter {
    constructor(
    // input start character index
    inputStart, option, opt) {
        this.inputStart = inputStart;
        this.option = option;
        this.opt = opt;
        // cache the sliced text
        this.previousCache = new Map();
        this.postCache = new Map();
        this.minCharacter = Number.MAX_SAFE_INTEGER;
        this.character = opt.position.character;
        this.inputLen = opt.position.character - inputStart;
    }
    /**
     * Text before input to replace
     */
    getPrevious(character) {
        if (this.previousCache.has(character))
            return this.previousCache.get(character);
        let prev = this.opt.line.slice(character, this.inputStart);
        this.previousCache.set(character, prev);
        return prev;
    }
    /**
     * Text after cursor to replace
     */
    getAfter(character) {
        if (this.postCache.has(character))
            return this.postCache.get(character);
        let text = this.opt.line.slice(this.character, character);
        this.postCache.set(character, text);
        return text;
    }
    /**
     * Exclude follow characters to replace from end of word
     */
    fixFollow(word, isSnippet, endCharacter) {
        if (isSnippet || endCharacter <= this.character)
            return word;
        let toReplace = this.getAfter(endCharacter);
        if (word.length - this.inputLen > toReplace.length && word.endsWith(toReplace)) {
            return word.slice(0, -toReplace.length);
        }
        return word;
    }
    /**
     * Better filter text with prefix before input removed if exists.
     */
    getDelta(filterText, character) {
        if (character < this.inputStart) {
            let prev = this.getPrevious(character);
            if (filterText.startsWith(prev))
                return prev.length;
        }
        return 0;
    }
    convertToDurationItem(item) {
        if (Is.isCompletionItem(item)) {
            return this.convertLspCompleteItem(item);
        }
        else if (Is.string(item.word)) {
            return this.convertVimCompleteItem(item);
        }
        return undefined;
    }
    convertVimCompleteItem(item) {
        var _a, _b;
        const { option } = this;
        const { range, asciiMatch } = option;
        const word = (0, string_1.toText)(item.word);
        const character = range.start.character;
        this.minCharacter = Math.min(this.minCharacter, character);
        let filterText = (_a = item.filterText) !== null && _a !== void 0 ? _a : word;
        filterText = asciiMatch ? (0, node_1.unidecode)(filterText) : filterText, character;
        const delta = this.getDelta(filterText, character);
        return {
            word: this.fixFollow(word, item.isSnippet, range.end.character),
            abbr: (_b = item.abbr) !== null && _b !== void 0 ? _b : word,
            filterText,
            delta,
            character,
            dup: item.dup === 1,
            menu: item.menu,
            kind: item.kind,
            isSnippet: !!item.isSnippet,
            insertText: item.insertText,
            preselect: item.preselect,
            sortText: item.sortText,
            deprecated: item.deprecated,
            detail: item.detail,
            labelDetails: item.labelDetails,
            get source() {
                return option.source;
            },
            get priority() {
                var _a;
                return (_a = option.source.priority) !== null && _a !== void 0 ? _a : 99;
            },
            get shortcut() {
                return (0, string_1.toText)(option.source.shortcut);
            }
        };
    }
    convertLspCompleteItem(item) {
        var _a, _b, _c;
        const { option, inputStart } = this;
        const label = item.label.trim();
        const itemDefaults = (0, object_1.toObject)(option.itemDefaults);
        const word = getWord(item, itemDefaults);
        const range = (_a = getReplaceRange(item, itemDefaults, inputStart, this.option.insertMode)) !== null && _a !== void 0 ? _a : option.range;
        const character = range.start.character;
        const data = (0, object_1.toObject)(item.data);
        const filterText = (_b = item.filterText) !== null && _b !== void 0 ? _b : item.label;
        const delta = this.getDelta(filterText, character);
        let obj = {
            // the word to be insert from it's own character.
            word: this.fixFollow(word, isSnippetItem(item, itemDefaults), range.end.character),
            abbr: label,
            character,
            delta,
            kind: item.kind,
            detail: item.detail,
            sortText: item.sortText,
            filterText,
            preselect: item.preselect === true,
            deprecated: item.deprecated === true || ((_c = item.tags) === null || _c === void 0 ? void 0 : _c.includes(vscode_languageserver_types_1.CompletionItemTag.Deprecated)),
            isSnippet: hasAction(item, itemDefaults),
            get source() {
                return option.source;
            },
            get priority() {
                return option.priority;
            },
            get shortcut() {
                return (0, string_1.toText)(option.source.shortcut);
            },
            dup: data.dup !== 0
        };
        this.minCharacter = Math.min(this.minCharacter, character);
        if (data.optional && !obj.abbr.endsWith(QuestionMark))
            obj.abbr += QuestionMark;
        if (!emptLabelDetails(item.labelDetails))
            obj.labelDetails = item.labelDetails;
        if (Is.number(item['score']) && !obj.sortText)
            obj.sortText = String.fromCodePoint(MAX_CODE_POINT - Math.round(item['score']));
        return obj;
    }
}
exports.Converter = Converter;
function toItemKey(item) {
    var _a;
    let label = item.filterText;
    let source = item.source.name;
    let kind = (_a = item.kind) !== null && _a !== void 0 ? _a : '';
    return `${label}|${source}|${kind}`;
}
class MruLoader {
    constructor() {
        this.max = 0;
        this.items = new map_1.LRUCache(MAX_MRU_ITEMS);
        this.itemsNoPrefex = new map_1.LRUCache(MAX_MRU_ITEMS);
    }
    getScore(input, item, selection) {
        var _a, _b;
        let key = toItemKey(item);
        if (input.length == 0)
            return (_a = this.itemsNoPrefex.get(key)) !== null && _a !== void 0 ? _a : -1;
        if (selection === Selection.RecentlyUsedByPrefix)
            key = `${input}|${key}`;
        let map = selection === Selection.RecentlyUsed ? this.itemsNoPrefex : this.items;
        return (_b = map.get(key)) !== null && _b !== void 0 ? _b : -1;
    }
    add(prefix, item) {
        if (!Is.number(item.kind))
            return;
        let key = toItemKey(item);
        if (!item.filterText.startsWith(prefix)) {
            prefix = '';
        }
        let line = `${prefix}|${key}`;
        this.items.set(line, this.max);
        this.itemsNoPrefex.set(key, this.max);
        this.max += 1;
    }
    clear() {
        this.max = 0;
        this.items.clear();
        this.itemsNoPrefex.clear();
    }
}
exports.MruLoader = MruLoader;
//# sourceMappingURL=util.js.map