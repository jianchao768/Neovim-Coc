'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortItems = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const filter_1 = require("../util/filter");
const Is = tslib_1.__importStar(require("../util/is"));
const numbers_1 = require("../util/numbers");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const types_1 = require("./types");
const util_2 = require("./util");
const wordDistance_1 = require("./wordDistance");
const logger = (0, logger_1.createLogger)('completion-complete');
const MAX_DISTANCE = 2 << 20;
const MIN_TIMEOUT = 50;
const MAX_TIMEOUT = 5000;
const MAX_TRIGGER_WAIT = 200;
class Complete {
    constructor(option, document, config, sources) {
        this.option = option;
        this.document = document;
        this.config = config;
        this.sources = sources;
        // identify this complete
        this.results = new Map();
        this._input = '';
        this._completing = false;
        this.names = [];
        this.cid = 0;
        this.minCharacter = Number.MAX_SAFE_INTEGER;
        this._onDidRefresh = new protocol_1.Emitter();
        this.tokenSources = new Set();
        this.tokensInfo = new WeakMap();
        this.itemsMap = new WeakMap();
        this.onDidRefresh = this._onDidRefresh.event;
        this.inputStart = (0, string_1.characterIndex)(option.line, option.col);
        this.timeout = (0, numbers_1.clamp)(this.config.timeout, MIN_TIMEOUT, MAX_TIMEOUT);
        sources.sort((a, b) => { var _a, _b; return ((_a = b.priority) !== null && _a !== void 0 ? _a : 99) - ((_b = a.priority) !== null && _b !== void 0 ? _b : 99); });
        this.names = sources.map(o => o.name);
        this.asciiMatch = config.asciiMatch && (0, util_2.useAscii)(option.input);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    fireRefresh(waitTime) {
        clearTimeout(this.timer);
        if (!waitTime) {
            this._onDidRefresh.fire();
        }
        else {
            this.timer = setTimeout(() => {
                this._onDidRefresh.fire();
            }, waitTime);
        }
    }
    get totalLength() {
        let len = 0;
        for (let result of this.results.values()) {
            len += result.items.length;
        }
        return len;
    }
    resolveItem(item) {
        if (!item)
            return undefined;
        return { source: item.source, item: this.itemsMap.get(item) };
    }
    get isCompleting() {
        return this._completing;
    }
    get input() {
        return this._input;
    }
    get isEmpty() {
        return this.results.size === 0;
    }
    get hasInComplete() {
        for (let result of this.results.values()) {
            if (result.isIncomplete)
                return true;
        }
        return false;
    }
    getIncompleteSources() {
        return this.sources.filter(s => {
            let res = this.results.get(s.name);
            return res && res.isIncomplete === true;
        });
    }
    async doComplete() {
        let tokenSource = this.createTokenSource(false);
        let token = tokenSource.token;
        let res = await Promise.all([
            this.nvim.call('coc#util#synname', []),
            this.nvim.call('coc#util#suggest_variables', [this.option.bufnr]),
            this.document.patchChange()
        ]);
        if (token.isCancellationRequested)
            return;
        this.option.synname = res[0];
        let variables = res[1];
        if (variables.disable) {
            logger.warn('suggest cancelled by b:coc_suggest_disable');
            return true;
        }
        if (!(0, array_1.isFalsyOrEmpty)(variables.disabled_sources)) {
            this.sources = this.sources.filter(s => !variables.disabled_sources.includes(s.name));
            if (this.sources.length === 0) {
                logger.warn('suggest cancelled by b:coc_disabled_sources');
                return true;
            }
        }
        if (!(0, array_1.isFalsyOrEmpty)(variables.blacklist) && variables.blacklist.includes(this.option.input)) {
            logger.warn('suggest cancelled by b:coc_suggest_blacklist');
            return true;
        }
        void wordDistance_1.WordDistance.create(this.config.localityBonus, this.option, token).then(instance => {
            this.wordDistance = instance;
        });
        await (0, util_1.waitWithToken)((0, numbers_1.clamp)(this.config.triggerCompletionWait, 0, MAX_TRIGGER_WAIT), tokenSource.token);
        await this.completeSources(this.sources, tokenSource, this.cid);
    }
    async completeSources(sources, tokenSource, cid) {
        const token = tokenSource.token;
        if (token.isCancellationRequested)
            return;
        this._completing = true;
        const remains = new Set();
        sources.forEach(s => remains.add(s.name));
        let timer;
        let disposable;
        let tp = new Promise(resolve => {
            disposable = token.onCancellationRequested(() => {
                clearTimeout(timer);
                resolve();
            });
            timer = setTimeout(() => {
                let names = Array.from(remains);
                disposable.dispose();
                tokenSource.cancel();
                logger.warn(`Completion timeout after ${this.timeout}ms`, names);
                this.nvim.setVar(`coc_timeout_sources`, names, true);
                resolve();
            }, this.timeout);
        });
        // default insert or replace range
        const range = this.getDefaultRange();
        let promises = sources.map(s => this.completeSource(s, range, token).then(added => {
            remains.delete(s.name);
            if (token.isCancellationRequested || cid != 0 || (this.cid > 0 && this._completing))
                return;
            if (remains.size === 0) {
                this.fireRefresh(0);
            }
            else if (added) {
                this.fireRefresh(16);
            }
        }));
        await Promise.race([tp, Promise.allSettled(promises)]);
        this.tokenSources.delete(tokenSource);
        disposable.dispose();
        clearTimeout(timer);
        if (cid === this.cid)
            this._completing = false;
    }
    async completeSource(source, range, token) {
        // new option for each source
        let opt = Object.assign({}, this.option);
        let { asciiMatch } = this;
        const insertMode = this.config.insertMode;
        const sourceName = source.name;
        let added = false;
        try {
            if (Is.func(source.shouldComplete)) {
                let shouldRun = await Promise.resolve(source.shouldComplete(opt));
                if (!shouldRun || token.isCancellationRequested)
                    return;
            }
            const start = Date.now();
            const map = this.itemsMap;
            await new Promise((resolve, reject) => {
                Promise.resolve(source.doComplete(opt, token)).then(result => {
                    if (token.isCancellationRequested) {
                        resolve(undefined);
                        return;
                    }
                    let len = result ? result.items.length : 0;
                    logger.debug(`Source "${sourceName}" finished with ${len} items ms cost:`, Date.now() - start);
                    if (len > 0) {
                        if (Is.number(result.startcol)) {
                            let line = opt.linenr - 1;
                            range = vscode_languageserver_types_1.Range.create(line, (0, string_1.characterIndex)(opt.line, result.startcol), line, range.end.character);
                        }
                        const priority = (0, util_2.getPriority)(source, this.config.languageSourcePriority);
                        const option = { source, insertMode, priority, asciiMatch, itemDefaults: result.itemDefaults, range };
                        const converter = new util_2.Converter(this.inputStart, option, opt);
                        const items = result.items.reduce((items, item) => {
                            let completeItem = converter.convertToDurationItem(item);
                            if (!completeItem) {
                                logger.error(`Unexpected completion item from ${sourceName}:`, item);
                                return items;
                            }
                            map.set(completeItem, item);
                            items.push(completeItem);
                            return items;
                        }, []);
                        this.minCharacter = Math.min(this.minCharacter, converter.minCharacter);
                        this.results.set(sourceName, { items, isIncomplete: result.isIncomplete === true });
                        added = true;
                    }
                    else {
                        this.results.delete(sourceName);
                    }
                    resolve();
                }, err => {
                    reject(err);
                });
            });
        }
        catch (err) {
            // this.nvim.echoError(err)
            logger.error('Complete error:', source.name, err);
        }
        return added;
    }
    async completeInComplete(resumeInput) {
        let { document } = this;
        this.cancelInComplete();
        let tokenSource = this.createTokenSource(true);
        let token = tokenSource.token;
        await document.patchChange(true);
        let { input, colnr, linenr, followWord, position } = this.option;
        Object.assign(this.option, {
            word: resumeInput + followWord,
            input: resumeInput,
            line: document.getline(linenr - 1),
            position: { line: position.line, character: position.character + resumeInput.length - input.length },
            colnr: colnr + (resumeInput.length - input.length),
            triggerCharacter: undefined,
            triggerForInComplete: true
        });
        this.cid++;
        const sources = this.getIncompleteSources();
        await this.completeSources(sources, tokenSource, this.cid);
        if (token.isCancellationRequested)
            return undefined;
        return this.filterItems(resumeInput);
    }
    filterItems(input) {
        let { results, names, option, inputStart } = this;
        this._input = input;
        let len = input.length;
        let { maxItemCount, defaultSortMethod, removeDuplicateItems } = this.config;
        let arr = [];
        let words = new Set();
        const emptyInput = len == 0;
        const lowInput = input.toLowerCase();
        const scoreFn = (!this.config.filterGraceful || this.totalLength > 2000) ? filter_1.fuzzyScore : filter_1.fuzzyScoreGracefulAggressive;
        const scoreOption = { boostFullMatch: true, firstMatchCanBeWeak: false };
        const anchor = vscode_languageserver_types_1.Position.create(option.linenr - 1, inputStart);
        for (let name of names) {
            let result = results.get(name);
            if (!result)
                continue;
            let items = result.items;
            for (let idx = 0; idx < items.length; idx++) {
                let item = items[idx];
                let { word, filterText, dup } = item;
                if (dup !== true && words.has(word))
                    continue;
                if (removeDuplicateItems && item.isSnippet !== true && words.has(word))
                    continue;
                let fuzzyResult;
                if (!emptyInput) {
                    scoreOption.firstMatchCanBeWeak = item.delta === 0 && item.character !== inputStart;
                    if (item.delta > 0) {
                        // better input to make it have higher score and better highlight
                        let prev = filterText.slice(0, item.delta);
                        fuzzyResult = scoreFn(prev + input, prev + lowInput, 0, filterText, filterText.toLowerCase(), 0, scoreOption);
                    }
                    else {
                        fuzzyResult = scoreFn(input, lowInput, 0, filterText, filterText.toLowerCase(), 0, scoreOption);
                    }
                    if (fuzzyResult == null)
                        continue;
                    item.score = fuzzyResult[0];
                    item.positions = fuzzyResult;
                    if (this.wordDistance)
                        item.localBonus = MAX_DISTANCE - this.wordDistance.distance(anchor, item);
                }
                else if (item.character < inputStart) {
                    let trigger = option.line.slice(item.character, inputStart);
                    scoreOption.firstMatchCanBeWeak = true;
                    fuzzyResult = (0, filter_1.anyScore)(trigger, trigger.toLowerCase(), 0, filterText, filterText.toLowerCase(), 0, scoreOption);
                    item.score = fuzzyResult[0];
                    item.positions = fuzzyResult;
                }
                else {
                    item.score = 0;
                }
                words.add(word);
                arr.push(item);
            }
        }
        arr.sort(sortItems.bind(null, emptyInput, defaultSortMethod));
        return this.limitCompleteItems(arr.slice(0, maxItemCount));
    }
    async filterResults(input) {
        clearTimeout(this.timer);
        if (input !== this.option.input && this.hasInComplete) {
            return await this.completeInComplete(input);
        }
        return this.filterItems(input);
    }
    limitCompleteItems(items) {
        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
        if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
            return items;
        let counts = new Map();
        return items.filter(item => {
            let { priority, source } = item;
            let isLow = priority < 90;
            let curr = counts.get(source) || 0;
            if ((lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit)
                || (highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit)) {
                return false;
            }
            counts.set(source, curr + 1);
            return true;
        });
    }
    getDefaultRange() {
        let { insertMode } = this.config;
        let { linenr, followWord, position } = this.option;
        let line = linenr - 1;
        let end = position.character + (insertMode == types_1.InsertMode.Repalce ? followWord.length : 0);
        return vscode_languageserver_types_1.Range.create(line, this.inputStart, line, end);
    }
    createTokenSource(isIncomplete) {
        let tokenSource = new protocol_1.CancellationTokenSource();
        this.tokenSources.add(tokenSource);
        tokenSource.token.onCancellationRequested(() => {
            this.tokenSources.delete(tokenSource);
        });
        this.tokensInfo.set(tokenSource, isIncomplete);
        return tokenSource;
    }
    cancelInComplete() {
        let { tokenSources, tokensInfo } = this;
        for (let tokenSource of Array.from(tokenSources)) {
            if (tokensInfo.get(tokenSource) === true) {
                tokenSource.cancel();
            }
        }
    }
    cancel() {
        let { tokenSources, timer } = this;
        clearTimeout(timer);
        for (let tokenSource of Array.from(tokenSources)) {
            tokenSource.cancel();
        }
        tokenSources.clear();
        this._completing = false;
    }
    dispose() {
        this.cancel();
        this.results.clear();
        this._onDidRefresh.dispose();
    }
}
exports.default = Complete;
function sortItems(emptyInput, defaultSortMethod, a, b) {
    let sa = a.sortText;
    let sb = b.sortText;
    if (a.score !== b.score)
        return b.score - a.score;
    if (a.priority !== b.priority)
        return b.priority - a.priority;
    if (a.source === b.source && sa !== sb)
        return sa < sb ? -1 : 1;
    if (a.localBonus !== b.localBonus)
        return b.localBonus - a.localBonus;
    // not sort with empty input, the item not replace trigger have higher priority
    if (emptyInput)
        return b.character - a.character;
    switch (defaultSortMethod) {
        case types_1.SortMethod.None:
            return 0;
        case types_1.SortMethod.Alphabetical:
            return a.filterText.localeCompare(b.filterText);
        case types_1.SortMethod.Length:
        default: // Fallback on length
            return a.filterText.length - b.filterText.length;
    }
}
exports.sortItems = sortItems;
//# sourceMappingURL=complete.js.map