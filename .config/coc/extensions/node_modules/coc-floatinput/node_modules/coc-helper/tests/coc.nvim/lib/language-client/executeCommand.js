'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecuteCommandFeature = void 0;
const tslib_1 = require("tslib");
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
class ExecuteCommandFeature extends features_1.BaseFeature {
    constructor(client) {
        super(client);
        this._commands = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._commands.size > 0 };
    }
    get registrationType() {
        return protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
            const params = {
                command,
                arguments: args
            };
            return this.sendRequest(protocol_1.ExecuteCommandRequest.type, params, protocol_1.CancellationToken.None);
        };
        if (data.registerOptions.commands) {
            let disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(commands_1.default.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }, null, true));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach(value => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
exports.ExecuteCommandFeature = ExecuteCommandFeature;
//# sourceMappingURL=executeCommand.js.map