'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const manager_1 = tslib_1.__importDefault(require("./manager"));
class SemanticTokensManager extends manager_1.default {
    register(selector, provider, legend) {
        return this.addProvider({
            id: (0, uuid_1.v4)(),
            selector,
            provider,
            legend,
        });
    }
    getLegend(document) {
        const item = this.getProvider(document);
        if (!item)
            return;
        return item.legend;
    }
    hasSemanticTokensEdits(document) {
        var _a;
        let provider = (_a = this.getProvider(document)) === null || _a === void 0 ? void 0 : _a.provider;
        if (!provider)
            return false;
        return (typeof provider.provideDocumentSemanticTokensEdits === 'function');
    }
    async provideDocumentSemanticTokens(document, token) {
        var _a;
        let provider = (_a = this.getProvider(document)) === null || _a === void 0 ? void 0 : _a.provider;
        if (!provider || typeof provider.provideDocumentSemanticTokens !== 'function')
            return null;
        return await Promise.resolve(provider.provideDocumentSemanticTokens(document, token));
    }
    async provideDocumentSemanticTokensEdits(document, previousResultId, token) {
        let item = this.getProvider(document);
        if (!item || typeof item.provider.provideDocumentSemanticTokensEdits !== 'function')
            return null;
        return await Promise.resolve(item.provider.provideDocumentSemanticTokensEdits(document, previousResultId, token));
    }
}
exports.default = SemanticTokensManager;
//# sourceMappingURL=semanticTokensManager.js.map