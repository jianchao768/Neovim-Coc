'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeTextEdits = exports.getChangedLineCount = exports.getPositionFromEdits = exports.getPosition = exports.getChangedPosition = exports.toTextChanges = exports.applyEdits = exports.filterSortEdits = exports.toDocumentChanges = exports.getAnnotationKey = exports.createFilteredChanges = exports.isDeniedEdit = exports.getConfirmAnnotations = exports.getRangesFromEdit = exports.emptyWorkspaceEdit = exports.emptyTextEdit = exports.mergeSortEdits = exports.getWellformedEdit = exports.getWellformedRange = exports.lineCountChange = exports.getStartLine = void 0;
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const array_1 = require("./array");
const object_1 = require("./object");
const position_1 = require("./position");
const string_1 = require("./string");
function getStartLine(edit) {
    let { start, end } = edit.range;
    if (edit.newText.endsWith('\n') && start.line == end.line && start.character == 0 && end.character == 0) {
        return start.line - 1;
    }
    return start.line;
}
exports.getStartLine = getStartLine;
function lineCountChange(edit) {
    let { newText } = edit;
    let range = getWellformedRange(edit.range);
    let n = range.end.line - range.start.line;
    return newText.split(/\r?\n/).length - n - 1;
}
exports.lineCountChange = lineCountChange;
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
exports.getWellformedRange = getWellformedRange;
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range };
    }
    return textEdit;
}
exports.getWellformedEdit = getWellformedEdit;
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = (data.length / 2) | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        let ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function mergeSortEdits(edits) {
    return mergeSort(edits, (a, b) => {
        let diff = a.range.start.line - b.range.start.line;
        if (diff === 0) {
            return a.range.start.character - b.range.start.character;
        }
        return diff;
    });
}
exports.mergeSortEdits = mergeSortEdits;
function emptyTextEdit(edit) {
    return (0, position_1.emptyRange)(edit.range) && edit.newText.length === 0;
}
exports.emptyTextEdit = emptyTextEdit;
function emptyWorkspaceEdit(edit) {
    let { changes, documentChanges } = edit;
    if (documentChanges && documentChanges.length)
        return false;
    if (changes && Object.keys(changes).length)
        return false;
    return true;
}
exports.emptyWorkspaceEdit = emptyWorkspaceEdit;
function getRangesFromEdit(uri, edit) {
    let { changes, documentChanges } = edit;
    if (changes) {
        let edits = changes[uri];
        return edits ? edits.map(e => e.range) : undefined;
    }
    else if (Array.isArray(documentChanges)) {
        for (let c of documentChanges) {
            if (vscode_languageserver_types_1.TextDocumentEdit.is(c) && c.textDocument.uri == uri) {
                return c.edits.map(e => e.range);
            }
        }
    }
    return undefined;
}
exports.getRangesFromEdit = getRangesFromEdit;
function getConfirmAnnotations(changes, changeAnnotations) {
    let keys = [];
    const add = (key) => {
        var _a;
        if (key && !keys.includes(key) && ((_a = changeAnnotations[key]) === null || _a === void 0 ? void 0 : _a.needsConfirmation))
            keys.push(key);
    };
    for (let change of changes) {
        if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
            change.edits.forEach(edit => {
                add(edit['annotationId']);
            });
        }
        else {
            add(change.annotationId);
        }
    }
    return keys;
}
exports.getConfirmAnnotations = getConfirmAnnotations;
function isDeniedEdit(edit, denied) {
    if (vscode_languageserver_types_1.AnnotatedTextEdit.is(edit) && denied.includes(edit.annotationId))
        return true;
    return false;
}
exports.isDeniedEdit = isDeniedEdit;
/**
 * Create new changes with denied filtered
 */
function createFilteredChanges(documentChanges, denied) {
    let changes = [];
    documentChanges.forEach(change => {
        if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
            let edits = change.edits.filter(edit => {
                return !isDeniedEdit(edit, denied);
            });
            if (edits.length > 0) {
                changes.push({ textDocument: change.textDocument, edits });
            }
        }
        else if (!denied.includes(change.annotationId)) {
            changes.push(change);
        }
    });
    return changes;
}
exports.createFilteredChanges = createFilteredChanges;
function getAnnotationKey(change) {
    let key;
    if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
        if (vscode_languageserver_types_1.AnnotatedTextEdit.is(change.edits[0])) {
            key = change.edits[0].annotationId;
        }
    }
    else {
        key = change.annotationId;
    }
    return key;
}
exports.getAnnotationKey = getAnnotationKey;
function toDocumentChanges(edit) {
    if (edit.documentChanges)
        return edit.documentChanges;
    let changes = [];
    for (let [uri, edits] of Object.entries((0, object_1.toObject)(edit.changes))) {
        changes.push({ textDocument: { uri, version: null }, edits });
    }
    return changes;
}
exports.toDocumentChanges = toDocumentChanges;
/**
 * Filter unnessary edits and fix edits.
 */
function filterSortEdits(textDocument, edits) {
    var _a;
    let res = [];
    let end = textDocument.end;
    let checkEnd = end.line > 0 && end.character == 0;
    let prevDelete;
    for (let i = 0; i < edits.length; i++) {
        let edit = edits[i];
        let { newText, range } = edit;
        let max = ((_a = textDocument.lines[range.end.line]) !== null && _a !== void 0 ? _a : '').length;
        range = (0, position_1.toValidRange)(edit.range, max);
        if (prevDelete) {
            // merge possible delete, insert edits.
            if ((0, position_1.samePosition)(prevDelete, range.start) && (0, position_1.emptyRange)(range) && newText.length > 0) {
                let last = res[res.length - 1];
                last.newText = newText;
                prevDelete = undefined;
                continue;
            }
            prevDelete = undefined;
        }
        if (newText.includes('\r'))
            newText = newText.replace(/\r\n/g, '\n');
        let d = (0, position_1.comparePosition)(range.end, end);
        if (d > 0)
            range.end = { line: end.line, character: end.character };
        if (textDocument.getText(range) !== newText) {
            // Adjust textEdit to make it acceptable by nvim_buf_set_text
            if (d === 0 && checkEnd && !(0, position_1.emptyRange)(range) && newText.endsWith('\n')) {
                newText = newText.slice(0, -1);
                let text = textDocument.lines[end.line - 1];
                range.end = vscode_languageserver_types_1.Position.create(end.line - 1, text.length);
            }
            else if (newText.length == 0) {
                prevDelete = range.start;
            }
            res.push({ range, newText });
        }
    }
    return mergeSortEdits(res);
}
exports.filterSortEdits = filterSortEdits;
/**
 * Apply valid & sorted edits
 */
function applyEdits(document, edits) {
    var _a, _b;
    if ((0, array_1.isFalsyOrEmpty)(edits))
        return undefined;
    if (edits.length == 1) {
        let { start, end } = edits[0].range;
        let { lines } = document;
        let sl = (_a = lines[start.line]) !== null && _a !== void 0 ? _a : '';
        let el = (_b = lines[end.line]) !== null && _b !== void 0 ? _b : '';
        let content = sl.substring(0, start.character) + edits[0].newText + el.substring(end.character);
        if (end.line >= lines.length && document.eol) {
            if (content == '')
                return [...lines.slice(0, start.line)];
            if (content.endsWith('\n'))
                content = content.slice(0, -1);
            return [...lines.slice(0, start.line), ...content.split('\n')];
        }
        return [...lines.slice(0, start.line), ...content.split('\n'), ...lines.slice(end.line + 1)];
    }
    let text = document.getText();
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of edits) {
        let startOffset = document.offsetAt(e.range.start);
        if (startOffset < lastModifiedOffset) {
            throw new Error('Overlapping edit');
        }
        else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
        }
        if (e.newText.length) {
            spans.push(e.newText);
        }
        lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text.substring(lastModifiedOffset));
    let result = spans.join('');
    if (result === text)
        return undefined;
    return (0, string_1.contentToLines)(result, document.eol);
}
exports.applyEdits = applyEdits;
function toTextChanges(lines, edits) {
    return edits.map(o => {
        let { start, end } = o.range;
        let sl = (0, string_1.toText)(lines[start.line]);
        let sc = (0, string_1.byteIndex)(sl, start.character);
        let el = end.line == start.line ? sl : (0, string_1.toText)(lines[end.line]);
        let ec = (0, string_1.byteIndex)(el, end.character);
        let { newText } = o;
        return [newText.length > 0 ? newText.split('\n') : [], start.line, sc, end.line, ec];
    });
}
exports.toTextChanges = toTextChanges;
function getChangedPosition(start, edit) {
    let { range, newText } = edit;
    if ((0, position_1.comparePosition)(range.end, start) <= 0) {
        let lines = newText.split('\n');
        let lineCount = lines.length - (range.end.line - range.start.line) - 1;
        let character = start.character;
        if (range.end.line == start.line) {
            let last = lines[lines.length - 1].length;
            if (lines.length > 1) {
                character = last + character - range.end.character;
            }
            else {
                character = range.start.character + last + character - range.end.character;
            }
        }
        return { line: lineCount, character: character - start.character };
    }
    return { line: 0, character: 0 };
}
exports.getChangedPosition = getChangedPosition;
function getPosition(start, edit) {
    let { line, character } = start;
    let { range, newText } = edit;
    let { end } = range;
    let lines = newText.split('\n');
    let lineCount = lines.length - (end.line - range.start.line) - 1;
    let c = range.end.line - start.line;
    if (c > 0)
        return { line, character };
    if (c < 0)
        return { line: line + lineCount, character };
    if (lines.length > 1) {
        let last = lines[lines.length - 1].length;
        return { line: line + lineCount, character: last + character - end.character };
    }
    let d = range.start.character - range.end.character;
    return { line: line + lineCount, character: d + newText.length + character };
}
exports.getPosition = getPosition;
/**
 * Get new position from sorted edits
 */
function getPositionFromEdits(start, edits) {
    let position = vscode_languageserver_types_1.Position.create(start.line, start.character);
    let before = false;
    for (let i = edits.length - 1; i >= 0; i--) {
        let edit = edits[i];
        if (before) {
            position.line += lineCountChange(edit);
            continue;
        }
        let d = (0, position_1.comparePosition)(edit.range.end, position);
        if (d > 0)
            continue;
        if (edit.range.end.line == position.line) {
            position = getPosition(position, edit);
        }
        else {
            before = true;
            position.line += lineCountChange(edit);
        }
    }
    return position;
}
exports.getPositionFromEdits = getPositionFromEdits;
function getChangedLineCount(start, edits) {
    let total = 0;
    for (let edit of edits) {
        let r = getWellformedRange(edit.range);
        if ((0, position_1.comparePosition)(r.end, start) <= 0) {
            total += lineCountChange(edit);
        }
    }
    return total;
}
exports.getChangedLineCount = getChangedLineCount;
/**
 * Merge sorted edits to single textedit
 */
function mergeTextEdits(edits, oldLines, newLines) {
    var _a, _b;
    let start = edits[0].range.start;
    let end = edits[edits.length - 1].range.end;
    let lr = oldLines.length - end.line;
    let cr = ((_a = oldLines[end.line]) !== null && _a !== void 0 ? _a : '').length - end.character;
    let line = newLines.length - lr;
    let character = ((_b = newLines[line]) !== null && _b !== void 0 ? _b : '').length - cr;
    let newText = getText(start, vscode_languageserver_types_1.Position.create(line, character), newLines);
    return vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(start, end), newText);
}
exports.mergeTextEdits = mergeTextEdits;
function getText(start, end, lines) {
    var _a;
    if (start.line === end.line) {
        return (0, string_1.toText)(lines[start.line]).slice(start.character, end.character);
    }
    let spans = [];
    for (let i = start.line; i <= end.line; i++) {
        let s = (_a = lines[i]) !== null && _a !== void 0 ? _a : '';
        if (i === start.line) {
            spans.push(s.slice(start.character));
        }
        else if (i === end.line) {
            spans.push(s.slice(0, end.character));
        }
        else {
            spans.push(s);
        }
    }
    return spans.join('\n');
}
//# sourceMappingURL=textedit.js.map