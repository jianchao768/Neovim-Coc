'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.terminate = exports.runCommand = exports.executable = exports.isRunning = void 0;
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const node_1 = require("./node");
const platform_1 = require("./platform");
function isRunning(pid) {
    try {
        let res = process.kill(pid, 0);
        return res == true;
    }
    catch (e) {
        return e['code'] === 'EPERM';
    }
}
exports.isRunning = isRunning;
function executable(command) {
    try {
        node_1.which.sync(command);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.executable = executable;
function runCommand(cmd, opts = {}, timeout, isWindows = platform_1.platform === platform_1.Platform.Windows) {
    if (!isWindows) {
        opts.shell = opts.shell || process.env.SHELL;
    }
    opts.maxBuffer = 500 * 1024;
    return new Promise((resolve, reject) => {
        let timer;
        let cp;
        if (timeout) {
            timer = setTimeout(() => {
                cp.kill('SIGKILL');
                reject(new errors_1.CancellationError());
            }, timeout * 1000);
        }
        cp = node_1.child_process.exec(cmd, opts, (err, stdout, stderr) => {
            if (timer)
                clearTimeout(timer);
            if (err) {
                reject(new Error(`exited with ${err.code}\n${err}\n${stderr}`));
                return;
            }
            resolve(stdout);
        });
    });
}
exports.runCommand = runCommand;
function terminate(process, cwd, pt = platform_1.platform) {
    if (process.killed)
        return;
    if (pt === platform_1.Platform.Windows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd)
                options.cwd = cwd;
            node_1.child_process.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (pt === platform_1.Platform.Linux || pt === platform_1.Platform.Mac) {
        try {
            let filepath = node_1.path.join(constants_1.pluginRoot, 'bin/terminateProcess.sh');
            let result = node_1.child_process.spawnSync(filepath, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;
//# sourceMappingURL=processes.js.map