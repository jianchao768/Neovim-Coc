'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.contentToItems = exports.loadCtagsSymbols = exports.getFilterText = exports.symbolsToListItems = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const array_1 = require("../../util/array");
const convert_1 = require("../../util/convert");
const fs_1 = require("../../util/fs");
const node_1 = require("../../util/node");
const position_1 = require("../../util/position");
const processes_1 = require("../../util/processes");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const formatting_1 = require("../formatting");
const location_1 = tslib_1.__importDefault(require("./location"));
class Outline extends location_1.default {
    constructor() {
        super(...arguments);
        this.description = 'symbols of current document';
        this.name = 'outline';
        this.options = [{
                name: '-k, -kind KIND',
                hasValue: true,
                description: 'filter symbol by kind',
            }];
    }
    async loadItems(context, token) {
        let document = workspace_1.default.getAttachedDocument(context.buffer.id);
        let config = this.getConfig();
        let ctagsFiletypes = config.get('ctagsFiletypes', []);
        let symbols;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toString().toLowerCase() : null;
        if (!ctagsFiletypes.includes(document.filetype)) {
            symbols = await languages_1.default.getDocumentSymbol(document.textDocument, token);
        }
        if (token.isCancellationRequested)
            return [];
        if (!symbols)
            return await loadCtagsSymbols(document, this.nvim);
        if ((0, array_1.isFalsyOrEmpty)(symbols))
            return [];
        let items = symbolsToListItems(symbols, document.uri, filterKind);
        return (0, formatting_1.formatListItems)(this.alignColumns, items);
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine', true);
        nvim.command('syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName', true);
        nvim.command('syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine', true);
        nvim.command('syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine', true);
        nvim.command('highlight default link CocOutlineName Normal', true);
        nvim.command('highlight default link CocOutlineIndentLine Comment', true);
        nvim.command('highlight default link CocOutlineKind Typedef', true);
        nvim.command('highlight default link CocOutlineLine Comment', true);
        nvim.resumeNotification(false, true);
    }
}
exports.default = Outline;
function symbolsToListItems(symbols, uri, filterKind) {
    let items = [];
    const addSymbols = (symbols, level = 0) => {
        symbols.sort((a, b) => {
            return (0, position_1.compareRangesUsingStarts)(a.selectionRange, b.selectionRange);
        });
        for (let s of symbols) {
            let kind = (0, convert_1.getSymbolKind)(s.kind);
            let location = vscode_languageserver_types_1.Location.create(uri, s.selectionRange);
            items.push({
                label: [`${'| '.repeat(level)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
                filterText: getFilterText(s, filterKind),
                location,
                data: { kind }
            });
            if (!(0, array_1.isFalsyOrEmpty)(s.children)) {
                addSymbols(s.children, level + 1);
            }
        }
    };
    addSymbols(symbols);
    if (filterKind) {
        items = items.filter(o => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
    }
    return items;
}
exports.symbolsToListItems = symbolsToListItems;
function getFilterText(s, kind) {
    if (typeof kind === 'string' && kind.length > 0)
        return s.name;
    return `${s.name}${(0, convert_1.getSymbolKind)(s.kind)}`;
}
exports.getFilterText = getFilterText;
async function loadCtagsSymbols(document, nvim) {
    if (!node_1.which.sync('ctags', { nothrow: true })) {
        return [];
    }
    let uri = vscode_uri_1.URI.parse(document.uri);
    let extname = node_1.path.extname(uri.fsPath);
    let content = '';
    let tempname = await nvim.call('tempname');
    let filepath = `${tempname}.${extname}`;
    let escaped = await nvim.call('fnameescape', filepath);
    await (0, fs_1.writeFile)(escaped, document.getDocumentContent());
    try {
        content = await (0, processes_1.runCommand)(`ctags -f - --excmd=number --language-force=${document.filetype} ${escaped}`);
    }
    catch (e) {
        // noop
    }
    if (!content.trim().length) {
        content = await (0, processes_1.runCommand)(`ctags -f - --excmd=number ${escaped}`);
    }
    content = content.trim();
    if (!content)
        return [];
    return contentToItems(content, document);
}
exports.loadCtagsSymbols = loadCtagsSymbols;
function contentToItems(content, document) {
    let lines = content.split(/\r?\n/);
    let items = [];
    for (let line of lines) {
        let parts = line.split('\t');
        if (parts.length < 4)
            continue;
        let lnum = Number(parts[2].replace(/;"$/, ''));
        let text = document.getline(lnum - 1);
        let idx = text.indexOf(parts[0]);
        let start = idx == -1 ? 0 : idx;
        let range = vscode_languageserver_types_1.Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
        items.push({
            label: `${parts[0]} [${parts[3]}] ${lnum}`,
            filterText: parts[0],
            location: vscode_languageserver_types_1.Location.create(document.uri, range),
            data: { line: lnum }
        });
    }
    items.sort((a, b) => a.data.line - b.data.line);
    return items;
}
exports.contentToItems = contentToItems;
//# sourceMappingURL=outline.js.map