'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnippetSession = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger_1 = require("../logger");
const mutex_1 = require("../util/mutex");
const object_1 = require("../util/object");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const parser_1 = require("./parser");
const snippet_1 = require("./snippet");
const variableResolve_1 = require("./variableResolve");
const logger = (0, logger_1.createLogger)('snippets-session');
const NAME_SPACE = 'snippets';
class SnippetSession {
    constructor(nvim, document, config) {
        this.nvim = nvim;
        this.document = document;
        this.config = config;
        this.mutex = new mutex_1.Mutex();
        this._applying = false;
        this._isActive = false;
        this._snippet = null;
        this._onCancelEvent = new protocol_1.Emitter();
        this.onCancel = this._onCancelEvent.event;
        this.disposable = document.onDocumentChange(async (e) => {
            if (this._applying || !this._isActive)
                return;
            let changes = e.contentChanges;
            await this.synchronize({ version: e.textDocument.version, change: changes[0] });
        });
    }
    async start(inserted, range, select = true, context) {
        const { document } = this;
        const placeholder = this.getReplacePlaceholder(range);
        const edits = [];
        if (placeholder) {
            // update all snippet.
            let r = this.snippet.range;
            let previous = document.textDocument.getText(r);
            let parts = (0, snippet_1.getParts)(placeholder.value, placeholder.range, range);
            this.current = await this.snippet.insertSnippet(placeholder, inserted, parts, context);
            let edit = (0, snippet_1.reduceTextEdit)({
                range: r,
                newText: this.snippet.text
            }, previous);
            edits.push(edit);
        }
        else {
            const resolver = new variableResolve_1.SnippetVariableResolver(this.nvim, workspace_1.default.workspaceFolderControl);
            let snippet = new snippet_1.CocSnippet(inserted, range.start, this.nvim, resolver);
            await snippet.init(context);
            this._snippet = snippet;
            this.current = snippet.firstPlaceholder.marker;
            edits.push(vscode_languageserver_types_1.TextEdit.replace(range, snippet.text));
            // try fix indent of remain text
            if (inserted.replace(/\$0$/, '').endsWith('\n')) {
                const currentLine = document.getline(range.start.line);
                const remain = currentLine.slice(range.end.character);
                if (remain.length) {
                    let s = range.end.character;
                    let l = remain.match(/^\s*/)[0].length;
                    let r = vscode_languageserver_types_1.Range.create(range.end.line, s, range.end.line, s + l);
                    edits.push(vscode_languageserver_types_1.TextEdit.replace(r, currentLine.match(/^\s*/)[0]));
                }
            }
        }
        await this.applyEdits(edits);
        this.textDocument = document.textDocument;
        this.activate();
        if (select && this.current) {
            let placeholder = this.snippet.getPlaceholderByMarker(this.current);
            await this.selectPlaceholder(placeholder, true);
        }
        return this._isActive;
    }
    async applyEdits(edits) {
        this._applying = true;
        await this.document.applyEdits(edits);
        this._applying = false;
    }
    /**
     * Get valid placeholder to insert
     */
    getReplacePlaceholder(range) {
        if (!this.snippet)
            return undefined;
        let placeholder = this.findPlaceholder(range);
        if (!placeholder || placeholder.index == 0)
            return undefined;
        return placeholder;
    }
    activate() {
        if (this._isActive)
            return;
        this._isActive = true;
        this.nvim.call('coc#snippet#enable', [this.config.preferComplete ? 1 : 0], true);
    }
    deactivate() {
        this.cancel();
        if (!this._isActive)
            return;
        this.disposable.dispose();
        this._isActive = false;
        this._snippet = undefined;
        this.current = null;
        this.nvim.call('coc#snippet#disable', [], true);
        if (this.config.highlight)
            this.nvim.call('coc#highlight#clear_highlight', [this.bufnr, NAME_SPACE, 0, -1], true);
        this._onCancelEvent.fire(void 0);
        logger.debug(`session ${this.bufnr} cancelled`);
    }
    get isActive() {
        return this._isActive;
    }
    get bufnr() {
        return this.document.bufnr;
    }
    async nextPlaceholder() {
        await this.forceSynchronize();
        let curr = this.placeholder;
        if (!curr)
            return;
        let next = this.snippet.getNextPlaceholder(curr.index);
        if (next)
            await this.selectPlaceholder(next);
    }
    async previousPlaceholder() {
        await this.forceSynchronize();
        let curr = this.placeholder;
        if (!curr)
            return;
        let prev = this.snippet.getPrevPlaceholder(curr.index);
        if (prev)
            await this.selectPlaceholder(prev);
    }
    async selectCurrentPlaceholder(triggerAutocmd = true) {
        await this.forceSynchronize();
        if (!this.snippet)
            return;
        let placeholder = this.snippet.getPlaceholderByMarker(this.current);
        if (placeholder)
            await this.selectPlaceholder(placeholder, triggerAutocmd);
    }
    async selectPlaceholder(placeholder, triggerAutocmd = true) {
        let { nvim, document } = this;
        if (!document || !placeholder)
            return;
        let { start, end } = placeholder.range;
        const line = document.getline(start.line);
        const col = (0, string_1.byteIndex)(line, start.character) + 1;
        let marker = this.current = placeholder.marker;
        if (marker instanceof parser_1.Placeholder && marker.choice && marker.choice.options.length) {
            let sources = (await Promise.resolve().then(() => tslib_1.__importStar(require('../completion/sources')))).default;
            sources.setWords(marker.choice.options.map(o => o.value));
            await nvim.call('coc#snippet#show_choices', [start.line + 1, col, end, placeholder.value]);
            if (triggerAutocmd)
                nvim.call('coc#util#do_autocmd', ['CocJumpPlaceholder'], true);
        }
        else {
            let finalCount = this.snippet.finalCount;
            await this.select(placeholder, triggerAutocmd);
            this.highlights(placeholder);
            if (placeholder.index == 0) {
                if (finalCount == 1) {
                    logger.info('Jump to final placeholder, cancelling snippet session');
                    this.deactivate();
                }
                else {
                    nvim.call('coc#snippet#disable', [], true);
                }
            }
        }
    }
    highlights(placeholder, redrawVim = true) {
        if (!this.config.highlight)
            return;
        // this.checkPosition
        let buf = this.document.buffer;
        this.nvim.pauseNotification();
        buf.clearNamespace(NAME_SPACE);
        let ranges = this.snippet.getRanges(placeholder);
        if (ranges.length) {
            buf.highlightRanges(NAME_SPACE, 'CocSnippetVisual', ranges);
        }
        this.nvim.resumeNotification(redrawVim, true);
    }
    async select(placeholder, triggerAutocmd) {
        let { range, value } = placeholder;
        let { nvim } = this;
        if (value.length > 0) {
            await nvim.call('coc#snippet#select', [range.start, range.end, value]);
        }
        else {
            await nvim.call('coc#snippet#move', [range.start]);
        }
        if (triggerAutocmd)
            nvim.call('coc#util#do_autocmd', ['CocJumpPlaceholder'], true);
        nvim.redrawVim();
    }
    async checkPosition() {
        if (!this.isActive)
            return;
        let position = await window_1.default.getCursorPosition();
        if (this.snippet && (0, position_1.positionInRange)(position, this.snippet.range) != 0) {
            logger.info('Cursor insert out of range, cancelling snippet session');
            this.deactivate();
        }
    }
    findPlaceholder(range) {
        let { placeholder } = this;
        if (placeholder && (0, position_1.rangeInRange)(range, placeholder.range))
            return placeholder;
        return this.snippet.getPlaceholderByRange(range) || null;
    }
    get version() {
        return this.textDocument ? this.textDocument.version : -1;
    }
    async synchronize(change) {
        await this.mutex.use(() => {
            if (change && (this.document.version != change.version || change.version - this.version !== 1)) {
                // can't be used any more
                change = undefined;
            }
            return this._synchronize(change ? change.change : undefined);
        });
    }
    async _synchronize(change) {
        let { document, textDocument } = this;
        if (!document.attached || !this._isActive)
            return;
        let start = Date.now();
        let d = document.textDocument;
        if (d.version == textDocument.version || (0, object_1.equals)(textDocument.lines, d.lines))
            return;
        let { range, text } = this.snippet;
        if (change && !(0, position_1.rangeInRange)(change.range, range))
            change = undefined;
        let end = (0, snippet_1.getEndPosition)(range.end, textDocument, d);
        if (!end) {
            logger.info('Content change after snippet, cancel snippet session');
            this.deactivate();
            return;
        }
        let checked = (0, snippet_1.checkContentBefore)(range.start, textDocument, d);
        if (!checked) {
            let content = d.getText(vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), end));
            if (content.endsWith(text)) {
                let pos = d.positionAt(content.length - text.length);
                this.snippet.resetStartPosition(pos);
                this.textDocument = d;
                logger.info('Content change before snippet, reset snippet position');
                return;
            }
            logger.info('Before and snippet body changed, cancel snippet session');
            this.deactivate();
            return;
        }
        let tokenSource = this.tokenSource = new protocol_1.CancellationTokenSource();
        let cursor = await window_1.default.getCursorPosition();
        if (tokenSource.token.isCancellationRequested || document.hasChanged)
            return;
        let placeholder;
        let newText;
        let inserted = d.getText(vscode_languageserver_types_1.Range.create(range.start, end));
        let curr = this.placeholder;
        if (change) {
            for (let p of this.snippet.getSortedPlaceholders(curr)) {
                if ((0, position_1.rangeInRange)(change.range, p.range)) {
                    placeholder = p;
                    newText = this.snippet.getNewText(p, inserted);
                    break;
                }
            }
            // Check Text delete
            if (!placeholder && change.text.length == 0 && !(0, position_1.emptyRange)(change.range) && (0, position_1.isSingleLine)(change.range)) {
                let length = change.range.end.character - change.range.start.character;
                let offset = d.getText(vscode_languageserver_types_1.Range.create(range.start, change.range.start)).length;
                if (this.snippet.removeText(offset, length)) {
                    this.textDocument = d;
                    return;
                }
            }
        }
        else {
            for (let p of this.snippet.getSortedPlaceholders(curr)) {
                if ((0, position_1.comparePosition)(cursor, p.range.start) < 0)
                    continue;
                newText = this.snippet.getNewText(p, inserted);
                // p.range.start + newText
                if (newText != null && (0, snippet_1.checkCursor)(p.range.start, cursor, newText)) {
                    placeholder = p;
                    break;
                }
            }
        }
        if (!placeholder && inserted.endsWith(text)) {
            let pos = (0, position_1.getEnd)(range.start, inserted.slice(0, -text.length));
            this.snippet.resetStartPosition(pos);
            this.textDocument = d;
            logger.info('Content change before snippet, reset snippet position');
            return;
        }
        if (!placeholder) {
            logger.info('Unable to find changed placeholder, cancel snippet session');
            this.deactivate();
            return;
        }
        let res = await this.snippet.updatePlaceholder(placeholder, cursor, newText, tokenSource.token);
        if (res == null || tokenSource.token.isCancellationRequested)
            return;
        // happens when applyEdits just after TextInsert
        if (document.dirty || !(0, object_1.equals)(document.textDocument.lines, d.lines)) {
            tokenSource.cancel();
            tokenSource.dispose();
            return;
        }
        tokenSource.dispose();
        this.current = placeholder.marker;
        if (res.text !== inserted) {
            let edit = (0, snippet_1.reduceTextEdit)({
                range: vscode_languageserver_types_1.Range.create(this.snippet.start, end),
                newText: res.text
            }, inserted);
            await this.applyEdits([edit]);
            let { delta } = res;
            if (delta.line != 0 || delta.character != 0) {
                this.nvim.call(`coc#cursor#move_to`, [cursor.line + delta.line, cursor.character + delta.character], true);
            }
            this.highlights(placeholder, false);
            this.nvim.redrawVim();
        }
        else {
            this.highlights(placeholder);
        }
        logger.debug('update cost:', Date.now() - start, res.delta);
        this.textDocument = this.document.textDocument;
        if (this.config.nextOnDelete) {
            if (curr && curr.value.length > 0 && placeholder.marker.toString() === '') {
                let next = this.snippet.getNextPlaceholder(placeholder.index);
                if (next)
                    await this.selectPlaceholder(next);
            }
        }
    }
    async forceSynchronize() {
        await this.document.patchChange();
        let release = await this.mutex.acquire();
        release();
        // text change event may not fired
        if (this.document.version !== this.version) {
            await this.synchronize();
        }
    }
    cancel() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource.dispose();
            this.tokenSource = null;
        }
    }
    get placeholder() {
        if (!this.snippet || !this.current)
            return undefined;
        return this.snippet.getPlaceholderByMarker(this.current);
    }
    get snippet() {
        return this._snippet;
    }
    static async resolveSnippet(nvim, snippetString, ultisnip) {
        let position = ultisnip && vscode_languageserver_types_1.Range.is(ultisnip.range) ? ultisnip.range.start : await window_1.default.getCursorPosition();
        let line = ultisnip && typeof ultisnip.line === 'string' ? ultisnip.line : await nvim.line;
        let context;
        if (ultisnip)
            context = Object.assign({ range: vscode_languageserver_types_1.Range.create(position, position), line }, ultisnip);
        const resolver = new variableResolve_1.SnippetVariableResolver(nvim, workspace_1.default.workspaceFolderControl);
        let snippet = new snippet_1.CocSnippet(snippetString, position, nvim, resolver);
        await snippet.init(context, true);
        return snippet.text;
    }
}
exports.SnippetSession = SnippetSession;
//# sourceMappingURL=session.js.map