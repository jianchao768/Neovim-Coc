"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_uri_1 = require("vscode-uri");
const index_1 = require("../../language-client/index");
const fs_2 = require("../../util/fs");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
function createClient(documentSelector, middleware = {}, opts = {}) {
    const serverModule = path_1.default.join(__dirname, './server/testDocuments.js');
    const serverOptions = {
        run: { module: serverModule, transport: index_1.TransportKind.ipc },
        debug: { module: serverModule, transport: index_1.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }
    };
    if (documentSelector === undefined)
        documentSelector = [{ scheme: 'file' }];
    const clientOptions = {
        documentSelector,
        synchronize: {},
        initializationOptions: opts,
        middleware
    };
    clientOptions.$testMode = true;
    const result = new index_1.LanguageClient('test', 'Test Language Server', serverOptions, clientOptions);
    return result;
}
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = workspace_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('TextDocumentSynchronization', () => {
    describe('DidOpenTextDocumentFeature', () => {
        it('should register with empty documentSelector', async () => {
            let client = createClient(undefined);
            await client.start();
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
            feature.register({ id: (0, uuid_1.v4)(), registerOptions: { documentSelector: null } });
            let res = await client.sendRequest('getLastOpen');
            expect(res).toBe(null);
            await client.stop();
        });
        it('should send event on document create', async () => {
            let client = createClient([{ language: 'vim' }]);
            await client.start();
            let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 't.vim'));
            let doc = await workspace_1.default.loadFile(uri.toString());
            expect(doc.languageId).toBe('vim');
            let res = await client.sendRequest('getLastOpen');
            expect(res.uri).toBe(doc.uri);
            expect(res.version).toBe(doc.version);
            await client.stop();
        });
        it('should work with middleware', async () => {
            let called = false;
            let client = createClient([{ language: 'vim' }], {
                didOpen: (doc, next) => {
                    called = true;
                    return next(doc);
                }
            });
            await client.start();
            let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 't.js'));
            let doc = await workspace_1.default.loadFile(uri.toString());
            expect(doc.languageId).toBe('javascript');
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
            feature.register({ id: (0, uuid_1.v4)(), registerOptions: { documentSelector: [{ language: 'javascript' }] } });
            let res = await client.sendRequest('getLastOpen');
            expect(res.uri).toBe(doc.uri);
            expect(called).toBe(true);
            await client.stop();
        });
    });
    describe('DidCloseTextDocumentFeature', () => {
        it('should send close event', async () => {
            let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 't.vim'));
            let doc = await workspace_1.default.loadFile(uri.toString());
            let client = createClient([{ language: 'vim' }]);
            await client.start();
            await workspace_1.default.nvim.command(`bd! ${doc.bufnr}`);
            await helper_1.default.wait(30);
            let res = await client.sendRequest('getLastClose');
            expect(res.uri).toBe(doc.uri);
            await client.stop();
        });
        it('should unregister document selector', async () => {
            let called = false;
            let client = createClient([{ language: 'javascript' }], {
                didClose: (e, next) => {
                    called = true;
                    return next(e);
                }
            });
            await client.start();
            let openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
            let id = (0, uuid_1.v4)();
            let options = { id, registerOptions: { documentSelector: [{ language: 'vim' }] } };
            openFeature.register(options);
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
            feature.register(options);
            let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 't.vim'));
            let doc = await workspace_1.default.loadFile(uri.toString());
            await helper_1.default.wait(30);
            feature.unregister(id);
            feature.unregister('unknown');
            await helper_1.default.wait(30);
            let res = await client.sendRequest('getLastClose');
            expect(res.uri).toBe(doc.uri);
            expect(called).toBe(true);
            await client.stop();
        });
    });
    describe('DidChangeTextDocumentFeature', () => {
        it('should send full change event ', async () => {
            let called = false;
            let client = createClient([{ language: 'vim' }], {
                didChange: (e, next) => {
                    called = true;
                    return next(e);
                }
            });
            await client.start();
            let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 'x.vim'));
            let doc = await workspace_1.default.loadFile(uri.toString());
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar')]);
            await client.forceDocumentSync();
            let res = await client.sendRequest('getLastChange');
            expect(res.text).toBe('bar\n');
            expect(called).toBe(true);
            await client.stop();
        });
        it('should send incremental change event', async () => {
            let client = createClient([{ scheme: 'lsptest' }]);
            await client.start();
            await client.sendNotification('registerDocumentSync');
            await helper_1.default.waitValue(() => {
                let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
                return feature !== undefined;
            }, true);
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            let called = false;
            feature.onNotificationSent(() => {
                called = true;
            });
            let doc = await helper_1.default.createDocument(`${(0, uuid_1.v4)()}.vim`);
            await nvim.call('setline', [1, 'foo']);
            await doc.synchronize();
            await client.forceDocumentSync();
            await nvim.call('setline', [1, 'bar']);
            await doc.synchronize();
            await helper_1.default.waitValue(() => {
                return called;
            }, true);
            let res = await client.sendRequest('getLastChange');
            expect(res.uri).toBe(doc.uri);
            expect(res.text).toBe('bar\n');
            let provider = feature.getProvider(doc.textDocument);
            expect(provider).toBeDefined();
            await provider.send({ contentChanges: [], textDocument: { uri: doc.uri, version: doc.version }, bufnr: doc.bufnr, original: '', originalLines: [] });
            await client.sendNotification('unregisterDocumentSync');
            await client.stop();
        });
        it('should not send change event when syncKind is none', async () => {
            let client = createClient([{ scheme: 'lsptest' }], {}, { none: true });
            await client.start();
            await client.sendNotification('registerDocumentSync');
            await nvim.command('edit x.vim');
            let doc = await workspace_1.default.document;
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            await helper_1.default.waitValue(() => {
                return feature.getProvider(doc.textDocument) != null;
            }, true);
            let provider = feature.getProvider(doc.textDocument);
            let changes = [{
                    range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0),
                    text: 'foo'
                }];
            await provider.send({ contentChanges: changes, textDocument: { uri: doc.uri, version: doc.version }, bufnr: doc.bufnr });
            let res = await client.sendRequest('getLastChange');
            expect(res.text).toBe('\n');
            await client.stop();
        });
    });
    describe('WillSaveFeature', () => {
        it('should will save event', async () => {
            let called = false;
            let client = createClient([{ language: 'vim' }], {
                willSave: (e, next) => {
                    called = true;
                    return next(e);
                }
            });
            await client.start();
            let fsPath = path_1.default.join(os_1.default.tmpdir(), `${(0, uuid_1.v4)()}.vim`);
            let uri = vscode_uri_1.URI.file(fsPath);
            await workspace_1.default.openResource(uri.toString());
            let doc = await workspace_1.default.document;
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar')]);
            let feature = client.getFeature(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.method);
            let provider = feature.getProvider(doc.textDocument);
            expect(provider).toBeDefined();
            await provider.send({ document: doc.textDocument, reason: vscode_languageserver_protocol_1.TextDocumentSaveReason.Manual, waitUntil: () => { } });
            let res = await client.sendRequest('getLastWillSave');
            expect(res.uri).toBe(doc.uri);
            await client.stop();
            expect(called).toBe(true);
            if (fs_1.default.existsSync(fsPath)) {
                fs_1.default.unlinkSync(fsPath);
            }
        });
    });
    describe('WillSaveWaitUntilFeature', () => {
        it('should send will save until request', async () => {
            let client = createClient([{ scheme: 'lsptest' }]);
            await client.start();
            await client.sendNotification('registerDocumentSync');
            let fsPath = path_1.default.join(os_1.default.tmpdir(), `${(0, uuid_1.v4)()}-foo.vim`);
            let uri = vscode_uri_1.URI.file(fsPath);
            await workspace_1.default.openResource(uri.toString());
            let doc = await workspace_1.default.document;
            await helper_1.default.waitValue(() => {
                let feature = client.getFeature(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.method);
                return feature.getProvider(doc.textDocument) != null;
            }, true);
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'x')]);
            nvim.command('w', true);
            await helper_1.default.waitValue(() => {
                return doc.getDocumentContent();
            }, 'abcx\n');
            await client.sendNotification('unregisterDocumentSync');
            await client.stop();
            await (0, fs_2.remove)(fsPath);
        });
        it('should not throw on response error', async () => {
            let called = false;
            let client = createClient([], {
                willSaveWaitUntil: (event, next) => {
                    called = true;
                    return next(event);
                }
            });
            await client.start();
            await client.sendNotification('registerDocumentSync');
            let fsPath = path_1.default.join(os_1.default.tmpdir(), `${(0, uuid_1.v4)()}-error.vim`);
            let uri = vscode_uri_1.URI.file(fsPath);
            await helper_1.default.waitValue(() => {
                let feature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
                let provider = feature.getProvider(vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), 'vim', 1, ''));
                return provider != null;
            }, true);
            await workspace_1.default.openResource(uri.toString());
            let doc = await workspace_1.default.document;
            await doc.synchronize();
            nvim.command('w', true);
            await helper_1.default.waitValue(() => {
                return called;
            }, true);
            await client.stop();
        });
        it('should unregister event handler', async () => {
            let client = createClient(null);
            await client.start();
            await client.sendNotification('registerDocumentSync');
            await helper_1.default.waitValue(() => {
                let feature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
                let provider = feature.getProvider(vscode_languageserver_textdocument_1.TextDocument.create('file:///f.vim', 'vim', 1, ''));
                return provider != null;
            }, true);
            await client.sendNotification('unregisterDocumentSync');
            await helper_1.default.waitValue(() => {
                let feature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
                let provider = feature.getProvider(vscode_languageserver_textdocument_1.TextDocument.create('file:///f.vim', 'vim', 1, ''));
                return provider == null;
            }, true);
            await client.stop();
        });
    });
    describe('DidSaveTextDocumentFeature', () => {
        it('should send did save notification', async () => {
            let called = false;
            let client = createClient([{ language: 'vim' }], {
                didSave: (e, next) => {
                    called = true;
                    return next(e);
                }
            });
            await client.start();
            let fsPath = path_1.default.join(os_1.default.tmpdir(), `${(0, uuid_1.v4)()}.vim`);
            let uri = vscode_uri_1.URI.file(fsPath);
            await workspace_1.default.openResource(uri.toString());
            let doc = await workspace_1.default.document;
            await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'bar')]);
            nvim.command('w', true);
            await helper_1.default.waitValue(() => {
                return called;
            }, true);
            let res = await client.sendRequest('getLastWillSave');
            expect(res.uri).toBe(doc.uri);
            await client.stop();
            fs_1.default.unlinkSync(fsPath);
        });
    });
});
//# sourceMappingURL=textSynchronization.test.js.map