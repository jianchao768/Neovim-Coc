'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.score = exports.resolveModule = exports.findUp = exports.getWatchmanPath = exports.createNameSpace = exports.callAsync = exports.has = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const resolver_1 = tslib_1.__importDefault(require("../model/resolver"));
const constants_1 = require("../util/constants");
const fs = tslib_1.__importStar(require("../util/fs"));
const node_1 = require("../util/node");
const platform = tslib_1.__importStar(require("../util/platform"));
const protocol_1 = require("../util/protocol");
let NAME_SPACE = 2000;
const resolver = new resolver_1.default();
const namespaceMap = new Map();
/**
 * Like vim's has(), but for version check only.
 * Check patch on neovim and check nvim on vim would return false.
 *
 * For example:
 * - has('nvim-0.6.0')
 * - has('patch-7.4.248')
 */
function has(env, feature) {
    if (!feature.startsWith('nvim-') && !feature.startsWith('patch-')) {
        throw new Error('Feature param could only starts with nvim and patch');
    }
    if (!env.isVim && feature.startsWith('patch-')) {
        return false;
    }
    if (env.isVim && feature.startsWith('nvim-')) {
        return false;
    }
    if (env.isVim) {
        let [_, major, minor, patch] = env.version.match(/^(\d)(\d{2})(\d+)$/);
        let version = `${major}.${parseInt(minor, 10)}.${parseInt(patch, 10)}`;
        return node_1.semver.gte(version, feature.slice(6));
    }
    return node_1.semver.gte(env.version, feature.slice(5));
}
exports.has = has;
async function callAsync(nvim, method, args) {
    if (!constants_1.isVim)
        return await nvim.call(method, args);
    return await nvim.callAsync('coc#util#with_callback', [method, args]);
}
exports.callAsync = callAsync;
/**
 * @deprecated
 */
function createNameSpace(name) {
    if (namespaceMap.has(name))
        return namespaceMap.get(name);
    NAME_SPACE = NAME_SPACE + 1;
    namespaceMap.set(name, NAME_SPACE);
    return NAME_SPACE;
}
exports.createNameSpace = createNameSpace;
/**
 * Resolve watchman path.
 */
function getWatchmanPath(configurations) {
    const watchmanPath = configurations.initialConfiguration.get('coc.preferences.watchmanPath', 'watchman');
    return node_1.which.sync(watchmanPath, { nothrow: true });
}
exports.getWatchmanPath = getWatchmanPath;
async function findUp(nvim, cwd, filename) {
    let filepath = await nvim.call('expand', '%:p');
    filepath = node_1.path.normalize(filepath);
    let isFile = filepath && node_1.path.isAbsolute(filepath);
    if (isFile && !fs.isParentFolder(cwd, filepath, true)) {
        // can't use cwd
        return fs.findUp(filename, node_1.path.dirname(filepath));
    }
    let res = fs.findUp(filename, cwd);
    if (res && res != node_1.os.homedir())
        return res;
    if (isFile)
        return fs.findUp(filename, node_1.path.dirname(filepath));
    return null;
}
exports.findUp = findUp;
function resolveModule(name) {
    return resolver.resolveModule(name);
}
exports.resolveModule = resolveModule;
function score(selector, uri, languageId, caseInsensitive = platform.isWindows || platform.isMacintosh) {
    if (Array.isArray(selector)) {
        // array -> take max individual value
        let ret = 0;
        for (const filter of selector) {
            const value = score(filter, uri, languageId);
            if (value === 10) {
                return value; // already at the highest
            }
            if (value > ret) {
                ret = value;
            }
        }
        return ret;
    }
    else if (typeof selector === 'string') {
        // short-hand notion, desugars to
        // 'fooLang' -> { language: 'fooLang'}
        // '*' -> { language: '*' }
        if (selector === '*') {
            return 5;
        }
        else if (selector === languageId) {
            return 10;
        }
        else {
            return 0;
        }
    }
    else if (selector && protocol_1.TextDocumentFilter.is(selector)) {
        let u = vscode_uri_1.URI.parse(uri);
        // filter -> select accordingly, use defaults for scheme
        const { language, pattern, scheme } = selector;
        let ret = 0;
        if (scheme) {
            if (scheme === u.scheme) {
                ret = 5;
            }
            else if (scheme === '*') {
                ret = 3;
            }
            else {
                return 0;
            }
        }
        if (language) {
            if (language === languageId) {
                ret = 10;
            }
            else if (language === '*') {
                ret = Math.max(ret, 5);
            }
            else {
                return 0;
            }
        }
        if (pattern) {
            let p = caseInsensitive ? pattern.toLowerCase() : pattern;
            let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
            if (p === f || (0, node_1.minimatch)(f, p, { dot: true })) {
                ret = 5;
            }
            else {
                return 0;
            }
        }
        return ret;
    }
    else {
        return 0;
    }
}
exports.score = score;
//# sourceMappingURL=funcs.js.map