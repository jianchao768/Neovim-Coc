'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const logger_1 = require("../logger");
const markdown_1 = require("../markdown");
const util_1 = require("../util");
const errors_1 = require("../util/errors");
const Is = tslib_1.__importStar(require("../util/is"));
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const util_2 = require("./util");
const logger = (0, logger_1.createLogger)('completion-floating');
const RESOLVE_TIMEOUT = (0, util_1.getConditionValue)(500, 50);
class Floating {
    constructor(config) {
        this.config = config;
    }
    async resolveItem(source, item, opt, showDocs, detailRendered = false) {
        this.cancel();
        if (Is.func(source.onCompleteResolve)) {
            try {
                await this.requestWithToken(token => {
                    return Promise.resolve(source.onCompleteResolve(item, opt, token));
                });
            }
            catch (e) {
                if ((0, errors_1.isCancellationError)(e))
                    return;
                logger.error(`Error on resolve complete item from ${source.name}:`, item, e);
                return;
            }
        }
        if (showDocs) {
            this.show((0, util_2.getDocumentaions)(item, opt.filetype, detailRendered));
        }
    }
    show(docs) {
        var _a;
        let config = this.config.floatConfig;
        docs = docs.filter(o => o.content.trim().length > 0);
        if (docs.length === 0) {
            this.close();
        }
        else {
            const markdownPreference = workspace_1.default.configurations.markdownPreference;
            let { lines, codes, highlights } = (0, markdown_1.parseDocuments)(docs, markdownPreference);
            let opts = {
                codes,
                highlights,
                highlight: (_a = config.highlight) !== null && _a !== void 0 ? _a : 'CocFloating',
                maxWidth: config.maxWidth || 80,
                rounded: config.rounded ? 1 : 0,
                focusable: config.focusable === true ? 1 : 0
            };
            if (config.shadow)
                opts.shadow = 1;
            if (config.border)
                opts.border = [1, 1, 1, 1];
            if (config.borderhighlight)
                opts.borderhighlight = config.borderhighlight;
            if (typeof config.winblend === 'number')
                opts.winblend = config.winblend;
            let { nvim } = workspace_1.default;
            nvim.call('coc#dialog#create_pum_float', [lines, opts], true);
            nvim.redrawVim();
        }
    }
    close() {
        workspace_1.default.nvim.call('coc#pum#close_detail', [], true);
        workspace_1.default.nvim.redrawVim();
    }
    cancel() {
        if (this.resolveTokenSource) {
            this.resolveTokenSource.cancel();
            this.resolveTokenSource = undefined;
        }
    }
    requestWithToken(fn) {
        let tokenSource = this.resolveTokenSource = new protocol_1.CancellationTokenSource();
        return new Promise((resolve, reject) => {
            let called = false;
            let onFinish = (err) => {
                if (called)
                    return;
                called = true;
                disposable.dispose();
                clearTimeout(timer);
                if (this.resolveTokenSource === tokenSource) {
                    this.resolveTokenSource = undefined;
                }
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            };
            let timer = setTimeout(() => {
                tokenSource.cancel();
            }, RESOLVE_TIMEOUT);
            let disposable = tokenSource.token.onCancellationRequested(() => {
                onFinish(new errors_1.CancellationError());
            });
            fn(tokenSource.token).then(() => {
                onFinish();
            }, e => {
                onFinish(e);
            });
        });
    }
}
exports.default = Floating;
//# sourceMappingURL=floating.js.map