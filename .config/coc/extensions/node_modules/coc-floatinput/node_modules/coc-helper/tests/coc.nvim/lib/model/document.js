'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNotAttachReason = exports.getUri = void 0;
const tslib_1 = require("tslib");
const buffer_1 = require("buffer");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../events"));
const constants_1 = require("../util/constants");
const diff_1 = require("../util/diff");
const index_1 = require("../util/index");
const is_1 = require("../util/is");
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const position_1 = require("../util/position");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const textedit_1 = require("../util/textedit");
const chars_1 = require("./chars");
const textdocument_1 = require("./textdocument");
const debounceTime = (0, index_1.getConditionValue)(150, 15);
// getText, positionAt, offsetAt
class Document {
    constructor(buffer, env, nvim, opts) {
        this.buffer = buffer;
        this.env = env;
        this.nvim = nvim;
        this.isIgnored = false;
        this.eol = true;
        this._disposed = false;
        this._attached = false;
        this._notAttachReason = '';
        this._previewwindow = false;
        this._winid = -1;
        this.disposables = [];
        // real current lines
        this.lines = [];
        this._onDocumentChange = new protocol_1.Emitter();
        this.onDocumentChange = this._onDocumentChange.event;
        this.fireContentChanges = (0, node_1.debounce)(() => {
            this._fireContentChanges();
        }, debounceTime);
        this.fetchContent = (0, node_1.debounce)(() => {
            void this._fetchContent();
        }, debounceTime);
        this.init(opts);
    }
    /**
     * Synchronize content
     */
    get content() {
        return this.syncLines.join('\n') + (this.eol ? '\n' : '');
    }
    get attached() {
        return this._attached;
    }
    /**
     * Synchronized textDocument.
     */
    get textDocument() {
        return this._textDocument;
    }
    get syncLines() {
        return this._textDocument.lines;
    }
    get version() {
        return this._textDocument.version;
    }
    /**
     * Buffer number
     */
    get bufnr() {
        return this.buffer.id;
    }
    get bufname() {
        return this._bufname;
    }
    get filetype() {
        return this._filetype;
    }
    get uri() {
        return this._uri;
    }
    get isCommandLine() {
        return this.uri && this.uri.endsWith('%5BCommand%20Line%5D');
    }
    /**
     * LanguageId of TextDocument, main filetype are used for combined filetypes
     * with '.'
     */
    get languageId() {
        let { _filetype } = this;
        return _filetype.includes('.') ? _filetype.match(/(.*?)\./)[1] : _filetype;
    }
    /**
     * Get current buffer changedtick.
     */
    get changedtick() {
        return this._changedtick;
    }
    /**
     * Map filetype for languageserver.
     */
    convertFiletype(filetype) {
        switch (filetype) {
            case 'javascript.jsx':
                return 'javascriptreact';
            case 'typescript.jsx':
            case 'typescript.tsx':
                return 'typescriptreact';
            case 'tex':
                // Vim filetype 'tex' means LaTeX, which has LSP language ID 'latex'
                return 'latex';
            default: {
                let map = this.env.filetypeMap;
                return String(map[filetype] || filetype);
            }
        }
    }
    /**
     * Scheme of document.
     */
    get schema() {
        return vscode_uri_1.URI.parse(this.uri).scheme;
    }
    /**
     * Line count of current buffer.
     */
    get lineCount() {
        return this.lines.length;
    }
    /**
     * Window ID when buffer create, could be -1 when no window associated.
     */
    get winid() {
        return this._winid;
    }
    /**
     * Returns if current document is opended with previewwindow
     *
     * @deprecated
     */
    get previewwindow() {
        return this._previewwindow;
    }
    /**
     * Initialize document model.
     */
    init(opts) {
        let buftype = this.buftype = opts.buftype;
        this._bufname = opts.bufname;
        this._previewwindow = !!opts.previewwindow;
        this._winid = opts.winid;
        this.variables = (0, object_1.toObject)(opts.variables);
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        this._uri = getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);
        if (Array.isArray(opts.lines)) {
            this.lines = opts.lines;
            this._noFetch = true;
            this._attached = true;
            this.attach();
        }
        else {
            this._notAttachReason = getNotAttachReason(buftype, this.variables[`coc_enabled`], opts.size);
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.setIskeyword(opts.iskeyword, opts.lisp);
        this.createTextDocument(1, this.lines);
    }
    get notAttachReason() {
        return this._notAttachReason;
    }
    attach() {
        if (constants_1.isVim)
            return;
        let lines = this.lines;
        this.buffer.attach(true).then(res => {
            if (!res)
                fireDetach(this.bufnr);
        }, _e => {
            fireDetach(this.bufnr);
        });
        this.buffer.listen('lines', (buf, tick, firstline, lastline, linedata) => {
            if (tick && tick > this._changedtick) {
                this._changedtick = tick;
                lines = [...lines.slice(0, firstline), ...linedata, ...(lastline == -1 ? [] : lines.slice(lastline))];
                if (lines.length == 0)
                    lines = [''];
                this.lines = lines;
                fireLinesChanged(buf.id);
                if (events_1.default.pumvisible)
                    return;
                this.fireContentChanges();
            }
        }, this.disposables);
        this.buffer.listen('detach', () => {
            fireDetach(this.bufnr);
        }, this.disposables);
    }
    /**
     * Check if document changed after last synchronize
     */
    get dirty() {
        // if (this.lines === this.syncLines) return false
        // return !equals(this.lines, this.syncLines)
        return this.lines !== this.syncLines;
    }
    get hasChanged() {
        if (!this.dirty)
            return false;
        return !(0, object_1.equals)(this.lines, this.syncLines);
    }
    _fireContentChanges(edit) {
        var _a;
        if (this.lines === this.syncLines)
            return;
        let textDocument = this._textDocument;
        let changes = [];
        if (!edit) {
            let { cursor } = events_1.default;
            let pos;
            // consider cursor position.
            if (cursor.bufnr == this.bufnr) {
                let content = (_a = this.lines[cursor.lnum - 1]) !== null && _a !== void 0 ? _a : '';
                pos = vscode_languageserver_types_1.Position.create(cursor.lnum - 1, (0, string_1.characterIndex)(content, cursor.col - 1));
            }
            edit = (0, diff_1.getTextEdit)(textDocument.lines, this.lines, pos, cursor.insert);
        }
        let original;
        if (edit) {
            original = textDocument.getText(edit.range);
            // TODO the range could be wrong
            changes.push({ range: edit.range, text: edit.newText, rangeLength: original.length });
        }
        else {
            original = '';
        }
        let created = this.createTextDocument(this.version + (edit ? 1 : 0), this.lines);
        this._onDocumentChange.fire(Object.freeze({
            bufnr: this.bufnr,
            original,
            originalLines: textDocument.lines,
            textDocument: { version: created.version, uri: this.uri },
            contentChanges: changes
        }));
    }
    async applyEdits(edits, joinUndo = false, move = false) {
        if (Array.isArray(arguments[1]))
            edits = arguments[1];
        if (!this._attached || edits.length === 0)
            return;
        this._forceSync();
        let textDocument = this.textDocument;
        edits = (0, textedit_1.filterSortEdits)(textDocument, edits);
        // apply edits to current textDocument
        let newLines = (0, textedit_1.applyEdits)(textDocument, edits);
        if (!newLines)
            return;
        let lines = textDocument.lines;
        let changed = (0, diff_1.diffLines)(lines, newLines, (0, textedit_1.getStartLine)(edits[0]));
        // append new lines
        let isAppend = changed.start === changed.end && changed.start === lines.length;
        let original = lines.slice(changed.start, changed.end);
        let changes = [];
        // avoid out of range and lines replacement, avoid too many buf_set_text cause nvim slow.
        if (edits.length < 200
            && changed.start !== changed.end
            && edits[edits.length - 1].range.end.line < lines.length) {
            changes = (0, textedit_1.toTextChanges)(lines, edits);
        }
        let cursor;
        let isCurrent = events_1.default.bufnr == this.bufnr;
        let col;
        if (move && isCurrent && !isAppend) {
            let pos = vscode_languageserver_types_1.Position.is(move) ? move : undefined;
            if (!pos && this.bufnr === events_1.default.cursor.bufnr) {
                let { col, lnum } = events_1.default.cursor;
                pos = vscode_languageserver_types_1.Position.create(lnum - 1, (0, string_1.characterIndex)(this.lines[lnum - 1], col - 1));
            }
            if (pos) {
                let position = (0, textedit_1.getPositionFromEdits)(pos, edits);
                if ((0, position_1.comparePosition)(pos, position) !== 0) {
                    let content = (0, string_1.toText)(newLines[position.line]);
                    let col = (0, string_1.byteIndex)(content, position.character) + 1;
                    cursor = [position.line + 1, col];
                }
                col = (0, string_1.byteIndex)(this.lines[pos.line], pos.character) + 1;
            }
        }
        this.nvim.pauseNotification();
        if (isCurrent && joinUndo)
            this.nvim.command('undojoin', true);
        if (isAppend) {
            this.buffer.setLines(changed.replacement, { start: -1, end: -1 }, true);
        }
        else {
            this.nvim.call('coc#ui#set_lines', [
                this.bufnr,
                this._changedtick,
                original,
                changed.replacement,
                changed.start,
                changed.end,
                changes,
                cursor,
                col
            ], true);
        }
        this.nvim.resumeNotification(isCurrent, true);
        let textEdit = edits.length == 1 ? edits[0] : (0, textedit_1.mergeTextEdits)(edits, lines, newLines);
        await (0, index_1.waitNextTick)();
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this.fireContentChanges.clear();
        this._fireContentChanges(textEdit);
        let range = vscode_languageserver_types_1.Range.create(changed.start, 0, changed.start + changed.replacement.length, 0);
        return vscode_languageserver_types_1.TextEdit.replace(range, original.join('\n') + (original.length > 0 ? '\n' : ''));
    }
    async changeLines(lines) {
        let filtered = [];
        let newLines = this.lines.slice();
        for (let [lnum, text] of lines) {
            if (newLines[lnum] != text) {
                filtered.push([lnum, text]);
                newLines[lnum] = text;
            }
        }
        if (!filtered.length)
            return;
        this.nvim.call('coc#ui#change_lines', [this.bufnr, filtered], true);
        this.nvim.redrawVim();
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this._forceSync();
    }
    _forceSync() {
        this.fireContentChanges.clear();
        this._fireContentChanges();
    }
    forceSync() {
        // may cause bugs, prevent extensions use it.
        if (global.__TEST__) {
            this._forceSync();
        }
    }
    /**
     * Get offset from lnum & col
     */
    getOffset(lnum, col) {
        return this.textDocument.offsetAt({
            line: lnum - 1,
            character: col
        });
    }
    /**
     * Check string is word.
     */
    isWord(word) {
        return this.chars.isKeyword(word);
    }
    getStartWord(text) {
        let i = 0;
        for (; i < text.length; i++) {
            if (!this.chars.isKeywordChar(text[i]))
                break;
        }
        return text.slice(0, i);
    }
    /**
     * Current word for replacement
     */
    getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars;
        if (extraChars && extraChars.length) {
            chars = this.chars.clone();
            for (let ch of extraChars) {
                chars.addKeyword(ch);
            }
        }
        let line = this.getline(position.line, current);
        let ch = line[position.character];
        if (ch == null || !chars.isKeywordChar(ch))
            return null;
        let start = position.character;
        let end = position.character + 1;
        while (start >= 0) {
            let ch = line[start - 1];
            if (!ch || !chars.isKeywordChar(ch))
                break;
            start = start - 1;
        }
        while (end <= line.length) {
            let ch = line[end];
            if (!ch || !chars.isKeywordChar(ch))
                break;
            end = end + 1;
        }
        return vscode_languageserver_types_1.Range.create(position.line, start, position.line, end);
    }
    createTextDocument(version, lines) {
        let { uri, languageId, eol } = this;
        let textDocument = this._textDocument = new textdocument_1.LinesTextDocument(uri, languageId, version, lines, this.bufnr, eol);
        return textDocument;
    }
    /**
     * Get ranges of word in textDocument.
     */
    getSymbolRanges(word) {
        let { version, filetype, uri } = this;
        let textDocument = new textdocument_1.LinesTextDocument(uri, filetype, version, this.lines, this.bufnr, this.eol);
        let res = [];
        let content = textDocument.getText();
        let str = '';
        for (let i = 0, l = content.length; i < l; i++) {
            let ch = content[i];
            if ('-' == ch && str.length == 0) {
                continue;
            }
            let isKeyword = this.chars.isKeywordChar(ch);
            if (isKeyword) {
                str = str + ch;
            }
            if (str.length > 0 && !isKeyword && str == word) {
                res.push(vscode_languageserver_types_1.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
            }
            if (!isKeyword) {
                str = '';
            }
        }
        return res;
    }
    /**
     * Adjust col with new valid character before position.
     */
    fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line)
            return 0;
        let { character } = position;
        let start = line.slice(0, character);
        let col = (0, string_1.byteLength)(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
            let c = start[i];
            if (!chars.isKeywordChar(c) && !valids.includes(c)) {
                break;
            }
            col = col - (0, string_1.byteLength)(c);
        }
        return col;
    }
    /**
     * Add vim highlight items from highlight group and range.
     * Synchronized lines are used for calculate cols.
     */
    addHighlights(items, hlGroup, range, opts = {}) {
        let { start, end } = range;
        if ((0, position_1.emptyRange)(range))
            return;
        for (let line = start.line; line <= end.line; line++) {
            const text = this.getline(line, false);
            let colStart = line == start.line ? (0, string_1.byteIndex)(text, start.character) : 0;
            let colEnd = line == end.line ? (0, string_1.byteIndex)(text, end.character) : buffer_1.Buffer.byteLength(text);
            if (colStart >= colEnd)
                continue;
            items.push(Object.assign({ hlGroup, lnum: line, colStart, colEnd }, opts));
        }
    }
    /**
     * Line content 0 based line
     */
    getline(line, current = true) {
        if (current)
            return this.lines[line] || '';
        return this.syncLines[line] || '';
    }
    /**
     * Get lines, zero indexed, end exclude.
     */
    getLines(start, end) {
        return this.lines.slice(start !== null && start !== void 0 ? start : 0, end !== null && end !== void 0 ? end : this.lines.length);
    }
    /**
     * Get current content text.
     */
    getDocumentContent() {
        let content = this.lines.join('\n');
        return this.eol ? content + '\n' : content;
    }
    /**
     * Get variable value by key, defined by `b:coc_{key}`
     */
    getVar(key, defaultValue) {
        let val = this.variables[`coc_${key}`];
        return val === undefined ? defaultValue : val;
    }
    /**
     * Get position from lnum & col
     */
    getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0)
            return { line: lnum - 1, character: 0 };
        let pre = (0, string_1.byteSlice)(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
    }
    /**
     * Recreate document with new filetype.
     */
    setFiletype(filetype) {
        this._filetype = this.convertFiletype(filetype);
        let lines = this._textDocument.lines;
        this._textDocument = new textdocument_1.LinesTextDocument(this.uri, this.languageId, 1, lines, this.bufnr, this.eol);
    }
    /**
     * Change iskeyword option of document
     */
    setIskeyword(iskeyword, lisp) {
        let chars = this.chars = new chars_1.Chars(iskeyword);
        let additional = this.getVar('additional_keywords', []);
        if (lisp)
            chars.addKeyword('-');
        if (additional && Array.isArray(additional)) {
            for (let ch of additional) {
                chars.addKeyword(ch);
            }
        }
    }
    /**
     * Detach document.
     */
    detach() {
        (0, index_1.disposeAll)(this.disposables);
        if (this._disposed)
            return;
        this._disposed = true;
        this._attached = false;
        this.lines = [];
        this.fetchContent.clear();
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
    }
    /**
     * Synchronize latest document content
     */
    async synchronize() {
        if (!this.attached)
            return;
        let { changedtick } = this;
        await this.patchChange();
        if (changedtick != this.changedtick) {
            await (0, index_1.wait)(50);
        }
    }
    /**
     * Synchronize buffer change
     */
    async patchChange(currentLine) {
        if (!this._attached)
            return;
        if (constants_1.isVim) {
            if (currentLine) {
                let change = await this.nvim.call('coc#util#get_changeinfo', [this.bufnr]);
                if (!change || change.changedtick < this._changedtick) {
                    this._forceSync();
                    return;
                }
                let { lnum, line, changedtick } = change;
                let curr = this.getline(lnum - 1);
                this._changedtick = changedtick;
                if (curr == line) {
                    this._forceSync();
                }
                else {
                    let newLines = this.lines.slice();
                    newLines[lnum - 1] = line;
                    this.lines = newLines;
                    fireLinesChanged(this.bufnr);
                    this._forceSync();
                }
            }
            else {
                this.fetchContent.clear();
                await this._fetchContent(true);
            }
        }
        else {
            // changedtick from buffer events could be not latest. #3003
            this._changedtick = await this.buffer.getVar('changedtick');
            this._forceSync();
        }
    }
    /**
     * Used by vim8 to fetch lines.
     */
    onTextChange(event, change) {
        if (event === 'TextChanged'
            || (event === 'TextChangedI' && !change.insertChar)
            || !this._noFetch) {
            this._noFetch = false;
            this.fetchContent();
            return;
        }
        let { line, changedtick, lnum } = change;
        if (changedtick === this.changedtick)
            return;
        let newLines = this.lines.slice();
        newLines[lnum - 1] = line;
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this._changedtick = changedtick;
        if (event !== 'TextChangedP')
            this._forceSync();
    }
    /**
     * Used by vim for fetch new lines.
     */
    async _fetchContent(sync) {
        if (!constants_1.isVim || !this._attached)
            return;
        let { nvim, bufnr, changedtick } = this;
        let o = await nvim.call('coc#util#get_buf_lines', [bufnr, changedtick]);
        this._noFetch = true;
        if (o) {
            this._changedtick = o.changedtick;
            this.lines = o.lines;
            fireLinesChanged(this.bufnr);
        }
        if (sync) {
            this._forceSync();
        }
        else {
            this.fireContentChanges();
        }
    }
}
exports.default = Document;
function fireDetach(bufnr) {
    void events_1.default.fire('BufDetach', [bufnr]);
}
function fireLinesChanged(bufnr) {
    void events_1.default.fire('LinesChanged', [bufnr]);
}
function getUri(fullpath, id, buftype, isCygwin) {
    if (!fullpath)
        return `untitled:${id}`;
    if (node_1.path.isAbsolute(fullpath))
        return vscode_uri_1.URI.file(isCygwin ? fullpath : node_1.path.normalize(fullpath)).toString();
    if ((0, is_1.isUrl)(fullpath))
        return vscode_uri_1.URI.parse(fullpath).toString();
    if (buftype != '')
        return `${buftype}:${id}`;
    return `unknown:${id}`;
}
exports.getUri = getUri;
function getNotAttachReason(buftype, enabled, size) {
    if (!['', 'acwrite'].includes(buftype)) {
        return `not a normal buffer, buftype "${buftype}"`;
    }
    if (enabled === 0) {
        return `b:coc_enabled = 0`;
    }
    return `buffer size ${size} exceed coc.preferences.maxFileSize`;
}
exports.getNotAttachReason = getNotAttachReason;
//# sourceMappingURL=document.js.map