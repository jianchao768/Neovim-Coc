'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncConfigurationFeature = exports.PullConfigurationFeature = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../configuration/util");
const Is = tslib_1.__importStar(require("../util/is"));
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const features_1 = require("./features");
const UUID = tslib_1.__importStar(require("./utils/uuid"));
class PullConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    get method() {
        return protocol_1.ConfigurationRequest.method;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)(capabilities, 'workspace').configuration = true;
    }
    getState() {
        return { kind: 'static' };
    }
    initialize() {
        let client = this._client;
        let { configuredSection } = client;
        client.onRequest(protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = params => {
                let result = [];
                for (let item of params.items) {
                    let section = configuredSection ? configuredSection + (item.section ? `.${item.section}` : '') : item.section;
                    result.push(this.getConfiguration(item.scopeUri, section));
                }
                return result;
            };
            let middleware = client.middleware.workspace;
            return (middleware === null || middleware === void 0 ? void 0 : middleware.configuration)
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = (0, util_1.toJSONObject)(workspace_1.default.getConfiguration(undefined, resource).get(section));
            }
            else {
                let config = workspace_1.default.getConfiguration(section.substr(0, index), resource);
                result = (0, util_1.toJSONObject)(config.get(section.substr(index + 1)));
            }
        }
        else {
            let config = workspace_1.default.getConfiguration(section, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = (0, util_1.toJSONObject)(config.get(key));
                }
            }
        }
        return result !== null && result !== void 0 ? result : null;
    }
    dispose() {
    }
}
exports.PullConfigurationFeature = PullConfigurationFeature;
class SyncConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        var _a;
        let section = (_a = this._client.clientOptions.synchronize) === null || _a === void 0 ? void 0 : _a.configurationSection;
        if (section !== undefined) {
            let id = this.configuredUID = UUID.generateUuid();
            this.register({
                id,
                registerOptions: {
                    section
                }
            });
        }
    }
    register(data) {
        if (this._client.configuredSection && data.id !== this.configuredUID)
            return;
        let { section } = data.registerOptions;
        let disposable = workspace_1.default.onDidChangeConfiguration(event => {
            this.onDidChangeConfiguration(section, event);
        });
        this._listeners.set(data.id, disposable);
        if (section !== undefined) {
            this.onDidChangeConfiguration(section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        var _a;
        let { configuredSection } = this._client;
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections != null && event != null) {
            let keys = sections.map(s => s.startsWith('languageserver.') ? 'languageserver' : s);
            let affected = keys.some(section => event.affectsConfiguration(section));
            if (!affected)
                return;
        }
        let didChangeConfiguration = (sections) => {
            if (sections == null) {
                return this._client.sendNotification(protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            }
            let workspaceFolder = this._client.clientOptions.workspaceFolder;
            let settings = configuredSection ? SyncConfigurationFeature.getConfiguredSettings(configuredSection, workspaceFolder) : SyncConfigurationFeature.extractSettingsInformation(sections, workspaceFolder);
            return this._client.sendNotification(protocol_1.DidChangeConfigurationNotification.type, { settings });
        };
        let middleware = (_a = this._client.middleware.workspace) === null || _a === void 0 ? void 0 : _a.didChangeConfiguration;
        let promise = middleware ? Promise.resolve(middleware(sections, didChangeConfiguration)) : didChangeConfiguration(sections);
        promise.catch(error => {
            this._client.error(`Sending notification ${protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
    }
    static getConfiguredSettings(key, workspaceFolder) {
        let len = '.settings'.length;
        let config = workspace_1.default.getConfiguration(key.slice(0, -len), workspaceFolder);
        return (0, util_1.mergeConfigProperties)(config.get('settings', {}));
    }
    static extractSettingsInformation(keys, workspaceFolder) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config;
            if (index >= 0) {
                config = workspace_1.default.getConfiguration(key.substr(0, index), workspaceFolder).get(key.substr(index + 1));
            }
            else {
                config = workspace_1.default.getConfiguration(key, workspaceFolder);
            }
            let path = keys[i].split('.');
            ensurePath(result, path)[path[path.length - 1]] = config;
        }
        return result;
    }
}
exports.SyncConfigurationFeature = SyncConfigurationFeature;
//# sourceMappingURL=configuration.js.map