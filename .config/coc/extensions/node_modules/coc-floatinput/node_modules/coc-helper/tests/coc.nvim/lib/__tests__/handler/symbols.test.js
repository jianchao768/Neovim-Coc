"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const window_1 = tslib_1.__importDefault(require("../../window"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
const parser_1 = tslib_1.__importDefault(require("./parser"));
const documentSymbolManager_1 = require("../../provider/documentSymbolManager");
let nvim;
let symbols;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    symbols = helper_1.default.plugin.getHandler().symbols;
});
beforeEach(() => {
    disposables.push(languages_1.default.registerDocumentSymbolProvider([{ language: 'javascript' }], {
        provideDocumentSymbols: document => {
            let text = document.getText();
            let parser = new parser_1.default(text, text.includes('detail'));
            let res = parser.parse();
            return Promise.resolve(res);
        }
    }));
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    disposables = [];
    await helper_1.default.reset();
});
describe('Parser', () => {
    it('should parse content', async () => {
        let code = `class myClass {
      fun1() { }
    }`;
        let parser = new parser_1.default(code);
        let res = parser.parse();
        expect(res.length).toBeGreaterThan(0);
    });
});
describe('symbols handler', () => {
    async function createBuffer(code) {
        let buf = await nvim.buffer;
        await nvim.command('setf javascript');
        await buf.setLines(code.split('\n'), { start: 0, end: -1, strictIndexing: false });
        let doc = await workspace_1.default.document;
        doc.forceSync();
        return buf;
    }
    describe('configuration', () => {
        it('should get configuration', async () => {
            let bufnr = await nvim.call('bufnr', ['%']);
            let functionUpdate = symbols.autoUpdate(bufnr);
            expect(functionUpdate).toBe(false);
            helper_1.default.updateConfiguration('coc.preferences.currentFunctionSymbolAutoUpdate', true);
            functionUpdate = symbols.autoUpdate(bufnr);
            expect(functionUpdate).toBe(true);
        });
        it('should update symbols automatically', async () => {
            helper_1.default.updateConfiguration('coc.preferences.currentFunctionSymbolAutoUpdate', true);
            let code = `class myClass {
      fun1() {
      }
    }`;
            let buf = await createBuffer(code);
            await events_1.default.fire('CursorHold', [buf.id, [2, 8]]);
            let val = await buf.getVar('coc_current_function');
            expect(val).toBe('fun1');
            await events_1.default.fire('CursorHold', [buf.id, [1, 8]]);
            val = await buf.getVar('coc_current_function');
            expect(val).toBe('myClass');
        });
    });
    describe('documentSymbols', () => {
        it('should create document symbol tree', () => {
            let uri = 'lsp:/1';
            let symbols = [
                vscode_languageserver_protocol_1.SymbolInformation.create('root', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), uri),
                vscode_languageserver_protocol_1.SymbolInformation.create('child', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 3, 0, 7), uri, 'root'),
                vscode_languageserver_protocol_1.SymbolInformation.create('child', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), uri, 'root'),
            ];
            let res = (0, documentSymbolManager_1.asDocumentSymbolTree)(symbols);
            expect(res.length).toBe(2);
        });
        it('should get empty metadata when provider not found', async () => {
            (0, util_1.disposeAll)(disposables);
            let doc = await workspace_1.default.document;
            let res = languages_1.default.getDocumentSymbolMetadata(doc.textDocument);
            expect(res).toBeNull();
            let symbols = await languages_1.default.getDocumentSymbol(doc.textDocument, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(symbols).toBeNull();
        });
        it('should get symbols of current buffer', async () => {
            let code = `class detail {
      fun1() { }
    }`;
            await createBuffer(code);
            let res = await helper_1.default.plugin.cocAction('documentSymbols');
            expect(res.length).toBe(2);
            expect(res[1].detail).toBeDefined();
        });
        it('should get current function symbols', async () => {
            let code = `class myClass {
      fun1() {
      }
      fun2() {
      }
    }
    `;
            await createBuffer(code);
            await nvim.call('cursor', [3, 0]);
            let res = await helper_1.default.doAction('getCurrentFunctionSymbol');
            expect(res).toBe('fun1');
            await nvim.command('normal! G');
            res = await helper_1.default.doAction('getCurrentFunctionSymbol');
            expect(res).toBe('');
        });
        it('should reset coc_current_function when symbols do not exist', async () => {
            let code = `class myClass {
      fun1() {
      }
    }`;
            await createBuffer(code);
            await nvim.call('cursor', [3, 0]);
            let res = await helper_1.default.doAction('getCurrentFunctionSymbol');
            expect(res).toBe('fun1');
            await nvim.command('normal! ggdG');
            res = await symbols.getCurrentFunctionSymbol();
            expect(res).toBe('');
        });
        it('should support SymbolInformation', async () => {
            disposables.push(languages_1.default.registerDocumentSymbolProvider(['*'], {
                provideDocumentSymbols: doc => {
                    let s = vscode_languageserver_protocol_1.SymbolInformation.create('root', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), doc.uri);
                    s.deprecated = true;
                    return [
                        s,
                        vscode_languageserver_protocol_1.SymbolInformation.create('child', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 3, 0, 7), doc.uri, 'root'),
                        vscode_languageserver_protocol_1.SymbolInformation.create('child', vscode_languageserver_protocol_1.SymbolKind.Function, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 10), doc.uri, 'root')
                    ];
                }
            }, { label: 'test' }));
            await helper_1.default.createDocument();
            let res = await symbols.getDocumentSymbols();
            expect(res.length).toBe(3);
            expect(res[0].text).toBe('root');
            await nvim.command('edit +setl\\ buftype=nofile b');
            res = await symbols.getDocumentSymbols();
            expect(res).toBeUndefined();
        });
    });
    describe('selectSymbolRange', () => {
        it('should show warning when no symbols exist', async () => {
            disposables.push(languages_1.default.registerDocumentSymbolProvider(['*'], {
                provideDocumentSymbols: () => {
                    return [];
                }
            }));
            await helper_1.default.createDocument();
            await nvim.call('cursor', [3, 0]);
            await symbols.selectSymbolRange(false, '', ['Function']);
            let msg = await helper_1.default.getCmdline();
            expect(msg).toMatch(/No symbols found/);
        });
        it('should select symbol range at cursor position', async () => {
            let code = `class myClass {
      fun1() {
      }
    }`;
            await createBuffer(code);
            await nvim.call('cursor', [3, 0]);
            await helper_1.default.doAction('selectSymbolRange', false, '', ['Function', 'Method']);
            let mode = await nvim.mode;
            expect(mode.mode).toBe('v');
            await nvim.input('<esc>');
            let res = await window_1.default.getSelectedRange('v');
            expect(res).toEqual({ start: { line: 1, character: 6 }, end: { line: 2, character: 6 } });
        });
        it('should select inner range', async () => {
            let code = `class myClass {
      fun1() {
        let foo;
      }
}`;
            await createBuffer(code);
            await nvim.call('cursor', [3, 3]);
            await symbols.selectSymbolRange(true, '', ['Method']);
            let mode = await nvim.mode;
            expect(mode.mode).toBe('v');
            await nvim.input('<esc>');
            let res = await window_1.default.getSelectedRange('v');
            expect(res).toEqual({
                start: { line: 2, character: 8 }, end: { line: 2, character: 16 }
            });
        });
        it('should reset visualmode when selection not found', async () => {
            let code = `class myClass {}`;
            await createBuffer(code);
            await nvim.call('cursor', [1, 1]);
            await nvim.command('normal! gg0v$');
            let mode = await nvim.mode;
            expect(mode.mode).toBe('v');
            await nvim.input('<esc>');
            await symbols.selectSymbolRange(true, 'v', ['Method']);
            mode = await nvim.mode;
            expect(mode.mode).toBe('v');
        });
        it('should select symbol range from select range', async () => {
            let code = `class myClass {
      fun1() {
      }
    }`;
            let buf = await createBuffer(code);
            await nvim.call('cursor', [2, 8]);
            await nvim.command('normal! viw');
            await nvim.input('<esc>');
            await helper_1.default.doAction('selectSymbolRange', false, 'v', ['Class']);
            let mode = await nvim.mode;
            expect(mode.mode).toBe('v');
            let doc = workspace_1.default.getDocument(buf.id);
            await nvim.input('<esc>');
            let res = await window_1.default.getSelectedRange('v');
            expect(res).toEqual({ start: { line: 0, character: 0 }, end: { line: 3, character: 4 } });
        });
    });
    describe('cancel', () => {
        it('should cancel symbols request on insert', async () => {
            let cancelled = false;
            disposables.push(languages_1.default.registerDocumentSymbolProvider([{ language: 'text' }], {
                provideDocumentSymbols: (_doc, token) => {
                    return new Promise(s => {
                        token.onCancellationRequested(() => {
                            if (timer)
                                clearTimeout(timer);
                            cancelled = true;
                            s(undefined);
                        });
                        let timer = setTimeout(() => {
                            s(undefined);
                        }, 3000);
                    });
                }
            }));
            let doc = await helper_1.default.createDocument('t.txt');
            let p = symbols.getDocumentSymbols(doc.bufnr);
            setTimeout(async () => {
                await nvim.input('i');
            }, 500);
            await p;
            expect(cancelled).toBe(true);
        });
    });
    describe('workspaceSymbols', () => {
        it('should get workspace symbols', async () => {
            var _a;
            disposables.push(languages_1.default.registerWorkspaceSymbolProvider({
                provideWorkspaceSymbols: (_query, _token) => {
                    return [vscode_languageserver_protocol_1.SymbolInformation.create('far', vscode_languageserver_protocol_1.SymbolKind.Class, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), '')];
                },
                resolveWorkspaceSymbol: sym => {
                    let res = Object.assign({}, sym);
                    res.location.uri = 'test:///foo';
                    return res;
                }
            }));
            let fn = languages_1.default.registerWorkspaceSymbolProvider.bind(languages_1.default);
            disposables.push(fn('vim', {
                provideWorkspaceSymbols: (_query, _token) => {
                    return null;
                }
            }));
            let res = await symbols.getWorkspaceSymbols('a');
            expect(res.length).toBe(1);
            let resolved = await helper_1.default.doAction('resolveWorkspaceSymbol', res[0]);
            expect((_a = resolved === null || resolved === void 0 ? void 0 : resolved.location) === null || _a === void 0 ? void 0 : _a.uri).toBe('test:///foo');
        });
        it('should return symbol when resolve failed', async () => {
            disposables.push(languages_1.default.registerWorkspaceSymbolProvider({
                provideWorkspaceSymbols: (_query, _token) => {
                    return [vscode_languageserver_protocol_1.SymbolInformation.create('far', vscode_languageserver_protocol_1.SymbolKind.Class, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0), '')];
                }
            }));
            let res = await helper_1.default.doAction('getWorkspaceSymbols');
            let resolved = await symbols.resolveWorkspaceSymbol(res[0]);
            expect(resolved).toBeDefined();
        });
    });
});
//# sourceMappingURL=symbols.test.js.map