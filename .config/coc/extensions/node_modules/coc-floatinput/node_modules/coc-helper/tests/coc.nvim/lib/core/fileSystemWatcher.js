'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemWatcher = exports.FileSystemWatcherManager = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const logger_1 = require("../logger");
const util_1 = require("../util");
const array_1 = require("../util/array");
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const watchman_1 = tslib_1.__importDefault(require("./watchman"));
const logger = (0, logger_1.createLogger)('fileSystemWatcher');
class FileSystemWatcherManager {
    constructor(workspaceFolder, watchmanPath) {
        this.workspaceFolder = workspaceFolder;
        this.watchmanPath = watchmanPath;
        this.clientsMap = new Map();
        this.disposables = [];
        this.creating = new Set();
        this._onDidCreateClient = new protocol_1.Emitter();
        this.disabled = global.__TEST__;
        this.onDidCreateClient = this._onDidCreateClient.event;
    }
    attach(channel) {
        this.channel = channel;
        let createClient = (folder) => {
            let root = vscode_uri_1.URI.parse(folder.uri).fsPath;
            void this.createClient(root);
        };
        this.workspaceFolder.workspaceFolders.forEach(folder => {
            createClient(folder);
        });
        this.workspaceFolder.onDidChangeWorkspaceFolders(e => {
            e.added.forEach(folder => {
                createClient(folder);
            });
            e.removed.forEach(folder => {
                let root = vscode_uri_1.URI.parse(folder.uri).fsPath;
                let client = this.clientsMap.get(root);
                if (client) {
                    this.clientsMap.delete(root);
                    client.dispose();
                }
            });
        }, null, this.disposables);
    }
    waitClient(root) {
        if (this.clientsMap.has(root))
            return Promise.resolve();
        return new Promise(resolve => {
            let disposable = this.onDidCreateClient(r => {
                if (r == root) {
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    async createClient(root) {
        if (this.watchmanPath == null || this.has(root) || this.disabled)
            return;
        try {
            let watchmanPath = await this.getWatchmanPath();
            this.creating.add(root);
            let client = await watchman_1.default.createClient(watchmanPath, root, this.channel);
            this.creating.delete(root);
            this.clientsMap.set(root, client);
            for (let watcher of FileSystemWatcherManager.watchers) {
                watcher.listen(root, client);
            }
            this._onDidCreateClient.fire(root);
        }
        catch (e) {
            this.creating.delete(root);
            if (this.channel)
                this.channel.appendLine(`Error on create watchman client: ${e}`);
        }
    }
    async getWatchmanPath() {
        let watchmanPath = this.watchmanPath;
        if (!process.env.WATCHMAN_SOCK) {
            watchmanPath = await (0, node_1.which)(this.watchmanPath, { all: false });
        }
        return watchmanPath;
    }
    has(root) {
        let curr = Array.from(this.clientsMap.keys());
        curr.push(...this.creating);
        return curr.some(r => (0, fs_1.sameFile)(r, root));
    }
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        let fileWatcher = new FileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        let base = typeof globPattern === 'string' ? undefined : globPattern.baseUri.fsPath;
        for (let [root, client] of this.clientsMap.entries()) {
            if (base && (0, fs_1.isParentFolder)(root, base, true)) {
                base = undefined;
            }
            fileWatcher.listen(root, client);
        }
        if (base)
            void this.createClient(base);
        FileSystemWatcherManager.watchers.add(fileWatcher);
        return fileWatcher;
    }
    dispose() {
        this._onDidCreateClient.dispose();
        for (let client of this.clientsMap.values()) {
            if (client)
                client.dispose();
        }
        this.clientsMap.clear();
        FileSystemWatcherManager.watchers.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.FileSystemWatcherManager = FileSystemWatcherManager;
FileSystemWatcherManager.watchers = new Set();
/*
 * FileSystemWatcher for watch workspace folders.
 */
class FileSystemWatcher {
    constructor(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new protocol_1.Emitter();
        this._onDidChange = new protocol_1.Emitter();
        this._onDidDelete = new protocol_1.Emitter();
        this._onDidRename = new protocol_1.Emitter();
        this.disposables = [];
        this._disposed = false;
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
        this._onDidListen = new protocol_1.Emitter();
        this.onDidListen = this._onDidListen.event;
    }
    listen(root, client) {
        let { globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents } = this;
        let pattern;
        let basePath;
        if (typeof globPattern === 'string') {
            pattern = globPattern;
        }
        else {
            pattern = globPattern.pattern;
            basePath = globPattern.baseUri.fsPath;
            // ignore client
            if (!(0, fs_1.isParentFolder)(root, basePath, true))
                return;
        }
        const onChange = (change) => {
            let { root, files } = change;
            if (basePath && !(0, fs_1.sameFile)(root, basePath)) {
                files = files.filter(f => {
                    if (f.type != 'f')
                        return false;
                    let fullpath = node_1.path.join(root, f.name);
                    if (!(0, fs_1.isParentFolder)(basePath, fullpath))
                        return false;
                    return (0, node_1.minimatch)(node_1.path.relative(basePath, fullpath), pattern, { dot: true });
                });
            }
            else {
                files = files.filter(f => f.type == 'f' && (0, node_1.minimatch)(f.name, pattern, { dot: true }));
            }
            for (let file of files) {
                let uri = vscode_uri_1.URI.file(node_1.path.join(root, file.name));
                if (!file.exists) {
                    if (!ignoreDeleteEvents)
                        this._onDidDelete.fire(uri);
                }
                else {
                    if (file.new === true) {
                        if (!ignoreCreateEvents)
                            this._onDidCreate.fire(uri);
                    }
                    else {
                        if (!ignoreChangeEvents)
                            this._onDidChange.fire(uri);
                    }
                }
            }
            // file rename
            if (files.length == 2 && files[0].exists !== files[1].exists) {
                let oldFile = files.find(o => o.exists !== true);
                let newFile = files.find(o => o.exists === true);
                if (oldFile.size == newFile.size) {
                    this._onDidRename.fire({
                        oldUri: vscode_uri_1.URI.file(node_1.path.join(root, oldFile.name)),
                        newUri: vscode_uri_1.URI.file(node_1.path.join(root, newFile.name))
                    });
                }
            }
            // detect folder rename
            if (files.length > 2 && files.length % 2 == 0) {
                let [oldFiles, newFiles] = (0, array_1.splitArray)(files, o => o.exists === false);
                if (oldFiles.length == newFiles.length) {
                    for (let oldFile of oldFiles) {
                        let newFile = newFiles.find(o => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                        if (newFile) {
                            this._onDidRename.fire({
                                oldUri: vscode_uri_1.URI.file(node_1.path.join(root, oldFile.name)),
                                newUri: vscode_uri_1.URI.file(node_1.path.join(root, newFile.name))
                            });
                        }
                    }
                }
            }
        };
        client.subscribe(pattern, onChange).then(disposable => {
            if (!disposable)
                return;
            this._onDidListen.fire();
            this.subscribe = disposable.subscribe;
            if (this._disposed)
                return disposable.dispose();
            this.disposables.push(disposable);
        }, e => {
            if (e instanceof Error && e.message.includes('client was ended'))
                return;
            logger.error(`Error on subscribe ${pattern}`, e);
        });
    }
    dispose() {
        this._disposed = true;
        FileSystemWatcherManager.watchers.delete(this);
        this._onDidRename.dispose();
        this._onDidCreate.dispose();
        this._onDidChange.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.FileSystemWatcher = FileSystemWatcher;
//# sourceMappingURL=fileSystemWatcher.js.map