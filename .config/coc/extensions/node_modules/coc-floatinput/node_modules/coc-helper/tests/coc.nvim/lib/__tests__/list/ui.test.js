"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = require("events");
const basic_1 = tslib_1.__importDefault(require("../../list/basic"));
const events_2 = tslib_1.__importDefault(require("../../events"));
const manager_1 = tslib_1.__importDefault(require("../../list/manager"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let labels = [];
let lastItem;
class SimpleList extends basic_1.default {
    constructor() {
        super();
        this.name = 'simple';
        this.addAction('open', item => {
            lastItem = item.label;
        });
    }
    loadItems() {
        return Promise.resolve(labels.map(s => {
            return { label: s, ansiHighlights: [{ span: [0, 1], hlGroup: 'MoreMsg' }] };
        }));
    }
}
class SlowTask extends events_1.EventEmitter {
    constructor() {
        super();
        let i = 0;
        let interval = this.interval = setInterval(() => {
            i++;
            this.emit('data', {
                label: i.toString(), highlights: {
                    spans: [[0, 1]],
                    hlGroup: 'Search'
                }
            });
            if (i == 5) {
                this.emit('end');
                clearInterval(interval);
            }
        }, 50);
    }
    dispose() {
        clearInterval(this.interval);
        this.removeAllListeners();
    }
}
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    manager_1.default.reset();
    await helper_1.default.reset();
});
describe('list ui', () => {
    describe('selectLines()', () => {
        it('should select lines', async () => {
            labels = ['foo', 'bar'];
            disposables.push(manager_1.default.registerList(new SimpleList()));
            await manager_1.default.start(['simple']);
            let ui = manager_1.default.session.ui;
            await ui.ready;
            await ui.selectLines(3, 1);
            let buf = await nvim.buffer;
            let res = await buf.getSigns({ group: 'coc-list' });
            expect(res.length).toBe(2);
        });
    });
    describe('preselect', () => {
        it('should select preselect item', async () => {
            let list = {
                actions: [{
                        name: 'open',
                        execute: () => { }
                    }],
                name: 'preselect',
                defaultAction: 'open',
                loadItems: () => {
                    return Promise.resolve([{ label: 'foo' }, { label: 'bar', preselect: true }]);
                }
            };
            disposables.push(manager_1.default.registerList(list));
            await manager_1.default.start(['--tab', 'preselect']);
            let ui = manager_1.default.session.ui;
            await ui.ready;
            ui.restoreWindow();
            let line = await nvim.line;
            expect(line).toBe('bar');
        });
    });
    describe('resume()', () => {
        it('should resume with selected lines', async () => {
            labels = ['foo', 'bar'];
            disposables.push(manager_1.default.registerList(new SimpleList()));
            await manager_1.default.start(['simple']);
            let ui = manager_1.default.session.ui;
            await ui.ready;
            await ui.selectLines(1, 2);
            await nvim.call('coc#window#close', [ui.winid]);
            await helper_1.default.wait(100);
            await manager_1.default.session.resume();
            await helper_1.default.wait(100);
            let buf = await nvim.buffer;
            let res = await buf.getSigns({ group: 'coc-list' });
            expect(res.length).toBe(2);
        });
    });
    describe('events', () => {
        async function mockMouse(winid, lnum) {
            await nvim.command(`let v:mouse_winid = ${winid}`);
            await nvim.command(`let v:mouse_lnum = ${lnum}`);
            await nvim.command('let v:mouse_col = 1');
        }
        it('should fire action on double click', async () => {
            labels = ['foo', 'bar'];
            disposables.push(manager_1.default.registerList(new SimpleList()));
            await manager_1.default.start(['simple']);
            let ui = manager_1.default.session.ui;
            await ui.ready;
            await mockMouse(ui.winid, 1);
            await manager_1.default.session.onMouseEvent('<2-LeftMouse>');
            await helper_1.default.waitValue(() => lastItem, 'foo');
        });
        it('should select clicked line', async () => {
            labels = ['foo', 'bar'];
            disposables.push(manager_1.default.registerList(new SimpleList()));
            await manager_1.default.start(['simple']);
            let ui = manager_1.default.session.ui;
            ui.updateItem(undefined, 0);
            ui.setLines([], 0, 0);
            await ui.onMouse('mouseDown');
            await ui.ready;
            await mockMouse(ui.winid, 2);
            await ui.onMouse('mouseDrag');
            await ui.onMouse('mouseUp');
            await ui.onMouse('mouseDown');
            await mockMouse(ui.winid, 2);
            await ui.onMouse('mouseUp');
            let item = await ui.item;
            await ui.appendItems([]);
            expect(item.label).toBe('bar');
        });
        it('should jump to original window on click', async () => {
            labels = ['foo', 'bar'];
            let win = await nvim.window;
            disposables.push(manager_1.default.registerList(new SimpleList()));
            await manager_1.default.start(['simple']);
            let ui = manager_1.default.session.ui;
            await ui.ready;
            await mockMouse(win.id, 1);
            await ui.onMouse('mouseUp');
            await helper_1.default.wait(50);
            let curr = await nvim.window;
            expect(curr.id).toBe(win.id);
        });
        it('should highlights items on CursorMoved', async () => {
            labels = (new Array(400)).fill('a');
            disposables.push(manager_1.default.registerList(new SimpleList()));
            await manager_1.default.start(['--normal', 'simple']);
            let ui = manager_1.default.session.ui;
            await ui.ready;
            await nvim.call('cursor', [350, 1]);
            await events_2.default.fire('CursorMoved', [ui.bufnr, [350, 1]]);
            await helper_1.default.wait(100);
            let res = await nvim.call('coc#highlight#get_highlights', [ui.bufnr, 'list']);
            expect(res.length).toBeGreaterThan(300);
        });
    });
});
describe('reversed list', () => {
    it('should render and add highlights', async () => {
        labels = ['a', 'b', 'c', 'd'];
        disposables.push(manager_1.default.registerList(new SimpleList()));
        await manager_1.default.start(['--reverse', 'simple']);
        let ui = manager_1.default.session.ui;
        await ui.ready;
        let buf = nvim.createBuffer(ui.bufnr);
        let lines = await buf.lines;
        expect(lines).toEqual(['d', 'c', 'b', 'a']);
        await helper_1.default.listInput('a');
        await helper_1.default.wait(50);
        lines = await buf.lines;
        expect(lines).toEqual(['a']);
        let res = await nvim.call('coc#highlight#get_highlights', [ui.bufnr, 'list']);
        expect(res.length).toBe(2);
        let win = nvim.createWindow(ui.winid);
        let height = await win.height;
        expect(height).toBe(1);
    });
    it('should moveUp and moveDown', async () => {
        labels = ['a', 'b', 'c', 'd'];
        disposables.push(manager_1.default.registerList(new SimpleList()));
        await manager_1.default.start(['--reverse', 'simple']);
        let ui = manager_1.default.session.ui;
        await ui.ready;
        await ui.moveCursor(-1);
        await helper_1.default.waitFor('line', ['.'], 3);
        await ui.moveCursor(1);
        await helper_1.default.waitFor('line', ['.'], 4);
    });
    it('should toggle selection', async () => {
        labels = ['a', 'b', 'c', 'd'];
        disposables.push(manager_1.default.registerList(new SimpleList()));
        await manager_1.default.start(['--reverse', '--normal', 'simple']);
        let ui = manager_1.default.session.ui;
        await ui.ready;
        await ui.toggleSelection();
        let items = ui.selectedItems;
        expect(items.length).toBeGreaterThan(0);
        expect(items[0].label).toBe('a');
        let lnum = await nvim.call('line', ['.']);
        expect(lnum).toBe(3);
        await helper_1.default.listInput('j');
        await ui.toggleSelection();
        items = ui.selectedItems;
        expect(items.length).toBe(0);
    });
    it('should prepend list items', async () => {
        let o;
        let p = new Promise(resolve => {
            let list = {
                actions: [{
                        name: 'open',
                        execute: item => {
                            o = item;
                        }
                    }],
                name: 'slow',
                defaultAction: 'open',
                loadItems: () => {
                    let task = new SlowTask();
                    task.on('end', () => {
                        resolve(undefined);
                    });
                    return Promise.resolve(task);
                }
            };
            disposables.push(manager_1.default.registerList(list));
            void manager_1.default.start(['--reverse', '--normal', 'slow']);
        });
        let ui = manager_1.default.session.ui;
        ui.setCursor(99);
        await p;
        await helper_1.default.wait(50);
        // ui.setCursor(2)
        let buf = nvim.createBuffer(ui.bufnr);
        let lines = await buf.lines;
        expect(lines).toEqual(['5', '4', '3', '2', '1']);
        let lnum = await nvim.call('line', ['.']);
        expect(lnum).toBe(5);
    });
});
//# sourceMappingURL=ui.test.js.map