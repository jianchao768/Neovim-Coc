"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let folds;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    folds = helper_1.default.plugin.getHandler().fold;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    await helper_1.default.createDocument();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('Folds', () => {
    it('should return empty array when provider does not exist', async () => {
        let doc = await workspace_1.default.document;
        let token = (new vscode_languageserver_protocol_1.CancellationTokenSource()).token;
        expect(await languages_1.default.provideFoldingRanges(doc.textDocument, {}, token)).toEqual([]);
    });
    it('should return false when no fold ranges found', async () => {
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges(_doc) {
                return [];
            }
        }));
        let res = await helper_1.default.doAction('fold');
        expect(res).toBe(false);
    });
    it('should fold all fold ranges', async () => {
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges(_doc) {
                return [vscode_languageserver_protocol_1.FoldingRange.create(1, 3), vscode_languageserver_protocol_1.FoldingRange.create(4, 6, 0, 0, 'comment')];
            }
        }));
        await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']]);
        let res = await folds.fold();
        expect(res).toBe(true);
        let closed = await nvim.call('foldclosed', [2]);
        expect(closed).toBe(2);
        closed = await nvim.call('foldclosed', [5]);
        expect(closed).toBe(5);
    });
    it('should merge folds from all providers', async () => {
        let doc = await workspace_1.default.document;
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges() {
                return [vscode_languageserver_protocol_1.FoldingRange.create(2, 3), vscode_languageserver_protocol_1.FoldingRange.create(4, 6)];
            }
        }));
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges() {
                return [vscode_languageserver_protocol_1.FoldingRange.create(1, 2), vscode_languageserver_protocol_1.FoldingRange.create(5, 6), vscode_languageserver_protocol_1.FoldingRange.create(7, 8)];
            }
        }));
        await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']]);
        await doc.synchronize();
        let foldingRanges = await languages_1.default.provideFoldingRanges(doc.textDocument, {}, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(foldingRanges.length).toBe(4);
    });
    it('should ignore range start at the same line', async () => {
        let doc = await workspace_1.default.document;
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges() {
                return [vscode_languageserver_protocol_1.FoldingRange.create(2, 3), vscode_languageserver_protocol_1.FoldingRange.create(4, 6)];
            }
        }));
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges() {
                return [vscode_languageserver_protocol_1.FoldingRange.create(4, 5)];
            }
        }));
        await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']]);
        await doc.synchronize();
        let foldingRanges = await languages_1.default.provideFoldingRanges(doc.textDocument, {}, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(foldingRanges.length).toBe(2);
    });
    it('should fold comment ranges', async () => {
        disposables.push(languages_1.default.registerFoldingRangeProvider([{ language: '*' }], {
            provideFoldingRanges(_doc) {
                return [vscode_languageserver_protocol_1.FoldingRange.create(1, 3), vscode_languageserver_protocol_1.FoldingRange.create(4, 6, 0, 0, 'comment')];
            }
        }));
        await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']]);
        let res = await folds.fold('comment');
        expect(res).toBe(true);
        let closed = await nvim.call('foldclosed', [2]);
        expect(closed).toBe(-1);
        closed = await nvim.call('foldclosed', [5]);
        expect(closed).toBe(5);
    });
});
//# sourceMappingURL=fold.test.js.map