'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const commands_1 = tslib_1.__importDefault(require("../commands"));
const session_1 = tslib_1.__importDefault(require("./session"));
const util_1 = require("./util");
class Cursors {
    constructor(nvim) {
        this.nvim = nvim;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        workspace_1.default.onDidCloseTextDocument(e => {
            let session = this.getSession(e.bufnr);
            if (!session)
                return;
            this.sessionsMap.delete(e.bufnr);
            session.dispose();
        }, null, this.disposables);
        this.disposables.push(commands_1.default.registerCommand('editor.action.addRanges', async (ranges) => {
            await this.addRanges(ranges);
        }, null, true));
    }
    loadConfiguration(e) {
        if (!e || e.affectsConfiguration('cursors')) {
            let config = workspace_1.default.initialConfiguration;
            this.config = config.get('cursors');
        }
    }
    cancel(uri) {
        let doc = workspace_1.default.getDocument(uri);
        if (!doc)
            return;
        let session = this.getSession(doc.bufnr);
        if (session)
            session.cancel();
    }
    getSession(bufnr) {
        return this.sessionsMap.get(bufnr);
    }
    async isActivated() {
        let bufnr = await this.nvim.call('bufnr', ['%']);
        return this.sessionsMap.get(bufnr) != null;
    }
    async select(bufnr, kind, mode) {
        let doc = workspace_1.default.getAttachedDocument(bufnr);
        let { nvim } = this;
        let session = this.createSession(doc);
        let range;
        if (kind == 'operator') {
            let res = await nvim.eval(`[getpos("'["),getpos("']")]`);
            if (mode == 'char') {
                let start = doc.getPosition(res[0][1], res[0][2]);
                let end = doc.getPosition(res[1][1], res[1][2] + 1);
                let ranges = (0, util_1.splitRange)(doc, vscode_languageserver_types_1.Range.create(start, end));
                session.addRanges(ranges);
            }
            else {
                let ranges = [];
                for (let i = res[0][1] - 1; i <= res[1][1] - 1; i++) {
                    let line = doc.getline(i);
                    ranges.push(vscode_languageserver_types_1.Range.create(i, 0, i, line.length));
                }
                session.addRanges(ranges);
            }
        }
        else if (kind == 'word') {
            let pos = await window_1.default.getCursorPosition();
            range = doc.getWordRangeAtPosition(pos);
            if (!range) {
                let line = doc.getline(pos.line);
                if (pos.character == line.length) {
                    range = vscode_languageserver_types_1.Range.create(pos.line, Math.max(0, line.length - 1), pos.line, line.length);
                }
                else {
                    range = vscode_languageserver_types_1.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
                }
            }
            session.addRange(range);
            await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        }
        else if (kind == 'position') {
            let pos = await window_1.default.getCursorPosition();
            // make sure range contains character for highlight
            let line = doc.getline(pos.line);
            if (pos.character >= line.length) {
                range = vscode_languageserver_types_1.Range.create(pos.line, line.length - 1, pos.line, line.length);
            }
            else {
                range = vscode_languageserver_types_1.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
            }
            session.addRange(range);
            await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        }
        else if (kind == 'range') {
            await nvim.call('eval', 'feedkeys("\\<esc>", "in")');
            let range = await window_1.default.getSelectedRange(mode);
            if (!range)
                return;
            let ranges = mode == '\x16' ? (0, util_1.getVisualRanges)(doc, range) : (0, util_1.splitRange)(doc, range);
            for (let r of ranges) {
                session.addRange(r);
            }
        }
        else {
            throw new Error(`select kind "${kind}" not supported`);
        }
    }
    createSession(doc) {
        let { bufnr } = doc;
        let session = this.getSession(bufnr);
        if (session)
            return session;
        session = new session_1.default(this.nvim, doc, this.config);
        this.sessionsMap.set(bufnr, session);
        session.onDidCancel(() => {
            session.dispose();
            this.sessionsMap.delete(bufnr);
        });
        return session;
    }
    // Add ranges to current document
    async addRanges(ranges) {
        let { nvim } = this;
        let bufnr = await nvim.call('bufnr', ['%']);
        let doc = workspace_1.default.getAttachedDocument(bufnr);
        let session = this.createSession(doc);
        return session.addRanges(ranges);
    }
    reset() {
        for (let session of this.sessionsMap.values()) {
            session.cancel();
        }
        this.sessionsMap.clear();
    }
}
exports.default = Cursors;
//# sourceMappingURL=index.js.map