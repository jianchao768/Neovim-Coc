'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependencies = exports.Installer = exports.isYarn = exports.isNpmCommand = exports.registryUrl = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const url_1 = require("url");
const uuid_1 = require("uuid");
const logger_1 = require("../logger");
const download_1 = tslib_1.__importDefault(require("../model/download"));
const fetch_1 = tslib_1.__importDefault(require("../model/fetch"));
const fs_1 = require("../util/fs");
const node_1 = require("../util/node");
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const logger = (0, logger_1.createLogger)('extension-installer');
const local_dependencies = ['coc.nvim', 'esbuild', 'webpack', '@types/node'];
function registryUrl(home = node_1.os.homedir()) {
    let res;
    let filepath = node_1.path.join(home, '.npmrc');
    if (node_1.fs.existsSync(filepath)) {
        try {
            let content = node_1.fs.readFileSync(filepath, 'utf8');
            let uri;
            for (let line of content.split(/\r?\n/)) {
                if (line.startsWith('#'))
                    continue;
                let ms = line.match(/^(.*?)=(.*)$/);
                if (ms && ms[1] === 'coc.nvim:registry') {
                    uri = ms[2];
                }
            }
            if (uri)
                res = new url_1.URL(uri);
        }
        catch (e) {
            logger.debug('Error on parse .npmrc:', e);
        }
    }
    return res !== null && res !== void 0 ? res : new url_1.URL('https://registry.npmjs.org');
}
exports.registryUrl = registryUrl;
function isNpmCommand(exePath) {
    let name = node_1.path.basename(exePath);
    return name === 'npm' || name === 'npm.CMD';
}
exports.isNpmCommand = isNpmCommand;
function isYarn(exePath) {
    let name = node_1.path.basename(exePath);
    return ['yarn', 'yarn.CMD', 'yarnpkg', 'yarnpkg.CMD'].includes(name);
}
exports.isYarn = isYarn;
function isPnpm(exePath) {
    let name = node_1.path.basename(exePath);
    return name === 'pnpm' || name === 'pnpm.CMD';
}
function isSymbolicLink(folder) {
    if (node_1.fs.existsSync(folder)) {
        let stat = node_1.fs.lstatSync(folder);
        if (stat.isSymbolicLink()) {
            return true;
        }
    }
    return false;
}
class Installer extends events_1.EventEmitter {
    constructor(root, npm, 
    // could be url or name@version or name
    def) {
        super();
        this.root = root;
        this.npm = npm;
        this.def = def;
        if (/^https?:/.test(def)) {
            this.url = def;
        }
        else {
            let ms = def.match(/(.+)@([^/]+)$/);
            if (ms) {
                this.name = ms[1];
                this.version = ms[2];
            }
            else {
                this.name = def;
            }
        }
    }
    get info() {
        return { name: this.name, version: this.version };
    }
    async getInfo() {
        if (this.url)
            return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let buffer = await this.fetch(new url_1.URL(this.name, registry), { timeout: 10000, buffer: true });
        let res = JSON.parse(buffer.toString());
        if (!this.version)
            this.version = res['dist-tags']['latest'];
        let obj = res['versions'][this.version];
        if (!obj)
            throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj['engines'] && obj['engines']['coc'];
        if (!requiredVersion)
            throw new Error(`${this.def} is not a valid coc extension, "engines" field with coc property required.`);
        return {
            'dist.tarball': obj['dist']['tarball'],
            'engines.coc': requiredVersion,
            version: obj['version'],
            name: res.name
        };
    }
    async getInfoFromUri() {
        let { url } = this;
        if (!url.startsWith('https://github.com')) {
            throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, '');
        let branch = 'master';
        if (url.includes('@')) {
            // https://github.com/sdras/vue-vscode-snippets@main
            let idx = url.indexOf('@');
            branch = url.substr(idx + 1);
            url = url.substring(0, idx);
        }
        let fileUrl = url.replace('github.com', 'raw.githubusercontent.com') + `/${branch}/package.json`;
        this.log(`Get info from ${fileUrl}`);
        let content = await this.fetch(fileUrl, { timeout: 10000 });
        let obj = typeof content == 'string' ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
            'dist.tarball': `${url}/archive/${branch}.tar.gz`,
            'engines.coc': obj['engines'] ? obj['engines']['coc'] : null,
            name: obj.name,
            version: obj.version
        };
    }
    log(msg, isProgress = false) {
        this.emit('message', msg, isProgress);
    }
    async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger.info(`Fetched info of ${this.def}`, info);
        let { name, version } = info;
        let required = (0, string_1.toText)(info['engines.coc']).replace(/^\^/, '>=');
        if (required && !node_1.semver.satisfies(workspace_1.default.version, required)) {
            throw new Error(`${name} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        let updated = await this.doInstall(info);
        return { name, updated, version, url: this.url, folder: node_1.path.join(this.root, info.name) };
    }
    async update(url) {
        if (url)
            this.url = url;
        let version;
        if (this.name) {
            let folder = node_1.path.join(this.root, this.name);
            if (isSymbolicLink(folder)) {
                this.log(`Skipped update for symbol link`);
                return;
            }
            let obj = (0, fs_1.loadJson)(node_1.path.join(folder, 'package.json'));
            version = obj.version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version && info.version && node_1.semver.gte(version, info.version)) {
            this.log(`Current version ${version} is up to date.`);
            return;
        }
        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\^/, '>=') : '';
        if (required && !node_1.semver.satisfies(workspace_1.default.version, required)) {
            throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        let succeed = await this.doInstall(info);
        if (!succeed)
            return;
        let jsonFile = node_1.path.join(this.root, info.name, 'package.json');
        this.log(`Updated to v${info.version}`);
        return node_1.path.dirname(jsonFile);
    }
    getInstallArguments(exePath, url) {
        let args = ['install', '--ignore-scripts', '--no-lockfile'];
        if (url && url.startsWith('https://github.com')) {
            args = ['install'];
        }
        if (isNpmCommand(exePath)) {
            args.push('--omit=dev');
            args.push('--legacy-peer-deps');
            args.push('--no-global');
        }
        if (isYarn(exePath)) {
            args.push('--production');
            args.push('--ignore-engines');
        }
        if (isPnpm(exePath)) {
            args.push('--production');
            args.push('--config.strict-peer-dependencies=false');
        }
        return args;
    }
    readLines(key, stream) {
        const rl = node_1.readline.createInterface({
            input: stream
        });
        rl.on('line', line => {
            this.log(`${key} ${line}`, true);
        });
    }
    installDependencies(folder, dependencies) {
        if (dependencies.length == 0)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            let args = this.getInstallArguments(this.npm, this.url);
            this.log(`Installing dependencies by: ${this.npm} ${args.join(' ')}.`);
            const child = node_1.child_process.spawn(this.npm, args, {
                cwd: folder,
                env: Object.assign(process.env, { NODE_ENV: 'production' })
            });
            this.readLines('[npm stdout]', child.stdout);
            this.readLines('[npm stderr]', child.stderr);
            child.stderr.setEncoding('utf8');
            child.stdout.setEncoding('utf8');
            child.on('error', reject);
            child.on('exit', code => {
                if (code) {
                    reject(new Error(`${this.npm} install exited with ${code}`));
                    return;
                }
                resolve();
            });
        });
    }
    async doInstall(info) {
        let dest = node_1.path.join(this.root, info.name);
        if (isSymbolicLink(dest))
            return false;
        let key = info.name.replace(/\//g, '_');
        let downloadFolder = node_1.path.join(this.root, `${key}-${(0, uuid_1.v4)()}`);
        let url = info['dist.tarball'];
        this.log(`Downloading from ${url}`);
        let etagAlgorithm = url.startsWith('https://registry.npmjs.org') ? 'md5' : undefined;
        try {
            await this.download(url, {
                dest: downloadFolder,
                etagAlgorithm,
                extract: 'untar',
                onProgress: p => this.log(`Download progress ${p}%`, true),
            });
            this.log(`Extension download at ${downloadFolder}`);
            let obj = (0, fs_1.loadJson)(node_1.path.join(downloadFolder, 'package.json'));
            await this.installDependencies(downloadFolder, getDependencies(obj));
        }
        catch (e) {
            node_1.fs.rmSync(downloadFolder, { recursive: true, force: true });
            throw e;
        }
        this.log(`Download extension ${info.name}@${info.version} at ${downloadFolder}`);
        node_1.fs.mkdirSync(node_1.path.dirname(dest), { recursive: true });
        if (node_1.fs.existsSync(dest))
            node_1.fs.rmSync(dest, { force: true, recursive: true });
        node_1.fs.renameSync(downloadFolder, dest);
        this.log(`Move extension ${info.name}@${info.version} to ${dest}`);
        return true;
    }
    async download(url, options) {
        return await (0, download_1.default)(url, options);
    }
    async fetch(url, options = {}) {
        return await (0, fetch_1.default)(url, options);
    }
}
exports.Installer = Installer;
function getDependencies(obj) {
    var _a;
    return Object.keys((_a = obj.dependencies) !== null && _a !== void 0 ? _a : {}).filter(id => !local_dependencies.includes(id));
}
exports.getDependencies = getDependencies;
//# sourceMappingURL=installer.js.map