'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.File = exports.getItemsFromRoot = exports.getDirectory = exports.filterFiles = exports.getFileItem = exports.resolveEnvVariables = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const fs_1 = require("../../util/fs");
const node_1 = require("../../util/node");
const platform_1 = require("../../util/platform");
const string_1 = require("../../util/string");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const source_1 = tslib_1.__importDefault(require("../source"));
const pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|[a-zA-Z]:|)(\/|\\+)(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-]+(\/|\\+))*(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-])*$/;
function resolveEnvVariables(str, env = process.env) {
    let replaced = str;
    // windows
    replaced = replaced.replace(/%([^%]+)%/g, (m, n) => { var _a; return (_a = env[n]) !== null && _a !== void 0 ? _a : m; });
    // linux and mac
    replaced = replaced.replace(/\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi, (m, a, b) => { var _a; return ((_a = env[a || b]) !== null && _a !== void 0 ? _a : m); });
    return replaced;
}
exports.resolveEnvVariables = resolveEnvVariables;
async function getFileItem(root, filename) {
    let f = node_1.path.join(root, filename);
    let stat = await (0, fs_1.statAsync)(f);
    if (stat) {
        let dir = stat.isDirectory();
        let abbr = dir ? filename + '/' : filename;
        let word = filename;
        return { word, abbr, kind: dir ? vscode_languageserver_types_1.CompletionItemKind.Folder : vscode_languageserver_types_1.CompletionItemKind.File };
    }
    return null;
}
exports.getFileItem = getFileItem;
function filterFiles(files, ignoreHidden, ignorePatterns = []) {
    return files.filter(f => {
        if (!f || (ignoreHidden && f.startsWith(".")))
            return false;
        for (let p of ignorePatterns) {
            if ((0, node_1.minimatch)(f, p, { dot: true }))
                return false;
        }
        return true;
    });
}
exports.filterFiles = filterFiles;
function getDirectory(pathstr, root) {
    let part = /[\\/]$/.test(pathstr) ? pathstr : node_1.path.dirname(pathstr);
    return node_1.path.isAbsolute(pathstr) ? part : node_1.path.join(root, part);
}
exports.getDirectory = getDirectory;
async function getItemsFromRoot(pathstr, root, ignoreHidden, ignorePatterns) {
    let res = [];
    let dir = getDirectory(pathstr, root);
    let stat = await (0, fs_1.statAsync)(dir);
    if (stat && stat.isDirectory()) {
        let files = await (0, node_1.promisify)(node_1.fs.readdir)(dir);
        files = filterFiles(files, ignoreHidden, ignorePatterns);
        let items = await Promise.all(files.map(filename => getFileItem(dir, filename)));
        res = res.concat(items);
    }
    res = res.filter(item => item != null);
    return res;
}
exports.getItemsFromRoot = getItemsFromRoot;
class File extends source_1.default {
    constructor(isWindows) {
        super({
            name: 'file',
            filepath: __filename
        });
        this.isWindows = isWindows;
    }
    get triggerCharacters() {
        let characters = this.getConfig('triggerCharacters', []);
        return this.isWindows ? characters : characters.filter(s => s != '\\');
    }
    getPathOption(opt) {
        let { line, colnr } = opt;
        let part = (0, string_1.byteSlice)(line, 0, colnr - 1);
        part = resolveEnvVariables(part);
        if (!part || part.endsWith('//'))
            return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
            const pathstr = workspace_1.default.expand(ms[0]);
            let input = ms[0].match(/[^/\\]*$/)[0];
            return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
    }
    shouldTrim(ext) {
        let trimSameExts = this.getConfig('trimSameExts', []);
        return trimSameExts.includes(ext);
    }
    async getRoot(pathstr, part, filepath, cwd) {
        let root;
        let dirname = filepath ? node_1.path.dirname(filepath) : '';
        if (pathstr.startsWith(".")) {
            root = filepath ? dirname : cwd;
        }
        else if (this.isWindows && /^\w+:/.test(pathstr)) {
            root = /[\\/]$/.test(pathstr) ? pathstr : node_1.path.win32.dirname(pathstr);
        }
        else if (!this.isWindows && pathstr.startsWith("/")) {
            root = pathstr.endsWith("/") ? pathstr : node_1.path.posix.dirname(pathstr);
        }
        else if (part) {
            let exists = await (0, node_1.promisify)(node_1.fs.exists)(node_1.path.join(dirname, part));
            if (exists) {
                root = dirname;
            }
            else {
                exists = await (0, node_1.promisify)(node_1.fs.exists)(node_1.path.join(cwd, part));
                if (exists)
                    root = cwd;
            }
        }
        else {
            root = cwd;
        }
        return root;
    }
    async doComplete(opt, token) {
        let { filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option || option.startcol < opt.col)
            return null;
        let { pathstr, part, startcol } = option;
        let startPart = opt.col == startcol ? '' : (0, string_1.byteSlice)(opt.line, opt.col, startcol);
        let ext = node_1.path.extname(node_1.path.basename(filepath));
        let cwd = await this.nvim.call('getcwd', []);
        let root = await this.getRoot(pathstr, part, filepath, cwd);
        if (!root || token.isCancellationRequested)
            return null;
        let items = await getItemsFromRoot(pathstr, root, this.getConfig('ignoreHidden', true), this.getConfig('ignorePatterns', []));
        let trimExt = this.shouldTrim(ext);
        return {
            items: items.map(item => {
                let ex = node_1.path.extname(item.word);
                item.word = trimExt && ex === ext ? item.word.replace(ext, '') : item.word;
                return {
                    word: `${startPart}${item.word}`,
                    abbr: `${startPart}${item.abbr}`,
                    menu: this.menu
                };
            })
        };
    }
}
exports.File = File;
function register(sourceMap) {
    sourceMap.set('file', new File(platform_1.isWindows));
}
exports.register = register;
//# sourceMappingURL=file.js.map