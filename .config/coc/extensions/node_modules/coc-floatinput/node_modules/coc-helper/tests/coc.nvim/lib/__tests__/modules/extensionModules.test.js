"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
process.env.COC_NO_PLUGINS = '1';
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const events_1 = tslib_1.__importDefault(require("../../events"));
const stat_1 = require("../../extension/stat");
const ui_1 = require("../../extension/ui");
const util_1 = require("../../util");
const fs_2 = require("../../util/fs");
const window_1 = tslib_1.__importDefault(require("../../window"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let disposables = [];
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterEach(() => {
    (0, util_1.disposeAll)(disposables);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
function createFolder() {
    let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
    fs_1.default.mkdirSync(folder, { recursive: true });
    disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
        fs_1.default.rmSync(folder, { recursive: true, force: true });
    }));
    return folder;
}
describe('utils', () => {
    describe('getJsFiles', () => {
        it('should get js files', async () => {
            let res = await (0, stat_1.getJsFiles)(__dirname);
            expect(Array.isArray(res)).toBe(true);
        });
    });
    describe('loadGlobalJsonAsync()', () => {
        it('should throw when engines not valid', async () => {
            let folder = createFolder();
            let file = path_1.default.join(folder, 'package.json');
            fs_1.default.writeFileSync(file, '{}', 'utf8');
            await expect(async () => {
                await (0, stat_1.loadGlobalJsonAsync)(folder, '0.0.80');
            }).rejects.toThrow(/Invalid engines/);
            fs_1.default.writeFileSync(file, '{"engines": {}}', 'utf8');
            await expect(async () => {
                await (0, stat_1.loadGlobalJsonAsync)(folder, '0.0.80');
            }).rejects.toThrow(/Invalid engines/);
        });
        it('should throw when version not match', async () => {
            let folder = createFolder();
            let file = path_1.default.join(folder, 'package.json');
            fs_1.default.writeFileSync(file, '{"engines": {"coc": ">=0.0.80"}}', 'utf8');
            await expect(async () => {
                await (0, stat_1.loadGlobalJsonAsync)(folder, '0.0.79');
            }).rejects.toThrow(/not match/);
        });
        it('should throw when main file not found', async () => {
            let folder = createFolder();
            let file = path_1.default.join(folder, 'package.json');
            fs_1.default.writeFileSync(file, '{"engines": {"coc": ">=0.0.80"}}', 'utf8');
            await expect(async () => {
                await (0, stat_1.loadGlobalJsonAsync)(folder, '0.0.80');
            }).rejects.toThrow(/not found/);
        });
        it('should load json', async () => {
            let folder = createFolder();
            let file = path_1.default.join(folder, 'package.json');
            fs_1.default.writeFileSync(file, '{"name": "foo","engines": {"coc": ">=0.0.80"}}', 'utf8');
            fs_1.default.writeFileSync(path_1.default.join(folder, 'index.js'), '', 'utf8');
            let res = await (0, stat_1.loadGlobalJsonAsync)(folder, '0.0.80');
            expect(res.name).toBe('foo');
        });
    });
    describe('validExtensionFolder()', () => {
        it('should check validExtensionFolder', async () => {
            expect((0, stat_1.validExtensionFolder)(__dirname, '')).toBe(false);
            let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_1.default.mkdirSync(folder);
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                fs_1.default.rmSync(folder, { recursive: true, force: true });
            }));
            (0, fs_2.writeJson)(path_1.default.join(folder, 'index.js'), '');
            let filepath = path_1.default.join(folder, 'package.json');
            (0, fs_2.writeJson)(filepath, { name: 'name', engines: { coc: '>=0.0.81' } });
            expect((0, stat_1.validExtensionFolder)(folder, '0.0.82')).toBe(true);
        });
    });
    describe('checkExtensionRoot', () => {
        it('should not throw on error', async () => {
            let spy = jest.spyOn(fs_1.default, 'existsSync').mockImplementation(() => {
                throw new Error('my error');
            });
            let called = false;
            let s = jest.spyOn(console, 'error').mockImplementation(() => {
                called = true;
            });
            let root = path_1.default.join(os_1.default.tmpdir(), 'foo-bar');
            let res = (0, stat_1.checkExtensionRoot)(root);
            s.mockRestore();
            spy.mockRestore();
            expect(res).toBe(false);
        });
        it('should create root when it does not exist', async () => {
            let root = path_1.default.join(os_1.default.tmpdir(), 'foo-bar');
            let res = (0, stat_1.checkExtensionRoot)(root);
            expect(res).toBe(true);
            expect(fs_1.default.existsSync(path_1.default.join(root, 'package.json'))).toBe(true);
            let method = typeof fs_1.default['rmSync'] === 'function' ? 'rmSync' : 'rmdirSync';
            fs_1.default[method](root, { recursive: true });
        });
        it('should remove unexpted file', async () => {
            let root = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_1.default.writeFileSync(root, '');
            let res = (0, stat_1.checkExtensionRoot)(root);
            expect(res).toBe(true);
            expect(fs_1.default.existsSync(path_1.default.join(root, 'package.json'))).toBe(true);
            let method = typeof fs_1.default['rmSync'] === 'function' ? 'rmSync' : 'rmdirSync';
            fs_1.default[method](root, { recursive: true });
        });
    });
    describe('loadExtensionJson()', () => {
        function testErrors(data, version, count, createJs = false) {
            let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_1.default.mkdirSync(folder);
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                fs_1.default.rmSync(folder, { recursive: true, force: true });
            }));
            if (createJs)
                (0, fs_2.writeJson)(path_1.default.join(folder, 'index.js'), '');
            let filepath = path_1.default.join(folder, 'package.json');
            if (data)
                (0, fs_2.writeJson)(filepath, data);
            let errors = [];
            let json = (0, stat_1.loadExtensionJson)(folder, version, errors);
            expect(errors.length).toBe(count);
            return json;
        }
        it('should add errors', async () => {
            testErrors(undefined, '', 1);
            testErrors({}, '', 2);
            testErrors({ name: 'name', main: 'main' }, '', 1);
            testErrors({ name: 'name', engines: {} }, '', 2);
            testErrors({ name: 'name', engines: { coc: '>=0.0.81' } }, '0.0.79', 1, true);
            testErrors({ name: 'name', engines: { coc: '>=0.0.81', main: 'index.js' } }, '0.0.82', 0, true);
        });
        it('should not check entry for vscode extension', async () => {
            testErrors({ name: 'name', engines: { vscode: '0.10.x' } }, '', 0);
        });
    });
    describe('getExtensionName', () => {
        it('should get extension name', async () => {
            expect((0, stat_1.getExtensionName)('foo')).toBe('foo');
            expect((0, stat_1.getExtensionName)('http://1')).toBe('http://1');
            expect((0, stat_1.getExtensionName)('@a/b')).toBe('@a/b');
            expect((0, stat_1.getExtensionName)('semver@1.2.3')).toBe('semver');
        });
    });
});
describe('ExtensionStat', () => {
    function createDB(folder, data) {
        let s = JSON.stringify(data, null, 2);
        let filepath = path_1.default.join(folder, 'db.json');
        fs_1.default.writeFileSync(filepath, s, 'utf8');
        return filepath;
    }
    function create() {
        let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        fs_1.default.mkdirSync(folder);
        disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            fs_1.default.rmSync(folder, { force: true, recursive: true });
        }));
        return [new stat_1.ExtensionStat(folder), path_1.default.join(folder, 'package.json')];
    }
    it('should not throw on create', async () => {
        let spy = jest.spyOn(stat_1.ExtensionStat.prototype, 'migrate').mockImplementation(() => {
            throw new Error('my error');
        });
        let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        fs_1.default.mkdirSync(folder);
        let stat = new stat_1.ExtensionStat(folder);
        spy.mockRestore();
        expect(stat).toBeDefined();
    });
    it('should add local extension', async () => {
        let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let stat = new stat_1.ExtensionStat(folder);
        stat.addLocalExtension('name', folder);
        expect(stat.getFolder('name')).toBe(folder);
        expect(stat.getFolder('unknown')).toBeUndefined();
    });
    it('should iterate activated extensions', () => {
        let folder = createFolder();
        (0, fs_2.writeJson)(path_1.default.join(folder, 'package.json'), {
            disabled: ['x', 'y'],
            dependencies: { x: '', y: '', z: '', a: '' }
        });
        let names = [];
        let stat = new stat_1.ExtensionStat(folder);
        for (let name of stat.activated()) {
            names.push(name);
        }
        expect(names).toEqual(['z', 'a']);
    });
    it('should migrate #1', async () => {
        let folder = createFolder();
        let stat = new stat_1.ExtensionStat(folder);
        expect(stat.getExtensionsStat()).toEqual({});
        let data = {
            extension: {
                x: { disabled: true },
                y: { locked: true },
                z: {}
            }
        };
        let filepath = createDB(folder, data);
        (0, fs_2.writeJson)(path_1.default.join(folder, 'package.json'), {
            dependencies: { x: '', y: '', z: '', a: '' }
        });
        stat = new stat_1.ExtensionStat(folder);
        let res = stat.getExtensionsStat();
        expect(res).toEqual({ x: 1, y: 2, z: 0, a: 0 });
        let obj = (0, fs_2.loadJson)(path_1.default.join(folder, 'package.json'));
        expect(obj.disabled).toEqual(['x']);
        expect(obj.locked).toEqual(['y']);
        expect(fs_1.default.existsSync(filepath)).toBe(false);
    });
    it('should migrate #2', async () => {
        let folder = createFolder();
        let stat = new stat_1.ExtensionStat(folder);
        expect(stat.getExtensionsStat()).toEqual({});
        let data = {};
        createDB(folder, data);
        (0, fs_2.writeJson)(path_1.default.join(folder, 'package.json'), {});
        stat = new stat_1.ExtensionStat(folder);
        let res = stat.getExtensionsStat();
        expect(res).toEqual({});
        let obj = (0, fs_2.loadJson)(path_1.default.join(folder, 'package.json'));
        expect(obj.disabled).toEqual([]);
        expect(obj.locked).toEqual([]);
    });
    it('should load disabled & locked from package.json', async () => {
        let folder = createFolder();
        let obj = {
            disabled: ['foo'],
            locked: ['bar'],
            dependencies: {
                foo: '',
                bar: '',
                z: ''
            }
        };
        (0, fs_2.writeJson)(path_1.default.join(folder, 'package.json'), obj);
        let stat = new stat_1.ExtensionStat(folder);
        expect(stat.disabledExtensions).toEqual(['foo']);
        expect(stat.lockedExtensions).toEqual(['bar']);
        expect(stat.getExtensionsStat()['z']).toBe(0);
    });
    it('should add & remove extension', async () => {
        let [stat, jsonFile] = create();
        stat.addExtension('foo', '');
        expect(stat.getExtensionsStat()).toEqual({ foo: 0 });
        let res = (0, fs_2.loadJson)(jsonFile);
        expect(res).toEqual({ dependencies: { foo: '' } });
        stat.removeExtension('foo');
        expect(stat.isDisabled('foo')).toBe(false);
        expect(stat.getExtensionsStat()).toEqual({});
        res = (0, fs_2.loadJson)(jsonFile);
        expect(res).toEqual({ dependencies: {} });
    });
    it('should remove extension not exists', async () => {
        let [stat] = create();
        stat.removeExtension('foo');
    });
    it('should remove from disabled and locked extensions', async () => {
        let [stat, jsonFile] = create();
        stat.addExtension('foo', '');
        stat.setDisable('foo', true);
        stat.setLocked('foo', true);
        let res = (0, fs_2.loadJson)(jsonFile);
        expect(res.disabled).toEqual(['foo']);
        expect(res.locked).toEqual(['foo']);
        stat.removeExtension('foo');
        res = (0, fs_2.loadJson)(jsonFile);
        expect(res.disabled).toEqual([]);
        expect(res.locked).toEqual([]);
    });
    it('should setDisable', async () => {
        let [stat] = create();
        stat.addExtension('foo', '');
        stat.setDisable('foo', true);
        expect(stat.hasExtension('foo')).toBe(true);
        expect(stat.isDisabled('foo')).toBe(true);
        stat.setDisable('foo', false);
        expect(stat.isDisabled('foo')).toBe(false);
        expect(stat.disabledExtensions).toEqual([]);
    });
    it('should setLocked', async () => {
        let [stat] = create();
        stat.addExtension('foo', '');
        stat.setLocked('foo', true);
        expect(stat.lockedExtensions).toEqual(['foo']);
        stat.setLocked('foo', false);
        expect(stat.lockedExtensions).toEqual([]);
    });
    it('should check update', async () => {
        let [stat] = create();
        expect(stat.shouldUpdate('never')).toBe(false);
        expect(stat.shouldUpdate('daily')).toBe(true);
        stat.setLastUpdate();
        expect(stat.shouldUpdate('weekly')).toBe(false);
    });
    it('should toInterval', async () => {
        expect(typeof (0, stat_1.toInterval)('daily')).toBe('number');
        expect(typeof (0, stat_1.toInterval)('weekly')).toBe('number');
    });
    it('should get dependencies', async () => {
        let [stat] = create();
        expect(stat.dependencies).toEqual({});
        expect(stat.globalIds).toEqual([]);
        stat.addExtension('foo', '');
        expect(stat.dependencies).toEqual({ foo: '' });
        expect(stat.globalIds).toEqual(['foo']);
    });
    it('should filterGlobalExtensions', async () => {
        let [stat, jsonFile] = create();
        expect(stat.filterGlobalExtensions(['foo', 'bar', undefined, 3])).toEqual(['foo', 'bar']);
        stat.addExtension('foo', '');
        expect(stat.filterGlobalExtensions(['foo', 'bar'])).toEqual(['bar']);
        stat.setDisable('bar', true);
        expect(stat.filterGlobalExtensions(['foo', 'bar'])).toEqual([]);
        let folder = path_1.default.resolve(jsonFile, '../node_modules');
        fs_1.default.mkdirSync(folder);
        fs_1.default.mkdirSync(path_1.default.join(folder, 'uri'));
        (0, fs_2.writeJson)(path_1.default.join(folder, 'uri', 'package.json'), {});
        stat.addExtension('uri', 'http://git');
        stat.addExtension('simple', '');
        fs_1.default.mkdirSync(path_1.default.join(folder, 'simple'));
        (0, fs_2.writeJson)(path_1.default.join(folder, 'simple', 'package.json'), {});
        let res = stat.filterGlobalExtensions(['http://git']);
        expect(res).toEqual([]);
    });
});
describe('InstallBuffer', () => {
    afterEach(() => {
        events_1.default.requesting = false;
    });
    it('should sync by not split', async () => {
        global.__TEST__ = false;
        let buf = new ui_1.InstallBuffer(false);
        disposables.push(buf);
        events_1.default.requesting = true;
        await buf.start(['a', 'b', 'c']);
        let wins = await nvim.windows;
        expect(wins.length).toBe(1);
        global.__TEST__ = true;
    });
    it('should draw buffer with stats', async () => {
        let buf = new ui_1.InstallBuffer(true);
        disposables.push(buf);
        buf.draw();
        await buf.start(['a', 'b', 'c', 'd']);
        buf.startProgress('a');
        buf.startProgress('b');
        buf.startProgress('c');
        buf.addMessage('a', 'Updated to 1.0.0');
        buf.addMessage('b', 'message');
        buf.finishProgress('a', true);
        buf.finishProgress('b', false);
        buf.draw();
        buf.finishProgress('c', true);
        buf.finishProgress('d', true);
        let buffer = await nvim.buffer;
        let lines = await buffer.lines;
        expect(lines.length).toBe(6);
        buf.draw();
    });
    it('should stop when all items finished', async () => {
        let buf = new ui_1.InstallBuffer(false);
        disposables.push(buf);
        await buf.start(['a', 'b']);
        buf.startProgress('a');
        buf.startProgress('b');
        expect(buf.remains).toBe(2);
        buf.finishProgress('a', true);
        buf.finishProgress('b', true);
        buf.draw();
        expect(buf.getMessages(0)).toEqual([]);
        expect(buf.stopped).toBe(true);
    });
    it('should show messages and dispose', async () => {
        events_1.default.requesting = true;
        let buf = new ui_1.InstallBuffer(true);
        disposables.push(buf);
        await buf.start(['a', 'b']);
        buf.startProgress('a');
        buf.addMessage('a', 'start');
        buf.addMessage('a', 'finish');
        buf.finishProgress('a', true);
        buf.draw();
        let bufnr = await nvim.call('bufnr', ['%']);
        await nvim.call('cursor', [3, 4]);
        let id = await helper_1.default.waitFloat();
        let win = nvim.createWindow(id);
        let buffer = await win.buffer;
        let lines = await buffer.lines;
        expect(lines.join(' ')).toBe('start finish');
        await nvim.command(`bd! ${bufnr}`);
        expect(buf.stopped).toBe(true);
    });
});
describe('InstallChannel', () => {
    it('should create install InstallChannel', async () => {
        let outputChannel = window_1.default.createOutputChannel('test');
        let channel = new ui_1.InstallChannel(true, outputChannel);
        channel.start(['a', 'b']);
        channel.startProgress('a');
        channel.addMessage('a', 'msg', true);
        channel.addMessage('a', 'msg', false);
        channel.finishProgress('a', true);
        channel.finishProgress('b', false);
    });
    it('should create update InstallChannel', async () => {
        let outputChannel = window_1.default.createOutputChannel('test');
        let channel = new ui_1.InstallChannel(false, outputChannel);
        channel.start(['a', 'b']);
        channel.startProgress('a');
        channel.finishProgress('a', true);
        channel.finishProgress('b', false);
    });
});
//# sourceMappingURL=extensionModules.test.js.map