'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllKeysConfigurationChangeEvent = exports.ConfigurationChangeEvent = void 0;
const object_1 = require("../util/object");
const configuration_1 = require("./configuration");
const model_1 = require("./model");
const util_1 = require("./util");
class ConfigurationChangeEvent {
    // public sourceConfig: any
    constructor(change, previous, currentConfiguration) {
        this.change = change;
        this.previous = previous;
        this.currentConfiguration = currentConfiguration;
        this._previousConfiguration = undefined;
        const keysSet = new Set();
        change.keys.forEach(key => keysSet.add(key));
        change.overrides.forEach(([, keys]) => keys.forEach(key => keysSet.add(key)));
        this.affectedKeys = [...keysSet.values()];
        const configurationModel = new model_1.ConfigurationModel();
        this.affectedKeys.forEach(key => configurationModel.setValue(key, {}));
        this.affectedKeysTree = configurationModel.contents;
    }
    get previousConfiguration() {
        if (!this._previousConfiguration && this.previous) {
            this._previousConfiguration = configuration_1.Configuration.parse(this.previous);
        }
        return this._previousConfiguration;
    }
    affectsConfiguration(section, scope) {
        let overrides = scope ? (0, util_1.scopeToOverrides)(scope) : undefined;
        if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, section)) {
            if (overrides) {
                const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides) : undefined;
                const value2 = this.currentConfiguration.getValue(section, overrides);
                return !(0, object_1.equals)(value1, value2);
            }
            return true;
        }
        return false;
    }
    doesAffectedKeysTreeContains(affectedKeysTree, section) {
        let requestedTree = (0, util_1.toValuesTree)({ [section]: true }, () => { });
        let key;
        while (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property
            affectedKeysTree = affectedKeysTree[key];
            if (!affectedKeysTree) {
                return false; // Requested tree is not found
            }
            requestedTree = requestedTree[key];
        }
        return true;
    }
}
exports.ConfigurationChangeEvent = ConfigurationChangeEvent;
class AllKeysConfigurationChangeEvent extends ConfigurationChangeEvent {
    constructor(configuration, source) {
        super({ keys: configuration.allKeys(), overrides: [] }, undefined, configuration);
        this.source = source;
    }
}
exports.AllKeysConfigurationChangeEvent = AllKeysConfigurationChangeEvent;
//# sourceMappingURL=event.js.map