'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const extensionRegistry_1 = require("../../util/extensionRegistry");
const registry_1 = require("../../util/registry");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const basic_1 = tslib_1.__importDefault(require("../basic"));
const formatting_1 = require("../formatting");
const string_1 = require("../../util/string");
const extensionRegistry = registry_1.Registry.as(extensionRegistry_1.Extensions.ExtensionContribution);
class CommandsList extends basic_1.default {
    constructor() {
        super();
        this.defaultAction = 'run';
        this.description = 'registered commands of coc.nvim';
        this.name = 'commands';
        this.mru = workspace_1.default.createMru('commands');
        this.addAction('run', async (item) => {
            await commands_1.default.fireCommand(item.data.cmd);
        });
        this.addAction('append', async (item) => {
            let { cmd } = item.data;
            await workspace_1.default.nvim.feedKeys(`:CocCommand ${cmd} `, 'n', false);
        });
    }
    async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        let ids = new Set();
        for (const obj of extensionRegistry.onCommands.concat(commands_1.default.commandList)) {
            let { id, title } = obj;
            if (ids.has(id))
                continue;
            ids.add(id);
            items.push({
                label: [id, (0, string_1.toText)(title)],
                filterText: id,
                data: { cmd: id, score: score(mruList, id) }
            });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return (0, formatting_1.formatListItems)(this.alignColumns, items);
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine', true);
        nvim.command('highlight default link CocCommandsTitle Comment', true);
        nvim.resumeNotification(false, true);
    }
}
exports.default = CommandsList;
function score(list, key) {
    let idx = list.indexOf(key);
    return idx == -1 ? -1 : list.length - idx;
}
//# sourceMappingURL=commands.js.map