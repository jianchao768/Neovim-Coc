'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPathFromArgs = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const events_1 = require("events");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const logger_1 = require("../../logger");
const highligher_1 = tslib_1.__importDefault(require("../../model/highligher"));
const ansiparse_1 = require("../../util/ansiparse");
const mutex_1 = require("../../util/mutex");
const node_1 = require("../../util/node");
const window_1 = tslib_1.__importDefault(require("../../window"));
const logger = (0, logger_1.createLogger)('handler-search');
const defaultArgs = ['--color', 'ansi', '--colors', 'path:fg:black', '--colors', 'line:fg:green', '--colors', 'match:fg:red', '--no-messages', '--heading', '-n'];
const controlCode = '\x1b';
// emit FileItem
class Task extends events_1.EventEmitter {
    start(cmd, args, cwd) {
        this.process = (0, child_process_1.spawn)(cmd, args, { cwd });
        this.process.on('error', e => {
            this.emit('error', e.message);
        });
        const rl = node_1.readline.createInterface(this.process.stdout);
        let start;
        let fileItem;
        let lines = [];
        let highlights = [];
        let create = true;
        rl.on('line', content => {
            if (content.includes(controlCode)) {
                let items = (0, ansiparse_1.ansiparse)(content);
                if (items.length == 0)
                    return;
                if (items[0].foreground == 'black') {
                    fileItem = { filepath: node_1.path.join(cwd, items[0].text), ranges: [] };
                    return;
                }
                let normalLine = items[0].foreground == 'green';
                if (normalLine) {
                    let lnum = parseInt(items[0].text, 10) - 1;
                    let padlen = items[0].text.length + 1;
                    if (create) {
                        start = lnum;
                        create = false;
                    }
                    let line = '';
                    for (let item of items) {
                        if (item.foreground == 'red') {
                            let l = lnum - start;
                            let c = line.length - padlen;
                            highlights.push(vscode_languageserver_types_1.Range.create(l, c, l, c + item.text.length));
                        }
                        line += item.text;
                    }
                    let currline = line.slice(padlen);
                    lines.push(currline);
                }
            }
            else {
                let fileEnd = content.trim().length == 0;
                if (fileItem && (fileEnd || content.trim() == '--')) {
                    fileItem.ranges.push({ lines, highlights, start });
                }
                if (fileEnd) {
                    this.emit('item', fileItem);
                    fileItem = null;
                }
                lines = [];
                highlights = [];
                create = true;
            }
        });
        rl.on('close', () => {
            if (fileItem) {
                if (lines.length) {
                    fileItem.ranges.push({ lines, highlights, start, });
                }
                this.emit('item', fileItem);
            }
            lines = highlights = fileItem = null;
            this.emit('end');
        });
    }
    dispose() {
        if (this.process) {
            this.process.kill();
        }
    }
}
class Search {
    constructor(nvim, cmd = 'rg') {
        this.nvim = nvim;
        this.cmd = cmd;
    }
    run(args, cwd, refactorBuf) {
        let { nvim, cmd } = this;
        let { afterContext, beforeContext } = refactorBuf.config;
        let argList = ['-A', afterContext.toString(), '-B', beforeContext.toString()].concat(defaultArgs, args);
        let p = getPathFromArgs(args);
        if (p)
            argList.pop();
        argList.push('--', p ? node_1.path.isAbsolute(p) ? p : `./${p.replace(/^\.\//, '')}` : './');
        this.task = new Task();
        this.task.start(cmd, argList, cwd);
        let mutex = new mutex_1.Mutex();
        let files = 0;
        let matches = 0;
        let start = Date.now();
        // remaining items
        let fileItems = [];
        const addFileItems = async () => {
            if (fileItems.length == 0)
                return;
            let items = fileItems.slice();
            fileItems = [];
            const release = await mutex.acquire();
            try {
                await refactorBuf.addFileItems(items);
            }
            catch (e) {
                logger.error(e);
            }
            release();
        };
        return new Promise((resolve, reject) => {
            let interval = setInterval(addFileItems, 300);
            this.task.on('item', async (fileItem) => {
                files++;
                matches = matches + fileItem.ranges.reduce((p, r) => p + r.highlights.length, 0);
                fileItems.push(fileItem);
            });
            this.task.on('error', message => {
                clearInterval(interval);
                void window_1.default.showErrorMessage(`Error on command "${cmd}": ${message}`);
                this.task = null;
                reject(new Error(message));
            });
            this.task.on('end', async () => {
                clearInterval(interval);
                try {
                    await addFileItems();
                    const release = await mutex.acquire();
                    release();
                    this.task.removeAllListeners();
                    this.task = null;
                    let buf = refactorBuf.buffer;
                    if (buf) {
                        nvim.pauseNotification();
                        if (files == 0) {
                            buf.setLines(['No match found'], { start: 1, end: 2, strictIndexing: false }, true);
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: 'Error' });
                            buf.setOption('modified', false, true);
                        }
                        else {
                            let highligher = new highligher_1.default();
                            highligher.addText('Files', 'MoreMsg');
                            highligher.addText(': ');
                            highligher.addText(`${files} `, 'Number');
                            highligher.addText('Matches', 'MoreMsg');
                            highligher.addText(': ');
                            highligher.addText(`${matches} `, 'Number');
                            highligher.addText('Duration', 'MoreMsg');
                            highligher.addText(': ');
                            highligher.addText(`${Date.now() - start}ms`, 'Number');
                            highligher.render(buf, 1, 2);
                        }
                        buf.setOption('modified', false, true);
                        nvim.resumeNotification(false, true);
                    }
                }
                catch (e) {
                    reject(e);
                    return;
                }
                resolve();
            });
        });
    }
    abort() {
        var _a;
        (_a = this.task) === null || _a === void 0 ? void 0 : _a.dispose();
    }
}
exports.default = Search;
// rg requires `-- [path]` at the end
function getPathFromArgs(args) {
    if (args.length < 2)
        return undefined;
    let len = args.length;
    if (args[len - 1].startsWith('-'))
        return undefined;
    if (args[len - 2].startsWith('-'))
        return undefined;
    return args[len - 1];
}
exports.getPathFromArgs = getPathFromArgs;
//# sourceMappingURL=search.js.map