"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const util_1 = require("../../util");
const vscode_uri_1 = require("vscode-uri");
const helper_1 = tslib_1.__importStar(require("../helper"));
const commands_1 = tslib_1.__importDefault(require("../../commands"));
let nvim;
let callHierarchy;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    callHierarchy = helper_1.default.plugin.getHandler().callHierarchy;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
function createCallItem(name, kind, uri, range) {
    return {
        name,
        kind,
        uri,
        range,
        selectionRange: range
    };
}
describe('CallHierarchy', () => {
    it('should throw when provider does not exist', async () => {
        let err;
        try {
            await callHierarchy.getIncoming();
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
    });
    it('should return null when provider not exist', async () => {
        let token = vscode_languageserver_protocol_1.CancellationToken.None;
        let doc = await workspace_1.default.document;
        let res;
        res = await languages_1.default.prepareCallHierarchy(doc.textDocument, vscode_languageserver_protocol_1.Position.create(0, 0), token);
        expect(res).toBeNull();
        let item = createCallItem('name', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0));
        res = await languages_1.default.provideOutgoingCalls(doc.textDocument, item, token);
        expect(res).toBeNull();
        res = await languages_1.default.provideIncomingCalls(doc.textDocument, item, token);
        expect(res).toBeNull();
    });
    it('should throw when prepare failed', async () => {
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return undefined;
            },
            provideCallHierarchyIncomingCalls() {
                return [];
            },
            provideCallHierarchyOutgoingCalls() {
                return [];
            }
        }));
        let fn = async () => {
            await callHierarchy.getOutgoing();
        };
        await expect(fn()).rejects.toThrow(Error);
    });
    it('should get incoming & outgoing callHierarchy items', async () => {
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, 'test:///foo', vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5));
            },
            provideCallHierarchyIncomingCalls() {
                return [{
                        from: createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, 'test:///bar', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5)),
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5)]
                    }];
            },
            provideCallHierarchyOutgoingCalls() {
                return [{
                        to: createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, 'test:///bar', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5)),
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5)]
                    }];
            }
        }));
        let res = await helper_1.default.doAction('incomingCalls');
        expect(res.length).toBe(1);
        expect(res[0].from.name).toBe('bar');
        let outgoing = await helper_1.default.doAction('outgoingCalls');
        expect(outgoing.length).toBe(1);
        res = await callHierarchy.getIncoming(outgoing[0].to);
        expect(res.length).toBe(1);
    });
    it('should show warning when provider does not exist', async () => {
        await helper_1.default.doAction('showIncomingCalls');
        let line = await helper_1.default.getCmdline();
        expect(line).toMatch('not found');
    });
    it('should show message when no result returned.', async () => {
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return null;
            },
            provideCallHierarchyIncomingCalls() {
                return [];
            },
            provideCallHierarchyOutgoingCalls() {
                return [];
            }
        }));
        await callHierarchy.showCallHierarchyTree('incoming');
        let line = await helper_1.default.getCmdline();
        expect(line).toMatch('Unable');
    });
    it('should render description and support default action', async () => {
        helper_1.default.updateConfiguration('callHierarchy.enableTooltip', false);
        let doc = await workspace_1.default.document;
        let bufnr = doc.bufnr;
        await doc.buffer.setLines(['foo'], { start: 0, end: -1, strictIndexing: false });
        let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            },
            provideCallHierarchyIncomingCalls() {
                let item = createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3));
                item.detail = 'Detail';
                item.tags = [vscode_languageserver_protocol_1.SymbolTag.Deprecated];
                return [{
                        from: item,
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(2, 0, 2, 5)]
                    }];
            },
            provideCallHierarchyOutgoingCalls() {
                return [];
            }
        }));
        await commands_1.default.executeCommand('document.showIncomingCalls');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual([
            'INCOMING CALLS',
            '- c foo',
            '  + c bar Detail'
        ]);
        await nvim.command('exe 3');
        await nvim.input('t');
        await helper_1.default.waitFor('getline', ['.'], '  - c bar Detail');
        await nvim.input('<cr>');
        await helper_1.default.waitFor('expand', ['%:p'], fsPath);
        let res = await nvim.call('coc#cursor#position');
        expect(res).toEqual([1, 0]);
        let matches = await nvim.call('getmatches');
        expect(matches.length).toBe(2);
        await nvim.command(`b ${bufnr}`);
        await helper_1.default.wait(50);
        matches = await nvim.call('getmatches');
        expect(matches.length).toBe(0);
        await nvim.command(`wincmd o`);
    });
    it('should invoke open in new tab action', async () => {
        let doc = await workspace_1.default.document;
        await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            },
            provideCallHierarchyIncomingCalls() {
                return [];
            },
            provideCallHierarchyOutgoingCalls() {
                let item = createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
                item.detail = 'Detail';
                return [{
                        to: item,
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3)]
                    }];
            }
        }));
        let win = await nvim.window;
        await commands_1.default.executeCommand('document.showOutgoingCalls');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c foo',
            '  + c bar Detail'
        ]);
        await nvim.command('exe 3');
        await nvim.input('<tab>');
        await helper_1.default.waitPrompt();
        await nvim.input('<cr>');
        await helper_1.default.waitFor('tabpagenr', [], 2);
        doc = await workspace_1.default.document;
        expect(doc.uri).toBe(uri);
        await helper_1.default.waitValue(async () => {
            let res = await nvim.call('getmatches', [win.id]);
            return res.length;
        }, 1);
    });
    it('should invoke show incoming calls action', async () => {
        let doc = await workspace_1.default.document;
        await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            },
            provideCallHierarchyIncomingCalls() {
                return [{
                        from: createCallItem('test', vscode_languageserver_protocol_1.SymbolKind.Class, 'test:///bar', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5)),
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5)]
                    }];
            },
            provideCallHierarchyOutgoingCalls() {
                let item = createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
                item.detail = 'Detail';
                return [{
                        to: item,
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3)]
                    }];
            }
        }));
        await callHierarchy.showCallHierarchyTree('outgoing');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c foo',
            '  + c bar Detail'
        ]);
        await nvim.command('exe 3');
        await nvim.input('<tab>');
        await helper_1.default.waitPrompt();
        await nvim.input('3');
        await helper_1.default.wait(200);
        lines = await buf.lines;
        expect(lines).toEqual([
            'INCOMING CALLS',
            '- c bar Detail',
            '  + c test'
        ]);
    });
    it('should invoke show outgoing calls action', async () => {
        let doc = await workspace_1.default.document;
        await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            },
            provideCallHierarchyIncomingCalls() {
                return [{
                        from: createCallItem('test', vscode_languageserver_protocol_1.SymbolKind.Class, 'test:///bar', vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5)),
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5)]
                    }];
            },
            provideCallHierarchyOutgoingCalls() {
                let item = createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
                item.detail = 'Detail';
                return [{
                        to: item,
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3)]
                    }];
            }
        }));
        await callHierarchy.showCallHierarchyTree('incoming');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual([
            'INCOMING CALLS',
            '- c foo',
            '  + c test'
        ]);
        await nvim.command('exe 3');
        await nvim.input('<tab>');
        await helper_1.default.waitPrompt();
        await nvim.input('4');
        await helper_1.default.wait(200);
        lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c test',
            '  + c bar Detail'
        ]);
    });
    it('should invoke dismiss action #1', async () => {
        let doc = await workspace_1.default.document;
        await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            },
            provideCallHierarchyIncomingCalls() {
                return [];
            },
            provideCallHierarchyOutgoingCalls() {
                let item = createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
                item.detail = 'Detail';
                return [{
                        to: item,
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3)]
                    }];
            }
        }));
        await callHierarchy.showCallHierarchyTree('outgoing');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c foo',
            '  + c bar Detail'
        ]);
        await nvim.command('exe 3');
        await nvim.input('<tab>');
        await helper_1.default.waitPrompt();
        await nvim.input('2');
        await helper_1.default.wait(200);
        lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c foo'
        ]);
        await nvim.command('exe 2');
        await nvim.input('<tab>');
        await helper_1.default.waitPrompt();
        await nvim.input('2');
        await helper_1.default.wait(30);
    });
    it('should invoke dismiss action #2', async () => {
        let doc = await workspace_1.default.document;
        await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
        let uri = vscode_uri_1.URI.file(fsPath).toString();
        disposables.push(languages_1.default.registerCallHierarchyProvider([{ language: '*' }], {
            prepareCallHierarchy() {
                return createCallItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3));
            },
            provideCallHierarchyIncomingCalls() {
                return [];
            },
            provideCallHierarchyOutgoingCalls() {
                let item = createCallItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1));
                item.detail = 'Detail';
                return [{
                        to: item,
                        fromRanges: [vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3)]
                    }];
            }
        }));
        await helper_1.default.doAction('showOutgoingCalls');
        let buf = await nvim.buffer;
        let lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c foo',
            '  + c bar Detail'
        ]);
        await nvim.command('exe 3');
        await nvim.input('t');
        await helper_1.default.waitFor('line', ['$'], 4);
        await nvim.command('exe 4');
        await nvim.input('<tab>');
        await helper_1.default.waitPrompt();
        await nvim.input('2');
        await helper_1.default.waitFor('line', ['$'], 3);
        lines = await buf.lines;
        expect(lines).toEqual([
            'OUTGOING CALLS',
            '- c foo',
            '  - c bar Detail'
        ]);
    });
});
//# sourceMappingURL=callHierarchy.test.js.map