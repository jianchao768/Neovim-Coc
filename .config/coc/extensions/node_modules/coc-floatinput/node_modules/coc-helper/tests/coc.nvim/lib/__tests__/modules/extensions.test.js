"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const which_1 = tslib_1.__importDefault(require("which"));
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const extension_1 = tslib_1.__importStar(require("../../extension"));
const fs_2 = require("../../util/fs");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let tmpfolder;
beforeAll(async () => {
    await helper_1.default.setup();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(() => {
    if (tmpfolder) {
        fs_1.default.rmSync(tmpfolder, { force: true, recursive: true });
        tmpfolder = undefined;
    }
});
describe('extensions', () => {
    it('should convert url', async () => {
        expect((0, extension_1.toUrl)('https://github.com/a/b.git#master')).toBe('https://github.com/a/b');
        expect((0, extension_1.toUrl)('https://github.com/a/b.git#main')).toBe('https://github.com/a/b');
        expect((0, extension_1.toUrl)('url')).toBe('');
    });
    it('should have events', async () => {
        expect(extension_1.Extensions).toBeDefined();
        expect(extension_1.default.onDidLoadExtension).toBeDefined();
        expect(extension_1.default.onDidActiveExtension).toBeDefined();
        expect(extension_1.default.onDidUnloadExtension).toBeDefined();
        expect(extension_1.default.schemes).toBeDefined();
        expect(extension_1.default.creteInstaller('npm', 'id')).toBeDefined();
    });
    it('should not throw with addSchemeProperty', async () => {
        extension_1.default.addSchemeProperty('', null);
    });
    it('should toggle auto update', async () => {
        await commands_1.default.executeCommand('extensions.toggleAutoUpdate');
        let config = workspace_1.default.getConfiguration('coc.preferences').get('extensionUpdateCheck');
        expect(config).toBe('daily');
        await commands_1.default.executeCommand('extensions.toggleAutoUpdate');
        config = workspace_1.default.getConfiguration('coc.preferences').get('extensionUpdateCheck');
        expect(config).toBe('never');
    });
    it('should get extensions stat', async () => {
        process.env.COC_NO_PLUGINS = '1';
        await extension_1.default.globalExtensions();
        let stats = await extension_1.default.getExtensionStates();
        expect(stats.length).toBe(0);
        process.env.COC_NO_PLUGINS = '0';
    });
    it('should add global extensions', async () => {
        extension_1.default.states.addExtension('foo', '0.0.1');
        extension_1.default.states.addExtension('bar', '0.0.1');
        extension_1.default.modulesFolder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let folder = path_1.default.join(extension_1.default.modulesFolder, 'foo');
        (0, fs_2.writeJson)(path_1.default.join(folder, 'package.json'), { name: 'foo', engines: { coc: '>=0.0.1' } });
        fs_1.default.writeFileSync(path_1.default.join(folder, 'index.js'), '');
        let res = await extension_1.default.globalExtensions();
        expect(res.length).toBe(1);
        fs_1.default.rmSync(extension_1.default.modulesFolder, { recursive: true });
        extension_1.default.states.removeExtension('foo');
    });
    it('should has extension', async () => {
        let res = extension_1.default.has('test');
        expect(res).toBe(false);
        expect(extension_1.default.isActivated('unknown')).toBe(false);
        let loaded = await helper_1.default.doAction('loadedExtensions');
        expect(loaded).toEqual([]);
        let stats = await helper_1.default.doAction('extensionStats');
        expect(stats).toBeDefined();
    });
    it('should load global extensions', async () => {
        extension_1.default.states.addExtension('foo', '0.0.1');
        let stats = extension_1.default.globalExtensionStats();
        expect(stats).toEqual([]);
        extension_1.default.states.removeExtension('foo');
        process.env.COC_NO_PLUGINS = '1';
        stats = extension_1.default.globalExtensionStats();
        expect(stats).toEqual([]);
        process.env.COC_NO_PLUGINS = '0';
    });
    it('should load extension stats from runtimepath', () => {
        let f1 = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        fs_1.default.mkdirSync(f1);
        (0, fs_2.writeJson)(path_1.default.join(f1, 'package.json'), { name: 'name', engines: { coc: '>=0.0.1' } });
        fs_1.default.writeFileSync(path_1.default.join(f1, 'index.js'), '');
        let f2 = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        fs_1.default.mkdirSync(f2);
        (0, fs_2.writeJson)(path_1.default.join(f2, 'package.json'), { name: 'folder', engines: { coc: '>=0.0.1' } });
        fs_1.default.writeFileSync(path_1.default.join(f2, 'index.js'), '');
        extension_1.default.states.addExtension('folder', '0.0.1');
        let res = extension_1.default.runtimeExtensionStats(`${f1},${f2}`);
        expect(res.length).toBe(1);
        expect(res[0].id).toBe('name');
        extension_1.default.states.removeExtension('folder');
        fs_1.default.rmSync(f1, { recursive: true, force: true });
        fs_1.default.rmSync(f2, { recursive: true, force: true });
    });
    it('should force update extensions', async () => {
        let spy = jest.spyOn(extension_1.default, 'installExtensions').mockImplementation(() => {
            return Promise.resolve();
        });
        await commands_1.default.executeCommand('extensions.forceUpdateAll');
        spy.mockRestore();
    });
    it('should auto update', async () => {
        let spy = jest.spyOn(extension_1.default.states, 'shouldUpdate').mockImplementation(() => {
            return true;
        });
        let s = jest.spyOn(extension_1.default, 'updateExtensions').mockImplementation(() => {
            return Promise.reject(new Error('error on update'));
        });
        await extension_1.default.activateExtensions();
        spy.mockRestore();
        s.mockRestore();
    });
    it('should use absolute path for npm', async () => {
        let res = extension_1.default.npm;
        expect(path_1.default.isAbsolute(res)).toBe(true);
    });
    it('should not throw when npm not found', async () => {
        let spy = jest.spyOn(which_1.default, 'sync').mockImplementation(() => {
            throw new Error('not executable');
        });
        let res = extension_1.default.npm;
        expect(res).toBeNull();
        await extension_1.default.updateExtensions();
        spy.mockRestore();
    });
    it('should get all extensions', () => {
        let list = extension_1.default.all;
        expect(Array.isArray(list)).toBe(true);
    });
    it('should call extension API', async () => {
        let fn = async () => {
            await extension_1.default.call('test', 'echo', ['5']);
        };
        await expect(fn()).rejects.toThrow(Error);
    });
    it('should catch error when installExtensions', async () => {
        let spy = jest.spyOn(extension_1.default, 'creteInstaller').mockImplementation(() => {
            return {
                on: (_key, cb) => {
                    cb('msg', false);
                },
                install: () => {
                    return Promise.resolve({ name: 'name', url: 'http://e', version: '1.0.0' });
                }
            };
        });
        let s = jest.spyOn(extension_1.default.states, 'setLocked').mockImplementation(() => {
            throw new Error('my error');
        });
        await extension_1.default.installExtensions(['abc@1.0.0']);
        spy.mockRestore();
        s.mockRestore();
    });
    it('should catch error on updateExtensions', async () => {
        let spy = jest.spyOn(extension_1.default, 'globalExtensionStats').mockImplementation(() => {
            return [{ id: 'test' }];
        });
        let s = jest.spyOn(extension_1.default, 'creteInstaller').mockImplementation(() => {
            return {
                on: () => { },
                update: () => {
                    return Promise.resolve(path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)()));
                }
            };
        });
        await helper_1.default.doAction('updateExtensions', true);
        spy.mockRestore();
        s.mockRestore();
    });
    it('should update enabled extensions', async () => {
        let spy = jest.spyOn(extension_1.default, 'globalExtensionStats').mockImplementation(() => {
            return [{ id: 'test' }, { id: 'global', isLocked: true }, { id: 'disabled', state: 'disabled' }];
        });
        let s = jest.spyOn(extension_1.default, 'creteInstaller').mockImplementation(() => {
            return {
                on: (_key, cb) => {
                    cb('msg', false);
                },
                update: async () => {
                    await helper_1.default.wait(1);
                    return '';
                }
            };
        });
        await extension_1.default.updateExtensions();
        spy.mockRestore();
        s.mockRestore();
    });
    it('should update extensions by url', async () => {
        let spy = jest.spyOn(extension_1.default, 'globalExtensionStats').mockImplementation(() => {
            return [{ id: 'test', exotic: true, uri: 'http://example.com' }];
        });
        let called = false;
        let s = jest.spyOn(extension_1.default, 'creteInstaller').mockImplementation(() => {
            return {
                on: (_key, cb) => {
                    cb('msg', false);
                },
                update: async (url) => {
                    await helper_1.default.wait(1);
                    called = true;
                    expect(url).toBe('http://example.com');
                    return '';
                }
            };
        });
        await extension_1.default.updateExtensions();
        expect(called).toBe(true);
        spy.mockRestore();
        s.mockRestore();
    });
    it('should clean unnecessary folders & links', async () => {
        // create folder and link in modulesFolder
        let folder = path_1.default.join(extension_1.default.modulesFolder, 'test');
        let link = path_1.default.join(extension_1.default.modulesFolder, 'test-link');
        fs_1.default.mkdirSync(folder, { recursive: true });
        fs_1.default.symlinkSync(folder, link);
        let stats = extension_1.default.states;
        stats.addExtension('foo', '1.0.0');
        let extensionFolder = path_1.default.join(extension_1.default.modulesFolder, 'foo');
        fs_1.default.mkdirSync(extensionFolder, { recursive: true });
        extension_1.default.cleanModulesFolder();
        expect(fs_1.default.existsSync(folder)).toBe(false);
        expect(fs_1.default.existsSync(link)).toBe(false);
        stats.removeExtension('foo');
        expect(fs_1.default.existsSync(extensionFolder)).toBe(true);
        fs_1.default.rmSync(extensionFolder, { recursive: true });
    });
    it('should install global extension', async () => {
        expect(extension_1.default.getExtensionById('coc-omni')).toBeUndefined();
        let folder = path_1.default.join(extension_1.default.modulesFolder, 'coc-omni');
        let spy = jest.spyOn(extension_1.default, 'creteInstaller').mockImplementation(() => {
            return {
                on: () => { },
                install: async () => {
                    fs_1.default.mkdirSync(folder, { recursive: true });
                    let file = path_1.default.join(folder, 'package.json');
                    await (0, fs_2.writeFile)(file, JSON.stringify({ name: 'coc-omni', engines: { coc: '>=0.0.1' }, version: '0.0.1' }, null, 2));
                    await (0, fs_2.writeFile)(path_1.default.join(folder, 'index.js'), 'exports.activate = () => {}');
                    return { name: 'coc-omni', version: '1.0.0', folder };
                }
            };
        });
        await helper_1.default.doAction('installExtensions', 'coc-omni');
        let item = extension_1.default.getExtension('coc-omni');
        expect(item).toBeDefined();
        expect(extension_1.default.getExtensionById('coc-omni')).toBeDefined();
        expect(item.extension.isActive).toBe(true);
        expect(extension_1.default.isActivated('coc-omni')).toBe(true);
        let globals = extension_1.default.globalExtensionStats();
        expect(globals.length).toBe(1);
        expect((await extension_1.default.getExtensionStates()).length).toBeGreaterThan(0);
        spy.mockRestore();
        await helper_1.default.doAction('reloadExtension', 'coc-omni');
        await helper_1.default.doAction('deactivateExtension', 'coc-omni');
        await helper_1.default.doAction('activeExtension', 'coc-omni');
        await helper_1.default.doAction('toggleExtension', 'coc-omni');
        await helper_1.default.doAction('uninstallExtension', 'coc-omni');
        item = extension_1.default.getExtension('coc-omni');
        expect(item).toBeUndefined();
    });
});
//# sourceMappingURL=extensions.test.js.map