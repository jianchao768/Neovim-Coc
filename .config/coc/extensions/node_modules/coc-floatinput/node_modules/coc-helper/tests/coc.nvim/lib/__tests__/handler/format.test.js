"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const util_1 = require("../../util");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let disposables = [];
let format;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    format = helper_1.default.plugin.getHandler().format;
});
beforeEach(() => {
    helper_1.default.updateConfiguration('coc.preferences.formatOnType', true);
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('format handler', () => {
    describe('documentFormat', () => {
        it('should return null when format provider not exists', async () => {
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.provideDocumentFormattingEdits(doc.textDocument, { insertSpaces: false, tabSize: 2 }, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
        it('should throw when provider not found', async () => {
            let doc = await workspace_1.default.document;
            let err;
            try {
                await format.documentFormat(doc);
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeDefined();
        });
        it('should return false when get empty edits ', async () => {
            disposables.push(languages_1.default.registerDocumentFormatProvider(['*'], {
                provideDocumentFormattingEdits: () => {
                    return [];
                }
            }));
            let doc = await helper_1.default.createDocument();
            let res = await format.documentFormat(doc);
            expect(res).toBe(false);
        });
        it('should use provider that have higher score', async () => {
            disposables.push(languages_1.default.registerDocumentFormatProvider([{ language: 'vim' }], {
                provideDocumentFormattingEdits: () => {
                    return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), '  ')];
                }
            }));
            disposables.push(languages_1.default.registerDocumentFormatProvider(['*'], {
                provideDocumentFormattingEdits: () => {
                    return [];
                }
            }));
            let doc = await helper_1.default.createDocument('t.vim');
            let res = await languages_1.default.provideDocumentFormattingEdits(doc.textDocument, { tabSize: 2, insertSpaces: false }, vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.length).toBe(1);
        });
        it('should format current buffer', async () => {
            disposables.push(languages_1.default.registerDocumentFormatProvider([{ language: 'vim' }], {
                provideDocumentFormattingEdits: () => {
                    return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), '  ')];
                }
            }));
            await helper_1.default.createDocument('t.vim');
            await commands_1.default.executeCommand('editor.action.format');
            let line = await nvim.line;
            expect(line).toBe('  ');
        });
    });
    describe('formatOnSave', () => {
        it('should not throw when provider not found', async () => {
            helper_1.default.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['javascript']);
            let filepath = await (0, helper_1.createTmpFile)('');
            await helper_1.default.edit(filepath);
            await nvim.command('setf javascript');
            await nvim.setLine('foo');
            await nvim.command('silent w');
        });
        it('should enable format on save', async () => {
            helper_1.default.updateConfiguration('coc.preferences.formatOnSaveFiletypes', null);
            helper_1.default.updateConfiguration('coc.preferences.formatOnSave', true);
            let doc = await workspace_1.default.document;
            let res = format.shouldFormatOnSave(doc.textDocument);
            expect(res).toBe(true);
        });
        it('should invoke format on save', async () => {
            helper_1.default.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['text']);
            disposables.push(languages_1.default.registerDocumentFormatProvider(['text'], {
                provideDocumentFormattingEdits: document => {
                    let lines = document.getText().replace(/\n$/, '').split(/\n/);
                    let edits = [];
                    for (let i = 0; i < lines.length; i++) {
                        let text = lines[i];
                        if (!text.startsWith(' ')) {
                            edits.push(vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(i, 0), '  '));
                        }
                    }
                    return edits;
                }
            }));
            let filepath = await (0, helper_1.createTmpFile)('a\nb\nc\n');
            let buf = await helper_1.default.edit(filepath);
            await nvim.command('setf text');
            await nvim.command('w');
            let lines = await buf.lines;
            expect(lines).toEqual(['  a', '  b', '  c']);
        });
        it('should cancel when timeout', async () => {
            helper_1.default.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['*']);
            let timer;
            disposables.push(languages_1.default.registerDocumentFormatProvider(['*'], {
                provideDocumentFormattingEdits: () => {
                    return new Promise(resolve => {
                        timer = setTimeout(() => {
                            resolve(undefined);
                        }, 2000);
                    });
                }
            }));
            let filepath = await (0, helper_1.createTmpFile)('a\nb\nc\n');
            await helper_1.default.edit(filepath);
            let n = Date.now();
            await nvim.command('w');
            expect(Date.now() - n).toBeLessThan(1000);
            clearTimeout(timer);
        });
    });
    describe('rangeFormat', () => {
        it('should return null when provider does not exist', async () => {
            let doc = (await workspace_1.default.document).textDocument;
            let range = vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0);
            let options = await workspace_1.default.getFormatOptions();
            let token = (new vscode_languageserver_protocol_1.CancellationTokenSource()).token;
            expect(await languages_1.default.provideDocumentRangeFormattingEdits(doc, range, options, token)).toBe(null);
            expect(languages_1.default.hasProvider(languages_1.ProviderName.FormatOnType, doc)).toBe(false);
            expect(languages_1.default.hasProvider(languages_1.ProviderName.OnTypeEdit, doc)).toBe(false);
            let edits = await languages_1.default.provideDocumentFormattingEdits(doc, options, token);
            expect(edits).toBe(null);
        });
        it('should invoke range format', async () => {
            disposables.push(languages_1.default.registerDocumentRangeFormatProvider(['text'], {
                provideDocumentRangeFormattingEdits: (_document, range) => {
                    let lines = [];
                    for (let i = range.start.line; i <= range.end.line; i++) {
                        lines.push(i);
                    }
                    return lines.map(i => {
                        return vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(i, 0), '  ');
                    });
                }
            }, 1));
            let doc = await helper_1.default.createDocument();
            await nvim.call('setline', [1, ['a', 'b', 'c']]);
            await nvim.command('setf text');
            await nvim.command('normal! ggvG');
            await nvim.input('<esc>');
            expect(languages_1.default.hasFormatProvider(doc.textDocument)).toBe(true);
            expect(languages_1.default.hasProvider(languages_1.ProviderName.Format, doc.textDocument)).toBe(true);
            await helper_1.default.doAction('formatSelected', 'v');
            let buf = nvim.createBuffer(doc.bufnr);
            let lines = await buf.lines;
            expect(lines).toEqual(['  a', '  b', '  c']);
            let options = await workspace_1.default.getFormatOptions(doc.uri);
            let token = (new vscode_languageserver_protocol_1.CancellationTokenSource()).token;
            let edits = await languages_1.default.provideDocumentFormattingEdits(doc.textDocument, options, token);
            expect(edits.length).toBeGreaterThan(0);
        });
        it('should format range by formatexpr option', async () => {
            let range;
            disposables.push(languages_1.default.registerDocumentRangeFormatProvider(['text'], {
                provideDocumentRangeFormattingEdits: (_document, r) => {
                    range = r;
                    return [];
                }
            }));
            await helper_1.default.createDocument();
            await nvim.call('setline', [1, ['a', 'b', 'c']]);
            await nvim.command('setf text');
            await nvim.command(`setl formatexpr=CocAction('formatSelected')`);
            await nvim.command('normal! ggvGgq');
            expect(range).toEqual({
                start: { line: 0, character: 0 }, end: { line: 3, character: 0 }
            });
        });
    });
    describe('formatOnType', () => {
        it('should invoke format', async () => {
            disposables.push(languages_1.default.registerDocumentFormatProvider(['text'], {
                provideDocumentFormattingEdits: () => {
                    return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), '  ')];
                }
            }));
            await helper_1.default.createDocument();
            await nvim.setLine('foo');
            await nvim.command('setf text');
            await helper_1.default.doAction('format');
            let line = await nvim.line;
            expect(line).toEqual('  foo');
        });
        it('should does format on type', async () => {
            let doc = await workspace_1.default.document;
            disposables.push(languages_1.default.registerOnTypeFormattingEditProvider(['text'], {
                provideOnTypeFormattingEdits: () => {
                    return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), '  ')];
                }
            }, ['|']));
            let res = languages_1.default.canFormatOnType('a', doc.textDocument);
            expect(res).toBe(false);
            await helper_1.default.edit();
            await nvim.command('setf text');
            await nvim.input('i|');
            await helper_1.default.waitFor('getline', ['.'], '  |');
            let cursor = await window_1.default.getCursorPosition();
            expect(cursor).toEqual({ line: 0, character: 3 });
        });
        it('should return null when provider not found', async () => {
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.provideDocumentOnTypeEdits('|', doc.textDocument, vscode_languageserver_protocol_1.Position.create(0, 0), vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
        it('should adjust cursor after format on type', async () => {
            disposables.push(languages_1.default.registerOnTypeFormattingEditProvider(['text'], {
                provideOnTypeFormattingEdits: () => {
                    return [
                        vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), '  '),
                        vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 2), 'end')
                    ];
                }
            }, ['|']));
            disposables.push(languages_1.default.registerOnTypeFormattingEditProvider([{ language: '*' }], {
                provideOnTypeFormattingEdits: () => {
                    return [];
                }
            }));
            await helper_1.default.edit();
            await nvim.command('setf text');
            await nvim.setLine('"');
            await nvim.input('i|');
            await helper_1.default.waitFor('getline', ['.'], '  |"end');
            let cursor = await window_1.default.getCursorPosition();
            expect(cursor).toEqual({ line: 0, character: 3 });
        });
    });
    describe('bracketEnterImprove', () => {
        afterEach(() => {
            nvim.command('iunmap <CR>', true);
        });
        it('should format vim file on enter', async () => {
            let buf = await helper_1.default.edit('foo.vim');
            await nvim.command(`inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\\<C-g>u\\<CR>\\<c-r>=coc#on_enter()\\<CR>"`);
            await nvim.setLine('let foo={}');
            await nvim.command(`normal! gg$`);
            await nvim.input('i');
            await nvim.eval(`feedkeys("\\<CR>", 'im')`);
            await helper_1.default.waitFor('getline', [2], '  \\ ');
            let lines = await buf.lines;
            expect(lines).toEqual(['let foo={', '  \\ ', '  \\ }']);
        });
        it('should add new line between bracket', async () => {
            let buf = await helper_1.default.edit();
            await nvim.command(`inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\\<C-g>u\\<CR>\\<c-r>=coc#on_enter()\\<CR>"`);
            await nvim.setLine('  {}');
            await nvim.command(`normal! gg$`);
            await nvim.input('i');
            await nvim.eval(`feedkeys("\\<CR>", 'im')`);
            await helper_1.default.waitFor('getline', [2], '  ');
            let lines = await buf.lines;
            expect(lines).toEqual(['  {', '  ', '  }']);
        });
    });
});
//# sourceMappingURL=format.test.js.map