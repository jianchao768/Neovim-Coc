"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../../events"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const attach_1 = require("../../attach");
const vscode_uri_1 = require("vscode-uri");
let nvim;
beforeAll(async () => {
    let plugin = await helper_1.default.setup(false);
    nvim = plugin.nvim;
    nvim.emit('notification', 'updateConfig', ['suggest.timeout', 300]);
    nvim.emit('notification', 'action_not_exists', []);
    let spy = jest.spyOn(console, 'error').mockImplementation(() => {
        // noop
    });
    await plugin.init('');
    spy.mockRestore();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('notifications', () => {
    it('should notification before plugin ready', () => {
        let timeout = workspace_1.default.getConfiguration('suggest').get('timeout');
        expect(timeout).toBe(300);
    });
    it('should do Log', () => {
        nvim.emit('notification', 'Log', []);
        nvim.emit('notification', 'redraw', []);
    });
    it('should do notifications', async () => {
        nvim.emit('notification', 'listNames', []);
        let called = false;
        let spy = jest.spyOn(console, 'error').mockImplementation(() => {
            called = true;
        });
        nvim.emit('notification', 'name_not_exists', []);
        nvim.emit('notification', 'MenuInput', []);
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
        spy.mockRestore();
    });
});
describe('request', () => {
    it('should get results', async () => {
        let result;
        nvim.emit('request', 'listNames', [], {
            send: res => {
                result = res;
            }
        });
        await helper_1.default.waitValue(() => {
            return Array.isArray(result);
        }, true);
    });
    it('should return error when plugin not ready', async () => {
        let plugin = helper_1.default.plugin;
        Object.assign(plugin, { ready: false });
        let isErr;
        nvim.emit('request', 'listNames', [], {
            send: (_res, isError) => {
                isErr = isError;
            }
        });
        await helper_1.default.waitValue(() => {
            return isErr;
        }, true);
        Object.assign(plugin, { ready: true });
    });
    it('should not throw when plugin method not found', async () => {
        let err;
        nvim.emit('request', 'NotExists', [], {
            send: res => {
                err = res;
            }
        });
        await helper_1.default.waitValue(() => {
            return typeof err === 'string';
        }, true);
    });
});
describe('attach', () => {
    it('should do path replace', () => {
        (0, attach_1.pathReplace)(undefined);
        (0, attach_1.pathReplace)({});
        nvim.emit('notification', 'VimEnter', [{
                '/foo': '/foo/bar'
            }]);
        let filepath = vscode_uri_1.URI.file('/foo/home').fsPath;
        expect(filepath).toBe('/foo/bar/home');
        (0, attach_1.pathReplace)({ '/foo': '/foo' });
    });
    it('should not throw on event handler error', async () => {
        events_1.default.on('CursorHold', () => {
            throw new Error('error');
        });
        let called = false;
        nvim.emit('request', 'CocAutocmd', ['CursorHold'], {
            send: () => {
                called = true;
            }
        });
        await helper_1.default.waitValue(() => {
            return called;
        }, true);
    });
});
//# sourceMappingURL=attach.test.js.map