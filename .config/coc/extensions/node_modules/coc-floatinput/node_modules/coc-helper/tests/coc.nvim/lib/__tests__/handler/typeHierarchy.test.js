"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importStar(require("../../languages"));
const LocationsDataProvider_1 = require("../../tree/LocationsDataProvider");
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let disposables = [];
let handler;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    handler = helper_1.default.plugin.getHandler().typeHierarchy;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    await helper_1.default.createDocument();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
function createItem(name, kind, uri, range) {
    range = range !== null && range !== void 0 ? range : vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3);
    return {
        name,
        kind: kind !== null && kind !== void 0 ? kind : vscode_languageserver_protocol_1.SymbolKind.Function,
        uri: uri !== null && uri !== void 0 ? uri : 'file:///1',
        range,
        selectionRange: range,
    };
}
const position = vscode_languageserver_protocol_1.Position.create(0, 0);
const token = vscode_languageserver_protocol_1.CancellationToken.None;
describe('TypeHierarchy', () => {
    describe('TypeHierarchyManager', () => {
        it('should return false when provider not exists', async () => {
            let doc = await workspace_1.default.document;
            let res = languages_1.default.hasProvider(languages_1.ProviderName.TypeHierarchy, doc.textDocument);
            expect(res).toBe(false);
        });
        it('should return merged results', async () => {
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy: () => {
                    return null;
                },
                provideTypeHierarchySubtypes: () => {
                    return [];
                },
                provideTypeHierarchySupertypes: () => {
                    return [];
                }
            }));
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy: () => {
                    return [createItem('a'), createItem('b')];
                },
                provideTypeHierarchySubtypes: () => {
                    return [];
                },
                provideTypeHierarchySupertypes: () => {
                    return [];
                }
            }));
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy: () => {
                    return [createItem('b'), createItem('c')];
                },
                provideTypeHierarchySubtypes: () => {
                    return [];
                },
                provideTypeHierarchySupertypes: () => {
                    return [];
                }
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.prepareTypeHierarchy(doc.textDocument, position, token);
            expect(res.length).toBe(3);
        });
        it('should return empty array when provider not found', async () => {
            let item = createItem('foo');
            let res;
            res = await languages_1.default.provideTypeHierarchySupertypes(item, token);
            expect(res).toEqual([]);
            res = await languages_1.default.provideTypeHierarchySubtypes(item, token);
            expect(res).toEqual([]);
        });
        it('should return subtypes and supertypes', async () => {
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy: () => {
                    return [createItem('b')];
                },
                provideTypeHierarchySubtypes: () => {
                    return [createItem('c')];
                },
                provideTypeHierarchySupertypes: () => {
                    return [createItem('d')];
                }
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.prepareTypeHierarchy(doc.textDocument, position, token);
            let arr;
            arr = await languages_1.default.provideTypeHierarchySubtypes(res[0], token);
            expect(arr.length).toBe(1);
            expect(arr[0].source).toBeDefined();
            arr = await languages_1.default.provideTypeHierarchySupertypes(res[0], token);
            expect(arr.length).toBe(1);
            expect(arr[0].source).toBeDefined();
        });
        it('should not throw when prepareTypeHierarchy throws', async () => {
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy: () => {
                    throw new Error('my error');
                },
                provideTypeHierarchySubtypes: () => {
                    return undefined;
                },
                provideTypeHierarchySupertypes: () => {
                    return undefined;
                }
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.prepareTypeHierarchy(doc.textDocument, position, token);
            expect(res).toEqual([]);
        });
        it('should return empty supertypes and supertypes', async () => {
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy: () => {
                    return [createItem('b')];
                },
                provideTypeHierarchySubtypes: () => {
                    return null;
                },
                provideTypeHierarchySupertypes: () => {
                    return undefined;
                }
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.prepareTypeHierarchy(doc.textDocument, position, token);
            let arr;
            arr = await languages_1.default.provideTypeHierarchySubtypes(res[0], token);
            expect(arr).toEqual([]);
            arr = await languages_1.default.provideTypeHierarchySupertypes(res[0], token);
            expect(arr).toEqual([]);
        });
    });
    describe('TypeHierarchyHandler', () => {
        it('should add children', async () => {
            let item = createItem('foo');
            (0, LocationsDataProvider_1.addChildren)(item, undefined);
            expect(item['children']).toBeUndefined();
            (0, LocationsDataProvider_1.addChildren)(item, [], vscode_languageserver_protocol_1.CancellationToken.Cancelled);
            expect(item['children']).toBeUndefined();
        });
        it('should throw when provider not exist', async () => {
            let fn = async () => {
                await handler.showTypeHierarchyTree('supertypes');
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should show warning when prepare return empty', async () => {
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy() {
                    return null;
                },
                provideTypeHierarchySupertypes() {
                    return [];
                },
                provideTypeHierarchySubtypes() {
                    return [];
                }
            }));
            let plugin = helper_1.default.plugin;
            await plugin.cocAction('showSuperTypes');
            await nvim.command('echo ""');
            await plugin.cocAction('showSubTypes');
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('Unable');
        });
        it('should invoke super types and sub types action', async () => {
            let doc = await workspace_1.default.document;
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy() {
                    return [createItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3))];
                },
                provideTypeHierarchySupertypes() {
                    return undefined;
                },
                provideTypeHierarchySubtypes() {
                    return undefined;
                }
            }));
            await handler.showTypeHierarchyTree('supertypes');
            await helper_1.default.waitFor('getline', [2], '- c foo');
            await nvim.command('exe 2');
            await nvim.input('<tab>');
            await helper_1.default.waitPrompt();
            await nvim.input('4');
            await helper_1.default.waitFor('getline', [1], 'Sub types');
            await nvim.input('<tab>');
            await helper_1.default.waitPrompt();
            await nvim.input('3');
            await helper_1.default.waitFor('getline', [1], 'Super types');
        });
        it('should render description and support default action', async () => {
            let doc = await workspace_1.default.document;
            let bufnr = doc.bufnr;
            await doc.buffer.setLines(['foo'], { start: 0, end: -1, strictIndexing: false });
            let fsPath = await (0, helper_1.createTmpFile)('foo\nbar\ncontent\n');
            let uri = vscode_uri_1.URI.file(fsPath).toString();
            disposables.push(languages_1.default.registerTypeHierarchyProvider([{ language: '*' }], {
                prepareTypeHierarchy() {
                    return [createItem('foo', vscode_languageserver_protocol_1.SymbolKind.Class, doc.uri, vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3))];
                },
                provideTypeHierarchySupertypes() {
                    let item = createItem('bar', vscode_languageserver_protocol_1.SymbolKind.Class, uri, vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3));
                    item.detail = 'Detail';
                    item.tags = [vscode_languageserver_protocol_1.SymbolTag.Deprecated];
                    return [item];
                },
                provideTypeHierarchySubtypes() {
                    return [];
                }
            }));
            await handler.showTypeHierarchyTree('supertypes');
            let buf = await nvim.buffer;
            let lines = await buf.lines;
            expect(lines).toEqual([
                'Super types',
                '- c foo',
                '  + c bar Detail'
            ]);
            await nvim.command('exe 3');
            await nvim.input('t');
            await helper_1.default.waitFor('getline', ['.'], '  - c bar Detail');
            await nvim.input('<cr>');
            await helper_1.default.waitFor('expand', ['%:p'], fsPath);
            let res = await nvim.call('coc#cursor#position');
            expect(res).toEqual([1, 0]);
            let matches = await nvim.call('getmatches');
            expect(matches.length).toBe(1);
            await nvim.command(`b ${bufnr}`);
            await helper_1.default.wait(50);
            matches = await nvim.call('getmatches');
            expect(matches.length).toBe(0);
            await nvim.command(`wincmd o`);
        });
    });
});
//# sourceMappingURL=typeHierarchy.test.js.map