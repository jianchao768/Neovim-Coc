'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.startedInDebugMode = exports.getServerWorkingDir = exports.mainGetRootPath = exports.getRuntimePath = exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("../logger");
const util_1 = require("../util");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const processes_1 = require("../util/processes");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const client_1 = require("./client");
const logger = (0, logger_1.createLogger)('language-client-index');
const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
const STOP_TIMEOUT = (0, util_1.getConditionValue)(2000, 100);
tslib_1.__exportStar(require("./client"), exports);
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        let candidate = value;
        return (candidate &&
            candidate.kind === TransportKind.socket &&
            Is.number(candidate.port));
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return (candidate && candidate.writer !== void 0 && candidate.reader !== void 0);
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return (candidate &&
            candidate.process !== void 0 &&
            typeof candidate.detached === 'boolean');
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            // first signature
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = !!forceDebug;
        this._isInDebugMode = !!forceDebug;
    }
    stop(timeout = STOP_TIMEOUT) {
        return super.stop(timeout).then(() => {
            if (this._serverProcess) {
                let toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === void 0 || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        }, err => {
            if (err.message.includes('timed out')) {
                this._serverProcess.kill('SIGKILL');
                this._serverProcess = undefined;
                return;
            }
            throw err;
        });
    }
    get serviceState() {
        return this._state;
    }
    checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === undefined)
            return;
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                (0, processes_1.terminate)(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, STOP_TIMEOUT);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    get isInDebugMode() {
        return this._isInDebugMode;
    }
    async restart() {
        await this.stop();
        // We are in debug mode. Wait a little before we restart
        // so that the debug port can be freed. We can safely ignore
        // the disposable returned from start since it will call
        // stop on the same client instance.
        if (this.isInDebugMode) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            await this._start();
        }
        else {
            await this._start();
        }
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            let result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        let server = this._serverOptions;
        const logMessage = this.logMessage.bind(this);
        // We got a function.
        if (Is.func(server)) {
            return server().then(result => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return {
                        reader: new protocol_1.StreamMessageReader(result.reader),
                        writer: new protocol_1.StreamMessageWriter(result.writer)
                    };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', logMessage);
                    return {
                        reader: new protocol_1.StreamMessageReader(cp.stdout),
                        writer: new protocol_1.StreamMessageWriter(cp.stdin)
                    };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode(process.execArgv)) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        return getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                let pipeName;
                let runtime = node.runtime ? getRuntimePath(node.runtime, serverWorkingDir) : undefined;
                return new Promise((resolve, _reject) => {
                    let args = node.args && node.args.slice() || [];
                    if (transport === TransportKind.ipc) {
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = (0, protocol_1.generateRandomPipeName)();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid}`);
                    let options = node.options || Object.create(null);
                    options.env = getEnvironment(options.env, true);
                    options.execArgv = options.execArgv || [];
                    options.cwd = serverWorkingDir;
                    options.silent = true;
                    if (runtime)
                        options.execPath = runtime;
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        let sp = node_1.child_process.fork(node.module, args || [], options);
                        assertStdio(sp);
                        this._serverProcess = sp;
                        logger.info(`Language server "${this.id}" started with ${sp.pid}`);
                        sp.stderr.on('data', logMessage);
                        if (transport === TransportKind.ipc) {
                            sp.stdout.on('data', logMessage);
                            resolve({ reader: new protocol_1.IPCMessageReader(this._serverProcess), writer: new protocol_1.IPCMessageWriter(this._serverProcess) });
                        }
                        else {
                            resolve({ reader: new protocol_1.StreamMessageReader(sp.stdout), writer: new protocol_1.StreamMessageWriter(sp.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return (0, protocol_1.createClientPipeTransport)(pipeName).then(transport => {
                            let sp = node_1.child_process.fork(node.module, args || [], options);
                            assertStdio(sp);
                            logger.info(`Language server "${this.id}" started with ${sp.pid}`);
                            this._serverProcess = sp;
                            sp.stderr.on('data', logMessage);
                            sp.stdout.on('data', logMessage);
                            void transport.onConnected().then(protocol => {
                                resolve({ reader: protocol[0], writer: protocol[1] });
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return (0, protocol_1.createClientSocketTransport)(transport.port).then(transport => {
                            let sp = node_1.child_process.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            logger.info(`Language server "${this.id}" started with ${sp.pid}`);
                            sp.stderr.on('data', logMessage);
                            sp.stdout.on('data', logMessage);
                            void transport.onConnected().then(protocol => {
                                resolve({ reader: protocol[0], writer: protocol[1] });
                            });
                        });
                    }
                });
            }
            else if (Executable.is(json) && json.command) {
                let command = json;
                let args = command.args || [];
                let options = Object.assign({}, command.options);
                options.env = options.env ? Object.assign({}, process.env, options.env) : process.env;
                options.cwd = options.cwd || serverWorkingDir;
                let cmd = workspace_1.default.expand(json.command);
                let serverProcess = node_1.child_process.spawn(cmd, args, options);
                serverProcess.on('error', e => {
                    this.error(e.message, e);
                });
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject(new Error(`Launching server "${this.id}" using command ${command.command} failed.`));
                }
                logger.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
                serverProcess.on('exit', code => {
                    if (code != 0)
                        this.error(`${command.command} exited with code: ${code}`);
                });
                serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                return Promise.resolve({ reader: new protocol_1.StreamMessageReader(serverProcess.stdout), writer: new protocol_1.StreamMessageWriter(serverProcess.stdin) });
            }
            return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
        });
    }
    logMessage(data) {
        let encoding = this.clientOptions.stdioEncoding;
        this.outputChannel.append(Is.string(data) ? data : data.toString(encoding));
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(this._setting)) {
                this.onDidChangeConfiguration();
            }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
            dispose: () => {
                (0, util_1.disposeAll)(this._listeners);
                void this._client.dispose();
            }
        };
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest
            ? workspace_1.default.getConfiguration(primary).get(rest, true)
            : workspace_1.default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start().catch(error => this._client.error('Start failed after configuration change', error, 'force'));
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop().catch(error => this._client.error('Stop failed after configuration change', error, 'force'));
        }
    }
}
exports.SettingMonitor = SettingMonitor;
function getRuntimePath(runtime, serverWorkingDirectory) {
    if (node_1.path.isAbsolute(runtime)) {
        return runtime;
    }
    const mainRootPath = mainGetRootPath();
    if (mainRootPath !== undefined) {
        const result = node_1.path.join(mainRootPath, runtime);
        if (node_1.fs.existsSync(result)) {
            return result;
        }
    }
    if (serverWorkingDirectory !== undefined) {
        const result = node_1.path.join(serverWorkingDirectory, runtime);
        if (node_1.fs.existsSync(result)) {
            return result;
        }
    }
    return runtime;
}
exports.getRuntimePath = getRuntimePath;
function mainGetRootPath() {
    let folders = workspace_1.default.workspaceFolders;
    if (!folders || folders.length === 0) {
        return undefined;
    }
    let folder = folders[0];
    return folder.uri;
}
exports.mainGetRootPath = mainGetRootPath;
function getServerWorkingDir(options) {
    let cwd = options && options.cwd;
    if (cwd && !node_1.path.isAbsolute(cwd))
        cwd = node_1.path.join(workspace_1.default.cwd, cwd);
    if (!cwd)
        cwd = workspace_1.default.cwd;
    // make sure the folder exists otherwise creating the process will fail
    return new Promise(s => {
        node_1.fs.lstat(cwd, (err, stats) => {
            s(!err && stats.isDirectory() ? cwd : undefined);
        });
    });
}
exports.getServerWorkingDir = getServerWorkingDir;
function startedInDebugMode(args) {
    if (args) {
        return args.some(arg => {
            return debugStartWith.some(value => arg.startsWith(value)) ||
                debugEquals.some(value => arg === value);
        });
    }
    return false;
}
exports.startedInDebugMode = startedInDebugMode;
//# sourceMappingURL=index.js.map