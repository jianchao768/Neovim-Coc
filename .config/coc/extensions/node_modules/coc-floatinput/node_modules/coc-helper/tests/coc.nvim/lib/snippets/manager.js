'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnippetManager = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const commands_1 = tslib_1.__importDefault(require("../commands"));
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const object_1 = require("../util/object");
const position_1 = require("../util/position");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const session_1 = require("./session");
const snippet_1 = require("./snippet");
const string_1 = require("./string");
class SnippetManager {
    constructor() {
        this.sessionMap = new Map();
        this.disposables = [];
    }
    init() {
        events_1.default.on('InsertCharPre', (_, bufnr) => {
            // avoid update session when pumvisible
            // Update may cause completion unexpected terminated.
            let session = this.getSession(bufnr);
            if (session)
                session.cancel();
        }, null, this.disposables);
        events_1.default.on('InsertEnter', async (bufnr) => {
            let session = this.getSession(bufnr);
            if (session)
                await session.checkPosition();
        }, null, this.disposables);
        workspace_1.default.onDidCloseTextDocument(e => {
            let session = this.getSession(e.bufnr);
            if (session)
                session.deactivate();
        }, null, this.disposables);
        window_1.default.onDidChangeActiveTextEditor(e => {
            if (!this._statusItem)
                return;
            let session = this.getSession(e.document.bufnr);
            if (session) {
                this.statusItem.show();
            }
            else {
                this.statusItem.hide();
            }
        }, null, this.disposables);
        commands_1.default.register({
            id: 'editor.action.insertSnippet',
            execute: async (edit, ultisnip) => {
                const opts = ultisnip === true ? {} : ultisnip;
                return await this.insertSnippet(edit.newText, true, edit.range, vscode_languageserver_types_1.InsertTextMode.adjustIndentation, opts ? opts : undefined);
            }
        }, true);
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
    get statusItem() {
        if (this._statusItem)
            return this._statusItem;
        let statusItem = this._statusItem = window_1.default.createStatusBarItem(0);
        const snippetConfig = workspace_1.default.initialConfiguration.get('snippet');
        statusItem.text = (0, util_1.defaultValue)(snippetConfig.statusText, '');
        return this._statusItem;
    }
    getSnippetConfig(resource) {
        let config = workspace_1.default.getConfiguration('coc.preferences', resource);
        const snippetConfig = workspace_1.default.getConfiguration('snippet', resource);
        const suggest = workspace_1.default.getConfiguration('suggest', resource);
        return {
            highlight: config.get('snippetHighlight', snippetConfig.get('highlight', false)),
            nextOnDelete: config.get('nextPlaceholderOnDelete', snippetConfig.get('nextPlaceholderOnDelete', false)),
            preferComplete: suggest.get('preferCompleteThanJumpPlaceholder', false)
        };
    }
    /**
     * Insert snippet at current cursor position
     */
    async insertSnippet(snippet, select = true, range, insertTextMode, ultisnip) {
        let { bufnr } = workspace_1.default;
        let doc = workspace_1.default.getAttachedDocument(bufnr);
        if (range && !(0, position_1.rangeInRange)(range, vscode_languageserver_types_1.Range.create(0, 0, doc.lineCount + 1, 0))) {
            throw new Error(`Unable to insert snippet, invalid range.`);
        }
        let context;
        if (!range) {
            let pos = await window_1.default.getCursorPosition();
            range = vscode_languageserver_types_1.Range.create(pos, pos);
        }
        const currentLine = doc.getline(range.start.line);
        const snippetStr = string_1.SnippetString.isSnippetString(snippet) ? snippet.value : snippet;
        const inserted = await this.normalizeInsertText(doc.uri, snippetStr, currentLine, insertTextMode);
        if (ultisnip != null) {
            context = Object.assign({ range: (0, object_1.deepClone)(range), line: currentLine }, ultisnip);
            if (!(0, position_1.emptyRange)(range) && inserted.includes('`!p')) {
                // same behavior as Ultisnips
                this.nvim.call('coc#cursor#move_to', [range.start.line, range.start.character], true);
                await doc.applyEdits([{ range, newText: '' }]);
                range.end = vscode_languageserver_types_1.Position.create(range.start.line, range.start.character);
            }
        }
        let session = this.getSession(bufnr);
        if (session) {
            await session.forceSynchronize();
            // current session could be canceled on synchronize.
            session = this.getSession(bufnr);
        }
        else {
            await doc.patchChange(true);
        }
        if (!session) {
            let config = this.getSnippetConfig(doc.uri);
            session = new session_1.SnippetSession(this.nvim, doc, config);
            session.onCancel(() => {
                this.sessionMap.delete(bufnr);
                this.statusItem.hide();
            });
        }
        let isActive = await session.start(inserted, range, select, context);
        if (isActive) {
            this.statusItem.show();
            this.sessionMap.set(bufnr, session);
        }
        else {
            this.statusItem.hide();
            this.sessionMap.delete(bufnr);
        }
        return isActive;
    }
    async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session)
            return await session.selectCurrentPlaceholder(triggerAutocmd);
    }
    async nextPlaceholder() {
        let { session } = this;
        if (session) {
            await session.nextPlaceholder();
        }
        else {
            this.nvim.call('coc#snippet#disable', [], true);
            this.statusItem.hide();
        }
        return '';
    }
    async previousPlaceholder() {
        let { session } = this;
        if (session) {
            await session.previousPlaceholder();
        }
        else {
            this.nvim.call('coc#snippet#disable', [], true);
            this.statusItem.hide();
        }
        return '';
    }
    cancel() {
        let session = this.getSession(workspace_1.default.bufnr);
        if (session)
            return session.deactivate();
        this.nvim.call('coc#snippet#disable', [], true);
        if (this.statusItem)
            this.statusItem.hide();
    }
    get session() {
        return this.getSession(workspace_1.default.bufnr);
    }
    getSession(bufnr) {
        return this.sessionMap.get(bufnr);
    }
    jumpable() {
        let { session } = this;
        if (!session)
            return false;
        return session.placeholder != null && session.placeholder.index != 0;
    }
    async editsInsideSnippet(edits) {
        let session = this.getSession(workspace_1.default.bufnr);
        if (!session || !session.snippet)
            return false;
        await session.forceSynchronize();
        let range = session.snippet.range;
        if (edits.some(e => (0, position_1.rangeOverlap)(e.range, range))) {
            return true;
        }
        return false;
    }
    async resolveSnippet(snippetString, ultisnip) {
        if (ultisnip) {
            let session = this.getSession(workspace_1.default.bufnr);
            if (session != null && session.snippet.hasPython)
                ultisnip.noPython = false;
        }
        return await session_1.SnippetSession.resolveSnippet(this.nvim, snippetString, ultisnip);
    }
    async normalizeInsertText(uri, snippetString, currentLine, insertTextMode) {
        let inserted = '';
        if (insertTextMode === vscode_languageserver_types_1.InsertTextMode.asIs || !(0, snippet_1.shouldFormat)(snippetString)) {
            inserted = snippetString;
        }
        else {
            const currentIndent = currentLine.match(/^\s*/)[0];
            const formatOptions = window_1.default.activeTextEditor ? window_1.default.activeTextEditor.options : await workspace_1.default.getFormatOptions(uri);
            inserted = (0, snippet_1.normalizeSnippetString)(snippetString, currentIndent, formatOptions);
        }
        return inserted;
    }
    dispose() {
        this.cancel();
        for (let d of this.disposables) {
            d.dispose();
        }
    }
}
exports.SnippetManager = SnippetManager;
exports.default = new SnippetManager();
//# sourceMappingURL=manager.js.map