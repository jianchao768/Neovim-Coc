"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semanticTokensBuilder_1 = require("../../model/semanticTokensBuilder");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
function toArr(uint32Arr) {
    const r = [];
    for (let i = 0, len = uint32Arr.length; i < len; i++) {
        r[i] = uint32Arr[i];
    }
    return r;
}
function deepStrictEqual(one, two) {
    expect(one).toEqual(two);
}
describe('SemanticTokensBuilder', () => {
    it('should build SemanticTokensBuilder simple', () => {
        const builder = new semanticTokensBuilder_1.SemanticTokensBuilder();
        builder.push(1, 0, 5, 1, 1);
        builder.push(1, 10, 4, 2, 2);
        builder.push(2, 2, 3, 2, 2);
        deepStrictEqual(toArr(builder.build().data), [
            1, 0, 5, 1, 1,
            0, 10, 4, 2, 2,
            1, 2, 3, 2, 2
        ]);
    });
    it('should throw for bad arguments', async () => {
        const builder = new semanticTokensBuilder_1.SemanticTokensBuilder();
        expect(() => {
            builder.push(undefined, undefined, undefined, undefined);
        }).toThrow(Error);
        expect(() => {
            builder.push(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), '');
        }).toThrow(Error);
        Object.assign(builder, { _hasLegend: true });
        expect(() => {
            builder.push(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 3), '');
        }).toThrow(Error);
        expect(() => {
            builder.push(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), '');
        }).toThrow(Error);
    });
    it('should build SemanticTokensBuilder no modifier', () => {
        const builder = new semanticTokensBuilder_1.SemanticTokensBuilder();
        builder.push(1, 0, 5, 1);
        builder.push(1, 10, 4, 2);
        builder.push(2, 2, 3, 2);
        deepStrictEqual(toArr(builder.build().data), [
            1, 0, 5, 1, 0,
            0, 10, 4, 2, 0,
            1, 2, 3, 2, 0
        ]);
    });
    it('should build SemanticTokensBuilder out of order 1', () => {
        const builder = new semanticTokensBuilder_1.SemanticTokensBuilder();
        builder.push(2, 0, 5, 1, 1);
        builder.push(2, 10, 1, 2, 2);
        builder.push(2, 15, 2, 3, 3);
        builder.push(1, 0, 4, 4, 4);
        deepStrictEqual(toArr(builder.build().data), [
            1, 0, 4, 4, 4,
            1, 0, 5, 1, 1,
            0, 10, 1, 2, 2,
            0, 5, 2, 3, 3
        ]);
    });
    it('SemanticTokensBuilder out of order 2', () => {
        const builder = new semanticTokensBuilder_1.SemanticTokensBuilder();
        builder.push(2, 10, 5, 1, 1);
        builder.push(2, 2, 4, 2, 2);
        deepStrictEqual(toArr(builder.build().data), [
            2, 2, 4, 2, 2,
            0, 8, 5, 1, 1
        ]);
    });
    test('SemanticTokensBuilder with legend', () => {
        const legend = {
            tokenTypes: ['aType', 'bType', 'cType', 'dType'],
            tokenModifiers: ['mod0', 'mod1', 'mod2', 'mod3', 'mod4', 'mod5']
        };
        const builder = new semanticTokensBuilder_1.SemanticTokensBuilder(legend);
        builder.push(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 5), 'bType');
        builder.push(vscode_languageserver_protocol_1.Range.create(2, 0, 2, 4), 'cType', ['mod0', 'mod5']);
        builder.push(vscode_languageserver_protocol_1.Range.create(3, 0, 3, 3), 'dType', ['mod2', 'mod4']);
        deepStrictEqual(toArr(builder.build().data), [
            1, 0, 5, 1, 0,
            1, 0, 4, 2, 1 | (1 << 5),
            1, 0, 3, 3, (1 << 2) | (1 << 4)
        ]);
        expect(() => {
            builder.push(vscode_languageserver_protocol_1.Range.create(3, 0, 3, 3), 'dType', ['mod2', 'mod4', 'mod10']);
        }).toThrow(Error);
    });
});
//# sourceMappingURL=semanticTokensBuilder.test.js.map