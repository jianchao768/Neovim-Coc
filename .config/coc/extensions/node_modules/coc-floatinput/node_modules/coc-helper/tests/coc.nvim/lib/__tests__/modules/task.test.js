"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterEach(() => {
    (0, util_1.disposeAll)(disposables);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('task test', () => {
    it('should start task', async () => {
        let task = workspace_1.default.createTask('sleep');
        disposables.push(task);
        let started = await task.start({ cmd: 'sleep', args: ['50'] });
        expect(started).toBe(true);
    });
    it('should stop task', async () => {
        let task = workspace_1.default.createTask('sleep');
        disposables.push(task);
        await task.start({ cmd: 'sleep', args: ['50'] });
        await task.stop();
        let running = await task.running;
        expect(running).toBe(false);
    });
    it('should emit exit event', async () => {
        let fn = jest.fn();
        let task = workspace_1.default.createTask('sleep');
        disposables.push(task);
        task.onExit(fn);
        await task.start({ cmd: 'sleep', args: ['50'] });
        await helper_1.default.wait(10);
        await task.stop();
        expect(fn).toBeCalled();
    });
    it('should emit stdout event', async () => {
        let file = await (0, helper_1.createTmpFile)('echo foo');
        let task = workspace_1.default.createTask('echo');
        disposables.push(task);
        let p = new Promise(resolve => {
            let lines = [];
            task.onStdout(stdout => {
                lines.push(...stdout);
            });
            task.onExit(() => {
                resolve(lines);
            });
        });
        await task.start({ cmd: '/bin/sh', args: [file] });
        let lines = await p;
        expect(lines).toEqual(['foo']);
    });
    it('should change environment variables', async () => {
        let file = await (0, helper_1.createTmpFile)('echo $NODE_ENV\necho $COC_NVIM_TEST');
        let task = workspace_1.default.createTask('ENV');
        disposables.push(task);
        let lines = [];
        task.onStdout(arr => {
            lines.push(...arr);
        });
        let p = new Promise(resolve => {
            task.onExit(() => {
                resolve();
            });
        });
        await task.start({
            cmd: '/bin/sh',
            args: [file],
            env: {
                NODE_ENV: 'production',
                COC_NVIM_TEST: 'yes'
            }
        });
        await p;
        expect(lines).toEqual(['production', 'yes']);
        let res = await nvim.call('getenv', 'COC_NVIM_TEST');
        expect(res).toBeNull();
    });
    it('should receive stdout lines as expected', async () => {
        let file = await (0, helper_1.createTmpFile)('echo 3\necho ""\necho 4');
        let task = workspace_1.default.createTask('ENV');
        let p = new Promise(resolve => {
            let lines = [];
            task.onStdout(arr => {
                lines.push(...arr);
            });
            task.onExit(() => {
                resolve(lines);
            });
        });
        await task.start({ cmd: '/bin/sh', args: [file] });
        let lines = await p;
        expect(lines).toEqual(['3', '', '4']);
        task.dispose();
    });
    it('should emit stderr event', async () => {
        let file = await (0, helper_1.createTmpFile)('console.error("start\\n\\nend");');
        let task = workspace_1.default.createTask('error');
        disposables.push(task);
        let p = new Promise(resolve => {
            let lines = [];
            task.onStderr(arr => {
                lines.push(...arr);
            });
            task.onExit(() => {
                resolve(lines);
            });
        });
        await task.start({ cmd: 'node', args: [file] });
        let lines = await p;
        expect(lines).toEqual(['start', '', 'end']);
    });
    it('should not receive event from other task', async () => {
        let task1 = workspace_1.default.createTask('one');
        disposables.push(task1);
        let count = 0;
        let cb = () => {
            count++;
        };
        task1.onExit(cb);
        task1.onStderr(cb);
        task1.onStdout(cb);
        let file = await (0, helper_1.createTmpFile)('console.log("start");console.error("end");');
        let task = workspace_1.default.createTask('error');
        await task.start({ cmd: 'node', args: [file] });
        let promise = new Promise(resolve => {
            task.onExit(() => {
                resolve(undefined);
            });
        });
        await promise;
        expect(count).toBe(0);
    });
});
//# sourceMappingURL=task.test.js.map