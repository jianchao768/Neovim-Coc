'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStateName = exports.stateString = exports.convertState = exports.getSpawnOptions = exports.getForkOptions = exports.getTransportKind = exports.getDocumentSelector = exports.getRevealOutputChannelOn = exports.isValidServerConfig = exports.getLanguageServerOptions = exports.documentSelectorToLanguageIds = exports.ServiceStat = void 0;
const tslib_1 = require("tslib");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("./events"));
const language_client_1 = require("./language-client");
const logger_1 = require("./logger");
const util_1 = require("./util");
const node_1 = require("./util/node");
const object_1 = require("./util/object");
const protocol_1 = require("./util/protocol");
const window_1 = tslib_1.__importDefault(require("./window"));
const workspace_1 = tslib_1.__importDefault(require("./workspace"));
const logger = (0, logger_1.createLogger)('services');
var ServiceStat;
(function (ServiceStat) {
    ServiceStat[ServiceStat["Initial"] = 0] = "Initial";
    ServiceStat[ServiceStat["Starting"] = 1] = "Starting";
    ServiceStat[ServiceStat["StartFailed"] = 2] = "StartFailed";
    ServiceStat[ServiceStat["Running"] = 3] = "Running";
    ServiceStat[ServiceStat["Stopping"] = 4] = "Stopping";
    ServiceStat[ServiceStat["Stopped"] = 5] = "Stopped";
})(ServiceStat = exports.ServiceStat || (exports.ServiceStat = {}));
class ServiceManager {
    constructor() {
        this.registered = new Map();
        this.disposables = [];
        this.pendingNotifications = new Map();
        this.registLanguageClient = this.registerLanguageClient.bind(this);
        this.regist = this.register.bind(this);
    }
    init() {
        workspace_1.default.onDidOpenTextDocument(document => {
            void this.start(document);
        }, null, this.disposables);
        const iterate = (folders) => {
            for (let folder of folders) {
                this.registerClientsFromFolder(folder);
            }
        };
        workspace_1.default.onDidChangeWorkspaceFolders(e => {
            iterate(e.added);
        }, null, this.disposables);
        // `languageserver.${name}`
        // Global configured languageserver
        let lspConfig = workspace_1.default.initialConfiguration.get('languageserver', {});
        this.registerClientsByConfig(lspConfig);
        iterate(workspace_1.default.workspaceFolders);
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('languageserver')) {
                let lspConfig = workspace_1.default.getConfiguration('languageserver', null);
                this.registerClientsByConfig(lspConfig);
            }
        }, null, this.disposables);
    }
    registerClientsFromFolder(workspaceFolder) {
        let uri = vscode_uri_1.URI.parse(workspaceFolder.uri);
        let lspConfig = workspace_1.default.getConfiguration(undefined, uri);
        let config = lspConfig.inspect('languageserver').workspaceFolderValue;
        this.registerClientsByConfig(config, uri);
    }
    register(service) {
        let { id } = service;
        if (this.registered.get(id))
            return;
        this.registered.set(id, service);
        this.tryStartService(service);
        service.onServiceReady(() => {
            logger.info(`service ${id} started`);
        }, null, this.disposables);
        return protocol_1.Disposable.create(() => {
            if (!this.registered.has(id))
                return;
            service.dispose();
            this.registered.delete(id);
        });
    }
    tryStartService(service) {
        if (!events_1.default.ready) {
            let disposable = events_1.default.on('ready', () => {
                disposable.dispose();
                if (this.shouldStart(service)) {
                    void service.start();
                }
            });
        }
        else if (this.shouldStart(service)) {
            void service.start();
        }
    }
    getService(id) {
        let service = this.registered.get(id);
        if (!service)
            service = this.registered.get(`languageserver.${id}`);
        return service;
    }
    shouldStart(service) {
        if (service.state != ServiceStat.Initial)
            return false;
        let selector = service.selector;
        for (let doc of workspace_1.default.documents) {
            if (workspace_1.default.match(selector, doc.textDocument)) {
                return true;
            }
        }
        return false;
    }
    async start(document) {
        let services = [];
        for (let service of this.registered.values()) {
            if (service.state == ServiceStat.Initial && workspace_1.default.match(service.selector, document) > 0) {
                services.push(service);
            }
        }
        await Promise.allSettled(services.map(service => {
            return service.start();
        }));
    }
    stop(id) {
        let service = this.registered.get(id);
        if (service)
            return Promise.resolve(service.stop());
    }
    async toggle(id) {
        let service = this.registered.get(id);
        if (!service)
            throw new Error(`Service ${id} not found`);
        let { state } = service;
        if (state == ServiceStat.Running) {
            await Promise.resolve(service.stop());
        }
        else if (state == ServiceStat.Initial || state == ServiceStat.StartFailed) {
            await service.start();
        }
        else if (state == ServiceStat.Stopped) {
            await service.restart();
        }
    }
    getServiceStats() {
        let res = [];
        for (let [id, service] of this.registered) {
            res.push({
                id,
                languageIds: documentSelectorToLanguageIds(service.selector),
                state: getStateName(service.state)
            });
        }
        return res;
    }
    registerClientsByConfig(lspConfig, folder) {
        for (let key of Object.keys((0, object_1.toObject)(lspConfig))) {
            let config = lspConfig[key];
            if (!isValidServerConfig(key, config)) {
                continue;
            }
            this.registerLanguageClient(key, config, folder);
        }
    }
    async getLanguageClient(id) {
        let service = this.getService(id);
        // wait for extension activate
        if (!service)
            await (0, util_1.wait)(100);
        service = this.getService(id);
        if (!service || !service.client) {
            throw new Error(`Language server ${id} not found`);
        }
        return service.client;
    }
    async sendNotification(id, method, params) {
        let client = await this.getLanguageClient(id);
        await Promise.resolve(client.sendNotification(method, params));
    }
    async sendRequest(id, method, params, token) {
        let client = await this.getLanguageClient(id);
        token = token !== null && token !== void 0 ? token : protocol_1.CancellationToken.None;
        return await Promise.resolve(client.sendRequest(method, params, token));
    }
    registerNotification(id, method) {
        var _a;
        let service = this.getService(id);
        if (service && service.client) {
            service.client.onNotification(method, async (result) => {
                this.sendNotificationVim(id, method, result);
            });
        }
        let arr = (_a = this.pendingNotifications.get(id)) !== null && _a !== void 0 ? _a : [];
        arr.push({ id, method });
        this.pendingNotifications.set(id, arr);
    }
    getRegisteredNotifications(id) {
        var _a;
        id = id.startsWith('languageserver') ? id.slice('languageserver.'.length) : id;
        return (_a = this.pendingNotifications.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    sendNotificationVim(id, method, result) {
        workspace_1.default.nvim.call('coc#do_notify', [id, method, result], true);
    }
    registerLanguageClient(name, config, folder) {
        let id = typeof name === 'string' ? `languageserver.${name}` : name.id;
        let disposables = [];
        let onDidServiceReady = new protocol_1.Emitter();
        let client = typeof name === 'string' ? null : name;
        if (this.registered.has(id))
            return protocol_1.Disposable.create(() => { });
        if (client && typeof client.dispose === 'function')
            disposables.push(client);
        let created = false;
        let service = {
            id,
            client,
            name: typeof name === 'string' ? name : name.name,
            selector: typeof name === 'string' ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name.clientOptions.documentSelector,
            state: client && client.state === language_client_1.State.Running ? ServiceStat.Running : ServiceStat.Initial,
            onServiceReady: onDidServiceReady.event,
            start: async () => {
                if (!created) {
                    if (typeof name == 'string' && !client) {
                        let config = workspace_1.default.getConfiguration(undefined, folder).get(`languageserver.${name}`, {});
                        let opts = getLanguageServerOptions(id, name, config, folder);
                        if (!opts || config.enable === false)
                            return;
                        client = new language_client_1.LanguageClient(id, name, opts[1], opts[0]);
                        service.selector = opts[0].documentSelector;
                        service.client = client;
                        disposables.push(client);
                    }
                    created = true;
                    for (let item of this.getRegisteredNotifications(id)) {
                        service.client.onNotification(item.method, async (result) => {
                            this.sendNotificationVim(item.id, item.method, result);
                        });
                    }
                    client.onDidChangeState(changeEvent => {
                        let { oldState, newState } = changeEvent;
                        service.state = convertState(newState);
                        let oldStr = stateString(oldState);
                        let newStr = stateString(newState);
                        logger.info(`LanguageClient ${client.name} state change: ${oldStr} => ${newStr}`);
                    }, null, disposables);
                }
                try {
                    if (!client.needsStart()) {
                        service.state = convertState(client.state);
                    }
                    else {
                        service.state = ServiceStat.Starting;
                        logger.debug(`starting service: ${id}`);
                        await client.start();
                        onDidServiceReady.fire(void 0);
                    }
                }
                catch (e) {
                    void window_1.default.showErrorMessage(`Server ${id} failed to start: ${e}`);
                    logger.error(`Server ${id} failed to start:`, e);
                    service.state = ServiceStat.StartFailed;
                }
            },
            dispose: async () => {
                onDidServiceReady.dispose();
                (0, util_1.disposeAll)(disposables);
            },
            stop: async () => {
                if (!client || !client.needsStop())
                    return;
                await Promise.resolve(client.stop());
            },
            restart: async () => {
                if (client) {
                    service.state = ServiceStat.Starting;
                    await client.restart();
                }
                else {
                    await service.start();
                }
            },
        };
        return this.register(service);
    }
    dispose() {
        (0, util_1.disposeAll)(this.disposables);
        for (let service of this.registered.values()) {
            service.dispose();
        }
        this.registered.clear();
    }
}
function documentSelectorToLanguageIds(documentSelector) {
    let res = documentSelector.map(filter => {
        if (typeof filter == 'string') {
            return filter;
        }
        return filter.language;
    });
    res = res.filter(s => typeof s == 'string');
    return Array.from(new Set(res));
}
exports.documentSelectorToLanguageIds = documentSelectorToLanguageIds;
// convert config to options
function getLanguageServerOptions(id, name, config, folder) {
    var _a, _b, _c;
    let { command, module, port, args, filetypes } = config;
    args = args || [];
    if (!filetypes) {
        void window_1.default.showErrorMessage(`Wrong configuration of LS "${name}", filetypes not found`);
        return null;
    }
    if (!command && !module && !port) {
        void window_1.default.showErrorMessage(`Wrong configuration of LS "${name}", no command or module specified.`);
        return null;
    }
    let serverOptions;
    if (module) {
        module = workspace_1.default.expand(module);
        if (!node_1.fs.existsSync(module)) {
            void window_1.default.showErrorMessage(`Module file "${module}" not found for LS "${name}"`);
            return null;
        }
        serverOptions = {
            module,
            runtime: (_a = config.runtime) !== null && _a !== void 0 ? _a : process.execPath,
            args,
            transport: getTransportKind(config),
            options: getForkOptions(config)
        };
    }
    else if (command) {
        serverOptions = {
            command,
            args,
            options: getSpawnOptions(config)
        };
    }
    else {
        serverOptions = () => new Promise((resolve, reject) => {
            var _a;
            let client = new node_1.net.Socket();
            let host = (_a = config.host) !== null && _a !== void 0 ? _a : '127.0.0.1';
            logger.info(`languageserver "${id}" connecting to ${host}:${port}`);
            client.connect(port, host, () => {
                resolve({
                    reader: client,
                    writer: client
                });
            });
            client.on('error', e => {
                reject(new Error(`Connection error for ${id}: ${e.message}`));
            });
        });
    }
    // compatible
    let disabledFeatures = Array.from(config.disabledFeatures || []);
    for (let key of ['disableWorkspaceFolders', 'disableCompletion', 'disableDiagnostics']) {
        if (config[key] === true) {
            logger.warn(`Language server config "${key}" is deprecated, use "disabledFeatures" instead.`);
            let s = key.slice(7);
            disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
        }
    }
    let disableSnippetCompletion = !!config.disableSnippetCompletion;
    let ignoredRootPaths = (_b = config.ignoredRootPaths) !== null && _b !== void 0 ? _b : [];
    let clientOptions = {
        workspaceFolder: folder == null ? undefined : { name: node_1.path.basename(folder.fsPath), uri: folder.toString() },
        rootPatterns: config.rootPatterns,
        requireRootPattern: config.requireRootPattern,
        ignoredRootPaths: ignoredRootPaths.map(s => workspace_1.default.expand(s)),
        disableSnippetCompletion,
        disableDynamicRegister: !!config.disableDynamicRegister,
        disabledFeatures,
        formatterPriority: config.formatterPriority,
        documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
        revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
        synchronize: {
            configurationSection: `${id}.settings`
        },
        diagnosticCollectionName: name,
        outputChannelName: id,
        stdioEncoding: config.stdioEncoding,
        progressOnInitialization: config.progressOnInitialization === true,
        initializationOptions: (_c = config.initializationOptions) !== null && _c !== void 0 ? _c : {}
    };
    return [clientOptions, serverOptions];
}
exports.getLanguageServerOptions = getLanguageServerOptions;
function isValidServerConfig(key, config) {
    let errors = [];
    let fields = ['module', 'command', 'transport'];
    for (let field of fields) {
        let val = config[field];
        if (val && typeof val !== 'string') {
            errors.push(`"${field}" field of languageserver ${key} should be string`);
        }
    }
    if (config.transportPort != null && typeof config.transportPort !== 'number') {
        errors.push(`"transportPort" field of languageserver ${key} should be number`);
    }
    if (!Array.isArray(config.filetypes) || !config.filetypes.every(s => typeof s === 'string')) {
        errors.push(`"filetypes" field of languageserver ${key} should be array of string`);
    }
    if (config.additionalSchemes && (!Array.isArray(config.additionalSchemes) || config.additionalSchemes.some(s => typeof s !== 'string'))) {
        errors.push(`"additionalSchemes" field of languageserver ${key} should be array of string`);
    }
    if (errors.length) {
        logger.error(`Invalid language server configuration for ${key}`, errors.join('\n'));
        return false;
    }
    return true;
}
exports.isValidServerConfig = isValidServerConfig;
function getRevealOutputChannelOn(revealOn) {
    switch (revealOn) {
        case 'info':
            return language_client_1.RevealOutputChannelOn.Info;
        case 'warn':
            return language_client_1.RevealOutputChannelOn.Warn;
        case 'error':
            return language_client_1.RevealOutputChannelOn.Error;
        case 'never':
            return language_client_1.RevealOutputChannelOn.Never;
        default:
            return language_client_1.RevealOutputChannelOn.Never;
    }
}
exports.getRevealOutputChannelOn = getRevealOutputChannelOn;
function getDocumentSelector(filetypes, additionalSchemes) {
    let documentSelector = [];
    let schemes = ['file', 'untitled'].concat(additionalSchemes || []);
    if (!filetypes)
        return schemes.map(s => ({ scheme: s }));
    filetypes.forEach(filetype => {
        documentSelector.push(...schemes.map(scheme => ({ language: filetype, scheme })));
    });
    return documentSelector;
}
exports.getDocumentSelector = getDocumentSelector;
function getTransportKind(config) {
    let { transport, transportPort } = config;
    if (!transport || transport == 'ipc')
        return language_client_1.TransportKind.ipc;
    if (transport == 'stdio')
        return language_client_1.TransportKind.stdio;
    if (transport == 'pipe')
        return language_client_1.TransportKind.pipe;
    return { kind: language_client_1.TransportKind.socket, port: transportPort };
}
exports.getTransportKind = getTransportKind;
function getForkOptions(config) {
    var _a, _b;
    return {
        cwd: config.cwd,
        execArgv: (_a = config.execArgv) !== null && _a !== void 0 ? _a : [],
        env: (_b = config.env) !== null && _b !== void 0 ? _b : undefined
    };
}
exports.getForkOptions = getForkOptions;
function getSpawnOptions(config) {
    var _a;
    return {
        cwd: config.cwd,
        detached: !!config.detached,
        shell: !!config.shell,
        env: (_a = config.env) !== null && _a !== void 0 ? _a : undefined
    };
}
exports.getSpawnOptions = getSpawnOptions;
function convertState(state) {
    switch (state) {
        case language_client_1.State.Running:
            return ServiceStat.Running;
        case language_client_1.State.Starting:
            return ServiceStat.Starting;
        case language_client_1.State.Stopped:
            return ServiceStat.Stopped;
        default:
            return undefined;
    }
}
exports.convertState = convertState;
function stateString(state) {
    switch (state) {
        case language_client_1.State.Running:
            return 'running';
        case language_client_1.State.Starting:
            return 'starting';
        case language_client_1.State.Stopped:
            return 'stopped';
        default:
            return 'unknown';
    }
}
exports.stateString = stateString;
function getStateName(state) {
    switch (state) {
        case ServiceStat.Initial:
            return 'init';
        case ServiceStat.Running:
            return 'running';
        case ServiceStat.Starting:
            return 'starting';
        case ServiceStat.StartFailed:
            return 'startFailed';
        case ServiceStat.Stopping:
            return 'stopping';
        case ServiceStat.Stopped:
            return 'stopped';
        default:
            return 'unknown';
    }
}
exports.getStateName = getStateName;
exports.default = new ServiceManager();
//# sourceMappingURL=services.js.map