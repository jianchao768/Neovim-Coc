'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const ui_1 = require("../core/ui");
const manager_1 = tslib_1.__importDefault(require("../snippets/manager"));
const string_1 = require("../util/string");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const source_1 = tslib_1.__importDefault(require("./source"));
const Is = tslib_1.__importStar(require("../util/is"));
class VimSource extends source_1.default {
    async callOptionalFunc(fname, args) {
        let exists = this.optionalFns.includes(fname);
        if (!exists)
            return null;
        let name = `coc#source#${this.name}#${fname}`;
        return await this.nvim.call(name, args);
    }
    async checkComplete(opt) {
        let shouldRun = await super.checkComplete(opt);
        if (!shouldRun)
            return false;
        if (!this.optionalFns.includes('should_complete'))
            return true;
        let res = await this.callOptionalFunc('should_complete', [opt]);
        return !!res;
    }
    async refresh() {
        await this.callOptionalFunc('refresh', []);
    }
    async insertSnippet(insertText, opt) {
        let pos = await (0, ui_1.getLineAndPosition)(this.nvim);
        let { line, col } = opt;
        let oldIndent = line.match(/^\s*/)[0];
        let newIndent = pos.text.match(/^\s*/)[0];
        // current insert range
        let range = vscode_languageserver_types_1.Range.create(pos.line, (0, string_1.characterIndex)(line, col) + newIndent.length - oldIndent.length, pos.line, pos.character);
        await manager_1.default.insertSnippet(insertText, true, range);
    }
    async onCompleteDone(item, opt) {
        if (this.optionalFns.includes('on_complete')) {
            await this.callOptionalFunc('on_complete', [item]);
        }
        else if (item.isSnippet && item.insertText) {
            await this.insertSnippet(item.insertText, opt);
        }
    }
    onEnter(bufnr) {
        if (!this.optionalFns.includes('on_enter'))
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc)
            return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype))
            return;
        void this.callOptionalFunc('on_enter', [{
                bufnr,
                uri: doc.uri,
                languageId: doc.filetype
            }]);
    }
    async doComplete(opt, token) {
        let shouldRun = await this.checkComplete(opt);
        if (!shouldRun)
            return null;
        let startcol = await this.callOptionalFunc('get_startcol', [opt]);
        if (token.isCancellationRequested)
            return null;
        let { col, input, line, colnr } = opt;
        if (Is.number(startcol) && startcol >= 0 && startcol !== col) {
            input = (0, string_1.byteSlice)(line, startcol, colnr - 1);
            opt = Object.assign({}, opt, {
                col: startcol,
                changed: col - startcol,
                input
            });
        }
        let vimItems = await this.nvim.callAsync('coc#util#do_complete', [this.name, opt]);
        if (!vimItems || vimItems.length == 0 || token.isCancellationRequested)
            return null;
        let checkFirst = this.firstMatch && input.length > 0;
        let inputFirst = checkFirst ? input[0].toLowerCase() : '';
        let items = [];
        vimItems.forEach(item => {
            var _a;
            let obj = Is.string(item) ? { word: item } : item;
            if (checkFirst) {
                let ch = ((_a = obj.filterText) !== null && _a !== void 0 ? _a : obj.word)[0];
                if (inputFirst && ch.toLowerCase() !== inputFirst)
                    return;
            }
            if (this.isSnippet)
                obj.isSnippet = true;
            items.push(obj);
        });
        return { items, startcol: Is.number(startcol) ? startcol : undefined };
    }
}
exports.default = VimSource;
//# sourceMappingURL=source-vim.js.map