'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderName = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const manager_1 = tslib_1.__importDefault(require("./diagnostic/manager"));
const callHierarchyManager_1 = tslib_1.__importDefault(require("./provider/callHierarchyManager"));
const codeActionManager_1 = tslib_1.__importDefault(require("./provider/codeActionManager"));
const codeLensManager_1 = tslib_1.__importDefault(require("./provider/codeLensManager"));
const declarationManager_1 = tslib_1.__importDefault(require("./provider/declarationManager"));
const definitionManager_1 = tslib_1.__importDefault(require("./provider/definitionManager"));
const documentColorManager_1 = tslib_1.__importDefault(require("./provider/documentColorManager"));
const documentHighlightManager_1 = tslib_1.__importDefault(require("./provider/documentHighlightManager"));
const documentLinkManager_1 = tslib_1.__importDefault(require("./provider/documentLinkManager"));
const documentSymbolManager_1 = tslib_1.__importDefault(require("./provider/documentSymbolManager"));
const foldingRangeManager_1 = tslib_1.__importDefault(require("./provider/foldingRangeManager"));
const formatManager_1 = tslib_1.__importDefault(require("./provider/formatManager"));
const formatRangeManager_1 = tslib_1.__importDefault(require("./provider/formatRangeManager"));
const hoverManager_1 = tslib_1.__importDefault(require("./provider/hoverManager"));
const implementationManager_1 = tslib_1.__importDefault(require("./provider/implementationManager"));
const inlayHintManager_1 = tslib_1.__importDefault(require("./provider/inlayHintManager"));
const inlineValueManager_1 = tslib_1.__importDefault(require("./provider/inlineValueManager"));
const linkedEditingRangeManager_1 = tslib_1.__importDefault(require("./provider/linkedEditingRangeManager"));
const onTypeFormatManager_1 = tslib_1.__importDefault(require("./provider/onTypeFormatManager"));
const referenceManager_1 = tslib_1.__importDefault(require("./provider/referenceManager"));
const renameManager_1 = tslib_1.__importDefault(require("./provider/renameManager"));
const selectionRangeManager_1 = tslib_1.__importDefault(require("./provider/selectionRangeManager"));
const semanticTokensManager_1 = tslib_1.__importDefault(require("./provider/semanticTokensManager"));
const semanticTokensRangeManager_1 = tslib_1.__importDefault(require("./provider/semanticTokensRangeManager"));
const signatureManager_1 = tslib_1.__importDefault(require("./provider/signatureManager"));
const typeDefinitionManager_1 = tslib_1.__importDefault(require("./provider/typeDefinitionManager"));
const typeHierarchyManager_1 = tslib_1.__importDefault(require("./provider/typeHierarchyManager"));
const workspaceSymbolsManager_1 = tslib_1.__importDefault(require("./provider/workspaceSymbolsManager"));
const util_1 = require("./util");
const Is = tslib_1.__importStar(require("./util/is"));
const protocol_1 = require("./util/protocol");
const string_1 = require("./util/string");
const eventDebounce = (0, util_1.getConditionValue)(500, 10);
var ProviderName;
(function (ProviderName) {
    ProviderName["FormatOnType"] = "formatOnType";
    ProviderName["Rename"] = "rename";
    ProviderName["OnTypeEdit"] = "onTypeEdit";
    ProviderName["DocumentLink"] = "documentLink";
    ProviderName["DocumentColor"] = "documentColor";
    ProviderName["FoldingRange"] = "foldingRange";
    ProviderName["Format"] = "format";
    ProviderName["CodeAction"] = "codeAction";
    ProviderName["FormatRange"] = "formatRange";
    ProviderName["Hover"] = "hover";
    ProviderName["Signature"] = "signature";
    ProviderName["WorkspaceSymbols"] = "workspaceSymbols";
    ProviderName["DocumentSymbol"] = "documentSymbol";
    ProviderName["DocumentHighlight"] = "documentHighlight";
    ProviderName["Definition"] = "definition";
    ProviderName["Declaration"] = "declaration";
    ProviderName["TypeDefinition"] = "typeDefinition";
    ProviderName["Reference"] = "reference";
    ProviderName["Implementation"] = "implementation";
    ProviderName["CodeLens"] = "codeLens";
    ProviderName["SelectionRange"] = "selectionRange";
    ProviderName["CallHierarchy"] = "callHierarchy";
    ProviderName["SemanticTokens"] = "semanticTokens";
    ProviderName["SemanticTokensRange"] = "semanticTokensRange";
    ProviderName["LinkedEditing"] = "linkedEditing";
    ProviderName["InlayHint"] = "inlayHint";
    ProviderName["InlineValue"] = "inlineValue";
    ProviderName["TypeHierarchy"] = "typeHierarchy";
})(ProviderName = exports.ProviderName || (exports.ProviderName = {}));
class Languages {
    constructor() {
        this._onDidSemanticTokensRefresh = new protocol_1.Emitter();
        this._onDidInlayHintRefresh = new protocol_1.Emitter();
        this._onDidCodeLensRefresh = new protocol_1.Emitter();
        this._onDidColorsRefresh = new protocol_1.Emitter();
        this._onDidLinksRefresh = new protocol_1.Emitter();
        this.onDidSemanticTokensRefresh = this._onDidSemanticTokensRefresh.event;
        this.onDidInlayHintRefresh = this._onDidInlayHintRefresh.event;
        this.onDidCodeLensRefresh = this._onDidCodeLensRefresh.event;
        this.onDidColorsRefresh = this._onDidColorsRefresh.event;
        this.onDidLinksRefresh = this._onDidLinksRefresh.event;
        this.onTypeFormatManager = new onTypeFormatManager_1.default();
        this.documentLinkManager = new documentLinkManager_1.default();
        this.documentColorManager = new documentColorManager_1.default();
        this.foldingRangeManager = new foldingRangeManager_1.default();
        this.renameManager = new renameManager_1.default();
        this.formatManager = new formatManager_1.default();
        this.codeActionManager = new codeActionManager_1.default();
        this.workspaceSymbolsManager = new workspaceSymbolsManager_1.default();
        this.formatRangeManager = new formatRangeManager_1.default();
        this.hoverManager = new hoverManager_1.default();
        this.signatureManager = new signatureManager_1.default();
        this.documentSymbolManager = new documentSymbolManager_1.default();
        this.documentHighlightManager = new documentHighlightManager_1.default();
        this.definitionManager = new definitionManager_1.default();
        this.declarationManager = new declarationManager_1.default();
        this.typeDefinitionManager = new typeDefinitionManager_1.default();
        this.typeHierarchyManager = new typeHierarchyManager_1.default();
        this.referenceManager = new referenceManager_1.default();
        this.implementationManager = new implementationManager_1.default();
        this.codeLensManager = new codeLensManager_1.default();
        this.selectionRangeManager = new selectionRangeManager_1.default();
        this.callHierarchyManager = new callHierarchyManager_1.default();
        this.semanticTokensManager = new semanticTokensManager_1.default();
        this.semanticTokensRangeManager = new semanticTokensRangeManager_1.default();
        this.linkedEditingManager = new linkedEditingRangeManager_1.default();
        this.inlayHintManager = new inlayHintManager_1.default();
        this.inlineValueManager = new inlineValueManager_1.default();
        this.registerReferenceProvider = this.registerReferencesProvider;
    }
    hasFormatProvider(doc) {
        if (this.formatManager.hasProvider(doc)) {
            return true;
        }
        if (this.formatRangeManager.hasProvider(doc)) {
            return true;
        }
        return false;
    }
    registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
    }
    registerCompletionItemProvider(name, shortcut, selector, provider, triggerCharacters = [], priority, allCommitCharacters) {
        selector = Is.string(selector) ? [{ language: selector }] : selector;
        let sources = require('./completion/sources').default;
        sources.removeSource(name);
        return sources.createLanguageSource(name, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters);
    }
    registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
    }
    registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
    }
    registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
    }
    registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
    }
    registerDocumentSymbolProvider(selector, provider, metadata) {
        if (metadata)
            provider.meta = metadata;
        return this.documentSymbolManager.register(selector, provider);
    }
    registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
    }
    registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
    }
    registerDocumentLinkProvider(selector, provider) {
        this._onDidLinksRefresh.fire(selector);
        let disposable = this.documentLinkManager.register(selector, provider);
        return protocol_1.Disposable.create(() => {
            disposable.dispose();
            this._onDidLinksRefresh.fire(selector);
        });
    }
    registerDocumentColorProvider(selector, provider) {
        this._onDidColorsRefresh.fire(selector);
        let disposable = this.documentColorManager.register(selector, provider);
        return protocol_1.Disposable.create(() => {
            disposable.dispose();
            this._onDidColorsRefresh.fire(selector);
        });
    }
    registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
    }
    registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
    }
    registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
    }
    registerTypeHierarchyProvider(selector, provider) {
        return this.typeHierarchyManager.register(selector, provider);
    }
    registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
    }
    registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
    }
    registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
    }
    registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && Is.func(arguments[1].provideWorkspaceSymbols)) {
            provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
    }
    registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
    }
    registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
    }
    registerCallHierarchyProvider(selector, provider) {
        return this.callHierarchyManager.register(selector, provider);
    }
    registerCodeLensProvider(selector, provider) {
        return this.registerProviderWithEvent(selector, provider, 'onDidChangeCodeLenses', this.codeLensManager, this._onDidCodeLensRefresh);
    }
    registerDocumentSemanticTokensProvider(selector, provider, legend) {
        return this.registerProviderWithEvent(selector, provider, 'onDidChangeSemanticTokens', this.semanticTokensManager, this._onDidSemanticTokensRefresh, legend);
    }
    registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        let timer = setTimeout(() => {
            this._onDidSemanticTokensRefresh.fire(selector);
        }, eventDebounce);
        let disposable = this.semanticTokensRangeManager.register(selector, provider, legend);
        return protocol_1.Disposable.create(() => {
            clearTimeout(timer);
            disposable.dispose();
            this._onDidSemanticTokensRefresh.fire(selector);
        });
    }
    registerInlayHintsProvider(selector, provider) {
        return this.registerProviderWithEvent(selector, provider, 'onDidChangeInlayHints', this.inlayHintManager, this._onDidInlayHintRefresh);
    }
    registerInlineValuesProvider(selector, provider) {
        // TODO onDidChangeInlineValues
        return this.inlineValueManager.register(selector, provider);
    }
    registerLinkedEditingRangeProvider(selector, provider) {
        return this.linkedEditingManager.register(selector, provider);
    }
    shouldTriggerSignatureHelp(document, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document, triggerCharacter);
    }
    async getHover(document, position, token) {
        return await this.hoverManager.provideHover(document, position, token);
    }
    async getSignatureHelp(document, position, token, context) {
        return await this.signatureManager.provideSignatureHelp(document, position, token, context);
    }
    async getDefinition(document, position, token) {
        return await this.definitionManager.provideDefinition(document, position, token);
    }
    async getDefinitionLinks(document, position, token) {
        return await this.definitionManager.provideDefinitionLinks(document, position, token);
    }
    async getDeclaration(document, position, token) {
        return await this.declarationManager.provideDeclaration(document, position, token);
    }
    async getTypeDefinition(document, position, token) {
        return await this.typeDefinitionManager.provideTypeDefinition(document, position, token);
    }
    async getImplementation(document, position, token) {
        return await this.implementationManager.provideImplementations(document, position, token);
    }
    async getReferences(document, context, position, token) {
        return await this.referenceManager.provideReferences(document, position, context, token);
    }
    async getDocumentSymbol(document, token) {
        return await this.documentSymbolManager.provideDocumentSymbols(document, token);
    }
    getDocumentSymbolMetadata(document) {
        return this.documentSymbolManager.getMetaData(document);
    }
    async getSelectionRanges(document, positions, token) {
        return await this.selectionRangeManager.provideSelectionRanges(document, positions, token);
    }
    async getWorkspaceSymbols(query, token) {
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols((0, string_1.toText)(query), token);
    }
    async resolveWorkspaceSymbol(symbol, token) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
    }
    async prepareRename(document, position, token) {
        return await this.renameManager.prepareRename(document, position, token);
    }
    async provideRenameEdits(document, position, newName, token) {
        return await this.renameManager.provideRenameEdits(document, position, newName, token);
    }
    async provideDocumentFormattingEdits(document, options, token) {
        let res = await this.formatManager.provideDocumentFormattingEdits(document, options, token);
        if (res == null) {
            let hasRangeFormatter = this.formatRangeManager.hasProvider(document);
            if (!hasRangeFormatter)
                return null;
            let end = document.positionAt(document.getText().length);
            let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), end);
            return await this.provideDocumentRangeFormattingEdits(document, range, options, token);
        }
        return res;
    }
    async provideDocumentRangeFormattingEdits(document, range, options, token) {
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document, range, options, token);
    }
    async getCodeActions(document, range, context, token) {
        return await this.codeActionManager.provideCodeActions(document, range, context, token);
    }
    async getDocumentHighLight(document, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document, position, token);
    }
    async getDocumentLinks(document, token) {
        return await this.documentLinkManager.provideDocumentLinks(document, token);
    }
    async resolveDocumentLink(link, token) {
        return await this.documentLinkManager.resolveDocumentLink(link, token);
    }
    async provideDocumentColors(document, token) {
        return await this.documentColorManager.provideDocumentColors(document, token);
    }
    async provideFoldingRanges(document, context, token) {
        return await this.foldingRangeManager.provideFoldingRanges(document, context, token);
    }
    async provideColorPresentations(color, document, token) {
        return await this.documentColorManager.provideColorPresentations(color, document, token);
    }
    async getCodeLens(document, token) {
        return await this.codeLensManager.provideCodeLenses(document, token);
    }
    async resolveCodeLens(codeLens, token) {
        return await this.codeLensManager.resolveCodeLens(codeLens, token);
    }
    async resolveCodeAction(codeAction, token) {
        return await this.codeActionManager.resolveCodeAction(codeAction, token);
    }
    async provideDocumentOnTypeEdits(character, document, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document, position, token);
    }
    canFormatOnType(character, document) {
        return this.onTypeFormatManager.couldTrigger(document, character) != null;
    }
    async prepareCallHierarchy(document, position, token) {
        return this.callHierarchyManager.prepareCallHierarchy(document, position, token);
    }
    async provideIncomingCalls(document, item, token) {
        return this.callHierarchyManager.provideCallHierarchyIncomingCalls(document, item, token);
    }
    async provideOutgoingCalls(document, item, token) {
        return this.callHierarchyManager.provideCallHierarchyOutgoingCalls(document, item, token);
    }
    getLegend(document, range) {
        if (range)
            return this.semanticTokensRangeManager.getLegend(document);
        return this.semanticTokensManager.getLegend(document);
    }
    hasSemanticTokensEdits(document) {
        return this.semanticTokensManager.hasSemanticTokensEdits(document);
    }
    async provideDocumentSemanticTokens(document, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokens(document, token);
    }
    async provideDocumentSemanticTokensEdits(document, previousResultId, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokensEdits(document, previousResultId, token);
    }
    async provideDocumentRangeSemanticTokens(document, range, token) {
        return this.semanticTokensRangeManager.provideDocumentRangeSemanticTokens(document, range, token);
    }
    async provideInlayHints(document, range, token) {
        return this.inlayHintManager.provideInlayHints(document, range, token);
    }
    async resolveInlayHint(hint, token) {
        return this.inlayHintManager.resolveInlayHint(hint, token);
    }
    async provideLinkedEdits(document, position, token) {
        return this.linkedEditingManager.provideLinkedEditingRanges(document, position, token);
    }
    async provideInlineValues(document, viewPort, context, token) {
        return this.inlineValueManager.provideInlineValues(document, viewPort, context, token);
    }
    async prepareTypeHierarchy(document, position, token) {
        return this.typeHierarchyManager.prepareTypeHierarchy(document, position, token);
    }
    async provideTypeHierarchySupertypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySupertypes(item, token);
    }
    async provideTypeHierarchySubtypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySubtypes(item, token);
    }
    createDiagnosticCollection(owner) {
        return manager_1.default.create(owner);
    }
    registerProviderWithEvent(selector, provider, key, manager, emitter, extra) {
        let disposables = [];
        // Wait the server finish initialize
        let timer = setTimeout(() => {
            emitter.fire(selector);
        }, eventDebounce);
        disposables.push(protocol_1.Disposable.create(() => {
            clearTimeout(timer);
        }));
        Is.func(provider[key]) && disposables.push(provider[key](() => {
            clearTimeout(timer);
            emitter.fire(selector);
        }));
        disposables.push(manager.register(selector, provider, extra));
        return protocol_1.Disposable.create(() => {
            (0, util_1.disposeAll)(disposables);
            emitter.fire(selector);
        });
    }
    hasProvider(id, document) {
        switch (id) {
            case ProviderName.OnTypeEdit:
            case ProviderName.FormatOnType:
                return this.onTypeFormatManager.hasProvider(document);
            case ProviderName.Rename:
                return this.renameManager.hasProvider(document);
            case ProviderName.DocumentLink:
                return this.documentLinkManager.hasProvider(document);
            case ProviderName.DocumentColor:
                return this.documentColorManager.hasProvider(document);
            case ProviderName.FoldingRange:
                return this.foldingRangeManager.hasProvider(document);
            case ProviderName.Format:
                return this.formatManager.hasProvider(document) || this.formatRangeManager.hasProvider(document);
            case ProviderName.CodeAction:
                return this.codeActionManager.hasProvider(document);
            case ProviderName.WorkspaceSymbols:
                return this.workspaceSymbolsManager.hasProvider();
            case ProviderName.FormatRange:
                return this.formatRangeManager.hasProvider(document);
            case ProviderName.Hover:
                return this.hoverManager.hasProvider(document);
            case ProviderName.Signature:
                return this.signatureManager.hasProvider(document);
            case ProviderName.DocumentSymbol:
                return this.documentSymbolManager.hasProvider(document);
            case ProviderName.DocumentHighlight:
                return this.documentHighlightManager.hasProvider(document);
            case ProviderName.Definition:
                return this.definitionManager.hasProvider(document);
            case ProviderName.Declaration:
                return this.declarationManager.hasProvider(document);
            case ProviderName.TypeDefinition:
                return this.typeDefinitionManager.hasProvider(document);
            case ProviderName.Reference:
                return this.referenceManager.hasProvider(document);
            case ProviderName.Implementation:
                return this.implementationManager.hasProvider(document);
            case ProviderName.CodeLens:
                return this.codeLensManager.hasProvider(document);
            case ProviderName.SelectionRange:
                return this.selectionRangeManager.hasProvider(document);
            case ProviderName.CallHierarchy:
                return this.callHierarchyManager.hasProvider(document);
            case ProviderName.SemanticTokens:
                return this.semanticTokensManager.hasProvider(document);
            case ProviderName.SemanticTokensRange:
                return this.semanticTokensRangeManager.hasProvider(document);
            case ProviderName.LinkedEditing:
                return this.linkedEditingManager.hasProvider(document);
            case ProviderName.InlayHint:
                return this.inlayHintManager.hasProvider(document);
            case ProviderName.InlineValue:
                return this.inlineValueManager.hasProvider(document);
            case ProviderName.TypeHierarchy:
                return this.typeHierarchyManager.hasProvider(document);
            default:
                return false;
        }
    }
}
exports.default = new Languages();
//# sourceMappingURL=languages.js.map