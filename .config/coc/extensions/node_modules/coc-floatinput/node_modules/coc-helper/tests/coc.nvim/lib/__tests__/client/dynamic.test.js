"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const lsclient = tslib_1.__importStar(require("../../language-client"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const vscode_uri_1 = require("vscode-uri");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
beforeAll(async () => {
    await helper_1.default.setup();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
});
describe('DynamicFeature', () => {
    let textDocument = vscode_languageserver_textdocument_1.TextDocument.create('file:///1', 'vim', 1, '\n');
    let position = vscode_languageserver_protocol_1.Position.create(1, 1);
    let token = vscode_languageserver_protocol_1.CancellationToken.None;
    async function startServer(opts = {}, middleware = {}) {
        let clientOptions = {
            documentSelector: [{ language: '*' }],
            initializationOptions: opts,
            synchronize: {
                configurationSection: 'languageserver.vim.settings'
            },
            middleware
        };
        let serverModule = path_1.default.join(__dirname, './server/dynamicServer.js');
        let serverOptions = {
            module: serverModule,
            transport: lsclient.TransportKind.ipc
        };
        let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions);
        await client.start();
        return client;
    }
    describe('RenameFeature', () => {
        it('should start server', async () => {
            let client = await startServer({ prepareRename: false });
            let feature = client.getFeature(vscode_languageserver_protocol_1.RenameRequest.method);
            let provider = feature.getProvider(textDocument);
            expect(provider.prepareRename).toBeUndefined();
            feature.unregister('');
            await client.stop();
        });
        it('should handle different result', async () => {
            let client = await startServer({ prepareRename: true }, {
                provideRenameEdits: (doc, pos, newName, token, next) => {
                    return next(doc, pos, newName, token);
                },
                prepareRename: (doc, pos, token, next) => {
                    return next(doc, pos, token);
                }
            });
            let feature = client.getFeature(vscode_languageserver_protocol_1.RenameRequest.method);
            let provider = feature.getProvider(textDocument);
            expect(provider.prepareRename).toBeDefined();
            let res = await provider.prepareRename(textDocument, position, token);
            expect(res).toBeNull();
            await client.sendRequest('setPrepareResponse', { defaultBehavior: true });
            res = await provider.prepareRename(textDocument, position, token);
            expect(res).toBeNull();
            await client.sendRequest('setPrepareResponse', { range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3), placeholder: 'placeholder' });
            res = await provider.prepareRename(textDocument, position, token);
            expect(res.placeholder).toBe('placeholder');
            await expect(async () => {
                await client.sendRequest('setPrepareResponse', { defaultBehavior: false });
                res = await provider.prepareRename(textDocument, position, token);
            }).rejects.toThrow(Error);
            await client.stop();
        });
    });
    describe('WorkspaceSymbolFeature', () => {
        it('should use middleware', async () => {
            let client = await startServer({}, {
                provideWorkspaceSymbols: (query, token, next) => {
                    return next(query, token);
                },
                resolveWorkspaceSymbol: (item, token, next) => {
                    return next(item, token);
                }
            });
            let feature = client.getFeature(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.method);
            await helper_1.default.waitValue(() => {
                return feature.getProviders().length;
            }, 2);
            let provider = feature.getProviders().find(o => typeof o.resolveWorkspaceSymbol === 'function');
            expect(provider).toBeDefined();
            let token = vscode_languageserver_protocol_1.CancellationToken.None;
            let res = await provider.provideWorkspaceSymbols('', token);
            expect(res.length).toBe(0);
            let sym = vscode_languageserver_protocol_1.SymbolInformation.create('name', vscode_languageserver_protocol_1.SymbolKind.Array, vscode_languageserver_protocol_1.Range.create(0, 1, 0, 1), 'file:///1');
            let resolved = await provider.resolveWorkspaceSymbol(sym, token);
            expect(resolved.name).toBe(sym.name);
            await client.stop();
        });
    });
    describe('SemanticTokensFeature', () => {
        it('should register semanticTokens', async () => {
            let client = await startServer({});
            let feature = client.getFeature(vscode_languageserver_protocol_1.SemanticTokensRegistrationType.method);
            let provider;
            await helper_1.default.waitValue(() => {
                provider = feature.getProvider(textDocument);
                return provider != null;
            }, true);
            expect(provider.range).toBeUndefined();
            await client.stop();
        });
        it('should use middleware', async () => {
            let client = await startServer({ rangeTokens: true, delta: true }, {});
            let feature = client.getFeature(vscode_languageserver_protocol_1.SemanticTokensRegistrationType.method);
            await helper_1.default.waitValue(() => {
                return feature.getProvider(textDocument) != null;
            }, true);
            let provider = feature.getProvider(textDocument);
            expect(provider).toBeDefined();
            expect(provider.range).toBeDefined();
            let res = await provider.full.provideDocumentSemanticTokensEdits(textDocument, '2', vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res.resultId).toBe('3');
            await client.stop();
        });
    });
    describe('CodeActionFeature', () => {
        it('should use registered command', async () => {
            let client = await startServer({});
            let feature = client.getFeature(vscode_languageserver_protocol_1.CodeActionRequest.method);
            await helper_1.default.waitValue(() => {
                return feature.getProvider(textDocument) != null;
            }, true);
            let provider = feature.getProvider(textDocument);
            let actions = await provider.provideCodeActions(textDocument, vscode_languageserver_protocol_1.Range.create(0, 1, 0, 1), { diagnostics: [] }, token);
            expect(actions.length).toBe(1);
            await client.stop();
        });
    });
    describe('PullConfigurationFeature', () => {
        it('should pull configuration for configured languageserver', async () => {
            helper_1.default.updateConfiguration('languageserver.vim.settings.foo', 'bar');
            let client = await startServer({});
            await helper_1.default.wait(50);
            await client.sendNotification('pullConfiguration');
            await helper_1.default.wait(50);
            let res = await client.sendRequest('getConfiguration');
            expect(res).toEqual(['bar']);
            helper_1.default.updateConfiguration('suggest.noselect', true);
            await helper_1.default.wait(50);
            await client.stop();
        });
    });
    describe('CodeLensFeature', () => {
        it('should use codeLens middleware', async () => {
            let fn = jest.fn();
            let client = await startServer({}, {
                provideCodeLenses: (doc, token, next) => {
                    fn();
                    return next(doc, token);
                },
                resolveCodeLens: (codelens, token, next) => {
                    fn();
                    return next(codelens, token);
                }
            });
            let feature = client.getFeature(vscode_languageserver_protocol_1.CodeLensRequest.method);
            let provider = feature.getProvider(textDocument).provider;
            expect(provider).toBeDefined();
            let res = await provider.provideCodeLenses(textDocument, token);
            expect(res.length).toBe(2);
            let resolved = await provider.resolveCodeLens(res[0], token);
            expect(resolved.command).toBeDefined();
            expect(fn).toBeCalledTimes(2);
            await client.stop();
        });
    });
    describe('InlineValueFeature', () => {
        it('should fire refresh', async () => {
            let client = await startServer({});
            let feature = client.getFeature(vscode_languageserver_protocol_1.InlineValueRequest.method);
            expect(feature).toBeDefined();
            await helper_1.default.waitValue(() => {
                return feature.getProvider(textDocument) != null;
            }, true);
            let provider = feature.getProvider(textDocument);
            let called = false;
            provider.onDidChangeInlineValues.event(() => {
                called = true;
            });
            await client.sendNotification('fireInlineValueRefresh');
            await helper_1.default.waitValue(() => {
                return called;
            }, true);
            await client.stop();
        });
    });
    describe('ExecuteCommandFeature', () => {
        it('should register command with middleware', async () => {
            let called = false;
            let client = await startServer({}, {
                executeCommand: (cmd, args, next) => {
                    called = true;
                    return next(cmd, args);
                }
            });
            await helper_1.default.waitValue(() => {
                return commands_1.default.has('test_command');
            }, true);
            let feature = client.getFeature(vscode_languageserver_protocol_1.ExecuteCommandRequest.method);
            expect(feature).toBeDefined();
            expect(feature.getState().kind).toBe('workspace');
            let res = await commands_1.default.executeCommand('test_command');
            expect(res).toEqual({ success: true });
            expect(called).toBe(true);
            await client.sendNotification('unregister');
            await client.stop();
        });
        it('should register command without middleware', async () => {
            let client = await startServer({}, {});
            await helper_1.default.waitValue(() => {
                return commands_1.default.has('test_command');
            }, true);
            let res = await commands_1.default.executeCommand('test_command');
            expect(res).toEqual({ success: true });
            await client.stop();
        });
    });
    describe('DocumentSymbolFeature', () => {
        it('should provide documentSymbols without middleware', async () => {
            let client = await startServer({}, {});
            let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentSymbolRequest.method);
            expect(feature).toBeDefined();
            expect(feature.getState()).toBeDefined();
            let provider = feature.getProvider(textDocument);
            let res = await provider.provideDocumentSymbols(textDocument, token);
            expect(res).toEqual([]);
            await client.stop();
        });
        it('should provide documentSymbols with middleware', async () => {
            let called = false;
            let client = await startServer({ label: true }, {
                provideDocumentSymbols: (doc, token, next) => {
                    called = true;
                    return next(doc, token);
                }
            });
            let feature = client.getFeature(vscode_languageserver_protocol_1.DocumentSymbolRequest.method);
            let provider = feature.getProvider(textDocument);
            expect(provider.meta).toEqual({ label: 'test' });
            let res = await provider.provideDocumentSymbols(textDocument, token);
            expect(res).toEqual([]);
            expect(called).toBe(true);
            await client.stop();
        });
    });
    describe('FileOperationFeature', () => {
        it('should use middleware for FileOperationFeature', async () => {
            let n = 0;
            let client = await startServer({}, {
                workspace: {
                    didCreateFiles: (ev, next) => {
                        n++;
                        return next(ev);
                    },
                    didRenameFiles: (ev, next) => {
                        n++;
                        return next(ev);
                    },
                    didDeleteFiles: (ev, next) => {
                        n++;
                        return next(ev);
                    },
                    willRenameFiles: (ev, next) => {
                        n++;
                        return next(ev);
                    },
                    willDeleteFiles: (ev, next) => {
                        n++;
                        return next(ev);
                    }
                }
            });
            let createFeature = client.getFeature(vscode_languageserver_protocol_1.DidCreateFilesNotification.method);
            await createFeature.send({ files: [vscode_uri_1.URI.file('/a/b')] });
            let renameFeature = client.getFeature(vscode_languageserver_protocol_1.DidRenameFilesNotification.method);
            await renameFeature.send({ files: [{ oldUri: vscode_uri_1.URI.file('/a/b'), newUri: vscode_uri_1.URI.file('/c/d') }] });
            let deleteFeature = client.getFeature(vscode_languageserver_protocol_1.DidDeleteFilesNotification.method);
            await deleteFeature.send({ files: [vscode_uri_1.URI.file('/x/y')] });
            let willRename = client.getFeature(vscode_languageserver_protocol_1.WillRenameFilesRequest.method);
            await willRename.send({ files: [{ oldUri: vscode_uri_1.URI.file(__dirname), newUri: vscode_uri_1.URI.file(path_1.default.join(__dirname, 'x')) }], waitUntil: () => { } });
            let willDelete = client.getFeature(vscode_languageserver_protocol_1.WillDeleteFilesRequest.method);
            await willDelete.send({ files: [vscode_uri_1.URI.file('/x/y')], waitUntil: () => { } });
            await helper_1.default.waitValue(() => {
                return n;
            }, 5);
            await client.stop();
        });
    });
    describe('CompletionItemFeature', () => {
        it('should register multiple completion sources', async () => {
            let client = await startServer({}, {});
            let feature = client.getFeature(vscode_languageserver_protocol_1.CompletionRequest.method);
            await helper_1.default.waitValue(() => {
                return feature.registrationLength;
            }, 2);
            await client.stop();
        });
    });
    describe('WorkspaceFoldersFeature', () => {
        it('should register listeners', async () => {
            let client = await startServer({}, {});
            let feature = client.getFeature(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.method);
            expect(feature).toBeDefined();
            let state = feature.getState();
            expect(state.registrations).toBe(true);
            await client.stop();
        });
        it('should handle WorkspaceFoldersRequest', async () => {
            let client = await startServer({ changeNotifications: true }, {});
            let folders = workspace_1.default.workspaceFolders;
            expect(folders.length).toBe(0);
            await client.sendNotification('requestFolders');
            await helper_1.default.wait(30);
            let res = await client.sendRequest('getFolders');
            expect(res).toBeNull();
            await client.stop();
        });
        it('should use workspaceFolders middleware', async () => {
            await workspace_1.default.loadFile(__filename);
            let folders = workspace_1.default.workspaceFolders;
            expect(folders.length).toBe(1);
            let called = false;
            let client = await startServer({ changeNotifications: true }, {
                workspace: {
                    workspaceFolders: (token, next) => {
                        called = true;
                        return next(token);
                    }
                }
            });
            await client.sendNotification('requestFolders');
            await helper_1.default.waitValue(async () => {
                let res = await client.sendRequest('getFolders');
                return Array.isArray(res) && res.length == 1;
            }, true);
            expect(called).toBe(true);
            await client.stop();
        });
        it('should send folders event with middleware', async () => {
            let called = false;
            let client = await startServer({ changeNotifications: true }, {
                workspace: {
                    didChangeWorkspaceFolders: (ev, next) => {
                        called = true;
                        return next(ev);
                    }
                }
            });
            let folders = workspace_1.default.workspaceFolders;
            expect(folders.length).toBe(0);
            await workspace_1.default.loadFile(__filename);
            await helper_1.default.waitValue(() => {
                return called;
            }, true);
            await client.stop();
        });
    });
});
//# sourceMappingURL=dynamic.test.js.map