"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const configuration_1 = require("../../configuration");
const events_1 = tslib_1.__importDefault(require("../../events"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importStar(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let disposables = [];
let tmpFolder = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}`);
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    if (!fs_1.default.existsSync(tmpFolder))
        fs_1.default.mkdirSync(tmpFolder);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
    disposables = [];
});
describe('workspace properties', () => {
    it('should have initialized', async () => {
        let { nvim, uri, insertMode, workspaceFolder, cwd, documents, textDocuments } = workspace_1.default;
        expect(insertMode).toBe(false);
        expect(nvim).toBeTruthy();
        expect(documents.length).toBe(1);
        expect(textDocuments.length).toBe(1);
        expect(cwd).toBe(process.cwd());
        let floatSupported = workspace_1.default.floatSupported;
        expect(floatSupported).toBe(true);
        let { pluginRoot } = workspace_1.default;
        expect(typeof pluginRoot).toBe('string');
        let { isVim, isNvim } = workspace_1.default;
        expect(isVim).toBe(false);
        expect(isNvim).toBe(true);
        expect(uri).toBeDefined();
        expect(workspaceFolder).toBeUndefined();
        let watchmanPath = workspace_1.default.getWatchmanPath();
        expect(watchmanPath == null || typeof watchmanPath === 'string').toBe(true);
        let folder = workspace_1.default.getWorkspaceFolder(uri);
        expect(folder).toBeUndefined();
        let rootPath = await helper_1.default.doAction('currentWorkspacePath');
        expect(rootPath).toBe(process.cwd());
    });
    it('should get filetyps', async () => {
        await helper_1.default.edit('f.js');
        let filetypes = workspace_1.default.filetypes;
        expect(filetypes.has('javascript')).toBe(true);
        let languageIds = workspace_1.default.languageIds;
        expect(languageIds.has('javascript')).toBe(true);
    });
    it('should get display width', () => {
        expect(workspace_1.default.getDisplayWidth('a')).toBe(1);
    });
    it('should get channelNames', async () => {
        let names = workspace_1.default.channelNames;
        expect(Array.isArray(names)).toBe(true);
    });
    it('should work with deprecated method', async () => {
        await nvim.setLine('foo');
        await workspace_1.default['moveTo'](vscode_languageserver_types_1.Position.create(0, 1));
        let col = await nvim.call('col', ['.']);
        expect(col).toBe(2);
    });
});
describe('workspace methods', () => {
    it('should call vim method', async () => {
        let res = await workspace_1.default.callAsync('bufnr', ['%']);
        expect(typeof res).toBe('number');
        let obj = workspace_1.default.env;
        obj.isVim = true;
        disposables.push({
            dispose: () => {
                obj.isVim = false;
            }
        });
        res = await workspace_1.default.callAsync('bufnr', ['%']);
        expect(typeof res).toBe('number');
    });
    it('should get the document', async () => {
        let doc = await workspace_1.default.document;
        let buf = await nvim.buffer;
        expect(doc.buffer.equals(buf)).toBeTruthy();
        doc = workspace_1.default.getDocument(doc.uri);
        expect(doc.buffer.equals(buf)).toBeTruthy();
    });
    it('should get uri', async () => {
        let doc = await workspace_1.default.document;
        expect(workspace_1.default.getUri(doc.bufnr, undefined)).toBeDefined();
        expect(workspace_1.default.getUri(999, null)).toBeNull();
        expect(workspace_1.default.getUri(999)).toBe('');
    });
    it('should get attached document', async () => {
        let fn = () => {
            workspace_1.default.getAttachedDocument('file://not_exists');
        };
        expect(fn).toThrow(Error);
        await nvim.command(`edit +setl\\ buftype=nofile [tree]`);
        let doc = await workspace_1.default.document;
        expect(doc.attached).toBe(false);
        fn = () => {
            workspace_1.default.getAttachedDocument(doc.bufnr);
        };
        expect(fn).toThrow(Error);
    });
    it('should get format options of without bufnr', async () => {
        let opts = await workspace_1.default.getFormatOptions();
        expect(opts.insertSpaces).toBe(true);
        expect(opts.tabSize).toBe(2);
    });
    it('should get format options of current buffer', async () => {
        let buf = await nvim.buffer;
        await buf.setVar('coc_trim_trailing_whitespace', 1);
        await buf.setVar('coc_trim_final_newlines', 1);
        await buf.setOption('shiftwidth', 8);
        await buf.setOption('expandtab', false);
        let doc = workspace_1.default.getDocument(buf.id);
        let opts = await workspace_1.default.getFormatOptions(doc.uri);
        expect(opts).toEqual({
            tabSize: 8,
            insertSpaces: false,
            insertFinalNewline: true,
            trimTrailingWhitespace: true,
            trimFinalNewlines: true
        });
    });
    it('should check document', async () => {
        let doc = await workspace_1.default.document;
        expect(workspace_1.default.hasDocument(doc.uri)).toBe(true);
        expect(workspace_1.default.hasDocument(doc.uri, doc.version)).toBe(true);
        expect(workspace_1.default.hasDocument(doc.uri, doc.version - 1)).toBe(false);
    });
    it('should get format options when uri does not exist', async () => {
        let uri = vscode_uri_1.URI.file('/tmp/foo').toString();
        let opts = await workspace_1.default.getFormatOptions(uri);
        expect(opts.insertSpaces).toBe(true);
        expect(opts.tabSize).toBe(2);
    });
    it('should create file watcher', async () => {
        let watcher = workspace_1.default.createFileSystemWatcher('**/*.ts');
        expect(watcher).toBeDefined();
    });
    it('should get quickfix item from Location', async () => {
        let filepath = await (0, helper_1.createTmpFile)('quickfix');
        let uri = vscode_uri_1.URI.file(filepath).toString();
        let p = vscode_languageserver_types_1.Position.create(0, 0);
        let loc = vscode_languageserver_types_1.Location.create(uri, vscode_languageserver_types_1.Range.create(p, p));
        let item = await workspace_1.default.getQuickfixItem(loc);
        expect(item.filename).toBe(filepath);
        expect(item.text).toBe('quickfix');
    });
    it('should get quickfix list from Locations', async () => {
        let filepathA = await (0, helper_1.createTmpFile)('fileA:1\nfileA:2\nfileA:3');
        let uriA = vscode_uri_1.URI.file(filepathA).toString();
        let filepathB = await (0, helper_1.createTmpFile)('fileB:1\nfileB:2\nfileB:3');
        let uriB = vscode_uri_1.URI.file(filepathB).toString();
        let p1 = vscode_languageserver_types_1.Position.create(0, 0);
        let p2 = vscode_languageserver_types_1.Position.create(1, 0);
        let locations = [];
        locations.push(vscode_languageserver_types_1.Location.create(uriA, vscode_languageserver_types_1.Range.create(p1, p1)));
        locations.push(vscode_languageserver_types_1.Location.create(uriA, vscode_languageserver_types_1.Range.create(p2, p2)));
        locations.push(vscode_languageserver_types_1.Location.create(uriB, vscode_languageserver_types_1.Range.create(p1, p1)));
        locations.push(vscode_languageserver_types_1.Location.create(uriB, vscode_languageserver_types_1.Range.create(p2, p2)));
        let items = await workspace_1.default.getQuickfixList(locations);
        expect(items[0].filename).toBe(filepathA);
        expect(items[0].text).toBe('fileA:1');
        expect(items[1].filename).toBe(filepathA);
        expect(items[1].text).toBe('fileA:2');
        expect(items[2].filename).toBe(filepathB);
        expect(items[2].text).toBe('fileB:1');
        expect(items[3].filename).toBe(filepathB);
        expect(items[3].text).toBe('fileB:2');
    });
    it('should get line of document', async () => {
        let doc = await workspace_1.default.document;
        await nvim.setLine('abc');
        let line = await workspace_1.default.getLine(doc.uri, 0);
        expect(line).toBe('abc');
    });
    it('should get line of file', async () => {
        let filepath = await (0, helper_1.createTmpFile)('quickfix');
        let uri = vscode_uri_1.URI.file(filepath).toString();
        let line = await workspace_1.default.getLine(uri, 0);
        expect(line).toBe('quickfix');
    });
    it('should read content from buffer', async () => {
        let doc = await workspace_1.default.document;
        await doc.applyEdits([{ range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0), newText: 'foo' }]);
        let line = await workspace_1.default.readFile(doc.uri);
        expect(line).toBe('foo\n');
    });
    it('should read content from file', async () => {
        let filepath = await (0, helper_1.createTmpFile)('content');
        let content = await workspace_1.default.readFile(vscode_uri_1.URI.file(filepath).toString());
        expect(content).toBe(content);
    });
    it('should expand filepath', async () => {
        let home = os_1.default.homedir();
        let res = workspace_1.default.expand('~/$NODE_ENV/');
        expect(res.startsWith(home)).toBeTruthy();
        expect(res).toContain(process.env.NODE_ENV);
        res = workspace_1.default.expand('$HOME/$NODE_ENV/');
        expect(res.startsWith(home)).toBeTruthy();
        expect(res).toContain(process.env.NODE_ENV);
    });
    it('should expand variables', async () => {
        expect(workspace_1.default.expand('${workspace}/foo')).toBe(`${workspace_1.default.root}/foo`);
        expect(workspace_1.default.expand('${env:NODE_ENV}')).toBe(process.env.NODE_ENV);
        expect(workspace_1.default.expand('${cwd}')).toBe(workspace_1.default.cwd);
        let folder = path_1.default.basename(workspace_1.default.root);
        expect(workspace_1.default.expand('${workspaceFolderBasename}')).toBe(folder);
        await helper_1.default.edit('bar.ts');
        expect(workspace_1.default.expand('${file}')).toContain('bar');
        expect(workspace_1.default.expand('${fileDirname}')).toBe(path_1.default.dirname(__dirname));
        expect(workspace_1.default.expand('${fileExtname}')).toBe('.ts');
        expect(workspace_1.default.expand('${fileBasename}')).toBe('bar.ts');
        expect(workspace_1.default.expand('${fileBasenameNoExtension}')).toBe('bar');
    });
    it('should run command', async () => {
        let res = await workspace_1.default.runCommand('ls', __dirname, 1000);
        expect(res).toMatch('workspace');
        res = await workspace_1.default.runCommand('ls');
        expect(res).toBeDefined();
    });
    it('should export deprecated properties', async () => {
        expect(workspace_1.default.completeOpt).toBeDefined();
        expect(workspace_1.default.createNameSpace('name')).toBeDefined();
        expect(workspace_1.Workspace).toBeDefined();
        expect(workspace_1.default['onDidOpenTerminal']).toBeDefined();
        expect(workspace_1.default['onDidCloseTerminal']).toBeDefined();
        workspace_1.default.checkVersion(0);
    });
    it('should resolve module path if exists', async () => {
        let res = await workspace_1.default.resolveModule('bytes');
        res = await workspace_1.default.resolveModule('bytes');
        expect(res).toBeTruthy();
    });
    it('should not resolve module if it does not exist', async () => {
        let res = await workspace_1.default.resolveModule('foo');
        res = await workspace_1.default.resolveModule('foo');
        expect(res).toBeFalsy();
    });
    it('should return match score for document', async () => {
        let doc = await helper_1.default.createDocument('tmp.xml');
        expect(workspace_1.default.match(['xml'], doc.textDocument)).toBe(10);
        expect(workspace_1.default.match(['wxml'], doc.textDocument)).toBe(0);
        expect(workspace_1.default.match([{ language: 'xml' }], doc.textDocument)).toBe(10);
        expect(workspace_1.default.match([{ language: 'wxml' }], doc.textDocument)).toBe(0);
        expect(workspace_1.default.match([{ pattern: '**/*.xml' }], doc.textDocument)).toBe(5);
        expect(workspace_1.default.match([{ pattern: '**/*.html' }], doc.textDocument)).toBe(0);
        expect(workspace_1.default.match([{ scheme: 'file' }], doc.textDocument)).toBe(5);
        expect(workspace_1.default.match([{ scheme: 'term' }], doc.textDocument)).toBe(0);
        expect(workspace_1.default.match([{ language: 'xml' }, { scheme: 'file' }], doc.textDocument)).toBe(10);
    });
    it('should handle will save event', async () => {
        async function doRename() {
            let fsPath = await (0, helper_1.createTmpFile)('foo', disposables);
            let newPath = path_1.default.join(path_1.default.dirname(fsPath), 'new_file');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(newPath))
                    fs_1.default.unlinkSync(newPath);
            }));
            await workspace_1.default.renameFile(fsPath, newPath, { overwrite: true });
            if (fs_1.default.existsSync(newPath))
                fs_1.default.unlinkSync(newPath);
        }
        let called = false;
        let disposable = workspace_1.default.onWillRenameFiles(e => {
            let p = new Promise(resolve => {
                setTimeout(() => {
                    called = true;
                    resolve();
                }, 10);
            });
            e.waitUntil(p);
        });
        await doRename();
        disposable.dispose();
        expect(called).toBe(true);
        called = false;
        disposable = workspace_1.default.onWillRenameFiles(e => {
            called = true;
            e.waitUntil(Promise.resolve({ changes: {} }));
        });
        await doRename();
        expect(called).toBe(true);
        disposable.dispose();
    });
});
describe('workspace utility', () => {
    it('should create database', async () => {
        let filpath = path_1.default.join(process.env.COC_DATA_HOME, 'test.json');
        if (fs_1.default.existsSync(filpath)) {
            fs_1.default.unlinkSync(filpath);
        }
        let db = workspace_1.default.createDatabase('test');
        let res = db.exists('xyz');
        expect(res).toBe(false);
        db.destroy();
    });
    it('should get current state', async () => {
        let buf = await helper_1.default.edit();
        await buf.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        await nvim.call('cursor', [2, 2]);
        let doc = workspace_1.default.getDocument(buf.id);
        let state = await workspace_1.default.getCurrentState();
        expect(doc.uri).toBe(state.document.uri);
        expect(state.position).toEqual({ line: 1, character: 1 });
    });
    it('should findUp to tsconfig.json from current file', async () => {
        await helper_1.default.edit(path_1.default.join(__dirname, 'edit'));
        let filepath = await workspace_1.default.findUp('tsconfig.json');
        expect(filepath).toMatch('tsconfig.json');
    });
    it('should findUp from current file ', async () => {
        await helper_1.default.edit('foo');
        let filepath = await workspace_1.default.findUp('tsconfig.json');
        expect(filepath).toMatch('tsconfig.json');
    });
    it('should not findUp from file in other directory', async () => {
        await nvim.command(`edit ${path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)())}`);
        let filepath = await workspace_1.default.findUp('tsconfig.json');
        expect(filepath).toBeNull();
    });
    it('should register autocmd', async () => {
        let event;
        let eventCount = 0;
        let disposables = [];
        disposables.push(workspace_1.default.registerAutocmd({
            event: 'TextYankPost',
            request: true,
            arglist: ['v:event'],
            callback: ev => {
                eventCount += 1;
                event = ev;
            }
        }));
        await nvim.setLine('foo');
        await nvim.command('normal! yy');
        await helper_1.default.wait(30);
        expect(event.regtype).toBe('V');
        expect(event.operator).toBe('y');
        expect(event.regcontents).toEqual(['foo']);
        expect(eventCount).toBe(1);
        disposables.forEach(d => d.dispose());
    });
    it('should register keymap', async () => {
        let n = 0;
        let fn = () => {
            n++;
        };
        await nvim.command('nmap go <Plug>(coc-echo)');
        let disposable = workspace_1.default.registerKeymap(['n', 'v'], 'echo', fn, { sync: true });
        let { mode } = await nvim.mode;
        expect(mode).toBe('n');
        await nvim.call('feedkeys', ['go', 'i']);
        await helper_1.default.waitValue(() => n, 1);
        disposable.dispose();
        await nvim.call('feedkeys', ['go', 'i']);
        await helper_1.default.wait(20);
        expect(n).toBe(1);
    });
    it('should register expr keymap', async () => {
        let called = false;
        let fn = () => {
            called = true;
            return '""';
        };
        await nvim.input('i');
        let { mode } = await nvim.mode;
        expect(mode).toBe('i');
        let disposable = workspace_1.default.registerExprKeymap('i', '"', fn);
        await helper_1.default.wait(30);
        await nvim.call('feedkeys', ['"', 't']);
        await helper_1.default.wait(30);
        expect(called).toBe(true);
        let line = await nvim.line;
        expect(line).toBe('""');
        disposable.dispose();
    });
    it('should register buffer expr keymap', async () => {
        let fn = () => '""';
        await nvim.input('i');
        let disposable = workspace_1.default.registerExprKeymap('i', '"', fn, true);
        await helper_1.default.wait(30);
        await nvim.call('feedkeys', ['"', 't']);
        await helper_1.default.wait(30);
        let line = await nvim.line;
        expect(line).toBe('""');
        disposable.dispose();
    });
    it('should check nvim version', async () => {
        expect(workspace_1.default.has('patch-7.4.248')).toBe(false);
        expect(workspace_1.default.has('nvim-0.5.0')).toBe(true);
        expect(workspace_1.default.has('nvim-9.0.0')).toBe(false);
    });
    it('should registerLocalKeymap by old API', async () => {
        let called = false;
        let fn = workspace_1.default.registerLocalKeymap.bind(workspace_1.default);
        let disposable = fn('n', 'n', () => { called = true; });
        await nvim.call('feedkeys', ['n', 't']);
        await helper_1.default.waitValue(() => called, true);
        disposable.dispose();
        let res = await nvim.exec('nmap n', true);
        expect(res).toMatch('No mapping found');
    });
});
describe('workspace events', () => {
    it('should listen to fileType change', async () => {
        let buf = await helper_1.default.edit();
        await nvim.command('setf xml');
        await helper_1.default.wait(50);
        let doc = workspace_1.default.getDocument(buf.id);
        expect(doc.filetype).toBe('xml');
    });
    it('should fire onDidOpenTextDocument', async () => {
        let fn = jest.fn();
        workspace_1.default.onDidOpenTextDocument(fn, null, disposables);
        await helper_1.default.edit();
        await helper_1.default.wait(30);
        expect(fn).toHaveBeenCalledTimes(1);
    });
    it('should fire onDidChangeTextDocument', async () => {
        let fn = jest.fn();
        await helper_1.default.edit();
        workspace_1.default.onDidChangeTextDocument(fn, null, disposables);
        await nvim.setLine('foo');
        let doc = await workspace_1.default.document;
        doc.forceSync();
        await helper_1.default.wait(20);
        expect(fn).toHaveBeenCalledTimes(1);
    });
    it('should fire onDidChangeConfiguration', async () => {
        let fn = jest.fn();
        let disposable = workspace_1.default.onDidChangeConfiguration(e => {
            disposable.dispose();
            expect(e.affectsConfiguration('tsserver')).toBe(true);
            expect(e.affectsConfiguration('tslint')).toBe(false);
            fn();
        });
        let config = workspace_1.default.getConfiguration('tsserver');
        await config.update('enable', false);
        expect(fn).toHaveBeenCalledTimes(1);
        await config.update('enable', undefined);
    });
    it('should resolve json schema', async () => {
        expect(workspace_1.default.resolveJSONSchema(configuration_1.userSettingsSchemaId)).toBeDefined();
    });
    it('should get empty configuration for none exists section', () => {
        let config = workspace_1.default.getConfiguration('notexists');
        let keys = Object.keys(config);
        expect(keys.length).toBe(0);
    });
    it('should fire onWillSaveUntil', async () => {
        let doc = await workspace_1.default.document;
        let filepath = vscode_uri_1.URI.parse(doc.uri).fsPath;
        let fn = jest.fn();
        let disposable = workspace_1.default.onWillSaveTextDocument(event => {
            let promise = new Promise(resolve => {
                fn();
                let edit = {
                    newText: 'foo',
                    range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0)
                };
                resolve([edit]);
            });
            event.waitUntil(promise);
        });
        await nvim.setLine('bar');
        await helper_1.default.wait(30);
        await events_1.default.fire('BufWritePre', [doc.bufnr, doc.bufname]);
        await helper_1.default.wait(30);
        let content = doc.getDocumentContent();
        expect(content.startsWith('foobar')).toBe(true);
        disposable.dispose();
        expect(fn).toBeCalledTimes(1);
        if (fs_1.default.existsSync(filepath)) {
            fs_1.default.unlinkSync(filepath);
        }
    });
    it('should not work for async waitUntil', async () => {
        let doc = await helper_1.default.createDocument();
        let filepath = vscode_uri_1.URI.parse(doc.uri).fsPath;
        let disposable = workspace_1.default.onWillSaveTextDocument(event => {
            setTimeout(() => {
                let edit = {
                    newText: 'foo',
                    range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0)
                };
                event.waitUntil(Promise.resolve([edit]));
            }, 30);
        });
        await nvim.setLine('bar');
        await helper_1.default.wait(30);
        await nvim.command('wa');
        let content = doc.getDocumentContent();
        expect(content).toMatch('bar');
        disposable.dispose();
        if (fs_1.default.existsSync(filepath)) {
            fs_1.default.unlinkSync(filepath);
        }
    });
    it('should only use first returned textEdits', async () => {
        let doc = await helper_1.default.createDocument();
        let filepath = vscode_uri_1.URI.parse(doc.uri).fsPath;
        disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
            if (fs_1.default.existsSync(filepath)) {
                fs_1.default.unlinkSync(filepath);
            }
        }));
        workspace_1.default.onWillSaveTextDocument(event => {
            event.waitUntil(Promise.resolve(undefined));
        }, null, disposables);
        workspace_1.default.onWillSaveTextDocument(event => {
            let promise = new Promise(resolve => {
                setTimeout(() => {
                    let edit = {
                        newText: 'foo',
                        range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0)
                    };
                    resolve([edit]);
                }, 10);
            });
            event.waitUntil(promise);
        }, null, disposables);
        workspace_1.default.onWillSaveTextDocument(event => {
            let promise = new Promise(resolve => {
                setTimeout(() => {
                    let edit = {
                        newText: 'bar',
                        range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0)
                    };
                    resolve([edit]);
                }, 30);
            });
            event.waitUntil(promise);
        }, null, disposables);
        await nvim.setLine('bar');
        await helper_1.default.wait(30);
        await nvim.command('wa');
        let content = doc.getDocumentContent();
        expect(content).toMatch('foo');
    });
    it('should attach & detach', async () => {
        let buf = await helper_1.default.edit();
        await nvim.command('CocDisable');
        let doc = workspace_1.default.getDocument(buf.id);
        expect(doc).toBeUndefined();
        await nvim.command('CocEnable');
        doc = workspace_1.default.getDocument(buf.id);
        expect(doc.bufnr).toBe(buf.id);
    });
});
describe('workspace registerBufferSync', () => {
    it('should register', async () => {
        await helper_1.default.createDocument();
        let created = 0;
        let deleted = 0;
        let changed = 0;
        let disposable = workspace_1.default.registerBufferSync(() => {
            created = created + 1;
            return {
                dispose: () => {
                    deleted += 1;
                },
                onChange: () => {
                    changed += 1;
                }
            };
        });
        disposables.push(disposable);
        let doc = await helper_1.default.createDocument();
        expect(created).toBe(2);
        await doc.applyEdits([vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo')]);
        expect(changed).toBe(1);
        await nvim.command('bd!');
        expect(deleted).toBe(1);
    });
    it('should invoke onTextChange', async () => {
        let called = 0;
        disposables.push(workspace_1.default.registerBufferSync(() => {
            return {
                dispose: () => {
                },
                onTextChange: () => {
                    called = called + 1;
                }
            };
        }));
        let doc = await helper_1.default.createDocument();
        await nvim.setLine('foo');
        await doc.synchronize();
        expect(called).toBe(1);
    });
});
//# sourceMappingURL=workspace.test.js.map