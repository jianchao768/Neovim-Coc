"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const outputChannel_1 = tslib_1.__importDefault(require("../../model/outputChannel"));
const util_1 = require("../../util");
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterEach(async () => {
    await helper_1.default.reset();
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
describe('OutputChannel', () => {
    test('without nvim', () => {
        let o = new outputChannel_1.default('f');
        o.appendLine('foo');
        o.append('bar');
        o.show();
        o.hide();
        o.clear();
    });
    test('bad channel name', () => {
        let err;
        try {
            new outputChannel_1.default('@', nvim);
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
    });
    test('outputChannel.show(true)', async () => {
        await nvim.setLine('foo');
        let c = new outputChannel_1.default('0', nvim);
        let bufnr = (await nvim.buffer).id;
        c.show(true);
        await helper_1.default.waitFor('bufnr', ['%'], bufnr);
        c.hide();
        c.clear(1);
        c.dispose();
        c.append('');
        c.appendLine('');
    });
    test('outputChannel.keep()', async () => {
        await nvim.setLine('foo');
        let c = new outputChannel_1.default('clear', nvim);
        c.appendLine('foo');
        c.appendLine('bar');
        c.show();
        await helper_1.default.wait(10);
        c.clear(2);
        let lines = await nvim.call('getbufline', ['output:///clear', 1, '$']);
        expect(lines.includes('bar')).toBe(true);
    });
    test('outputChannel.show(false)', async () => {
        let c = new outputChannel_1.default('1', nvim);
        let bufnr = (await nvim.buffer).id;
        c.show();
        await (0, util_1.wait)(100);
        let nr = (await nvim.buffer).id;
        expect(bufnr).toBeLessThan(nr);
    });
    test('outputChannel.appendLine()', async () => {
        let c = new outputChannel_1.default('2', nvim);
        c.show();
        await (0, util_1.wait)(100);
        let buf = await nvim.buffer;
        c.appendLine('foo');
        await helper_1.default.waitFor('eval', [`join(getbufline(${buf.id},1,'$'),'\n')`], /foo/);
    });
    test('outputChannel.append()', async () => {
        let c = new outputChannel_1.default('3', nvim);
        c.show(false);
        await (0, util_1.wait)(60);
        c.append('foo');
        c.append('bar');
        await (0, util_1.wait)(50);
        let buf = await nvim.buffer;
        await helper_1.default.waitFor('eval', [`join(getbufline(${buf.id},1,'$'),'\n')`], /foo/);
    });
    test('outputChannel.clear()', async () => {
        let c = new outputChannel_1.default('4', nvim);
        c.show(false);
        await (0, util_1.wait)(30);
        let buf = await nvim.buffer;
        c.appendLine('foo');
        c.appendLine('bar');
        await (0, util_1.wait)(30);
        c.clear();
        await (0, util_1.wait)(30);
        let lines = await buf.lines;
        let content = lines.join('');
        expect(content).toBe('');
    });
});
//# sourceMappingURL=outputChannel.test.js.map