'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const util_1 = require("../../util");
const fs_1 = require("../../util/fs");
const protocol_1 = require("../../util/protocol");
const textedit_1 = require("../../util/textedit");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const buffer_1 = tslib_1.__importStar(require("./buffer"));
const search_1 = tslib_1.__importDefault(require("./search"));
const name = '__coc_refactor__';
let refactorId = 0;
let srcId;
class Refactor {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.buffers = new Map();
        this.disposables = [];
        this._onCreate = new protocol_1.Emitter();
        this.onCreate = this._onCreate.event;
        this.setConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        events_1.default.on('BufUnload', bufnr => {
            let buf = this.buffers.get(bufnr);
            if (buf) {
                buf.dispose();
                this.buffers.delete(bufnr);
            }
        }, null, this.disposables);
        workspace_1.default.onDidChangeTextDocument(e => {
            let buf = this.buffers.get(e.bufnr);
            if (buf)
                buf.onChange(e);
        }, null, this.disposables);
    }
    has(bufnr) {
        return this.buffers.has(bufnr);
    }
    setConfiguration(e) {
        if (e && !e.affectsConfiguration('refactor'))
            return;
        let config = workspace_1.default.getConfiguration('refactor', null);
        this.config = Object.assign(this.config || {}, {
            afterContext: config.get('afterContext', 3),
            beforeContext: config.get('beforeContext', 3),
            openCommand: config.get('openCommand', 'edit'),
            saveToFile: config.get('saveToFile', true),
            showMenu: config.get('showMenu', '<Tab>')
        });
    }
    /**
     * Refactor of current symbol
     */
    async doRefactor() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_1.default.hasProvider(languages_1.ProviderName.Rename, doc.textDocument)) {
            throw new Error(`Rename provider not found for current buffer`);
        }
        await doc.synchronize();
        let edit = await this.handler.withRequestToken('refactor', async (token) => {
            let res = await languages_1.default.prepareRename(doc.textDocument, position, token);
            if (token.isCancellationRequested)
                return null;
            if (res === false)
                throw new Error(`Provider returns null on prepare, unable to rename at current position`);
            let edit = await languages_1.default.provideRenameEdits(doc.textDocument, position, 'NewName', token);
            if (token.isCancellationRequested)
                return null;
            if (!edit)
                throw new Error('Provider returns null for rename edits.');
            return edit;
        });
        if (edit) {
            await this.fromWorkspaceEdit(edit, doc.filetype);
        }
    }
    /**
     * Search by rg
     */
    async search(args) {
        let buf = await this.createRefactorBuffer();
        let cwd = await this.nvim.call('getcwd', []);
        let search = new search_1.default(this.nvim);
        await search.run(args, cwd, buf);
    }
    async save(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (buf)
            return await buf.save();
    }
    getBuffer(bufnr) {
        return this.buffers.get(bufnr);
    }
    /**
     * Create initialized refactor buffer
     */
    async createRefactorBuffer(filetype, conceal = false) {
        let { nvim } = this;
        let [fromWinid, cwd] = await nvim.eval('[win_getid(),getcwd()]');
        let { openCommand } = this.config;
        if (!nvim.isVim && !srcId)
            srcId = await this.nvim.createNamespace('coc-refactor');
        nvim.pauseNotification();
        nvim.command(`${openCommand} ${name}${refactorId++}`, true);
        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
        nvim.call('setline', [1, ['Save current buffer to make changes', buffer_1.SEPARATOR]], true);
        nvim.call('matchadd', ['Comment', '\\%1l'], true);
        nvim.call('matchadd', ['Conceal', '^\\%u3000'], true);
        nvim.call('matchadd', ['Label', '^\\%u3000\\zs\\S\\+'], true);
        nvim.command('setl nomod', true);
        if (filetype)
            nvim.command(`runtime! syntax/${filetype}.vim`, true);
        nvim.call('coc#util#do_autocmd', ['CocRefactorOpen'], true);
        await nvim.resumeNotification();
        let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
        let opts = { fromWinid, winid: win, cwd };
        await workspace_1.default.document;
        let buf = new buffer_1.default(bufnr, conceal ? undefined : srcId, this.nvim, this.config, opts);
        this.buffers.set(bufnr, buf);
        return buf;
    }
    /**
     * Create refactor buffer from lines
     */
    async fromLines(lines) {
        let buf = await this.createRefactorBuffer();
        await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });
        return buf;
    }
    /**
     * Create refactor buffer from locations
     */
    async fromLocations(locations, filetype) {
        if (!locations || locations.length == 0)
            return undefined;
        let changes = {};
        let edit = { changes };
        for (let location of locations) {
            let edits = changes[location.uri] || [];
            edits.push({ range: location.range, newText: '' });
            changes[location.uri] = edits;
        }
        return await this.fromWorkspaceEdit(edit, filetype);
    }
    /**
     * Start refactor from workspaceEdit
     */
    async fromWorkspaceEdit(edit, filetype) {
        if (!edit || (0, textedit_1.emptyWorkspaceEdit)(edit))
            return undefined;
        let items = [];
        let { beforeContext, afterContext } = this.config;
        let { changes, documentChanges } = edit;
        if (!changes) {
            changes = {};
            for (let change of documentChanges || []) {
                if (vscode_languageserver_types_1.TextDocumentEdit.is(change)) {
                    let { textDocument, edits } = change;
                    changes[textDocument.uri] = edits;
                }
            }
        }
        for (let key of Object.keys(changes)) {
            let max = await this.getLineCount(key);
            let edits = changes[key];
            let ranges = [];
            // start end highlights
            let start = null;
            let end = null;
            let highlights = [];
            edits.sort((a, b) => a.range.start.line - b.range.start.line);
            for (let edit of edits) {
                let { line } = edit.range.start;
                let s = Math.max(0, line - beforeContext);
                if (start != null && s < end) {
                    end = Math.min(max, line + afterContext + 1);
                    highlights.push(adjustRange(edit.range, start));
                }
                else {
                    if (start != null)
                        ranges.push({ start, end, highlights });
                    start = s;
                    end = Math.min(max, line + afterContext + 1);
                    highlights = [adjustRange(edit.range, start)];
                }
            }
            if (start != null)
                ranges.push({ start, end, highlights });
            items.push({
                ranges,
                filepath: vscode_uri_1.URI.parse(key).fsPath
            });
        }
        let buf = await this.createRefactorBuffer(filetype);
        await buf.addFileItems(items);
        return buf;
    }
    async getLineCount(uri) {
        let doc = workspace_1.default.getDocument(uri);
        if (doc)
            return doc.lineCount;
        return await (0, fs_1.getFileLineCount)(vscode_uri_1.URI.parse(uri).fsPath);
    }
    reset() {
        for (let buf of this.buffers.values()) {
            buf.dispose();
        }
        this.buffers.clear();
    }
    dispose() {
        this._onCreate.dispose();
        this.buffers.clear();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Refactor;
function adjustRange(range, offset) {
    let { start, end } = range;
    return vscode_languageserver_types_1.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
//# sourceMappingURL=index.js.map