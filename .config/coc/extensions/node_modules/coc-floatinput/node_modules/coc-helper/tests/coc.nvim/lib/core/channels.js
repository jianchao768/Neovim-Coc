'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const outputChannel_1 = tslib_1.__importDefault(require("../model/outputChannel"));
class Channels {
    constructor() {
        this.outputChannels = new Map();
        this.bufnrs = new Map();
        this.disposable = events_1.default.on('BufUnload', bufnr => {
            let name = this.bufnrs.get(bufnr);
            if (name) {
                let channel = this.outputChannels.get(name);
                if (channel)
                    channel.created = false;
            }
        });
    }
    /**
     * Get text document provider
     */
    getProvider(nvim) {
        let provider = {
            onDidChange: null,
            provideTextDocumentContent: async (uri) => {
                let channel = this.get(uri.path.slice(1));
                if (!channel)
                    return '';
                nvim.pauseNotification();
                nvim.call('bufnr', ['%'], true);
                nvim.command('setlocal nospell nofoldenable nowrap noswapfile', true);
                nvim.command('setlocal buftype=nofile bufhidden=hide', true);
                nvim.command('setfiletype log', true);
                let res = await nvim.resumeNotification();
                this.bufnrs.set(res[0][0], channel.name);
                channel.created = true;
                return channel.content;
            }
        };
        return provider;
    }
    get names() {
        return Array.from(this.outputChannels.keys());
    }
    get(channelName) {
        return this.outputChannels.get(channelName);
    }
    create(name, nvim) {
        if (this.outputChannels.has(name))
            return this.outputChannels.get(name);
        let channel = new outputChannel_1.default(name, nvim, () => {
            this.outputChannels.delete(name);
        });
        this.outputChannels.set(name, channel);
        return channel;
    }
    show(name, cmd, preserveFocus) {
        let channel = this.outputChannels.get(name);
        if (!channel)
            return;
        channel.show(preserveFocus, cmd);
    }
    dispose() {
        this.disposable.dispose();
        for (let channel of this.outputChannels.values()) {
            channel.dispose();
        }
        this.outputChannels.clear();
    }
}
exports.default = new Channels();
//# sourceMappingURL=channels.js.map