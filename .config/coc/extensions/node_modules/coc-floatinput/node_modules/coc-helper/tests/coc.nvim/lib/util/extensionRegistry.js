'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseExtensionName = exports.getProperties = exports.validCommandContribution = exports.validRootPattern = exports.getExtensionDefinitions = exports.Extensions = void 0;
const tslib_1 = require("tslib");
const array_1 = require("./array");
const constants_1 = require("./constants");
const fs_1 = require("./fs");
const Is = tslib_1.__importStar(require("./is"));
const object_1 = require("./object");
const registry_1 = require("./registry");
const string_1 = require("./string");
/**
 * Contains static extension infos
 */
exports.Extensions = {
    ExtensionContribution: 'base.contributions.extensions'
};
/**
 * Registry for loaded extensions.
 */
class ExtensionRegistry {
    constructor() {
        this.extensionsById = new Map();
    }
    get onCommands() {
        let res = [];
        for (let item of this.extensionsById.values()) {
            let { commands, onCommands } = item;
            for (let cmd of onCommands) {
                if (typeof cmd === 'string') {
                    let find = commands.find(o => o.command === cmd);
                    let title = find == null ? '' : find.title;
                    res.push({ id: cmd, title });
                }
            }
        }
        return res;
    }
    getCommandTitle(id) {
        for (let item of this.extensionsById.values()) {
            for (let cmd of (0, array_1.toArray)(item.commands)) {
                if (cmd.command === id)
                    return cmd.title;
            }
        }
        return undefined;
    }
    get commands() {
        let res = [];
        for (let item of this.extensionsById.values()) {
            res.push(...((0, array_1.toArray)(item.commands).filter(validCommandContribution)));
        }
        return res;
    }
    getRootPatternsByFiletype(filetype) {
        let res = [];
        for (let item of this.extensionsById.values()) {
            for (let p of (0, array_1.toArray)(item.rootPatterns).filter(validRootPattern)) {
                if (p.filetype === filetype)
                    res.push(...p.patterns.filter(s => typeof s === 'string'));
            }
        }
        return res;
    }
    unregistExtension(id) {
        this.extensionsById.delete(id);
    }
    registerExtension(id, info) {
        this.extensionsById.set(id, info);
    }
    getExtension(id) {
        return this.extensionsById.get(id);
    }
    getExtensions() {
        return { extensions: this.extensionsById.values() };
    }
}
let extensionRegistry = new ExtensionRegistry();
registry_1.Registry.add(exports.Extensions.ExtensionContribution, extensionRegistry);
function getExtensionDefinitions() {
    let obj = {};
    for (let extensionInfo of extensionRegistry.getExtensions().extensions) {
        let definitions = extensionInfo.definitions;
        Object.entries((0, object_1.toObject)(definitions)).forEach(([key, val]) => {
            obj[key] = val;
        });
    }
    return obj;
}
exports.getExtensionDefinitions = getExtensionDefinitions;
function validRootPattern(rootPattern) {
    return rootPattern && typeof rootPattern.filetype === 'string' && !(0, array_1.isFalsyOrEmpty)(rootPattern.patterns);
}
exports.validRootPattern = validRootPattern;
function validCommandContribution(cmd) {
    return cmd && typeof cmd.command === 'string' && typeof cmd.title === 'string';
}
exports.validCommandContribution = validCommandContribution;
function getProperties(configuration) {
    let obj = {};
    if (Array.isArray(configuration)) {
        for (let item of configuration) {
            Object.assign(obj, (0, object_1.toObject)(item['properties']));
        }
    }
    else if (Is.objectLiteral(configuration['properties'])) {
        obj = configuration['properties'];
    }
    return obj;
}
exports.getProperties = getProperties;
/**
 * Get extension name from error stack
 */
function parseExtensionName(stack, level = 2) {
    let line = stack.split(/\r?\n/).slice(level)[0];
    if (!line)
        return undefined;
    line = line.replace(/^\s*at\s*/, '');
    let filepath;
    if (line.endsWith(')')) {
        let ms = line.match(/(\((.*?):\d+:\d+\))$/);
        if (ms)
            filepath = ms[2];
    }
    else {
        let ms = line.match(/(.*?):\d+:\d+$/);
        if (ms)
            filepath = ms[1];
    }
    if (!filepath)
        return undefined;
    let arr = Array.from(extensionRegistry.getExtensions().extensions);
    let find = arr.find(o => (0, fs_1.sameFile)((0, string_1.toText)(o.filepath), filepath));
    if (find)
        return find.name;
    find = arr.find(o => (0, fs_1.isParentFolder)(o.directory, filepath));
    if (find)
        return find.name;
    if ((0, fs_1.isParentFolder)(constants_1.pluginRoot, filepath))
        return 'coc.nvim';
}
exports.parseExtensionName = parseExtensionName;
//# sourceMappingURL=extensionRegistry.js.map