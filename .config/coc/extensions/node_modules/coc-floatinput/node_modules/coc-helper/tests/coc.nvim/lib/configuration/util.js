'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookUp = exports.getDefaultValue = exports.compareConfigurationContents = exports.toJSONObject = exports.getConfigurationValue = exports.removeFromValueTree = exports.addToValueTree = exports.toValuesTree = exports.convertErrors = exports.mergeConfigProperties = exports.mergeChanges = exports.overrideIdentifiersFromKey = exports.scopeToOverrides = exports.convertTarget = exports.expandObject = exports.expand = exports.OVERRIDE_PROPERTY_REGEX = exports.OVERRIDE_PROPERTY_PATTERN = void 0;
const tslib_1 = require("tslib");
const jsonc_parser_1 = require("jsonc-parser");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const array_1 = require("../util/array");
const Is = tslib_1.__importStar(require("../util/is"));
const node_1 = require("../util/node");
const object_1 = require("../util/object");
const types_1 = require("./types");
const documentUri = 'file:///1';
const OVERRIDE_IDENTIFIER_PATTERN = `\\[([^\\]]+)\\]`;
const OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, 'g');
exports.OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;
exports.OVERRIDE_PROPERTY_REGEX = new RegExp(exports.OVERRIDE_PROPERTY_PATTERN);
/**
 * Basic expand for ${env:value}, ${cwd}, ${userHome}
 */
function expand(input) {
    return input.replace(/\$\{(.*?)\}/g, (match, name) => {
        var _a;
        if (name.startsWith('env:')) {
            let key = name.split(':')[1];
            return (_a = process.env[key]) !== null && _a !== void 0 ? _a : match;
        }
        switch (name) {
            case 'userHome':
                return node_1.os.homedir();
            case 'cwd':
                return process.cwd();
            default:
                return match;
        }
    });
}
exports.expand = expand;
function expandObject(obj) {
    if (obj == null)
        return obj;
    if (typeof obj === 'string')
        return expand(obj);
    if (Array.isArray(obj))
        return obj.map(obj => expandObject(obj));
    if (Is.objectLiteral(obj)) {
        for (let key of Object.keys(obj)) {
            obj[key] = expandObject(obj[key]);
        }
        return obj;
    }
    return obj;
}
exports.expandObject = expandObject;
function convertTarget(updateTarget) {
    let target;
    switch (updateTarget) {
        case types_1.ConfigurationUpdateTarget.Global:
            target = types_1.ConfigurationTarget.User;
            break;
        case types_1.ConfigurationUpdateTarget.Workspace:
            target = types_1.ConfigurationTarget.Workspace;
            break;
        default:
            target = types_1.ConfigurationTarget.WorkspaceFolder;
    }
    return target;
}
exports.convertTarget = convertTarget;
function scopeToOverrides(scope) {
    let overrides;
    if (typeof scope === 'string') {
        overrides = { resource: scope };
    }
    else if (vscode_uri_1.URI.isUri(scope)) {
        overrides = { resource: scope.toString() };
    }
    else if (scope != null) {
        let uri = scope['uri'];
        let languageId = scope['languageId'];
        overrides = { resource: uri, overrideIdentifier: languageId };
    }
    return overrides;
}
exports.scopeToOverrides = scopeToOverrides;
function overrideIdentifiersFromKey(key) {
    const identifiers = [];
    if (exports.OVERRIDE_PROPERTY_REGEX.test(key)) {
        let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
        while (matches === null || matches === void 0 ? void 0 : matches.length) {
            const identifier = matches[1].trim();
            if (identifier) {
                identifiers.push(identifier);
            }
            matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
        }
    }
    return (0, array_1.distinct)(identifiers);
}
exports.overrideIdentifiersFromKey = overrideIdentifiersFromKey;
function getOrSet(map, key, value) {
    let result = map.get(key);
    if (result === undefined) {
        result = value;
        map.set(key, result);
    }
    return result;
}
function mergeChanges(...changes) {
    if (changes.length === 0) {
        return { keys: [], overrides: [] };
    }
    if (changes.length === 1) {
        return changes[0];
    }
    const keysSet = new Set();
    const overridesMap = new Map();
    for (const change of changes) {
        change.keys.forEach(key => keysSet.add(key));
        change.overrides.forEach(([identifier, keys]) => {
            const result = getOrSet(overridesMap, identifier, new Set());
            keys.forEach(key => result.add(key));
        });
    }
    const overrides = [];
    overridesMap.forEach((keys, identifier) => overrides.push([identifier, [...keys.values()]]));
    return { keys: [...keysSet.values()], overrides };
}
exports.mergeChanges = mergeChanges;
function mergeConfigProperties(obj) {
    let res = {};
    for (let key of Object.keys(obj)) {
        if (key.indexOf('.') == -1) {
            res[key] = obj[key];
        }
        else {
            let parts = key.split('.');
            let pre = res;
            let len = parts.length;
            for (let i = 0; i < len; i++) {
                let k = parts[i];
                if (i == len - 1) {
                    pre[k] = obj[key];
                }
                else {
                    pre[k] = pre[k] || {};
                    pre = pre[k];
                }
            }
        }
    }
    return res;
}
exports.mergeConfigProperties = mergeConfigProperties;
function convertErrors(content, errors) {
    let items = [];
    let document = vscode_languageserver_textdocument_1.TextDocument.create(documentUri, 'json', 0, content);
    for (let err of errors) {
        const range = vscode_languageserver_types_1.Range.create(document.positionAt(err.offset), document.positionAt(err.offset + err.length));
        items.push(vscode_languageserver_types_1.Diagnostic.create(range, (0, jsonc_parser_1.printParseErrorCode)(err.error), vscode_languageserver_types_1.DiagnosticSeverity.Error));
    }
    return items;
}
exports.convertErrors = convertErrors;
function toValuesTree(properties, conflictReporter, doExpand = false) {
    const root = Object.create(null);
    for (const key in properties) {
        addToValueTree(root, key, properties[key], conflictReporter, doExpand);
    }
    return root;
}
exports.toValuesTree = toValuesTree;
function addToValueTree(settingsTreeRoot, key, value, conflictReporter, doExpand = false) {
    const segments = key.split('.');
    const last = segments.pop();
    let curr = settingsTreeRoot;
    for (let i = 0; i < segments.length; i++) {
        const s = segments[i];
        let obj = curr[s];
        switch (typeof obj) {
            case 'undefined':
                obj = curr[s] = Object.create(null);
                break;
            case 'object':
                break;
            default:
                if (conflictReporter)
                    conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);
                return;
        }
        curr = obj;
    }
    if (typeof curr === 'object' && curr !== null) {
        if (doExpand) {
            curr[last] = expandObject(value);
        }
        else {
            curr[last] = value;
        }
    }
    else {
        if (conflictReporter)
            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
    }
}
exports.addToValueTree = addToValueTree;
function removeFromValueTree(valueTree, key) {
    const segments = key.split('.');
    doRemoveFromValueTree(valueTree, segments);
}
exports.removeFromValueTree = removeFromValueTree;
function doRemoveFromValueTree(valueTree, segments) {
    const first = segments.shift();
    if (segments.length === 0) {
        // Reached last segment
        delete valueTree[first];
        return;
    }
    if (Object.keys(valueTree).includes(first)) {
        const value = valueTree[first];
        if (typeof value === 'object' && !Array.isArray(value)) {
            doRemoveFromValueTree(value, segments);
            if (Object.keys(value).length === 0) {
                delete valueTree[first];
            }
        }
    }
}
function getConfigurationValue(config, settingPath, defaultValue) {
    function accessSetting(config, path) {
        let current = config;
        for (let i = 0; i < path.length; i++) {
            if (typeof current !== 'object' || current === null) {
                return undefined;
            }
            current = current[path[i]];
        }
        return current;
    }
    const path = settingPath.split('.');
    const result = accessSetting(config, path);
    return typeof result === 'undefined' ? defaultValue : result;
}
exports.getConfigurationValue = getConfigurationValue;
function toJSONObject(obj) {
    if (obj) {
        if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
        }
        else if (typeof obj === 'object') {
            const res = Object.create(null);
            for (const key in obj) {
                res[key] = toJSONObject(obj[key]);
            }
            return res;
        }
    }
    return obj;
}
exports.toJSONObject = toJSONObject;
/**
 * Compare too configuration contents
 */
function compareConfigurationContents(to, from) {
    const added = to
        ? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]
        : [];
    const removed = from
        ? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]
        : [];
    const updated = [];
    if (to && from) {
        for (const key of from.keys) {
            if (to.keys.indexOf(key) !== -1) {
                const value1 = getConfigurationValue(from.contents, key);
                const value2 = getConfigurationValue(to.contents, key);
                if (!(0, object_1.equals)(value1, value2)) {
                    updated.push(key);
                }
            }
        }
    }
    return { added, removed, updated };
}
exports.compareConfigurationContents = compareConfigurationContents;
function getDefaultValue(type) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const t = Array.isArray(type) ? type[0] : type;
    switch (t) {
        case 'boolean':
            return false;
        case 'integer':
        case 'number':
            return 0;
        case 'string':
            return '';
        case 'array':
            return [];
        case 'object':
            return {};
        default:
            return null;
    }
}
exports.getDefaultValue = getDefaultValue;
function lookUp(tree, key) {
    if (key) {
        if (tree && (0, object_1.hasOwnProperty)(tree, key))
            return tree[key];
        const parts = key.split('.');
        let node = tree;
        for (let i = 0; node && i < parts.length; i++) {
            node = node[parts[i]];
        }
        return node;
    }
    return tree;
}
exports.lookUp = lookUp;
//# sourceMappingURL=util.js.map