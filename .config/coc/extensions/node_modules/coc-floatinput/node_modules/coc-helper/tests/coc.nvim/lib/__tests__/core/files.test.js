"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const uuid_1 = require("uuid");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const editInspect_1 = require("../../model/editInspect");
const relativePattern_1 = tslib_1.__importDefault(require("../../model/relativePattern"));
const util_1 = require("../../util");
const fs_2 = require("../../util/fs");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importStar(require("../helper"));
let nvim;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
    disposables = [];
});
describe('RelativePattern', () => {
    function testThrow(fn) {
        let err;
        try {
            fn();
        }
        catch (e) {
            err = e;
        }
        expect(err).toBeDefined();
    }
    it('should throw for invalid arguments', async () => {
        testThrow(() => {
            new relativePattern_1.default('', undefined);
        });
        testThrow(() => {
            new relativePattern_1.default({ uri: undefined }, '');
        });
    });
    it('should create relativePattern', async () => {
        for (let base of [__filename, vscode_uri_1.URI.file(__filename), { uri: vscode_uri_1.URI.file(__dirname).toString(), name: 'test' }]) {
            let p = new relativePattern_1.default(base, '**/*');
            expect(vscode_uri_1.URI.isUri(p.baseUri)).toBe(true);
            expect(p.toJSON()).toBeDefined();
        }
    });
});
describe('findFiles()', () => {
    beforeEach(() => {
        workspace_1.default.workspaceFolderControl.setWorkspaceFolders([__dirname]);
    });
    it('should use glob pattern', async () => {
        let res = await workspace_1.default.findFiles('**/*.ts', undefined, 1);
        expect(res.length).toBeGreaterThan(0);
    });
    it('should use relativePattern', async () => {
        let relativePattern = new relativePattern_1.default(vscode_uri_1.URI.file(__dirname), '**/*.ts');
        let res = await workspace_1.default.findFiles(relativePattern);
        expect(res.length).toBeGreaterThan(0);
    });
    it('should respect exclude as glob pattern', async () => {
        let arr = await workspace_1.default.findFiles('**/*.ts', 'files*');
        let res = arr.find(o => path_1.default.relative(__dirname, o.fsPath).startsWith('files'));
        expect(res).toBeUndefined();
    });
    it('should respect exclude as relativePattern', async () => {
        let relativePattern = new relativePattern_1.default(vscode_uri_1.URI.file(__dirname), 'files*');
        let arr = await workspace_1.default.findFiles('**/*.ts', relativePattern);
        let res = arr.find(o => path_1.default.relative(__dirname, o.fsPath).startsWith('files'));
        expect(res).toBeUndefined();
        relativePattern = new relativePattern_1.default(vscode_uri_1.URI.file(path_1.default.join(__dirname, 'foo')), '**/*.ts');
        arr = await workspace_1.default.findFiles('**/*.ts', relativePattern, 1);
        expect(arr.length).toBe(1);
    });
    it('should respect maxResults', async () => {
        let arr = await workspace_1.default.findFiles('**/*.ts', undefined, 1);
        expect(arr.length).toBe(1);
    });
    it('should respect token', async () => {
        let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        source.cancel();
        let arr = await workspace_1.default.findFiles('**/*.ts', undefined, 2, source.token);
        expect(arr.length).toBe(0);
    });
    it('should cancel findFiles', async () => {
        let source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let p = workspace_1.default.findFiles('**/*.ts', undefined, undefined, source.token);
        source.cancel();
        let arr = await p;
        expect(arr.length).toBe(0);
    });
});
describe('applyEdits()', () => {
    it('should not throw when unable to undo & redo', async () => {
        await commands_1.default.executeCommand('workspace.undo');
        await commands_1.default.executeCommand('workspace.redo');
    });
    it('should throw for unsupported scheme', () => {
        expect(() => {
            let edit = vscode_languageserver_types_1.TextDocumentEdit.create({ uri: 'lsp:/1', version: 1 }, [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), ' ')]);
            workspace_1.default.files.validateChanges([edit]);
        }).toThrow(Error);
        expect(() => {
            let edit = vscode_languageserver_types_1.TextDocumentEdit.create({ uri: 'lsp:/1', version: null }, [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), ' ')]);
            workspace_1.default.files.validateChanges([edit]);
        }).toThrow(Error);
        let rename = vscode_languageserver_types_1.RenameFile.create('lsp:/1', 'lsp:/2');
        expect(() => {
            workspace_1.default.files.validateChanges([rename]);
        }).toThrow(Error);
    });
    it('should show error when document with version not loaded', async () => {
        let uri = 'lsptest:///file';
        let versioned = vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(uri, 1);
        let edit = vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar');
        let change = vscode_languageserver_types_1.TextDocumentEdit.create(versioned, [edit]);
        let workspaceEdit = {
            documentChanges: [change]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(false);
        let line = await helper_1.default.getCmdline();
        expect(line).toMatch('Error');
    });
    it('should apply TextEdit of documentChanges', async () => {
        let doc = await helper_1.default.createDocument();
        let versioned = vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(doc.uri, doc.version);
        let edit = vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar');
        let change = vscode_languageserver_types_1.TextDocumentEdit.create(versioned, [edit]);
        let workspaceEdit = {
            documentChanges: [change]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        let line = await nvim.getLine();
        expect(line).toBe('bar');
        await nvim.command('bd!');
        await workspace_1.default.files.undoWorkspaceEdit();
    });
    it('should apply edit with out change buffers', async () => {
        let doc = await helper_1.default.createDocument();
        await nvim.setLine('bar');
        await doc.synchronize();
        let version = doc.version;
        let versioned = vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(doc.uri, doc.version);
        let edit = vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(0, 0, 0, 3), 'bar');
        let change = vscode_languageserver_types_1.TextDocumentEdit.create(versioned, [edit]);
        let workspaceEdit = {
            documentChanges: [change]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        expect(doc.version).toBe(version);
    });
    it('should not apply TextEdit if version miss match', async () => {
        let doc = await helper_1.default.createDocument();
        let versioned = vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(doc.uri, 10);
        let edit = vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar');
        let change = vscode_languageserver_types_1.TextDocumentEdit.create(versioned, [edit]);
        let workspaceEdit = {
            documentChanges: [change]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(false);
    });
    it('should apply edits with changes to buffer', async () => {
        let doc = await helper_1.default.createDocument();
        let changes = {
            [doc.uri]: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar')]
        };
        let workspaceEdit = { changes };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        let line = await nvim.getLine();
        expect(line).toBe('bar');
    });
    it('should apply edits with changes to file not in buffer list', async () => {
        let filepath = await (0, helper_1.createTmpFile)('bar');
        let uri = vscode_uri_1.URI.file(filepath).toString();
        let changes = {
            [uri]: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo')]
        };
        let res = await workspace_1.default.applyEdit({ changes });
        expect(res).toBe(true);
        let doc = workspace_1.default.getDocument(uri);
        let content = doc.getDocumentContent();
        expect(content).toMatch(/^foobar/);
        await nvim.command('silent! %bwipeout!');
    });
    it('should apply edits when file does not exist', async () => {
        let filepath = path_1.default.join(__dirname, 'not_exists');
        disposables.push({
            dispose: () => {
                if (fs_1.default.existsSync(filepath)) {
                    fs_1.default.unlinkSync(filepath);
                }
            }
        });
        let uri = vscode_uri_1.URI.file(filepath).toString();
        let changes = {
            [uri]: [vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo')]
        };
        let res = await workspace_1.default.applyEdit({ changes });
        expect(res).toBe(true);
    });
    it('should adjust cursor position after applyEdits', async () => {
        let doc = await helper_1.default.createDocument();
        let pos = await window_1.default.getCursorPosition();
        expect(pos).toEqual({ line: 0, character: 0 });
        let edit = vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo\n');
        let versioned = vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(doc.uri, null);
        let documentChanges = [vscode_languageserver_types_1.TextDocumentEdit.create(versioned, [edit])];
        let res = await workspace_1.default.applyEdit({ documentChanges });
        expect(res).toBe(true);
        pos = await window_1.default.getCursorPosition();
        expect(pos).toEqual({ line: 1, character: 0 });
    });
    it('should throw when waitUntil is not synchronize', async () => {
        let err;
        workspace_1.default.onWillCreateFiles(e => {
            setTimeout(() => {
                try {
                    e.waitUntil(Promise.resolve());
                }
                catch (e) {
                    err = e;
                }
            }, 0);
        }, null, disposables);
        let file = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        await workspace_1.default.createFile(file, { overwrite: true });
        expect(err).toBeDefined();
        fs_1.default.rmSync(file, { force: true });
    });
    it('should support null version of documentChanges', async () => {
        let file = path_1.default.join(__dirname, 'foo');
        await workspace_1.default.createFile(file, { ignoreIfExists: true, overwrite: true });
        let uri = vscode_uri_1.URI.file(file).toString();
        let versioned = vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(uri, null);
        let edit = vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar');
        let change = vscode_languageserver_types_1.TextDocumentEdit.create(versioned, [edit]);
        let workspaceEdit = {
            documentChanges: [change]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        await nvim.command('wa');
        let content = await (0, fs_2.readFile)(file, 'utf8');
        expect(content).toMatch(/^bar/);
        await workspace_1.default.deleteFile(file, { ignoreIfNotExists: true });
    });
    it('should support CreateFile edit', async () => {
        let file = path_1.default.join(__dirname, 'foo');
        let uri = vscode_uri_1.URI.file(file).toString();
        let workspaceEdit = {
            documentChanges: [vscode_languageserver_types_1.CreateFile.create(uri, { overwrite: true })]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        await workspace_1.default.deleteFile(file, { ignoreIfNotExists: true });
    });
    it('should support DeleteFile edit', async () => {
        let file = path_1.default.join(__dirname, 'foo');
        await workspace_1.default.createFile(file, { ignoreIfExists: true, overwrite: true });
        let uri = vscode_uri_1.URI.file(file).toString();
        let workspaceEdit = {
            documentChanges: [vscode_languageserver_types_1.DeleteFile.create(uri)]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
    });
    it('should check uri for CreateFile edit', async () => {
        let workspaceEdit = {
            documentChanges: [vscode_languageserver_types_1.CreateFile.create('term://.', { overwrite: true })]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(false);
    });
    it('should support RenameFile edit', async () => {
        let file = path_1.default.join(__dirname, 'foo');
        await workspace_1.default.createFile(file, { ignoreIfExists: true, overwrite: true });
        let newFile = path_1.default.join(__dirname, 'bar');
        let uri = vscode_uri_1.URI.file(file).toString();
        let workspaceEdit = {
            documentChanges: [vscode_languageserver_types_1.RenameFile.create(uri, vscode_uri_1.URI.file(newFile).toString())]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        await workspace_1.default.deleteFile(newFile, { ignoreIfNotExists: true });
    });
    it('should support changes with edit and rename', async () => {
        let fsPath = await (0, helper_1.createTmpFile)('test');
        let doc = await helper_1.default.createDocument(fsPath);
        let newFile = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}/new-${(0, uuid_1.v4)()}`);
        let newUri = vscode_uri_1.URI.file(newFile).toString();
        let edit = {
            documentChanges: [
                {
                    textDocument: {
                        version: null,
                        uri: doc.uri,
                    },
                    edits: [
                        {
                            range: {
                                start: {
                                    line: 0,
                                    character: 0
                                },
                                end: {
                                    line: 0,
                                    character: 4
                                }
                            },
                            newText: 'bar'
                        }
                    ]
                },
                {
                    oldUri: doc.uri,
                    newUri,
                    kind: 'rename'
                }
            ]
        };
        let res = await workspace_1.default.applyEdit(edit);
        expect(res).toBe(true);
        let curr = await workspace_1.default.document;
        expect(curr.uri).toBe(newUri);
        expect(curr.getline(0)).toBe('bar');
        let line = await nvim.line;
        expect(line).toBe('bar');
    });
    it('should support edit new file with CreateFile', async () => {
        let file = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        let uri = vscode_uri_1.URI.file(file).toString();
        let workspaceEdit = {
            documentChanges: [
                vscode_languageserver_types_1.CreateFile.create(uri, { overwrite: true }),
                vscode_languageserver_types_1.TextDocumentEdit.create({ uri, version: 0 }, [
                    vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo bar')
                ])
            ]
        };
        let res = await workspace_1.default.applyEdit(workspaceEdit);
        expect(res).toBe(true);
        let doc = workspace_1.default.getDocument(uri);
        expect(doc).toBeDefined();
        let line = doc.getline(0);
        expect(line).toBe('foo bar');
        await workspace_1.default.deleteFile(file, { ignoreIfNotExists: true });
    });
    it('should undo and redo workspace edit', async () => {
        const folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        const pathone = path_1.default.join(folder, 'a');
        const pathtwo = path_1.default.join(folder, 'b');
        await workspace_1.default.files.createFile(pathone, { overwrite: true });
        await workspace_1.default.files.createFile(pathtwo, { overwrite: true });
        let uris = [vscode_uri_1.URI.file(pathone).toString(), vscode_uri_1.URI.file(pathtwo).toString()];
        const assertContent = (one, two) => {
            let doc = workspace_1.default.getDocument(uris[0]);
            expect(doc.getDocumentContent()).toBe(one);
            doc = workspace_1.default.getDocument(uris[1]);
            expect(doc.getDocumentContent()).toBe(two);
        };
        let edits = [];
        edits.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: uris[0], version: null }, [
            vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'foo')
        ]));
        edits.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: uris[1], version: null }, [
            vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(0, 0), 'bar')
        ]));
        await workspace_1.default.applyEdit({ documentChanges: edits });
        assertContent('foo\n', 'bar\n');
        await workspace_1.default.files.undoWorkspaceEdit();
        assertContent('\n', '\n');
        await workspace_1.default.files.redoWorkspaceEdit();
        assertContent('foo\n', 'bar\n');
    });
    it('should should support annotations', async () => {
        async function assertEdit(confirm, description) {
            let doc = await helper_1.default.createDocument((0, uuid_1.v4)());
            let edit = {
                documentChanges: [
                    {
                        textDocument: { version: doc.version, uri: doc.uri },
                        edits: [
                            {
                                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                                newText: 'bar',
                                annotationId: '85bc78e2-5ef0-4949-b10c-13f476faf430'
                            }
                        ]
                    },
                ],
                changeAnnotations: {
                    '85bc78e2-5ef0-4949-b10c-13f476faf430': {
                        needsConfirmation: true,
                        label: 'Text changes',
                        description
                    }
                }
            };
            let p = workspace_1.default.files.applyEdit(edit);
            await helper_1.default.waitPrompt();
            if (confirm) {
                await nvim.input('<cr>');
            }
            else {
                await nvim.input('<esc>');
            }
            await p;
            let content = doc.getDocumentContent();
            if (confirm) {
                expect(content).toBe('bar\n');
            }
            else {
                expect(content).toBe('\n');
            }
        }
        await assertEdit(true, 'description');
        await assertEdit(false, undefined);
    });
});
describe('getOriginalLine', () => {
    it('should get original line', async () => {
        let item = { index: 0, filepath: '' };
        expect((0, editInspect_1.getOriginalLine)(item, undefined)).toBeUndefined();
        expect((0, editInspect_1.getOriginalLine)({ index: 0, filepath: '', lnum: 1 }, undefined)).toBe(1);
        let doc = await helper_1.default.createDocument();
        let change = {
            textDocument: { version: doc.version, uri: doc.uri },
            edits: [
                {
                    range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                    newText: 'bar',
                }
            ]
        };
        expect((0, editInspect_1.getOriginalLine)({ index: 0, filepath: '', lnum: 1 }, change)).toBe(1);
    });
    describe('inspectEdit', () => {
        async function inspect(edit) {
            await workspace_1.default.applyEdit(edit);
            await commands_1.default.executeCommand('workspace.inspectEdit');
            let buf = await nvim.buffer;
            return buf;
        }
        it('should show wanring when edit not exists', async () => {
            workspace_1.default.files.editState = undefined;
            await workspace_1.default.files.inspectEdit();
        });
        it('should render with changes', async () => {
            let fsPath = await (0, helper_1.createTmpFile)('foo\n1\n2\nbar');
            let doc = await helper_1.default.createDocument(fsPath);
            let newFile = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}/new-${(0, uuid_1.v4)()}`);
            let newUri = vscode_uri_1.URI.file(newFile).toString();
            let createFile = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}/create-${(0, uuid_1.v4)()}`);
            let deleteFile = await (0, helper_1.createTmpFile)('delete');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(newFile))
                    fs_1.default.unlinkSync(newFile);
                if (fs_1.default.existsSync(createFile))
                    fs_1.default.unlinkSync(createFile);
                if (fs_1.default.existsSync(deleteFile))
                    fs_1.default.unlinkSync(deleteFile);
            }));
            let edit = {
                documentChanges: [
                    {
                        textDocument: { version: null, uri: doc.uri, },
                        edits: [
                            vscode_languageserver_types_1.TextEdit.del(vscode_languageserver_types_1.Range.create(0, 0, 1, 0)),
                            vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(3, 0, 3, 3), 'xyz'),
                        ]
                    },
                    {
                        kind: 'rename',
                        oldUri: doc.uri,
                        newUri
                    }, {
                        kind: 'create',
                        uri: vscode_uri_1.URI.file(createFile).toString()
                    }, {
                        kind: 'delete',
                        uri: vscode_uri_1.URI.file(deleteFile).toString()
                    }
                ]
            };
            let buf = await inspect(edit);
            let lines = await buf.lines;
            let content = lines.join('\n');
            expect(content).toMatch('Change');
            expect(content).toMatch('Rename');
            expect(content).toMatch('Create');
            expect(content).toMatch('Delete');
            await nvim.command('exe 5');
            await nvim.input('<CR>');
            await helper_1.default.waitFor('expand', ['%:p'], newFile);
            let line = await nvim.call('line', ['.']);
            expect(line).toBe(3);
        });
        it('should render annotation label', async () => {
            let doc = await helper_1.default.createDocument((0, uuid_1.v4)());
            let edit = {
                documentChanges: [
                    {
                        textDocument: { version: doc.version, uri: doc.uri },
                        edits: [
                            {
                                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                                newText: 'bar',
                                annotationId: 'dd866f37-a24c-4503-9c35-c139fb28e25b'
                            }
                        ]
                    }, {
                        textDocument: { version: 1, uri: doc.uri },
                        edits: [
                            {
                                range: vscode_languageserver_types_1.Range.create(0, 0, 0, 0),
                                newText: 'bar',
                                annotationId: '9468b9bf-97b6-4b37-b21f-aba8df3ce658'
                            }
                        ]
                    }
                ],
                changeAnnotations: {
                    'dd866f37-a24c-4503-9c35-c139fb28e25b': {
                        needsConfirmation: false,
                        label: 'Text changes'
                    }
                }
            };
            let buf = await inspect(edit);
            await events_1.default.fire('BufUnload', [buf.id + 1]);
            let winid = await nvim.call('win_getid');
            let lines = await buf.lines;
            expect(lines[0]).toBe('Text changes');
            await nvim.command('exe 1');
            await nvim.input('<CR>');
            let bufnr = await nvim.call('bufnr', ['%']);
            expect(bufnr).toBe(buf.id);
            await nvim.command('exe 3');
            await nvim.input('<CR>');
            let fsPath = vscode_uri_1.URI.parse(doc.uri).fsPath;
            await helper_1.default.waitFor('expand', ['%:p'], fsPath);
            await nvim.call('win_gotoid', [winid]);
            await nvim.input('<esc>');
            await helper_1.default.wait(10);
        });
    });
    describe('createFile()', () => {
        it('should create and revert parent folder', async () => {
            const folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            const filepath = path_1.default.join(folder, 'a/b/bar');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                fs_1.default.rmSync(folder, { recursive: true, force: true });
            }));
            let fns = [];
            expect(fs_1.default.existsSync(folder)).toBe(false);
            await workspace_1.default.files.createFile(filepath, {}, fns);
            expect(fs_1.default.existsSync(filepath)).toBe(true);
            for (let i = fns.length - 1; i >= 0; i--) {
                await fns[i]();
            }
            expect(fs_1.default.existsSync(folder)).toBe(false);
        });
        it('should throw when file already exists', async () => {
            let filepath = await (0, helper_1.createTmpFile)('foo', disposables);
            let fn = async () => {
                await workspace_1.default.createFile(filepath, {});
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should not create file if file exists with ignoreIfExists', async () => {
            let file = await (0, helper_1.createTmpFile)('foo');
            await workspace_1.default.createFile(file, { ignoreIfExists: true });
            let content = fs_1.default.readFileSync(file, 'utf8');
            expect(content).toBe('foo');
        });
        it('should create file if does not exist', async () => {
            await helper_1.default.edit();
            let filepath = path_1.default.join(__dirname, 'foo');
            await workspace_1.default.createFile(filepath, { ignoreIfExists: true });
            let exists = fs_1.default.existsSync(filepath);
            expect(exists).toBe(true);
            fs_1.default.unlinkSync(filepath);
        });
        it('should revert file create', async () => {
            let filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(filepath))
                    fs_1.default.unlinkSync(filepath);
            }));
            let fns = [];
            await workspace_1.default.files.createFile(filepath, { overwrite: true }, fns);
            expect(fs_1.default.existsSync(filepath)).toBe(true);
            let bufnr = await nvim.call('bufnr', [filepath]);
            expect(bufnr).toBeGreaterThan(0);
            let doc = workspace_1.default.getDocument(bufnr);
            expect(doc).toBeDefined();
            for (let fn of fns) {
                await fn();
            }
            expect(fs_1.default.existsSync(filepath)).toBe(false);
            let loaded = await nvim.call('bufloaded', [filepath]);
            expect(loaded).toBe(0);
        });
    });
    describe('renameFile', () => {
        it('should throw when oldPath not exists', async () => {
            await workspace_1.default.renameFile('/foo', '/foo');
            await workspace_1.default.renameFile('/foo', __filename, { ignoreIfExists: true });
            let filepath = path_1.default.join(__dirname, 'not_exists_file');
            let newPath = path_1.default.join(__dirname, 'bar');
            let fn = async () => {
                await workspace_1.default.renameFile(filepath, newPath);
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should throw when new path exits and not overwrite', async () => {
            await expect(async () => {
                await workspace_1.default.renameFile('/foo', __filename, {});
            }).rejects.toThrow(/exists/);
        });
        it('should rename file on disk', async () => {
            let filepath = await (0, helper_1.createTmpFile)('test');
            let newPath = path_1.default.join(path_1.default.dirname(filepath), 'new_file');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(newPath))
                    fs_1.default.unlinkSync(newPath);
                if (fs_1.default.existsSync(filepath))
                    fs_1.default.unlinkSync(filepath);
            }));
            let fns = [];
            await workspace_1.default.files.renameFile(filepath, newPath, { overwrite: true }, fns);
            expect(fs_1.default.existsSync(newPath)).toBe(true);
            for (let fn of fns) {
                await fn();
            }
            expect(fs_1.default.existsSync(newPath)).toBe(false);
            expect(fs_1.default.existsSync(filepath)).toBe(true);
        });
        it('should rename if file does not exist', async () => {
            let filepath = path_1.default.join(__dirname, 'foo');
            let newPath = path_1.default.join(__dirname, 'bar');
            await workspace_1.default.createFile(filepath);
            await workspace_1.default.renameFile(filepath, newPath);
            expect(fs_1.default.existsSync(newPath)).toBe(true);
            expect(fs_1.default.existsSync(filepath)).toBe(false);
            fs_1.default.unlinkSync(newPath);
        });
        it('should rename current buffer with same bufnr', async () => {
            let file = await (0, helper_1.createTmpFile)('test');
            let doc = await helper_1.default.createDocument(file);
            await nvim.setLine('bar');
            await doc.patchChange();
            let newFile = path_1.default.join(os_1.default.tmpdir(), `coc-${process.pid}/new-${(0, uuid_1.v4)()}`);
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(newFile))
                    fs_1.default.unlinkSync(newFile);
            }));
            await workspace_1.default.renameFile(file, newFile);
            let bufnr = await nvim.call('bufnr', ['%']);
            expect(bufnr).toBe(doc.bufnr);
            let line = await nvim.line;
            expect(line).toBe('bar');
            let exists = fs_1.default.existsSync(newFile);
            expect(exists).toBe(true);
        });
        it('should overwrite if file exists', async () => {
            let filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            let newPath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            await workspace_1.default.createFile(filepath);
            await workspace_1.default.createFile(newPath);
            await workspace_1.default.renameFile(filepath, newPath, { overwrite: true });
            expect(fs_1.default.existsSync(newPath)).toBe(true);
            expect(fs_1.default.existsSync(filepath)).toBe(false);
            fs_1.default.unlinkSync(newPath);
        });
        it('should rename buffer in directory and revert', async () => {
            let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            let newFolder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_1.default.mkdirSync(folder);
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                fs_1.default.rmSync(folder, { recursive: true, force: true });
                fs_1.default.rmSync(newFolder, { recursive: true, force: true });
            }));
            let filepath = path_1.default.join(folder, 'new_file');
            await workspace_1.default.createFile(filepath);
            let bufnr = await nvim.call('bufnr', [filepath]);
            expect(bufnr).toBeGreaterThan(0);
            let fns = [];
            await workspace_1.default.files.renameFile(folder, newFolder, { overwrite: true }, fns);
            bufnr = await nvim.call('bufnr', [path_1.default.join(newFolder, 'new_file')]);
            expect(bufnr).toBeGreaterThan(0);
            for (let i = fns.length - 1; i >= 0; i--) {
                await fns[i]();
            }
            bufnr = await nvim.call('bufnr', [filepath]);
            expect(bufnr).toBeGreaterThan(0);
        });
    });
    describe('loadResource()', () => {
        it('should load file as hidden buffer', async () => {
            helper_1.default.updateConfiguration('workspace.openResourceCommand', '');
            let filepath = await (0, helper_1.createTmpFile)('foo');
            let uri = vscode_uri_1.URI.file(filepath).toString();
            let doc = await workspace_1.default.files.loadResource(uri);
            let bufnrs = await nvim.call('coc#window#bufnrs');
            expect(bufnrs.indexOf(doc.bufnr)).toBe(-1);
        });
    });
    describe('deleteFile()', () => {
        it('should throw when file not exists', async () => {
            let filepath = path_1.default.join(__dirname, 'not_exists');
            let fn = async () => {
                await workspace_1.default.deleteFile(filepath);
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should ignore when ignoreIfNotExists set', async () => {
            let filepath = path_1.default.join(__dirname, 'not_exists');
            let fns = [];
            await workspace_1.default.files.deleteFile(filepath, { ignoreIfNotExists: true }, fns);
            expect(fns.length).toBe(0);
        });
        it('should unload loaded buffer', async () => {
            let filepath = await (0, helper_1.createTmpFile)('file to delete');
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(filepath))
                    fs_1.default.unlinkSync(filepath);
            }));
            await workspace_1.default.files.loadResource(vscode_uri_1.URI.file(filepath).toString());
            let fns = [];
            await workspace_1.default.files.deleteFile(filepath, {}, fns);
            let loaded = await nvim.call('bufloaded', [filepath]);
            expect(loaded).toBe(0);
            for (let i = fns.length - 1; i >= 0; i--) {
                await fns[i]();
            }
            expect(fs_1.default.existsSync(filepath)).toBe(true);
            loaded = await nvim.call('bufloaded', [filepath]);
            expect(loaded).toBe(1);
        });
        it('should delete and recover folder', async () => {
            let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                if (fs_1.default.existsSync(folder))
                    fs_1.default.rmdirSync(folder);
            }));
            fs_1.default.mkdirSync(folder);
            expect(fs_1.default.existsSync(folder)).toBe(true);
            let fns = [];
            await workspace_1.default.files.deleteFile(folder, {}, fns);
            expect(fs_1.default.existsSync(folder)).toBe(false);
            for (let i = fns.length - 1; i >= 0; i--) {
                await fns[i]();
            }
            expect(fs_1.default.existsSync(folder)).toBe(true);
            await workspace_1.default.files.deleteFile(folder, {});
        });
        it('should delete and recover folder recursive', async () => {
            let folder = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            disposables.push(vscode_languageserver_protocol_1.Disposable.create(() => {
                fs_1.default.rmSync(folder, { recursive: true, force: true });
            }));
            fs_1.default.mkdirSync(folder);
            fs_1.default.writeFileSync(path_1.default.join(folder, 'new_file'), '', 'utf8');
            let fns = [];
            await workspace_1.default.files.deleteFile(folder, { recursive: true }, fns);
            expect(fs_1.default.existsSync(folder)).toBe(false);
            for (let i = fns.length - 1; i >= 0; i--) {
                await fns[i]();
            }
            expect(fs_1.default.existsSync(folder)).toBe(true);
            expect(fs_1.default.existsSync(path_1.default.join(folder, 'new_file'))).toBe(true);
            await workspace_1.default.files.deleteFile(folder, { recursive: true });
        });
        it('should delete file if exists', async () => {
            let filepath = path_1.default.join(__dirname, 'foo');
            await workspace_1.default.createFile(filepath);
            expect(fs_1.default.existsSync(filepath)).toBe(true);
            await workspace_1.default.deleteFile(filepath);
            expect(fs_1.default.existsSync(filepath)).toBe(false);
        });
    });
    describe('loadFile()', () => {
        it('should single loadFile', async () => {
            let doc = await helper_1.default.createDocument();
            let newFile = vscode_uri_1.URI.file(path_1.default.join(__dirname, 'abc')).toString();
            let document = await workspace_1.default.loadFile(newFile);
            let bufnr = await nvim.call('bufnr', '%');
            expect(document.uri.endsWith('abc')).toBe(true);
            expect(bufnr).toBe(doc.bufnr);
        });
    });
    describe('loadFiles', () => {
        it('should loadFiles', async () => {
            let files = ['a', 'b', 'c'].map(key => vscode_uri_1.URI.file(path_1.default.join(__dirname, key)).toString());
            let docs = await workspace_1.default.loadFiles(files);
            let uris = docs.map(o => o.uri);
            expect(uris).toEqual(files);
            await workspace_1.default.loadFiles([]);
        });
        it('should load uri', async () => {
            let res = await workspace_1.default.loadFiles(['deno:/foo']);
            expect(res[0].uri).toBe('deno:/foo');
        });
    });
    describe('openTextDocument()', () => {
        it('should open document already exists', async () => {
            let doc = await helper_1.default.createDocument('a');
            await nvim.command('enew');
            await workspace_1.default.openTextDocument(vscode_uri_1.URI.parse(doc.uri));
            let curr = await workspace_1.default.document;
            expect(curr.uri).toBe(doc.uri);
        });
        it('should throw when file does not exist', async () => {
            let err;
            try {
                await workspace_1.default.openTextDocument('/a/b/c');
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeDefined();
        });
        it('should open untitled document', async () => {
            let doc = await workspace_1.default.openTextDocument(vscode_uri_1.URI.parse(`untitled:///a/b.js`));
            expect(doc.uri).toBe('file:///a/b.js');
        });
        it('should load file that exists', async () => {
            let doc = await workspace_1.default.openTextDocument(vscode_uri_1.URI.file(__filename));
            expect(vscode_uri_1.URI.parse(doc.uri).fsPath).toBe(__filename);
            let curr = await workspace_1.default.document;
            expect(curr.uri).toBe(doc.uri);
        });
    });
});
//# sourceMappingURL=files.test.js.map