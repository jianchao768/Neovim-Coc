'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
const tslib_1 = require("tslib");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
const UUID = tslib_1.__importStar(require("./utils/uuid"));
class DidOpenTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, _syncedDocuments) {
        super(client, workspace_1.default.onDidOpenTextDocument, protocol_1.DidOpenTextDocumentNotification.type, 'didOpen', textDocument => cv.asOpenTextDocumentParams(textDocument), features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get registrationType() {
        return protocol_1.DidOpenTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector }
            });
        }
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector)
            return;
        workspace_1.default.textDocuments.forEach(textDocument => {
            let uri = textDocument.uri;
            if (this._syncedDocuments.has(uri))
                return;
            void this.callback(textDocument);
        });
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
class DidCloseTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, _syncedDocuments) {
        super(client, workspace_1.default.onDidCloseTextDocument, protocol_1.DidCloseTextDocumentNotification.type, 'didClose', textDocument => cv.asCloseTextDocumentParams(textDocument), features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get registrationType() {
        return protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.openClose) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector }
            });
        }
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        if (!selector)
            return;
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach(textDocument => {
            if (workspace_1.default.match(selector, textDocument) > 0 &&
                !this._selectorFilter(selectors, textDocument)) {
                let middleware = this._client.middleware;
                let didClose = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                let promise = middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument);
                if (promise) {
                    promise.catch(error => {
                        this._client.error(`Sending document notification ${this._type.method} failed`, error);
                    });
                }
            }
        });
    }
}
exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
class DidChangeTextDocumentFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._changeData = new Map();
        this._onNotificationSent = new protocol_1.Emitter();
    }
    *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
            yield data.documentSelector;
        }
    }
    get registrationType() {
        return protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.change !== undefined &&
            textDocumentSyncOptions.change !== protocol_1.TextDocumentSyncKind.None) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector)
            return;
        if (!this._listener) {
            this._listener = workspace_1.default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / undirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        let doc = workspace_1.default.getDocument(event.textDocument.uri);
        let { textDocument } = doc;
        const promises = [];
        for (const changeData of this._changeData.values()) {
            if (workspace_1.default.match(changeData.documentSelector, textDocument) > 0) {
                let middleware = this._client.middleware;
                let promise;
                let didChange;
                if (changeData.syncKind === protocol_1.TextDocumentSyncKind.Incremental) {
                    didChange = async (event) => {
                        const params = cv.asChangeTextDocumentParams(event);
                        await this._client.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, params);
                        this.notificationSent(event, protocol_1.DidChangeTextDocumentNotification.type, params);
                    };
                }
                else if (changeData.syncKind === protocol_1.TextDocumentSyncKind.Full) {
                    didChange = async (event) => {
                        const params = cv.asFullChangeTextDocumentParams(textDocument);
                        await this._client.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, params);
                        this.notificationSent(event, protocol_1.DidChangeTextDocumentNotification.type, params);
                    };
                }
                else {
                    didChange = () => Promise.resolve(undefined);
                }
                promise = middleware.didChange ? middleware.didChange(event, didChange) : didChange(event);
                if (promise)
                    promises.push(promise);
            }
        }
        return Promise.all(promises).then(undefined, error => {
            this._client.error(`Sending document notification ${protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
            throw error;
        });
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
    }
    unregister(id) {
        this._changeData.delete(id);
    }
    dispose() {
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (workspace_1.default.match(changeData.documentSelector, document) > 0) {
                return {
                    send: (event) => {
                        return this.callback(event);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
class WillSaveFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, workspace_1.default.onWillSaveTextDocument, protocol_1.WillSaveTextDocumentNotification.type, 'willSave', willSaveEvent => cv.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
        return protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.willSave) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector }
            });
        }
    }
}
exports.WillSaveFeature = WillSaveFeature;
class WillSaveWaitUntilFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._selectors = new Map();
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    get registrationType() {
        return protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector &&
            documentSelector.length > 0 &&
            textDocumentSyncOptions &&
            textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector }
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = workspace_1.default.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document)) {
            let middleware = this._client.middleware;
            let willSaveWaitUntil = (event) => {
                return this.sendRequest(protocol_1.WillSaveTextDocumentWaitUntilRequest.type, cv.asWillSaveTextDocumentParams(event), protocol_1.CancellationToken.None);
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
class DidSaveTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, workspace_1.default.onDidSaveTextDocument, protocol_1.DidSaveTextDocumentNotification.type, 'didSave', textDocument => cv.asSaveTextDocumentParams(textDocument, this._includeText), features_1.TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
    }
    get registrationType() {
        return protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === 'boolean'
                ? { includeText: false }
                : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector }, saveOptions)
            });
        }
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
}
exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
//# sourceMappingURL=textSynchronization.js.map