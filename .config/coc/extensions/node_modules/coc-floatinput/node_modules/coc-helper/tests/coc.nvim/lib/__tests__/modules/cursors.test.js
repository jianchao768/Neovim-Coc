"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const session_1 = require("../../cursors/session");
const textRange_1 = tslib_1.__importDefault(require("../../cursors/textRange"));
const util_1 = require("../../cursors/util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const window_1 = tslib_1.__importDefault(require("../../window"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const commands_1 = tslib_1.__importDefault(require("../../commands"));
let nvim;
let cursors;
let ns;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    ns = await nvim.createNamespace('coc-cursors');
    cursors = window_1.default.cursors;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    nvim.pauseNotification();
    cursors.reset();
    await nvim.resumeNotification();
    await helper_1.default.reset();
});
async function rangeCount() {
    let buf = await nvim.buffer;
    let markers = await buf.getExtMarks(ns, 0, -1);
    return markers.length;
}
describe('cursors', () => {
    describe('surrondChanges()', () => {
        it('should check surrond changes', async () => {
            expect((0, session_1.surrondChanges)([], 0)).toBe(false);
            expect((0, session_1.surrondChanges)([{ offset: 1, add: 'f' }, { offset: 3, add: 'f' }], 0)).toBe(false);
        });
    });
    describe('getDelta()', () => {
        it('should get delta count', async () => {
            expect((0, util_1.getDelta)({ prepend: [1, 'foo'], append: [1, 'bar'] })).toBe(4);
            expect((0, util_1.getDelta)({ offset: 0, remove: 2, insert: 'foo' })).toBe(1);
        });
    });
    describe('getChange()', () => {
        it('should get surrond change', async () => {
            const getText = (newText) => {
                let r = new textRange_1.default(0, 0, 'foo');
                let res = (0, util_1.getChange)(r, vscode_languageserver_types_1.Range.create(0, 0, 0, 3), newText);
                expect((0, util_1.isSurrondChange)(res)).toBe(true);
                r.applySurrondChange(res);
                return r.text;
            };
            expect(getText('"foo"')).toBe('"foo"');
            expect(getText('o')).toBe('o');
            expect(getText('')).toBe('');
        });
        it('should get end change', async () => {
            const getText = (character, newText) => {
                let start = vscode_languageserver_types_1.Position.create(0, character);
                let r = new textRange_1.default(0, 0, 'foo');
                let res = (0, util_1.getChange)(r, vscode_languageserver_types_1.Range.create(start, r.range.end), newText);
                expect((0, util_1.isTextChange)(res)).toBe(true);
                r.applyTextChange(res);
                return r.text;
            };
            expect(getText(3, 'bar')).toBe('foobar');
            expect(getText(1, '')).toBe('f');
            expect(getText(2, 'ba')).toBe('foba');
        });
        it('should get normal change', async () => {
            const getText = (start, end, newText) => {
                let r = new textRange_1.default(0, 0, 'foo');
                let res = (0, util_1.getChange)(r, vscode_languageserver_types_1.Range.create(0, start, 0, end), newText);
                expect((0, util_1.isTextChange)(res)).toBe(true);
                r.applyTextChange(res);
                return r.text;
            };
            expect(getText(0, 0, 'a')).toBe('afoo');
            expect(getText(0, 1, '')).toBe('oo');
            expect(getText(0, 2, 'ba')).toBe('bao');
        });
    });
    describe('cancel()', () => {
        it('should cancel cursors session', async () => {
            cursors.cancel(999);
            let doc = await workspace_1.default.document;
            cursors.cancel(doc.bufnr);
            await nvim.call('setline', [1, ['a', 'b']]);
            await nvim.call('cursor', [1, 1]);
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'position', 'n');
            let activated = await cursors.isActivated();
            expect(activated).toBe(true);
            cursors.cancel(doc.bufnr);
            activated = await cursors.isActivated();
            expect(activated).toBe(false);
        });
    });
    describe('select()', () => {
        it('should throw with unsupported kind', async () => {
            let doc = await workspace_1.default.document;
            let fn = async () => {
                await cursors.select(doc.bufnr, 'undefined', 'n');
            };
            await expect(fn()).rejects.toThrow(/not supported/);
        });
        it('should select by position', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['a', 'b']]);
            await nvim.call('cursor', [1, 1]);
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'position', 'n');
            let n = await rangeCount();
            expect(n).toBe(1);
            await nvim.setOption('virtualedit', 'onemore');
            await nvim.call('cursor', [2, 2]);
            await cursors.select(doc.bufnr, 'position', 'n');
            n = await rangeCount();
            expect(n).toBe(2);
            await cursors.select(doc.bufnr, 'position', 'n');
            n = await rangeCount();
            expect(n).toBe(1);
        });
        it('should select by word', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['foo', 'bar']]);
            await nvim.call('cursor', [1, 1]);
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'word', 'n');
            let n = await rangeCount();
            expect(n).toBe(1);
            await nvim.call('cursor', [2, 2]);
            await cursors.select(doc.bufnr, 'word', 'n');
            n = await rangeCount();
            expect(n).toBe(2);
            await cursors.select(doc.bufnr, 'word', 'n');
            n = await rangeCount();
            expect(n).toBe(1);
        });
        it('should toggle select', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['foo', 'bar']]);
            await nvim.call('cursor', [1, 1]);
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'word', 'n');
            let n = await rangeCount();
            expect(n).toBe(1);
            await cursors.select(doc.bufnr, 'word', 'n');
            n = await rangeCount();
            expect(n).toBe(0);
            let activated = await doc.buffer.getVar('coc_cursors_activated');
            expect(activated).toBe(0);
        });
        it('should select last character', async () => {
            let doc = await workspace_1.default.document;
            await nvim.setOption('virtualedit', 'onemore');
            await nvim.call('setline', [1, ['}', '{']]);
            await nvim.call('cursor', [1, 2]);
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'word', 'n');
            let n = await rangeCount();
            expect(n).toBe(1);
            await nvim.call('cursor', [2, 1]);
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'word', 'n');
            n = await rangeCount();
            expect(n).toBe(2);
        });
        it('should select by visual range', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['"foo"', '"bar"']]);
            await nvim.call('cursor', [1, 1]);
            await nvim.command('normal! vE');
            await doc.synchronize();
            await cursors.select(doc.bufnr, 'range', 'v');
            let n = await rangeCount();
            expect(n).toBe(1);
            await nvim.call('cursor', [2, 1]);
            await nvim.command('normal! vE');
            await cursors.select(doc.bufnr, 'range', 'v');
            n = await rangeCount();
            expect(n).toBe(2);
            await cursors.select(doc.bufnr, 'range', 'v');
            n = await rangeCount();
            expect(n).toBe(1);
        });
        it('should select visual blocks', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['let x = "foo"', 'let y = "bar"']]);
            await doc.synchronize();
            await nvim.call('cursor', [1, 1]);
            await nvim.input('<C-v>');
            await nvim.input('je');
            await cursors.select(doc.bufnr, 'range', '\x16');
            let n = await rangeCount();
            expect(n).toBe(2);
        });
        it('should select by operator char type', async () => {
            await nvim.command('nmap x  <Plug>(coc-cursors-operator)');
            let bufnr = await nvim.call('bufnr', ['%']);
            await nvim.call('setline', [1, ['"short"', '"long"']]);
            await nvim.call('cursor', [1, 2]);
            await nvim.input('xi"');
            await helper_1.default.waitValue(() => {
                let s = cursors.getSession(bufnr);
                return s ? s.currentRanges.length : 0;
            }, 1);
        });
        it('should select by operator line type', async () => {
            await nvim.command('nmap x  <Plug>(coc-cursors-operator)');
            let bufnr = await nvim.call('bufnr', ['%']);
            await nvim.call('setline', [1, ['"short"', '"long"']]);
            await nvim.call('cursor', [1, 2]);
            await nvim.input('xap');
            await helper_1.default.waitValue(() => {
                let s = cursors.getSession(bufnr);
                return s ? s.currentRanges.length : 0;
            }, 2);
        });
    });
    describe('addRanges()', () => {
        it('should add ranges', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['foo foo foo', 'bar bar']]);
            await doc.synchronize();
            let ranges = [
                vscode_languageserver_types_1.Range.create(0, 0, 0, 3),
                vscode_languageserver_types_1.Range.create(0, 4, 0, 7),
                vscode_languageserver_types_1.Range.create(0, 8, 0, 11),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 3),
                vscode_languageserver_types_1.Range.create(1, 4, 1, 7)
            ];
            await commands_1.default.executeCommand('editor.action.addRanges', ranges);
            let n = await rangeCount();
            expect(n).toBe(5);
        });
    });
    describe('validChange()', () => {
        it('should check valid change', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['foo', 'foo', '']]);
            await doc.synchronize();
            let ranges = [
                vscode_languageserver_types_1.Range.create(0, 0, 0, 3),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 3),
            ];
            await helper_1.default.doAction('addRanges', ranges);
            let session = cursors.getSession(doc.bufnr);
            expect(session.validChange(vscode_languageserver_types_1.Range.create(0, 0, 1, 0), '')).toBe(false);
            expect(session.validChange(vscode_languageserver_types_1.Range.create(0, 0, 2, 0), '\n\n')).toBe(false);
            expect(session.validChange(vscode_languageserver_types_1.Range.create(1, 0, 1, 3), 'bar')).toBe(false);
        });
    });
    describe('onChange()', () => {
        let session;
        function edit(sl, sc, el, ec, text) {
            let r = vscode_languageserver_types_1.Range.create(sl, sc, el, ec);
            return vscode_languageserver_types_1.TextEdit.replace(r, text);
        }
        async function assertEdits(edits, characters, line) {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['foo foo foo', '']]);
            await doc.synchronize();
            let ranges = [
                vscode_languageserver_types_1.Range.create(0, 0, 0, 3),
                vscode_languageserver_types_1.Range.create(0, 4, 0, 7),
                vscode_languageserver_types_1.Range.create(0, 8, 0, 11),
            ];
            await cursors.addRanges(ranges);
            session = cursors.getSession(doc.bufnr);
            let p = new Promise(resolve => {
                let disposable = session.onDidUpdate(() => {
                    disposable.dispose();
                    resolve(undefined);
                });
                void doc.applyEdits(edits);
            });
            await p;
            if (line != null) {
                expect(doc.getline(0)).toBe(line);
            }
            let arr = [];
            session.currentRanges.forEach(r => {
                arr.push(r.start.character, r.end.character);
            });
            expect(arr).toEqual(characters);
            session.cancel();
        }
        it('should adjust on text insert', async () => {
            await assertEdits([edit(0, 0, 0, 0, 'bar\n')], [0, 3, 4, 7, 8, 11]);
            await assertEdits([edit(0, 0, 0, 0, 'b')], [0, 4, 5, 9, 10, 14], 'bfoo bfoo bfoo');
            await assertEdits([edit(0, 1, 0, 1, 'b')], [0, 4, 5, 9, 10, 14], 'fboo fboo fboo');
            await assertEdits([edit(0, 3, 0, 3, 'b')], [0, 4, 5, 9, 10, 14], 'foob foob foob');
            await assertEdits([edit(0, 3, 0, 4, '\n')], [0, 3, 0, 3, 4, 7], 'foo');
            await assertEdits([edit(1, 0, 1, 0, 'bar')], [0, 3, 4, 7, 8, 11]);
            await nvim.call('setline', [1, ['foo foo foo', '']]);
            await nvim.call('cursor', [1, 4]);
            await assertEdits([edit(0, 8, 0, 8, 'b')], [0, 4, 5, 9, 10, 14], 'bfoo bfoo bfoo');
            let col = await nvim.call('col', ['.']);
            expect(col).toBe(5);
        });
        it('should adjust on text detete', async () => {
            await assertEdits([edit(0, 2, 0, 3, '')], [0, 2, 3, 5, 6, 8], 'fo fo fo');
            await assertEdits([edit(0, 3, 0, 4, '')], [0, 3, 3, 6, 7, 10], 'foofoo foo');
            await assertEdits([edit(0, 4, 0, 7, '')], [0, 0, 1, 1, 2, 2], '  ');
            await nvim.setLine('foo foo');
            await nvim.call('cursor', [1, 4]);
            await assertEdits([edit(0, 3, 0, 7, '')], [0, 3, 4, 7], 'foo foo');
            await assertEdits([edit(0, 1, 0, 11, '')], [], 'f');
        });
        it('should adjust on text change', async () => {
            await assertEdits([edit(0, 0, 0, 0, '"'), edit(0, 3, 0, 3, '"')], [0, 5, 6, 11, 12, 17], '"foo" "foo" "foo"');
            await assertEdits([edit(0, 0, 0, 1, 'b')], [0, 3, 4, 7, 8, 11], 'boo boo boo');
            await assertEdits([edit(0, 0, 0, 3, 'ba')], [0, 2, 3, 5, 6, 8], 'ba ba ba');
            await nvim.call('setline', [1, ['', '']]);
            await nvim.call('cursor', [2, 1]);
            await assertEdits([edit(0, 4, 0, 5, 'ba')], [0, 4, 5, 9, 10, 14], 'baoo baoo baoo');
            let col = await nvim.call('col', ['.']);
            expect(col).toBe(1);
        });
        it('should adjust on undo & redo', async () => {
            let doc = await workspace_1.default.document;
            let edits = [edit(0, 0, 0, 0, '"'), edit(0, 3, 0, 3, '"')];
            await nvim.call('setline', [1, ['foo foo foo', '']]);
            await doc.synchronize();
            let ranges = [
                vscode_languageserver_types_1.Range.create(0, 0, 0, 3),
                vscode_languageserver_types_1.Range.create(0, 4, 0, 7),
                vscode_languageserver_types_1.Range.create(0, 8, 0, 11),
            ];
            await cursors.addRanges(ranges);
            session = cursors.getSession(doc.bufnr);
            let p = new Promise(resolve => {
                let disposable = session.onDidUpdate(() => {
                    disposable.dispose();
                    resolve(undefined);
                });
                void doc.applyEdits(edits);
            });
            await p;
            await nvim.command('undo');
            await helper_1.default.wait(50);
            expect(session.currentRanges).toEqual(ranges);
        });
        it('should highlight on empty content change', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['foo', '']]);
            await doc.synchronize();
            let ranges = [vscode_languageserver_types_1.Range.create(0, 0, 0, 3)];
            await cursors.addRanges(ranges);
            session = cursors.getSession(doc.bufnr);
            await nvim.call('setline', [1, ['foo', '']]);
            await doc.synchronize();
            let c = await rangeCount();
            expect(c).toBe(1);
        });
    });
    describe('applyComposedEdit()', () => {
        async function setup() {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['bar foo foo', 'foo']]);
            await doc.synchronize();
            let session = cursors.createSession(doc);
            session.addRanges([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 7),
                vscode_languageserver_types_1.Range.create(0, 8, 0, 11),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 3),
            ]);
            return session;
        }
        it('should check change before first range', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['abc foob foob', 'foob']);
            expect(res).toBe(false);
        });
        it('should check change of first range', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar foo foob', 'foob']);
            expect(res).toBe(false);
        });
        it('should check delete exceed range', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fofoo', 'foo']);
            expect(res).toBe(false);
        });
        it('should check content prepend', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar bfoo bfoo', 'bfoo']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 8),
                vscode_languageserver_types_1.Range.create(0, 9, 0, 13),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 4),
            ]);
            s = await setup();
            doc = await workspace_1.default.document;
            res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar bfoo bfoo', 'xfoo']);
            expect(res).toBe(false);
        });
        it('should check content insert', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fboo fboo', 'fboo']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 8),
                vscode_languageserver_types_1.Range.create(0, 9, 0, 13),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 4),
            ]);
        });
        it('should check content append', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar foob foob', 'foob']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 8),
                vscode_languageserver_types_1.Range.create(0, 9, 0, 13),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 4),
            ]);
        });
        it('should check content detete #1', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar oo oo', 'oo']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 6),
                vscode_languageserver_types_1.Range.create(0, 7, 0, 9),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 2),
            ]);
        });
        it('should check content delete #2', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar  ', '']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 4),
                vscode_languageserver_types_1.Range.create(0, 5, 0, 5),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 0),
            ]);
        });
        it('should check content delete #3', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fo fo', 'fo']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 6),
                vscode_languageserver_types_1.Range.create(0, 7, 0, 9),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 2),
            ]);
        });
        it('should check content change #1', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fa fa', 'fa']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 6),
                vscode_languageserver_types_1.Range.create(0, 7, 0, 9),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 2),
            ]);
        });
        it('should check content change #1', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fa fa', 'fa']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 6),
                vscode_languageserver_types_1.Range.create(0, 7, 0, 9),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 2),
            ]);
        });
        it('should check content change #2', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar ab ab', 'ab']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 6),
                vscode_languageserver_types_1.Range.create(0, 7, 0, 9),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 2),
            ]);
        });
        it('should check content change #3', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar xfa xfa', 'xfa']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 7),
                vscode_languageserver_types_1.Range.create(0, 8, 0, 11),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 3),
            ]);
        });
        it('should check content change #4', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar xfao xfao', 'xfao']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 8),
                vscode_languageserver_types_1.Range.create(0, 9, 0, 13),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 4),
            ]);
        });
        it('should check surrond add', async () => {
            let s = await setup();
            let doc = await workspace_1.default.document;
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar "foo" "foo"', '"foo"']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 9),
                vscode_languageserver_types_1.Range.create(0, 10, 0, 15),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 5),
            ]);
        });
        it('should check surrond remove', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['bar "foo" "foo"', '"foo"']]);
            await doc.synchronize();
            let s = cursors.createSession(doc);
            s.addRanges([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 9),
                vscode_languageserver_types_1.Range.create(0, 10, 0, 15),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 5),
            ]);
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar foo foo', 'foo']);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 7),
                vscode_languageserver_types_1.Range.create(0, 8, 0, 11),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 3),
            ]);
        });
        it('should check surrond change', async () => {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['bar "foo" "foo"', '"foo"']]);
            await doc.synchronize();
            let s = cursors.createSession(doc);
            s.addRanges([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 9),
                vscode_languageserver_types_1.Range.create(0, 10, 0, 15),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 5),
            ]);
            let res = s.applyComposedEdit(doc.textDocument.lines.slice(), [`bar 'foo' 'foo'`, `'foo'`]);
            expect(res).toBe(true);
            expect(s.currentRanges).toEqual([
                vscode_languageserver_types_1.Range.create(0, 4, 0, 9),
                vscode_languageserver_types_1.Range.create(0, 10, 0, 15),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 5),
            ]);
        });
    });
    describe('key mappings', () => {
        async function setup() {
            let doc = await workspace_1.default.document;
            await nvim.call('setline', [1, ['a', 'b', 'c']]);
            await doc.synchronize();
            let session = cursors.createSession(doc);
            session.addRanges([
                vscode_languageserver_types_1.Range.create(0, 0, 0, 1),
                vscode_languageserver_types_1.Range.create(1, 0, 1, 1),
                vscode_languageserver_types_1.Range.create(2, 0, 2, 1),
            ]);
        }
        async function hasKeymap(key) {
            let buf = await nvim.buffer;
            let keymaps = await buf.getKeymap('n');
            return keymaps.find(o => o.lhs == key) != null;
        }
        it('should setup cancel keymap', async () => {
            await setup();
            let count = await rangeCount();
            expect(count).toBe(3);
            await nvim.input('<esc>');
            await helper_1.default.wait(50);
            count = await rangeCount();
            expect(count).toBe(0);
            let has = await hasKeymap('<Esc>');
            expect(has).toBe(false);
        });
        it('should next key wrapscan', async () => {
            await setup();
            await nvim.call('cursor', [1, 1]);
            const next = async (line, character) => {
                await nvim.input('<C-n>');
                await helper_1.default.waitValue(async () => {
                    return await nvim.call('coc#cursor#position');
                }, [line, character]);
            };
            await next(1, 0);
            await next(2, 0);
            await next(0, 0);
        });
        it('should previous key wrapscan', async () => {
            await setup();
            await nvim.call('cursor', [3, 1]);
            const prev = async (line, character) => {
                await nvim.input('<C-p>');
                await helper_1.default.waitValue(async () => {
                    return await nvim.call('coc#cursor#position');
                }, [line, character]);
            };
            await prev(1, 0);
            await prev(0, 0);
            await prev(2, 0);
        });
        it('should next key no wrapscan', async () => {
            helper_1.default.updateConfiguration('cursors.wrapscan', false);
            await setup();
            await nvim.call('cursor', [3, 1]);
            const next = async (line, character) => {
                await nvim.input('<C-n>');
                await helper_1.default.wait(50);
                let cursor = await nvim.call('coc#cursor#position');
                expect(cursor).toEqual([line, character]);
            };
            await next(2, 0);
        });
        it('should previous key no wrapscan', async () => {
            helper_1.default.updateConfiguration('cursors.wrapscan', false);
            await setup();
            await nvim.call('cursor', [1, 1]);
            const prev = async (line, character) => {
                await nvim.input('<C-p>');
                await helper_1.default.wait(30);
                let cursor = await nvim.call('coc#cursor#position');
                expect(cursor).toEqual([line, character]);
            };
            await prev(0, 0);
        });
    });
});
//# sourceMappingURL=cursors.test.js.map