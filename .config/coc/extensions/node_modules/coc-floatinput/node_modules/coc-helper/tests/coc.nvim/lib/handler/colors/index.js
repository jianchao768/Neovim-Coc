'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const util_1 = require("../../util");
const color_1 = require("../../util/color");
const protocol_1 = require("../../util/protocol");
const window_1 = tslib_1.__importDefault(require("../../window"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const colorBuffer_1 = tslib_1.__importDefault(require("./colorBuffer"));
class Colors {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        let usedColors = new Set();
        this.highlighters = workspace_1.default.registerBufferSync(doc => {
            return new colorBuffer_1.default(this.nvim, doc, this.config, usedColors);
        });
        events_1.default.on('ColorScheme', () => {
            usedColors.clear();
            for (let item of this.highlighters.items) {
                item.cancel();
                void item.doHighlight();
            }
        }, null, this.disposables);
        languages_1.default.onDidColorsRefresh(selector => {
            for (let item of this.highlighters.items) {
                if (workspace_1.default.match(selector, item.doc)) {
                    item.highlight();
                }
            }
        });
        commands_1.default.register({
            id: 'editor.action.pickColor',
            execute: async () => {
                await this.pickColor();
            }
        }, false, 'pick color from system color picker when possible.');
        commands_1.default.register({
            id: 'editor.action.colorPresentation',
            execute: async () => {
                await this.pickPresentation();
            }
        }, false, 'change color presentation.');
        commands_1.default.register({
            id: 'document.toggleColors',
            execute: async () => {
                let bufnr = await nvim.call('bufnr', ['%']);
                let item = this.highlighters.getItem(bufnr);
                workspace_1.default.getAttachedDocument(bufnr);
                item.toggle();
            }
        }, false, 'toggle colors for current buffer');
    }
    loadConfiguration(e) {
        var _a;
        if (!e || e.affectsConfiguration('colors')) {
            let c = workspace_1.default.initialConfiguration.get('colors');
            this.config = Object.assign((_a = this.config) !== null && _a !== void 0 ? _a : {}, {
                filetypes: c.filetypes,
                highlightPriority: (0, util_1.defaultValue)(c.highlightPriority, 1000)
            });
            if (e) {
                for (let item of this.highlighters.items) {
                    item.updateDocumentConfig();
                }
            }
        }
    }
    async pickPresentation() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.DocumentColor, doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info)
            return void window_1.default.showWarningMessage('Color not found at current position');
        let tokenSource = new protocol_1.CancellationTokenSource();
        let presentations = await languages_1.default.provideColorPresentations(info, doc.textDocument, tokenSource.token);
        if (!(presentations === null || presentations === void 0 ? void 0 : presentations.length))
            return void window_1.default.showWarningMessage('No color presentations found');
        let res = await window_1.default.showMenuPicker(presentations.map(o => o.label), 'Choose color:');
        if (res == -1)
            return;
        let presentation = presentations[res];
        let { textEdit, additionalTextEdits, label } = presentation;
        if (!textEdit)
            textEdit = { range: info.range, newText: label };
        await doc.applyEdits([textEdit]);
        if (additionalTextEdits)
            await doc.applyEdits(additionalTextEdits);
    }
    async pickColor() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.DocumentColor, doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info)
            return void window_1.default.showWarningMessage('Color not found at current position');
        let { color } = info;
        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
        let res = await this.nvim.call('coc#color#pick_color', [colorArr]);
        if (!res)
            return;
        let hex = (0, color_1.toHexString)({
            red: (res[0] / 65535),
            green: (res[1] / 65535),
            blue: (res[2] / 65535),
            alpha: 1
        });
        await doc.applyEdits([{
                range: info.range,
                newText: `#${hex}`
            }]);
    }
    isEnabled(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        return highlighter != null && highlighter.enabled === true;
    }
    clearHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter)
            highlighter.clearHighlight();
    }
    hasColor(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
            return false;
        return highlighter.hasColor();
    }
    hasColorAtPosition(bufnr, position) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
            return false;
        return highlighter.hasColorAtPosition(position);
    }
    highlightAll() {
        for (let buf of this.highlighters.items) {
            buf.highlight();
        }
    }
    async doHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter)
            await highlighter.doHighlight();
    }
    async getColorInformation(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
            return null;
        let position = await window_1.default.getCursorPosition();
        for (let info of highlighter.colors) {
            let { range } = info;
            let { start, end } = range;
            if (position.line == start.line
                && position.character >= start.character
                && position.character <= end.character) {
                return info;
            }
        }
        return null;
    }
    dispose() {
        this.highlighters.dispose();
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = Colors;
//# sourceMappingURL=index.js.map