'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSortedArray = exports.flatMap = exports.lastIndex = exports.distinct = exports.groupBy = exports.group = exports.tail = exports.splitArray = exports.findIndex = exports.intersect = exports.binarySearch2 = exports.binarySearch = exports.intable = exports.isFalsyOrEmpty = exports.toArray = void 0;
function toArray(item) {
    return Array.isArray(item) ? item : item == null ? [] : [item];
}
exports.toArray = toArray;
/**
 * @returns false if the provided object is an array and not empty.
 */
function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
}
exports.isFalsyOrEmpty = isFalsyOrEmpty;
function compareValue(n, r) {
    if (n < r[0])
        return 1;
    if (n > r[1])
        return -1;
    return 0;
}
/**
 * Check if n in sorted table
 */
function intable(n, table) {
    // do binary search
    let low = 0;
    let high = table.length - 1;
    while (low <= high) {
        const mid = ((low + high) / 2) | 0;
        const comp = compareValue(n, table[mid]);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return true;
        }
    }
    return false;
}
exports.intable = intable;
/**
 * Performs a binary search algorithm over a sorted array.
 *
 * @param array The array being searched.
 * @param key The value we search for.
 * @param comparator A function that takes two array elements and returns zero
 * if they are equal, a negative number if the first element precedes the
 * second one in the sorting order, or a positive number if the second element
 * precedes the first one.
 * @return See {@link binarySearch2}
 */
function binarySearch(array, key, comparator) {
    return binarySearch2(array.length, i => comparator(array[i], key));
}
exports.binarySearch = binarySearch;
/**
 * Performs a binary search algorithm over a sorted collection. Useful for cases
 * when we need to perform a binary search over something that isn't actually an
 * array, and converting data to an array would defeat the use of binary search
 * in the first place.
 *
 * @param length The collection length.
 * @param compareToKey A function that takes an index of an element in the
 * collection and returns zero if the value at this index is equal to the
 * search key, a negative number if the value precedes the search key in the
 * sorting order, or a positive number if the search key precedes the value.
 * @return A non-negative index of an element, if found. If not found, the
 * result is -(n+1) (or ~n, using bitwise notation), where n is the index
 * where the key should be inserted to maintain the sorting order.
 */
function binarySearch2(length, compareToKey) {
    let low = 0;
    let high = length - 1;
    while (low <= high) {
        const mid = ((low + high) / 2) | 0;
        const comp = compareToKey(mid);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
exports.binarySearch2 = binarySearch2;
function intersect(array, other) {
    for (let item of other) {
        if (array.includes(item)) {
            return true;
        }
    }
    return false;
}
exports.intersect = intersect;
function findIndex(array, val, start = 0) {
    let idx = -1;
    for (let i = start; i < array.length; i++) {
        if (array[i] === val) {
            idx = i;
            break;
        }
    }
    return idx;
}
exports.findIndex = findIndex;
function splitArray(array, fn) {
    let res = [[], []];
    for (let item of array) {
        if (fn(item)) {
            res[0].push(item);
        }
        else {
            res[1].push(item);
        }
    }
    return res;
}
exports.splitArray = splitArray;
function tail(array, n = 0) {
    return array[array.length - (1 + n)];
}
exports.tail = tail;
function group(array, size) {
    let len = array.length;
    let res = [];
    for (let i = 0; i < Math.ceil(len / size); i++) {
        res.push(array.slice(i * size, (i + 1) * size));
    }
    return res;
}
exports.group = group;
function groupBy(array, fn) {
    let res = [[], []];
    array.forEach(v => {
        if (fn(v)) {
            res[0].push(v);
        }
        else {
            res[1].push(v);
        }
    });
    return res;
}
exports.groupBy = groupBy;
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equalness by returning a unique string for each.
 */
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter((element, position) => array.indexOf(element) === position);
    }
    const seen = Object.create(null);
    return array.filter(elem => {
        const key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
exports.distinct = distinct;
function lastIndex(array, fn) {
    let i = array.length - 1;
    while (i >= 0) {
        if (fn(array[i])) {
            break;
        }
        i--;
    }
    return i;
}
exports.lastIndex = lastIndex;
const flatMap = (xs, f) => xs.reduce((x, y) => [...x, ...f(y)], []);
exports.flatMap = flatMap;
/**
 * Add text to sorted array
 */
function addSortedArray(text, arr) {
    let idx;
    for (let i = 0; i < arr.length; i++) {
        let s = arr[i];
        if (text === s)
            return arr;
        if (s > text) {
            idx = i;
            break;
        }
    }
    if (idx === undefined) {
        arr.push(text);
    }
    else {
        arr.splice(idx, 0, text);
    }
    return arr;
}
exports.addSortedArray = addSortedArray;
//# sourceMappingURL=array.js.map