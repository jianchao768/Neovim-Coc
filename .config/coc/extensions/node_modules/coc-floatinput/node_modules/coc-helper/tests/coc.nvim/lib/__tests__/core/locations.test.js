"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    await nvim.command(`source ${path_1.default.join(process.cwd(), 'autoload/coc/ui.vim')}`);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
});
function createLocations() {
    let uri = vscode_uri_1.URI.file(__filename).toString();
    return [vscode_languageserver_protocol_1.Location.create(uri, vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0)), vscode_languageserver_protocol_1.Location.create(uri, vscode_languageserver_protocol_1.Range.create(2, 0, 3, 0))];
}
describe('showLocations()', () => {
    it('should show locations by editor.action.showReferences', async () => {
        let doc = await workspace_1.default.document;
        let uri = doc.uri;
        let locations = createLocations();
        await commands_1.default.executeCommand('editor.action.showReferences', uri, vscode_languageserver_protocol_1.Position.create(0, 0), locations);
        await helper_1.default.waitValue(async () => {
            let wins = await nvim.windows;
            return wins.length > 1;
        }, true);
    });
    it('should show location list by default', async () => {
        let locations = createLocations();
        await workspace_1.default.showLocations(locations);
        await helper_1.default.waitFor('bufname', ['%'], 'list:///location');
    });
    it('should fire autocmd when location list disabled', async () => {
        Object.assign(workspace_1.default.env, {
            locationlist: false
        });
        await nvim.exec(`
function OnLocationsChange()
  let g:called = 1
endfunction
autocmd User CocLocationsChange :call OnLocationsChange()`);
        let locations = createLocations();
        await workspace_1.default.showLocations(locations);
        await helper_1.default.waitFor('eval', [`get(g:,'called',0)`], 1);
    });
    it('should show quickfix when quickfix enabled', async () => {
        helper_1.default.updateConfiguration('coc.preferences.useQuickfixForLocations', true);
        let locations = createLocations();
        await workspace_1.default.showLocations(locations);
        await helper_1.default.waitFor('eval', [`&buftype`], 'quickfix');
    });
    it('should use customized quickfix open command', async () => {
        await nvim.setVar('coc_quickfix_open_command', 'copen 1');
        helper_1.default.updateConfiguration('coc.preferences.useQuickfixForLocations', true);
        let locations = createLocations();
        await workspace_1.default.showLocations(locations);
        await helper_1.default.waitFor('eval', [`&buftype`], 'quickfix');
        let win = await nvim.window;
        let height = await win.height;
        expect(height).toBe(1);
    });
});
describe('jumpTo()', () => {
    it('should jumpTo position', async () => {
        let uri = vscode_uri_1.URI.file('/tmp/foo');
        await workspace_1.default.jumpTo(uri, { line: 1, character: 1 });
        await nvim.command('setl buftype=nofile');
        let buf = await nvim.buffer;
        let name = await buf.name;
        expect(name).toMatch('/foo');
        await buf.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false });
        await workspace_1.default.jumpTo(uri, { line: 1, character: 1 });
        let pos = await nvim.call('getcurpos');
        expect(pos.slice(1, 3)).toEqual([2, 2]);
    });
    it('should jumpTo uri without normalize', async () => {
        let uri = 'zipfile:///tmp/clojure-1.9.0.jar::clojure/core.clj';
        await workspace_1.default.jumpTo(uri);
        let buf = await nvim.buffer;
        let name = await buf.name;
        expect(name).toBe(uri);
        let doc = await workspace_1.default.document;
        expect(doc.uri.startsWith('zipfile:/tmp')).toBe(true);
    });
    it('should jump without position', async () => {
        let uri = vscode_uri_1.URI.file('/tmp/foo').toString();
        await workspace_1.default.jumpTo(uri);
        let buf = await nvim.buffer;
        let name = await buf.name;
        expect(name).toMatch('/foo');
    });
    it('should jumpTo custom uri scheme', async () => {
        let uri = 'jdt://foo';
        await workspace_1.default.jumpTo(uri, { line: 1, character: 1 });
        let buf = await nvim.buffer;
        let name = await buf.name;
        expect(name).toBe(uri);
    });
    it('should jump with uri fragment', async () => {
        let uri = vscode_uri_1.URI.file(__filename).with({ fragment: '3,3' }).toString();
        await workspace_1.default.jumpTo(uri);
        let cursor = await nvim.call('coc#util#cursor');
        expect(cursor).toEqual([2, 2]);
        uri = vscode_uri_1.URI.file(__filename).with({ fragment: '1' }).toString();
        await workspace_1.default.jumpTo(uri);
        cursor = await nvim.call('coc#util#cursor');
        expect(cursor).toEqual([0, 0]);
    });
});
describe('openResource()', () => {
    it('should open resource', async () => {
        let uri = vscode_uri_1.URI.file(path_1.default.join(os_1.default.tmpdir(), 'bar')).toString();
        await workspace_1.default.openResource(uri);
        let buf = await nvim.buffer;
        let name = await buf.name;
        expect(name).toMatch('bar');
    });
    it('should open none file uri', async () => {
        workspace_1.default.registerTextDocumentContentProvider('jd', {
            provideTextDocumentContent: () => 'jd'
        });
        let uri = 'jd://abc';
        await workspace_1.default.openResource(uri);
        let buf = await nvim.buffer;
        let name = await buf.name;
        expect(name).toBe('jd://abc');
    });
    it('should open opened buffer', async () => {
        let buf = await helper_1.default.edit();
        let doc = workspace_1.default.getDocument(buf.id);
        await workspace_1.default.openResource(doc.uri);
        await helper_1.default.waitFor('bufnr', ['%'], buf.id);
    });
    it('should open url', async () => {
        await helper_1.default.mockFunction('coc#ui#open_url', 0);
        let buf = await helper_1.default.edit();
        let uri = 'http://example.com';
        await workspace_1.default.openResource(uri);
        await helper_1.default.waitFor('bufnr', ['%'], buf.id);
    });
});
//# sourceMappingURL=locations.test.js.map