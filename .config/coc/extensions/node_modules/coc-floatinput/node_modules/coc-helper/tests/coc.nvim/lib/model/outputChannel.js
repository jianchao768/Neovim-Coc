'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
class BufferChannel {
    constructor(name, nvim, onDispose) {
        this.name = name;
        this.nvim = nvim;
        this.onDispose = onDispose;
        this.lines = [''];
        this._disposed = false;
        this.created = false;
        if (!/^[\w\s-.]+$/.test(name))
            throw new Error(`Invalid channel name "${name}", only word characters and white space allowed.`);
    }
    get content() {
        return this.lines.join('\n');
    }
    _append(value) {
        let { nvim } = this;
        if (!nvim)
            return;
        let idx = this.lines.length - 1;
        let newlines = value.split(/\r?\n/);
        let lastline = this.lines[idx] + newlines[0];
        this.lines[idx] = lastline;
        let append = newlines.slice(1);
        this.lines = this.lines.concat(append);
        if (!this.created)
            return;
        nvim.pauseNotification();
        nvim.call('setbufline', [this.bufname, '$', lastline], true);
        if (append.length) {
            nvim.call('appendbufline', [this.bufname, '$', append], true);
        }
        nvim.resumeNotification(false, true);
    }
    append(value) {
        if (!this.validate())
            return;
        this._append(value);
    }
    appendLine(value) {
        if (!this.validate())
            return;
        this._append(value + '\n');
    }
    clear(keep) {
        let { nvim } = this;
        if (!this.validate() || !nvim)
            return;
        this.lines = keep ? this.lines.slice(-keep) : [];
        if (!this.created)
            return;
        nvim.pauseNotification();
        nvim.call('deletebufline', [this.bufname, 1, '$'], true);
        if (this.lines.length) {
            nvim.call('appendbufline', [this.bufname, '$', this.lines], true);
        }
        nvim.resumeNotification(true, true);
    }
    hide() {
        this.created = false;
        if (this.nvim)
            this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);
    }
    get bufname() {
        return `output:///${this.name}`;
    }
    show(preserveFocus, cmd = 'vs') {
        let { nvim } = this;
        if (!nvim)
            return;
        nvim.pauseNotification();
        nvim.command(`exe '${cmd} '.fnameescape('${this.bufname}')`, true);
        if (preserveFocus) {
            nvim.command('wincmd p', true);
        }
        nvim.resumeNotification(true, true);
        this.created = true;
    }
    validate() {
        return !this._disposed;
    }
    dispose() {
        if (this.onDispose)
            this.onDispose();
        this._disposed = true;
        this.hide();
        this.lines = [];
    }
}
exports.default = BufferChannel;
//# sourceMappingURL=outputChannel.js.map