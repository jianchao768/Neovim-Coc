'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.toIndexText = exports.isMenuItem = void 0;
const tslib_1 = require("tslib");
const protocol_1 = require("../util/protocol");
const events_1 = tslib_1.__importDefault(require("../events"));
const util_1 = require("../util");
const string_1 = require("../util/string");
const popup_1 = tslib_1.__importDefault(require("./popup"));
function isMenuItem(item) {
    if (!item)
        return false;
    return typeof item.text === 'string';
}
exports.isMenuItem = isMenuItem;
function toIndexText(n) {
    return n < 99 ? `${n + 1}. ` : '  ';
}
exports.toIndexText = toIndexText;
/**
 * Select single item from menu at cursor position.
 */
class Menu {
    constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.currIndex = 0;
        this.contentHeight = 0;
        this.disposables = [];
        this.keyMappings = new Map();
        this.shortcutIndexes = new Set();
        this._disposed = false;
        this._onDidClose = new protocol_1.Emitter();
        this.onDidClose = this._onDidClose.event;
        this.total = config.items.length;
        if (token) {
            token.onCancellationRequested(() => {
                this._onDidClose.fire(-1);
                this.dispose();
            });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
    }
    attachEvents() {
        events_1.default.on('InputChar', this.onInputChar.bind(this), null, this.disposables);
        events_1.default.on('BufWinLeave', bufnr => {
            if (bufnr == this.bufnr) {
                this._onDidClose.fire(-1);
                this.dispose();
            }
        }, null, this.disposables);
    }
    addKeymappings() {
        let { nvim } = this;
        this.addKeys(['<esc>', '<C-c>'], () => {
            this._onDidClose.fire(-1);
            this.dispose();
        });
        this.addKeys(['\r', '<cr>'], () => {
            this.selectCurrent();
        });
        let setCursorIndex = idx => {
            nvim.pauseNotification();
            this.setCursor(idx + this.contentHeight);
            this.win.refreshScrollbar();
            nvim.command('redraw', true);
            nvim.resumeNotification(false, true);
        };
        this.addKeys('<C-f>', async () => {
            await this.win.scrollForward();
        });
        this.addKeys('<C-b>', async () => {
            await this.win.scrollBackward();
        });
        this.addKeys(['j', '<down>', '<tab>', '<C-n>'], () => {
            // next
            let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
            setCursorIndex(idx);
        });
        this.addKeys(['k', '<up>', '<s-tab>', '<C-p>'], () => {
            // previous
            let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
            setCursorIndex(idx);
        });
        this.addKeys(['g'], () => {
            setCursorIndex(0);
        });
        this.addKeys(['G'], () => {
            setCursorIndex(this.total - 1);
        });
        let timer;
        let firstNumber;
        const choose = (n) => {
            let disabled = this.isDisabled(n);
            if (disabled)
                return;
            this._onDidClose.fire(n);
            this.dispose();
        };
        this.addKeys(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], character => {
            if (timer)
                clearTimeout(timer);
            let n = parseInt(character, 10);
            if (isNaN(n) || n > this.total)
                return;
            if (firstNumber == null && n == 0)
                return;
            if (firstNumber) {
                let count = firstNumber * 10 + n;
                firstNumber = undefined;
                choose(count - 1);
                return;
            }
            if (this.total < 10 || n * 10 > this.total) {
                choose(n - 1);
                return;
            }
            timer = setTimeout(async () => {
                choose(n - 1);
            }, 200);
            firstNumber = n;
        });
        if (this.config.shortcuts) {
            this.addShortcuts(choose);
        }
    }
    addShortcuts(choose) {
        let { items } = this.config;
        let texts = items.map(o => {
            return isMenuItem(o) ? o.text : o;
        });
        texts.forEach((text, idx) => {
            if (text.length) {
                let s = text[0];
                if ((0, string_1.isAlphabet)(s.charCodeAt(0)) && !this.keyMappings.has(s)) {
                    this.shortcutIndexes.add(idx);
                    this.addKeys(s, () => {
                        choose(idx);
                    });
                }
            }
        });
    }
    isDisabled(idx) {
        let { items } = this.config;
        let item = items[idx];
        if (isMenuItem(item) && item.disabled) {
            return true;
        }
        return false;
    }
    async show(preferences = {}) {
        let { nvim, shortcutIndexes } = this;
        let { title, items, borderhighlight, position, content } = this.config;
        let opts = {};
        if (title)
            opts.title = title;
        if (position === 'center')
            opts.relative = 'editor';
        if (preferences.maxHeight)
            opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
            opts.maxWidth = preferences.maxWidth;
        if (preferences.floatHighlight)
            opts.highlight = preferences.floatHighlight;
        if (borderhighlight) {
            opts.borderhighlight = borderhighlight;
        }
        else if (preferences.floatBorderHighlight) {
            opts.borderhighlight = preferences.floatBorderHighlight;
        }
        if (preferences.rounded)
            opts.rounded = 1;
        if (typeof content === 'string')
            opts.content = content;
        if (preferences.confirmKey) {
            this.addKeys(preferences.confirmKey, () => {
                this.selectCurrent();
            });
        }
        let highlights = [];
        let lines = items.map((v, i) => {
            let text = isMenuItem(v) ? v.text : v;
            let pre = toIndexText(i);
            if (shortcutIndexes.has(i)) {
                highlights.push({
                    lnum: i,
                    hlGroup: preferences.shortcutHighlight || 'MoreMsg',
                    colStart: (0, string_1.byteLength)(pre),
                    colEnd: (0, string_1.byteLength)(pre) + 1
                });
            }
            return pre + text.trim();
        });
        lines.forEach((line, i) => {
            let item = items[i];
            if (isMenuItem(item) && item.disabled) {
                highlights.push({
                    hlGroup: 'CocDisabled',
                    lnum: i,
                    colStart: 0,
                    colEnd: (0, string_1.byteLength)(line)
                });
            }
        });
        if (highlights.length)
            opts.highlights = highlights;
        let [winid, bufnr, contentHeight] = await nvim.call('coc#dialog#create_menu', [lines, opts]);
        nvim.command('redraw', true);
        if (this._disposed)
            return;
        this.win = new popup_1.default(nvim, winid, bufnr, lines.length + contentHeight, contentHeight);
        this.bufnr = bufnr;
        this.contentHeight = contentHeight;
        this.attachEvents();
        nvim.call('coc#prompt#start_prompt', ['menu'], true);
    }
    selectCurrent() {
        if (this.isDisabled(this.currIndex)) {
            let item = this.config.items[this.currIndex];
            if (item.disabled['reason']) {
                this.nvim.outWriteLine(`Item disabled: ${item.disabled['reason']}`);
            }
            return;
        }
        this._onDidClose.fire(this.currIndex);
        this.dispose();
    }
    get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : undefined;
    }
    dispose() {
        var _a;
        if (this._disposed)
            return;
        this._disposed = true;
        (0, util_1.disposeAll)(this.disposables);
        this.shortcutIndexes.clear();
        this.keyMappings.clear();
        this.nvim.call('coc#prompt#stop_prompt', ['menu'], true);
        (_a = this.win) === null || _a === void 0 ? void 0 : _a.close();
        this.bufnr = undefined;
        this.win = undefined;
    }
    async onInputChar(session, character) {
        if (session != 'menu' || !this.win)
            return;
        let fn = this.keyMappings.get(character);
        if (fn)
            await Promise.resolve(fn(character));
    }
    setCursor(index) {
        this.currIndex = index - this.contentHeight;
        this.win.setCursor(index);
    }
    addKeys(keys, fn) {
        if (Array.isArray(keys)) {
            for (let key of keys) {
                this.keyMappings.set(key, fn);
            }
        }
        else {
            this.keyMappings.set(keys, fn);
        }
    }
}
exports.default = Menu;
//# sourceMappingURL=menu.js.map