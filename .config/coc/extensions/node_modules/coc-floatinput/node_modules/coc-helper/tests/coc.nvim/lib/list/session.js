'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const highligher_1 = tslib_1.__importDefault(require("../model/highligher"));
const util_1 = require("../util");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const configuration_1 = tslib_1.__importDefault(require("./configuration"));
const db_1 = tslib_1.__importDefault(require("./db"));
const history_1 = tslib_1.__importDefault(require("./history"));
const ui_1 = tslib_1.__importDefault(require("./ui"));
const worker_1 = tslib_1.__importDefault(require("./worker"));
const frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
const debounceTime = (0, util_1.getConditionValue)(50, 1);
/**
 * Activated list session with UI and worker
 */
class ListSession {
    constructor(nvim, prompt, list, listOptions, listArgs) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.loadingFrame = '';
        this.hidden = false;
        this.disposables = [];
        /**
         * Original list arguments.
         */
        this.args = [];
        this.ui = new ui_1.default(nvim, list.name, listOptions);
        this.history = new history_1.default(prompt, list.name, db_1.default, workspace_1.default.cwd);
        this.worker = new worker_1.default(list, prompt, listOptions);
        let debouncedChangeLine = (0, node_1.debounce)(async () => {
            let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
            if (previewing && currwin == this.winid) {
                let idx = this.ui.lnumToIndex(lnum);
                await this.doPreview(idx);
            }
        }, debounceTime);
        this.disposables.push({
            dispose: () => {
                debouncedChangeLine.clear();
            }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = (0, node_1.debounce)(async () => {
            this.updateStatus();
            let { autoPreview } = this.listOptions;
            if (!autoPreview) {
                let [previewing, mode] = await nvim.eval('[coc#list#has_preview(),mode()]');
                if (mode != 'n' || !previewing)
                    return;
            }
            await this.doAction('preview');
        }, 50);
        this.disposables.push({
            dispose: () => {
                debounced.clear();
            }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidOpen(async () => {
            if (typeof this.list.doHighlight == 'function') {
                this.list.doHighlight();
            }
            if (this.listOptions.first) {
                await this.doAction();
            }
        }, null, this.disposables);
        this.ui.onDidClose(this.hide, this, this.disposables);
        this.ui.onDidDoubleClick(this.doAction, this, this.disposables);
        this.worker.onDidChangeItems(ev => {
            if (this.hidden)
                return;
            this.ui.onDidChangeItems(ev);
        }, null, this.disposables);
        let start = 0;
        let timer;
        let interval;
        this.disposables.push(protocol_1.Disposable.create(() => {
            clearTimeout(timer);
            clearInterval(interval);
        }));
        this.worker.onDidChangeLoading(loading => {
            if (this.hidden)
                return;
            if (timer)
                clearTimeout(timer);
            if (loading) {
                start = Date.now();
                if (interval)
                    clearInterval(interval);
                interval = setInterval(() => {
                    let idx = Math.floor((Date.now() - start) % 1000 / 100);
                    this.loadingFrame = frames[idx];
                    this.updateStatus();
                }, 100);
            }
            else {
                timer = setTimeout(() => {
                    this.loadingFrame = '';
                    if (interval)
                        clearInterval(interval);
                    interval = null;
                    this.updateStatus();
                }, Math.max(0, 200 - (Date.now() - start)));
            }
        }, null, this.disposables);
    }
    async start(args) {
        this.args = args;
        this.cwd = workspace_1.default.cwd;
        this.hidden = false;
        let { listArgs } = this;
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.listArgs = listArgs;
        this.history.filter();
        this.targetWinid = res[0];
        this.targetBufnr = res[1];
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
    }
    async reloadItems() {
        if (!this.ui.winid)
            return;
        await this.worker.loadItems(this.context, true);
    }
    async call(fname) {
        await this.nvim.call('coc#prompt#stop_prompt', ['list']);
        let targets = await this.ui.getItems();
        let context = {
            name: this.name,
            args: this.listArgs,
            input: this.prompt.input,
            winid: this.targetWinid,
            bufnr: this.targetBufnr,
            targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
    }
    async chooseAction() {
        let { nvim, defaultAction } = this;
        let { actions } = this.list;
        let names = actions.map(o => o.name);
        let idx = names.indexOf(defaultAction.name);
        if (idx != -1) {
            names.splice(idx, 1);
            names.unshift(defaultAction.name);
        }
        let shortcuts = new Set();
        let choices = [];
        let invalids = [];
        let menuAction = workspace_1.default.env.dialog && configuration_1.default.get('menuAction', false);
        for (let name of names) {
            let i = 0;
            for (let ch of name) {
                if (!shortcuts.has(ch)) {
                    shortcuts.add(ch);
                    choices.push(`${name.slice(0, i)}&${name.slice(i)}`);
                    break;
                }
                i++;
            }
            if (i == name.length) {
                invalids.push(name);
            }
        }
        if (invalids.length && !menuAction) {
            names = names.filter(s => !invalids.includes(s));
        }
        let n;
        if (menuAction) {
            nvim.call('coc#prompt#stop_prompt', ['list'], true);
            n = await window_1.default.showMenuPicker(names, { title: 'Choose action', shortcuts: true });
            n = n + 1;
            this.prompt.start();
        }
        else {
            await nvim.call('coc#prompt#stop_prompt', ['list']);
            n = await nvim.call('confirm', ['Choose action:', choices.join('\n')]);
            await (0, util_1.wait)(10);
            this.prompt.start();
        }
        if (n)
            await this.doAction(names[n - 1]);
    }
    async doAction(name) {
        let { list } = this;
        let action;
        if (name != null) {
            action = list.actions.find(o => o.name == name);
            if (!action) {
                void window_1.default.showErrorMessage(`Action ${name} not found`);
                return;
            }
        }
        else {
            action = this.defaultAction;
        }
        let items;
        if (name == 'preview') {
            let item = await this.ui.item;
            items = item ? [item] : [];
        }
        else {
            items = await this.ui.getItems();
        }
        if (items.length)
            await this.doItemAction(items, action);
    }
    async doPreview(index) {
        let item = this.ui.getItem(index);
        let action = this.list.actions.find(o => o.name == 'preview');
        if (!item || !action)
            return;
        await this.doItemAction([item], action);
    }
    async first() {
        await this.doDefaultAction(0);
    }
    async last() {
        await this.doDefaultAction(this.ui.length - 1);
    }
    async previous() {
        await this.doDefaultAction(this.ui.index - 1);
    }
    async next() {
        await this.doDefaultAction(this.ui.index + 1);
    }
    async doDefaultAction(index) {
        let { ui } = this;
        let item = ui.getItem(index);
        if (!item)
            return;
        await this.ui.setIndex(index);
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
    }
    /**
     * list name
     */
    get name() {
        return this.list.name;
    }
    /**
     * Window id used by list.
     *
     * @returns {number | undefined}
     */
    get winid() {
        return this.ui.winid;
    }
    get length() {
        return this.ui.length;
    }
    get defaultAction() {
        let { defaultAction, actions, name } = this.list;
        let config = workspace_1.default.getConfiguration(`list.source.${name}`);
        let action;
        if (config.defaultAction)
            action = actions.find(o => o.name == config.defaultAction);
        if (!action)
            action = actions.find(o => o.name == defaultAction);
        if (!action)
            action = actions[0];
        if (!action)
            throw new Error(`default action "${defaultAction}" not found`);
        return action;
    }
    async hide(notify = false, isVim = workspace_1.default.isVim) {
        if (this.hidden)
            return;
        let { nvim, timer, targetWinid, context } = this;
        let { winid } = this.ui;
        if (timer)
            clearTimeout(timer);
        this.worker.stop();
        this.history.add();
        this.ui.reset();
        db_1.default.save();
        this.hidden = true;
        nvim.pauseNotification();
        nvim.call('coc#prompt#stop_prompt', ['list'], true);
        if (winid)
            nvim.call('coc#list#close', [winid, context.options.position, targetWinid, this.savedHeight], true);
        if (notify)
            return nvim.resumeNotification(true, true);
        await nvim.resumeNotification(false);
        if (isVim) {
            // required on vim
            await (0, util_1.wait)(10);
            nvim.call('coc#prompt#stop_prompt', ['list'], true);
            nvim.redrawVim();
        }
    }
    toggleMode() {
        let mode = this.prompt.mode == 'normal' ? 'insert' : 'normal';
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
    }
    stop() {
        this.worker.stop();
    }
    async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(index);
        if (!item || item.resolved)
            return;
        let { list } = this;
        if (typeof list.resolveItem === 'function') {
            let label = item.label;
            let resolved = await Promise.resolve(list.resolveItem(item));
            if (resolved && index == this.ui.index) {
                Object.assign(item, resolved, { resolved: true });
                if (label == resolved.label)
                    return;
                this.ui.updateItem(item, index);
            }
        }
    }
    async showHelp() {
        await this.hide();
        let { list, nvim } = this;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command('setl nobuflisted noswapfile buftype=nofile bufhidden=wipe', true);
        await nvim.resumeNotification();
        let hasOptions = list.options && list.options.length;
        let buf = await nvim.buffer;
        let highligher = new highligher_1.default();
        highligher.addLine('NAME', 'Label');
        highligher.addLine(`  ${list.name} - ${list.description || ''}\n`);
        highligher.addLine('SYNOPSIS', 'Label');
        highligher.addLine(`  :CocList [LIST OPTIONS] ${list.name}${hasOptions ? ' [ARGUMENTS]' : ''}\n`);
        if (list.detail) {
            highligher.addLine('DESCRIPTION', 'Label');
            let lines = list.detail.split('\n').map(s => '  ' + s);
            highligher.addLine(lines.join('\n') + '\n');
        }
        if (hasOptions) {
            highligher.addLine('ARGUMENTS', 'Label');
            highligher.addLine('');
            for (let opt of list.options) {
                highligher.addLine(opt.name, 'Special');
                highligher.addLine(`  ${opt.description}`);
                highligher.addLine('');
            }
            highligher.addLine('');
        }
        let config = workspace_1.default.getConfiguration(`list.source.${list.name}`);
        if (Object.keys(config).length) {
            highligher.addLine('CONFIGURATIONS', 'Label');
            highligher.addLine('');
            for (let key of Object.keys(config)) {
                let val = config[key];
                let name = `list.source.${list.name}.${key}`;
                let description = (0, util_1.defaultValue)(workspace_1.default.configurations.getDescription(name), key);
                highligher.addLine(`  "${name}"`, 'MoreMsg');
                highligher.addText(` - ${description} current value: `);
                highligher.addText(JSON.stringify(val), 'Special');
            }
            highligher.addLine('');
        }
        highligher.addLine('ACTIONS', 'Label');
        highligher.addLine(`  ${list.actions.map(o => o.name).join(', ')}`);
        highligher.addLine('');
        highligher.addLine(`see ':h coc-list-options' for available list options.`, 'Comment');
        nvim.pauseNotification();
        highligher.render(buf, 0, -1);
        nvim.command('setl nomod', true);
        nvim.command('setl nomodifiable', true);
        nvim.command('normal! gg', true);
        nvim.command('nnoremap <buffer> q :bd!<CR>', true);
        await nvim.resumeNotification();
    }
    async switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive)
            return;
        const list = ['fuzzy', 'strict', 'regex'];
        let idx = list.indexOf(matcher) + 1;
        if (idx >= list.length)
            idx = 0;
        this.listOptions.matcher = list[idx];
        this.prompt.matcher = list[idx];
        await this.worker.drawItems();
    }
    updateStatus() {
        let { ui, list, nvim } = this;
        if (!ui.bufnr)
            return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
            mode: this.prompt.mode.toUpperCase(),
            args: this.args.join(' '),
            name: list.name,
            cwd: this.cwd,
            loading: this.loadingFrame,
            total: this.worker.length
        };
        buf.setVar('list_status', status, true);
        nvim.command('redraws', true);
    }
    get context() {
        let { winid } = this.ui;
        return {
            options: this.listOptions,
            args: this.listArgs,
            input: this.prompt.input,
            cwd: workspace_1.default.cwd,
            window: this.window,
            buffer: this.buffer,
            listWindow: winid ? this.nvim.createWindow(winid) : undefined
        };
    }
    get window() {
        return this.targetWinid ? this.nvim.createWindow(this.targetWinid) : undefined;
    }
    get buffer() {
        return this.targetBufnr ? this.nvim.createBuffer(this.targetBufnr) : undefined;
    }
    onMouseEvent(key) {
        switch (key) {
            case '<LeftMouse>':
                return this.ui.onMouse('mouseDown');
            case '<LeftDrag>':
                return this.ui.onMouse('mouseDrag');
            case '<LeftRelease>':
                return this.ui.onMouse('mouseUp');
            case '<2-LeftMouse>':
                return this.ui.onMouse('doubleClick');
        }
    }
    async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect)
            return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
            let n = Number(ch);
            if (n == 0)
                n = 10;
            if (this.ui.length >= n) {
                this.nvim.pauseNotification();
                this.ui.setCursor(n);
                await this.nvim.resumeNotification();
                await this.doAction();
                return true;
            }
        }
        return false;
    }
    jumpBack() {
        let { targetWinid, nvim } = this;
        if (targetWinid) {
            nvim.pauseNotification();
            nvim.call('coc#prompt#stop_prompt', ['list'], true);
            this.nvim.call('win_gotoid', [targetWinid], true);
            nvim.resumeNotification(false, true);
        }
    }
    async resume() {
        if (this.winid)
            await this.hide();
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.hidden = false;
        this.targetWinid = res[0];
        this.targetBufnr = res[1];
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
            await this.doAction('preview');
        }
    }
    async doItemAction(items, action) {
        let { noQuit, position } = this.listOptions;
        let { nvim } = this;
        let persistAction = action.persist === true || action.name == 'preview';
        if (position === 'tab' && action.tabPersist)
            persistAction = true;
        let persist = this.winid && (persistAction || noQuit);
        if (persist) {
            if (!persistAction) {
                nvim.pauseNotification();
                nvim.call('coc#prompt#stop_prompt', ['list'], true);
                nvim.call('win_gotoid', [this.context.window.id], true);
                await nvim.resumeNotification();
            }
        }
        else {
            await this.hide();
        }
        if (action.multiple) {
            await Promise.resolve(action.execute(items, this.context));
        }
        else if (action.parallel) {
            await Promise.all(items.map(item => Promise.resolve(action.execute(item, this.context))));
        }
        else {
            for (let item of items) {
                await Promise.resolve(action.execute(item, this.context));
            }
        }
        if (persist)
            this.ui.restoreWindow();
        if (action.reload && persist) {
            await this.reloadItems();
        }
        else if (persist) {
            this.nvim.command('redraw', true);
        }
    }
    onInputChange() {
        if (this.timer)
            clearTimeout(this.timer);
        this.ui.cancel();
        this.history.filter();
        this.listOptions.input = this.prompt.input;
        // reload or filter items
        if (this.listOptions.interactive) {
            this.worker.stop();
            this.timer = setTimeout(async () => {
                await this.worker.loadItems(this.context);
            }, configuration_1.default.debounceTime);
        }
        else {
            void this.worker.drawItems();
        }
    }
    dispose() {
        void this.hide(true);
        (0, util_1.disposeAll)(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
    }
}
exports.default = ListSession;
//# sourceMappingURL=session.js.map