'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExtension = exports.createSandbox = exports.getProtoWithCompile = exports.compileInSandbox = exports.consoleLogger = void 0;
const logger_1 = require("../logger");
const node_1 = require("../util/node");
const lodash_1 = require("./lodash");
const object_1 = require("./object");
exports.consoleLogger = {
    category: '',
    log: console.log.bind(console),
    debug: console.debug.bind(console),
    error: console.error.bind(console),
    warn: console.warn.bind(console),
    info: console.info.bind(console),
    trace: console.log.bind(console),
    fatal: console.error.bind(console),
    mark: console.log.bind(console),
};
const Module = require('module');
const mainModule = require.main;
const REMOVED_GLOBALS = [
    'reallyExit',
    'abort',
    'umask',
    'setuid',
    'setgid',
    'setgroups',
    '_fatalException',
    'exit',
    'kill',
];
function removedGlobalStub(name) {
    return () => {
        throw new Error(`process.${name}() is not allowed in extension sandbox`);
    };
}
// @see node/lib/internal/module.js
function makeRequireFunction(cocExports) {
    const req = (p) => {
        if (p === 'coc.nvim') {
            return (0, object_1.toObject)(cocExports);
        }
        return this.require(p);
    };
    req.resolve = request => Module._resolveFilename(request, this);
    req.main = mainModule;
    // Enable support to add extra extension types
    req.extensions = Module._extensions;
    req.cache = Module._cache;
    return req;
}
// @see node/lib/module.js
function compileInSandbox(sandbox, cocExports) {
    return function (content, filename) {
        const require = makeRequireFunction.call(this, cocExports);
        const dirname = node_1.path.dirname(filename);
        const newContent = content.startsWith('#!') ? content.replace(/^#!.*/, '') : content;
        const wrapper = Module.wrap(newContent);
        const compiledWrapper = node_1.vm.runInContext(wrapper, sandbox, { filename });
        const args = [this.exports, require, this, filename, dirname];
        return compiledWrapper.apply(this.exports, args);
    };
}
exports.compileInSandbox = compileInSandbox;
// find correct Module since jest use a fake Module object that extends Module
function getProtoWithCompile(mod) {
    if ((0, object_1.hasOwnProperty)(mod.prototype, '_compile'))
        return mod.prototype;
    if ((0, object_1.hasOwnProperty)(mod.prototype.__proto__, '_compile'))
        return mod.prototype.__proto__;
    throw new Error('_compile not found');
}
exports.getProtoWithCompile = getProtoWithCompile;
const ModuleProto = getProtoWithCompile(Module);
function createSandbox(filename, logger, name, noExport = global.__TEST__) {
    const module = new Module(filename);
    module.paths = Module._nodeModulePaths(filename);
    const sandbox = node_1.vm.createContext({
        module,
        Buffer,
        URL: globalThis.URL,
        console: {
            debug: (...args) => {
                logger.debug.apply(logger, args);
            },
            log: (...args) => {
                logger.info.apply(logger, args);
            },
            error: (...args) => {
                logger.error.apply(logger, args);
            },
            info: (...args) => {
                logger.info.apply(logger, args);
            },
            warn: (...args) => {
                logger.warn.apply(logger, args);
            }
        }
    }, { name });
    (0, lodash_1.defaults)(sandbox, global);
    sandbox.Reflect = Reflect;
    let cocExports = noExport ? undefined : require('../index');
    sandbox.require = function sandboxRequire(p) {
        const oldCompile = ModuleProto._compile;
        ModuleProto._compile = compileInSandbox(sandbox, cocExports);
        const moduleExports = sandbox.module.require(p);
        ModuleProto._compile = oldCompile;
        return moduleExports;
    };
    // patch `require` in sandbox to run loaded module in sandbox context
    // if you need any of these, it might be worth discussing spawning separate processes
    sandbox.process = new process.constructor();
    for (let key of Object.keys(process)) {
        sandbox.process[key] = process[key];
    }
    REMOVED_GLOBALS.forEach(name => {
        sandbox.process[name] = removedGlobalStub(name);
    });
    sandbox.process['chdir'] = () => { };
    // read-only umask
    sandbox.process.umask = (mask) => {
        if (typeof mask !== 'undefined') {
            throw new Error('Cannot use process.umask() to change mask (read-only)');
        }
        return process.umask();
    };
    return sandbox;
}
exports.createSandbox = createSandbox;
function getLogger(useConsole, id) {
    return useConsole ? exports.consoleLogger : (0, logger_1.createLogger)(`extension:${id}`);
}
// inspiration drawn from Module
function createExtension(id, filename, isEmpty) {
    if (isEmpty || !node_1.fs.existsSync(filename))
        return {
            activate: () => { },
            deactivate: null
        };
    const logger = getLogger(!global.__isMain && !global.__TEST__, id);
    const sandbox = createSandbox(filename, logger, id);
    delete Module._cache[require.resolve(filename)];
    // attempt to import plugin
    // Require plugin to export activate & deactivate
    const defaultImport = sandbox.require(filename);
    const activate = (defaultImport && defaultImport.activate) || defaultImport;
    if (typeof activate !== 'function')
        return { activate: () => { } };
    return typeof defaultImport === 'function' ? { activate } : Object.assign({}, defaultImport);
}
exports.createExtension = createExtension;
//# sourceMappingURL=factory.js.map