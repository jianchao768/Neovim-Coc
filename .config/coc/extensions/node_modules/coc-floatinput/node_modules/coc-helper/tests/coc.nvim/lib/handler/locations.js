'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importStar(require("../languages"));
const services_1 = tslib_1.__importDefault(require("../services"));
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
class LocationsHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
    }
    async request(method, fn) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(method, doc.textDocument);
        await doc.synchronize();
        return await this.handler.withRequestToken(method, token => {
            return fn(doc.textDocument, position, token);
        }, true);
    }
    async definitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.Definition, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new protocol_1.CancellationTokenSource();
        return languages_1.default.getDefinition(doc.textDocument, position, tokenSource.token);
    }
    async declarations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.Declaration, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new protocol_1.CancellationTokenSource();
        return languages_1.default.getDeclaration(doc.textDocument, position, tokenSource.token);
    }
    async typeDefinitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.TypeDefinition, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new protocol_1.CancellationTokenSource();
        return languages_1.default.getTypeDefinition(doc.textDocument, position, tokenSource.token);
    }
    async implementations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.Implementation, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new protocol_1.CancellationTokenSource();
        return languages_1.default.getImplementation(doc.textDocument, position, tokenSource.token);
    }
    async references(excludeDeclaration) {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(languages_1.ProviderName.Reference, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new protocol_1.CancellationTokenSource();
        return languages_1.default.getReferences(doc.textDocument, { includeDeclaration: !excludeDeclaration }, position, tokenSource.token);
    }
    async gotoDefinition(openCommand) {
        let definition = await this.request(languages_1.ProviderName.Definition, (doc, position, token) => {
            return languages_1.default.getDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
    }
    async gotoDeclaration(openCommand) {
        let definition = await this.request(languages_1.ProviderName.Declaration, (doc, position, token) => {
            return languages_1.default.getDeclaration(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
    }
    async gotoTypeDefinition(openCommand) {
        let definition = await this.request(languages_1.ProviderName.TypeDefinition, (doc, position, token) => {
            return languages_1.default.getTypeDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
    }
    async gotoImplementation(openCommand) {
        let definition = await this.request(languages_1.ProviderName.Implementation, (doc, position, token) => {
            return languages_1.default.getImplementation(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
    }
    async gotoReferences(openCommand, includeDeclaration = true) {
        let definition = await this.request(languages_1.ProviderName.Reference, (doc, position, token) => {
            return languages_1.default.getReferences(doc, { includeDeclaration }, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
    }
    async getTagList() {
        let { doc, position } = await this.handler.getCurrentState();
        let word = await this.nvim.call('expand', '<cword>');
        if (!word)
            return null;
        if (!languages_1.default.hasProvider(languages_1.ProviderName.Definition, doc.textDocument))
            return null;
        let tokenSource = new protocol_1.CancellationTokenSource();
        let definitions = await languages_1.default.getDefinition(doc.textDocument, position, tokenSource.token);
        if (!definitions || !definitions.length)
            return null;
        return definitions.map(location => {
            let parsedURI = vscode_uri_1.URI.parse(location.uri);
            const filename = parsedURI.scheme == 'file' ? parsedURI.fsPath : parsedURI.toString();
            return {
                name: word,
                cmd: `silent keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,
                filename,
            };
        });
    }
    /**
     * Send custom request for locations to services.
     */
    async findLocations(id, method, params, openCommand = false) {
        let { doc, position } = await this.handler.getCurrentState();
        params = params || {};
        Object.assign(params, {
            textDocument: { uri: doc.uri },
            position
        });
        let res = await services_1.default.sendRequest(id, method, params);
        let locations = this.toLocations(res);
        await this.handleLocations(locations, openCommand);
        return locations.length > 0;
    }
    toLocations(location) {
        let res = [];
        if (location && (0, object_1.hasOwnProperty)(location, 'location') && (0, object_1.hasOwnProperty)(location, 'children')) {
            let getLocation = (item) => {
                if (!item)
                    return;
                if (vscode_languageserver_types_1.Location.is(item.location)) {
                    res.push(item.location);
                }
                else if (vscode_languageserver_types_1.LocationLink.is(item.location)) {
                    let loc = item.location;
                    res.push({
                        uri: loc.targetUri,
                        range: loc.targetSelectionRange,
                        targetRange: loc.targetRange
                    });
                }
                if (item.children && item.children.length) {
                    for (let loc of item.children) {
                        getLocation(loc);
                    }
                }
            };
            getLocation(location);
            return res;
        }
        if (vscode_languageserver_types_1.Location.is(location)) {
            res.push(location);
        }
        else if (vscode_languageserver_types_1.LocationLink.is(location)) {
            res.push({
                uri: location.targetUri,
                range: location.targetSelectionRange,
                targetRange: location.targetRange
            });
        }
        else if (Array.isArray(location)) {
            for (let loc of location) {
                if (vscode_languageserver_types_1.Location.is(loc)) {
                    res.push(loc);
                }
                else if (loc && typeof loc.targetUri === 'string') {
                    res.push({
                        uri: loc.targetUri,
                        range: loc.targetSelectionRange,
                        targetRange: loc.targetRange
                    });
                }
            }
        }
        return res;
    }
    async handleLocations(locations, openCommand) {
        if (!locations)
            return;
        let len = locations.length;
        if (len == 0)
            return;
        if (len == 1 && openCommand !== false) {
            let { uri, range } = locations[0];
            await workspace_1.default.jumpTo(uri, range.start, openCommand);
        }
        else {
            await workspace_1.default.showLocations(locations);
        }
    }
}
exports.default = LocationsHandler;
//# sourceMappingURL=locations.js.map