'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("../events"));
const terminal_1 = require("../model/terminal");
const util_1 = require("../util");
const object_1 = require("../util/object");
const protocol_1 = require("../util/protocol");
class Terminals {
    constructor() {
        this._terminals = new Map();
        this.disposables = [];
        this._onDidOpenTerminal = new protocol_1.Emitter();
        this._onDidCloseTerminal = new protocol_1.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        events_1.default.on('BufUnload', bufnr => {
            if (this._terminals.has(bufnr)) {
                let terminal = this._terminals.get(bufnr);
                this._onDidCloseTerminal.fire(terminal);
                this._terminals.delete(bufnr);
            }
        }, null, this.disposables);
        events_1.default.on('TermExit', (bufnr, status) => {
            let terminal = this._terminals.get(bufnr);
            if (terminal) {
                terminal.onExit(status);
                terminal.dispose();
            }
        }, null, this.disposables);
    }
    get terminals() {
        return Array.from(this._terminals.values());
    }
    async createTerminal(nvim, opts) {
        let cwd = opts.cwd;
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd)
            cmd = await nvim.getOption('shell');
        if (!cwd)
            cwd = await nvim.call('getcwd');
        let terminal = new terminal_1.TerminalModel(cmd, args || [], nvim, opts.name, opts.strictEnv);
        await terminal.start(cwd, opts.env);
        this._terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
    }
    async runTerminalCommand(nvim, cmd, cwd, keepfocus) {
        return await nvim.callAsync('coc#ui#run_terminal', { cmd, cwd, keepfocus: keepfocus ? 1 : 0 });
    }
    async openTerminal(nvim, cmd, opts) {
        return await nvim.call('coc#ui#open_terminal', Object.assign({ cmd }, (0, object_1.toObject)(opts)));
    }
    reset() {
        for (let terminal of this._terminals.values()) {
            terminal.dispose();
        }
        this._terminals.clear();
    }
    dispose() {
        this._onDidOpenTerminal.dispose();
        this._onDidCloseTerminal.dispose();
        (0, util_1.disposeAll)(this.disposables);
        this.reset();
    }
}
exports.default = Terminals;
//# sourceMappingURL=terminals.js.map