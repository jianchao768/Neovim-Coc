"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let commands;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    commands = helper_1.default.plugin.handler.commands;
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
beforeEach(async () => {
    await helper_1.default.createDocument();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    await helper_1.default.reset();
});
describe('Commands', () => {
    describe('addVimCommand', () => {
        it('should register global vim commands', async () => {
            await commands_1.default.executeCommand('vim.config');
            let val = await nvim.getVar('coc_config_init');
            expect(val).toBe(1);
            let list = await helper_1.default.doAction('commandList');
            expect(list.includes('vim.config')).toBe(true);
        });
        it('should add vim command with title', async () => {
            await helper_1.default.plugin.cocAction('addCommand', { id: 'bad', cmd: '', title: '' });
            commands.addVimCommand({ id: 'list', cmd: 'CocList', title: 'list of coc.nvim' });
            let res = commands_1.default.titles.get('vim.list');
            expect(res).toBe('list of coc.nvim');
            commands_1.default.unregister('vim.list');
            commands_1.default.unregister('unknown.command');
            let list = commands.getCommandList();
            expect(list.includes('bad')).toBe(false);
        });
    });
    describe('commandManager', () => {
        it('should replace builtin command', async () => {
            let fn = jest.fn();
            commands_1.default.registerCommand('editor.action.restart', () => {
                fn();
            });
            await commands_1.default.executeCommand('editor.action.restart');
            expect(fn).toBeCalled();
        });
        it('should throw when command not found', async () => {
            await expect(async () => {
                await commands_1.default.executeCommand('');
            }).rejects.toThrow(Error);
        });
        it('should add to recent', async () => {
            await commands_1.default.addRecent('document.checkBuffer', true);
            let mru = workspace_1.default.createMru('commands');
            let list = await mru.load();
            expect(list[0]).toBe('document.checkBuffer');
        });
    });
    describe('getCommands', () => {
        it('should get command items', async () => {
            let res = await helper_1.default.doAction('commands');
            let idx = res.findIndex(o => o.id == 'workspace.showOutput');
            expect(idx != -1).toBe(true);
        });
    });
    describe('repeat', () => {
        it('should repeat command', async () => {
            // let buf = await nvim.buffer
            await nvim.call('setline', [1, ['a', 'b', 'c']]);
            await nvim.call('cursor', [1, 1]);
            commands.addVimCommand({ id: 'remove', cmd: 'normal! dd' });
            await helper_1.default.doAction('runCommand', 'vim.remove');
            await helper_1.default.waitFor('getline', ['.'], 'b');
            await helper_1.default.doAction('repeatCommand');
            await helper_1.default.waitFor('getline', ['.'], 'c');
        });
    });
    describe('runCommand', () => {
        it('should open command list without id', async () => {
            await commands.runCommand();
            await helper_1.default.waitFor('bufname', ['%'], 'list:///commands');
        });
    });
});
//# sourceMappingURL=commands.test.js.map