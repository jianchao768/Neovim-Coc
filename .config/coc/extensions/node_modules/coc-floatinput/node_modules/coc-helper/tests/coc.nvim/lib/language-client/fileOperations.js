'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
const tslib_1 = require("tslib");
const node_1 = require("../util/node");
const fs_1 = require("../util/fs");
const protocol_1 = require("../util/protocol");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const features_1 = require("./features");
const UUID = tslib_1.__importStar(require("./utils/uuid"));
function access(target, key) {
    return target[key];
}
function assign(target, key, value) {
    target[key] = value;
}
function asCreateDeleteFilesParams(e) {
    return {
        files: e.files.map(f => ({ uri: f.toString() }))
    };
}
function asRenameFilesParams(e) {
    return {
        files: e.files.map(f => ({ oldUri: f.oldUri.toString(), newUri: f.newUri.toString() }))
    };
}
class FileOperationFeature extends features_1.BaseFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
        super(client);
        this._filters = new Map();
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
    }
    getState() {
        return { kind: 'workspace', id: this._registrationType.method, registrations: this._filters.size > 0 };
    }
    get registrationType() {
        return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
        const value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'fileOperations');
        // this happens n times but it is the same value so we tolerate this.
        assign(value, 'dynamicRegistration', true);
        assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
        var _a;
        const options = (_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.fileOperations;
        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;
        if ((capability === null || capability === void 0 ? void 0 : capability.filters) !== undefined) {
            try {
                this.register({
                    id: UUID.generateUuid(),
                    registerOptions: { filters: capability.filters },
                });
            }
            catch (e) {
                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
        }
    }
    register(data) {
        if (!this._listener) {
            this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map(filter => {
            const matcher = new node_1.minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
        this._filters.delete(id);
    }
    dispose() {
        this._filters.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    async filter(event, prop) {
        // (Asynchronously) map each file onto a boolean of whether it matches
        // any of the globs.
        const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            // Use fsPath to make this consistent with file system watchers but help
            // minimatch to use '/' instead of `\\` if present.
            const path = uri.fsPath.replace(/\\/g, '/');
            for (const filters of this._filters.values()) {
                for (const filter of filters) {
                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {
                        continue;
                    }
                    if (filter.matcher.match(path)) {
                        // The pattern matches. If kind is undefined then everything is ok
                        if (filter.kind === undefined) {
                            return true;
                        }
                        const fileType = await (0, fs_1.getFileType)(uri.fsPath);
                        // If we can't determine the file type than we treat it as a match.
                        // Dropping it would be another alternative.
                        if (fileType === undefined) {
                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                            return true;
                        }
                        if ((fileType === fs_1.FileType.File && filter.kind === protocol_1.FileOperationPatternKind.file) ||
                            (fileType === fs_1.FileType.Directory && filter.kind === protocol_1.FileOperationPatternKind.folder)) {
                            return true;
                        }
                    }
                    else if (filter.kind === protocol_1.FileOperationPatternKind.folder) {
                        const fileType = await (0, fs_1.getFileType)(uri.fsPath);
                        if (fileType === fs_1.FileType.Directory && filter.matcher.match(`${path}/`)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }));
        // Filter the files to those that matched.
        const files = event.files.filter((_, index) => fileMatches[index]);
        return Object.assign(Object.assign({}, event), { files });
    }
    static asMinimatchOptions(options) {
        if (options === undefined) {
            return undefined;
        }
        if (options.ignoreCase === true) {
            return { nocase: true };
        }
        return undefined;
    }
}
class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = async (event) => {
                if (!this._client.isRunning())
                    return;
                return this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            let promise = this.doSend(filteredEvent, next);
            if (promise) {
                await promise.catch(e => {
                    this._client.error(`Sending notification ${this.registrationType.method} failed`, e);
                });
            }
        }
    }
}
class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, workspace_1.default.onDidCreateFiles, protocol_1.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, e => asCreateDeleteFilesParams(e));
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didCreateFiles) ? middleware.didCreateFiles(event, next) : next(event);
    }
}
exports.DidCreateFilesFeature = DidCreateFilesFeature;
class DidRenameFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, workspace_1.default.onDidRenameFiles, protocol_1.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, e => asRenameFilesParams(e));
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didRenameFiles) ? middleware.didRenameFiles(event, next) : next(event);
    }
}
exports.DidRenameFilesFeature = DidRenameFilesFeature;
class DidDeleteFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, workspace_1.default.onDidDeleteFiles, protocol_1.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, e => asCreateDeleteFilesParams(e));
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didDeleteFiles) ? middleware.didDeleteFiles(event, next) : next(event);
    }
}
exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = (event) => {
                return this.sendRequest(this._requestType, this._createParams(event), protocol_1.CancellationToken.None);
            };
            return this.doSend(filteredEvent, next);
        }
        else {
            return undefined;
        }
    }
}
class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, workspace_1.default.onWillCreateFiles, protocol_1.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, e => asCreateDeleteFilesParams(e));
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willCreateFiles) ? middleware.willCreateFiles(event, next) : next(event);
    }
}
exports.WillCreateFilesFeature = WillCreateFilesFeature;
class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, workspace_1.default.onWillRenameFiles, protocol_1.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, e => asRenameFilesParams(e));
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willRenameFiles) ? middleware.willRenameFiles(event, next) : next(event);
    }
}
exports.WillRenameFilesFeature = WillRenameFilesFeature;
class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, workspace_1.default.onWillDeleteFiles, protocol_1.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, e => asCreateDeleteFilesParams(e));
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willDeleteFiles) ? middleware.willDeleteFiles(event, next) : next(event);
    }
}
exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
//# sourceMappingURL=fileOperations.js.map