'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importStar(require("../../languages"));
const regions_1 = tslib_1.__importDefault(require("../../model/regions"));
const inlayHintManager_1 = require("../../provider/inlayHintManager");
const util_1 = require("../../util");
const errors_1 = require("../../util/errors");
const position_1 = require("../../util/position");
const protocol_1 = require("../../util/protocol");
const string_1 = require("../../util/string");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
let srcId;
const debounceInterval = (0, util_1.getConditionValue)(100, 10);
const requestDelay = (0, util_1.getConditionValue)(500, 10);
function getHighlightGroup(kind) {
    switch (kind) {
        case vscode_languageserver_types_1.InlayHintKind.Parameter:
            return 'CocInlayHintParameter';
        case vscode_languageserver_types_1.InlayHintKind.Type:
            return 'CocInlayHintType';
        default:
            return 'CocInlayHint';
    }
}
class InlayHintBuffer {
    constructor(nvim, doc) {
        this.nvim = nvim;
        this.doc = doc;
        this.regions = new regions_1.default();
        // Saved for resolve and TextEdits in the future.
        this.currentHints = [];
        this._onDidRefresh = new protocol_1.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.render = (0, util_1.delay)(() => {
            void this.renderRange();
        }, debounceInterval);
        if (this.hasProvider)
            this.render();
    }
    get config() {
        if (this._config)
            return this._config;
        this.loadConfiguration();
        return this._config;
    }
    loadConfiguration() {
        let config = workspace_1.default.getConfiguration('inlayHint', this.doc);
        let changed = this._config && this._config.enable != config.enable;
        this._config = {
            enable: config.get('enable'),
            display: config.get('display', true),
            filetypes: config.get('filetypes'),
            refreshOnInsertMode: config.get('refreshOnInsertMode'),
            enableParameter: config.get('enableParameter'),
            typeSeparator: config.get('typeSeparator', ''),
            parameterSeparator: config.get('parameterSeparator', ''),
            subSeparator: config.get('subSeparator', ' ')
        };
        if (changed) {
            let { enable, display } = this._config;
            if (enable) {
                this.clearCache();
                this.clearVirtualText();
            }
            else if (display) {
                void this.renderRange();
            }
        }
    }
    onInsertLeave() {
        if (this.config.refreshOnInsertMode)
            return;
        this.render();
    }
    onInsertEnter() {
        if (this.config.refreshOnInsertMode)
            return;
        this.cancel();
    }
    get current() {
        return this.currentHints;
    }
    get enabled() {
        if (!this.config.display || !this.configEnabled)
            return false;
        return this.hasProvider;
    }
    get hasProvider() {
        return languages_1.default.hasProvider(languages_1.ProviderName.InlayHint, this.doc);
    }
    get configEnabled() {
        let { filetypes, enable } = this.config;
        if (Array.isArray(filetypes))
            return filetypes.includes('*') || filetypes.includes(this.doc.filetype);
        return enable === true;
    }
    toggle() {
        if (!languages_1.default.hasProvider(languages_1.ProviderName.InlayHint, this.doc.textDocument))
            throw new Error('Inlay hint provider not found for current document');
        if (!this.configEnabled)
            throw new Error(`Filetype "${this.doc.filetype}" not enabled by inlayHint configuration`);
        if (this.config.display) {
            this.config.display = false;
            this.clearCache();
            this.clearVirtualText();
        }
        else {
            this.config.display = true;
            void this.renderRange();
        }
    }
    clearCache() {
        this.currentHints = [];
        this.regions.clear();
        this.render.clear();
    }
    onTextChange() {
        this.clearCache();
        this.cancel();
    }
    onChange() {
        this.cancel();
        this.render();
    }
    cancel() {
        this.render.clear();
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
    }
    async requestInlayHints(range, token) {
        try {
            return await languages_1.default.provideInlayHints(this.doc.textDocument, range, token);
        }
        catch (e) {
            if (!token.isCancellationRequested && e instanceof errors_1.CancellationError) {
                // wait for more time
                this.render(requestDelay);
            }
        }
    }
    async renderRange() {
        this.cancel();
        if ((events_1.default.insertMode && !this.config.refreshOnInsertMode) || !this.enabled)
            return;
        this.tokenSource = new protocol_1.CancellationTokenSource();
        let token = this.tokenSource.token;
        let res = await this.nvim.call('coc#window#visible_range', [this.doc.bufnr]);
        if (!Array.isArray(res) || res[1] <= 0 || token.isCancellationRequested)
            return;
        if (!srcId)
            srcId = await this.nvim.createNamespace('coc-inlayHint');
        if (token.isCancellationRequested || this.regions.has(res[0], res[1]))
            return;
        let range = vscode_languageserver_types_1.Range.create(res[0] - 1, 0, res[1], 0);
        let inlayHints = await this.requestInlayHints(range, token);
        if (inlayHints == null || token.isCancellationRequested)
            return;
        this.regions.add(res[0], res[1]);
        if (!this.config.enableParameter) {
            inlayHints = inlayHints.filter(o => o.kind !== vscode_languageserver_types_1.InlayHintKind.Parameter);
        }
        this.currentHints = this.currentHints.filter(o => (0, position_1.positionInRange)(o.position, range) !== 0);
        this.currentHints.push(...inlayHints);
        this.setVirtualText(range, inlayHints, workspace_1.default.env.isVim);
    }
    setVirtualText(range, inlayHints, isVim) {
        var _a;
        let { nvim, doc } = this;
        let buffer = doc.buffer;
        let { subSeparator, parameterSeparator, typeSeparator } = this.config;
        const chunksMap = new Map();
        if (!isVim) {
            for (const item of inlayHints) {
                let { line } = item.position;
                const chunks = (_a = chunksMap.get(line)) !== null && _a !== void 0 ? _a : [];
                if (chunks.length > 0) {
                    chunks.push([subSeparator, subSeparator === ' ' ? 'Normal' : getHighlightGroup(item.kind)]);
                }
                let sep = item.kind === vscode_languageserver_types_1.InlayHintKind.Parameter ? parameterSeparator : typeSeparator;
                chunks.push([sep + (0, inlayHintManager_1.getLabel)(item), getHighlightGroup(item.kind)]);
                chunksMap.set(line, chunks);
            }
        }
        nvim.pauseNotification();
        buffer.clearNamespace(srcId, range.start.line, range.end.line + 1);
        if (isVim) {
            for (const item of inlayHints) {
                const chunks = [];
                let { position } = item;
                let line = this.doc.getline(position.line);
                let col = (0, string_1.byteIndex)(line, position.character) + 1;
                if (item.paddingLeft) {
                    chunks.push([' ', 'Normal']);
                }
                chunks.push([(0, inlayHintManager_1.getLabel)(item), getHighlightGroup(item.kind)]);
                if (item.paddingRight) {
                    chunks.push([' ', 'Normal']);
                }
                buffer.setVirtualText(srcId, position.line, chunks, { col });
            }
        }
        else {
            for (let [line, chunks] of chunksMap.entries()) {
                buffer.setExtMark(srcId, line, 0, {
                    virt_text: chunks,
                    virt_text_pos: 'eol',
                    hl_mode: 'combine'
                });
            }
        }
        nvim.resumeNotification(true, true);
        this._onDidRefresh.fire();
    }
    clearVirtualText() {
        if (srcId)
            this.doc.buffer.clearNamespace(srcId);
    }
    dispose() {
        this.cancel();
    }
}
exports.default = InlayHintBuffer;
//# sourceMappingURL=buffer.js.map