"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
/**
 * A syntax parser that parse `class` and `method` only.
 */
class Parser {
    constructor(_content, showDetail = false) {
        this._content = _content;
        this.showDetail = showDetail;
        this._curr = 0;
        this._symbols = [];
        this.len = _content.length;
        this.textDocument = vscode_languageserver_textdocument_1.TextDocument.create('test:///a', 'txt', 1, _content);
    }
    parse() {
        while (this._curr <= this.len - 1) {
            this.parseToken();
        }
        return this._symbols;
    }
    /**
     * Parse a symbol, reset currSymbol & _curr
     */
    parseToken() {
        this.skipSpaces();
        if (this.currSymbol) {
            let endOffset = this.textDocument.offsetAt(this.currSymbol.range.end);
            if (this._curr > endOffset) {
                this.currSymbol = undefined;
            }
        }
        let remain = this.getLineRemain();
        let ms = remain.match(/^(class)\s(\w+)\s\{\s*/);
        if (ms) {
            // find class
            let start = this._curr + 6;
            let end = start + ms[2].length;
            let selectionRange = vscode_languageserver_protocol_1.Range.create(this.textDocument.positionAt(start), this.textDocument.positionAt(end));
            let endPosition = this.findMatchedIndex(this._curr + ms[0].length);
            let range = vscode_languageserver_protocol_1.Range.create(this.textDocument.positionAt(this._curr), this.textDocument.positionAt(endPosition));
            let symbolInfo = {
                range,
                selectionRange,
                kind: vscode_languageserver_protocol_1.SymbolKind.Class,
                name: ms[2],
                children: []
            };
            if (this.currSymbol && this.currSymbol.children) {
                this.currSymbol.children.push(symbolInfo);
            }
            else {
                this._symbols.push(symbolInfo);
            }
            this.currSymbol = symbolInfo;
        }
        else {
            let ms = remain.match(/(\w+)\((.*)\)\s*\{/);
            if (ms) {
                // find method
                let start = this._curr;
                let end = start + ms[1].length;
                let selectionRange = vscode_languageserver_protocol_1.Range.create(this.textDocument.positionAt(start), this.textDocument.positionAt(end));
                let endPosition = this.findMatchedIndex(this._curr + ms[0].length);
                let range = vscode_languageserver_protocol_1.Range.create(this.textDocument.positionAt(this._curr), this.textDocument.positionAt(endPosition));
                let symbolInfo = {
                    range,
                    selectionRange,
                    kind: vscode_languageserver_protocol_1.SymbolKind.Method,
                    detail: this.showDetail ? `(${ms[2]})` : undefined,
                    name: ms[1]
                };
                if (this.currSymbol && this.currSymbol.children) {
                    this.currSymbol.children.push(symbolInfo);
                }
                else {
                    this._symbols.push(symbolInfo);
                }
            }
        }
        this._curr = this._curr + remain.length + 1;
    }
    findMatchedIndex(start) {
        let level = 0;
        for (let i = start; i < this.len; i++) {
            let ch = this._content[i];
            if (ch == '{') {
                level = level + 1;
            }
            if (ch == '}') {
                if (level == 0)
                    return i;
                level = level - 1;
            }
        }
        throw new Error(`Can't find matched }`);
    }
    getLineRemain() {
        let chars = '';
        for (let i = this._curr; i < this.len; i++) {
            let ch = this._content[i];
            if (ch == '\n')
                break;
            chars = chars + ch;
        }
        return chars;
    }
    skipSpaces() {
        for (let i = this._curr; i < this.len; i++) {
            let ch = this._content[i];
            if (!ch || /\S/.test(ch)) {
                this._curr = i;
                break;
            }
        }
    }
}
exports.default = Parser;
//# sourceMappingURL=parser.js.map