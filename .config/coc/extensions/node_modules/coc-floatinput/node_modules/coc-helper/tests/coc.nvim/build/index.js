"use strict";
global.__starttime = Date.now();
global.__isMain = require.main === module;
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue2) => `\x1B[${38 + offset};2;${red};${green};${blue2}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright;
      styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
      styles3.color.grey = styles3.color.blackBright;
      styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (const [groupName2, group] of Object.entries(styles3)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles3[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles3, groupName2, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "\x1B[39m";
      styles3.bgColor.close = "\x1B[49m";
      styles3.color.ansi256 = wrapAnsi256();
      styles3.color.ansi16m = wrapAnsi16m();
      styles3.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles3.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: (red, green, blue2) => {
            if (red === green && green === blue2) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer2 = Number.parseInt(colorString, 16);
            return [
              integer2 >> 16 & 255,
              integer2 >> 8 & 255,
              integer2 & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports2, module2) {
    function debounce3(func2, wait2, immediate) {
      var timeout2, args, context, timestamp, result;
      if (null == wait2)
        wait2 = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait2 && last >= 0) {
          timeout2 = setTimeout(later, wait2 - last);
        } else {
          timeout2 = null;
          if (!immediate) {
            result = func2.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout2;
        if (!timeout2)
          timeout2 = setTimeout(later, wait2);
        if (callNow) {
          result = func2.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
      };
      debounced.flush = function() {
        if (timeout2) {
          result = func2.apply(context, args);
          context = args = null;
          clearTimeout(timeout2);
          timeout2 = null;
        }
      };
      return debounced;
    }
    debounce3.debounce = debounce3;
    module2.exports = debounce3;
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows2 = process.platform === "win32";
    var fs2 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows2) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows2) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows2 && !knownHard[base]) {
          fs2.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs2.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows2) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs2.statSync(base);
            linkTarget = fs2.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows2)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows2 && !knownHard[base]) {
          fs2.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs2.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows2) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs2.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs2.readlink(base, function(err3, target) {
            if (!isWindows2)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs2 = require("fs");
    var origRealpath = fs2.realpath;
    var origRealpathSync = fs2.realpathSync;
    var version2 = process.version;
    var ok = /^v[0-5]\./.test(version2);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs2.realpath = realpath;
      fs2.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs2.realpath = origRealpath;
      fs2.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/glob/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/glob/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand2(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand2(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand2(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad2) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand2(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/glob/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/glob/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch2;
    minimatch2.Minimatch = Minimatch;
    var path2 = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch2.sep = path2.sep;
    var GLOBSTAR = minimatch2.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand2 = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch2.filter = filter2;
    function filter2(pattern, options2) {
      options2 = options2 || {};
      return function(p, i, list2) {
        return minimatch2(p, pattern, options2);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch2.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      var orig = minimatch2;
      var m = function minimatch3(p, pattern, options2) {
        return orig(p, pattern, ext(def, options2));
      };
      m.Minimatch = function Minimatch2(pattern, options2) {
        return new orig.Minimatch(pattern, ext(def, options2));
      };
      m.Minimatch.defaults = function defaults3(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      };
      m.filter = function filter3(pattern, options2) {
        return orig.filter(pattern, ext(def, options2));
      };
      m.defaults = function defaults3(options2) {
        return orig.defaults(ext(def, options2));
      };
      m.makeRe = function makeRe2(pattern, options2) {
        return orig.makeRe(pattern, ext(def, options2));
      };
      m.braceExpand = function braceExpand2(pattern, options2) {
        return orig.braceExpand(pattern, ext(def, options2));
      };
      m.match = function(list2, pattern, options2) {
        return orig.match(list2, pattern, ext(def, options2));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch2.defaults(def).Minimatch;
    };
    function minimatch2(p, pattern, options2) {
      assertValidPattern(pattern);
      if (!options2)
        options2 = {};
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options2).match(p);
    }
    function Minimatch(pattern, options2) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options2);
      }
      assertValidPattern(pattern);
      if (!options2)
        options2 = {};
      pattern = pattern.trim();
      if (!options2.allowWindowsEscape && path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options2.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch2.braceExpand = function(pattern, options2) {
      return braceExpand(pattern, options2);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options2) {
      if (!options2) {
        if (this instanceof Minimatch) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand2(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse3;
    var SUBPARSE = {};
    function parse3(pattern, isSub) {
      assertValidPattern(pattern);
      var options2 = this.options;
      if (pattern === "**") {
        if (!options2.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch2.makeRe = function(pattern, options2) {
      return new Minimatch(pattern, options2 || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch2.match = function(list2, pattern, options2) {
      options2 = options2 || {};
      var mm = new Minimatch(pattern, options2);
      list2 = list2.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options2 = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options2.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options2 = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path2);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs2 = require("fs");
    var path2 = require("path");
    var minimatch2 = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch2.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options2) {
      self.ignore = options2.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && -1 === pattern.indexOf("/")) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options2.silent;
      self.pattern = pattern;
      self.strict = options2.strict !== false;
      self.realpath = !!options2.realpath;
      self.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options2.follow;
      self.dot = !!options2.dot;
      self.mark = !!options2.mark;
      self.nodir = !!options2.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options2.sync;
      self.nounique = !!options2.nounique;
      self.nonull = !!options2.nonull;
      self.nosort = !!options2.nosort;
      self.nocase = !!options2.nocase;
      self.stat = !!options2.stat;
      self.noprocess = !!options2.noprocess;
      self.absolute = !!options2.absolute;
      self.fs = options2.fs || fs2;
      self.maxLength = options2.maxLength || Infinity;
      self.cache = options2.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options2.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options2);
      self.changedCwd = false;
      var cwd2 = process.cwd();
      if (!ownProp(options2, "cwd"))
        self.cwd = cwd2;
      else {
        self.cwd = path2.resolve(options2.cwd);
        self.changedCwd = self.cwd !== cwd2;
      }
      self.root = options2.root || path2.resolve(self.cwd, "/");
      self.root = path2.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options2.nomount;
      options2.nonegate = true;
      options2.nocomment = true;
      options2.allowWindowsEscape = false;
      self.minimatch = new Minimatch(pattern, options2);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path2.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path2.resolve(self.cwd, f);
      } else {
        abs = path2.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
    function childrenIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch2 = require_minimatch();
    var Minimatch = minimatch2.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path2 = require("path");
    var assert2 = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options2) {
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options2).found;
    }
    function GlobSync(pattern, options2) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options2);
      setopts(this, pattern, options2);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert2.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert2.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name2 = fn.name || "Function wrapped with `once`";
      f.onceError = name2 + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob2;
    var rp = require_fs();
    var minimatch2 = require_minimatch();
    var Minimatch = minimatch2.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path2 = require("path");
    var assert2 = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob2(pattern, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = {};
      if (!options2)
        options2 = {};
      if (options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options2);
      }
      return new Glob(pattern, options2, cb);
    }
    glob2.sync = globSync;
    var GlobSync = glob2.GlobSync = globSync.GlobSync;
    glob2.glob = glob2;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob2.hasMagic = function(pattern, options_) {
      var options2 = extend({}, options_);
      options2.noprocess = true;
      var g = new Glob(pattern, options2);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob2.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      if (options2 && options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options2);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options2, cb);
      setopts(this, pattern, options2);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert2(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert2(this instanceof Glob);
      assert2(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/minimatch/lib/path.js"(exports2, module2) {
    var isWindows2 = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows2 ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion2 = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad2 = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad2) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch2 = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    var minimatch2 = module2.exports = (p, pattern, options2 = {}) => {
      assertValidPattern(pattern);
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options2).match(p);
    };
    module2.exports = minimatch2;
    var path2 = require_path();
    minimatch2.sep = path2.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch2.GLOBSTAR = GLOBSTAR;
    var expand2 = require_brace_expansion2();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch2.filter = (pattern, options2 = {}) => (p, i, list2) => minimatch2(p, pattern, options2);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch2.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      const orig = minimatch2;
      const m = (p, pattern, options2) => orig(p, pattern, ext(def, options2));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options2) {
          super(pattern, ext(def, options2));
        }
      };
      m.Minimatch.defaults = (options2) => orig.defaults(ext(def, options2)).Minimatch;
      m.filter = (pattern, options2) => orig.filter(pattern, ext(def, options2));
      m.defaults = (options2) => orig.defaults(ext(def, options2));
      m.makeRe = (pattern, options2) => orig.makeRe(pattern, ext(def, options2));
      m.braceExpand = (pattern, options2) => orig.braceExpand(pattern, ext(def, options2));
      m.match = (list2, pattern, options2) => orig.match(list2, pattern, ext(def, options2));
      return m;
    };
    minimatch2.braceExpand = (pattern, options2) => braceExpand(pattern, options2);
    var braceExpand = (pattern, options2 = {}) => {
      assertValidPattern(pattern);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand2(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch2.makeRe = (pattern, options2) => new Minimatch(pattern, options2 || {}).makeRe();
    minimatch2.match = (list2, pattern, options2 = {}) => {
      const mm = new Minimatch(pattern, options2);
      list2 = list2.filter((f) => mm.match(f));
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options2) {
        assertValidPattern(pattern);
        if (!options2)
          options2 = {};
        this.options = options2;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options2.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      matchOne(file, pattern, partial) {
        var options2 = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options2 = this.options;
        if (pattern === "**") {
          if (!options2.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = !!options2.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options2.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options2.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = options2.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options2 = this.options;
        if (path2.sep !== "/") {
          f = f.split(path2.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options2.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options2.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options2.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch2.defaults(def).Minimatch;
      }
    };
    minimatch2.Minimatch = Minimatch;
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path2, options2) {
      var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path2.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path2, options2) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path2, options2);
    }
    function isexe(path2, options2, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path2, options2));
      });
    }
    function sync(path2, options2) {
      return checkStat(fs2.statSync(path2), path2, options2);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path2, options2, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options2));
      });
    }
    function sync(path2, options2) {
      return checkStat(fs2.statSync(path2), options2);
    }
    function checkStat(stat, options2) {
      return stat.isFile() && checkMode(stat, options2);
    }
    function checkMode(stat, options2) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
      var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path2, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path2, options2 || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path2, options2 || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path2, options2) {
      try {
        return core.sync(path2, options2 || {});
      } catch (er) {
        if (options2 && options2.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports2, module2) {
    var isWindows2 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path2 = require("path");
    var COLON = isWindows2 ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows2 && cmd.match(/\\/) ? [""] : [
        ...isWindows2 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows2 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows2 ? pathExtExe.split(colon) : [""];
      if (isWindows2) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which2 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name2, value, isGlobal) => {
      const index = R++;
      debug(name2, index, value);
      t[name2] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options2) => !options2 ? {} : typeof options2 !== "object" ? { loose: true } : opts.filter((k) => options2[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options2) {
        options2 = parseOptions(options2);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options2.loose && version2.includePrerelease === !!options2.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version2.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse3 = (version2, options2) => {
      options2 = parseOptions(options2);
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      const r = options2.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options2);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse3 = require_parse();
    var valid = (version2, options2) => {
      const v = parse3(version2, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse3 = require_parse();
    var clean = (version2, options2) => {
      const s = parse3(version2.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options2, identifier) => {
      if (typeof options2 === "string") {
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options2
        ).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare2;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare2 = require_compare();
    var eq = (a, b, loose) => compare2(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse3 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v12 = parse3(version1);
        const v2 = parse3(version2);
        const hasPre = v12.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse3 = require_parse();
    var prerelease = (version2, options2) => {
      const parsed = parse3(version2, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare2 = require_compare();
    var rcompare = (a, b, loose) => compare2(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare2 = require_compare();
    var compareLoose = (a, b) => compare2(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare2 = require_compare();
    var gt = (a, b, loose) => compare2(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare2 = require_compare();
    var lt = (a, b, loose) => compare2(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare2 = require_compare();
    var neq = (a, b, loose) => compare2(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare2 = require_compare();
    var gte = (a, b, loose) => compare2(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare2 = require_compare();
    var lte = (a, b, loose) => compare2(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { re, t } = require_re();
    var coerce = (version2, options2) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse3(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options2);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list2) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list2);
      }
      this.list = list2;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache2 = class {
      constructor(options2) {
        if (typeof options2 === "number")
          options2 = { max: options2 };
        if (!options2)
          options2 = {};
        if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options2.max || Infinity;
        const lc = options2.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options2.stale || false;
        if (options2.maxAge && typeof options2.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options2.maxAge || 0;
        this[DISPOSE] = options2.dispose;
        this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self, key, doUse) => {
      const node = self[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    };
    var trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    };
    var del = (self, node) => {
      if (node) {
        const hit = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self);
    };
    module2.exports = LRUCache2;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var Range13 = class {
      constructor(range, options2) {
        options2 = parseOptions(options2);
        if (range instanceof Range13) {
          if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
            return range;
          } else {
            return new Range13(range.raw, options2);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range;
        this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options2) {
        if (!(range instanceof Range13)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range13;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options2) => comp.trim().split(/\s+/).map((c) => {
      return replaceTilde(c, options2);
    }).join(" ");
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => comp.trim().split(/\s+/).map((c) => {
      return replaceCaret(c, options2);
    }).join(" ");
    var replaceCaret = (comp, options2) => {
      debug("caret", comp, options2);
      const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options2.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c) => {
        return replaceXRange(c, options2);
      }).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug("replaceGTE0", comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options2) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options2 || typeof options2 !== "object") {
          options2 = {
            loose: !!options2,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range13(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range13(this.value, options2).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range13 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range13 = require_range();
    var satisfies = (version2, range, options2) => {
      try {
        range = new Range13(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range13 = require_range();
    var toComparators = (range, options2) => new Range13(range, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range13 = require_range();
    var maxSatisfying = (versions, range, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range13(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range13 = require_range();
    var minSatisfying = (versions, range, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range13(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range13 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range13(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range13 = require_range();
    var validRange = (range, options2) => {
      try {
        return new Range13(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range13 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options2) => {
      version2 = new SemVer(version2, options2);
      range = new Range13(range, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options2)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options2) => outside(version2, range, ">", options2);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options2) => outside(version2, range, "<", options2);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range13 = require_range();
    var intersects = (r1, r2, options2) => {
      r1 = new Range13(r1, options2);
      r2 = new Range13(r2, options2);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module2.exports = (versions, range, options2) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare2(a, b, options2));
      for (const version2 of v) {
        const included = satisfies(version2, range, options2);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range13 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range13(sub, options2);
      dom = new Range13(dom, options2);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options2);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = [new Comparator(">=0.0.0-0")];
        } else {
          sub = [new Comparator(">=0.0.0")];
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = [new Comparator(">=0.0.0")];
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options2);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options2);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options2)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options2);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range13 = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range: Range13,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
  }
});

// node_modules/fast-diff/diff.js
var require_diff2 = __commonJS({
  "node_modules/fast-diff/diff.js"(exports2, module2) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v12 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v12[x] = -1;
        v2[x] = -1;
      }
      v12[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v12[k1_offset - 1] < v12[k1_offset + 1]) {
            x1 = v12[k1_offset + 1];
          } else {
            x1 = v12[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v12[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v12[k1_offset] !== -1) {
              var x1 = v12[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(
              j - suffixLength,
              j
            ) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos) {
      return diff_main(text1, text2, cursor_pos, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// node_modules/unidecode/data/x00.js
var require_x00 = __commonJS({
  "node_modules/unidecode/data/x00.js"(exports2, module2) {
    module2.exports = ["\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", " ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "\x7F", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "!", "C/", "PS", "$?", "Y=", "|", "SS", '"', "(c)", "a", "<<", "!", "", "(r)", "-", "deg", "+-", "2", "3", "'", "u", "P", "*", ",", "1", "o", ">>", "1/4", "1/2", "3/4", "?", "A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "U", "Th", "ss", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "/", "o", "u", "u", "u", "u", "y", "th", "y"];
  }
});

// node_modules/unidecode/data/x01.js
var require_x01 = __commonJS({
  "node_modules/unidecode/data/x01.js"(exports2, module2) {
    module2.exports = ["A", "a", "A", "a", "A", "a", "C", "c", "C", "c", "C", "c", "C", "c", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "G", "g", "G", "g", "G", "g", "G", "g", "H", "h", "H", "h", "I", "i", "I", "i", "I", "i", "I", "i", "I", "i", "IJ", "", "J", "j", "K", "k", "k", "L", "l", "L", "l", "L", "l", "L", "l", "L", "l", "N", "n", "N", "n", "N", "n", "'n", "ng", "NG", "O", "o", "O", "o", "O", "o", "OE", "oe", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "W", "w", "Y", "y", "Y", "Z", "z", "Z", "z", "Z", "z", "s", "b", "B", "B", "b", "6", "6", "O", "C", "c", "D", "D", "D", "d", "d", "3", "@", "E", "F", "f", "G", "G", "hv", "I", "I", "K", "k", "l", "l", "W", "N", "n", "O", "O", "o", "OI", "oi", "P", "p", "YR", "2", "2", "SH", "sh", "t", "T", "t", "T", "U", "u", "Y", "V", "Y", "y", "Z", "z", "ZH", "ZH", "zh", "zh", "2", "5", "5", "ts", "w", "|", "||", "|=", "!", "DZ", "Dz", "dz", "LJ", "Lj", "lj", "NJ", "Nj", "nj", "A", "a", "I", "i", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "@", "A", "a", "A", "a", "AE", "ae", "G", "g", "G", "g", "K", "k", "O", "o", "O", "o", "ZH", "zh", "j", "DZ", "D", "dz", "G", "g", "HV", "W", "N", "n", "A", "a", "AE", "ae", "O", "o"];
  }
});

// node_modules/unidecode/data/x02.js
var require_x02 = __commonJS({
  "node_modules/unidecode/data/x02.js"(exports2, module2) {
    module2.exports = ["A", "a", "A", "a", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "R", "r", "R", "r", "U", "u", "U", "u", "S", "s", "T", "t", "Y", "y", "H", "h", "[?]", "[?]", "OU", "ou", "Z", "z", "A", "a", "E", "e", "O", "o", "O", "o", "O", "o", "O", "o", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "a", "a", "b", "o", "c", "d", "d", "e", "@", "@", "e", "e", "e", "e", "j", "g", "g", "g", "g", "u", "Y", "h", "h", "i", "i", "I", "l", "l", "l", "lZ", "W", "W", "m", "n", "n", "n", "o", "OE", "O", "F", "R", "R", "R", "R", "r", "r", "R", "R", "R", "s", "S", "j", "S", "S", "t", "t", "U", "U", "v", "^", "W", "Y", "Y", "z", "z", "Z", "Z", "?", "?", "?", "C", "@", "B", "E", "G", "H", "j", "k", "L", "q", "?", "?", "dz", "dZ", "dz", "ts", "tS", "tC", "fN", "ls", "lz", "WW", "]]", "[?]", "[?]", "k", "h", "j", "r", "r", "r", "r", "w", "y", "'", '"', "`", "'", "`", "`", "'", "?", "?", "<", ">", "^", "V", "^", "V", "'", "-", "/", "\\", ",", "_", "\\", "/", ":", ".", "`", "'", "^", "V", "+", "-", "V", ".", "@", ",", "~", '"', "R", "X", "G", "l", "s", "x", "?", "", "", "", "", "", "", "", "V", "=", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x03.js
var require_x03 = __commonJS({
  "node_modules/unidecode/data/x03.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "'", ",", "[?]", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "?", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "A", ";", "E", "E", "I", "[?]", "O", "[?]", "U", "O", "I", "A", "B", "G", "D", "E", "Z", "E", "Th", "I", "K", "L", "M", "N", "Ks", "O", "P", "R", "[?]", "S", "T", "U", "Ph", "Kh", "Ps", "O", "I", "U", "a", "e", "e", "i", "u", "a", "b", "g", "d", "e", "z", "e", "th", "i", "k", "l", "m", "n", "x", "o", "p", "r", "s", "s", "t", "u", "ph", "kh", "ps", "o", "i", "u", "o", "u", "o", "[?]", "b", "th", "U", "U", "U", "ph", "p", "&", "[?]", "[?]", "St", "st", "W", "w", "Q", "q", "Sp", "sp", "Sh", "sh", "F", "f", "Kh", "kh", "H", "h", "G", "g", "CH", "ch", "Ti", "ti", "k", "r", "c", "j", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x04.js
var require_x04 = __commonJS({
  "node_modules/unidecode/data/x04.js"(exports2, module2) {
    module2.exports = ["Ie", "Io", "Dj", "Gj", "Ie", "Dz", "I", "Yi", "J", "Lj", "Nj", "Tsh", "Kj", "I", "U", "Dzh", "A", "B", "V", "G", "D", "Ie", "Zh", "Z", "I", "I", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "Kh", "Ts", "Ch", "Sh", "Shch", "", "Y", "'", "E", "Iu", "Ia", "a", "b", "v", "gh", "d", "ie", "zh", "z", "i", "i", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "kh", "ts", "ch", "sh", "shch", "", "y", "'", "e", "iu", "ia", "ie", "io", "dj", "gj", "ie", "dz", "i", "yi", "j", "lj", "nj", "tsh", "kj", "i", "u", "dzh", "O", "o", "E", "e", "Ie", "ie", "E", "e", "Ie", "ie", "O", "o", "Io", "io", "Ks", "ks", "Ps", "ps", "F", "f", "Y", "y", "Y", "y", "u", "u", "O", "o", "O", "o", "Ot", "ot", "Q", "q", "*1000*", "", "", "", "", "[?]", "*100.000*", "*1.000.000*", "[?]", "[?]", '"', '"', "R'", "r'", "G'", "g'", "G'", "g'", "G'", "g'", "Zh'", "zh'", "Z'", "z'", "K'", "k'", "K'", "k'", "K'", "k'", "K'", "k'", "N'", "n'", "Ng", "ng", "P'", "p'", "Kh", "kh", "S'", "s'", "T'", "t'", "U", "u", "U'", "u'", "Kh'", "kh'", "Tts", "tts", "Ch'", "ch'", "Ch'", "ch'", "H", "h", "Ch", "ch", "Ch'", "ch'", "`", "Zh", "zh", "K'", "k'", "[?]", "[?]", "N'", "n'", "[?]", "[?]", "Ch", "ch", "[?]", "[?]", "[?]", "a", "a", "A", "a", "Ae", "ae", "Ie", "ie", "@", "@", "@", "@", "Zh", "zh", "Z", "z", "Dz", "dz", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "E", "e", "U", "u", "U", "u", "U", "u", "Ch", "ch", "[?]", "[?]", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x05.js
var require_x05 = __commonJS({
  "node_modules/unidecode/data/x05.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "Z", "E", "E", "T`", "Zh", "I", "L", "Kh", "Ts", "K", "H", "Dz", "Gh", "Ch", "M", "Y", "N", "Sh", "O", "Ch`", "P", "J", "Rh", "S", "V", "T", "R", "Ts`", "W", "P`", "K`", "O", "F", "[?]", "[?]", "<", "'", "/", "!", ",", "?", ".", "[?]", "a", "b", "g", "d", "e", "z", "e", "e", "t`", "zh", "i", "l", "kh", "ts", "k", "h", "dz", "gh", "ch", "m", "y", "n", "sh", "o", "ch`", "p", "j", "rh", "s", "v", "t", "r", "ts`", "w", "p`", "k`", "o", "f", "ew", "[?]", ".", "-", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "@", "e", "a", "o", "i", "e", "e", "a", "a", "o", "[?]", "u", "'", "", "", "", "", "", "", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "b", "g", "d", "h", "v", "z", "kh", "t", "y", "k", "k", "l", "m", "m", "n", "n", "s", "`", "p", "p", "ts", "ts", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "[?]", "[?]", "V", "oy", "i", "'", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x06.js
var require_x06 = __commonJS({
  "node_modules/unidecode/data/x06.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ",", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ";", "[?]", "[?]", "[?]", "?", "[?]", "", "a", "'", "w'", "", "y'", "", "b", "@", "t", "th", "j", "H", "kh", "d", "dh", "r", "z", "s", "sh", "S", "D", "T", "Z", "aa", "G", "[?]", "[?]", "[?]", "[?]", "[?]", "", "f", "q", "k", "l", "m", "n", "h", "w", "~", "y", "an", "un", "in", "a", "u", "i", "W", "", "", "'", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%", ".", ",", "*", "[?]", "[?]", "", "'", "'", "'", "", "'", "'w", "'u", "'y", "tt", "tth", "b", "t", "T", "p", "th", "bh", "'h", "H", "ny", "dy", "H", "ch", "cch", "dd", "D", "D", "Dt", "dh", "ddh", "d", "D", "D", "rr", "R", "R", "R", "R", "R", "R", "j", "R", "S", "S", "S", "S", "S", "T", "GH", "F", "F", "F", "v", "f", "ph", "Q", "Q", "kh", "k", "K", "K", "ng", "K", "g", "G", "N", "G", "G", "G", "L", "L", "L", "L", "N", "N", "N", "N", "N", "h", "Ch", "hy", "h", "H", "@", "W", "oe", "oe", "u", "yu", "yu", "W", "v", "y", "Y", "Y", "W", "", "", "y", "y'", ".", "ae", "", "", "", "", "", "", "", "@", "#", "", "", "", "", "", "", "", "", "", "", "^", "", "", "", "", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Sh", "D", "Gh", "&", "+m"];
  }
});

// node_modules/unidecode/data/x07.js
var require_x07 = __commonJS({
  "node_modules/unidecode/data/x07.js"(exports2, module2) {
    module2.exports = ["//", "/", ",", "!", "!", "-", ",", ",", ";", "?", "~", "{", "}", "*", "[?]", "", "'", "", "b", "g", "g", "d", "d", "h", "w", "z", "H", "t", "t", "y", "yh", "k", "l", "m", "n", "s", "s", "`", "p", "p", "S", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "a", "a", "a", "A", "A", "A", "e", "e", "e", "E", "i", "i", "u", "u", "u", "o", "", "`", "'", "", "", "X", "Q", "@", "@", "|", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "h", "sh", "n", "r", "b", "L", "k", "'", "v", "m", "f", "dh", "th", "l", "g", "ny", "s", "d", "z", "t", "y", "p", "j", "ch", "tt", "hh", "kh", "th", "z", "sh", "s", "d", "t", "z", "`", "gh", "q", "w", "a", "aa", "i", "ee", "u", "oo", "e", "ey", "o", "oa", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x09.js
var require_x09 = __commonJS({
  "node_modules/unidecode/data/x09.js"(exports2, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "eN", "e", "e", "ai", "oN", "o", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "nnn", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "l", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "e", "e", "ai", "oN", "o", "o", "au", "", "[?]", "[?]", "AUM", "'", "'", "`", "'", "[?]", "[?]", "[?]", "q", "khh", "ghh", "z", "dddh", "rh", "f", "yy", "RR", "LL", "L", "LL", " / ", " // ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "[?]", "[?]", "[?]", "sh", "ss", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "L", "LL", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "r'", "r`", "Rs", "Rs", "1/", "2/", "3/", "4/", " 1 - 1/", "/16", "", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0a.js
var require_x0a = __commonJS({
  "node_modules/unidecode/data/x0a.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "N", "[?]", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bb", "m", "y", "r", "[?]", "l", "ll", "[?]", "v", "sh", "[?]", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "khh", "ghh", "z", "rr", "[?]", "f", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "N", "H", "", "", "G.E.O.", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "[?]", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "ya", "r", "[?]", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "", "[?]", "[?]", "AUM", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0b.js
var require_x0b = __commonJS({
  "node_modules/unidecode/data/x0b.js"(exports2, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "ll", "[?]", "", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "[?]", "[?]", "[?]", "ng", "c", "[?]", "j", "[?]", "ny", "tt", "[?]", "[?]", "[?]", "nn", "t", "[?]", "[?]", "[?]", "n", "nnn", "p", "[?]", "[?]", "[?]", "m", "y", "r", "rr", "l", "ll", "lll", "v", "[?]", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+10+", "+100+", "+1000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0c.js
var require_x0c = __commonJS({
  "node_modules/unidecode/data/x0c.js"(exports2, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "lll", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0d.js
var require_x0d = __commonJS({
  "node_modules/unidecode/data/x0d.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "e", "ee", "ai", "", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "ae", "aae", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "ai", "o", "oo", "au", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "nng", "c", "ch", "j", "jh", "ny", "jny", "nyj", "tt", "tth", "dd", "ddh", "nn", "nndd", "t", "th", "d", "dh", "n", "[?]", "nd", "p", "ph", "b", "bh", "m", "mb", "y", "r", "[?]", "l", "[?]", "[?]", "v", "sh", "ss", "s", "h", "ll", "f", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "aa", "ae", "aae", "i", "ii", "u", "[?]", "uu", "[?]", "R", "e", "ee", "ai", "o", "oo", "au", "L", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", " . ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0e.js
var require_x0e = __commonJS({
  "node_modules/unidecode/data/x0e.js"(exports2, module2) {
    module2.exports = ["[?]", "k", "kh", "kh", "kh", "kh", "kh", "ng", "cch", "ch", "ch", "ch", "ch", "y", "d", "t", "th", "th", "th", "n", "d", "t", "th", "th", "th", "n", "b", "p", "ph", "f", "ph", "f", "ph", "m", "y", "r", "R", "l", "L", "w", "s", "s", "s", "h", "l", "`", "h", "~", "a", "a", "aa", "am", "i", "ii", "ue", "uue", "u", "uu", "'", "[?]", "[?]", "[?]", "[?]", "Bh.", "e", "ae", "o", "ai", "ai", "ao", "+", "", "", "", "", "", "", "M", "", " * ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " // ", " /// ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "[?]", "kh", "[?]", "[?]", "ng", "ch", "[?]", "s", "[?]", "[?]", "ny", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "d", "h", "th", "th", "[?]", "n", "b", "p", "ph", "f", "ph", "f", "[?]", "m", "y", "r", "[?]", "l", "[?]", "w", "[?]", "[?]", "s", "h", "[?]", "`", "", "~", "a", "", "aa", "am", "i", "ii", "y", "yy", "u", "uu", "[?]", "o", "l", "ny", "[?]", "[?]", "e", "ei", "o", "ay", "ai", "[?]", "+", "[?]", "", "", "", "", "", "M", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "hn", "hm", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0f.js
var require_x0f = __commonJS({
  "node_modules/unidecode/data/x0f.js"(exports2, module2) {
    module2.exports = ["AUM", "", "", "", "", "", "", "", " // ", " * ", "", "-", " / ", " / ", " // ", " -/ ", " +/ ", " X/ ", " /XX/ ", " /X/ ", ", ", "", "", "", "", "", "", "", "", "", "", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".5", "1.5", "2.5", "3.5", "4.5", "5.5", "6.5", "7.5", "8.5", "-.5", "+", "*", "^", "_", "", "~", "[?]", "]", "[[", "]]", "", "", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ssh", "s", "h", "a", "kss", "r", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "o", "oo", "M", "H", "i", "ii", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ss", "s", "h", "a", "kss", "w", "y", "r", "[?]", "X", " :X: ", " /O/ ", " /o/ ", " \\o\\ ", " (O) ", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x10.js
var require_x10 = __commonJS({
  "node_modules/unidecode/data/x10.js"(exports2, module2) {
    module2.exports = ["k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "nny", "tt", "tth", "dd", "ddh", "nn", "tt", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "w", "s", "h", "ll", "a", "[?]", "i", "ii", "u", "uu", "e", "[?]", "o", "au", "[?]", "aa", "i", "ii", "u", "uu", "e", "ai", "[?]", "[?]", "[?]", "N", "'", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " / ", " // ", "n*", "r*", "l*", "e*", "sh", "ss", "R", "RR", "L", "LL", "R", "RR", "L", "LL", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "V", "Z", "T`", "I", "K", "L", "M", "N", "O", "P", "Zh", "R", "S", "T", "U", "P`", "K`", "G'", "Q", "Sh", "Ch`", "C`", "Z'", "C", "Ch", "X", "J", "H", "E", "Y", "W", "Xh", "OE", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "b", "g", "d", "e", "v", "z", "t`", "i", "k", "l", "m", "n", "o", "p", "zh", "r", "s", "t", "u", "p`", "k`", "g'", "q", "sh", "ch`", "c`", "z'", "c", "ch", "x", "j", "h", "e", "y", "w", "xh", "oe", "f", "[?]", "[?]", "[?]", "[?]", " // ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x11.js
var require_x11 = __commonJS({
  "node_modules/unidecode/data/x11.js"(exports2, module2) {
    module2.exports = ["g", "gg", "n", "d", "dd", "r", "m", "b", "bb", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "ng", "nn", "nd", "nb", "dg", "rn", "rr", "rh", "rN", "mb", "mN", "bg", "bn", "", "bs", "bsg", "bst", "bsb", "bss", "bsj", "bj", "bc", "bt", "bp", "bN", "bbN", "sg", "sn", "sd", "sr", "sm", "sb", "sbg", "sss", "s", "sj", "sc", "sk", "st", "sp", "sh", "", "", "", "", "Z", "g", "d", "m", "b", "s", "Z", "", "j", "c", "t", "p", "N", "j", "", "", "", "", "ck", "ch", "", "", "pb", "pN", "hh", "Q", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "a-o", "a-u", "ya-o", "ya-yo", "eo-o", "eo-u", "eo-eu", "yeo-o", "yeo-u", "o-eo", "o-e", "o-ye", "o-o", "o-u", "yo-ya", "yo-yae", "yo-yeo", "yo-o", "yo-i", "u-a", "u-ae", "u-eo-eu", "u-ye", "u-u", "yu-a", "yu-eo", "yu-e", "yu-yeo", "yu-ye", "yu-u", "yu-i", "eu-u", "eu-eu", "yi-u", "i-a", "i-ya", "i-o", "i-u", "i-eu", "i-U", "U", "U-eo", "U-u", "U-i", "UU", "[?]", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "l", "lg", "lm", "lb", "ls", "lt", "lp", "lh", "m", "b", "bs", "s", "ss", "ng", "j", "c", "k", "t", "p", "h", "gl", "gsg", "ng", "nd", "ns", "nZ", "nt", "dg", "tl", "lgs", "ln", "ld", "lth", "ll", "lmg", "lms", "lbs", "lbh", "rNp", "lss", "lZ", "lk", "lQ", "mg", "ml", "mb", "ms", "mss", "mZ", "mc", "mh", "mN", "bl", "bp", "ph", "pN", "sg", "sd", "sl", "sb", "Z", "g", "ss", "", "kh", "N", "Ns", "NZ", "pb", "pN", "hn", "hl", "hm", "hb", "Q", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x12.js
var require_x12 = __commonJS({
  "node_modules/unidecode/data/x12.js"(exports2, module2) {
    module2.exports = ["ha", "hu", "hi", "haa", "hee", "he", "ho", "[?]", "la", "lu", "li", "laa", "lee", "le", "lo", "lwa", "hha", "hhu", "hhi", "hhaa", "hhee", "hhe", "hho", "hhwa", "ma", "mu", "mi", "maa", "mee", "me", "mo", "mwa", "sza", "szu", "szi", "szaa", "szee", "sze", "szo", "szwa", "ra", "ru", "ri", "raa", "ree", "re", "ro", "rwa", "sa", "su", "si", "saa", "see", "se", "so", "swa", "sha", "shu", "shi", "shaa", "shee", "she", "sho", "shwa", "qa", "qu", "qi", "qaa", "qee", "qe", "qo", "[?]", "qwa", "[?]", "qwi", "qwaa", "qwee", "qwe", "[?]", "[?]", "qha", "qhu", "qhi", "qhaa", "qhee", "qhe", "qho", "[?]", "qhwa", "[?]", "qhwi", "qhwaa", "qhwee", "qhwe", "[?]", "[?]", "ba", "bu", "bi", "baa", "bee", "be", "bo", "bwa", "va", "vu", "vi", "vaa", "vee", "ve", "vo", "vwa", "ta", "tu", "ti", "taa", "tee", "te", "to", "twa", "ca", "cu", "ci", "caa", "cee", "ce", "co", "cwa", "xa", "xu", "xi", "xaa", "xee", "xe", "xo", "[?]", "xwa", "[?]", "xwi", "xwaa", "xwee", "xwe", "[?]", "[?]", "na", "nu", "ni", "naa", "nee", "ne", "no", "nwa", "nya", "nyu", "nyi", "nyaa", "nyee", "nye", "nyo", "nywa", "'a", "'u", "[?]", "'aa", "'ee", "'e", "'o", "'wa", "ka", "ku", "ki", "kaa", "kee", "ke", "ko", "[?]", "kwa", "[?]", "kwi", "kwaa", "kwee", "kwe", "[?]", "[?]", "kxa", "kxu", "kxi", "kxaa", "kxee", "kxe", "kxo", "[?]", "kxwa", "[?]", "kxwi", "kxwaa", "kxwee", "kxwe", "[?]", "[?]", "wa", "wu", "wi", "waa", "wee", "we", "wo", "[?]", "`a", "`u", "`i", "`aa", "`ee", "`e", "`o", "[?]", "za", "zu", "zi", "zaa", "zee", "ze", "zo", "zwa", "zha", "zhu", "zhi", "zhaa", "zhee", "zhe", "zho", "zhwa", "ya", "yu", "yi", "yaa", "yee", "ye", "yo", "[?]", "da", "du", "di", "daa", "dee", "de", "do", "dwa", "dda", "ddu", "ddi", "ddaa", "ddee", "dde", "ddo", "ddwa"];
  }
});

// node_modules/unidecode/data/x13.js
var require_x13 = __commonJS({
  "node_modules/unidecode/data/x13.js"(exports2, module2) {
    module2.exports = ["ja", "ju", "ji", "jaa", "jee", "je", "jo", "jwa", "ga", "gu", "gi", "gaa", "gee", "ge", "go", "[?]", "gwa", "[?]", "gwi", "gwaa", "gwee", "gwe", "[?]", "[?]", "gga", "ggu", "ggi", "ggaa", "ggee", "gge", "ggo", "[?]", "tha", "thu", "thi", "thaa", "thee", "the", "tho", "thwa", "cha", "chu", "chi", "chaa", "chee", "che", "cho", "chwa", "pha", "phu", "phi", "phaa", "phee", "phe", "pho", "phwa", "tsa", "tsu", "tsi", "tsaa", "tsee", "tse", "tso", "tswa", "tza", "tzu", "tzi", "tzaa", "tzee", "tze", "tzo", "[?]", "fa", "fu", "fi", "faa", "fee", "fe", "fo", "fwa", "pa", "pu", "pi", "paa", "pee", "pe", "po", "pwa", "rya", "mya", "fya", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", ".", ",", ";", ":", ":: ", "?", "//", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+", "20+", "30+", "40+", "50+", "60+", "70+", "80+", "90+", "100+", "10,000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "v", "ga", "ka", "ge", "gi", "go", "gu", "gv", "ha", "he", "hi", "ho", "hu", "hv", "la", "le", "li", "lo", "lu", "lv", "ma", "me", "mi", "mo", "mu", "na", "hna", "nah", "ne", "ni", "no", "nu", "nv", "qua", "que", "qui", "quo", "quu", "quv", "sa", "s", "se", "si", "so", "su", "sv", "da", "ta", "de", "te", "di", "ti", "do", "du", "dv", "dla", "tla", "tle", "tli", "tlo", "tlu", "tlv", "tsa", "tse", "tsi", "tso", "tsu", "tsv", "wa", "we", "wi", "wo", "wu", "wv", "ya", "ye", "yi", "yo", "yu", "yv", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x14.js
var require_x14 = __commonJS({
  "node_modules/unidecode/data/x14.js"(exports2, module2) {
    module2.exports = ["[?]", "e", "aai", "i", "ii", "o", "oo", "oo", "ee", "i", "a", "aa", "we", "we", "wi", "wi", "wii", "wii", "wo", "wo", "woo", "woo", "woo", "wa", "wa", "waa", "waa", "waa", "ai", "w", "'", "t", "k", "sh", "s", "n", "w", "n", "[?]", "w", "c", "?", "l", "en", "in", "on", "an", "pe", "paai", "pi", "pii", "po", "poo", "poo", "hee", "hi", "pa", "paa", "pwe", "pwe", "pwi", "pwi", "pwii", "pwii", "pwo", "pwo", "pwoo", "pwoo", "pwa", "pwa", "pwaa", "pwaa", "pwaa", "p", "p", "h", "te", "taai", "ti", "tii", "to", "too", "too", "dee", "di", "ta", "taa", "twe", "twe", "twi", "twi", "twii", "twii", "two", "two", "twoo", "twoo", "twa", "twa", "twaa", "twaa", "twaa", "t", "tte", "tti", "tto", "tta", "ke", "kaai", "ki", "kii", "ko", "koo", "koo", "ka", "kaa", "kwe", "kwe", "kwi", "kwi", "kwii", "kwii", "kwo", "kwo", "kwoo", "kwoo", "kwa", "kwa", "kwaa", "kwaa", "kwaa", "k", "kw", "keh", "kih", "koh", "kah", "ce", "caai", "ci", "cii", "co", "coo", "coo", "ca", "caa", "cwe", "cwe", "cwi", "cwi", "cwii", "cwii", "cwo", "cwo", "cwoo", "cwoo", "cwa", "cwa", "cwaa", "cwaa", "cwaa", "c", "th", "me", "maai", "mi", "mii", "mo", "moo", "moo", "ma", "maa", "mwe", "mwe", "mwi", "mwi", "mwii", "mwii", "mwo", "mwo", "mwoo", "mwoo", "mwa", "mwa", "mwaa", "mwaa", "mwaa", "m", "m", "mh", "m", "m", "ne", "naai", "ni", "nii", "no", "noo", "noo", "na", "naa", "nwe", "nwe", "nwa", "nwa", "nwaa", "nwaa", "nwaa", "n", "ng", "nh", "le", "laai", "li", "lii", "lo", "loo", "loo", "la", "laa", "lwe", "lwe", "lwi", "lwi", "lwii", "lwii", "lwo", "lwo", "lwoo", "lwoo", "lwa", "lwa", "lwaa", "lwaa", "l", "l", "l", "se", "saai", "si", "sii", "so", "soo", "soo", "sa", "saa", "swe", "swe", "swi", "swi", "swii", "swii", "swo", "swo", "swoo", "swoo"];
  }
});

// node_modules/unidecode/data/x15.js
var require_x15 = __commonJS({
  "node_modules/unidecode/data/x15.js"(exports2, module2) {
    module2.exports = ["swa", "swa", "swaa", "swaa", "swaa", "s", "s", "sw", "s", "sk", "skw", "sW", "spwa", "stwa", "skwa", "scwa", "she", "shi", "shii", "sho", "shoo", "sha", "shaa", "shwe", "shwe", "shwi", "shwi", "shwii", "shwii", "shwo", "shwo", "shwoo", "shwoo", "shwa", "shwa", "shwaa", "shwaa", "sh", "ye", "yaai", "yi", "yii", "yo", "yoo", "yoo", "ya", "yaa", "ywe", "ywe", "ywi", "ywi", "ywii", "ywii", "ywo", "ywo", "ywoo", "ywoo", "ywa", "ywa", "ywaa", "ywaa", "ywaa", "y", "y", "y", "yi", "re", "re", "le", "raai", "ri", "rii", "ro", "roo", "lo", "ra", "raa", "la", "rwaa", "rwaa", "r", "r", "r", "fe", "faai", "fi", "fii", "fo", "foo", "fa", "faa", "fwaa", "fwaa", "f", "the", "the", "thi", "thi", "thii", "thii", "tho", "thoo", "tha", "thaa", "thwaa", "thwaa", "th", "tthe", "tthi", "ttho", "ttha", "tth", "tye", "tyi", "tyo", "tya", "he", "hi", "hii", "ho", "hoo", "ha", "haa", "h", "h", "hk", "qaai", "qi", "qii", "qo", "qoo", "qa", "qaa", "q", "tlhe", "tlhi", "tlho", "tlha", "re", "ri", "ro", "ra", "ngaai", "ngi", "ngii", "ngo", "ngoo", "nga", "ngaa", "ng", "nng", "she", "shi", "sho", "sha", "the", "thi", "tho", "tha", "th", "lhi", "lhii", "lho", "lhoo", "lha", "lhaa", "lh", "the", "thi", "thii", "tho", "thoo", "tha", "thaa", "th", "b", "e", "i", "o", "a", "we", "wi", "wo", "wa", "ne", "ni", "no", "na", "ke", "ki", "ko", "ka", "he", "hi", "ho", "ha", "ghu", "gho", "ghe", "ghee", "ghi", "gha", "ru", "ro", "re", "ree", "ri", "ra", "wu", "wo", "we", "wee", "wi", "wa", "hwu", "hwo", "hwe", "hwee", "hwi", "hwa", "thu", "tho", "the", "thee", "thi", "tha", "ttu", "tto", "tte", "ttee", "tti", "tta", "pu", "po", "pe", "pee", "pi", "pa", "p", "gu", "go", "ge", "gee", "gi", "ga", "khu", "kho", "khe", "khee", "khi", "kha", "kku", "kko", "kke", "kkee", "kki"];
  }
});

// node_modules/unidecode/data/x16.js
var require_x16 = __commonJS({
  "node_modules/unidecode/data/x16.js"(exports2, module2) {
    module2.exports = ["kka", "kk", "nu", "no", "ne", "nee", "ni", "na", "mu", "mo", "me", "mee", "mi", "ma", "yu", "yo", "ye", "yee", "yi", "ya", "ju", "ju", "jo", "je", "jee", "ji", "ji", "ja", "jju", "jjo", "jje", "jjee", "jji", "jja", "lu", "lo", "le", "lee", "li", "la", "dlu", "dlo", "dle", "dlee", "dli", "dla", "lhu", "lho", "lhe", "lhee", "lhi", "lha", "tlhu", "tlho", "tlhe", "tlhee", "tlhi", "tlha", "tlu", "tlo", "tle", "tlee", "tli", "tla", "zu", "zo", "ze", "zee", "zi", "za", "z", "z", "dzu", "dzo", "dze", "dzee", "dzi", "dza", "su", "so", "se", "see", "si", "sa", "shu", "sho", "she", "shee", "shi", "sha", "sh", "tsu", "tso", "tse", "tsee", "tsi", "tsa", "chu", "cho", "che", "chee", "chi", "cha", "ttsu", "ttso", "ttse", "ttsee", "ttsi", "ttsa", "X", ".", "qai", "ngai", "nngi", "nngii", "nngo", "nngoo", "nnga", "nngaa", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", "b", "l", "f", "s", "n", "h", "d", "t", "c", "q", "m", "g", "ng", "z", "r", "a", "o", "u", "e", "i", "ch", "th", "ph", "p", "x", "p", "<", ">", "[?]", "[?]", "[?]", "f", "v", "u", "yr", "y", "w", "th", "th", "a", "o", "ac", "ae", "o", "o", "o", "oe", "on", "r", "k", "c", "k", "g", "ng", "g", "g", "w", "h", "h", "h", "h", "n", "n", "n", "i", "e", "j", "g", "ae", "a", "eo", "p", "z", "s", "s", "s", "c", "z", "t", "t", "d", "b", "b", "p", "p", "e", "m", "m", "m", "l", "l", "ng", "ng", "d", "o", "ear", "ior", "qu", "qu", "qu", "s", "yr", "yr", "yr", "q", "x", ".", ":", "+", "17", "18", "19", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x17.js
var require_x17 = __commonJS({
  "node_modules/unidecode/data/x17.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "t", "tth", "d", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "v", "sh", "ss", "s", "h", "l", "q", "a", "aa", "i", "ii", "u", "uk", "uu", "uuv", "ry", "ryy", "ly", "lyy", "e", "ai", "oo", "oo", "au", "a", "aa", "aa", "i", "ii", "y", "yy", "u", "uu", "ua", "oe", "ya", "ie", "e", "ae", "ai", "oo", "au", "M", "H", "a`", "", "", "", "r", "", "!", "", "", "", "", "", ".", " // ", ":", "+", "++", " * ", " /// ", "KR", "'", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x18.js
var require_x18 = __commonJS({
  "node_modules/unidecode/data/x18.js"(exports2, module2) {
    module2.exports = [" @ ", " ... ", ", ", ". ", ": ", " // ", "", "-", ", ", ". ", "", "", "", "", "", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "O", "U", "ee", "n", "ng", "b", "p", "q", "g", "m", "l", "s", "sh", "t", "d", "ch", "j", "y", "r", "w", "f", "k", "kha", "ts", "z", "h", "zr", "lh", "zh", "ch", "-", "e", "i", "o", "u", "O", "U", "ng", "b", "p", "q", "g", "m", "t", "d", "ch", "j", "ts", "y", "w", "k", "g", "h", "jy", "ny", "dz", "e", "i", "iy", "U", "u", "ng", "k", "g", "h", "p", "sh", "t", "d", "j", "f", "g", "h", "ts", "z", "r", "ch", "zh", "i", "k", "r", "f", "zh", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "H", "X", "W", "M", " 3 ", " 333 ", "a", "i", "k", "ng", "c", "tt", "tth", "dd", "nn", "t", "d", "p", "ph", "ss", "zh", "z", "a", "t", "zh", "gh", "ng", "c", "jh", "tta", "ddh", "t", "dh", "ss", "cy", "zh", "z", "u", "y", "bh", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1e.js
var require_x1e = __commonJS({
  "node_modules/unidecode/data/x1e.js"(exports2, module2) {
    module2.exports = ["A", "a", "B", "b", "B", "b", "B", "b", "C", "c", "D", "d", "D", "d", "D", "d", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "F", "f", "G", "g", "H", "h", "H", "h", "H", "h", "H", "h", "H", "h", "I", "i", "I", "i", "K", "k", "K", "k", "K", "k", "L", "l", "L", "l", "L", "l", "L", "l", "M", "m", "M", "m", "M", "m", "N", "n", "N", "n", "N", "n", "N", "n", "O", "o", "O", "o", "O", "o", "O", "o", "P", "p", "P", "p", "R", "r", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "V", "v", "V", "v", "W", "w", "W", "w", "W", "w", "W", "w", "W", "w", "X", "x", "X", "x", "Y", "y", "Z", "z", "Z", "z", "Z", "z", "h", "t", "w", "y", "a", "S", "[?]", "[?]", "[?]", "[?]", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "Y", "y", "Y", "y", "Y", "y", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1f.js
var require_x1f = __commonJS({
  "node_modules/unidecode/data/x1f.js"(exports2, module2) {
    module2.exports = ["a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "[?]", "[?]", "E", "E", "E", "E", "E", "E", "[?]", "[?]", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "o", "o", "o", "o", "o", "o", "[?]", "[?]", "O", "O", "O", "O", "O", "O", "[?]", "[?]", "u", "u", "u", "u", "u", "u", "u", "u", "[?]", "U", "[?]", "U", "[?]", "U", "[?]", "U", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "e", "e", "e", "e", "i", "i", "o", "o", "u", "u", "o", "o", "[?]", "[?]", "a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "a", "a", "a", "[?]", "a", "a", "A", "A", "A", "A", "A", "'", "i", "'", "~", '"~', "e", "e", "e", "[?]", "e", "e", "E", "E", "E", "E", "E", "'`", "''", "'~", "i", "i", "i", "i", "[?]", "[?]", "i", "i", "I", "I", "I", "I", "[?]", "`'", "`'", "`~", "u", "u", "u", "u", "R", "R", "u", "u", "U", "U", "U", "U", "R", '"`', `"'`, "`", "[?]", "[?]", "o", "o", "o", "[?]", "o", "o", "O", "O", "O", "O", "O", "'", "`"];
  }
});

// node_modules/unidecode/data/x20.js
var require_x20 = __commonJS({
  "node_modules/unidecode/data/x20.js"(exports2, module2) {
    module2.exports = [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "", "", "", "", "-", "-", "-", "-", "--", "--", "||", "_", "'", "'", ",", "'", '"', '"', ",,", '"', "+", "++", "*", "*>", ".", "..", "...", ".", "\n", "\n\n", "", "", "", "", "", " ", "%0", "%00", "'", "''", "'''", "`", "``", "```", "^", "<", ">", "*", "!!", "!?", "-", "_", "-", "^", "***", "--", "/", "-[", "]-", "[?]", "?!", "!?", "7", "PP", "(]", "[)", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "0", "", "", "", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "n", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "ECU", "CL", "Cr", "FF", "L", "mil", "N", "Pts", "Rs", "W", "NS", "D", "EU", "K", "T", "Dr", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x21.js
var require_x21 = __commonJS({
  "node_modules/unidecode/data/x21.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " 1/3 ", " 2/3 ", " 1/5 ", " 2/5 ", " 3/5 ", " 4/5 ", " 1/6 ", " 5/6 ", " 1/8 ", " 3/8 ", " 5/8 ", " 7/8 ", " 1/", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "L", "C", "D", "M", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix", "x", "xi", "xii", "l", "c", "d", "m", "(D", "D)", "((|))", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "-", "|", "-", "|", "-", "|", "\\", "/", "\\", "/", "-", "-", "~", "~", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "-", "-", "-", "-", "-", "-", "|", "|", "|", "|", "|", "|", "|", "^", "V", "\\", "=", "V", "^", "-", "-", "|", "|", "-", "-", "|", "|", "=", "|", "=", "=", "|", "=", "|", "=", "=", "=", "=", "=", "=", "|", "=", "|", "=", "|", "\\", "/", "\\", "/", "=", "=", "~", "~", "|", "|", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "|", "|", "|", "|", "|", "-", "\\", "\\", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x22.js
var require_x22 = __commonJS({
  "node_modules/unidecode/data/x22.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x23.js
var require_x23 = __commonJS({
  "node_modules/unidecode/data/x23.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x24.js
var require_x24 = __commonJS({
  "node_modules/unidecode/data/x24.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x25.js
var require_x25 = __commonJS({
  "node_modules/unidecode/data/x25.js"(exports2, module2) {
    module2.exports = ["-", "-", "|", "|", "-", "-", "|", "|", "-", "-", "|", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "|", "|", "-", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "/", "\\", "X", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "-", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "^", "^", "^", "^", ">", ">", ">", ">", ">", ">", "V", "V", "V", "V", "<", "<", "<", "<", "<", "<", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "#", "#", "#", "#", "#", "^", "^", "^", "O", "#", "#", "#", "#", "#", "#", "#", "#", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x26.js
var require_x26 = __commonJS({
  "node_modules/unidecode/data/x26.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x27.js
var require_x27 = __commonJS({
  "node_modules/unidecode/data/x27.js"(exports2, module2) {
    module2.exports = ["[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x28.js
var require_x28 = __commonJS({
  "node_modules/unidecode/data/x28.js"(exports2, module2) {
    module2.exports = [" ", "a", "1", "b", "'", "k", "2", "l", "@", "c", "i", "f", "/", "m", "s", "p", '"', "e", "3", "h", "9", "o", "6", "r", "^", "d", "j", "g", ">", "n", "t", "q", ",", "*", "5", "<", "-", "u", "8", "v", ".", "%", "[", "$", "+", "x", "!", "&", ";", ":", "4", "\\", "0", "z", "7", "(", "_", "?", "w", "]", "#", "y", ")", "=", "[d7]", "[d17]", "[d27]", "[d127]", "[d37]", "[d137]", "[d237]", "[d1237]", "[d47]", "[d147]", "[d247]", "[d1247]", "[d347]", "[d1347]", "[d2347]", "[d12347]", "[d57]", "[d157]", "[d257]", "[d1257]", "[d357]", "[d1357]", "[d2357]", "[d12357]", "[d457]", "[d1457]", "[d2457]", "[d12457]", "[d3457]", "[d13457]", "[d23457]", "[d123457]", "[d67]", "[d167]", "[d267]", "[d1267]", "[d367]", "[d1367]", "[d2367]", "[d12367]", "[d467]", "[d1467]", "[d2467]", "[d12467]", "[d3467]", "[d13467]", "[d23467]", "[d123467]", "[d567]", "[d1567]", "[d2567]", "[d12567]", "[d3567]", "[d13567]", "[d23567]", "[d123567]", "[d4567]", "[d14567]", "[d24567]", "[d124567]", "[d34567]", "[d134567]", "[d234567]", "[d1234567]", "[d8]", "[d18]", "[d28]", "[d128]", "[d38]", "[d138]", "[d238]", "[d1238]", "[d48]", "[d148]", "[d248]", "[d1248]", "[d348]", "[d1348]", "[d2348]", "[d12348]", "[d58]", "[d158]", "[d258]", "[d1258]", "[d358]", "[d1358]", "[d2358]", "[d12358]", "[d458]", "[d1458]", "[d2458]", "[d12458]", "[d3458]", "[d13458]", "[d23458]", "[d123458]", "[d68]", "[d168]", "[d268]", "[d1268]", "[d368]", "[d1368]", "[d2368]", "[d12368]", "[d468]", "[d1468]", "[d2468]", "[d12468]", "[d3468]", "[d13468]", "[d23468]", "[d123468]", "[d568]", "[d1568]", "[d2568]", "[d12568]", "[d3568]", "[d13568]", "[d23568]", "[d123568]", "[d4568]", "[d14568]", "[d24568]", "[d124568]", "[d34568]", "[d134568]", "[d234568]", "[d1234568]", "[d78]", "[d178]", "[d278]", "[d1278]", "[d378]", "[d1378]", "[d2378]", "[d12378]", "[d478]", "[d1478]", "[d2478]", "[d12478]", "[d3478]", "[d13478]", "[d23478]", "[d123478]", "[d578]", "[d1578]", "[d2578]", "[d12578]", "[d3578]", "[d13578]", "[d23578]", "[d123578]", "[d4578]", "[d14578]", "[d24578]", "[d124578]", "[d34578]", "[d134578]", "[d234578]", "[d1234578]", "[d678]", "[d1678]", "[d2678]", "[d12678]", "[d3678]", "[d13678]", "[d23678]", "[d123678]", "[d4678]", "[d14678]", "[d24678]", "[d124678]", "[d34678]", "[d134678]", "[d234678]", "[d1234678]", "[d5678]", "[d15678]", "[d25678]", "[d125678]", "[d35678]", "[d135678]", "[d235678]", "[d1235678]", "[d45678]", "[d145678]", "[d245678]", "[d1245678]", "[d345678]", "[d1345678]", "[d2345678]", "[d12345678]"];
  }
});

// node_modules/unidecode/data/x2e.js
var require_x2e = __commonJS({
  "node_modules/unidecode/data/x2e.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x2f.js
var require_x2f = __commonJS({
  "node_modules/unidecode/data/x2f.js"(exports2, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x30.js
var require_x30 = __commonJS({
  "node_modules/unidecode/data/x30.js"(exports2, module2) {
    module2.exports = [" ", ", ", ". ", '"', "[JIS]", '"', "/", "0", "<", "> ", "<<", ">> ", "[", "] ", "{", "} ", "[(", ")] ", "@", "X ", "[", "] ", "[[", "]] ", "((", ")) ", "[[", "]] ", "~ ", "``", "''", ",,", "@", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "~", "+", "+", "+", "+", "", "@", " // ", "+10+", "+20+", "+30+", "[?]", "[?]", "[?]", "", "", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "[?]", "[?]", "[?]", "[?]", "", "", "", "", '"', '"', "[?]", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "ka", "ke", "va", "vi", "ve", "vo", "", "", '"', '"'];
  }
});

// node_modules/unidecode/data/x31.js
var require_x31 = __commonJS({
  "node_modules/unidecode/data/x31.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "B", "P", "M", "F", "D", "T", "N", "L", "G", "K", "H", "J", "Q", "X", "ZH", "CH", "SH", "R", "Z", "C", "S", "A", "O", "E", "EH", "AI", "EI", "AU", "OU", "AN", "EN", "ANG", "ENG", "ER", "I", "U", "IU", "V", "NG", "GN", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "", "nn", "nd", "ns", "nZ", "lgs", "ld", "lbs", "lZ", "lQ", "mb", "ms", "mZ", "mN", "bg", "", "bsg", "bst", "bj", "bt", "bN", "bbN", "sg", "sn", "sd", "sb", "sj", "Z", "", "N", "Ns", "NZ", "pN", "hh", "Q", "yo-ya", "yo-yae", "yo-i", "yu-yeo", "yu-ye", "yu-i", "U", "U-i", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BU", "ZI", "JI", "GU", "EE", "ENN", "OO", "ONN", "IR", "ANN", "INN", "UNN", "IM", "NGG", "AINN", "AUNN", "AM", "OM", "ONG", "INNN", "P", "T", "K", "H", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x32.js
var require_x32 = __commonJS({
  "node_modules/unidecode/data/x32.js"(exports2, module2) {
    module2.exports = ["(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "(ju)", "[?]", "[?]", "[?]", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Dai) ", "(Hu) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ji) ", "(Xiu) ", "<<", ">>", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "[?]", "[?]", "[?]", "KIS ", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Mi) ", "(Nan) ", "(Nu) ", "(Shi) ", "(You) ", "(Yin) ", "(Zhu) ", "(Xiang) ", "(Xiu) ", "(Xie) ", "(Zheng) ", "(Shang) ", "(Zhong) ", "(Xia) ", "(Zuo) ", "(You) ", "(Yi) ", "(Zong) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ye) ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "1M", "2M", "3M", "4M", "5M", "6M", "7M", "8M", "9M", "10M", "11M", "12M", "[?]", "[?]", "[?]", "[?]", "a", "i", "u", "u", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wi", "we", "wo"];
  }
});

// node_modules/unidecode/data/x33.js
var require_x33 = __commonJS({
  "node_modules/unidecode/data/x33.js"(exports2, module2) {
    module2.exports = ["apartment", "alpha", "ampere", "are", "inning", "inch", "won", "escudo", "acre", "ounce", "ohm", "kai-ri", "carat", "calorie", "gallon", "gamma", "giga", "guinea", "curie", "guilder", "kilo", "kilogram", "kilometer", "kilowatt", "gram", "gram ton", "cruzeiro", "krone", "case", "koruna", "co-op", "cycle", "centime", "shilling", "centi", "cent", "dozen", "desi", "dollar", "ton", "nano", "knot", "heights", "percent", "parts", "barrel", "piaster", "picul", "pico", "building", "farad", "feet", "bushel", "franc", "hectare", "peso", "pfennig", "hertz", "pence", "page", "beta", "point", "volt", "hon", "pound", "hall", "horn", "micro", "mile", "mach", "mark", "mansion", "micron", "milli", "millibar", "mega", "megaton", "meter", "yard", "yard", "yuan", "liter", "lira", "rupee", "ruble", "rem", "roentgen", "watt", "0h", "1h", "2h", "3h", "4h", "5h", "6h", "7h", "8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h", "16h", "17h", "18h", "19h", "20h", "21h", "22h", "23h", "24h", "HPA", "da", "AU", "bar", "oV", "pc", "[?]", "[?]", "[?]", "[?]", "Heisei", "Syouwa", "Taisyou", "Meiji", "Inc.", "pA", "nA", "microamp", "mA", "kA", "kB", "MB", "GB", "cal", "kcal", "pF", "nF", "microFarad", "microgram", "mg", "kg", "Hz", "kHz", "MHz", "GHz", "THz", "microliter", "ml", "dl", "kl", "fm", "nm", "micrometer", "mm", "cm", "km", "mm^2", "cm^2", "m^2", "km^2", "mm^4", "cm^3", "m^3", "km^3", "m/s", "m/s^2", "Pa", "kPa", "MPa", "GPa", "rad", "rad/s", "rad/s^2", "ps", "ns", "microsecond", "ms", "pV", "nV", "microvolt", "mV", "kV", "MV", "pW", "nW", "microwatt", "mW", "kW", "MW", "kOhm", "MOhm", "a.m.", "Bq", "cc", "cd", "C/kg", "Co.", "dB", "Gy", "ha", "HP", "in", "K.K.", "KM", "kt", "lm", "ln", "log", "lx", "mb", "mil", "mol", "pH", "p.m.", "PPM", "PR", "sr", "Sv", "Wb", "[?]", "[?]", "1d", "2d", "3d", "4d", "5d", "6d", "7d", "8d", "9d", "10d", "11d", "12d", "13d", "14d", "15d", "16d", "17d", "18d", "19d", "20d", "21d", "22d", "23d", "24d", "25d", "26d", "27d", "28d", "29d", "30d", "31d"];
  }
});

// node_modules/unidecode/data/x4d.js
var require_x4d = __commonJS({
  "node_modules/unidecode/data/x4d.js"(exports2, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x4e.js
var require_x4e = __commonJS({
  "node_modules/unidecode/data/x4e.js"(exports2, module2) {
    module2.exports = ["Yi ", "Ding ", "Kao ", "Qi ", "Shang ", "Xia ", "[?] ", "Mo ", "Zhang ", "San ", "Shang ", "Xia ", "Ji ", "Bu ", "Yu ", "Mian ", "Gai ", "Chou ", "Chou ", "Zhuan ", "Qie ", "Pi ", "Shi ", "Shi ", "Qiu ", "Bing ", "Ye ", "Cong ", "Dong ", "Si ", "Cheng ", "Diu ", "Qiu ", "Liang ", "Diu ", "You ", "Liang ", "Yan ", "Bing ", "Sang ", "Gun ", "Jiu ", "Ge ", "Ya ", "Qiang ", "Zhong ", "Ji ", "Jie ", "Feng ", "Guan ", "Chuan ", "Chan ", "Lin ", "Zhuo ", "Zhu ", "Ha ", "Wan ", "Dan ", "Wei ", "Zhu ", "Jing ", "Li ", "Ju ", "Pie ", "Fu ", "Yi ", "Yi ", "Nai ", "Shime ", "Jiu ", "Jiu ", "Zhe ", "Yao ", "Yi ", "[?] ", "Zhi ", "Wu ", "Zha ", "Hu ", "Fa ", "Le ", "Zhong ", "Ping ", "Pang ", "Qiao ", "Hu ", "Guai ", "Cheng ", "Cheng ", "Yi ", "Yin ", "[?] ", "Mie ", "Jiu ", "Qi ", "Ye ", "Xi ", "Xiang ", "Gai ", "Diu ", "Hal ", "[?] ", "Shu ", "Twul ", "Shi ", "Ji ", "Nang ", "Jia ", "Kel ", "Shi ", "[?] ", "Ol ", "Mai ", "Luan ", "Cal ", "Ru ", "Xue ", "Yan ", "Fu ", "Sha ", "Na ", "Gan ", "Sol ", "El ", "Cwul ", "[?] ", "Gan ", "Chi ", "Gui ", "Gan ", "Luan ", "Lin ", "Yi ", "Jue ", "Liao ", "Ma ", "Yu ", "Zheng ", "Shi ", "Shi ", "Er ", "Chu ", "Yu ", "Yu ", "Yu ", "Yun ", "Hu ", "Qi ", "Wu ", "Jing ", "Si ", "Sui ", "Gen ", "Gen ", "Ya ", "Xie ", "Ya ", "Qi ", "Ya ", "Ji ", "Tou ", "Wang ", "Kang ", "Ta ", "Jiao ", "Hai ", "Yi ", "Chan ", "Heng ", "Mu ", "[?] ", "Xiang ", "Jing ", "Ting ", "Liang ", "Xiang ", "Jing ", "Ye ", "Qin ", "Bo ", "You ", "Xie ", "Dan ", "Lian ", "Duo ", "Wei ", "Ren ", "Ren ", "Ji ", "La ", "Wang ", "Yi ", "Shi ", "Ren ", "Le ", "Ding ", "Ze ", "Jin ", "Pu ", "Chou ", "Ba ", "Zhang ", "Jin ", "Jie ", "Bing ", "Reng ", "Cong ", "Fo ", "San ", "Lun ", "Sya ", "Cang ", "Zi ", "Shi ", "Ta ", "Zhang ", "Fu ", "Xian ", "Xian ", "Tuo ", "Hong ", "Tong ", "Ren ", "Qian ", "Gan ", "Yi ", "Di ", "Dai ", "Ling ", "Yi ", "Chao ", "Chang ", "Sa ", "[?] ", "Yi ", "Mu ", "Men ", "Ren ", "Jia ", "Chao ", "Yang ", "Qian ", "Zhong ", "Pi ", "Wan ", "Wu ", "Jian ", "Jie ", "Yao ", "Feng ", "Cang ", "Ren ", "Wang ", "Fen ", "Di ", "Fang "];
  }
});

// node_modules/unidecode/data/x4f.js
var require_x4f = __commonJS({
  "node_modules/unidecode/data/x4f.js"(exports2, module2) {
    module2.exports = ["Zhong ", "Qi ", "Pei ", "Yu ", "Diao ", "Dun ", "Wen ", "Yi ", "Xin ", "Kang ", "Yi ", "Ji ", "Ai ", "Wu ", "Ji ", "Fu ", "Fa ", "Xiu ", "Jin ", "Bei ", "Dan ", "Fu ", "Tang ", "Zhong ", "You ", "Huo ", "Hui ", "Yu ", "Cui ", "Chuan ", "San ", "Wei ", "Chuan ", "Che ", "Ya ", "Xian ", "Shang ", "Chang ", "Lun ", "Cang ", "Xun ", "Xin ", "Wei ", "Zhu ", "[?] ", "Xuan ", "Nu ", "Bo ", "Gu ", "Ni ", "Ni ", "Xie ", "Ban ", "Xu ", "Ling ", "Zhou ", "Shen ", "Qu ", "Si ", "Beng ", "Si ", "Jia ", "Pi ", "Yi ", "Si ", "Ai ", "Zheng ", "Dian ", "Han ", "Mai ", "Dan ", "Zhu ", "Bu ", "Qu ", "Bi ", "Shao ", "Ci ", "Wei ", "Di ", "Zhu ", "Zuo ", "You ", "Yang ", "Ti ", "Zhan ", "He ", "Bi ", "Tuo ", "She ", "Yu ", "Yi ", "Fo ", "Zuo ", "Kou ", "Ning ", "Tong ", "Ni ", "Xuan ", "Qu ", "Yong ", "Wa ", "Qian ", "[?] ", "Ka ", "[?] ", "Pei ", "Huai ", "He ", "Lao ", "Xiang ", "Ge ", "Yang ", "Bai ", "Fa ", "Ming ", "Jia ", "Er ", "Bing ", "Ji ", "Hen ", "Huo ", "Gui ", "Quan ", "Tiao ", "Jiao ", "Ci ", "Yi ", "Shi ", "Xing ", "Shen ", "Tuo ", "Kan ", "Zhi ", "Gai ", "Lai ", "Yi ", "Chi ", "Kua ", "Guang ", "Li ", "Yin ", "Shi ", "Mi ", "Zhu ", "Xu ", "You ", "An ", "Lu ", "Mou ", "Er ", "Lun ", "Tong ", "Cha ", "Chi ", "Xun ", "Gong ", "Zhou ", "Yi ", "Ru ", "Jian ", "Xia ", "Jia ", "Zai ", "Lu ", "Ko ", "Jiao ", "Zhen ", "Ce ", "Qiao ", "Kuai ", "Chai ", "Ning ", "Nong ", "Jin ", "Wu ", "Hou ", "Jiong ", "Cheng ", "Zhen ", "Zuo ", "Chou ", "Qin ", "Lu ", "Ju ", "Shu ", "Ting ", "Shen ", "Tuo ", "Bo ", "Nan ", "Hao ", "Bian ", "Tui ", "Yu ", "Xi ", "Cu ", "E ", "Qiu ", "Xu ", "Kuang ", "Ku ", "Wu ", "Jun ", "Yi ", "Fu ", "Lang ", "Zu ", "Qiao ", "Li ", "Yong ", "Hun ", "Jing ", "Xian ", "San ", "Pai ", "Su ", "Fu ", "Xi ", "Li ", "Fu ", "Ping ", "Bao ", "Yu ", "Si ", "Xia ", "Xin ", "Xiu ", "Yu ", "Ti ", "Che ", "Chou ", "[?] ", "Yan ", "Lia ", "Li ", "Lai ", "[?] ", "Jian ", "Xiu ", "Fu ", "He ", "Ju ", "Xiao ", "Pai ", "Jian ", "Biao ", "Chu ", "Fei ", "Feng ", "Ya ", "An ", "Bei ", "Yu ", "Xin ", "Bi ", "Jian "];
  }
});

// node_modules/unidecode/data/x50.js
var require_x50 = __commonJS({
  "node_modules/unidecode/data/x50.js"(exports2, module2) {
    module2.exports = ["Chang ", "Chi ", "Bing ", "Zan ", "Yao ", "Cui ", "Lia ", "Wan ", "Lai ", "Cang ", "Zong ", "Ge ", "Guan ", "Bei ", "Tian ", "Shu ", "Shu ", "Men ", "Dao ", "Tan ", "Jue ", "Chui ", "Xing ", "Peng ", "Tang ", "Hou ", "Yi ", "Qi ", "Ti ", "Gan ", "Jing ", "Jie ", "Sui ", "Chang ", "Jie ", "Fang ", "Zhi ", "Kong ", "Juan ", "Zong ", "Ju ", "Qian ", "Ni ", "Lun ", "Zhuo ", "Wei ", "Luo ", "Song ", "Leng ", "Hun ", "Dong ", "Zi ", "Ben ", "Wu ", "Ju ", "Nai ", "Cai ", "Jian ", "Zhai ", "Ye ", "Zhi ", "Sha ", "Qing ", "[?] ", "Ying ", "Cheng ", "Jian ", "Yan ", "Nuan ", "Zhong ", "Chun ", "Jia ", "Jie ", "Wei ", "Yu ", "Bing ", "Ruo ", "Ti ", "Wei ", "Pian ", "Yan ", "Feng ", "Tang ", "Wo ", "E ", "Xie ", "Che ", "Sheng ", "Kan ", "Di ", "Zuo ", "Cha ", "Ting ", "Bei ", "Ye ", "Huang ", "Yao ", "Zhan ", "Chou ", "Yan ", "You ", "Jian ", "Xu ", "Zha ", "Ci ", "Fu ", "Bi ", "Zhi ", "Zong ", "Mian ", "Ji ", "Yi ", "Xie ", "Xun ", "Si ", "Duan ", "Ce ", "Zhen ", "Ou ", "Tou ", "Tou ", "Bei ", "Za ", "Lu ", "Jie ", "Wei ", "Fen ", "Chang ", "Gui ", "Sou ", "Zhi ", "Su ", "Xia ", "Fu ", "Yuan ", "Rong ", "Li ", "Ru ", "Yun ", "Gou ", "Ma ", "Bang ", "Dian ", "Tang ", "Hao ", "Jie ", "Xi ", "Shan ", "Qian ", "Jue ", "Cang ", "Chu ", "San ", "Bei ", "Xiao ", "Yong ", "Yao ", "Tan ", "Suo ", "Yang ", "Fa ", "Bing ", "Jia ", "Dai ", "Zai ", "Tang ", "[?] ", "Bin ", "Chu ", "Nuo ", "Can ", "Lei ", "Cui ", "Yong ", "Zao ", "Zong ", "Peng ", "Song ", "Ao ", "Chuan ", "Yu ", "Zhai ", "Cou ", "Shang ", "Qiang ", "Jing ", "Chi ", "Sha ", "Han ", "Zhang ", "Qing ", "Yan ", "Di ", "Xi ", "Lu ", "Bei ", "Piao ", "Jin ", "Lian ", "Lu ", "Man ", "Qian ", "Xian ", "Tan ", "Ying ", "Dong ", "Zhuan ", "Xiang ", "Shan ", "Qiao ", "Jiong ", "Tui ", "Zun ", "Pu ", "Xi ", "Lao ", "Chang ", "Guang ", "Liao ", "Qi ", "Deng ", "Chan ", "Wei ", "Ji ", "Fan ", "Hui ", "Chuan ", "Jian ", "Dan ", "Jiao ", "Jiu ", "Seng ", "Fen ", "Xian ", "Jue ", "E ", "Jiao ", "Jian ", "Tong ", "Lin ", "Bo ", "Gu ", "[?] ", "Su ", "Xian ", "Jiang ", "Min ", "Ye ", "Jin ", "Jia ", "Qiao ", "Pi ", "Feng ", "Zhou ", "Ai ", "Sai "];
  }
});

// node_modules/unidecode/data/x51.js
var require_x51 = __commonJS({
  "node_modules/unidecode/data/x51.js"(exports2, module2) {
    module2.exports = ["Yi ", "Jun ", "Nong ", "Chan ", "Yi ", "Dang ", "Jing ", "Xuan ", "Kuai ", "Jian ", "Chu ", "Dan ", "Jiao ", "Sha ", "Zai ", "[?] ", "Bin ", "An ", "Ru ", "Tai ", "Chou ", "Chai ", "Lan ", "Ni ", "Jin ", "Qian ", "Meng ", "Wu ", "Ning ", "Qiong ", "Ni ", "Chang ", "Lie ", "Lei ", "Lu ", "Kuang ", "Bao ", "Du ", "Biao ", "Zan ", "Zhi ", "Si ", "You ", "Hao ", "Chen ", "Chen ", "Li ", "Teng ", "Wei ", "Long ", "Chu ", "Chan ", "Rang ", "Shu ", "Hui ", "Li ", "Luo ", "Zan ", "Nuo ", "Tang ", "Yan ", "Lei ", "Nang ", "Er ", "Wu ", "Yun ", "Zan ", "Yuan ", "Xiong ", "Chong ", "Zhao ", "Xiong ", "Xian ", "Guang ", "Dui ", "Ke ", "Dui ", "Mian ", "Tu ", "Chang ", "Er ", "Dui ", "Er ", "Xin ", "Tu ", "Si ", "Yan ", "Yan ", "Shi ", "Shi ", "Dang ", "Qian ", "Dou ", "Fen ", "Mao ", "Shen ", "Dou ", "Bai ", "Jing ", "Li ", "Huang ", "Ru ", "Wang ", "Nei ", "Quan ", "Liang ", "Yu ", "Ba ", "Gong ", "Liu ", "Xi ", "[?] ", "Lan ", "Gong ", "Tian ", "Guan ", "Xing ", "Bing ", "Qi ", "Ju ", "Dian ", "Zi ", "Ppwun ", "Yang ", "Jian ", "Shou ", "Ji ", "Yi ", "Ji ", "Chan ", "Jiong ", "Mao ", "Ran ", "Nei ", "Yuan ", "Mao ", "Gang ", "Ran ", "Ce ", "Jiong ", "Ce ", "Zai ", "Gua ", "Jiong ", "Mao ", "Zhou ", "Mou ", "Gou ", "Xu ", "Mian ", "Mi ", "Rong ", "Yin ", "Xie ", "Kan ", "Jun ", "Nong ", "Yi ", "Mi ", "Shi ", "Guan ", "Meng ", "Zhong ", "Ju ", "Yuan ", "Ming ", "Kou ", "Lam ", "Fu ", "Xie ", "Mi ", "Bing ", "Dong ", "Tai ", "Gang ", "Feng ", "Bing ", "Hu ", "Chong ", "Jue ", "Hu ", "Kuang ", "Ye ", "Leng ", "Pan ", "Fu ", "Min ", "Dong ", "Xian ", "Lie ", "Xia ", "Jian ", "Jing ", "Shu ", "Mei ", "Tu ", "Qi ", "Gu ", "Zhun ", "Song ", "Jing ", "Liang ", "Qing ", "Diao ", "Ling ", "Dong ", "Gan ", "Jian ", "Yin ", "Cou ", "Yi ", "Li ", "Cang ", "Ming ", "Zhuen ", "Cui ", "Si ", "Duo ", "Jin ", "Lin ", "Lin ", "Ning ", "Xi ", "Du ", "Ji ", "Fan ", "Fan ", "Fan ", "Feng ", "Ju ", "Chu ", "Tako ", "Feng ", "Mok ", "Ci ", "Fu ", "Feng ", "Ping ", "Feng ", "Kai ", "Huang ", "Kai ", "Gan ", "Deng ", "Ping ", "Qu ", "Xiong ", "Kuai ", "Tu ", "Ao ", "Chu ", "Ji ", "Dang ", "Han ", "Han ", "Zao "];
  }
});

// node_modules/unidecode/data/x52.js
var require_x52 = __commonJS({
  "node_modules/unidecode/data/x52.js"(exports2, module2) {
    module2.exports = ["Dao ", "Diao ", "Dao ", "Ren ", "Ren ", "Chuang ", "Fen ", "Qie ", "Yi ", "Ji ", "Kan ", "Qian ", "Cun ", "Chu ", "Wen ", "Ji ", "Dan ", "Xing ", "Hua ", "Wan ", "Jue ", "Li ", "Yue ", "Lie ", "Liu ", "Ze ", "Gang ", "Chuang ", "Fu ", "Chu ", "Qu ", "Ju ", "Shan ", "Min ", "Ling ", "Zhong ", "Pan ", "Bie ", "Jie ", "Jie ", "Bao ", "Li ", "Shan ", "Bie ", "Chan ", "Jing ", "Gua ", "Gen ", "Dao ", "Chuang ", "Kui ", "Ku ", "Duo ", "Er ", "Zhi ", "Shua ", "Quan ", "Cha ", "Ci ", "Ke ", "Jie ", "Gui ", "Ci ", "Gui ", "Kai ", "Duo ", "Ji ", "Ti ", "Jing ", "Lou ", "Gen ", "Ze ", "Yuan ", "Cuo ", "Xue ", "Ke ", "La ", "Qian ", "Cha ", "Chuang ", "Gua ", "Jian ", "Cuo ", "Li ", "Ti ", "Fei ", "Pou ", "Chan ", "Qi ", "Chuang ", "Zi ", "Gang ", "Wan ", "Bo ", "Ji ", "Duo ", "Qing ", "Yan ", "Zhuo ", "Jian ", "Ji ", "Bo ", "Yan ", "Ju ", "Huo ", "Sheng ", "Jian ", "Duo ", "Duan ", "Wu ", "Gua ", "Fu ", "Sheng ", "Jian ", "Ge ", "Zha ", "Kai ", "Chuang ", "Juan ", "Chan ", "Tuan ", "Lu ", "Li ", "Fou ", "Shan ", "Piao ", "Kou ", "Jiao ", "Gua ", "Qiao ", "Jue ", "Hua ", "Zha ", "Zhuo ", "Lian ", "Ju ", "Pi ", "Liu ", "Gui ", "Jiao ", "Gui ", "Jian ", "Jian ", "Tang ", "Huo ", "Ji ", "Jian ", "Yi ", "Jian ", "Zhi ", "Chan ", "Cuan ", "Mo ", "Li ", "Zhu ", "Li ", "Ya ", "Quan ", "Ban ", "Gong ", "Jia ", "Wu ", "Mai ", "Lie ", "Jin ", "Keng ", "Xie ", "Zhi ", "Dong ", "Zhu ", "Nu ", "Jie ", "Qu ", "Shao ", "Yi ", "Zhu ", "Miao ", "Li ", "Jing ", "Lao ", "Lao ", "Juan ", "Kou ", "Yang ", "Wa ", "Xiao ", "Mou ", "Kuang ", "Jie ", "Lie ", "He ", "Shi ", "Ke ", "Jing ", "Hao ", "Bo ", "Min ", "Chi ", "Lang ", "Yong ", "Yong ", "Mian ", "Ke ", "Xun ", "Juan ", "Qing ", "Lu ", "Pou ", "Meng ", "Lai ", "Le ", "Kai ", "Mian ", "Dong ", "Xu ", "Xu ", "Kan ", "Wu ", "Yi ", "Xun ", "Weng ", "Sheng ", "Lao ", "Mu ", "Lu ", "Piao ", "Shi ", "Ji ", "Qin ", "Qiang ", "Jiao ", "Quan ", "Yang ", "Yi ", "Jue ", "Fan ", "Juan ", "Tong ", "Ju ", "Dan ", "Xie ", "Mai ", "Xun ", "Xun ", "Lu ", "Li ", "Che ", "Rang ", "Quan ", "Bao ", "Shao ", "Yun ", "Jiu ", "Bao ", "Gou ", "Wu "];
  }
});

// node_modules/unidecode/data/x53.js
var require_x53 = __commonJS({
  "node_modules/unidecode/data/x53.js"(exports2, module2) {
    module2.exports = ["Yun ", "Mwun ", "Nay ", "Gai ", "Gai ", "Bao ", "Cong ", "[?] ", "Xiong ", "Peng ", "Ju ", "Tao ", "Ge ", "Pu ", "An ", "Pao ", "Fu ", "Gong ", "Da ", "Jiu ", "Qiong ", "Bi ", "Hua ", "Bei ", "Nao ", "Chi ", "Fang ", "Jiu ", "Yi ", "Za ", "Jiang ", "Kang ", "Jiang ", "Kuang ", "Hu ", "Xia ", "Qu ", "Bian ", "Gui ", "Qie ", "Zang ", "Kuang ", "Fei ", "Hu ", "Tou ", "Gui ", "Gui ", "Hui ", "Dan ", "Gui ", "Lian ", "Lian ", "Suan ", "Du ", "Jiu ", "Qu ", "Xi ", "Pi ", "Qu ", "Yi ", "Qia ", "Yan ", "Bian ", "Ni ", "Qu ", "Shi ", "Xin ", "Qian ", "Nian ", "Sa ", "Zu ", "Sheng ", "Wu ", "Hui ", "Ban ", "Shi ", "Xi ", "Wan ", "Hua ", "Xie ", "Wan ", "Bei ", "Zu ", "Zhuo ", "Xie ", "Dan ", "Mai ", "Nan ", "Dan ", "Ji ", "Bo ", "Shuai ", "Bu ", "Kuang ", "Bian ", "Bu ", "Zhan ", "Qia ", "Lu ", "You ", "Lu ", "Xi ", "Gua ", "Wo ", "Xie ", "Jie ", "Jie ", "Wei ", "Ang ", "Qiong ", "Zhi ", "Mao ", "Yin ", "Wei ", "Shao ", "Ji ", "Que ", "Luan ", "Shi ", "Juan ", "Xie ", "Xu ", "Jin ", "Que ", "Wu ", "Ji ", "E ", "Qing ", "Xi ", "[?] ", "Han ", "Zhan ", "E ", "Ting ", "Li ", "Zhe ", "Han ", "Li ", "Ya ", "Ya ", "Yan ", "She ", "Zhi ", "Zha ", "Pang ", "[?] ", "He ", "Ya ", "Zhi ", "Ce ", "Pang ", "Ti ", "Li ", "She ", "Hou ", "Ting ", "Zui ", "Cuo ", "Fei ", "Yuan ", "Ce ", "Yuan ", "Xiang ", "Yan ", "Li ", "Jue ", "Sha ", "Dian ", "Chu ", "Jiu ", "Qin ", "Ao ", "Gui ", "Yan ", "Si ", "Li ", "Chang ", "Lan ", "Li ", "Yan ", "Yan ", "Yuan ", "Si ", "Gong ", "Lin ", "Qiu ", "Qu ", "Qu ", "Uk ", "Lei ", "Du ", "Xian ", "Zhuan ", "San ", "Can ", "Can ", "Can ", "Can ", "Ai ", "Dai ", "You ", "Cha ", "Ji ", "You ", "Shuang ", "Fan ", "Shou ", "Guai ", "Ba ", "Fa ", "Ruo ", "Shi ", "Shu ", "Zhuo ", "Qu ", "Shou ", "Bian ", "Xu ", "Jia ", "Pan ", "Sou ", "Gao ", "Wei ", "Sou ", "Die ", "Rui ", "Cong ", "Kou ", "Gu ", "Ju ", "Ling ", "Gua ", "Tao ", "Kou ", "Zhi ", "Jiao ", "Zhao ", "Ba ", "Ding ", "Ke ", "Tai ", "Chi ", "Shi ", "You ", "Qiu ", "Po ", "Xie ", "Hao ", "Si ", "Tan ", "Chi ", "Le ", "Diao ", "Ji ", "[?] ", "Hong "];
  }
});

// node_modules/unidecode/data/x54.js
var require_x54 = __commonJS({
  "node_modules/unidecode/data/x54.js"(exports2, module2) {
    module2.exports = ["Mie ", "Xu ", "Mang ", "Chi ", "Ge ", "Xuan ", "Yao ", "Zi ", "He ", "Ji ", "Diao ", "Cun ", "Tong ", "Ming ", "Hou ", "Li ", "Tu ", "Xiang ", "Zha ", "Xia ", "Ye ", "Lu ", "A ", "Ma ", "Ou ", "Xue ", "Yi ", "Jun ", "Chou ", "Lin ", "Tun ", "Yin ", "Fei ", "Bi ", "Qin ", "Qin ", "Jie ", "Bu ", "Fou ", "Ba ", "Dun ", "Fen ", "E ", "Han ", "Ting ", "Hang ", "Shun ", "Qi ", "Hong ", "Zhi ", "Shen ", "Wu ", "Wu ", "Chao ", "Ne ", "Xue ", "Xi ", "Chui ", "Dou ", "Wen ", "Hou ", "Ou ", "Wu ", "Gao ", "Ya ", "Jun ", "Lu ", "E ", "Ge ", "Mei ", "Ai ", "Qi ", "Cheng ", "Wu ", "Gao ", "Fu ", "Jiao ", "Hong ", "Chi ", "Sheng ", "Ne ", "Tun ", "Fu ", "Yi ", "Dai ", "Ou ", "Li ", "Bai ", "Yuan ", "Kuai ", "[?] ", "Qiang ", "Wu ", "E ", "Shi ", "Quan ", "Pen ", "Wen ", "Ni ", "M ", "Ling ", "Ran ", "You ", "Di ", "Zhou ", "Shi ", "Zhou ", "Tie ", "Xi ", "Yi ", "Qi ", "Ping ", "Zi ", "Gu ", "Zi ", "Wei ", "Xu ", "He ", "Nao ", "Xia ", "Pei ", "Yi ", "Xiao ", "Shen ", "Hu ", "Ming ", "Da ", "Qu ", "Ju ", "Gem ", "Za ", "Tuo ", "Duo ", "Pou ", "Pao ", "Bi ", "Fu ", "Yang ", "He ", "Zha ", "He ", "Hai ", "Jiu ", "Yong ", "Fu ", "Que ", "Zhou ", "Wa ", "Ka ", "Gu ", "Ka ", "Zuo ", "Bu ", "Long ", "Dong ", "Ning ", "Tha ", "Si ", "Xian ", "Huo ", "Qi ", "Er ", "E ", "Guang ", "Zha ", "Xi ", "Yi ", "Lie ", "Zi ", "Mie ", "Mi ", "Zhi ", "Yao ", "Ji ", "Zhou ", "Ge ", "Shuai ", "Zan ", "Xiao ", "Ke ", "Hui ", "Kua ", "Huai ", "Tao ", "Xian ", "E ", "Xuan ", "Xiu ", "Wai ", "Yan ", "Lao ", "Yi ", "Ai ", "Pin ", "Shen ", "Tong ", "Hong ", "Xiong ", "Chi ", "Wa ", "Ha ", "Zai ", "Yu ", "Di ", "Pai ", "Xiang ", "Ai ", "Hen ", "Kuang ", "Ya ", "Da ", "Xiao ", "Bi ", "Yue ", "[?] ", "Hua ", "Sasou ", "Kuai ", "Duo ", "[?] ", "Ji ", "Nong ", "Mou ", "Yo ", "Hao ", "Yuan ", "Long ", "Pou ", "Mang ", "Ge ", "E ", "Chi ", "Shao ", "Li ", "Na ", "Zu ", "He ", "Ku ", "Xiao ", "Xian ", "Lao ", "Bo ", "Zhe ", "Zha ", "Liang ", "Ba ", "Mie ", "Le ", "Sui ", "Fou ", "Bu ", "Han ", "Heng ", "Geng ", "Shuo ", "Ge "];
  }
});

// node_modules/unidecode/data/x55.js
var require_x55 = __commonJS({
  "node_modules/unidecode/data/x55.js"(exports2, module2) {
    module2.exports = ["You ", "Yan ", "Gu ", "Gu ", "Bai ", "Han ", "Suo ", "Chun ", "Yi ", "Ai ", "Jia ", "Tu ", "Xian ", "Huan ", "Li ", "Xi ", "Tang ", "Zuo ", "Qiu ", "Che ", "Wu ", "Zao ", "Ya ", "Dou ", "Qi ", "Di ", "Qin ", "Ma ", "Mal ", "Hong ", "Dou ", "Kes ", "Lao ", "Liang ", "Suo ", "Zao ", "Huan ", "Lang ", "Sha ", "Ji ", "Zuo ", "Wo ", "Feng ", "Yin ", "Hu ", "Qi ", "Shou ", "Wei ", "Shua ", "Chang ", "Er ", "Li ", "Qiang ", "An ", "Jie ", "Yo ", "Nian ", "Yu ", "Tian ", "Lai ", "Sha ", "Xi ", "Tuo ", "Hu ", "Ai ", "Zhou ", "Nou ", "Ken ", "Zhuo ", "Zhuo ", "Shang ", "Di ", "Heng ", "Lan ", "A ", "Xiao ", "Xiang ", "Tun ", "Wu ", "Wen ", "Cui ", "Sha ", "Hu ", "Qi ", "Qi ", "Tao ", "Dan ", "Dan ", "Ye ", "Zi ", "Bi ", "Cui ", "Chuo ", "He ", "Ya ", "Qi ", "Zhe ", "Pei ", "Liang ", "Xian ", "Pi ", "Sha ", "La ", "Ze ", "Qing ", "Gua ", "Pa ", "Zhe ", "Se ", "Zhuan ", "Nie ", "Guo ", "Luo ", "Yan ", "Di ", "Quan ", "Tan ", "Bo ", "Ding ", "Lang ", "Xiao ", "[?] ", "Tang ", "Chi ", "Ti ", "An ", "Jiu ", "Dan ", "Ke ", "Yong ", "Wei ", "Nan ", "Shan ", "Yu ", "Zhe ", "La ", "Jie ", "Hou ", "Han ", "Die ", "Zhou ", "Chai ", "Wai ", "Re ", "Yu ", "Yin ", "Zan ", "Yao ", "Wo ", "Mian ", "Hu ", "Yun ", "Chuan ", "Hui ", "Huan ", "Huan ", "Xi ", "He ", "Ji ", "Kui ", "Zhong ", "Wei ", "Sha ", "Xu ", "Huang ", "Du ", "Nie ", "Xuan ", "Liang ", "Yu ", "Sang ", "Chi ", "Qiao ", "Yan ", "Dan ", "Pen ", "Can ", "Li ", "Yo ", "Zha ", "Wei ", "Miao ", "Ying ", "Pen ", "Phos ", "Kui ", "Xi ", "Yu ", "Jie ", "Lou ", "Ku ", "Sao ", "Huo ", "Ti ", "Yao ", "He ", "A ", "Xiu ", "Qiang ", "Se ", "Yong ", "Su ", "Hong ", "Xie ", "Yi ", "Suo ", "Ma ", "Cha ", "Hai ", "Ke ", "Ta ", "Sang ", "Tian ", "Ru ", "Sou ", "Wa ", "Ji ", "Pang ", "Wu ", "Xian ", "Shi ", "Ge ", "Zi ", "Jie ", "Luo ", "Weng ", "Wa ", "Si ", "Chi ", "Hao ", "Suo ", "Jia ", "Hai ", "Suo ", "Qin ", "Nie ", "He ", "Cis ", "Sai ", "Ng ", "Ge ", "Na ", "Dia ", "Ai ", "[?] ", "Tong ", "Bi ", "Ao ", "Ao ", "Lian ", "Cui ", "Zhe ", "Mo ", "Sou ", "Sou ", "Tan "];
  }
});

// node_modules/unidecode/data/x56.js
var require_x56 = __commonJS({
  "node_modules/unidecode/data/x56.js"(exports2, module2) {
    module2.exports = ["Di ", "Qi ", "Jiao ", "Chong ", "Jiao ", "Kai ", "Tan ", "San ", "Cao ", "Jia ", "Ai ", "Xiao ", "Piao ", "Lou ", "Ga ", "Gu ", "Xiao ", "Hu ", "Hui ", "Guo ", "Ou ", "Xian ", "Ze ", "Chang ", "Xu ", "Po ", "De ", "Ma ", "Ma ", "Hu ", "Lei ", "Du ", "Ga ", "Tang ", "Ye ", "Beng ", "Ying ", "Saai ", "Jiao ", "Mi ", "Xiao ", "Hua ", "Mai ", "Ran ", "Zuo ", "Peng ", "Lao ", "Xiao ", "Ji ", "Zhu ", "Chao ", "Kui ", "Zui ", "Xiao ", "Si ", "Hao ", "Fu ", "Liao ", "Qiao ", "Xi ", "Xiu ", "Tan ", "Tan ", "Mo ", "Xun ", "E ", "Zun ", "Fan ", "Chi ", "Hui ", "Zan ", "Chuang ", "Cu ", "Dan ", "Yu ", "Tun ", "Cheng ", "Jiao ", "Ye ", "Xi ", "Qi ", "Hao ", "Lian ", "Xu ", "Deng ", "Hui ", "Yin ", "Pu ", "Jue ", "Qin ", "Xun ", "Nie ", "Lu ", "Si ", "Yan ", "Ying ", "Da ", "Dan ", "Yu ", "Zhou ", "Jin ", "Nong ", "Yue ", "Hui ", "Qi ", "E ", "Zao ", "Yi ", "Shi ", "Jiao ", "Yuan ", "Ai ", "Yong ", "Jue ", "Kuai ", "Yu ", "Pen ", "Dao ", "Ge ", "Xin ", "Dun ", "Dang ", "Sin ", "Sai ", "Pi ", "Pi ", "Yin ", "Zui ", "Ning ", "Di ", "Lan ", "Ta ", "Huo ", "Ru ", "Hao ", "Xia ", "Ya ", "Duo ", "Xi ", "Chou ", "Ji ", "Jin ", "Hao ", "Ti ", "Chang ", "[?] ", "[?] ", "Ca ", "Ti ", "Lu ", "Hui ", "Bo ", "You ", "Nie ", "Yin ", "Hu ", "Mo ", "Huang ", "Zhe ", "Li ", "Liu ", "Haai ", "Nang ", "Xiao ", "Mo ", "Yan ", "Li ", "Lu ", "Long ", "Fu ", "Dan ", "Chen ", "Pin ", "Pi ", "Xiang ", "Huo ", "Mo ", "Xi ", "Duo ", "Ku ", "Yan ", "Chan ", "Ying ", "Rang ", "Dian ", "La ", "Ta ", "Xiao ", "Jiao ", "Chuo ", "Huan ", "Huo ", "Zhuan ", "Nie ", "Xiao ", "Ca ", "Li ", "Chan ", "Chai ", "Li ", "Yi ", "Luo ", "Nang ", "Zan ", "Su ", "Xi ", "So ", "Jian ", "Za ", "Zhu ", "Lan ", "Nie ", "Nang ", "[?] ", "[?] ", "Wei ", "Hui ", "Yin ", "Qiu ", "Si ", "Nin ", "Jian ", "Hui ", "Xin ", "Yin ", "Nan ", "Tuan ", "Tuan ", "Dun ", "Kang ", "Yuan ", "Jiong ", "Pian ", "Yun ", "Cong ", "Hu ", "Hui ", "Yuan ", "You ", "Guo ", "Kun ", "Cong ", "Wei ", "Tu ", "Wei ", "Lun ", "Guo ", "Qun ", "Ri ", "Ling ", "Gu ", "Guo ", "Tai ", "Guo ", "Tu ", "You "];
  }
});

// node_modules/unidecode/data/x57.js
var require_x57 = __commonJS({
  "node_modules/unidecode/data/x57.js"(exports2, module2) {
    module2.exports = ["Guo ", "Yin ", "Hun ", "Pu ", "Yu ", "Han ", "Yuan ", "Lun ", "Quan ", "Yu ", "Qing ", "Guo ", "Chuan ", "Wei ", "Yuan ", "Quan ", "Ku ", "Fu ", "Yuan ", "Yuan ", "E ", "Tu ", "Tu ", "Tu ", "Tuan ", "Lue ", "Hui ", "Yi ", "Yuan ", "Luan ", "Luan ", "Tu ", "Ya ", "Tu ", "Ting ", "Sheng ", "Pu ", "Lu ", "Iri ", "Ya ", "Zai ", "Wei ", "Ge ", "Yu ", "Wu ", "Gui ", "Pi ", "Yi ", "Di ", "Qian ", "Qian ", "Zhen ", "Zhuo ", "Dang ", "Qia ", "Akutsu ", "Yama ", "Kuang ", "Chang ", "Qi ", "Nie ", "Mo ", "Ji ", "Jia ", "Zhi ", "Zhi ", "Ban ", "Xun ", "Tou ", "Qin ", "Fen ", "Jun ", "Keng ", "Tun ", "Fang ", "Fen ", "Ben ", "Tan ", "Kan ", "Pi ", "Zuo ", "Keng ", "Bi ", "Xing ", "Di ", "Jing ", "Ji ", "Kuai ", "Di ", "Jing ", "Jian ", "Tan ", "Li ", "Ba ", "Wu ", "Fen ", "Zhui ", "Po ", "Pan ", "Tang ", "Kun ", "Qu ", "Tan ", "Zhi ", "Tuo ", "Gan ", "Ping ", "Dian ", "Gua ", "Ni ", "Tai ", "Pi ", "Jiong ", "Yang ", "Fo ", "Ao ", "Liu ", "Qiu ", "Mu ", "Ke ", "Gou ", "Xue ", "Ba ", "Chi ", "Che ", "Ling ", "Zhu ", "Fu ", "Hu ", "Zhi ", "Chui ", "La ", "Long ", "Long ", "Lu ", "Ao ", "Tay ", "Pao ", "[?] ", "Xing ", "Dong ", "Ji ", "Ke ", "Lu ", "Ci ", "Chi ", "Lei ", "Gai ", "Yin ", "Hou ", "Dui ", "Zhao ", "Fu ", "Guang ", "Yao ", "Duo ", "Duo ", "Gui ", "Cha ", "Yang ", "Yin ", "Fa ", "Gou ", "Yuan ", "Die ", "Xie ", "Ken ", "Jiong ", "Shou ", "E ", "Ha ", "Dian ", "Hong ", "Wu ", "Kua ", "[?] ", "Tao ", "Dang ", "Kai ", "Gake ", "Nao ", "An ", "Xing ", "Xian ", "Huan ", "Bang ", "Pei ", "Ba ", "Yi ", "Yin ", "Han ", "Xu ", "Chui ", "Cen ", "Geng ", "Ai ", "Peng ", "Fang ", "Que ", "Yong ", "Xun ", "Jia ", "Di ", "Mai ", "Lang ", "Xuan ", "Cheng ", "Yan ", "Jin ", "Zhe ", "Lei ", "Lie ", "Bu ", "Cheng ", "Gomi ", "Bu ", "Shi ", "Xun ", "Guo ", "Jiong ", "Ye ", "Nian ", "Di ", "Yu ", "Bu ", "Ya ", "Juan ", "Sui ", "Pi ", "Cheng ", "Wan ", "Ju ", "Lun ", "Zheng ", "Kong ", "Chong ", "Dong ", "Dai ", "Tan ", "An ", "Cai ", "Shu ", "Beng ", "Kan ", "Zhi ", "Duo ", "Yi ", "Zhi ", "Yi ", "Pei ", "Ji ", "Zhun ", "Qi ", "Sao ", "Ju ", "Ni "];
  }
});

// node_modules/unidecode/data/x58.js
var require_x58 = __commonJS({
  "node_modules/unidecode/data/x58.js"(exports2, module2) {
    module2.exports = ["Ku ", "Ke ", "Tang ", "Kun ", "Ni ", "Jian ", "Dui ", "Jin ", "Gang ", "Yu ", "E ", "Peng ", "Gu ", "Tu ", "Leng ", "[?] ", "Ya ", "Qian ", "[?] ", "An ", "[?] ", "Duo ", "Nao ", "Tu ", "Cheng ", "Yin ", "Hun ", "Bi ", "Lian ", "Guo ", "Die ", "Zhuan ", "Hou ", "Bao ", "Bao ", "Yu ", "Di ", "Mao ", "Jie ", "Ruan ", "E ", "Geng ", "Kan ", "Zong ", "Yu ", "Huang ", "E ", "Yao ", "Yan ", "Bao ", "Ji ", "Mei ", "Chang ", "Du ", "Tuo ", "Yin ", "Feng ", "Zhong ", "Jie ", "Zhen ", "Feng ", "Gang ", "Chuan ", "Jian ", "Pyeng ", "Toride ", "Xiang ", "Huang ", "Leng ", "Duan ", "[?] ", "Xuan ", "Ji ", "Ji ", "Kuai ", "Ying ", "Ta ", "Cheng ", "Yong ", "Kai ", "Su ", "Su ", "Shi ", "Mi ", "Ta ", "Weng ", "Cheng ", "Tu ", "Tang ", "Que ", "Zhong ", "Li ", "Peng ", "Bang ", "Sai ", "Zang ", "Dui ", "Tian ", "Wu ", "Cheng ", "Xun ", "Ge ", "Zhen ", "Ai ", "Gong ", "Yan ", "Kan ", "Tian ", "Yuan ", "Wen ", "Xie ", "Liu ", "Ama ", "Lang ", "Chang ", "Peng ", "Beng ", "Chen ", "Cu ", "Lu ", "Ou ", "Qian ", "Mei ", "Mo ", "Zhuan ", "Shuang ", "Shu ", "Lou ", "Chi ", "Man ", "Biao ", "Jing ", "Qi ", "Shu ", "Di ", "Zhang ", "Kan ", "Yong ", "Dian ", "Chen ", "Zhi ", "Xi ", "Guo ", "Qiang ", "Jin ", "Di ", "Shang ", "Mu ", "Cui ", "Yan ", "Ta ", "Zeng ", "Qi ", "Qiang ", "Liang ", "[?] ", "Zhui ", "Qiao ", "Zeng ", "Xu ", "Shan ", "Shan ", "Ba ", "Pu ", "Kuai ", "Dong ", "Fan ", "Que ", "Mo ", "Dun ", "Dun ", "Dun ", "Di ", "Sheng ", "Duo ", "Duo ", "Tan ", "Deng ", "Wu ", "Fen ", "Huang ", "Tan ", "Da ", "Ye ", "Sho ", "Mama ", "Yu ", "Qiang ", "Ji ", "Qiao ", "Ken ", "Yi ", "Pi ", "Bi ", "Dian ", "Jiang ", "Ye ", "Yong ", "Bo ", "Tan ", "Lan ", "Ju ", "Huai ", "Dang ", "Rang ", "Qian ", "Xun ", "Lan ", "Xi ", "He ", "Ai ", "Ya ", "Dao ", "Hao ", "Ruan ", "Mama ", "Lei ", "Kuang ", "Lu ", "Yan ", "Tan ", "Wei ", "Huai ", "Long ", "Long ", "Rui ", "Li ", "Lin ", "Rang ", "Ten ", "Xun ", "Yan ", "Lei ", "Ba ", "[?] ", "Shi ", "Ren ", "[?] ", "Zhuang ", "Zhuang ", "Sheng ", "Yi ", "Mai ", "Ke ", "Zhu ", "Zhuang ", "Hu ", "Hu ", "Kun ", "Yi ", "Hu ", "Xu ", "Kun ", "Shou ", "Mang ", "Zun "];
  }
});

// node_modules/unidecode/data/x59.js
var require_x59 = __commonJS({
  "node_modules/unidecode/data/x59.js"(exports2, module2) {
    module2.exports = ["Shou ", "Yi ", "Zhi ", "Gu ", "Chu ", "Jiang ", "Feng ", "Bei ", "Cay ", "Bian ", "Sui ", "Qun ", "Ling ", "Fu ", "Zuo ", "Xia ", "Xiong ", "[?] ", "Nao ", "Xia ", "Kui ", "Xi ", "Wai ", "Yuan ", "Mao ", "Su ", "Duo ", "Duo ", "Ye ", "Qing ", "Uys ", "Gou ", "Gou ", "Qi ", "Meng ", "Meng ", "Yin ", "Huo ", "Chen ", "Da ", "Ze ", "Tian ", "Tai ", "Fu ", "Guai ", "Yao ", "Yang ", "Hang ", "Gao ", "Shi ", "Ben ", "Tai ", "Tou ", "Yan ", "Bi ", "Yi ", "Kua ", "Jia ", "Duo ", "Kwu ", "Kuang ", "Yun ", "Jia ", "Pa ", "En ", "Lian ", "Huan ", "Di ", "Yan ", "Pao ", "Quan ", "Qi ", "Nai ", "Feng ", "Xie ", "Fen ", "Dian ", "[?] ", "Kui ", "Zou ", "Huan ", "Qi ", "Kai ", "Zha ", "Ben ", "Yi ", "Jiang ", "Tao ", "Zang ", "Ben ", "Xi ", "Xiang ", "Fei ", "Diao ", "Xun ", "Keng ", "Dian ", "Ao ", "She ", "Weng ", "Pan ", "Ao ", "Wu ", "Ao ", "Jiang ", "Lian ", "Duo ", "Yun ", "Jiang ", "Shi ", "Fen ", "Huo ", "Bi ", "Lian ", "Duo ", "Nu ", "Nu ", "Ding ", "Nai ", "Qian ", "Jian ", "Ta ", "Jiu ", "Nan ", "Cha ", "Hao ", "Xian ", "Fan ", "Ji ", "Shuo ", "Ru ", "Fei ", "Wang ", "Hong ", "Zhuang ", "Fu ", "Ma ", "Dan ", "Ren ", "Fu ", "Jing ", "Yan ", "Xie ", "Wen ", "Zhong ", "Pa ", "Du ", "Ji ", "Keng ", "Zhong ", "Yao ", "Jin ", "Yun ", "Miao ", "Pei ", "Shi ", "Yue ", "Zhuang ", "Niu ", "Yan ", "Na ", "Xin ", "Fen ", "Bi ", "Yu ", "Tuo ", "Feng ", "Yuan ", "Fang ", "Wu ", "Yu ", "Gui ", "Du ", "Ba ", "Ni ", "Zhou ", "Zhuo ", "Zhao ", "Da ", "Nai ", "Yuan ", "Tou ", "Xuan ", "Zhi ", "E ", "Mei ", "Mo ", "Qi ", "Bi ", "Shen ", "Qie ", "E ", "He ", "Xu ", "Fa ", "Zheng ", "Min ", "Ban ", "Mu ", "Fu ", "Ling ", "Zi ", "Zi ", "Shi ", "Ran ", "Shan ", "Yang ", "Man ", "Jie ", "Gu ", "Si ", "Xing ", "Wei ", "Zi ", "Ju ", "Shan ", "Pin ", "Ren ", "Yao ", "Tong ", "Jiang ", "Shu ", "Ji ", "Gai ", "Shang ", "Kuo ", "Juan ", "Jiao ", "Gou ", "Mu ", "Jian ", "Jian ", "Yi ", "Nian ", "Zhi ", "Ji ", "Ji ", "Xian ", "Heng ", "Guang ", "Jun ", "Kua ", "Yan ", "Ming ", "Lie ", "Pei ", "Yan ", "You ", "Yan ", "Cha ", "Shen ", "Yin ", "Chi ", "Gui ", "Quan ", "Zi "];
  }
});

// node_modules/unidecode/data/x5a.js
var require_x5a = __commonJS({
  "node_modules/unidecode/data/x5a.js"(exports2, module2) {
    module2.exports = ["Song ", "Wei ", "Hong ", "Wa ", "Lou ", "Ya ", "Rao ", "Jiao ", "Luan ", "Ping ", "Xian ", "Shao ", "Li ", "Cheng ", "Xiao ", "Mang ", "Fu ", "Suo ", "Wu ", "Wei ", "Ke ", "Lai ", "Chuo ", "Ding ", "Niang ", "Xing ", "Nan ", "Yu ", "Nuo ", "Pei ", "Nei ", "Juan ", "Shen ", "Zhi ", "Han ", "Di ", "Zhuang ", "E ", "Pin ", "Tui ", "Han ", "Mian ", "Wu ", "Yan ", "Wu ", "Xi ", "Yan ", "Yu ", "Si ", "Yu ", "Wa ", "[?] ", "Xian ", "Ju ", "Qu ", "Shui ", "Qi ", "Xian ", "Zhui ", "Dong ", "Chang ", "Lu ", "Ai ", "E ", "E ", "Lou ", "Mian ", "Cong ", "Pou ", "Ju ", "Po ", "Cai ", "Ding ", "Wan ", "Biao ", "Xiao ", "Shu ", "Qi ", "Hui ", "Fu ", "E ", "Wo ", "Tan ", "Fei ", "Wei ", "Jie ", "Tian ", "Ni ", "Quan ", "Jing ", "Hun ", "Jing ", "Qian ", "Dian ", "Xing ", "Hu ", "Wa ", "Lai ", "Bi ", "Yin ", "Chou ", "Chuo ", "Fu ", "Jing ", "Lun ", "Yan ", "Lan ", "Kun ", "Yin ", "Ya ", "Ju ", "Li ", "Dian ", "Xian ", "Hwa ", "Hua ", "Ying ", "Chan ", "Shen ", "Ting ", "Dang ", "Yao ", "Wu ", "Nan ", "Ruo ", "Jia ", "Tou ", "Xu ", "Yu ", "Wei ", "Ti ", "Rou ", "Mei ", "Dan ", "Ruan ", "Qin ", "Hui ", "Wu ", "Qian ", "Chun ", "Mao ", "Fu ", "Jie ", "Duan ", "Xi ", "Zhong ", "Mei ", "Huang ", "Mian ", "An ", "Ying ", "Xuan ", "Jie ", "Wei ", "Mei ", "Yuan ", "Zhen ", "Qiu ", "Ti ", "Xie ", "Tuo ", "Lian ", "Mao ", "Ran ", "Si ", "Pian ", "Wei ", "Wa ", "Jiu ", "Hu ", "Ao ", "[?] ", "Bou ", "Xu ", "Tou ", "Gui ", "Zou ", "Yao ", "Pi ", "Xi ", "Yuan ", "Ying ", "Rong ", "Ru ", "Chi ", "Liu ", "Mei ", "Pan ", "Ao ", "Ma ", "Gou ", "Kui ", "Qin ", "Jia ", "Sao ", "Zhen ", "Yuan ", "Cha ", "Yong ", "Ming ", "Ying ", "Ji ", "Su ", "Niao ", "Xian ", "Tao ", "Pang ", "Lang ", "Nao ", "Bao ", "Ai ", "Pi ", "Pin ", "Yi ", "Piao ", "Yu ", "Lei ", "Xuan ", "Man ", "Yi ", "Zhang ", "Kang ", "Yong ", "Ni ", "Li ", "Di ", "Gui ", "Yan ", "Jin ", "Zhuan ", "Chang ", "Ce ", "Han ", "Nen ", "Lao ", "Mo ", "Zhe ", "Hu ", "Hu ", "Ao ", "Nen ", "Qiang ", "Ma ", "Pie ", "Gu ", "Wu ", "Jiao ", "Tuo ", "Zhan ", "Mao ", "Xian ", "Xian ", "Mo ", "Liao ", "Lian ", "Hua "];
  }
});

// node_modules/unidecode/data/x5b.js
var require_x5b = __commonJS({
  "node_modules/unidecode/data/x5b.js"(exports2, module2) {
    module2.exports = ["Gui ", "Deng ", "Zhi ", "Xu ", "Yi ", "Hua ", "Xi ", "Hui ", "Rao ", "Xi ", "Yan ", "Chan ", "Jiao ", "Mei ", "Fan ", "Fan ", "Xian ", "Yi ", "Wei ", "Jiao ", "Fu ", "Shi ", "Bi ", "Shan ", "Sui ", "Qiang ", "Lian ", "Huan ", "Xin ", "Niao ", "Dong ", "Yi ", "Can ", "Ai ", "Niang ", "Neng ", "Ma ", "Tiao ", "Chou ", "Jin ", "Ci ", "Yu ", "Pin ", "Yong ", "Xu ", "Nai ", "Yan ", "Tai ", "Ying ", "Can ", "Niao ", "Wo ", "Ying ", "Mian ", "Kaka ", "Ma ", "Shen ", "Xing ", "Ni ", "Du ", "Liu ", "Yuan ", "Lan ", "Yan ", "Shuang ", "Ling ", "Jiao ", "Niang ", "Lan ", "Xian ", "Ying ", "Shuang ", "Shuai ", "Quan ", "Mi ", "Li ", "Luan ", "Yan ", "Zhu ", "Lan ", "Zi ", "Jie ", "Jue ", "Jue ", "Kong ", "Yun ", "Zi ", "Zi ", "Cun ", "Sun ", "Fu ", "Bei ", "Zi ", "Xiao ", "Xin ", "Meng ", "Si ", "Tai ", "Bao ", "Ji ", "Gu ", "Nu ", "Xue ", "[?] ", "Zhuan ", "Hai ", "Luan ", "Sun ", "Huai ", "Mie ", "Cong ", "Qian ", "Shu ", "Chan ", "Ya ", "Zi ", "Ni ", "Fu ", "Zi ", "Li ", "Xue ", "Bo ", "Ru ", "Lai ", "Nie ", "Nie ", "Ying ", "Luan ", "Mian ", "Zhu ", "Rong ", "Ta ", "Gui ", "Zhai ", "Qiong ", "Yu ", "Shou ", "An ", "Tu ", "Song ", "Wan ", "Rou ", "Yao ", "Hong ", "Yi ", "Jing ", "Zhun ", "Mi ", "Zhu ", "Dang ", "Hong ", "Zong ", "Guan ", "Zhou ", "Ding ", "Wan ", "Yi ", "Bao ", "Shi ", "Shi ", "Chong ", "Shen ", "Ke ", "Xuan ", "Shi ", "You ", "Huan ", "Yi ", "Tiao ", "Shi ", "Xian ", "Gong ", "Cheng ", "Qun ", "Gong ", "Xiao ", "Zai ", "Zha ", "Bao ", "Hai ", "Yan ", "Xiao ", "Jia ", "Shen ", "Chen ", "Rong ", "Huang ", "Mi ", "Kou ", "Kuan ", "Bin ", "Su ", "Cai ", "Zan ", "Ji ", "Yuan ", "Ji ", "Yin ", "Mi ", "Kou ", "Qing ", "Que ", "Zhen ", "Jian ", "Fu ", "Ning ", "Bing ", "Huan ", "Mei ", "Qin ", "Han ", "Yu ", "Shi ", "Ning ", "Qin ", "Ning ", "Zhi ", "Yu ", "Bao ", "Kuan ", "Ning ", "Qin ", "Mo ", "Cha ", "Ju ", "Gua ", "Qin ", "Hu ", "Wu ", "Liao ", "Shi ", "Zhu ", "Zhai ", "Shen ", "Wei ", "Xie ", "Kuan ", "Hui ", "Liao ", "Jun ", "Huan ", "Yi ", "Yi ", "Bao ", "Qin ", "Chong ", "Bao ", "Feng ", "Cun ", "Dui ", "Si ", "Xun ", "Dao ", "Lu ", "Dui ", "Shou "];
  }
});

// node_modules/unidecode/data/x5c.js
var require_x5c = __commonJS({
  "node_modules/unidecode/data/x5c.js"(exports2, module2) {
    module2.exports = ["Po ", "Feng ", "Zhuan ", "Fu ", "She ", "Ke ", "Jiang ", "Jiang ", "Zhuan ", "Wei ", "Zun ", "Xun ", "Shu ", "Dui ", "Dao ", "Xiao ", "Ji ", "Shao ", "Er ", "Er ", "Er ", "Ga ", "Jian ", "Shu ", "Chen ", "Shang ", "Shang ", "Mo ", "Ga ", "Chang ", "Liao ", "Xian ", "Xian ", "[?] ", "Wang ", "Wang ", "You ", "Liao ", "Liao ", "Yao ", "Mang ", "Wang ", "Wang ", "Wang ", "Ga ", "Yao ", "Duo ", "Kui ", "Zhong ", "Jiu ", "Gan ", "Gu ", "Gan ", "Tui ", "Gan ", "Gan ", "Shi ", "Yin ", "Chi ", "Kao ", "Ni ", "Jin ", "Wei ", "Niao ", "Ju ", "Pi ", "Ceng ", "Xi ", "Bi ", "Ju ", "Jie ", "Tian ", "Qu ", "Ti ", "Jie ", "Wu ", "Diao ", "Shi ", "Shi ", "Ping ", "Ji ", "Xie ", "Chen ", "Xi ", "Ni ", "Zhan ", "Xi ", "[?] ", "Man ", "E ", "Lou ", "Ping ", "Ti ", "Fei ", "Shu ", "Xie ", "Tu ", "Lu ", "Lu ", "Xi ", "Ceng ", "Lu ", "Ju ", "Xie ", "Ju ", "Jue ", "Liao ", "Jue ", "Shu ", "Xi ", "Che ", "Tun ", "Ni ", "Shan ", "[?] ", "Xian ", "Li ", "Xue ", "Nata ", "[?] ", "Long ", "Yi ", "Qi ", "Ren ", "Wu ", "Han ", "Shen ", "Yu ", "Chu ", "Sui ", "Qi ", "[?] ", "Yue ", "Ban ", "Yao ", "Ang ", "Ya ", "Wu ", "Jie ", "E ", "Ji ", "Qian ", "Fen ", "Yuan ", "Qi ", "Cen ", "Qian ", "Qi ", "Cha ", "Jie ", "Qu ", "Gang ", "Xian ", "Ao ", "Lan ", "Dao ", "Ba ", "Zuo ", "Zuo ", "Yang ", "Ju ", "Gang ", "Ke ", "Gou ", "Xue ", "Bei ", "Li ", "Tiao ", "Ju ", "Yan ", "Fu ", "Xiu ", "Jia ", "Ling ", "Tuo ", "Pei ", "You ", "Dai ", "Kuang ", "Yue ", "Qu ", "Hu ", "Po ", "Min ", "An ", "Tiao ", "Ling ", "Chi ", "Yuri ", "Dong ", "Cem ", "Kui ", "Xiu ", "Mao ", "Tong ", "Xue ", "Yi ", "Kura ", "He ", "Ke ", "Luo ", "E ", "Fu ", "Xun ", "Die ", "Lu ", "An ", "Er ", "Gai ", "Quan ", "Tong ", "Yi ", "Mu ", "Shi ", "An ", "Wei ", "Hu ", "Zhi ", "Mi ", "Li ", "Ji ", "Tong ", "Wei ", "You ", "Sang ", "Xia ", "Li ", "Yao ", "Jiao ", "Zheng ", "Luan ", "Jiao ", "E ", "E ", "Yu ", "Ye ", "Bu ", "Qiao ", "Qun ", "Feng ", "Feng ", "Nao ", "Li ", "You ", "Xian ", "Hong ", "Dao ", "Shen ", "Cheng ", "Tu ", "Geng ", "Jun ", "Hao ", "Xia ", "Yin ", "Yu "];
  }
});

// node_modules/unidecode/data/x5d.js
var require_x5d = __commonJS({
  "node_modules/unidecode/data/x5d.js"(exports2, module2) {
    module2.exports = ["Lang ", "Kan ", "Lao ", "Lai ", "Xian ", "Que ", "Kong ", "Chong ", "Chong ", "Ta ", "Lin ", "Hua ", "Ju ", "Lai ", "Qi ", "Min ", "Kun ", "Kun ", "Zu ", "Gu ", "Cui ", "Ya ", "Ya ", "Gang ", "Lun ", "Lun ", "Leng ", "Jue ", "Duo ", "Zheng ", "Guo ", "Yin ", "Dong ", "Han ", "Zheng ", "Wei ", "Yao ", "Pi ", "Yan ", "Song ", "Jie ", "Beng ", "Zu ", "Jue ", "Dong ", "Zhan ", "Gu ", "Yin ", "[?] ", "Ze ", "Huang ", "Yu ", "Wei ", "Yang ", "Feng ", "Qiu ", "Dun ", "Ti ", "Yi ", "Zhi ", "Shi ", "Zai ", "Yao ", "E ", "Zhu ", "Kan ", "Lu ", "Yan ", "Mei ", "Gan ", "Ji ", "Ji ", "Huan ", "Ting ", "Sheng ", "Mei ", "Qian ", "Wu ", "Yu ", "Zong ", "Lan ", "Jue ", "Yan ", "Yan ", "Wei ", "Zong ", "Cha ", "Sui ", "Rong ", "Yamashina ", "Qin ", "Yu ", "Kewashii ", "Lou ", "Tu ", "Dui ", "Xi ", "Weng ", "Cang ", "Dang ", "Hong ", "Jie ", "Ai ", "Liu ", "Wu ", "Song ", "Qiao ", "Zi ", "Wei ", "Beng ", "Dian ", "Cuo ", "Qian ", "Yong ", "Nie ", "Cuo ", "Ji ", "[?] ", "Tao ", "Song ", "Zong ", "Jiang ", "Liao ", "Kang ", "Chan ", "Die ", "Cen ", "Ding ", "Tu ", "Lou ", "Zhang ", "Zhan ", "Zhan ", "Ao ", "Cao ", "Qu ", "Qiang ", "Zui ", "Zui ", "Dao ", "Dao ", "Xi ", "Yu ", "Bo ", "Long ", "Xiang ", "Ceng ", "Bo ", "Qin ", "Jiao ", "Yan ", "Lao ", "Zhan ", "Lin ", "Liao ", "Liao ", "Jin ", "Deng ", "Duo ", "Zun ", "Jiao ", "Gui ", "Yao ", "Qiao ", "Yao ", "Jue ", "Zhan ", "Yi ", "Xue ", "Nao ", "Ye ", "Ye ", "Yi ", "E ", "Xian ", "Ji ", "Xie ", "Ke ", "Xi ", "Di ", "Ao ", "Zui ", "[?] ", "Ni ", "Rong ", "Dao ", "Ling ", "Za ", "Yu ", "Yue ", "Yin ", "[?] ", "Jie ", "Li ", "Sui ", "Long ", "Long ", "Dian ", "Ying ", "Xi ", "Ju ", "Chan ", "Ying ", "Kui ", "Yan ", "Wei ", "Nao ", "Quan ", "Chao ", "Cuan ", "Luan ", "Dian ", "Dian ", "[?] ", "Yan ", "Yan ", "Yan ", "Nao ", "Yan ", "Chuan ", "Gui ", "Chuan ", "Zhou ", "Huang ", "Jing ", "Xun ", "Chao ", "Chao ", "Lie ", "Gong ", "Zuo ", "Qiao ", "Ju ", "Gong ", "Kek ", "Wu ", "Pwu ", "Pwu ", "Chai ", "Qiu ", "Qiu ", "Ji ", "Yi ", "Si ", "Ba ", "Zhi ", "Zhao ", "Xiang ", "Yi ", "Jin ", "Xun ", "Juan ", "Phas ", "Xun ", "Jin ", "Fu "];
  }
});

// node_modules/unidecode/data/x5e.js
var require_x5e = __commonJS({
  "node_modules/unidecode/data/x5e.js"(exports2, module2) {
    module2.exports = ["Za ", "Bi ", "Shi ", "Bu ", "Ding ", "Shuai ", "Fan ", "Nie ", "Shi ", "Fen ", "Pa ", "Zhi ", "Xi ", "Hu ", "Dan ", "Wei ", "Zhang ", "Tang ", "Dai ", "Ma ", "Pei ", "Pa ", "Tie ", "Fu ", "Lian ", "Zhi ", "Zhou ", "Bo ", "Zhi ", "Di ", "Mo ", "Yi ", "Yi ", "Ping ", "Qia ", "Juan ", "Ru ", "Shuai ", "Dai ", "Zheng ", "Shui ", "Qiao ", "Zhen ", "Shi ", "Qun ", "Xi ", "Bang ", "Dai ", "Gui ", "Chou ", "Ping ", "Zhang ", "Sha ", "Wan ", "Dai ", "Wei ", "Chang ", "Sha ", "Qi ", "Ze ", "Guo ", "Mao ", "Du ", "Hou ", "Zheng ", "Xu ", "Mi ", "Wei ", "Wo ", "Fu ", "Yi ", "Bang ", "Ping ", "Tazuna ", "Gong ", "Pan ", "Huang ", "Dao ", "Mi ", "Jia ", "Teng ", "Hui ", "Zhong ", "Shan ", "Man ", "Mu ", "Biao ", "Guo ", "Ze ", "Mu ", "Bang ", "Zhang ", "Jiong ", "Chan ", "Fu ", "Zhi ", "Hu ", "Fan ", "Chuang ", "Bi ", "Hei ", "[?] ", "Mi ", "Qiao ", "Chan ", "Fen ", "Meng ", "Bang ", "Chou ", "Mie ", "Chu ", "Jie ", "Xian ", "Lan ", "Gan ", "Ping ", "Nian ", "Qian ", "Bing ", "Bing ", "Xing ", "Gan ", "Yao ", "Huan ", "You ", "You ", "Ji ", "Yan ", "Pi ", "Ting ", "Ze ", "Guang ", "Zhuang ", "Mo ", "Qing ", "Bi ", "Qin ", "Dun ", "Chuang ", "Gui ", "Ya ", "Bai ", "Jie ", "Xu ", "Lu ", "Wu ", "[?] ", "Ku ", "Ying ", "Di ", "Pao ", "Dian ", "Ya ", "Miao ", "Geng ", "Ci ", "Fu ", "Tong ", "Pang ", "Fei ", "Xiang ", "Yi ", "Zhi ", "Tiao ", "Zhi ", "Xiu ", "Du ", "Zuo ", "Xiao ", "Tu ", "Gui ", "Ku ", "Pang ", "Ting ", "You ", "Bu ", "Ding ", "Cheng ", "Lai ", "Bei ", "Ji ", "An ", "Shu ", "Kang ", "Yong ", "Tuo ", "Song ", "Shu ", "Qing ", "Yu ", "Yu ", "Miao ", "Sou ", "Ce ", "Xiang ", "Fei ", "Jiu ", "He ", "Hui ", "Liu ", "Sha ", "Lian ", "Lang ", "Sou ", "Jian ", "Pou ", "Qing ", "Jiu ", "Jiu ", "Qin ", "Ao ", "Kuo ", "Lou ", "Yin ", "Liao ", "Dai ", "Lu ", "Yi ", "Chu ", "Chan ", "Tu ", "Si ", "Xin ", "Miao ", "Chang ", "Wu ", "Fei ", "Guang ", "Koc ", "Kuai ", "Bi ", "Qiang ", "Xie ", "Lin ", "Lin ", "Liao ", "Lu ", "[?] ", "Ying ", "Xian ", "Ting ", "Yong ", "Li ", "Ting ", "Yin ", "Xun ", "Yan ", "Ting ", "Di ", "Po ", "Jian ", "Hui ", "Nai ", "Hui ", "Gong ", "Nian "];
  }
});

// node_modules/unidecode/data/x5f.js
var require_x5f = __commonJS({
  "node_modules/unidecode/data/x5f.js"(exports2, module2) {
    module2.exports = ["Kai ", "Bian ", "Yi ", "Qi ", "Nong ", "Fen ", "Ju ", "Yan ", "Yi ", "Zang ", "Bi ", "Yi ", "Yi ", "Er ", "San ", "Shi ", "Er ", "Shi ", "Shi ", "Gong ", "Diao ", "Yin ", "Hu ", "Fu ", "Hong ", "Wu ", "Tui ", "Chi ", "Jiang ", "Ba ", "Shen ", "Di ", "Zhang ", "Jue ", "Tao ", "Fu ", "Di ", "Mi ", "Xian ", "Hu ", "Chao ", "Nu ", "Jing ", "Zhen ", "Yi ", "Mi ", "Quan ", "Wan ", "Shao ", "Ruo ", "Xuan ", "Jing ", "Dun ", "Zhang ", "Jiang ", "Qiang ", "Peng ", "Dan ", "Qiang ", "Bi ", "Bi ", "She ", "Dan ", "Jian ", "Gou ", "Sei ", "Fa ", "Bi ", "Kou ", "Nagi ", "Bie ", "Xiao ", "Dan ", "Kuo ", "Qiang ", "Hong ", "Mi ", "Kuo ", "Wan ", "Jue ", "Ji ", "Ji ", "Gui ", "Dang ", "Lu ", "Lu ", "Tuan ", "Hui ", "Zhi ", "Hui ", "Hui ", "Yi ", "Yi ", "Yi ", "Yi ", "Huo ", "Huo ", "Shan ", "Xing ", "Wen ", "Tong ", "Yan ", "Yan ", "Yu ", "Chi ", "Cai ", "Biao ", "Diao ", "Bin ", "Peng ", "Yong ", "Piao ", "Zhang ", "Ying ", "Chi ", "Chi ", "Zhuo ", "Tuo ", "Ji ", "Pang ", "Zhong ", "Yi ", "Wang ", "Che ", "Bi ", "Chi ", "Ling ", "Fu ", "Wang ", "Zheng ", "Cu ", "Wang ", "Jing ", "Dai ", "Xi ", "Xun ", "Hen ", "Yang ", "Huai ", "Lu ", "Hou ", "Wa ", "Cheng ", "Zhi ", "Xu ", "Jing ", "Tu ", "Cong ", "[?] ", "Lai ", "Cong ", "De ", "Pai ", "Xi ", "[?] ", "Qi ", "Chang ", "Zhi ", "Cong ", "Zhou ", "Lai ", "Yu ", "Xie ", "Jie ", "Jian ", "Chi ", "Jia ", "Bian ", "Huang ", "Fu ", "Xun ", "Wei ", "Pang ", "Yao ", "Wei ", "Xi ", "Zheng ", "Piao ", "Chi ", "De ", "Zheng ", "Zheng ", "Bie ", "De ", "Chong ", "Che ", "Jiao ", "Wei ", "Jiao ", "Hui ", "Mei ", "Long ", "Xiang ", "Bao ", "Qu ", "Xin ", "Shu ", "Bi ", "Yi ", "Le ", "Ren ", "Dao ", "Ding ", "Gai ", "Ji ", "Ren ", "Ren ", "Chan ", "Tan ", "Te ", "Te ", "Gan ", "Qi ", "Shi ", "Cun ", "Zhi ", "Wang ", "Mang ", "Xi ", "Fan ", "Ying ", "Tian ", "Min ", "Min ", "Zhong ", "Chong ", "Wu ", "Ji ", "Wu ", "Xi ", "Ye ", "You ", "Wan ", "Cong ", "Zhong ", "Kuai ", "Yu ", "Bian ", "Zhi ", "Qi ", "Cui ", "Chen ", "Tai ", "Tun ", "Qian ", "Nian ", "Hun ", "Xiong ", "Niu ", "Wang ", "Xian ", "Xin ", "Kang ", "Hu ", "Kai ", "Fen "];
  }
});

// node_modules/unidecode/data/x60.js
var require_x60 = __commonJS({
  "node_modules/unidecode/data/x60.js"(exports2, module2) {
    module2.exports = ["Huai ", "Tai ", "Song ", "Wu ", "Ou ", "Chang ", "Chuang ", "Ju ", "Yi ", "Bao ", "Chao ", "Min ", "Pei ", "Zuo ", "Zen ", "Yang ", "Kou ", "Ban ", "Nu ", "Nao ", "Zheng ", "Pa ", "Bu ", "Tie ", "Gu ", "Hu ", "Ju ", "Da ", "Lian ", "Si ", "Chou ", "Di ", "Dai ", "Yi ", "Tu ", "You ", "Fu ", "Ji ", "Peng ", "Xing ", "Yuan ", "Ni ", "Guai ", "Fu ", "Xi ", "Bi ", "You ", "Qie ", "Xuan ", "Cong ", "Bing ", "Huang ", "Xu ", "Chu ", "Pi ", "Xi ", "Xi ", "Tan ", "Koraeru ", "Zong ", "Dui ", "[?] ", "Ki ", "Yi ", "Chi ", "Ren ", "Xun ", "Shi ", "Xi ", "Lao ", "Heng ", "Kuang ", "Mu ", "Zhi ", "Xie ", "Lian ", "Tiao ", "Huang ", "Die ", "Hao ", "Kong ", "Gui ", "Heng ", "Xi ", "Xiao ", "Shu ", "S ", "Kua ", "Qiu ", "Yang ", "Hui ", "Hui ", "Chi ", "Jia ", "Yi ", "Xiong ", "Guai ", "Lin ", "Hui ", "Zi ", "Xu ", "Chi ", "Xiang ", "Nu ", "Hen ", "En ", "Ke ", "Tong ", "Tian ", "Gong ", "Quan ", "Xi ", "Qia ", "Yue ", "Peng ", "Ken ", "De ", "Hui ", "E ", "Kyuu ", "Tong ", "Yan ", "Kai ", "Ce ", "Nao ", "Yun ", "Mang ", "Yong ", "Yong ", "Yuan ", "Pi ", "Kun ", "Qiao ", "Yue ", "Yu ", "Yu ", "Jie ", "Xi ", "Zhe ", "Lin ", "Ti ", "Han ", "Hao ", "Qie ", "Ti ", "Bu ", "Yi ", "Qian ", "Hui ", "Xi ", "Bei ", "Man ", "Yi ", "Heng ", "Song ", "Quan ", "Cheng ", "Hui ", "Wu ", "Wu ", "You ", "Li ", "Liang ", "Huan ", "Cong ", "Yi ", "Yue ", "Li ", "Nin ", "Nao ", "E ", "Que ", "Xuan ", "Qian ", "Wu ", "Min ", "Cong ", "Fei ", "Bei ", "Duo ", "Cui ", "Chang ", "Men ", "Li ", "Ji ", "Guan ", "Guan ", "Xing ", "Dao ", "Qi ", "Kong ", "Tian ", "Lun ", "Xi ", "Kan ", "Kun ", "Ni ", "Qing ", "Chou ", "Dun ", "Guo ", "Chan ", "Liang ", "Wan ", "Yuan ", "Jin ", "Ji ", "Lin ", "Yu ", "Huo ", "He ", "Quan ", "Tan ", "Ti ", "Ti ", "Nie ", "Wang ", "Chuo ", "Bu ", "Hun ", "Xi ", "Tang ", "Xin ", "Wei ", "Hui ", "E ", "Rui ", "Zong ", "Jian ", "Yong ", "Dian ", "Ju ", "Can ", "Cheng ", "De ", "Bei ", "Qie ", "Can ", "Dan ", "Guan ", "Duo ", "Nao ", "Yun ", "Xiang ", "Zhui ", "Die ", "Huang ", "Chun ", "Qiong ", "Re ", "Xing ", "Ce ", "Bian ", "Hun ", "Zong ", "Ti "];
  }
});

// node_modules/unidecode/data/x61.js
var require_x61 = __commonJS({
  "node_modules/unidecode/data/x61.js"(exports2, module2) {
    module2.exports = ["Qiao ", "Chou ", "Bei ", "Xuan ", "Wei ", "Ge ", "Qian ", "Wei ", "Yu ", "Yu ", "Bi ", "Xuan ", "Huan ", "Min ", "Bi ", "Yi ", "Mian ", "Yong ", "Kai ", "Dang ", "Yin ", "E ", "Chen ", "Mou ", "Ke ", "Ke ", "Yu ", "Ai ", "Qie ", "Yan ", "Nuo ", "Gan ", "Yun ", "Zong ", "Sai ", "Leng ", "Fen ", "[?] ", "Kui ", "Kui ", "Que ", "Gong ", "Yun ", "Su ", "Su ", "Qi ", "Yao ", "Song ", "Huang ", "Ji ", "Gu ", "Ju ", "Chuang ", "Ni ", "Xie ", "Kai ", "Zheng ", "Yong ", "Cao ", "Sun ", "Shen ", "Bo ", "Kai ", "Yuan ", "Xie ", "Hun ", "Yong ", "Yang ", "Li ", "Sao ", "Tao ", "Yin ", "Ci ", "Xu ", "Qian ", "Tai ", "Huang ", "Yun ", "Shen ", "Ming ", "[?] ", "She ", "Cong ", "Piao ", "Mo ", "Mu ", "Guo ", "Chi ", "Can ", "Can ", "Can ", "Cui ", "Min ", "Te ", "Zhang ", "Tong ", "Ao ", "Shuang ", "Man ", "Guan ", "Que ", "Zao ", "Jiu ", "Hui ", "Kai ", "Lian ", "Ou ", "Song ", "Jin ", "Yin ", "Lu ", "Shang ", "Wei ", "Tuan ", "Man ", "Qian ", "She ", "Yong ", "Qing ", "Kang ", "Di ", "Zhi ", "Lou ", "Juan ", "Qi ", "Qi ", "Yu ", "Ping ", "Liao ", "Cong ", "You ", "Chong ", "Zhi ", "Tong ", "Cheng ", "Qi ", "Qu ", "Peng ", "Bei ", "Bie ", "Chun ", "Jiao ", "Zeng ", "Chi ", "Lian ", "Ping ", "Kui ", "Hui ", "Qiao ", "Cheng ", "Yin ", "Yin ", "Xi ", "Xi ", "Dan ", "Tan ", "Duo ", "Dui ", "Dui ", "Su ", "Jue ", "Ce ", "Xiao ", "Fan ", "Fen ", "Lao ", "Lao ", "Chong ", "Han ", "Qi ", "Xian ", "Min ", "Jing ", "Liao ", "Wu ", "Can ", "Jue ", "Cu ", "Xian ", "Tan ", "Sheng ", "Pi ", "Yi ", "Chu ", "Xian ", "Nao ", "Dan ", "Tan ", "Jing ", "Song ", "Han ", "Jiao ", "Wai ", "Huan ", "Dong ", "Qin ", "Qin ", "Qu ", "Cao ", "Ken ", "Xie ", "Ying ", "Ao ", "Mao ", "Yi ", "Lin ", "Se ", "Jun ", "Huai ", "Men ", "Lan ", "Ai ", "Lin ", "Yan ", "Gua ", "Xia ", "Chi ", "Yu ", "Yin ", "Dai ", "Meng ", "Ai ", "Meng ", "Dui ", "Qi ", "Mo ", "Lan ", "Men ", "Chou ", "Zhi ", "Nuo ", "Nuo ", "Yan ", "Yang ", "Bo ", "Zhi ", "Kuang ", "Kuang ", "You ", "Fu ", "Liu ", "Mie ", "Cheng ", "[?] ", "Chan ", "Meng ", "Lan ", "Huai ", "Xuan ", "Rang ", "Chan ", "Ji ", "Ju ", "Huan ", "She ", "Yi "];
  }
});

// node_modules/unidecode/data/x62.js
var require_x62 = __commonJS({
  "node_modules/unidecode/data/x62.js"(exports2, module2) {
    module2.exports = ["Lian ", "Nan ", "Mi ", "Tang ", "Jue ", "Gang ", "Gang ", "Gang ", "Ge ", "Yue ", "Wu ", "Jian ", "Xu ", "Shu ", "Rong ", "Xi ", "Cheng ", "Wo ", "Jie ", "Ge ", "Jian ", "Qiang ", "Huo ", "Qiang ", "Zhan ", "Dong ", "Qi ", "Jia ", "Die ", "Zei ", "Jia ", "Ji ", "Shi ", "Kan ", "Ji ", "Kui ", "Gai ", "Deng ", "Zhan ", "Chuang ", "Ge ", "Jian ", "Jie ", "Yu ", "Jian ", "Yan ", "Lu ", "Xi ", "Zhan ", "Xi ", "Xi ", "Chuo ", "Dai ", "Qu ", "Hu ", "Hu ", "Hu ", "E ", "Shi ", "Li ", "Mao ", "Hu ", "Li ", "Fang ", "Suo ", "Bian ", "Dian ", "Jiong ", "Shang ", "Yi ", "Yi ", "Shan ", "Hu ", "Fei ", "Yan ", "Shou ", "T ", "Cai ", "Zha ", "Qiu ", "Le ", "Bu ", "Ba ", "Da ", "Reng ", "Fu ", "Hameru ", "Zai ", "Tuo ", "Zhang ", "Diao ", "Kang ", "Yu ", "Ku ", "Han ", "Shen ", "Cha ", "Yi ", "Gu ", "Kou ", "Wu ", "Tuo ", "Qian ", "Zhi ", "Ren ", "Kuo ", "Men ", "Sao ", "Yang ", "Niu ", "Ban ", "Che ", "Rao ", "Xi ", "Qian ", "Ban ", "Jia ", "Yu ", "Fu ", "Ao ", "Xi ", "Pi ", "Zhi ", "Zi ", "E ", "Dun ", "Zhao ", "Cheng ", "Ji ", "Yan ", "Kuang ", "Bian ", "Chao ", "Ju ", "Wen ", "Hu ", "Yue ", "Jue ", "Ba ", "Qin ", "Zhen ", "Zheng ", "Yun ", "Wan ", "Nu ", "Yi ", "Shu ", "Zhua ", "Pou ", "Tou ", "Dou ", "Kang ", "Zhe ", "Pou ", "Fu ", "Pao ", "Ba ", "Ao ", "Ze ", "Tuan ", "Kou ", "Lun ", "Qiang ", "[?] ", "Hu ", "Bao ", "Bing ", "Zhi ", "Peng ", "Tan ", "Pu ", "Pi ", "Tai ", "Yao ", "Zhen ", "Zha ", "Yang ", "Bao ", "He ", "Ni ", "Yi ", "Di ", "Chi ", "Pi ", "Za ", "Mo ", "Mo ", "Shen ", "Ya ", "Chou ", "Qu ", "Min ", "Chu ", "Jia ", "Fu ", "Zhan ", "Zhu ", "Dan ", "Chai ", "Mu ", "Nian ", "La ", "Fu ", "Pao ", "Ban ", "Pai ", "Ling ", "Na ", "Guai ", "Qian ", "Ju ", "Tuo ", "Ba ", "Tuo ", "Tuo ", "Ao ", "Ju ", "Zhuo ", "Pan ", "Zhao ", "Bai ", "Bai ", "Di ", "Ni ", "Ju ", "Kuo ", "Long ", "Jian ", "[?] ", "Yong ", "Lan ", "Ning ", "Bo ", "Ze ", "Qian ", "Hen ", "Gua ", "Shi ", "Jie ", "Zheng ", "Nin ", "Gong ", "Gong ", "Quan ", "Shuan ", "Cun ", "Zan ", "Kao ", "Chi ", "Xie ", "Ce ", "Hui ", "Pin ", "Zhuai ", "Shi ", "Na "];
  }
});

// node_modules/unidecode/data/x63.js
var require_x63 = __commonJS({
  "node_modules/unidecode/data/x63.js"(exports2, module2) {
    module2.exports = ["Bo ", "Chi ", "Gua ", "Zhi ", "Kuo ", "Duo ", "Duo ", "Zhi ", "Qie ", "An ", "Nong ", "Zhen ", "Ge ", "Jiao ", "Ku ", "Dong ", "Ru ", "Tiao ", "Lie ", "Zha ", "Lu ", "Die ", "Wa ", "Jue ", "Mushiru ", "Ju ", "Zhi ", "Luan ", "Ya ", "Zhua ", "Ta ", "Xie ", "Nao ", "Dang ", "Jiao ", "Zheng ", "Ji ", "Hui ", "Xun ", "Ku ", "Ai ", "Tuo ", "Nuo ", "Cuo ", "Bo ", "Geng ", "Ti ", "Zhen ", "Cheng ", "Suo ", "Suo ", "Keng ", "Mei ", "Long ", "Ju ", "Peng ", "Jian ", "Yi ", "Ting ", "Shan ", "Nuo ", "Wan ", "Xie ", "Cha ", "Feng ", "Jiao ", "Wu ", "Jun ", "Jiu ", "Tong ", "Kun ", "Huo ", "Tu ", "Zhuo ", "Pou ", "Le ", "Ba ", "Han ", "Shao ", "Nie ", "Juan ", "Ze ", "Song ", "Ye ", "Jue ", "Bu ", "Huan ", "Bu ", "Zun ", "Yi ", "Zhai ", "Lu ", "Sou ", "Tuo ", "Lao ", "Sun ", "Bang ", "Jian ", "Huan ", "Dao ", "[?] ", "Wan ", "Qin ", "Peng ", "She ", "Lie ", "Min ", "Men ", "Fu ", "Bai ", "Ju ", "Dao ", "Wo ", "Ai ", "Juan ", "Yue ", "Zong ", "Chen ", "Chui ", "Jie ", "Tu ", "Ben ", "Na ", "Nian ", "Nuo ", "Zu ", "Wo ", "Xi ", "Xian ", "Cheng ", "Dian ", "Sao ", "Lun ", "Qing ", "Gang ", "Duo ", "Shou ", "Diao ", "Pou ", "Di ", "Zhang ", "Gun ", "Ji ", "Tao ", "Qia ", "Qi ", "Pai ", "Shu ", "Qian ", "Ling ", "Yi ", "Ya ", "Jue ", "Zheng ", "Liang ", "Gua ", "Yi ", "Huo ", "Shan ", "Zheng ", "Lue ", "Cai ", "Tan ", "Che ", "Bing ", "Jie ", "Ti ", "Kong ", "Tui ", "Yan ", "Cuo ", "Zou ", "Ju ", "Tian ", "Qian ", "Ken ", "Bai ", "Shou ", "Jie ", "Lu ", "Guo ", "Haba ", "[?] ", "Zhi ", "Dan ", "Mang ", "Xian ", "Sao ", "Guan ", "Peng ", "Yuan ", "Nuo ", "Jian ", "Zhen ", "Jiu ", "Jian ", "Yu ", "Yan ", "Kui ", "Nan ", "Hong ", "Rou ", "Pi ", "Wei ", "Sai ", "Zou ", "Xuan ", "Miao ", "Ti ", "Nie ", "Cha ", "Shi ", "Zong ", "Zhen ", "Yi ", "Shun ", "Heng ", "Bian ", "Yang ", "Huan ", "Yan ", "Zuan ", "An ", "Xu ", "Ya ", "Wo ", "Ke ", "Chuai ", "Ji ", "Ti ", "La ", "La ", "Cheng ", "Kai ", "Jiu ", "Jiu ", "Tu ", "Jie ", "Hui ", "Geng ", "Chong ", "Shuo ", "She ", "Xie ", "Yuan ", "Qian ", "Ye ", "Cha ", "Zha ", "Bei ", "Yao ", "[?] ", "[?] ", "Lan ", "Wen ", "Qin "];
  }
});

// node_modules/unidecode/data/x64.js
var require_x64 = __commonJS({
  "node_modules/unidecode/data/x64.js"(exports2, module2) {
    module2.exports = ["Chan ", "Ge ", "Lou ", "Zong ", "Geng ", "Jiao ", "Gou ", "Qin ", "Yong ", "Que ", "Chou ", "Chi ", "Zhan ", "Sun ", "Sun ", "Bo ", "Chu ", "Rong ", "Beng ", "Cuo ", "Sao ", "Ke ", "Yao ", "Dao ", "Zhi ", "Nu ", "Xie ", "Jian ", "Sou ", "Qiu ", "Gao ", "Xian ", "Shuo ", "Sang ", "Jin ", "Mie ", "E ", "Chui ", "Nuo ", "Shan ", "Ta ", "Jie ", "Tang ", "Pan ", "Ban ", "Da ", "Li ", "Tao ", "Hu ", "Zhi ", "Wa ", "Xia ", "Qian ", "Wen ", "Qiang ", "Tian ", "Zhen ", "E ", "Xi ", "Nuo ", "Quan ", "Cha ", "Zha ", "Ge ", "Wu ", "En ", "She ", "Kang ", "She ", "Shu ", "Bai ", "Yao ", "Bin ", "Sou ", "Tan ", "Sa ", "Chan ", "Suo ", "Liao ", "Chong ", "Chuang ", "Guo ", "Bing ", "Feng ", "Shuai ", "Di ", "Qi ", "Sou ", "Zhai ", "Lian ", "Tang ", "Chi ", "Guan ", "Lu ", "Luo ", "Lou ", "Zong ", "Gai ", "Hu ", "Zha ", "Chuang ", "Tang ", "Hua ", "Cui ", "Nai ", "Mo ", "Jiang ", "Gui ", "Ying ", "Zhi ", "Ao ", "Zhi ", "Nie ", "Man ", "Shan ", "Kou ", "Shu ", "Suo ", "Tuan ", "Jiao ", "Mo ", "Mo ", "Zhe ", "Xian ", "Keng ", "Piao ", "Jiang ", "Yin ", "Gou ", "Qian ", "Lue ", "Ji ", "Ying ", "Jue ", "Pie ", "Pie ", "Lao ", "Dun ", "Xian ", "Ruan ", "Kui ", "Zan ", "Yi ", "Xun ", "Cheng ", "Cheng ", "Sa ", "Nao ", "Heng ", "Si ", "Qian ", "Huang ", "Da ", "Zun ", "Nian ", "Lin ", "Zheng ", "Hui ", "Zhuang ", "Jiao ", "Ji ", "Cao ", "Dan ", "Dan ", "Che ", "Bo ", "Che ", "Jue ", "Xiao ", "Liao ", "Ben ", "Fu ", "Qiao ", "Bo ", "Cuo ", "Zhuo ", "Zhuan ", "Tuo ", "Pu ", "Qin ", "Dun ", "Nian ", "[?] ", "Xie ", "Lu ", "Jiao ", "Cuan ", "Ta ", "Han ", "Qiao ", "Zhua ", "Jian ", "Gan ", "Yong ", "Lei ", "Kuo ", "Lu ", "Shan ", "Zhuo ", "Ze ", "Pu ", "Chuo ", "Ji ", "Dang ", "Suo ", "Cao ", "Qing ", "Jing ", "Huan ", "Jie ", "Qin ", "Kuai ", "Dan ", "Xi ", "Ge ", "Pi ", "Bo ", "Ao ", "Ju ", "Ye ", "[?] ", "Mang ", "Sou ", "Mi ", "Ji ", "Tai ", "Zhuo ", "Dao ", "Xing ", "Lan ", "Ca ", "Ju ", "Ye ", "Ru ", "Ye ", "Ye ", "Ni ", "Hu ", "Ji ", "Bin ", "Ning ", "Ge ", "Zhi ", "Jie ", "Kuo ", "Mo ", "Jian ", "Xie ", "Lie ", "Tan ", "Bai ", "Sou ", "Lu ", "Lue ", "Rao ", "Zhi "];
  }
});

// node_modules/unidecode/data/x65.js
var require_x65 = __commonJS({
  "node_modules/unidecode/data/x65.js"(exports2, module2) {
    module2.exports = ["Pan ", "Yang ", "Lei ", "Sa ", "Shu ", "Zan ", "Nian ", "Xian ", "Jun ", "Huo ", "Li ", "La ", "Han ", "Ying ", "Lu ", "Long ", "Qian ", "Qian ", "Zan ", "Qian ", "Lan ", "San ", "Ying ", "Mei ", "Rang ", "Chan ", "[?] ", "Cuan ", "Xi ", "She ", "Luo ", "Jun ", "Mi ", "Li ", "Zan ", "Luan ", "Tan ", "Zuan ", "Li ", "Dian ", "Wa ", "Dang ", "Jiao ", "Jue ", "Lan ", "Li ", "Nang ", "Zhi ", "Gui ", "Gui ", "Qi ", "Xin ", "Pu ", "Sui ", "Shou ", "Kao ", "You ", "Gai ", "Yi ", "Gong ", "Gan ", "Ban ", "Fang ", "Zheng ", "Bo ", "Dian ", "Kou ", "Min ", "Wu ", "Gu ", "He ", "Ce ", "Xiao ", "Mi ", "Chu ", "Ge ", "Di ", "Xu ", "Jiao ", "Min ", "Chen ", "Jiu ", "Zhen ", "Duo ", "Yu ", "Chi ", "Ao ", "Bai ", "Xu ", "Jiao ", "Duo ", "Lian ", "Nie ", "Bi ", "Chang ", "Dian ", "Duo ", "Yi ", "Gan ", "San ", "Ke ", "Yan ", "Dun ", "Qi ", "Dou ", "Xiao ", "Duo ", "Jiao ", "Jing ", "Yang ", "Xia ", "Min ", "Shu ", "Ai ", "Qiao ", "Ai ", "Zheng ", "Di ", "Zhen ", "Fu ", "Shu ", "Liao ", "Qu ", "Xiong ", "Xi ", "Jiao ", "Sen ", "Jiao ", "Zhuo ", "Yi ", "Lian ", "Bi ", "Li ", "Xiao ", "Xiao ", "Wen ", "Xue ", "Qi ", "Qi ", "Zhai ", "Bin ", "Jue ", "Zhai ", "[?] ", "Fei ", "Ban ", "Ban ", "Lan ", "Yu ", "Lan ", "Wei ", "Dou ", "Sheng ", "Liao ", "Jia ", "Hu ", "Xie ", "Jia ", "Yu ", "Zhen ", "Jiao ", "Wo ", "Tou ", "Chu ", "Jin ", "Chi ", "Yin ", "Fu ", "Qiang ", "Zhan ", "Qu ", "Zhuo ", "Zhan ", "Duan ", "Zhuo ", "Si ", "Xin ", "Zhuo ", "Zhuo ", "Qin ", "Lin ", "Zhuo ", "Chu ", "Duan ", "Zhu ", "Fang ", "Xie ", "Hang ", "Yu ", "Shi ", "Pei ", "You ", "Mye ", "Pang ", "Qi ", "Zhan ", "Mao ", "Lu ", "Pei ", "Pi ", "Liu ", "Fu ", "Fang ", "Xuan ", "Jing ", "Jing ", "Ni ", "Zu ", "Zhao ", "Yi ", "Liu ", "Shao ", "Jian ", "Es ", "Yi ", "Qi ", "Zhi ", "Fan ", "Piao ", "Fan ", "Zhan ", "Guai ", "Sui ", "Yu ", "Wu ", "Ji ", "Ji ", "Ji ", "Huo ", "Ri ", "Dan ", "Jiu ", "Zhi ", "Zao ", "Xie ", "Tiao ", "Xun ", "Xu ", "Xu ", "Xu ", "Gan ", "Han ", "Tai ", "Di ", "Xu ", "Chan ", "Shi ", "Kuang ", "Yang ", "Shi ", "Wang ", "Min ", "Min ", "Tun ", "Chun ", "Wu "];
  }
});

// node_modules/unidecode/data/x66.js
var require_x66 = __commonJS({
  "node_modules/unidecode/data/x66.js"(exports2, module2) {
    module2.exports = ["Yun ", "Bei ", "Ang ", "Ze ", "Ban ", "Jie ", "Kun ", "Sheng ", "Hu ", "Fang ", "Hao ", "Gui ", "Chang ", "Xuan ", "Ming ", "Hun ", "Fen ", "Qin ", "Hu ", "Yi ", "Xi ", "Xin ", "Yan ", "Ze ", "Fang ", "Tan ", "Shen ", "Ju ", "Yang ", "Zan ", "Bing ", "Xing ", "Ying ", "Xuan ", "Pei ", "Zhen ", "Ling ", "Chun ", "Hao ", "Mei ", "Zuo ", "Mo ", "Bian ", "Xu ", "Hun ", "Zhao ", "Zong ", "Shi ", "Shi ", "Yu ", "Fei ", "Die ", "Mao ", "Ni ", "Chang ", "Wen ", "Dong ", "Ai ", "Bing ", "Ang ", "Zhou ", "Long ", "Xian ", "Kuang ", "Tiao ", "Chao ", "Shi ", "Huang ", "Huang ", "Xuan ", "Kui ", "Xu ", "Jiao ", "Jin ", "Zhi ", "Jin ", "Shang ", "Tong ", "Hong ", "Yan ", "Gai ", "Xiang ", "Shai ", "Xiao ", "Ye ", "Yun ", "Hui ", "Han ", "Han ", "Jun ", "Wan ", "Xian ", "Kun ", "Zhou ", "Xi ", "Cheng ", "Sheng ", "Bu ", "Zhe ", "Zhe ", "Wu ", "Han ", "Hui ", "Hao ", "Chen ", "Wan ", "Tian ", "Zhuo ", "Zui ", "Zhou ", "Pu ", "Jing ", "Xi ", "Shan ", "Yi ", "Xi ", "Qing ", "Qi ", "Jing ", "Gui ", "Zhen ", "Yi ", "Zhi ", "An ", "Wan ", "Lin ", "Liang ", "Chang ", "Wang ", "Xiao ", "Zan ", "Hi ", "Xuan ", "Xuan ", "Yi ", "Xia ", "Yun ", "Hui ", "Fu ", "Min ", "Kui ", "He ", "Ying ", "Du ", "Wei ", "Shu ", "Qing ", "Mao ", "Nan ", "Jian ", "Nuan ", "An ", "Yang ", "Chun ", "Yao ", "Suo ", "Jin ", "Ming ", "Jiao ", "Kai ", "Gao ", "Weng ", "Chang ", "Qi ", "Hao ", "Yan ", "Li ", "Ai ", "Ji ", "Gui ", "Men ", "Zan ", "Xie ", "Hao ", "Mu ", "Mo ", "Cong ", "Ni ", "Zhang ", "Hui ", "Bao ", "Han ", "Xuan ", "Chuan ", "Liao ", "Xian ", "Dan ", "Jing ", "Pie ", "Lin ", "Tun ", "Xi ", "Yi ", "Ji ", "Huang ", "Tai ", "Ye ", "Ye ", "Li ", "Tan ", "Tong ", "Xiao ", "Fei ", "Qin ", "Zhao ", "Hao ", "Yi ", "Xiang ", "Xing ", "Sen ", "Jiao ", "Bao ", "Jing ", "Yian ", "Ai ", "Ye ", "Ru ", "Shu ", "Meng ", "Xun ", "Yao ", "Pu ", "Li ", "Chen ", "Kuang ", "Die ", "[?] ", "Yan ", "Huo ", "Lu ", "Xi ", "Rong ", "Long ", "Nang ", "Luo ", "Luan ", "Shai ", "Tang ", "Yan ", "Chu ", "Yue ", "Yue ", "Qu ", "Yi ", "Geng ", "Ye ", "Hu ", "He ", "Shu ", "Cao ", "Cao ", "Noboru ", "Man ", "Ceng ", "Ceng ", "Ti "];
  }
});

// node_modules/unidecode/data/x67.js
var require_x67 = __commonJS({
  "node_modules/unidecode/data/x67.js"(exports2, module2) {
    module2.exports = ["Zui ", "Can ", "Xu ", "Hui ", "Yin ", "Qie ", "Fen ", "Pi ", "Yue ", "You ", "Ruan ", "Peng ", "Ban ", "Fu ", "Ling ", "Fei ", "Qu ", "[?] ", "Nu ", "Tiao ", "Shuo ", "Zhen ", "Lang ", "Lang ", "Juan ", "Ming ", "Huang ", "Wang ", "Tun ", "Zhao ", "Ji ", "Qi ", "Ying ", "Zong ", "Wang ", "Tong ", "Lang ", "[?] ", "Meng ", "Long ", "Mu ", "Deng ", "Wei ", "Mo ", "Ben ", "Zha ", "Zhu ", "Zhu ", "[?] ", "Zhu ", "Ren ", "Ba ", "Po ", "Duo ", "Duo ", "Dao ", "Li ", "Qiu ", "Ji ", "Jiu ", "Bi ", "Xiu ", "Ting ", "Ci ", "Sha ", "Eburi ", "Za ", "Quan ", "Qian ", "Yu ", "Gan ", "Wu ", "Cha ", "Shan ", "Xun ", "Fan ", "Wu ", "Zi ", "Li ", "Xing ", "Cai ", "Cun ", "Ren ", "Shao ", "Tuo ", "Di ", "Zhang ", "Mang ", "Chi ", "Yi ", "Gu ", "Gong ", "Du ", "Yi ", "Qi ", "Shu ", "Gang ", "Tiao ", "Moku ", "Soma ", "Tochi ", "Lai ", "Sugi ", "Mang ", "Yang ", "Ma ", "Miao ", "Si ", "Yuan ", "Hang ", "Fei ", "Bei ", "Jie ", "Dong ", "Gao ", "Yao ", "Xian ", "Chu ", "Qun ", "Pa ", "Shu ", "Hua ", "Xin ", "Chou ", "Zhu ", "Chou ", "Song ", "Ban ", "Song ", "Ji ", "Yue ", "Jin ", "Gou ", "Ji ", "Mao ", "Pi ", "Bi ", "Wang ", "Ang ", "Fang ", "Fen ", "Yi ", "Fu ", "Nan ", "Xi ", "Hu ", "Ya ", "Dou ", "Xun ", "Zhen ", "Yao ", "Lin ", "Rui ", "E ", "Mei ", "Zhao ", "Guo ", "Zhi ", "Cong ", "Yun ", "Waku ", "Dou ", "Shu ", "Zao ", "[?] ", "Li ", "Haze ", "Jian ", "Cheng ", "Matsu ", "Qiang ", "Feng ", "Nan ", "Xiao ", "Xian ", "Ku ", "Ping ", "Yi ", "Xi ", "Zhi ", "Guai ", "Xiao ", "Jia ", "Jia ", "Gou ", "Fu ", "Mo ", "Yi ", "Ye ", "Ye ", "Shi ", "Nie ", "Bi ", "Duo ", "Yi ", "Ling ", "Bing ", "Ni ", "La ", "He ", "Pan ", "Fan ", "Zhong ", "Dai ", "Ci ", "Yang ", "Fu ", "Bo ", "Mou ", "Gan ", "Qi ", "Ran ", "Rou ", "Mao ", "Zhao ", "Song ", "Zhe ", "Xia ", "You ", "Shen ", "Ju ", "Tuo ", "Zuo ", "Nan ", "Ning ", "Yong ", "Di ", "Zhi ", "Zha ", "Cha ", "Dan ", "Gu ", "Pu ", "Jiu ", "Ao ", "Fu ", "Jian ", "Bo ", "Duo ", "Ke ", "Nai ", "Zhu ", "Bi ", "Liu ", "Chai ", "Zha ", "Si ", "Zhu ", "Pei ", "Shi ", "Guai ", "Cha ", "Yao ", "Jue ", "Jiu ", "Shi "];
  }
});

// node_modules/unidecode/data/x68.js
var require_x68 = __commonJS({
  "node_modules/unidecode/data/x68.js"(exports2, module2) {
    module2.exports = ["Zhi ", "Liu ", "Mei ", "Hoy ", "Rong ", "Zha ", "[?] ", "Biao ", "Zhan ", "Jie ", "Long ", "Dong ", "Lu ", "Sayng ", "Li ", "Lan ", "Yong ", "Shu ", "Xun ", "Shuan ", "Qi ", "Zhen ", "Qi ", "Li ", "Yi ", "Xiang ", "Zhen ", "Li ", "Su ", "Gua ", "Kan ", "Bing ", "Ren ", "Xiao ", "Bo ", "Ren ", "Bing ", "Zi ", "Chou ", "Yi ", "Jie ", "Xu ", "Zhu ", "Jian ", "Zui ", "Er ", "Er ", "You ", "Fa ", "Gong ", "Kao ", "Lao ", "Zhan ", "Li ", "Yin ", "Yang ", "He ", "Gen ", "Zhi ", "Chi ", "Ge ", "Zai ", "Luan ", "Fu ", "Jie ", "Hang ", "Gui ", "Tao ", "Guang ", "Wei ", "Kuang ", "Ru ", "An ", "An ", "Juan ", "Yi ", "Zhuo ", "Ku ", "Zhi ", "Qiong ", "Tong ", "Sang ", "Sang ", "Huan ", "Jie ", "Jiu ", "Xue ", "Duo ", "Zhui ", "Yu ", "Zan ", "Kasei ", "Ying ", "Masu ", "[?] ", "Zhan ", "Ya ", "Nao ", "Zhen ", "Dang ", "Qi ", "Qiao ", "Hua ", "Kuai ", "Jiang ", "Zhuang ", "Xun ", "Suo ", "Sha ", "Zhen ", "Bei ", "Ting ", "Gua ", "Jing ", "Bo ", "Ben ", "Fu ", "Rui ", "Tong ", "Jue ", "Xi ", "Lang ", "Liu ", "Feng ", "Qi ", "Wen ", "Jun ", "Gan ", "Cu ", "Liang ", "Qiu ", "Ting ", "You ", "Mei ", "Bang ", "Long ", "Peng ", "Zhuang ", "Di ", "Xuan ", "Tu ", "Zao ", "Ao ", "Gu ", "Bi ", "Di ", "Han ", "Zi ", "Zhi ", "Ren ", "Bei ", "Geng ", "Jian ", "Huan ", "Wan ", "Nuo ", "Jia ", "Tiao ", "Ji ", "Xiao ", "Lu ", "Huan ", "Shao ", "Cen ", "Fen ", "Song ", "Meng ", "Wu ", "Li ", "Li ", "Dou ", "Cen ", "Ying ", "Suo ", "Ju ", "Ti ", "Jie ", "Kun ", "Zhuo ", "Shu ", "Chan ", "Fan ", "Wei ", "Jing ", "Li ", "Bing ", "Fumoto ", "Shikimi ", "Tao ", "Zhi ", "Lai ", "Lian ", "Jian ", "Zhuo ", "Ling ", "Li ", "Qi ", "Bing ", "Zhun ", "Cong ", "Qian ", "Mian ", "Qi ", "Qi ", "Cai ", "Gun ", "Chan ", "Te ", "Fei ", "Pai ", "Bang ", "Pou ", "Hun ", "Zong ", "Cheng ", "Zao ", "Ji ", "Li ", "Peng ", "Yu ", "Yu ", "Gu ", "Hun ", "Dong ", "Tang ", "Gang ", "Wang ", "Di ", "Xi ", "Fan ", "Cheng ", "Zhan ", "Qi ", "Yuan ", "Yan ", "Yu ", "Quan ", "Yi ", "Sen ", "Ren ", "Chui ", "Leng ", "Qi ", "Zhuo ", "Fu ", "Ke ", "Lai ", "Zou ", "Zou ", "Zhuo ", "Guan ", "Fen ", "Fen ", "Chen ", "Qiong ", "Nie "];
  }
});

// node_modules/unidecode/data/x69.js
var require_x69 = __commonJS({
  "node_modules/unidecode/data/x69.js"(exports2, module2) {
    module2.exports = ["Wan ", "Guo ", "Lu ", "Hao ", "Jie ", "Yi ", "Chou ", "Ju ", "Ju ", "Cheng ", "Zuo ", "Liang ", "Qiang ", "Zhi ", "Zhui ", "Ya ", "Ju ", "Bei ", "Jiao ", "Zhuo ", "Zi ", "Bin ", "Peng ", "Ding ", "Chu ", "Chang ", "Kunugi ", "Momiji ", "Jian ", "Gui ", "Xi ", "Du ", "Qian ", "Kunugi ", "Soko ", "Shide ", "Luo ", "Zhi ", "Ken ", "Myeng ", "Tafu ", "[?] ", "Peng ", "Zhan ", "[?] ", "Tuo ", "Sen ", "Duo ", "Ye ", "Fou ", "Wei ", "Wei ", "Duan ", "Jia ", "Zong ", "Jian ", "Yi ", "Shen ", "Xi ", "Yan ", "Yan ", "Chuan ", "Zhan ", "Chun ", "Yu ", "He ", "Zha ", "Wo ", "Pian ", "Bi ", "Yao ", "Huo ", "Xu ", "Ruo ", "Yang ", "La ", "Yan ", "Ben ", "Hun ", "Kui ", "Jie ", "Kui ", "Si ", "Feng ", "Xie ", "Tuo ", "Zhi ", "Jian ", "Mu ", "Mao ", "Chu ", "Hu ", "Hu ", "Lian ", "Leng ", "Ting ", "Nan ", "Yu ", "You ", "Mei ", "Song ", "Xuan ", "Xuan ", "Ying ", "Zhen ", "Pian ", "Ye ", "Ji ", "Jie ", "Ye ", "Chu ", "Shun ", "Yu ", "Cou ", "Wei ", "Mei ", "Di ", "Ji ", "Jie ", "Kai ", "Qiu ", "Ying ", "Rou ", "Heng ", "Lou ", "Le ", "Hazou ", "Katsura ", "Pin ", "Muro ", "Gai ", "Tan ", "Lan ", "Yun ", "Yu ", "Chen ", "Lu ", "Ju ", "Sakaki ", "[?] ", "Pi ", "Xie ", "Jia ", "Yi ", "Zhan ", "Fu ", "Nai ", "Mi ", "Lang ", "Rong ", "Gu ", "Jian ", "Ju ", "Ta ", "Yao ", "Zhen ", "Bang ", "Sha ", "Yuan ", "Zi ", "Ming ", "Su ", "Jia ", "Yao ", "Jie ", "Huang ", "Gan ", "Fei ", "Zha ", "Qian ", "Ma ", "Sun ", "Yuan ", "Xie ", "Rong ", "Shi ", "Zhi ", "Cui ", "Yun ", "Ting ", "Liu ", "Rong ", "Tang ", "Que ", "Zhai ", "Si ", "Sheng ", "Ta ", "Ke ", "Xi ", "Gu ", "Qi ", "Kao ", "Gao ", "Sun ", "Pan ", "Tao ", "Ge ", "Xun ", "Dian ", "Nou ", "Ji ", "Shuo ", "Gou ", "Chui ", "Qiang ", "Cha ", "Qian ", "Huai ", "Mei ", "Xu ", "Gang ", "Gao ", "Zhuo ", "Tuo ", "Hashi ", "Yang ", "Dian ", "Jia ", "Jian ", "Zui ", "Kashi ", "Ori ", "Bin ", "Zhu ", "[?] ", "Xi ", "Qi ", "Lian ", "Hui ", "Yong ", "Qian ", "Guo ", "Gai ", "Gai ", "Tuan ", "Hua ", "Cu ", "Sen ", "Cui ", "Beng ", "You ", "Hu ", "Jiang ", "Hu ", "Huan ", "Kui ", "Yi ", "Nie ", "Gao ", "Kang ", "Gui ", "Gui ", "Cao ", "Man ", "Jin "];
  }
});

// node_modules/unidecode/data/x6a.js
var require_x6a = __commonJS({
  "node_modules/unidecode/data/x6a.js"(exports2, module2) {
    module2.exports = ["Di ", "Zhuang ", "Le ", "Lang ", "Chen ", "Cong ", "Li ", "Xiu ", "Qing ", "Shuang ", "Fan ", "Tong ", "Guan ", "Ji ", "Suo ", "Lei ", "Lu ", "Liang ", "Mi ", "Lou ", "Chao ", "Su ", "Ke ", "Shu ", "Tang ", "Biao ", "Lu ", "Jiu ", "Shu ", "Zha ", "Shu ", "Zhang ", "Men ", "Mo ", "Niao ", "Yang ", "Tiao ", "Peng ", "Zhu ", "Sha ", "Xi ", "Quan ", "Heng ", "Jian ", "Cong ", "[?] ", "Hokuso ", "Qiang ", "Tara ", "Ying ", "Er ", "Xin ", "Zhi ", "Qiao ", "Zui ", "Cong ", "Pu ", "Shu ", "Hua ", "Kui ", "Zhen ", "Zun ", "Yue ", "Zhan ", "Xi ", "Xun ", "Dian ", "Fa ", "Gan ", "Mo ", "Wu ", "Qiao ", "Nao ", "Lin ", "Liu ", "Qiao ", "Xian ", "Run ", "Fan ", "Zhan ", "Tuo ", "Lao ", "Yun ", "Shun ", "Tui ", "Cheng ", "Tang ", "Meng ", "Ju ", "Cheng ", "Su ", "Jue ", "Jue ", "Tan ", "Hui ", "Ji ", "Nuo ", "Xiang ", "Tuo ", "Ning ", "Rui ", "Zhu ", "Chuang ", "Zeng ", "Fen ", "Qiong ", "Ran ", "Heng ", "Cen ", "Gu ", "Liu ", "Lao ", "Gao ", "Chu ", "Zusa ", "Nude ", "Ca ", "San ", "Ji ", "Dou ", "Shou ", "Lu ", "[?] ", "[?] ", "Yuan ", "Ta ", "Shu ", "Jiang ", "Tan ", "Lin ", "Nong ", "Yin ", "Xi ", "Sui ", "Shan ", "Zui ", "Xuan ", "Cheng ", "Gan ", "Ju ", "Zui ", "Yi ", "Qin ", "Pu ", "Yan ", "Lei ", "Feng ", "Hui ", "Dang ", "Ji ", "Sui ", "Bo ", "Bi ", "Ding ", "Chu ", "Zhua ", "Kuai ", "Ji ", "Jie ", "Jia ", "Qing ", "Zhe ", "Jian ", "Qiang ", "Dao ", "Yi ", "Biao ", "Song ", "She ", "Lin ", "Kunugi ", "Cha ", "Meng ", "Yin ", "Tao ", "Tai ", "Mian ", "Qi ", "Toan ", "Bin ", "Huo ", "Ji ", "Qian ", "Mi ", "Ning ", "Yi ", "Gao ", "Jian ", "Yin ", "Er ", "Qing ", "Yan ", "Qi ", "Mi ", "Zhao ", "Gui ", "Chun ", "Ji ", "Kui ", "Po ", "Deng ", "Chu ", "[?] ", "Mian ", "You ", "Zhi ", "Guang ", "Qian ", "Lei ", "Lei ", "Sa ", "Lu ", "Li ", "Cuan ", "Lu ", "Mie ", "Hui ", "Ou ", "Lu ", "Jie ", "Gao ", "Du ", "Yuan ", "Li ", "Fei ", "Zhuo ", "Sou ", "Lian ", "Tamo ", "Chu ", "[?] ", "Zhu ", "Lu ", "Yan ", "Li ", "Zhu ", "Chen ", "Jie ", "E ", "Su ", "Huai ", "Nie ", "Yu ", "Long ", "Lai ", "[?] ", "Xian ", "Kwi ", "Ju ", "Xiao ", "Ling ", "Ying ", "Jian ", "Yin ", "You ", "Ying "];
  }
});

// node_modules/unidecode/data/x6b.js
var require_x6b = __commonJS({
  "node_modules/unidecode/data/x6b.js"(exports2, module2) {
    module2.exports = ["Xiang ", "Nong ", "Bo ", "Chan ", "Lan ", "Ju ", "Shuang ", "She ", "Wei ", "Cong ", "Quan ", "Qu ", "Cang ", "[?] ", "Yu ", "Luo ", "Li ", "Zan ", "Luan ", "Dang ", "Jue ", "Em ", "Lan ", "Lan ", "Zhu ", "Lei ", "Li ", "Ba ", "Nang ", "Yu ", "Ling ", "Tsuki ", "Qian ", "Ci ", "Huan ", "Xin ", "Yu ", "Yu ", "Qian ", "Ou ", "Xu ", "Chao ", "Chu ", "Chi ", "Kai ", "Yi ", "Jue ", "Xi ", "Xu ", "Xia ", "Yu ", "Kuai ", "Lang ", "Kuan ", "Shuo ", "Xi ", "Ai ", "Yi ", "Qi ", "Hu ", "Chi ", "Qin ", "Kuan ", "Kan ", "Kuan ", "Kan ", "Chuan ", "Sha ", "Gua ", "Yin ", "Xin ", "Xie ", "Yu ", "Qian ", "Xiao ", "Yi ", "Ge ", "Wu ", "Tan ", "Jin ", "Ou ", "Hu ", "Ti ", "Huan ", "Xu ", "Pen ", "Xi ", "Xiao ", "Xu ", "Xi ", "Sen ", "Lian ", "Chu ", "Yi ", "Kan ", "Yu ", "Chuo ", "Huan ", "Zhi ", "Zheng ", "Ci ", "Bu ", "Wu ", "Qi ", "Bu ", "Bu ", "Wai ", "Ju ", "Qian ", "Chi ", "Se ", "Chi ", "Se ", "Zhong ", "Sui ", "Sui ", "Li ", "Cuo ", "Yu ", "Li ", "Gui ", "Dai ", "Dai ", "Si ", "Jian ", "Zhe ", "Mo ", "Mo ", "Yao ", "Mo ", "Cu ", "Yang ", "Tian ", "Sheng ", "Dai ", "Shang ", "Xu ", "Xun ", "Shu ", "Can ", "Jue ", "Piao ", "Qia ", "Qiu ", "Su ", "Qing ", "Yun ", "Lian ", "Yi ", "Fou ", "Zhi ", "Ye ", "Can ", "Hun ", "Dan ", "Ji ", "Ye ", "Zhen ", "Yun ", "Wen ", "Chou ", "Bin ", "Ti ", "Jin ", "Shang ", "Yin ", "Diao ", "Cu ", "Hui ", "Cuan ", "Yi ", "Dan ", "Du ", "Jiang ", "Lian ", "Bin ", "Du ", "Tsukusu ", "Jian ", "Shu ", "Ou ", "Duan ", "Zhu ", "Yin ", "Qing ", "Yi ", "Sha ", "Que ", "Ke ", "Yao ", "Jun ", "Dian ", "Hui ", "Hui ", "Gu ", "Que ", "Ji ", "Yi ", "Ou ", "Hui ", "Duan ", "Yi ", "Xiao ", "Wu ", "Guan ", "Mu ", "Mei ", "Mei ", "Ai ", "Zuo ", "Du ", "Yu ", "Bi ", "Bi ", "Bi ", "Pi ", "Pi ", "Bi ", "Chan ", "Mao ", "[?] ", "[?] ", "Pu ", "Mushiru ", "Jia ", "Zhan ", "Sai ", "Mu ", "Tuo ", "Xun ", "Er ", "Rong ", "Xian ", "Ju ", "Mu ", "Hao ", "Qiu ", "Dou ", "Mushiru ", "Tan ", "Pei ", "Ju ", "Duo ", "Cui ", "Bi ", "San ", "[?] ", "Mao ", "Sui ", "Yu ", "Yu ", "Tuo ", "He ", "Jian ", "Ta ", "San "];
  }
});

// node_modules/unidecode/data/x6c.js
var require_x6c = __commonJS({
  "node_modules/unidecode/data/x6c.js"(exports2, module2) {
    module2.exports = ["Lu ", "Mu ", "Li ", "Tong ", "Rong ", "Chang ", "Pu ", "Luo ", "Zhan ", "Sao ", "Zhan ", "Meng ", "Luo ", "Qu ", "Die ", "Shi ", "Di ", "Min ", "Jue ", "Mang ", "Qi ", "Pie ", "Nai ", "Qi ", "Dao ", "Xian ", "Chuan ", "Fen ", "Ri ", "Nei ", "[?] ", "Fu ", "Shen ", "Dong ", "Qing ", "Qi ", "Yin ", "Xi ", "Hai ", "Yang ", "An ", "Ya ", "Ke ", "Qing ", "Ya ", "Dong ", "Dan ", "Lu ", "Qing ", "Yang ", "Yun ", "Yun ", "Shui ", "San ", "Zheng ", "Bing ", "Yong ", "Dang ", "Shitamizu ", "Le ", "Ni ", "Tun ", "Fan ", "Gui ", "Ting ", "Zhi ", "Qiu ", "Bin ", "Ze ", "Mian ", "Cuan ", "Hui ", "Diao ", "Yi ", "Cha ", "Zhuo ", "Chuan ", "Wan ", "Fan ", "Dai ", "Xi ", "Tuo ", "Mang ", "Qiu ", "Qi ", "Shan ", "Pai ", "Han ", "Qian ", "Wu ", "Wu ", "Xun ", "Si ", "Ru ", "Gong ", "Jiang ", "Chi ", "Wu ", "Tsuchi ", "[?] ", "Tang ", "Zhi ", "Chi ", "Qian ", "Mi ", "Yu ", "Wang ", "Qing ", "Jing ", "Rui ", "Jun ", "Hong ", "Tai ", "Quan ", "Ji ", "Bian ", "Bian ", "Gan ", "Wen ", "Zhong ", "Fang ", "Xiong ", "Jue ", "Hang ", "Niou ", "Qi ", "Fen ", "Xu ", "Xu ", "Qin ", "Yi ", "Wo ", "Yun ", "Yuan ", "Hang ", "Yan ", "Chen ", "Chen ", "Dan ", "You ", "Dun ", "Hu ", "Huo ", "Qie ", "Mu ", "Rou ", "Mei ", "Ta ", "Mian ", "Wu ", "Chong ", "Tian ", "Bi ", "Sha ", "Zhi ", "Pei ", "Pan ", "Zhui ", "Za ", "Gou ", "Liu ", "Mei ", "Ze ", "Feng ", "Ou ", "Li ", "Lun ", "Cang ", "Feng ", "Wei ", "Hu ", "Mo ", "Mei ", "Shu ", "Ju ", "Zan ", "Tuo ", "Tuo ", "Tuo ", "He ", "Li ", "Mi ", "Yi ", "Fa ", "Fei ", "You ", "Tian ", "Zhi ", "Zhao ", "Gu ", "Zhan ", "Yan ", "Si ", "Kuang ", "Jiong ", "Ju ", "Xie ", "Qiu ", "Yi ", "Jia ", "Zhong ", "Quan ", "Bo ", "Hui ", "Mi ", "Ben ", "Zhuo ", "Chu ", "Le ", "You ", "Gu ", "Hong ", "Gan ", "Fa ", "Mao ", "Si ", "Hu ", "Ping ", "Ci ", "Fan ", "Chi ", "Su ", "Ning ", "Cheng ", "Ling ", "Pao ", "Bo ", "Qi ", "Si ", "Ni ", "Ju ", "Yue ", "Zhu ", "Sheng ", "Lei ", "Xuan ", "Xue ", "Fu ", "Pan ", "Min ", "Tai ", "Yang ", "Ji ", "Yong ", "Guan ", "Beng ", "Xue ", "Long ", "Lu ", "[?] ", "Bo ", "Xie ", "Po ", "Ze ", "Jing ", "Yin "];
  }
});

// node_modules/unidecode/data/x6d.js
var require_x6d = __commonJS({
  "node_modules/unidecode/data/x6d.js"(exports2, module2) {
    module2.exports = ["Zhou ", "Ji ", "Yi ", "Hui ", "Hui ", "Zui ", "Cheng ", "Yin ", "Wei ", "Hou ", "Jian ", "Yang ", "Lie ", "Si ", "Ji ", "Er ", "Xing ", "Fu ", "Sa ", "Suo ", "Zhi ", "Yin ", "Wu ", "Xi ", "Kao ", "Zhu ", "Jiang ", "Luo ", "[?] ", "An ", "Dong ", "Yi ", "Mou ", "Lei ", "Yi ", "Mi ", "Quan ", "Jin ", "Mo ", "Wei ", "Xiao ", "Xie ", "Hong ", "Xu ", "Shuo ", "Kuang ", "Tao ", "Qie ", "Ju ", "Er ", "Zhou ", "Ru ", "Ping ", "Xun ", "Xiong ", "Zhi ", "Guang ", "Huan ", "Ming ", "Huo ", "Wa ", "Qia ", "Pai ", "Wu ", "Qu ", "Liu ", "Yi ", "Jia ", "Jing ", "Qian ", "Jiang ", "Jiao ", "Cheng ", "Shi ", "Zhuo ", "Ce ", "Pal ", "Kuai ", "Ji ", "Liu ", "Chan ", "Hun ", "Hu ", "Nong ", "Xun ", "Jin ", "Lie ", "Qiu ", "Wei ", "Zhe ", "Jun ", "Han ", "Bang ", "Mang ", "Zhuo ", "You ", "Xi ", "Bo ", "Dou ", "Wan ", "Hong ", "Yi ", "Pu ", "Ying ", "Lan ", "Hao ", "Lang ", "Han ", "Li ", "Geng ", "Fu ", "Wu ", "Lian ", "Chun ", "Feng ", "Yi ", "Yu ", "Tong ", "Lao ", "Hai ", "Jin ", "Jia ", "Chong ", "Weng ", "Mei ", "Sui ", "Cheng ", "Pei ", "Xian ", "Shen ", "Tu ", "Kun ", "Pin ", "Nie ", "Han ", "Jing ", "Xiao ", "She ", "Nian ", "Tu ", "Yong ", "Xiao ", "Xian ", "Ting ", "E ", "Su ", "Tun ", "Juan ", "Cen ", "Ti ", "Li ", "Shui ", "Si ", "Lei ", "Shui ", "Tao ", "Du ", "Lao ", "Lai ", "Lian ", "Wei ", "Wo ", "Yun ", "Huan ", "Di ", "[?] ", "Run ", "Jian ", "Zhang ", "Se ", "Fu ", "Guan ", "Xing ", "Shou ", "Shuan ", "Ya ", "Chuo ", "Zhang ", "Ye ", "Kong ", "Wo ", "Han ", "Tuo ", "Dong ", "He ", "Wo ", "Ju ", "Gan ", "Liang ", "Hun ", "Ta ", "Zhuo ", "Dian ", "Qie ", "De ", "Juan ", "Zi ", "Xi ", "Yao ", "Qi ", "Gu ", "Guo ", "Han ", "Lin ", "Tang ", "Zhou ", "Peng ", "Hao ", "Chang ", "Shu ", "Qi ", "Fang ", "Chi ", "Lu ", "Nao ", "Ju ", "Tao ", "Cong ", "Lei ", "Zhi ", "Peng ", "Fei ", "Song ", "Tian ", "Pi ", "Dan ", "Yu ", "Ni ", "Yu ", "Lu ", "Gan ", "Mi ", "Jing ", "Ling ", "Lun ", "Yin ", "Cui ", "Qu ", "Huai ", "Yu ", "Nian ", "Shen ", "Piao ", "Chun ", "Wa ", "Yuan ", "Lai ", "Hun ", "Qing ", "Yan ", "Qian ", "Tian ", "Miao ", "Zhi ", "Yin ", "Mi "];
  }
});

// node_modules/unidecode/data/x6e.js
var require_x6e = __commonJS({
  "node_modules/unidecode/data/x6e.js"(exports2, module2) {
    module2.exports = ["Ben ", "Yuan ", "Wen ", "Re ", "Fei ", "Qing ", "Yuan ", "Ke ", "Ji ", "She ", "Yuan ", "Shibui ", "Lu ", "Zi ", "Du ", "[?] ", "Jian ", "Min ", "Pi ", "Tani ", "Yu ", "Yuan ", "Shen ", "Shen ", "Rou ", "Huan ", "Zhu ", "Jian ", "Nuan ", "Yu ", "Qiu ", "Ting ", "Qu ", "Du ", "Feng ", "Zha ", "Bo ", "Wo ", "Wo ", "Di ", "Wei ", "Wen ", "Ru ", "Xie ", "Ce ", "Wei ", "Ge ", "Gang ", "Yan ", "Hong ", "Xuan ", "Mi ", "Ke ", "Mao ", "Ying ", "Yan ", "You ", "Hong ", "Miao ", "Xing ", "Mei ", "Zai ", "Hun ", "Nai ", "Kui ", "Shi ", "E ", "Pai ", "Mei ", "Lian ", "Qi ", "Qi ", "Mei ", "Tian ", "Cou ", "Wei ", "Can ", "Tuan ", "Mian ", "Hui ", "Mo ", "Xu ", "Ji ", "Pen ", "Jian ", "Jian ", "Hu ", "Feng ", "Xiang ", "Yi ", "Yin ", "Zhan ", "Shi ", "Jie ", "Cheng ", "Huang ", "Tan ", "Yu ", "Bi ", "Min ", "Shi ", "Tu ", "Sheng ", "Yong ", "Qu ", "Zhong ", "Suei ", "Jiu ", "Jiao ", "Qiou ", "Yin ", "Tang ", "Long ", "Huo ", "Yuan ", "Nan ", "Ban ", "You ", "Quan ", "Chui ", "Liang ", "Chan ", "Yan ", "Chun ", "Nie ", "Zi ", "Wan ", "Shi ", "Man ", "Ying ", "Ratsu ", "Kui ", "[?] ", "Jian ", "Xu ", "Lu ", "Gui ", "Gai ", "[?] ", "[?] ", "Po ", "Jin ", "Gui ", "Tang ", "Yuan ", "Suo ", "Yuan ", "Lian ", "Yao ", "Meng ", "Zhun ", "Sheng ", "Ke ", "Tai ", "Da ", "Wa ", "Liu ", "Gou ", "Sao ", "Ming ", "Zha ", "Shi ", "Yi ", "Lun ", "Ma ", "Pu ", "Wei ", "Li ", "Cai ", "Wu ", "Xi ", "Wen ", "Qiang ", "Ze ", "Shi ", "Su ", "Yi ", "Zhen ", "Sou ", "Yun ", "Xiu ", "Yin ", "Rong ", "Hun ", "Su ", "Su ", "Ni ", "Ta ", "Shi ", "Ru ", "Wei ", "Pan ", "Chu ", "Chu ", "Pang ", "Weng ", "Cang ", "Mie ", "He ", "Dian ", "Hao ", "Huang ", "Xi ", "Zi ", "Di ", "Zhi ", "Ying ", "Fu ", "Jie ", "Hua ", "Ge ", "Zi ", "Tao ", "Teng ", "Sui ", "Bi ", "Jiao ", "Hui ", "Gun ", "Yin ", "Gao ", "Long ", "Zhi ", "Yan ", "She ", "Man ", "Ying ", "Chun ", "Lu ", "Lan ", "Luan ", "[?] ", "Bin ", "Tan ", "Yu ", "Sou ", "Hu ", "Bi ", "Biao ", "Zhi ", "Jiang ", "Kou ", "Shen ", "Shang ", "Di ", "Mi ", "Ao ", "Lu ", "Hu ", "Hu ", "You ", "Chan ", "Fan ", "Yong ", "Gun ", "Man "];
  }
});

// node_modules/unidecode/data/x6f.js
var require_x6f = __commonJS({
  "node_modules/unidecode/data/x6f.js"(exports2, module2) {
    module2.exports = ["Qing ", "Yu ", "Piao ", "Ji ", "Ya ", "Jiao ", "Qi ", "Xi ", "Ji ", "Lu ", "Lu ", "Long ", "Jin ", "Guo ", "Cong ", "Lou ", "Zhi ", "Gai ", "Qiang ", "Li ", "Yan ", "Cao ", "Jiao ", "Cong ", "Qun ", "Tuan ", "Ou ", "Teng ", "Ye ", "Xi ", "Mi ", "Tang ", "Mo ", "Shang ", "Han ", "Lian ", "Lan ", "Wa ", "Li ", "Qian ", "Feng ", "Xuan ", "Yi ", "Man ", "Zi ", "Mang ", "Kang ", "Lei ", "Peng ", "Shu ", "Zhang ", "Zhang ", "Chong ", "Xu ", "Huan ", "Kuo ", "Jian ", "Yan ", "Chuang ", "Liao ", "Cui ", "Ti ", "Yang ", "Jiang ", "Cong ", "Ying ", "Hong ", "Xun ", "Shu ", "Guan ", "Ying ", "Xiao ", "[?] ", "[?] ", "Xu ", "Lian ", "Zhi ", "Wei ", "Pi ", "Jue ", "Jiao ", "Po ", "Dang ", "Hui ", "Jie ", "Wu ", "Pa ", "Ji ", "Pan ", "Gui ", "Xiao ", "Qian ", "Qian ", "Xi ", "Lu ", "Xi ", "Xuan ", "Dun ", "Huang ", "Min ", "Run ", "Su ", "Liao ", "Zhen ", "Zhong ", "Yi ", "Di ", "Wan ", "Dan ", "Tan ", "Chao ", "Xun ", "Kui ", "Yie ", "Shao ", "Tu ", "Zhu ", "San ", "Hei ", "Bi ", "Shan ", "Chan ", "Chan ", "Shu ", "Tong ", "Pu ", "Lin ", "Wei ", "Se ", "Se ", "Cheng ", "Jiong ", "Cheng ", "Hua ", "Jiao ", "Lao ", "Che ", "Gan ", "Cun ", "Heng ", "Si ", "Shu ", "Peng ", "Han ", "Yun ", "Liu ", "Hong ", "Fu ", "Hao ", "He ", "Xian ", "Jian ", "Shan ", "Xi ", "Oki ", "[?] ", "Lan ", "[?] ", "Yu ", "Lin ", "Min ", "Zao ", "Dang ", "Wan ", "Ze ", "Xie ", "Yu ", "Li ", "Shi ", "Xue ", "Ling ", "Man ", "Zi ", "Yong ", "Kuai ", "Can ", "Lian ", "Dian ", "Ye ", "Ao ", "Huan ", "Zhen ", "Chan ", "Man ", "Dan ", "Dan ", "Yi ", "Sui ", "Pi ", "Ju ", "Ta ", "Qin ", "Ji ", "Zhuo ", "Lian ", "Nong ", "Guo ", "Jin ", "Fen ", "Se ", "Ji ", "Sui ", "Hui ", "Chu ", "Ta ", "Song ", "Ding ", "[?] ", "Zhu ", "Lai ", "Bin ", "Lian ", "Mi ", "Shi ", "Shu ", "Mi ", "Ning ", "Ying ", "Ying ", "Meng ", "Jin ", "Qi ", "Pi ", "Ji ", "Hao ", "Ru ", "Zui ", "Wo ", "Tao ", "Yin ", "Yin ", "Dui ", "Ci ", "Huo ", "Jing ", "Lan ", "Jun ", "Ai ", "Pu ", "Zhuo ", "Wei ", "Bin ", "Gu ", "Qian ", "Xing ", "Hama ", "Kuo ", "Fei ", "[?] ", "Boku ", "Jian ", "Wei ", "Luo ", "Zan ", "Lu ", "Li "];
  }
});

// node_modules/unidecode/data/x70.js
var require_x70 = __commonJS({
  "node_modules/unidecode/data/x70.js"(exports2, module2) {
    module2.exports = ["You ", "Yang ", "Lu ", "Si ", "Jie ", "Ying ", "Du ", "Wang ", "Hui ", "Xie ", "Pan ", "Shen ", "Biao ", "Chan ", "Mo ", "Liu ", "Jian ", "Pu ", "Se ", "Cheng ", "Gu ", "Bin ", "Huo ", "Xian ", "Lu ", "Qin ", "Han ", "Ying ", "Yong ", "Li ", "Jing ", "Xiao ", "Ying ", "Sui ", "Wei ", "Xie ", "Huai ", "Hao ", "Zhu ", "Long ", "Lai ", "Dui ", "Fan ", "Hu ", "Lai ", "[?] ", "[?] ", "Ying ", "Mi ", "Ji ", "Lian ", "Jian ", "Ying ", "Fen ", "Lin ", "Yi ", "Jian ", "Yue ", "Chan ", "Dai ", "Rang ", "Jian ", "Lan ", "Fan ", "Shuang ", "Yuan ", "Zhuo ", "Feng ", "She ", "Lei ", "Lan ", "Cong ", "Qu ", "Yong ", "Qian ", "Fa ", "Guan ", "Que ", "Yan ", "Hao ", "Hyeng ", "Sa ", "Zan ", "Luan ", "Yan ", "Li ", "Mi ", "Shan ", "Tan ", "Dang ", "Jiao ", "Chan ", "[?] ", "Hao ", "Ba ", "Zhu ", "Lan ", "Lan ", "Nang ", "Wan ", "Luan ", "Xun ", "Xian ", "Yan ", "Gan ", "Yan ", "Yu ", "Huo ", "Si ", "Mie ", "Guang ", "Deng ", "Hui ", "Xiao ", "Xiao ", "Hu ", "Hong ", "Ling ", "Zao ", "Zhuan ", "Jiu ", "Zha ", "Xie ", "Chi ", "Zhuo ", "Zai ", "Zai ", "Can ", "Yang ", "Qi ", "Zhong ", "Fen ", "Niu ", "Jiong ", "Wen ", "Po ", "Yi ", "Lu ", "Chui ", "Pi ", "Kai ", "Pan ", "Yan ", "Kai ", "Pang ", "Mu ", "Chao ", "Liao ", "Gui ", "Kang ", "Tun ", "Guang ", "Xin ", "Zhi ", "Guang ", "Guang ", "Wei ", "Qiang ", "[?] ", "Da ", "Xia ", "Zheng ", "Zhu ", "Ke ", "Zhao ", "Fu ", "Ba ", "Duo ", "Duo ", "Ling ", "Zhuo ", "Xuan ", "Ju ", "Tan ", "Pao ", "Jiong ", "Pao ", "Tai ", "Tai ", "Bing ", "Yang ", "Tong ", "Han ", "Zhu ", "Zha ", "Dian ", "Wei ", "Shi ", "Lian ", "Chi ", "Huang ", "[?] ", "Hu ", "Shuo ", "Lan ", "Jing ", "Jiao ", "Xu ", "Xing ", "Quan ", "Lie ", "Huan ", "Yang ", "Xiao ", "Xiu ", "Xian ", "Yin ", "Wu ", "Zhou ", "Yao ", "Shi ", "Wei ", "Tong ", "Xue ", "Zai ", "Kai ", "Hong ", "Luo ", "Xia ", "Zhu ", "Xuan ", "Zheng ", "Po ", "Yan ", "Hui ", "Guang ", "Zhe ", "Hui ", "Kao ", "[?] ", "Fan ", "Shao ", "Ye ", "Hui ", "[?] ", "Tang ", "Jin ", "Re ", "[?] ", "Xi ", "Fu ", "Jiong ", "Che ", "Pu ", "Jing ", "Zhuo ", "Ting ", "Wan ", "Hai ", "Peng ", "Lang ", "Shan ", "Hu ", "Feng ", "Chi ", "Rong "];
  }
});

// node_modules/unidecode/data/x71.js
var require_x71 = __commonJS({
  "node_modules/unidecode/data/x71.js"(exports2, module2) {
    module2.exports = ["Hu ", "Xi ", "Shu ", "He ", "Xun ", "Ku ", "Jue ", "Xiao ", "Xi ", "Yan ", "Han ", "Zhuang ", "Jun ", "Di ", "Xie ", "Ji ", "Wu ", "[?] ", "[?] ", "Han ", "Yan ", "Huan ", "Men ", "Ju ", "Chou ", "Bei ", "Fen ", "Lin ", "Kun ", "Hun ", "Tun ", "Xi ", "Cui ", "Wu ", "Hong ", "Ju ", "Fu ", "Wo ", "Jiao ", "Cong ", "Feng ", "Ping ", "Qiong ", "Ruo ", "Xi ", "Qiong ", "Xin ", "Zhuo ", "Yan ", "Yan ", "Yi ", "Jue ", "Yu ", "Gang ", "Ran ", "Pi ", "Gu ", "[?] ", "Sheng ", "Chang ", "Shao ", "[?] ", "[?] ", "[?] ", "[?] ", "Chen ", "He ", "Kui ", "Zhong ", "Duan ", "Xia ", "Hui ", "Feng ", "Lian ", "Xuan ", "Xing ", "Huang ", "Jiao ", "Jian ", "Bi ", "Ying ", "Zhu ", "Wei ", "Tuan ", "Tian ", "Xi ", "Nuan ", "Nuan ", "Chan ", "Yan ", "Jiong ", "Jiong ", "Yu ", "Mei ", "Sha ", "Wei ", "Ye ", "Xin ", "Qiong ", "Rou ", "Mei ", "Huan ", "Xu ", "Zhao ", "Wei ", "Fan ", "Qiu ", "Sui ", "Yang ", "Lie ", "Zhu ", "Jie ", "Gao ", "Gua ", "Bao ", "Hu ", "Yun ", "Xia ", "[?] ", "[?] ", "Bian ", "Gou ", "Tui ", "Tang ", "Chao ", "Shan ", "N ", "Bo ", "Huang ", "Xie ", "Xi ", "Wu ", "Xi ", "Yun ", "He ", "He ", "Xi ", "Yun ", "Xiong ", "Nai ", "Shan ", "Qiong ", "Yao ", "Xun ", "Mi ", "Lian ", "Ying ", "Wen ", "Rong ", "Oozutsu ", "[?] ", "Qiang ", "Liu ", "Xi ", "Bi ", "Biao ", "Zong ", "Lu ", "Jian ", "Shou ", "Yi ", "Lou ", "Feng ", "Sui ", "Yi ", "Tong ", "Jue ", "Zong ", "Yun ", "Hu ", "Yi ", "Zhi ", "Ao ", "Wei ", "Liao ", "Han ", "Ou ", "Re ", "Jiong ", "Man ", "[?] ", "Shang ", "Cuan ", "Zeng ", "Jian ", "Xi ", "Xi ", "Xi ", "Yi ", "Xiao ", "Chi ", "Huang ", "Chan ", "Ye ", "Qian ", "Ran ", "Yan ", "Xian ", "Qiao ", "Zun ", "Deng ", "Dun ", "Shen ", "Jiao ", "Fen ", "Si ", "Liao ", "Yu ", "Lin ", "Tong ", "Shao ", "Fen ", "Fan ", "Yan ", "Xun ", "Lan ", "Mei ", "Tang ", "Yi ", "Jing ", "Men ", "[?] ", "[?] ", "Ying ", "Yu ", "Yi ", "Xue ", "Lan ", "Tai ", "Zao ", "Can ", "Sui ", "Xi ", "Que ", "Cong ", "Lian ", "Hui ", "Zhu ", "Xie ", "Ling ", "Wei ", "Yi ", "Xie ", "Zhao ", "Hui ", "Tatsu ", "Nung ", "Lan ", "Ru ", "Xian ", "Kao ", "Xun ", "Jin ", "Chou ", "Chou ", "Yao "];
  }
});

// node_modules/unidecode/data/x72.js
var require_x72 = __commonJS({
  "node_modules/unidecode/data/x72.js"(exports2, module2) {
    module2.exports = ["He ", "Lan ", "Biao ", "Rong ", "Li ", "Mo ", "Bao ", "Ruo ", "Lu ", "La ", "Ao ", "Xun ", "Kuang ", "Shuo ", "[?] ", "Li ", "Lu ", "Jue ", "Liao ", "Yan ", "Xi ", "Xie ", "Long ", "Ye ", "[?] ", "Rang ", "Yue ", "Lan ", "Cong ", "Jue ", "Tong ", "Guan ", "[?] ", "Che ", "Mi ", "Tang ", "Lan ", "Zhu ", "[?] ", "Ling ", "Cuan ", "Yu ", "Zhua ", "Tsumekanmuri ", "Pa ", "Zheng ", "Pao ", "Cheng ", "Yuan ", "Ai ", "Wei ", "[?] ", "Jue ", "Jue ", "Fu ", "Ye ", "Ba ", "Die ", "Ye ", "Yao ", "Zu ", "Shuang ", "Er ", "Qiang ", "Chuang ", "Ge ", "Zang ", "Die ", "Qiang ", "Yong ", "Qiang ", "Pian ", "Ban ", "Pan ", "Shao ", "Jian ", "Pai ", "Du ", "Chuang ", "Tou ", "Zha ", "Bian ", "Die ", "Bang ", "Bo ", "Chuang ", "You ", "[?] ", "Du ", "Ya ", "Cheng ", "Niu ", "Ushihen ", "Pin ", "Jiu ", "Mou ", "Tuo ", "Mu ", "Lao ", "Ren ", "Mang ", "Fang ", "Mao ", "Mu ", "Gang ", "Wu ", "Yan ", "Ge ", "Bei ", "Si ", "Jian ", "Gu ", "You ", "Ge ", "Sheng ", "Mu ", "Di ", "Qian ", "Quan ", "Quan ", "Zi ", "Te ", "Xi ", "Mang ", "Keng ", "Qian ", "Wu ", "Gu ", "Xi ", "Li ", "Li ", "Pou ", "Ji ", "Gang ", "Zhi ", "Ben ", "Quan ", "Run ", "Du ", "Ju ", "Jia ", "Jian ", "Feng ", "Pian ", "Ke ", "Ju ", "Kao ", "Chu ", "Xi ", "Bei ", "Luo ", "Jie ", "Ma ", "San ", "Wei ", "Li ", "Dun ", "Tong ", "[?] ", "Jiang ", "Ikenie ", "Li ", "Du ", "Lie ", "Pi ", "Piao ", "Bao ", "Xi ", "Chou ", "Wei ", "Kui ", "Chou ", "Quan ", "Fan ", "Ba ", "Fan ", "Qiu ", "Ji ", "Cai ", "Chuo ", "An ", "Jie ", "Zhuang ", "Guang ", "Ma ", "You ", "Kang ", "Bo ", "Hou ", "Ya ", "Yin ", "Huan ", "Zhuang ", "Yun ", "Kuang ", "Niu ", "Di ", "Qing ", "Zhong ", "Mu ", "Bei ", "Pi ", "Ju ", "Ni ", "Sheng ", "Pao ", "Xia ", "Tuo ", "Hu ", "Ling ", "Fei ", "Pi ", "Ni ", "Ao ", "You ", "Gou ", "Yue ", "Ju ", "Dan ", "Po ", "Gu ", "Xian ", "Ning ", "Huan ", "Hen ", "Jiao ", "He ", "Zhao ", "Ji ", "Xun ", "Shan ", "Ta ", "Rong ", "Shou ", "Tong ", "Lao ", "Du ", "Xia ", "Shi ", "Hua ", "Zheng ", "Yu ", "Sun ", "Yu ", "Bi ", "Mang ", "Xi ", "Juan ", "Li ", "Xia ", "Yin ", "Suan ", "Lang ", "Bei ", "Zhi ", "Yan "];
  }
});

// node_modules/unidecode/data/x73.js
var require_x73 = __commonJS({
  "node_modules/unidecode/data/x73.js"(exports2, module2) {
    module2.exports = ["Sha ", "Li ", "Han ", "Xian ", "Jing ", "Pai ", "Fei ", "Yao ", "Ba ", "Qi ", "Ni ", "Biao ", "Yin ", "Lai ", "Xi ", "Jian ", "Qiang ", "Kun ", "Yan ", "Guo ", "Zong ", "Mi ", "Chang ", "Yi ", "Zhi ", "Zheng ", "Ya ", "Meng ", "Cai ", "Cu ", "She ", "Kari ", "Cen ", "Luo ", "Hu ", "Zong ", "Ji ", "Wei ", "Feng ", "Wo ", "Yuan ", "Xing ", "Zhu ", "Mao ", "Wei ", "Yuan ", "Xian ", "Tuan ", "Ya ", "Nao ", "Xie ", "Jia ", "Hou ", "Bian ", "You ", "You ", "Mei ", "Zha ", "Yao ", "Sun ", "Bo ", "Ming ", "Hua ", "Yuan ", "Sou ", "Ma ", "Yuan ", "Dai ", "Yu ", "Shi ", "Hao ", "[?] ", "Yi ", "Zhen ", "Chuang ", "Hao ", "Man ", "Jing ", "Jiang ", "Mu ", "Zhang ", "Chan ", "Ao ", "Ao ", "Hao ", "Cui ", "Fen ", "Jue ", "Bi ", "Bi ", "Huang ", "Pu ", "Lin ", "Yu ", "Tong ", "Yao ", "Liao ", "Shuo ", "Xiao ", "Swu ", "Ton ", "Xi ", "Ge ", "Juan ", "Du ", "Hui ", "Kuai ", "Xian ", "Xie ", "Ta ", "Xian ", "Xun ", "Ning ", "Pin ", "Huo ", "Nou ", "Meng ", "Lie ", "Nao ", "Guang ", "Shou ", "Lu ", "Ta ", "Xian ", "Mi ", "Rang ", "Huan ", "Nao ", "Luo ", "Xian ", "Qi ", "Jue ", "Xuan ", "Miao ", "Zi ", "Lu ", "Lu ", "Yu ", "Su ", "Wang ", "Qiu ", "Ga ", "Ding ", "Le ", "Ba ", "Ji ", "Hong ", "Di ", "Quan ", "Gan ", "Jiu ", "Yu ", "Ji ", "Yu ", "Yang ", "Ma ", "Gong ", "Wu ", "Fu ", "Wen ", "Jie ", "Ya ", "Fen ", "Bian ", "Beng ", "Yue ", "Jue ", "Yun ", "Jue ", "Wan ", "Jian ", "Mei ", "Dan ", "Pi ", "Wei ", "Huan ", "Xian ", "Qiang ", "Ling ", "Dai ", "Yi ", "An ", "Ping ", "Dian ", "Fu ", "Xuan ", "Xi ", "Bo ", "Ci ", "Gou ", "Jia ", "Shao ", "Po ", "Ci ", "Ke ", "Ran ", "Sheng ", "Shen ", "Yi ", "Zu ", "Jia ", "Min ", "Shan ", "Liu ", "Bi ", "Zhen ", "Zhen ", "Jue ", "Fa ", "Long ", "Jin ", "Jiao ", "Jian ", "Li ", "Guang ", "Xian ", "Zhou ", "Gong ", "Yan ", "Xiu ", "Yang ", "Xu ", "Luo ", "Su ", "Zhu ", "Qin ", "Ken ", "Xun ", "Bao ", "Er ", "Xiang ", "Yao ", "Xia ", "Heng ", "Gui ", "Chong ", "Xu ", "Ban ", "Pei ", "[?] ", "Dang ", "Ei ", "Hun ", "Wen ", "E ", "Cheng ", "Ti ", "Wu ", "Wu ", "Cheng ", "Jun ", "Mei ", "Bei ", "Ting ", "Xian ", "Chuo "];
  }
});

// node_modules/unidecode/data/x74.js
var require_x74 = __commonJS({
  "node_modules/unidecode/data/x74.js"(exports2, module2) {
    module2.exports = ["Han ", "Xuan ", "Yan ", "Qiu ", "Quan ", "Lang ", "Li ", "Xiu ", "Fu ", "Liu ", "Ye ", "Xi ", "Ling ", "Li ", "Jin ", "Lian ", "Suo ", "Chiisai ", "[?] ", "Wan ", "Dian ", "Pin ", "Zhan ", "Cui ", "Min ", "Yu ", "Ju ", "Chen ", "Lai ", "Wen ", "Sheng ", "Wei ", "Dian ", "Chu ", "Zhuo ", "Pei ", "Cheng ", "Hu ", "Qi ", "E ", "Kun ", "Chang ", "Qi ", "Beng ", "Wan ", "Lu ", "Cong ", "Guan ", "Yan ", "Diao ", "Bei ", "Lin ", "Qin ", "Pi ", "Pa ", "Que ", "Zhuo ", "Qin ", "Fa ", "[?] ", "Qiong ", "Du ", "Jie ", "Hun ", "Yu ", "Mao ", "Mei ", "Chun ", "Xuan ", "Ti ", "Xing ", "Dai ", "Rou ", "Min ", "Zhen ", "Wei ", "Ruan ", "Huan ", "Jie ", "Chuan ", "Jian ", "Zhuan ", "Yang ", "Lian ", "Quan ", "Xia ", "Duan ", "Yuan ", "Ye ", "Nao ", "Hu ", "Ying ", "Yu ", "Huang ", "Rui ", "Se ", "Liu ", "Shi ", "Rong ", "Suo ", "Yao ", "Wen ", "Wu ", "Jin ", "Jin ", "Ying ", "Ma ", "Tao ", "Liu ", "Tang ", "Li ", "Lang ", "Gui ", "Zhen ", "Qiang ", "Cuo ", "Jue ", "Zhao ", "Yao ", "Ai ", "Bin ", "Tu ", "Chang ", "Kun ", "Zhuan ", "Cong ", "Jin ", "Yi ", "Cui ", "Cong ", "Qi ", "Li ", "Ying ", "Suo ", "Qiu ", "Xuan ", "Ao ", "Lian ", "Man ", "Zhang ", "Yin ", "[?] ", "Ying ", "Zhi ", "Lu ", "Wu ", "Deng ", "Xiou ", "Zeng ", "Xun ", "Qu ", "Dang ", "Lin ", "Liao ", "Qiong ", "Su ", "Huang ", "Gui ", "Pu ", "Jing ", "Fan ", "Jin ", "Liu ", "Ji ", "[?] ", "Jing ", "Ai ", "Bi ", "Can ", "Qu ", "Zao ", "Dang ", "Jiao ", "Gun ", "Tan ", "Hui ", "Huan ", "Se ", "Sui ", "Tian ", "[?] ", "Yu ", "Jin ", "Lu ", "Bin ", "Shou ", "Wen ", "Zui ", "Lan ", "Xi ", "Ji ", "Xuan ", "Ruan ", "Huo ", "Gai ", "Lei ", "Du ", "Li ", "Zhi ", "Rou ", "Li ", "Zan ", "Qiong ", "Zhe ", "Gui ", "Sui ", "La ", "Long ", "Lu ", "Li ", "Zan ", "Lan ", "Ying ", "Mi ", "Xiang ", "Xi ", "Guan ", "Dao ", "Zan ", "Huan ", "Gua ", "Bo ", "Die ", "Bao ", "Hu ", "Zhi ", "Piao ", "Ban ", "Rang ", "Li ", "Wa ", "Dekaguramu ", "Jiang ", "Qian ", "Fan ", "Pen ", "Fang ", "Dan ", "Weng ", "Ou ", "Deshiguramu ", "Miriguramu ", "Thon ", "Hu ", "Ling ", "Yi ", "Ping ", "Ci ", "Hekutogura ", "Juan ", "Chang ", "Chi ", "Sarake ", "Dang ", "Meng ", "Pou "];
  }
});

// node_modules/unidecode/data/x75.js
var require_x75 = __commonJS({
  "node_modules/unidecode/data/x75.js"(exports2, module2) {
    module2.exports = ["Zhui ", "Ping ", "Bian ", "Zhou ", "Zhen ", "Senchigura ", "Ci ", "Ying ", "Qi ", "Xian ", "Lou ", "Di ", "Ou ", "Meng ", "Zhuan ", "Peng ", "Lin ", "Zeng ", "Wu ", "Pi ", "Dan ", "Weng ", "Ying ", "Yan ", "Gan ", "Dai ", "Shen ", "Tian ", "Tian ", "Han ", "Chang ", "Sheng ", "Qing ", "Sheng ", "Chan ", "Chan ", "Rui ", "Sheng ", "Su ", "Sen ", "Yong ", "Shuai ", "Lu ", "Fu ", "Yong ", "Beng ", "Feng ", "Ning ", "Tian ", "You ", "Jia ", "Shen ", "Zha ", "Dian ", "Fu ", "Nan ", "Dian ", "Ping ", "Ting ", "Hua ", "Ting ", "Quan ", "Zi ", "Meng ", "Bi ", "Qi ", "Liu ", "Xun ", "Liu ", "Chang ", "Mu ", "Yun ", "Fan ", "Fu ", "Geng ", "Tian ", "Jie ", "Jie ", "Quan ", "Wei ", "Fu ", "Tian ", "Mu ", "Tap ", "Pan ", "Jiang ", "Wa ", "Da ", "Nan ", "Liu ", "Ben ", "Zhen ", "Chu ", "Mu ", "Mu ", "Ce ", "Cen ", "Gai ", "Bi ", "Da ", "Zhi ", "Lue ", "Qi ", "Lue ", "Pan ", "Kesa ", "Fan ", "Hua ", "Yu ", "Yu ", "Mu ", "Jun ", "Yi ", "Liu ", "Yu ", "Die ", "Chou ", "Hua ", "Dang ", "Chuo ", "Ji ", "Wan ", "Jiang ", "Sheng ", "Chang ", "Tuan ", "Lei ", "Ji ", "Cha ", "Liu ", "Tatamu ", "Tuan ", "Lin ", "Jiang ", "Jiang ", "Chou ", "Bo ", "Die ", "Die ", "Pi ", "Nie ", "Dan ", "Shu ", "Shu ", "Zhi ", "Yi ", "Chuang ", "Nai ", "Ding ", "Bi ", "Jie ", "Liao ", "Gong ", "Ge ", "Jiu ", "Zhou ", "Xia ", "Shan ", "Xu ", "Nue ", "Li ", "Yang ", "Chen ", "You ", "Ba ", "Jie ", "Jue ", "Zhi ", "Xia ", "Cui ", "Bi ", "Yi ", "Li ", "Zong ", "Chuang ", "Feng ", "Zhu ", "Pao ", "Pi ", "Gan ", "Ke ", "Ci ", "Xie ", "Qi ", "Dan ", "Zhen ", "Fa ", "Zhi ", "Teng ", "Ju ", "Ji ", "Fei ", "Qu ", "Dian ", "Jia ", "Xian ", "Cha ", "Bing ", "Ni ", "Zheng ", "Yong ", "Jing ", "Quan ", "Chong ", "Tong ", "Yi ", "Kai ", "Wei ", "Hui ", "Duo ", "Yang ", "Chi ", "Zhi ", "Hen ", "Ya ", "Mei ", "Dou ", "Jing ", "Xiao ", "Tong ", "Tu ", "Mang ", "Pi ", "Xiao ", "Suan ", "Pu ", "Li ", "Zhi ", "Cuo ", "Duo ", "Wu ", "Sha ", "Lao ", "Shou ", "Huan ", "Xian ", "Yi ", "Peng ", "Zhang ", "Guan ", "Tan ", "Fei ", "Ma ", "Lin ", "Chi ", "Ji ", "Dian ", "An ", "Chi ", "Bi ", "Bei ", "Min ", "Gu ", "Dui ", "E ", "Wei "];
  }
});

// node_modules/unidecode/data/x76.js
var require_x76 = __commonJS({
  "node_modules/unidecode/data/x76.js"(exports2, module2) {
    module2.exports = ["Yu ", "Cui ", "Ya ", "Zhu ", "Cu ", "Dan ", "Shen ", "Zhung ", "Ji ", "Yu ", "Hou ", "Feng ", "La ", "Yang ", "Shen ", "Tu ", "Yu ", "Gua ", "Wen ", "Huan ", "Ku ", "Jia ", "Yin ", "Yi ", "Lu ", "Sao ", "Jue ", "Chi ", "Xi ", "Guan ", "Yi ", "Wen ", "Ji ", "Chuang ", "Ban ", "Lei ", "Liu ", "Chai ", "Shou ", "Nue ", "Dian ", "Da ", "Pie ", "Tan ", "Zhang ", "Biao ", "Shen ", "Cu ", "Luo ", "Yi ", "Zong ", "Chou ", "Zhang ", "Zhai ", "Sou ", "Suo ", "Que ", "Diao ", "Lou ", "Lu ", "Mo ", "Jin ", "Yin ", "Ying ", "Huang ", "Fu ", "Liao ", "Long ", "Qiao ", "Liu ", "Lao ", "Xian ", "Fei ", "Dan ", "Yin ", "He ", "Yan ", "Ban ", "Xian ", "Guan ", "Guai ", "Nong ", "Yu ", "Wei ", "Yi ", "Yong ", "Pi ", "Lei ", "Li ", "Shu ", "Dan ", "Lin ", "Dian ", "Lin ", "Lai ", "Pie ", "Ji ", "Chi ", "Yang ", "Xian ", "Jie ", "Zheng ", "[?] ", "Li ", "Huo ", "Lai ", "Shaku ", "Dian ", "Xian ", "Ying ", "Yin ", "Qu ", "Yong ", "Tan ", "Dian ", "Luo ", "Luan ", "Luan ", "Bo ", "[?] ", "Gui ", "Po ", "Fa ", "Deng ", "Fa ", "Bai ", "Bai ", "Qie ", "Bi ", "Zao ", "Zao ", "Mao ", "De ", "Pa ", "Jie ", "Huang ", "Gui ", "Ci ", "Ling ", "Gao ", "Mo ", "Ji ", "Jiao ", "Peng ", "Gao ", "Ai ", "E ", "Hao ", "Han ", "Bi ", "Wan ", "Chou ", "Qian ", "Xi ", "Ai ", "Jiong ", "Hao ", "Huang ", "Hao ", "Ze ", "Cui ", "Hao ", "Xiao ", "Ye ", "Po ", "Hao ", "Jiao ", "Ai ", "Xing ", "Huang ", "Li ", "Piao ", "He ", "Jiao ", "Pi ", "Gan ", "Pao ", "Zhou ", "Jun ", "Qiu ", "Cun ", "Que ", "Zha ", "Gu ", "Jun ", "Jun ", "Zhou ", "Zha ", "Gu ", "Zhan ", "Du ", "Min ", "Qi ", "Ying ", "Yu ", "Bei ", "Zhao ", "Zhong ", "Pen ", "He ", "Ying ", "He ", "Yi ", "Bo ", "Wan ", "He ", "Ang ", "Zhan ", "Yan ", "Jian ", "He ", "Yu ", "Kui ", "Fan ", "Gai ", "Dao ", "Pan ", "Fu ", "Qiu ", "Sheng ", "Dao ", "Lu ", "Zhan ", "Meng ", "Li ", "Jin ", "Xu ", "Jian ", "Pan ", "Guan ", "An ", "Lu ", "Shu ", "Zhou ", "Dang ", "An ", "Gu ", "Li ", "Mu ", "Cheng ", "Gan ", "Xu ", "Mang ", "Mang ", "Zhi ", "Qi ", "Ruan ", "Tian ", "Xiang ", "Dun ", "Xin ", "Xi ", "Pan ", "Feng ", "Dun ", "Min "];
  }
});

// node_modules/unidecode/data/x77.js
var require_x77 = __commonJS({
  "node_modules/unidecode/data/x77.js"(exports2, module2) {
    module2.exports = ["Ming ", "Sheng ", "Shi ", "Yun ", "Mian ", "Pan ", "Fang ", "Miao ", "Dan ", "Mei ", "Mao ", "Kan ", "Xian ", "Ou ", "Shi ", "Yang ", "Zheng ", "Yao ", "Shen ", "Huo ", "Da ", "Zhen ", "Kuang ", "Ju ", "Shen ", "Chi ", "Sheng ", "Mei ", "Mo ", "Zhu ", "Zhen ", "Zhen ", "Mian ", "Di ", "Yuan ", "Die ", "Yi ", "Zi ", "Zi ", "Chao ", "Zha ", "Xuan ", "Bing ", "Mi ", "Long ", "Sui ", "Dong ", "Mi ", "Die ", "Yi ", "Er ", "Ming ", "Xuan ", "Chi ", "Kuang ", "Juan ", "Mou ", "Zhen ", "Tiao ", "Yang ", "Yan ", "Mo ", "Zhong ", "Mai ", "Zhao ", "Zheng ", "Mei ", "Jun ", "Shao ", "Han ", "Huan ", "Di ", "Cheng ", "Cuo ", "Juan ", "E ", "Wan ", "Xian ", "Xi ", "Kun ", "Lai ", "Jian ", "Shan ", "Tian ", "Hun ", "Wan ", "Ling ", "Shi ", "Qiong ", "Lie ", "Yai ", "Jing ", "Zheng ", "Li ", "Lai ", "Sui ", "Juan ", "Shui ", "Sui ", "Du ", "Bi ", "Bi ", "Mu ", "Hun ", "Ni ", "Lu ", "Yi ", "Jie ", "Cai ", "Zhou ", "Yu ", "Hun ", "Ma ", "Xia ", "Xing ", "Xi ", "Gun ", "Cai ", "Chun ", "Jian ", "Mei ", "Du ", "Hou ", "Xuan ", "Ti ", "Kui ", "Gao ", "Rui ", "Mou ", "Xu ", "Fa ", "Wen ", "Miao ", "Chou ", "Kui ", "Mi ", "Weng ", "Kou ", "Dang ", "Chen ", "Ke ", "Sou ", "Xia ", "Qiong ", "Mao ", "Ming ", "Man ", "Shui ", "Ze ", "Zhang ", "Yi ", "Diao ", "Ou ", "Mo ", "Shun ", "Cong ", "Lou ", "Chi ", "Man ", "Piao ", "Cheng ", "Ji ", "Meng ", "[?] ", "Run ", "Pie ", "Xi ", "Qiao ", "Pu ", "Zhu ", "Deng ", "Shen ", "Shun ", "Liao ", "Che ", "Xian ", "Kan ", "Ye ", "Xu ", "Tong ", "Mou ", "Lin ", "Kui ", "Xian ", "Ye ", "Ai ", "Hui ", "Zhan ", "Jian ", "Gu ", "Zhao ", "Qu ", "Wei ", "Chou ", "Sao ", "Ning ", "Xun ", "Yao ", "Huo ", "Meng ", "Mian ", "Bin ", "Mian ", "Li ", "Kuang ", "Jue ", "Xuan ", "Mian ", "Huo ", "Lu ", "Meng ", "Long ", "Guan ", "Man ", "Xi ", "Chu ", "Tang ", "Kan ", "Zhu ", "Mao ", "Jin ", "Lin ", "Yu ", "Shuo ", "Ce ", "Jue ", "Shi ", "Yi ", "Shen ", "Zhi ", "Hou ", "Shen ", "Ying ", "Ju ", "Zhou ", "Jiao ", "Cuo ", "Duan ", "Ai ", "Jiao ", "Zeng ", "Huo ", "Bai ", "Shi ", "Ding ", "Qi ", "Ji ", "Zi ", "Gan ", "Wu ", "Tuo ", "Ku ", "Qiang ", "Xi ", "Fan ", "Kuang "];
  }
});

// node_modules/unidecode/data/x78.js
var require_x78 = __commonJS({
  "node_modules/unidecode/data/x78.js"(exports2, module2) {
    module2.exports = ["Dang ", "Ma ", "Sha ", "Dan ", "Jue ", "Li ", "Fu ", "Min ", "Nuo ", "Huo ", "Kang ", "Zhi ", "Qi ", "Kan ", "Jie ", "Fen ", "E ", "Ya ", "Pi ", "Zhe ", "Yan ", "Sui ", "Zhuan ", "Che ", "Dun ", "Pan ", "Yan ", "[?] ", "Feng ", "Fa ", "Mo ", "Zha ", "Qu ", "Yu ", "Luo ", "Tuo ", "Tuo ", "Di ", "Zhai ", "Zhen ", "Ai ", "Fei ", "Mu ", "Zhu ", "Li ", "Bian ", "Nu ", "Ping ", "Peng ", "Ling ", "Pao ", "Le ", "Po ", "Bo ", "Po ", "Shen ", "Za ", "Nuo ", "Li ", "Long ", "Tong ", "[?] ", "Li ", "Aragane ", "Chu ", "Keng ", "Quan ", "Zhu ", "Kuang ", "Huo ", "E ", "Nao ", "Jia ", "Lu ", "Wei ", "Ai ", "Luo ", "Ken ", "Xing ", "Yan ", "Tong ", "Peng ", "Xi ", "[?] ", "Hong ", "Shuo ", "Xia ", "Qiao ", "[?] ", "Wei ", "Qiao ", "[?] ", "Keng ", "Xiao ", "Que ", "Chan ", "Lang ", "Hong ", "Yu ", "Xiao ", "Xia ", "Mang ", "Long ", "Iong ", "Che ", "Che ", "E ", "Liu ", "Ying ", "Mang ", "Que ", "Yan ", "Sha ", "Kun ", "Yu ", "[?] ", "Kaki ", "Lu ", "Chen ", "Jian ", "Nue ", "Song ", "Zhuo ", "Keng ", "Peng ", "Yan ", "Zhui ", "Kong ", "Ceng ", "Qi ", "Zong ", "Qing ", "Lin ", "Jun ", "Bo ", "Ding ", "Min ", "Diao ", "Jian ", "He ", "Lu ", "Ai ", "Sui ", "Que ", "Ling ", "Bei ", "Yin ", "Dui ", "Wu ", "Qi ", "Lun ", "Wan ", "Dian ", "Gang ", "Pei ", "Qi ", "Chen ", "Ruan ", "Yan ", "Die ", "Ding ", "Du ", "Tuo ", "Jie ", "Ying ", "Bian ", "Ke ", "Bi ", "Wei ", "Shuo ", "Zhen ", "Duan ", "Xia ", "Dang ", "Ti ", "Nao ", "Peng ", "Jian ", "Di ", "Tan ", "Cha ", "Seki ", "Qi ", "[?] ", "Feng ", "Xuan ", "Que ", "Que ", "Ma ", "Gong ", "Nian ", "Su ", "E ", "Ci ", "Liu ", "Si ", "Tang ", "Bang ", "Hua ", "Pi ", "Wei ", "Sang ", "Lei ", "Cuo ", "Zhen ", "Xia ", "Qi ", "Lian ", "Pan ", "Wei ", "Yun ", "Dui ", "Zhe ", "Ke ", "La ", "[?] ", "Qing ", "Gun ", "Zhuan ", "Chan ", "Qi ", "Ao ", "Peng ", "Lu ", "Lu ", "Kan ", "Qiang ", "Chen ", "Yin ", "Lei ", "Biao ", "Qi ", "Mo ", "Qi ", "Cui ", "Zong ", "Qing ", "Chuo ", "[?] ", "Ji ", "Shan ", "Lao ", "Qu ", "Zeng ", "Deng ", "Jian ", "Xi ", "Lin ", "Ding ", "Dian ", "Huang ", "Pan ", "Za ", "Qiao ", "Di ", "Li "];
  }
});

// node_modules/unidecode/data/x79.js
var require_x79 = __commonJS({
  "node_modules/unidecode/data/x79.js"(exports2, module2) {
    module2.exports = ["Tani ", "Jiao ", "[?] ", "Zhang ", "Qiao ", "Dun ", "Xian ", "Yu ", "Zhui ", "He ", "Huo ", "Zhai ", "Lei ", "Ke ", "Chu ", "Ji ", "Que ", "Dang ", "Yi ", "Jiang ", "Pi ", "Pi ", "Yu ", "Pin ", "Qi ", "Ai ", "Kai ", "Jian ", "Yu ", "Ruan ", "Meng ", "Pao ", "Ci ", "[?] ", "[?] ", "Mie ", "Ca ", "Xian ", "Kuang ", "Lei ", "Lei ", "Zhi ", "Li ", "Li ", "Fan ", "Que ", "Pao ", "Ying ", "Li ", "Long ", "Long ", "Mo ", "Bo ", "Shuang ", "Guan ", "Lan ", "Zan ", "Yan ", "Shi ", "Shi ", "Li ", "Reng ", "She ", "Yue ", "Si ", "Qi ", "Ta ", "Ma ", "Xie ", "Xian ", "Xian ", "Zhi ", "Qi ", "Zhi ", "Beng ", "Dui ", "Zhong ", "[?] ", "Yi ", "Shi ", "You ", "Zhi ", "Tiao ", "Fu ", "Fu ", "Mi ", "Zu ", "Zhi ", "Suan ", "Mei ", "Zuo ", "Qu ", "Hu ", "Zhu ", "Shen ", "Sui ", "Ci ", "Chai ", "Mi ", "Lu ", "Yu ", "Xiang ", "Wu ", "Tiao ", "Piao ", "Zhu ", "Gui ", "Xia ", "Zhi ", "Ji ", "Gao ", "Zhen ", "Gao ", "Shui ", "Jin ", "Chen ", "Gai ", "Kun ", "Di ", "Dao ", "Huo ", "Tao ", "Qi ", "Gu ", "Guan ", "Zui ", "Ling ", "Lu ", "Bing ", "Jin ", "Dao ", "Zhi ", "Lu ", "Shan ", "Bei ", "Zhe ", "Hui ", "You ", "Xi ", "Yin ", "Zi ", "Huo ", "Zhen ", "Fu ", "Yuan ", "Wu ", "Xian ", "Yang ", "Ti ", "Yi ", "Mei ", "Si ", "Di ", "[?] ", "Zhuo ", "Zhen ", "Yong ", "Ji ", "Gao ", "Tang ", "Si ", "Ma ", "Ta ", "[?] ", "Xuan ", "Qi ", "Yu ", "Xi ", "Ji ", "Si ", "Chan ", "Tan ", "Kuai ", "Sui ", "Li ", "Nong ", "Ni ", "Dao ", "Li ", "Rang ", "Yue ", "Ti ", "Zan ", "Lei ", "Rou ", "Yu ", "Yu ", "Chi ", "Xie ", "Qin ", "He ", "Tu ", "Xiu ", "Si ", "Ren ", "Tu ", "Zi ", "Cha ", "Gan ", "Yi ", "Xian ", "Bing ", "Nian ", "Qiu ", "Qiu ", "Chong ", "Fen ", "Hao ", "Yun ", "Ke ", "Miao ", "Zhi ", "Geng ", "Bi ", "Zhi ", "Yu ", "Mi ", "Ku ", "Ban ", "Pi ", "Ni ", "Li ", "You ", "Zu ", "Pi ", "Ba ", "Ling ", "Mo ", "Cheng ", "Nian ", "Qin ", "Yang ", "Zuo ", "Zhi ", "Zhi ", "Shu ", "Ju ", "Zi ", "Huo ", "Ji ", "Cheng ", "Tong ", "Zhi ", "Huo ", "He ", "Yin ", "Zi ", "Zhi ", "Jie ", "Ren ", "Du ", "Yi ", "Zhu ", "Hui ", "Nong ", "Fu "];
  }
});

// node_modules/unidecode/data/x7a.js
var require_x7a = __commonJS({
  "node_modules/unidecode/data/x7a.js"(exports2, module2) {
    module2.exports = ["Xi ", "Kao ", "Lang ", "Fu ", "Ze ", "Shui ", "Lu ", "Kun ", "Gan ", "Geng ", "Ti ", "Cheng ", "Tu ", "Shao ", "Shui ", "Ya ", "Lun ", "Lu ", "Gu ", "Zuo ", "Ren ", "Zhun ", "Bang ", "Bai ", "Ji ", "Zhi ", "Zhi ", "Kun ", "Leng ", "Peng ", "Ke ", "Bing ", "Chou ", "Zu ", "Yu ", "Su ", "Lue ", "[?] ", "Yi ", "Xi ", "Bian ", "Ji ", "Fu ", "Bi ", "Nuo ", "Jie ", "Zhong ", "Zong ", "Xu ", "Cheng ", "Dao ", "Wen ", "Lian ", "Zi ", "Yu ", "Ji ", "Xu ", "Zhen ", "Zhi ", "Dao ", "Jia ", "Ji ", "Gao ", "Gao ", "Gu ", "Rong ", "Sui ", "You ", "Ji ", "Kang ", "Mu ", "Shan ", "Men ", "Zhi ", "Ji ", "Lu ", "Su ", "Ji ", "Ying ", "Wen ", "Qiu ", "Se ", "[?] ", "Yi ", "Huang ", "Qie ", "Ji ", "Sui ", "Xiao ", "Pu ", "Jiao ", "Zhuo ", "Tong ", "Sai ", "Lu ", "Sui ", "Nong ", "Se ", "Hui ", "Rang ", "Nuo ", "Yu ", "Bin ", "Ji ", "Tui ", "Wen ", "Cheng ", "Huo ", "Gong ", "Lu ", "Biao ", "[?] ", "Rang ", "Zhuo ", "Li ", "Zan ", "Xue ", "Wa ", "Jiu ", "Qiong ", "Xi ", "Qiong ", "Kong ", "Yu ", "Sen ", "Jing ", "Yao ", "Chuan ", "Zhun ", "Tu ", "Lao ", "Qie ", "Zhai ", "Yao ", "Bian ", "Bao ", "Yao ", "Bing ", "Wa ", "Zhu ", "Jiao ", "Qiao ", "Diao ", "Wu ", "Gui ", "Yao ", "Zhi ", "Chuang ", "Yao ", "Tiao ", "Jiao ", "Chuang ", "Jiong ", "Xiao ", "Cheng ", "Kou ", "Cuan ", "Wo ", "Dan ", "Ku ", "Ke ", "Zhui ", "Xu ", "Su ", "Guan ", "Kui ", "Dou ", "[?] ", "Yin ", "Wo ", "Wa ", "Ya ", "Yu ", "Ju ", "Qiong ", "Yao ", "Yao ", "Tiao ", "Chao ", "Yu ", "Tian ", "Diao ", "Ju ", "Liao ", "Xi ", "Wu ", "Kui ", "Chuang ", "Zhao ", "[?] ", "Kuan ", "Long ", "Cheng ", "Cui ", "Piao ", "Zao ", "Cuan ", "Qiao ", "Qiong ", "Dou ", "Zao ", "Long ", "Qie ", "Li ", "Chu ", "Shi ", "Fou ", "Qian ", "Chu ", "Hong ", "Qi ", "Qian ", "Gong ", "Shi ", "Shu ", "Miao ", "Ju ", "Zhan ", "Zhu ", "Ling ", "Long ", "Bing ", "Jing ", "Jing ", "Zhang ", "Yi ", "Si ", "Jun ", "Hong ", "Tong ", "Song ", "Jing ", "Diao ", "Yi ", "Shu ", "Jing ", "Qu ", "Jie ", "Ping ", "Duan ", "Shao ", "Zhuan ", "Ceng ", "Deng ", "Cui ", "Huai ", "Jing ", "Kan ", "Jing ", "Zhu ", "Zhu ", "Le ", "Peng ", "Yu ", "Chi ", "Gan "];
  }
});

// node_modules/unidecode/data/x7b.js
var require_x7b = __commonJS({
  "node_modules/unidecode/data/x7b.js"(exports2, module2) {
    module2.exports = ["Mang ", "Zhu ", "Utsubo ", "Du ", "Ji ", "Xiao ", "Ba ", "Suan ", "Ji ", "Zhen ", "Zhao ", "Sun ", "Ya ", "Zhui ", "Yuan ", "Hu ", "Gang ", "Xiao ", "Cen ", "Pi ", "Bi ", "Jian ", "Yi ", "Dong ", "Shan ", "Sheng ", "Xia ", "Di ", "Zhu ", "Na ", "Chi ", "Gu ", "Li ", "Qie ", "Min ", "Bao ", "Tiao ", "Si ", "Fu ", "Ce ", "Ben ", "Pei ", "Da ", "Zi ", "Di ", "Ling ", "Ze ", "Nu ", "Fu ", "Gou ", "Fan ", "Jia ", "Ge ", "Fan ", "Shi ", "Mao ", "Po ", "Sey ", "Jian ", "Qiong ", "Long ", "Souke ", "Bian ", "Luo ", "Gui ", "Qu ", "Chi ", "Yin ", "Yao ", "Xian ", "Bi ", "Qiong ", "Gua ", "Deng ", "Jiao ", "Jin ", "Quan ", "Sun ", "Ru ", "Fa ", "Kuang ", "Zhu ", "Tong ", "Ji ", "Da ", "Xing ", "Ce ", "Zhong ", "Kou ", "Lai ", "Bi ", "Shai ", "Dang ", "Zheng ", "Ce ", "Fu ", "Yun ", "Tu ", "Pa ", "Li ", "Lang ", "Ju ", "Guan ", "Jian ", "Han ", "Tong ", "Xia ", "Zhi ", "Cheng ", "Suan ", "Shi ", "Zhu ", "Zuo ", "Xiao ", "Shao ", "Ting ", "Ce ", "Yan ", "Gao ", "Kuai ", "Gan ", "Chou ", "Kago ", "Gang ", "Yun ", "O ", "Qian ", "Xiao ", "Jian ", "Pu ", "Lai ", "Zou ", "Bi ", "Bi ", "Bi ", "Ge ", "Chi ", "Guai ", "Yu ", "Jian ", "Zhao ", "Gu ", "Chi ", "Zheng ", "Jing ", "Sha ", "Zhou ", "Lu ", "Bo ", "Ji ", "Lin ", "Suan ", "Jun ", "Fu ", "Zha ", "Gu ", "Kong ", "Qian ", "Quan ", "Jun ", "Chui ", "Guan ", "Yuan ", "Ce ", "Ju ", "Bo ", "Ze ", "Qie ", "Tuo ", "Luo ", "Dan ", "Xiao ", "Ruo ", "Jian ", "Xuan ", "Bian ", "Sun ", "Xiang ", "Xian ", "Ping ", "Zhen ", "Sheng ", "Hu ", "Shi ", "Zhu ", "Yue ", "Chun ", "Lu ", "Wu ", "Dong ", "Xiao ", "Ji ", "Jie ", "Huang ", "Xing ", "Mei ", "Fan ", "Chui ", "Zhuan ", "Pian ", "Feng ", "Zhu ", "Hong ", "Qie ", "Hou ", "Qiu ", "Miao ", "Qian ", "[?] ", "Kui ", "Sik ", "Lou ", "Yun ", "He ", "Tang ", "Yue ", "Chou ", "Gao ", "Fei ", "Ruo ", "Zheng ", "Gou ", "Nie ", "Qian ", "Xiao ", "Cuan ", "Gong ", "Pang ", "Du ", "Li ", "Bi ", "Zhuo ", "Chu ", "Shai ", "Chi ", "Zhu ", "Qiang ", "Long ", "Lan ", "Jian ", "Bu ", "Li ", "Hui ", "Bi ", "Di ", "Cong ", "Yan ", "Peng ", "Sen ", "Zhuan ", "Pai ", "Piao ", "Dou ", "Yu ", "Mie ", "Zhuan "];
  }
});

// node_modules/unidecode/data/x7c.js
var require_x7c = __commonJS({
  "node_modules/unidecode/data/x7c.js"(exports2, module2) {
    module2.exports = ["Ze ", "Xi ", "Guo ", "Yi ", "Hu ", "Chan ", "Kou ", "Cu ", "Ping ", "Chou ", "Ji ", "Gui ", "Su ", "Lou ", "Zha ", "Lu ", "Nian ", "Suo ", "Cuan ", "Sasara ", "Suo ", "Le ", "Duan ", "Yana ", "Xiao ", "Bo ", "Mi ", "Si ", "Dang ", "Liao ", "Dan ", "Dian ", "Fu ", "Jian ", "Min ", "Kui ", "Dai ", "Qiao ", "Deng ", "Huang ", "Sun ", "Lao ", "Zan ", "Xiao ", "Du ", "Shi ", "Zan ", "[?] ", "Pai ", "Hata ", "Pai ", "Gan ", "Ju ", "Du ", "Lu ", "Yan ", "Bo ", "Dang ", "Sai ", "Ke ", "Long ", "Qian ", "Lian ", "Bo ", "Zhou ", "Lai ", "[?] ", "Lan ", "Kui ", "Yu ", "Yue ", "Hao ", "Zhen ", "Tai ", "Ti ", "Mi ", "Chou ", "Ji ", "[?] ", "Hata ", "Teng ", "Zhuan ", "Zhou ", "Fan ", "Sou ", "Zhou ", "Kuji ", "Zhuo ", "Teng ", "Lu ", "Lu ", "Jian ", "Tuo ", "Ying ", "Yu ", "Lai ", "Long ", "Shinshi ", "Lian ", "Lan ", "Qian ", "Yue ", "Zhong ", "Qu ", "Lian ", "Bian ", "Duan ", "Zuan ", "Li ", "Si ", "Luo ", "Ying ", "Yue ", "Zhuo ", "Xu ", "Mi ", "Di ", "Fan ", "Shen ", "Zhe ", "Shen ", "Nu ", "Xie ", "Lei ", "Xian ", "Zi ", "Ni ", "Cun ", "[?] ", "Qian ", "Kume ", "Bi ", "Ban ", "Wu ", "Sha ", "Kang ", "Rou ", "Fen ", "Bi ", "Cui ", "[?] ", "Li ", "Chi ", "Nukamiso ", "Ro ", "Ba ", "Li ", "Gan ", "Ju ", "Po ", "Mo ", "Cu ", "Nian ", "Zhou ", "Li ", "Su ", "Tiao ", "Li ", "Qi ", "Su ", "Hong ", "Tong ", "Zi ", "Ce ", "Yue ", "Zhou ", "Lin ", "Zhuang ", "Bai ", "[?] ", "Fen ", "Ji ", "[?] ", "Sukumo ", "Liang ", "Xian ", "Fu ", "Liang ", "Can ", "Geng ", "Li ", "Yue ", "Lu ", "Ju ", "Qi ", "Cui ", "Bai ", "Zhang ", "Lin ", "Zong ", "Jing ", "Guo ", "Kouji ", "San ", "San ", "Tang ", "Bian ", "Rou ", "Mian ", "Hou ", "Xu ", "Zong ", "Hu ", "Jian ", "Zan ", "Ci ", "Li ", "Xie ", "Fu ", "Ni ", "Bei ", "Gu ", "Xiu ", "Gao ", "Tang ", "Qiu ", "Sukumo ", "Cao ", "Zhuang ", "Tang ", "Mi ", "San ", "Fen ", "Zao ", "Kang ", "Jiang ", "Mo ", "San ", "San ", "Nuo ", "Xi ", "Liang ", "Jiang ", "Kuai ", "Bo ", "Huan ", "[?] ", "Zong ", "Xian ", "Nuo ", "Tuan ", "Nie ", "Li ", "Zuo ", "Di ", "Nie ", "Tiao ", "Lan ", "Mi ", "Jiao ", "Jiu ", "Xi ", "Gong ", "Zheng ", "Jiu ", "You "];
  }
});

// node_modules/unidecode/data/x7d.js
var require_x7d = __commonJS({
  "node_modules/unidecode/data/x7d.js"(exports2, module2) {
    module2.exports = ["Ji ", "Cha ", "Zhou ", "Xun ", "Yue ", "Hong ", "Yu ", "He ", "Wan ", "Ren ", "Wen ", "Wen ", "Qiu ", "Na ", "Zi ", "Tou ", "Niu ", "Fou ", "Jie ", "Shu ", "Chun ", "Pi ", "Yin ", "Sha ", "Hong ", "Zhi ", "Ji ", "Fen ", "Yun ", "Ren ", "Dan ", "Jin ", "Su ", "Fang ", "Suo ", "Cui ", "Jiu ", "Zha ", "Kinu ", "Jin ", "Fu ", "Zhi ", "Ci ", "Zi ", "Chou ", "Hong ", "Zha ", "Lei ", "Xi ", "Fu ", "Xie ", "Shen ", "Bei ", "Zhu ", "Qu ", "Ling ", "Zhu ", "Shao ", "Gan ", "Yang ", "Fu ", "Tuo ", "Zhen ", "Dai ", "Zhuo ", "Shi ", "Zhong ", "Xian ", "Zu ", "Jiong ", "Ban ", "Ju ", "Mo ", "Shu ", "Zui ", "Wata ", "Jing ", "Ren ", "Heng ", "Xie ", "Jie ", "Zhu ", "Chou ", "Gua ", "Bai ", "Jue ", "Kuang ", "Hu ", "Ci ", "Geng ", "Geng ", "Tao ", "Xie ", "Ku ", "Jiao ", "Quan ", "Gai ", "Luo ", "Xuan ", "Bing ", "Xian ", "Fu ", "Gei ", "Tong ", "Rong ", "Tiao ", "Yin ", "Lei ", "Xie ", "Quan ", "Xu ", "Lun ", "Die ", "Tong ", "Si ", "Jiang ", "Xiang ", "Hui ", "Jue ", "Zhi ", "Jian ", "Juan ", "Chi ", "Mian ", "Zhen ", "Lu ", "Cheng ", "Qiu ", "Shu ", "Bang ", "Tong ", "Xiao ", "Wan ", "Qin ", "Geng ", "Xiu ", "Ti ", "Xiu ", "Xie ", "Hong ", "Xi ", "Fu ", "Ting ", "Sui ", "Dui ", "Kun ", "Fu ", "Jing ", "Hu ", "Zhi ", "Yan ", "Jiong ", "Feng ", "Ji ", "Sok ", "Kase ", "Zong ", "Lin ", "Duo ", "Li ", "Lu ", "Liang ", "Chou ", "Quan ", "Shao ", "Qi ", "Qi ", "Zhun ", "Qi ", "Wan ", "Qian ", "Xian ", "Shou ", "Wei ", "Qi ", "Tao ", "Wan ", "Gang ", "Wang ", "Beng ", "Zhui ", "Cai ", "Guo ", "Cui ", "Lun ", "Liu ", "Qi ", "Zhan ", "Bei ", "Chuo ", "Ling ", "Mian ", "Qi ", "Qie ", "Tan ", "Zong ", "Gun ", "Zou ", "Yi ", "Zi ", "Xing ", "Liang ", "Jin ", "Fei ", "Rui ", "Min ", "Yu ", "Zong ", "Fan ", "Lu ", "Xu ", "Yingl ", "Zhang ", "Kasuri ", "Xu ", "Xiang ", "Jian ", "Ke ", "Xian ", "Ruan ", "Mian ", "Qi ", "Duan ", "Zhong ", "Di ", "Min ", "Miao ", "Yuan ", "Xie ", "Bao ", "Si ", "Qiu ", "Bian ", "Huan ", "Geng ", "Cong ", "Mian ", "Wei ", "Fu ", "Wei ", "Yu ", "Gou ", "Miao ", "Xie ", "Lian ", "Zong ", "Bian ", "Yun ", "Yin ", "Ti ", "Gua ", "Zhi ", "Yun ", "Cheng ", "Chan ", "Dai "];
  }
});

// node_modules/unidecode/data/x7e.js
var require_x7e = __commonJS({
  "node_modules/unidecode/data/x7e.js"(exports2, module2) {
    module2.exports = ["Xia ", "Yuan ", "Zong ", "Xu ", "Nawa ", "Odoshi ", "Geng ", "Sen ", "Ying ", "Jin ", "Yi ", "Zhui ", "Ni ", "Bang ", "Gu ", "Pan ", "Zhou ", "Jian ", "Cuo ", "Quan ", "Shuang ", "Yun ", "Xia ", "Shuai ", "Xi ", "Rong ", "Tao ", "Fu ", "Yun ", "Zhen ", "Gao ", "Ru ", "Hu ", "Zai ", "Teng ", "Xian ", "Su ", "Zhen ", "Zong ", "Tao ", "Horo ", "Cai ", "Bi ", "Feng ", "Cu ", "Li ", "Suo ", "Yin ", "Xi ", "Zong ", "Lei ", "Zhuan ", "Qian ", "Man ", "Zhi ", "Lu ", "Mo ", "Piao ", "Lian ", "Mi ", "Xuan ", "Zong ", "Ji ", "Shan ", "Sui ", "Fan ", "Shuai ", "Beng ", "Yi ", "Sao ", "Mou ", "Zhou ", "Qiang ", "Hun ", "Sem ", "Xi ", "Jung ", "Xiu ", "Ran ", "Xuan ", "Hui ", "Qiao ", "Zeng ", "Zuo ", "Zhi ", "Shan ", "San ", "Lin ", "Yu ", "Fan ", "Liao ", "Chuo ", "Zun ", "Jian ", "Rao ", "Chan ", "Rui ", "Xiu ", "Hui ", "Hua ", "Zuan ", "Xi ", "Qiang ", "Un ", "Da ", "Sheng ", "Hui ", "Xi ", "Se ", "Jian ", "Jiang ", "Huan ", "Zao ", "Cong ", "Jie ", "Jiao ", "Bo ", "Chan ", "Yi ", "Nao ", "Sui ", "Yi ", "Shai ", "Xu ", "Ji ", "Bin ", "Qian ", "Lan ", "Pu ", "Xun ", "Zuan ", "Qi ", "Peng ", "Li ", "Mo ", "Lei ", "Xie ", "Zuan ", "Kuang ", "You ", "Xu ", "Lei ", "Xian ", "Chan ", "Kou ", "Lu ", "Chan ", "Ying ", "Cai ", "Xiang ", "Xian ", "Zui ", "Zuan ", "Luo ", "Xi ", "Dao ", "Lan ", "Lei ", "Lian ", "Si ", "Jiu ", "Yu ", "Hong ", "Zhou ", "Xian ", "He ", "Yue ", "Ji ", "Wan ", "Kuang ", "Ji ", "Ren ", "Wei ", "Yun ", "Hong ", "Chun ", "Pi ", "Sha ", "Gang ", "Na ", "Ren ", "Zong ", "Lun ", "Fen ", "Zhi ", "Wen ", "Fang ", "Zhu ", "Yin ", "Niu ", "Shu ", "Xian ", "Gan ", "Xie ", "Fu ", "Lian ", "Zu ", "Shen ", "Xi ", "Zhi ", "Zhong ", "Zhou ", "Ban ", "Fu ", "Zhuo ", "Shao ", "Yi ", "Jing ", "Dai ", "Bang ", "Rong ", "Jie ", "Ku ", "Rao ", "Die ", "Heng ", "Hui ", "Gei ", "Xuan ", "Jiang ", "Luo ", "Jue ", "Jiao ", "Tong ", "Geng ", "Xiao ", "Juan ", "Xiu ", "Xi ", "Sui ", "Tao ", "Ji ", "Ti ", "Ji ", "Xu ", "Ling ", "[?] ", "Xu ", "Qi ", "Fei ", "Chuo ", "Zhang ", "Gun ", "Sheng ", "Wei ", "Mian ", "Shou ", "Beng ", "Chou ", "Tao ", "Liu ", "Quan ", "Zong ", "Zhan ", "Wan ", "Lu "];
  }
});

// node_modules/unidecode/data/x7f.js
var require_x7f = __commonJS({
  "node_modules/unidecode/data/x7f.js"(exports2, module2) {
    module2.exports = ["Zhui ", "Zi ", "Ke ", "Xiang ", "Jian ", "Mian ", "Lan ", "Ti ", "Miao ", "Qi ", "Yun ", "Hui ", "Si ", "Duo ", "Duan ", "Bian ", "Xian ", "Gou ", "Zhui ", "Huan ", "Di ", "Lu ", "Bian ", "Min ", "Yuan ", "Jin ", "Fu ", "Ru ", "Zhen ", "Feng ", "Shuai ", "Gao ", "Chan ", "Li ", "Yi ", "Jian ", "Bin ", "Piao ", "Man ", "Lei ", "Ying ", "Suo ", "Mou ", "Sao ", "Xie ", "Liao ", "Shan ", "Zeng ", "Jiang ", "Qian ", "Zao ", "Huan ", "Jiao ", "Zuan ", "Fou ", "Xie ", "Gang ", "Fou ", "Que ", "Fou ", "Kaakeru ", "Bo ", "Ping ", "Hou ", "[?] ", "Gang ", "Ying ", "Ying ", "Qing ", "Xia ", "Guan ", "Zun ", "Tan ", "Chang ", "Qi ", "Weng ", "Ying ", "Lei ", "Tan ", "Lu ", "Guan ", "Wang ", "Wang ", "Gang ", "Wang ", "Han ", "[?] ", "Luo ", "Fu ", "Mi ", "Fa ", "Gu ", "Zhu ", "Ju ", "Mao ", "Gu ", "Min ", "Gang ", "Ba ", "Gua ", "Ti ", "Juan ", "Fu ", "Lin ", "Yan ", "Zhao ", "Zui ", "Gua ", "Zhuo ", "Yu ", "Zhi ", "An ", "Fa ", "Nan ", "Shu ", "Si ", "Pi ", "Ma ", "Liu ", "Ba ", "Fa ", "Li ", "Chao ", "Wei ", "Bi ", "Ji ", "Zeng ", "Tong ", "Liu ", "Ji ", "Juan ", "Mi ", "Zhao ", "Luo ", "Pi ", "Ji ", "Ji ", "Luan ", "Yang ", "Mie ", "Qiang ", "Ta ", "Mei ", "Yang ", "You ", "You ", "Fen ", "Ba ", "Gao ", "Yang ", "Gu ", "Qiang ", "Zang ", "Gao ", "Ling ", "Yi ", "Zhu ", "Di ", "Xiu ", "Qian ", "Yi ", "Xian ", "Rong ", "Qun ", "Qun ", "Qian ", "Huan ", "Zui ", "Xian ", "Yi ", "Yashinau ", "Qiang ", "Xian ", "Yu ", "Geng ", "Jie ", "Tang ", "Yuan ", "Xi ", "Fan ", "Shan ", "Fen ", "Shan ", "Lian ", "Lei ", "Geng ", "Nou ", "Qiang ", "Chan ", "Yu ", "Gong ", "Yi ", "Chong ", "Weng ", "Fen ", "Hong ", "Chi ", "Chi ", "Cui ", "Fu ", "Xia ", "Pen ", "Yi ", "La ", "Yi ", "Pi ", "Ling ", "Liu ", "Zhi ", "Qu ", "Xi ", "Xie ", "Xiang ", "Xi ", "Xi ", "Qi ", "Qiao ", "Hui ", "Hui ", "Xiao ", "Se ", "Hong ", "Jiang ", "Di ", "Cui ", "Fei ", "Tao ", "Sha ", "Chi ", "Zhu ", "Jian ", "Xuan ", "Shi ", "Pian ", "Zong ", "Wan ", "Hui ", "Hou ", "He ", "He ", "Han ", "Ao ", "Piao ", "Yi ", "Lian ", "Qu ", "[?] ", "Lin ", "Pen ", "Qiao ", "Ao ", "Fan ", "Yi ", "Hui ", "Xuan ", "Dao "];
  }
});

// node_modules/unidecode/data/x80.js
var require_x80 = __commonJS({
  "node_modules/unidecode/data/x80.js"(exports2, module2) {
    module2.exports = ["Yao ", "Lao ", "[?] ", "Kao ", "Mao ", "Zhe ", "Qi ", "Gou ", "Gou ", "Gou ", "Die ", "Die ", "Er ", "Shua ", "Ruan ", "Er ", "Nai ", "Zhuan ", "Lei ", "Ting ", "Zi ", "Geng ", "Chao ", "Hao ", "Yun ", "Pa ", "Pi ", "Chi ", "Si ", "Chu ", "Jia ", "Ju ", "He ", "Chu ", "Lao ", "Lun ", "Ji ", "Tang ", "Ou ", "Lou ", "Nou ", "Gou ", "Pang ", "Ze ", "Lou ", "Ji ", "Lao ", "Huo ", "You ", "Mo ", "Huai ", "Er ", "Zhe ", "Ting ", "Ye ", "Da ", "Song ", "Qin ", "Yun ", "Chi ", "Dan ", "Dan ", "Hong ", "Geng ", "Zhi ", "[?] ", "Nie ", "Dan ", "Zhen ", "Che ", "Ling ", "Zheng ", "You ", "Wa ", "Liao ", "Long ", "Zhi ", "Ning ", "Tiao ", "Er ", "Ya ", "Die ", "Gua ", "[?] ", "Lian ", "Hao ", "Sheng ", "Lie ", "Pin ", "Jing ", "Ju ", "Bi ", "Di ", "Guo ", "Wen ", "Xu ", "Ping ", "Cong ", "Shikato ", "[?] ", "Ting ", "Yu ", "Cong ", "Kui ", "Tsuraneru ", "Kui ", "Cong ", "Lian ", "Weng ", "Kui ", "Lian ", "Lian ", "Cong ", "Ao ", "Sheng ", "Song ", "Ting ", "Kui ", "Nie ", "Zhi ", "Dan ", "Ning ", "Qie ", "Ji ", "Ting ", "Ting ", "Long ", "Yu ", "Yu ", "Zhao ", "Si ", "Su ", "Yi ", "Su ", "Si ", "Zhao ", "Zhao ", "Rou ", "Yi ", "Le ", "Ji ", "Qiu ", "Ken ", "Cao ", "Ge ", "Di ", "Huan ", "Huang ", "Yi ", "Ren ", "Xiao ", "Ru ", "Zhou ", "Yuan ", "Du ", "Gang ", "Rong ", "Gan ", "Cha ", "Wo ", "Chang ", "Gu ", "Zhi ", "Han ", "Fu ", "Fei ", "Fen ", "Pei ", "Pang ", "Jian ", "Fang ", "Zhun ", "You ", "Na ", "Hang ", "Ken ", "Ran ", "Gong ", "Yu ", "Wen ", "Yao ", "Jin ", "Pi ", "Qian ", "Xi ", "Xi ", "Fei ", "Ken ", "Jing ", "Tai ", "Shen ", "Zhong ", "Zhang ", "Xie ", "Shen ", "Wei ", "Zhou ", "Die ", "Dan ", "Fei ", "Ba ", "Bo ", "Qu ", "Tian ", "Bei ", "Gua ", "Tai ", "Zi ", "Ku ", "Zhi ", "Ni ", "Ping ", "Zi ", "Fu ", "Pang ", "Zhen ", "Xian ", "Zuo ", "Pei ", "Jia ", "Sheng ", "Zhi ", "Bao ", "Mu ", "Qu ", "Hu ", "Ke ", "Yi ", "Yin ", "Xu ", "Yang ", "Long ", "Dong ", "Ka ", "Lu ", "Jing ", "Nu ", "Yan ", "Pang ", "Kua ", "Yi ", "Guang ", "Gai ", "Ge ", "Dong ", "Zhi ", "Xiao ", "Xiong ", "Xiong ", "Er ", "E ", "Xing ", "Pian ", "Neng ", "Zi ", "Gui "];
  }
});

// node_modules/unidecode/data/x81.js
var require_x81 = __commonJS({
  "node_modules/unidecode/data/x81.js"(exports2, module2) {
    module2.exports = ["Cheng ", "Tiao ", "Zhi ", "Cui ", "Mei ", "Xie ", "Cui ", "Xie ", "Mo ", "Mai ", "Ji ", "Obiyaakasu ", "[?] ", "Kuai ", "Sa ", "Zang ", "Qi ", "Nao ", "Mi ", "Nong ", "Luan ", "Wan ", "Bo ", "Wen ", "Guan ", "Qiu ", "Jiao ", "Jing ", "Rou ", "Heng ", "Cuo ", "Lie ", "Shan ", "Ting ", "Mei ", "Chun ", "Shen ", "Xie ", "De ", "Zui ", "Cu ", "Xiu ", "Xin ", "Tuo ", "Pao ", "Cheng ", "Nei ", "Fu ", "Dou ", "Tuo ", "Niao ", "Noy ", "Pi ", "Gu ", "Gua ", "Li ", "Lian ", "Zhang ", "Cui ", "Jie ", "Liang ", "Zhou ", "Pi ", "Biao ", "Lun ", "Pian ", "Guo ", "Kui ", "Chui ", "Dan ", "Tian ", "Nei ", "Jing ", "Jie ", "La ", "Yi ", "An ", "Ren ", "Shen ", "Chuo ", "Fu ", "Fu ", "Ju ", "Fei ", "Qiang ", "Wan ", "Dong ", "Pi ", "Guo ", "Zong ", "Ding ", "Wu ", "Mei ", "Ruan ", "Zhuan ", "Zhi ", "Cou ", "Gua ", "Ou ", "Di ", "An ", "Xing ", "Nao ", "Yu ", "Chuan ", "Nan ", "Yun ", "Zhong ", "Rou ", "E ", "Sai ", "Tu ", "Yao ", "Jian ", "Wei ", "Jiao ", "Yu ", "Jia ", "Duan ", "Bi ", "Chang ", "Fu ", "Xian ", "Ni ", "Mian ", "Wa ", "Teng ", "Tui ", "Bang ", "Qian ", "Lu ", "Wa ", "Sou ", "Tang ", "Su ", "Zhui ", "Ge ", "Yi ", "Bo ", "Liao ", "Ji ", "Pi ", "Xie ", "Gao ", "Lu ", "Bin ", "Ou ", "Chang ", "Lu ", "Guo ", "Pang ", "Chuai ", "Piao ", "Jiang ", "Fu ", "Tang ", "Mo ", "Xi ", "Zhuan ", "Lu ", "Jiao ", "Ying ", "Lu ", "Zhi ", "Tara ", "Chun ", "Lian ", "Tong ", "Peng ", "Ni ", "Zha ", "Liao ", "Cui ", "Gui ", "Xiao ", "Teng ", "Fan ", "Zhi ", "Jiao ", "Shan ", "Wu ", "Cui ", "Run ", "Xiang ", "Sui ", "Fen ", "Ying ", "Tan ", "Zhua ", "Dan ", "Kuai ", "Nong ", "Tun ", "Lian ", "Bi ", "Yong ", "Jue ", "Chu ", "Yi ", "Juan ", "La ", "Lian ", "Sao ", "Tun ", "Gu ", "Qi ", "Cui ", "Bin ", "Xun ", "Ru ", "Huo ", "Zang ", "Xian ", "Biao ", "Xing ", "Kuan ", "La ", "Yan ", "Lu ", "Huo ", "Zang ", "Luo ", "Qu ", "Zang ", "Luan ", "Ni ", "Zang ", "Chen ", "Qian ", "Wo ", "Guang ", "Zang ", "Lin ", "Guang ", "Zi ", "Jiao ", "Nie ", "Chou ", "Ji ", "Gao ", "Chou ", "Mian ", "Nie ", "Zhi ", "Zhi ", "Ge ", "Jian ", "Die ", "Zhi ", "Xiu ", "Tai ", "Zhen ", "Jiu ", "Xian ", "Yu ", "Cha "];
  }
});

// node_modules/unidecode/data/x82.js
var require_x82 = __commonJS({
  "node_modules/unidecode/data/x82.js"(exports2, module2) {
    module2.exports = ["Yao ", "Yu ", "Chong ", "Xi ", "Xi ", "Jiu ", "Yu ", "Yu ", "Xing ", "Ju ", "Jiu ", "Xin ", "She ", "She ", "Yadoru ", "Jiu ", "Shi ", "Tan ", "Shu ", "Shi ", "Tian ", "Dan ", "Pu ", "Pu ", "Guan ", "Hua ", "Tan ", "Chuan ", "Shun ", "Xia ", "Wu ", "Zhou ", "Dao ", "Gang ", "Shan ", "Yi ", "[?] ", "Pa ", "Tai ", "Fan ", "Ban ", "Chuan ", "Hang ", "Fang ", "Ban ", "Que ", "Hesaki ", "Zhong ", "Jian ", "Cang ", "Ling ", "Zhu ", "Ze ", "Duo ", "Bo ", "Xian ", "Ge ", "Chuan ", "Jia ", "Lu ", "Hong ", "Pang ", "Xi ", "[?] ", "Fu ", "Zao ", "Feng ", "Li ", "Shao ", "Yu ", "Lang ", "Ting ", "[?] ", "Wei ", "Bo ", "Meng ", "Nian ", "Ju ", "Huang ", "Shou ", "Zong ", "Bian ", "Mao ", "Die ", "[?] ", "Bang ", "Cha ", "Yi ", "Sao ", "Cang ", "Cao ", "Lou ", "Dai ", "Sori ", "Yao ", "Tong ", "Yofune ", "Dang ", "Tan ", "Lu ", "Yi ", "Jie ", "Jian ", "Huo ", "Meng ", "Qi ", "Lu ", "Lu ", "Chan ", "Shuang ", "Gen ", "Liang ", "Jian ", "Jian ", "Se ", "Yan ", "Fu ", "Ping ", "Yan ", "Yan ", "Cao ", "Cao ", "Yi ", "Le ", "Ting ", "Qiu ", "Ai ", "Nai ", "Tiao ", "Jiao ", "Jie ", "Peng ", "Wan ", "Yi ", "Chai ", "Mian ", "Mie ", "Gan ", "Qian ", "Yu ", "Yu ", "Shuo ", "Qiong ", "Tu ", "Xia ", "Qi ", "Mang ", "Zi ", "Hui ", "Sui ", "Zhi ", "Xiang ", "Bi ", "Fu ", "Tun ", "Wei ", "Wu ", "Zhi ", "Qi ", "Shan ", "Wen ", "Qian ", "Ren ", "Fou ", "Kou ", "Jie ", "Lu ", "Xu ", "Ji ", "Qin ", "Qi ", "Yuan ", "Fen ", "Ba ", "Rui ", "Xin ", "Ji ", "Hua ", "Hua ", "Fang ", "Wu ", "Jue ", "Gou ", "Zhi ", "Yun ", "Qin ", "Ao ", "Chu ", "Mao ", "Ya ", "Fei ", "Reng ", "Hang ", "Cong ", "Yin ", "You ", "Bian ", "Yi ", "Susa ", "Wei ", "Li ", "Pi ", "E ", "Xian ", "Chang ", "Cang ", "Meng ", "Su ", "Yi ", "Yuan ", "Ran ", "Ling ", "Tai ", "Tiao ", "Di ", "Miao ", "Qiong ", "Li ", "Yong ", "Ke ", "Mu ", "Pei ", "Bao ", "Gou ", "Min ", "Yi ", "Yi ", "Ju ", "Pi ", "Ruo ", "Ku ", "Zhu ", "Ni ", "Bo ", "Bing ", "Shan ", "Qiu ", "Yao ", "Xian ", "Ben ", "Hong ", "Ying ", "Zha ", "Dong ", "Ju ", "Die ", "Nie ", "Gan ", "Hu ", "Ping ", "Mei ", "Fu ", "Sheng ", "Gu ", "Bi ", "Wei "];
  }
});

// node_modules/unidecode/data/x83.js
var require_x83 = __commonJS({
  "node_modules/unidecode/data/x83.js"(exports2, module2) {
    module2.exports = ["Fu ", "Zhuo ", "Mao ", "Fan ", "Qie ", "Mao ", "Mao ", "Ba ", "Zi ", "Mo ", "Zi ", "Di ", "Chi ", "Ji ", "Jing ", "Long ", "[?] ", "Niao ", "[?] ", "Xue ", "Ying ", "Qiong ", "Ge ", "Ming ", "Li ", "Rong ", "Yin ", "Gen ", "Qian ", "Chai ", "Chen ", "Yu ", "Xiu ", "Zi ", "Lie ", "Wu ", "Ji ", "Kui ", "Ce ", "Chong ", "Ci ", "Gou ", "Guang ", "Mang ", "Chi ", "Jiao ", "Jiao ", "Fu ", "Yu ", "Zhu ", "Zi ", "Jiang ", "Hui ", "Yin ", "Cha ", "Fa ", "Rong ", "Ru ", "Chong ", "Mang ", "Tong ", "Zhong ", "[?] ", "Zhu ", "Xun ", "Huan ", "Kua ", "Quan ", "Gai ", "Da ", "Jing ", "Xing ", "Quan ", "Cao ", "Jing ", "Er ", "An ", "Shou ", "Chi ", "Ren ", "Jian ", "Ti ", "Huang ", "Ping ", "Li ", "Jin ", "Lao ", "Shu ", "Zhuang ", "Da ", "Jia ", "Rao ", "Bi ", "Ze ", "Qiao ", "Hui ", "Qi ", "Dang ", "[?] ", "Rong ", "Hun ", "Ying ", "Luo ", "Ying ", "Xun ", "Jin ", "Sun ", "Yin ", "Mai ", "Hong ", "Zhou ", "Yao ", "Du ", "Wei ", "Chu ", "Dou ", "Fu ", "Ren ", "Yin ", "He ", "Bi ", "Bu ", "Yun ", "Di ", "Tu ", "Sui ", "Sui ", "Cheng ", "Chen ", "Wu ", "Bie ", "Xi ", "Geng ", "Li ", "Fu ", "Zhu ", "Mo ", "Li ", "Zhuang ", "Ji ", "Duo ", "Qiu ", "Sha ", "Suo ", "Chen ", "Feng ", "Ju ", "Mei ", "Meng ", "Xing ", "Jing ", "Che ", "Xin ", "Jun ", "Yan ", "Ting ", "Diao ", "Cuo ", "Wan ", "Han ", "You ", "Cuo ", "Jia ", "Wang ", "You ", "Niu ", "Shao ", "Xian ", "Lang ", "Fu ", "E ", "Mo ", "Wen ", "Jie ", "Nan ", "Mu ", "Kan ", "Lai ", "Lian ", "Shi ", "Wo ", "Usagi ", "Lian ", "Huo ", "You ", "Ying ", "Ying ", "Nuc ", "Chun ", "Mang ", "Mang ", "Ci ", "Wan ", "Jing ", "Di ", "Qu ", "Dong ", "Jian ", "Zou ", "Gu ", "La ", "Lu ", "Ju ", "Wei ", "Jun ", "Nie ", "Kun ", "He ", "Pu ", "Zi ", "Gao ", "Guo ", "Fu ", "Lun ", "Chang ", "Chou ", "Song ", "Chui ", "Zhan ", "Men ", "Cai ", "Ba ", "Li ", "Tu ", "Bo ", "Han ", "Bao ", "Qin ", "Juan ", "Xi ", "Qin ", "Di ", "Jie ", "Pu ", "Dang ", "Jin ", "Zhao ", "Tai ", "Geng ", "Hua ", "Gu ", "Ling ", "Fei ", "Jin ", "An ", "Wang ", "Beng ", "Zhou ", "Yan ", "Ju ", "Jian ", "Lin ", "Tan ", "Shu ", "Tian ", "Dao "];
  }
});

// node_modules/unidecode/data/x84.js
var require_x84 = __commonJS({
  "node_modules/unidecode/data/x84.js"(exports2, module2) {
    module2.exports = ["Hu ", "Qi ", "He ", "Cui ", "Tao ", "Chun ", "Bei ", "Chang ", "Huan ", "Fei ", "Lai ", "Qi ", "Meng ", "Ping ", "Wei ", "Dan ", "Sha ", "Huan ", "Yan ", "Yi ", "Tiao ", "Qi ", "Wan ", "Ce ", "Nai ", "Kutabireru ", "Tuo ", "Jiu ", "Tie ", "Luo ", "[?] ", "[?] ", "Meng ", "[?] ", "Yaji ", "[?] ", "Ying ", "Ying ", "Ying ", "Xiao ", "Sa ", "Qiu ", "Ke ", "Xiang ", "Wan ", "Yu ", "Yu ", "Fu ", "Lian ", "Xuan ", "Yuan ", "Nan ", "Ze ", "Wo ", "Chun ", "Xiao ", "Yu ", "Pian ", "Mao ", "An ", "E ", "Luo ", "Ying ", "Huo ", "Gua ", "Jiang ", "Mian ", "Zuo ", "Zuo ", "Ju ", "Bao ", "Rou ", "Xi ", "Xie ", "An ", "Qu ", "Jian ", "Fu ", "Lu ", "Jing ", "Pen ", "Feng ", "Hong ", "Hong ", "Hou ", "Yan ", "Tu ", "Zhu ", "Zi ", "Xiang ", "Shen ", "Ge ", "Jie ", "Jing ", "Mi ", "Huang ", "Shen ", "Pu ", "Gai ", "Dong ", "Zhou ", "Qian ", "Wei ", "Bo ", "Wei ", "Pa ", "Ji ", "Hu ", "Zang ", "Jia ", "Duan ", "Yao ", "Jun ", "Cong ", "Quan ", "Wei ", "Xian ", "Kui ", "Ting ", "Hun ", "Xi ", "Shi ", "Qi ", "Lan ", "Zong ", "Yao ", "Yuan ", "Mei ", "Yun ", "Shu ", "Di ", "Zhuan ", "Guan ", "Sukumo ", "Xue ", "Chan ", "Kai ", "Kui ", "[?] ", "Jiang ", "Lou ", "Wei ", "Pai ", "[?] ", "Sou ", "Yin ", "Shi ", "Chun ", "Shi ", "Yun ", "Zhen ", "Lang ", "Nu ", "Meng ", "He ", "Que ", "Suan ", "Yuan ", "Li ", "Ju ", "Xi ", "Pang ", "Chu ", "Xu ", "Tu ", "Liu ", "Wo ", "Zhen ", "Qian ", "Zu ", "Po ", "Cuo ", "Yuan ", "Chu ", "Yu ", "Kuai ", "Pan ", "Pu ", "Pu ", "Na ", "Shuo ", "Xi ", "Fen ", "Yun ", "Zheng ", "Jian ", "Ji ", "Ruo ", "Cang ", "En ", "Mi ", "Hao ", "Sun ", "Zhen ", "Ming ", "Sou ", "Xu ", "Liu ", "Xi ", "Gu ", "Lang ", "Rong ", "Weng ", "Gai ", "Cuo ", "Shi ", "Tang ", "Luo ", "Ru ", "Suo ", "Xian ", "Bei ", "Yao ", "Gui ", "Bi ", "Zong ", "Gun ", "Za ", "Xiu ", "Ce ", "Hai ", "Lan ", "[?] ", "Ji ", "Li ", "Can ", "Lang ", "Yu ", "[?] ", "Ying ", "Mo ", "Diao ", "Tiao ", "Mao ", "Tong ", "Zhu ", "Peng ", "An ", "Lian ", "Cong ", "Xi ", "Ping ", "Qiu ", "Jin ", "Chun ", "Jie ", "Wei ", "Tui ", "Cao ", "Yu ", "Yi ", "Ji ", "Liao ", "Bi ", "Lu ", "Su "];
  }
});

// node_modules/unidecode/data/x85.js
var require_x85 = __commonJS({
  "node_modules/unidecode/data/x85.js"(exports2, module2) {
    module2.exports = ["Bu ", "Zhang ", "Luo ", "Jiang ", "Man ", "Yan ", "Ling ", "Ji ", "Piao ", "Gun ", "Han ", "Di ", "Su ", "Lu ", "She ", "Shang ", "Di ", "Mie ", "Xun ", "Man ", "Bo ", "Di ", "Cuo ", "Zhe ", "Sen ", "Xuan ", "Wei ", "Hu ", "Ao ", "Mi ", "Lou ", "Cu ", "Zhong ", "Cai ", "Po ", "Jiang ", "Mi ", "Cong ", "Niao ", "Hui ", "Jun ", "Yin ", "Jian ", "Yan ", "Shu ", "Yin ", "Kui ", "Chen ", "Hu ", "Sha ", "Kou ", "Qian ", "Ma ", "Zang ", "Sonoko ", "Qiang ", "Dou ", "Lian ", "Lin ", "Kou ", "Ai ", "Bi ", "Li ", "Wei ", "Ji ", "Xun ", "Sheng ", "Fan ", "Meng ", "Ou ", "Chan ", "Dian ", "Xun ", "Jiao ", "Rui ", "Rui ", "Lei ", "Yu ", "Qiao ", "Chu ", "Hua ", "Jian ", "Mai ", "Yun ", "Bao ", "You ", "Qu ", "Lu ", "Rao ", "Hui ", "E ", "Teng ", "Fei ", "Jue ", "Zui ", "Fa ", "Ru ", "Fen ", "Kui ", "Shun ", "Rui ", "Ya ", "Xu ", "Fu ", "Jue ", "Dang ", "Wu ", "Tong ", "Si ", "Xiao ", "Xi ", "Long ", "Yun ", "[?] ", "Qi ", "Jian ", "Yun ", "Sun ", "Ling ", "Yu ", "Xia ", "Yong ", "Ji ", "Hong ", "Si ", "Nong ", "Lei ", "Xuan ", "Yun ", "Yu ", "Xi ", "Hao ", "Bo ", "Hao ", "Ai ", "Wei ", "Hui ", "Wei ", "Ji ", "Ci ", "Xiang ", "Luan ", "Mie ", "Yi ", "Leng ", "Jiang ", "Can ", "Shen ", "Qiang ", "Lian ", "Ke ", "Yuan ", "Da ", "Ti ", "Tang ", "Xie ", "Bi ", "Zhan ", "Sun ", "Lian ", "Fan ", "Ding ", "Jie ", "Gu ", "Xie ", "Shu ", "Jian ", "Kao ", "Hong ", "Sa ", "Xin ", "Xun ", "Yao ", "Hie ", "Sou ", "Shu ", "Xun ", "Dui ", "Pin ", "Wei ", "Neng ", "Chou ", "Mai ", "Ru ", "Piao ", "Tai ", "Qi ", "Zao ", "Chen ", "Zhen ", "Er ", "Ni ", "Ying ", "Gao ", "Cong ", "Xiao ", "Qi ", "Fa ", "Jian ", "Xu ", "Kui ", "Jie ", "Bian ", "Diao ", "Mi ", "Lan ", "Jin ", "Cang ", "Miao ", "Qiong ", "Qie ", "Xian ", "[?] ", "Ou ", "Xian ", "Su ", "Lu ", "Yi ", "Xu ", "Xie ", "Li ", "Yi ", "La ", "Lei ", "Xiao ", "Di ", "Zhi ", "Bei ", "Teng ", "Yao ", "Mo ", "Huan ", "Piao ", "Fan ", "Sou ", "Tan ", "Tui ", "Qiong ", "Qiao ", "Wei ", "Liu ", "Hui ", "[?] ", "Gao ", "Yun ", "[?] ", "Li ", "Shu ", "Chu ", "Ai ", "Lin ", "Zao ", "Xuan ", "Chen ", "Lai ", "Huo "];
  }
});

// node_modules/unidecode/data/x86.js
var require_x86 = __commonJS({
  "node_modules/unidecode/data/x86.js"(exports2, module2) {
    module2.exports = ["Tuo ", "Wu ", "Rui ", "Rui ", "Qi ", "Heng ", "Lu ", "Su ", "Tui ", "Mang ", "Yun ", "Pin ", "Yu ", "Xun ", "Ji ", "Jiong ", "Xian ", "Mo ", "Hagi ", "Su ", "Jiong ", "[?] ", "Nie ", "Bo ", "Rang ", "Yi ", "Xian ", "Yu ", "Ju ", "Lian ", "Lian ", "Yin ", "Qiang ", "Ying ", "Long ", "Tong ", "Wei ", "Yue ", "Ling ", "Qu ", "Yao ", "Fan ", "Mi ", "Lan ", "Kui ", "Lan ", "Ji ", "Dang ", "Katsura ", "Lei ", "Lei ", "Hua ", "Feng ", "Zhi ", "Wei ", "Kui ", "Zhan ", "Huai ", "Li ", "Ji ", "Mi ", "Lei ", "Huai ", "Luo ", "Ji ", "Kui ", "Lu ", "Jian ", "San ", "[?] ", "Lei ", "Quan ", "Xiao ", "Yi ", "Luan ", "Men ", "Bie ", "Hu ", "Hu ", "Lu ", "Nue ", "Lu ", "Si ", "Xiao ", "Qian ", "Chu ", "Hu ", "Xu ", "Cuo ", "Fu ", "Xu ", "Xu ", "Lu ", "Hu ", "Yu ", "Hao ", "Jiao ", "Ju ", "Guo ", "Bao ", "Yan ", "Zhan ", "Zhan ", "Kui ", "Ban ", "Xi ", "Shu ", "Chong ", "Qiu ", "Diao ", "Ji ", "Qiu ", "Cheng ", "Shi ", "[?] ", "Di ", "Zhe ", "She ", "Yu ", "Gan ", "Zi ", "Hong ", "Hui ", "Meng ", "Ge ", "Sui ", "Xia ", "Chai ", "Shi ", "Yi ", "Ma ", "Xiang ", "Fang ", "E ", "Pa ", "Chi ", "Qian ", "Wen ", "Wen ", "Rui ", "Bang ", "Bi ", "Yue ", "Yue ", "Jun ", "Qi ", "Ran ", "Yin ", "Qi ", "Tian ", "Yuan ", "Jue ", "Hui ", "Qin ", "Qi ", "Zhong ", "Ya ", "Ci ", "Mu ", "Wang ", "Fen ", "Fen ", "Hang ", "Gong ", "Zao ", "Fu ", "Ran ", "Jie ", "Fu ", "Chi ", "Dou ", "Piao ", "Xian ", "Ni ", "Te ", "Qiu ", "You ", "Zha ", "Ping ", "Chi ", "You ", "He ", "Han ", "Ju ", "Li ", "Fu ", "Ran ", "Zha ", "Gou ", "Pi ", "Bo ", "Xian ", "Zhu ", "Diao ", "Bie ", "Bing ", "Gu ", "Ran ", "Qu ", "She ", "Tie ", "Ling ", "Gu ", "Dan ", "Gu ", "Ying ", "Li ", "Cheng ", "Qu ", "Mou ", "Ge ", "Ci ", "Hui ", "Hui ", "Mang ", "Fu ", "Yang ", "Wa ", "Lie ", "Zhu ", "Yi ", "Xian ", "Kuo ", "Jiao ", "Li ", "Yi ", "Ping ", "Ji ", "Ha ", "She ", "Yi ", "Wang ", "Mo ", "Qiong ", "Qie ", "Gui ", "Gong ", "Zhi ", "Man ", "Ebi ", "Zhi ", "Jia ", "Rao ", "Si ", "Qi ", "Xing ", "Lie ", "Qiu ", "Shao ", "Yong ", "Jia ", "Shui ", "Che ", "Bai ", "E ", "Han "];
  }
});

// node_modules/unidecode/data/x87.js
var require_x87 = __commonJS({
  "node_modules/unidecode/data/x87.js"(exports2, module2) {
    module2.exports = ["Shu ", "Xuan ", "Feng ", "Shen ", "Zhen ", "Fu ", "Xian ", "Zhe ", "Wu ", "Fu ", "Li ", "Lang ", "Bi ", "Chu ", "Yuan ", "You ", "Jie ", "Dan ", "Yan ", "Ting ", "Dian ", "Shui ", "Hui ", "Gua ", "Zhi ", "Song ", "Fei ", "Ju ", "Mi ", "Qi ", "Qi ", "Yu ", "Jun ", "Zha ", "Meng ", "Qiang ", "Si ", "Xi ", "Lun ", "Li ", "Die ", "Tiao ", "Tao ", "Kun ", "Gan ", "Han ", "Yu ", "Bang ", "Fei ", "Pi ", "Wei ", "Dun ", "Yi ", "Yuan ", "Su ", "Quan ", "Qian ", "Rui ", "Ni ", "Qing ", "Wei ", "Liang ", "Guo ", "Wan ", "Dong ", "E ", "Ban ", "Di ", "Wang ", "Can ", "Yang ", "Ying ", "Guo ", "Chan ", "[?] ", "La ", "Ke ", "Ji ", "He ", "Ting ", "Mai ", "Xu ", "Mian ", "Yu ", "Jie ", "Shi ", "Xuan ", "Huang ", "Yan ", "Bian ", "Rou ", "Wei ", "Fu ", "Yuan ", "Mei ", "Wei ", "Fu ", "Ruan ", "Xie ", "You ", "Qiu ", "Mao ", "Xia ", "Ying ", "Shi ", "Chong ", "Tang ", "Zhu ", "Zong ", "Ti ", "Fu ", "Yuan ", "Hui ", "Meng ", "La ", "Du ", "Hu ", "Qiu ", "Die ", "Li ", "Gua ", "Yun ", "Ju ", "Nan ", "Lou ", "Qun ", "Rong ", "Ying ", "Jiang ", "[?] ", "Lang ", "Pang ", "Si ", "Xi ", "Ci ", "Xi ", "Yuan ", "Weng ", "Lian ", "Sou ", "Ban ", "Rong ", "Rong ", "Ji ", "Wu ", "Qiu ", "Han ", "Qin ", "Yi ", "Bi ", "Hua ", "Tang ", "Yi ", "Du ", "Nai ", "He ", "Hu ", "Hui ", "Ma ", "Ming ", "Yi ", "Wen ", "Ying ", "Teng ", "Yu ", "Cang ", "So ", "Ebi ", "Man ", "[?] ", "Shang ", "Zhe ", "Cao ", "Chi ", "Di ", "Ao ", "Lu ", "Wei ", "Zhi ", "Tang ", "Chen ", "Piao ", "Qu ", "Pi ", "Yu ", "Jian ", "Luo ", "Lou ", "Qin ", "Zhong ", "Yin ", "Jiang ", "Shuai ", "Wen ", "Jiao ", "Wan ", "Zhi ", "Zhe ", "Ma ", "Ma ", "Guo ", "Liu ", "Mao ", "Xi ", "Cong ", "Li ", "Man ", "Xiao ", "Kamakiri ", "Zhang ", "Mang ", "Xiang ", "Mo ", "Zui ", "Si ", "Qiu ", "Te ", "Zhi ", "Peng ", "Peng ", "Jiao ", "Qu ", "Bie ", "Liao ", "Pan ", "Gui ", "Xi ", "Ji ", "Zhuan ", "Huang ", "Fei ", "Lao ", "Jue ", "Jue ", "Hui ", "Yin ", "Chan ", "Jiao ", "Shan ", "Rao ", "Xiao ", "Mou ", "Chong ", "Xun ", "Si ", "[?] ", "Cheng ", "Dang ", "Li ", "Xie ", "Shan ", "Yi ", "Jing ", "Da ", "Chan ", "Qi "];
  }
});

// node_modules/unidecode/data/x88.js
var require_x88 = __commonJS({
  "node_modules/unidecode/data/x88.js"(exports2, module2) {
    module2.exports = ["Ci ", "Xiang ", "She ", "Luo ", "Qin ", "Ying ", "Chai ", "Li ", "Ze ", "Xuan ", "Lian ", "Zhu ", "Ze ", "Xie ", "Mang ", "Xie ", "Qi ", "Rong ", "Jian ", "Meng ", "Hao ", "Ruan ", "Huo ", "Zhuo ", "Jie ", "Bin ", "He ", "Mie ", "Fan ", "Lei ", "Jie ", "La ", "Mi ", "Li ", "Chun ", "Li ", "Qiu ", "Nie ", "Lu ", "Du ", "Xiao ", "Zhu ", "Long ", "Li ", "Long ", "Feng ", "Ye ", "Beng ", "Shang ", "Gu ", "Juan ", "Ying ", "[?] ", "Xi ", "Can ", "Qu ", "Quan ", "Du ", "Can ", "Man ", "Jue ", "Jie ", "Zhu ", "Zha ", "Xie ", "Huang ", "Niu ", "Pei ", "Nu ", "Xin ", "Zhong ", "Mo ", "Er ", "Ke ", "Mie ", "Xi ", "Xing ", "Yan ", "Kan ", "Yuan ", "[?] ", "Ling ", "Xuan ", "Shu ", "Xian ", "Tong ", "Long ", "Jie ", "Xian ", "Ya ", "Hu ", "Wei ", "Dao ", "Chong ", "Wei ", "Dao ", "Zhun ", "Heng ", "Qu ", "Yi ", "Yi ", "Bu ", "Gan ", "Yu ", "Biao ", "Cha ", "Yi ", "Shan ", "Chen ", "Fu ", "Gun ", "Fen ", "Shuai ", "Jie ", "Na ", "Zhong ", "Dan ", "Ri ", "Zhong ", "Zhong ", "Xie ", "Qi ", "Xie ", "Ran ", "Zhi ", "Ren ", "Qin ", "Jin ", "Jun ", "Yuan ", "Mei ", "Chai ", "Ao ", "Niao ", "Hui ", "Ran ", "Jia ", "Tuo ", "Ling ", "Dai ", "Bao ", "Pao ", "Yao ", "Zuo ", "Bi ", "Shao ", "Tan ", "Ju ", "He ", "Shu ", "Xiu ", "Zhen ", "Yi ", "Pa ", "Bo ", "Di ", "Wa ", "Fu ", "Gun ", "Zhi ", "Zhi ", "Ran ", "Pan ", "Yi ", "Mao ", "Tuo ", "Na ", "Kou ", "Xian ", "Chan ", "Qu ", "Bei ", "Gun ", "Xi ", "Ne ", "Bo ", "Horo ", "Fu ", "Yi ", "Chi ", "Ku ", "Ren ", "Jiang ", "Jia ", "Cun ", "Mo ", "Jie ", "Er ", "Luo ", "Ru ", "Zhu ", "Gui ", "Yin ", "Cai ", "Lie ", "Kamishimo ", "Yuki ", "Zhuang ", "Dang ", "[?] ", "Kun ", "Ken ", "Niao ", "Shu ", "Jia ", "Kun ", "Cheng ", "Li ", "Juan ", "Shen ", "Pou ", "Ge ", "Yi ", "Yu ", "Zhen ", "Liu ", "Qiu ", "Qun ", "Ji ", "Yi ", "Bu ", "Zhuang ", "Shui ", "Sha ", "Qun ", "Li ", "Lian ", "Lian ", "Ku ", "Jian ", "Fou ", "Chan ", "Bi ", "Gun ", "Tao ", "Yuan ", "Ling ", "Chi ", "Chang ", "Chou ", "Duo ", "Biao ", "Liang ", "Chang ", "Pei ", "Pei ", "Fei ", "Yuan ", "Luo ", "Guo ", "Yan ", "Du ", "Xi ", "Zhi ", "Ju ", "Qi "];
  }
});

// node_modules/unidecode/data/x89.js
var require_x89 = __commonJS({
  "node_modules/unidecode/data/x89.js"(exports2, module2) {
    module2.exports = ["Ji ", "Zhi ", "Gua ", "Ken ", "Che ", "Ti ", "Ti ", "Fu ", "Chong ", "Xie ", "Bian ", "Die ", "Kun ", "Duan ", "Xiu ", "Xiu ", "He ", "Yuan ", "Bao ", "Bao ", "Fu ", "Yu ", "Tuan ", "Yan ", "Hui ", "Bei ", "Chu ", "Lu ", "Ena ", "Hitoe ", "Yun ", "Da ", "Gou ", "Da ", "Huai ", "Rong ", "Yuan ", "Ru ", "Nai ", "Jiong ", "Suo ", "Ban ", "Tun ", "Chi ", "Sang ", "Niao ", "Ying ", "Jie ", "Qian ", "Huai ", "Ku ", "Lian ", "Bao ", "Li ", "Zhe ", "Shi ", "Lu ", "Yi ", "Die ", "Xie ", "Xian ", "Wei ", "Biao ", "Cao ", "Ji ", "Jiang ", "Sen ", "Bao ", "Xiang ", "Chihaya ", "Pu ", "Jian ", "Zhuan ", "Jian ", "Zui ", "Ji ", "Dan ", "Za ", "Fan ", "Bo ", "Xiang ", "Xin ", "Bie ", "Rao ", "Man ", "Lan ", "Ao ", "Duo ", "Gui ", "Cao ", "Sui ", "Nong ", "Chan ", "Lian ", "Bi ", "Jin ", "Dang ", "Shu ", "Tan ", "Bi ", "Lan ", "Pu ", "Ru ", "Zhi ", "[?] ", "Shu ", "Wa ", "Shi ", "Bai ", "Xie ", "Bo ", "Chen ", "Lai ", "Long ", "Xi ", "Xian ", "Lan ", "Zhe ", "Dai ", "Tasuki ", "Zan ", "Shi ", "Jian ", "Pan ", "Yi ", "Ran ", "Ya ", "Xi ", "Xi ", "Yao ", "Feng ", "Tan ", "[?] ", "Biao ", "Fu ", "Ba ", "He ", "Ji ", "Ji ", "Jian ", "Guan ", "Bian ", "Yan ", "Gui ", "Jue ", "Pian ", "Mao ", "Mi ", "Mi ", "Mie ", "Shi ", "Si ", "Zhan ", "Luo ", "Jue ", "Mi ", "Tiao ", "Lian ", "Yao ", "Zhi ", "Jun ", "Xi ", "Shan ", "Wei ", "Xi ", "Tian ", "Yu ", "Lan ", "E ", "Du ", "Qin ", "Pang ", "Ji ", "Ming ", "Ying ", "Gou ", "Qu ", "Zhan ", "Jin ", "Guan ", "Deng ", "Jian ", "Luo ", "Qu ", "Jian ", "Wei ", "Jue ", "Qu ", "Luo ", "Lan ", "Shen ", "Di ", "Guan ", "Jian ", "Guan ", "Yan ", "Gui ", "Mi ", "Shi ", "Zhan ", "Lan ", "Jue ", "Ji ", "Xi ", "Di ", "Tian ", "Yu ", "Gou ", "Jin ", "Qu ", "Jiao ", "Jiu ", "Jin ", "Cu ", "Jue ", "Zhi ", "Chao ", "Ji ", "Gu ", "Dan ", "Zui ", "Di ", "Shang ", "Hua ", "Quan ", "Ge ", "Chi ", "Jie ", "Gui ", "Gong ", "Hong ", "Jie ", "Hun ", "Qiu ", "Xing ", "Su ", "Ni ", "Ji ", "Lu ", "Zhi ", "Zha ", "Bi ", "Xing ", "Hu ", "Shang ", "Gong ", "Zhi ", "Xue ", "Chu ", "Xi ", "Yi ", "Lu ", "Jue ", "Xi ", "Yan ", "Xi "];
  }
});

// node_modules/unidecode/data/x8a.js
var require_x8a = __commonJS({
  "node_modules/unidecode/data/x8a.js"(exports2, module2) {
    module2.exports = ["Yan ", "Yan ", "Ding ", "Fu ", "Qiu ", "Qiu ", "Jiao ", "Hong ", "Ji ", "Fan ", "Xun ", "Diao ", "Hong ", "Cha ", "Tao ", "Xu ", "Jie ", "Yi ", "Ren ", "Xun ", "Yin ", "Shan ", "Qi ", "Tuo ", "Ji ", "Xun ", "Yin ", "E ", "Fen ", "Ya ", "Yao ", "Song ", "Shen ", "Yin ", "Xin ", "Jue ", "Xiao ", "Ne ", "Chen ", "You ", "Zhi ", "Xiong ", "Fang ", "Xin ", "Chao ", "She ", "Xian ", "Sha ", "Tun ", "Xu ", "Yi ", "Yi ", "Su ", "Chi ", "He ", "Shen ", "He ", "Xu ", "Zhen ", "Zhu ", "Zheng ", "Gou ", "Zi ", "Zi ", "Zhan ", "Gu ", "Fu ", "Quan ", "Die ", "Ling ", "Di ", "Yang ", "Li ", "Nao ", "Pan ", "Zhou ", "Gan ", "Yi ", "Ju ", "Ao ", "Zha ", "Tuo ", "Yi ", "Qu ", "Zhao ", "Ping ", "Bi ", "Xiong ", "Qu ", "Ba ", "Da ", "Zu ", "Tao ", "Zhu ", "Ci ", "Zhe ", "Yong ", "Xu ", "Xun ", "Yi ", "Huang ", "He ", "Shi ", "Cha ", "Jiao ", "Shi ", "Hen ", "Cha ", "Gou ", "Gui ", "Quan ", "Hui ", "Jie ", "Hua ", "Gai ", "Xiang ", "Wei ", "Shen ", "Chou ", "Tong ", "Mi ", "Zhan ", "Ming ", "E ", "Hui ", "Yan ", "Xiong ", "Gua ", "Er ", "Beng ", "Tiao ", "Chi ", "Lei ", "Zhu ", "Kuang ", "Kua ", "Wu ", "Yu ", "Teng ", "Ji ", "Zhi ", "Ren ", "Su ", "Lang ", "E ", "Kuang ", "E ", "Shi ", "Ting ", "Dan ", "Bo ", "Chan ", "You ", "Heng ", "Qiao ", "Qin ", "Shua ", "An ", "Yu ", "Xiao ", "Cheng ", "Jie ", "Xian ", "Wu ", "Wu ", "Gao ", "Song ", "Pu ", "Hui ", "Jing ", "Shuo ", "Zhen ", "Shuo ", "Du ", "Yasashi ", "Chang ", "Shui ", "Jie ", "Ke ", "Qu ", "Cong ", "Xiao ", "Sui ", "Wang ", "Xuan ", "Fei ", "Chi ", "Ta ", "Yi ", "Na ", "Yin ", "Diao ", "Pi ", "Chuo ", "Chan ", "Chen ", "Zhun ", "Ji ", "Qi ", "Tan ", "Zhui ", "Wei ", "Ju ", "Qing ", "Jian ", "Zheng ", "Ze ", "Zou ", "Qian ", "Zhuo ", "Liang ", "Jian ", "Zhu ", "Hao ", "Lun ", "Shen ", "Biao ", "Huai ", "Pian ", "Yu ", "Die ", "Xu ", "Pian ", "Shi ", "Xuan ", "Shi ", "Hun ", "Hua ", "E ", "Zhong ", "Di ", "Xie ", "Fu ", "Pu ", "Ting ", "Jian ", "Qi ", "Yu ", "Zi ", "Chuan ", "Xi ", "Hui ", "Yin ", "An ", "Xian ", "Nan ", "Chen ", "Feng ", "Zhu ", "Yang ", "Yan ", "Heng ", "Xuan ", "Ge ", "Nuo ", "Qi "];
  }
});

// node_modules/unidecode/data/x8b.js
var require_x8b = __commonJS({
  "node_modules/unidecode/data/x8b.js"(exports2, module2) {
    module2.exports = ["Mou ", "Ye ", "Wei ", "[?] ", "Teng ", "Zou ", "Shan ", "Jian ", "Bo ", "Ku ", "Huang ", "Huo ", "Ge ", "Ying ", "Mi ", "Xiao ", "Mi ", "Xi ", "Qiang ", "Chen ", "Nue ", "Ti ", "Su ", "Bang ", "Chi ", "Qian ", "Shi ", "Jiang ", "Yuan ", "Xie ", "Xue ", "Tao ", "Yao ", "Yao ", "[?] ", "Yu ", "Biao ", "Cong ", "Qing ", "Li ", "Mo ", "Mo ", "Shang ", "Zhe ", "Miu ", "Jian ", "Ze ", "Jie ", "Lian ", "Lou ", "Can ", "Ou ", "Guan ", "Xi ", "Zhuo ", "Ao ", "Ao ", "Jin ", "Zhe ", "Yi ", "Hu ", "Jiang ", "Man ", "Chao ", "Han ", "Hua ", "Chan ", "Xu ", "Zeng ", "Se ", "Xi ", "She ", "Dui ", "Zheng ", "Nao ", "Lan ", "E ", "Ying ", "Jue ", "Ji ", "Zun ", "Jiao ", "Bo ", "Hui ", "Zhuan ", "Mu ", "Zen ", "Zha ", "Shi ", "Qiao ", "Tan ", "Zen ", "Pu ", "Sheng ", "Xuan ", "Zao ", "Tan ", "Dang ", "Sui ", "Qian ", "Ji ", "Jiao ", "Jing ", "Lian ", "Nou ", "Yi ", "Ai ", "Zhan ", "Pi ", "Hui ", "Hua ", "Yi ", "Yi ", "Shan ", "Rang ", "Nou ", "Qian ", "Zhui ", "Ta ", "Hu ", "Zhou ", "Hao ", "Ye ", "Ying ", "Jian ", "Yu ", "Jian ", "Hui ", "Du ", "Zhe ", "Xuan ", "Zan ", "Lei ", "Shen ", "Wei ", "Chan ", "Li ", "Yi ", "Bian ", "Zhe ", "Yan ", "E ", "Chou ", "Wei ", "Chou ", "Yao ", "Chan ", "Rang ", "Yin ", "Lan ", "Chen ", "Huo ", "Zhe ", "Huan ", "Zan ", "Yi ", "Dang ", "Zhan ", "Yan ", "Du ", "Yan ", "Ji ", "Ding ", "Fu ", "Ren ", "Ji ", "Jie ", "Hong ", "Tao ", "Rang ", "Shan ", "Qi ", "Tuo ", "Xun ", "Yi ", "Xun ", "Ji ", "Ren ", "Jiang ", "Hui ", "Ou ", "Ju ", "Ya ", "Ne ", "Xu ", "E ", "Lun ", "Xiong ", "Song ", "Feng ", "She ", "Fang ", "Jue ", "Zheng ", "Gu ", "He ", "Ping ", "Zu ", "Shi ", "Xiong ", "Zha ", "Su ", "Zhen ", "Di ", "Zou ", "Ci ", "Qu ", "Zhao ", "Bi ", "Yi ", "Yi ", "Kuang ", "Lei ", "Shi ", "Gua ", "Shi ", "Jie ", "Hui ", "Cheng ", "Zhu ", "Shen ", "Hua ", "Dan ", "Gou ", "Quan ", "Gui ", "Xun ", "Yi ", "Zheng ", "Gai ", "Xiang ", "Cha ", "Hun ", "Xu ", "Zhou ", "Jie ", "Wu ", "Yu ", "Qiao ", "Wu ", "Gao ", "You ", "Hui ", "Kuang ", "Shuo ", "Song ", "Ai ", "Qing ", "Zhu ", "Zou ", "Nuo ", "Du ", "Zhuo ", "Fei ", "Ke ", "Wei "];
  }
});

// node_modules/unidecode/data/x8c.js
var require_x8c = __commonJS({
  "node_modules/unidecode/data/x8c.js"(exports2, module2) {
    module2.exports = ["Yu ", "Shui ", "Shen ", "Diao ", "Chan ", "Liang ", "Zhun ", "Sui ", "Tan ", "Shen ", "Yi ", "Mou ", "Chen ", "Die ", "Huang ", "Jian ", "Xie ", "Nue ", "Ye ", "Wei ", "E ", "Yu ", "Xuan ", "Chan ", "Zi ", "An ", "Yan ", "Di ", "Mi ", "Pian ", "Xu ", "Mo ", "Dang ", "Su ", "Xie ", "Yao ", "Bang ", "Shi ", "Qian ", "Mi ", "Jin ", "Man ", "Zhe ", "Jian ", "Miu ", "Tan ", "Zen ", "Qiao ", "Lan ", "Pu ", "Jue ", "Yan ", "Qian ", "Zhan ", "Chen ", "Gu ", "Qian ", "Hong ", "Xia ", "Jue ", "Hong ", "Han ", "Hong ", "Xi ", "Xi ", "Huo ", "Liao ", "Han ", "Du ", "Long ", "Dou ", "Jiang ", "Qi ", "Shi ", "Li ", "Deng ", "Wan ", "Bi ", "Shu ", "Xian ", "Feng ", "Zhi ", "Zhi ", "Yan ", "Yan ", "Shi ", "Chu ", "Hui ", "Tun ", "Yi ", "Tun ", "Yi ", "Jian ", "Ba ", "Hou ", "E ", "Cu ", "Xiang ", "Huan ", "Jian ", "Ken ", "Gai ", "Qu ", "Fu ", "Xi ", "Bin ", "Hao ", "Yu ", "Zhu ", "Jia ", "[?] ", "Xi ", "Bo ", "Wen ", "Huan ", "Bin ", "Di ", "Zong ", "Fen ", "Yi ", "Zhi ", "Bao ", "Chai ", "Han ", "Pi ", "Na ", "Pi ", "Gou ", "Na ", "You ", "Diao ", "Mo ", "Si ", "Xiu ", "Huan ", "Kun ", "He ", "He ", "Mo ", "Han ", "Mao ", "Li ", "Ni ", "Bi ", "Yu ", "Jia ", "Tuan ", "Mao ", "Pi ", "Xi ", "E ", "Ju ", "Mo ", "Chu ", "Tan ", "Huan ", "Jue ", "Bei ", "Zhen ", "Yuan ", "Fu ", "Cai ", "Gong ", "Te ", "Yi ", "Hang ", "Wan ", "Pin ", "Huo ", "Fan ", "Tan ", "Guan ", "Ze ", "Zhi ", "Er ", "Zhu ", "Shi ", "Bi ", "Zi ", "Er ", "Gui ", "Pian ", "Bian ", "Mai ", "Dai ", "Sheng ", "Kuang ", "Fei ", "Tie ", "Yi ", "Chi ", "Mao ", "He ", "Bi ", "Lu ", "Ren ", "Hui ", "Gai ", "Pian ", "Zi ", "Jia ", "Xu ", "Zei ", "Jiao ", "Gai ", "Zang ", "Jian ", "Ying ", "Xun ", "Zhen ", "She ", "Bin ", "Bin ", "Qiu ", "She ", "Chuan ", "Zang ", "Zhou ", "Lai ", "Zan ", "Si ", "Chen ", "Shang ", "Tian ", "Pei ", "Geng ", "Xian ", "Mai ", "Jian ", "Sui ", "Fu ", "Tan ", "Cong ", "Cong ", "Zhi ", "Ji ", "Zhang ", "Du ", "Jin ", "Xiong ", "Shun ", "Yun ", "Bao ", "Zai ", "Lai ", "Feng ", "Cang ", "Ji ", "Sheng ", "Ai ", "Zhuan ", "Fu ", "Gou ", "Sai ", "Ze ", "Liao "];
  }
});

// node_modules/unidecode/data/x8d.js
var require_x8d = __commonJS({
  "node_modules/unidecode/data/x8d.js"(exports2, module2) {
    module2.exports = ["Wei ", "Bai ", "Chen ", "Zhuan ", "Zhi ", "Zhui ", "Biao ", "Yun ", "Zeng ", "Tan ", "Zan ", "Yan ", "[?] ", "Shan ", "Wan ", "Ying ", "Jin ", "Gan ", "Xian ", "Zang ", "Bi ", "Du ", "Shu ", "Yan ", "[?] ", "Xuan ", "Long ", "Gan ", "Zang ", "Bei ", "Zhen ", "Fu ", "Yuan ", "Gong ", "Cai ", "Ze ", "Xian ", "Bai ", "Zhang ", "Huo ", "Zhi ", "Fan ", "Tan ", "Pin ", "Bian ", "Gou ", "Zhu ", "Guan ", "Er ", "Jian ", "Bi ", "Shi ", "Tie ", "Gui ", "Kuang ", "Dai ", "Mao ", "Fei ", "He ", "Yi ", "Zei ", "Zhi ", "Jia ", "Hui ", "Zi ", "Ren ", "Lu ", "Zang ", "Zi ", "Gai ", "Jin ", "Qiu ", "Zhen ", "Lai ", "She ", "Fu ", "Du ", "Ji ", "Shu ", "Shang ", "Si ", "Bi ", "Zhou ", "Geng ", "Pei ", "Tan ", "Lai ", "Feng ", "Zhui ", "Fu ", "Zhuan ", "Sai ", "Ze ", "Yan ", "Zan ", "Yun ", "Zeng ", "Shan ", "Ying ", "Gan ", "Chi ", "Xi ", "She ", "Nan ", "Xiong ", "Xi ", "Cheng ", "He ", "Cheng ", "Zhe ", "Xia ", "Tang ", "Zou ", "Zou ", "Li ", "Jiu ", "Fu ", "Zhao ", "Gan ", "Qi ", "Shan ", "Qiong ", "Qin ", "Xian ", "Ci ", "Jue ", "Qin ", "Chi ", "Ci ", "Chen ", "Chen ", "Die ", "Ju ", "Chao ", "Di ", "Se ", "Zhan ", "Zhu ", "Yue ", "Qu ", "Jie ", "Chi ", "Chu ", "Gua ", "Xue ", "Ci ", "Tiao ", "Duo ", "Lie ", "Gan ", "Suo ", "Cu ", "Xi ", "Zhao ", "Su ", "Yin ", "Ju ", "Jian ", "Que ", "Tang ", "Chuo ", "Cui ", "Lu ", "Qu ", "Dang ", "Qiu ", "Zi ", "Ti ", "Qu ", "Chi ", "Huang ", "Qiao ", "Qiao ", "Yao ", "Zao ", "Ti ", "[?] ", "Zan ", "Zan ", "Zu ", "Pa ", "Bao ", "Ku ", "Ke ", "Dun ", "Jue ", "Fu ", "Chen ", "Jian ", "Fang ", "Zhi ", "Sa ", "Yue ", "Pa ", "Qi ", "Yue ", "Qiang ", "Tuo ", "Tai ", "Yi ", "Nian ", "Ling ", "Mei ", "Ba ", "Die ", "Ku ", "Tuo ", "Jia ", "Ci ", "Pao ", "Qia ", "Zhu ", "Ju ", "Die ", "Zhi ", "Fu ", "Pan ", "Ju ", "Shan ", "Bo ", "Ni ", "Ju ", "Li ", "Gen ", "Yi ", "Ji ", "Dai ", "Xian ", "Jiao ", "Duo ", "Zhu ", "Zhuan ", "Kua ", "Zhuai ", "Gui ", "Qiong ", "Kui ", "Xiang ", "Chi ", "Lu ", "Beng ", "Zhi ", "Jia ", "Tiao ", "Cai ", "Jian ", "Ta ", "Qiao ", "Bi ", "Xian ", "Duo ", "Ji ", "Ju ", "Ji ", "Shu ", "Tu "];
  }
});

// node_modules/unidecode/data/x8e.js
var require_x8e = __commonJS({
  "node_modules/unidecode/data/x8e.js"(exports2, module2) {
    module2.exports = ["Chu ", "Jing ", "Nie ", "Xiao ", "Bo ", "Chi ", "Qun ", "Mou ", "Shu ", "Lang ", "Yong ", "Jiao ", "Chou ", "Qiao ", "[?] ", "Ta ", "Jian ", "Qi ", "Wo ", "Wei ", "Zhuo ", "Jie ", "Ji ", "Nie ", "Ju ", "Ju ", "Lun ", "Lu ", "Leng ", "Huai ", "Ju ", "Chi ", "Wan ", "Quan ", "Ti ", "Bo ", "Zu ", "Qie ", "Ji ", "Cu ", "Zong ", "Cai ", "Zong ", "Peng ", "Zhi ", "Zheng ", "Dian ", "Zhi ", "Yu ", "Duo ", "Dun ", "Chun ", "Yong ", "Zhong ", "Di ", "Zhe ", "Chen ", "Chuai ", "Jian ", "Gua ", "Tang ", "Ju ", "Fu ", "Zu ", "Die ", "Pian ", "Rou ", "Nuo ", "Ti ", "Cha ", "Tui ", "Jian ", "Dao ", "Cuo ", "Xi ", "Ta ", "Qiang ", "Zhan ", "Dian ", "Ti ", "Ji ", "Nie ", "Man ", "Liu ", "Zhan ", "Bi ", "Chong ", "Lu ", "Liao ", "Cu ", "Tang ", "Dai ", "Suo ", "Xi ", "Kui ", "Ji ", "Zhi ", "Qiang ", "Di ", "Man ", "Zong ", "Lian ", "Beng ", "Zao ", "Nian ", "Bie ", "Tui ", "Ju ", "Deng ", "Ceng ", "Xian ", "Fan ", "Chu ", "Zhong ", "Dun ", "Bo ", "Cu ", "Zu ", "Jue ", "Jue ", "Lin ", "Ta ", "Qiao ", "Qiao ", "Pu ", "Liao ", "Dun ", "Cuan ", "Kuang ", "Zao ", "Ta ", "Bi ", "Bi ", "Zhu ", "Ju ", "Chu ", "Qiao ", "Dun ", "Chou ", "Ji ", "Wu ", "Yue ", "Nian ", "Lin ", "Lie ", "Zhi ", "Li ", "Zhi ", "Chan ", "Chu ", "Duan ", "Wei ", "Long ", "Lin ", "Xian ", "Wei ", "Zuan ", "Lan ", "Xie ", "Rang ", "Xie ", "Nie ", "Ta ", "Qu ", "Jie ", "Cuan ", "Zuan ", "Xi ", "Kui ", "Jue ", "Lin ", "Shen ", "Gong ", "Dan ", "Segare ", "Qu ", "Ti ", "Duo ", "Duo ", "Gong ", "Lang ", "Nerau ", "Luo ", "Ai ", "Ji ", "Ju ", "Tang ", "Utsuke ", "[?] ", "Yan ", "Shitsuke ", "Kang ", "Qu ", "Lou ", "Lao ", "Tuo ", "Zhi ", "Yagate ", "Ti ", "Dao ", "Yagate ", "Yu ", "Che ", "Ya ", "Gui ", "Jun ", "Wei ", "Yue ", "Xin ", "Di ", "Xuan ", "Fan ", "Ren ", "Shan ", "Qiang ", "Shu ", "Tun ", "Chen ", "Dai ", "E ", "Na ", "Qi ", "Mao ", "Ruan ", "Ren ", "Fan ", "Zhuan ", "Hong ", "Hu ", "Qu ", "Huang ", "Di ", "Ling ", "Dai ", "Ao ", "Zhen ", "Fan ", "Kuang ", "Ang ", "Peng ", "Bei ", "Gu ", "Ku ", "Pao ", "Zhu ", "Rong ", "E ", "Ba ", "Zhou ", "Zhi ", "Yao ", "Ke ", "Yi ", "Qing ", "Shi ", "Ping "];
  }
});

// node_modules/unidecode/data/x8f.js
var require_x8f = __commonJS({
  "node_modules/unidecode/data/x8f.js"(exports2, module2) {
    module2.exports = ["Er ", "Qiong ", "Ju ", "Jiao ", "Guang ", "Lu ", "Kai ", "Quan ", "Zhou ", "Zai ", "Zhi ", "She ", "Liang ", "Yu ", "Shao ", "You ", "Huan ", "Yun ", "Zhe ", "Wan ", "Fu ", "Qing ", "Zhou ", "Ni ", "Ling ", "Zhe ", "Zhan ", "Liang ", "Zi ", "Hui ", "Wang ", "Chuo ", "Guo ", "Kan ", "Yi ", "Peng ", "Qian ", "Gun ", "Nian ", "Pian ", "Guan ", "Bei ", "Lun ", "Pai ", "Liang ", "Ruan ", "Rou ", "Ji ", "Yang ", "Xian ", "Chuan ", "Cou ", "Qun ", "Ge ", "You ", "Hong ", "Shu ", "Fu ", "Zi ", "Fu ", "Wen ", "Ben ", "Zhan ", "Yu ", "Wen ", "Tao ", "Gu ", "Zhen ", "Xia ", "Yuan ", "Lu ", "Jiu ", "Chao ", "Zhuan ", "Wei ", "Hun ", "Sori ", "Che ", "Jiao ", "Zhan ", "Pu ", "Lao ", "Fen ", "Fan ", "Lin ", "Ge ", "Se ", "Kan ", "Huan ", "Yi ", "Ji ", "Dui ", "Er ", "Yu ", "Xian ", "Hong ", "Lei ", "Pei ", "Li ", "Li ", "Lu ", "Lin ", "Che ", "Ya ", "Gui ", "Xuan ", "Di ", "Ren ", "Zhuan ", "E ", "Lun ", "Ruan ", "Hong ", "Ku ", "Ke ", "Lu ", "Zhou ", "Zhi ", "Yi ", "Hu ", "Zhen ", "Li ", "Yao ", "Qing ", "Shi ", "Zai ", "Zhi ", "Jiao ", "Zhou ", "Quan ", "Lu ", "Jiao ", "Zhe ", "Fu ", "Liang ", "Nian ", "Bei ", "Hui ", "Gun ", "Wang ", "Liang ", "Chuo ", "Zi ", "Cou ", "Fu ", "Ji ", "Wen ", "Shu ", "Pei ", "Yuan ", "Xia ", "Zhan ", "Lu ", "Che ", "Lin ", "Xin ", "Gu ", "Ci ", "Ci ", "Pi ", "Zui ", "Bian ", "La ", "La ", "Ci ", "Xue ", "Ban ", "Bian ", "Bian ", "Bian ", "[?] ", "Bian ", "Ban ", "Ci ", "Bian ", "Bian ", "Chen ", "Ru ", "Nong ", "Nong ", "Zhen ", "Chuo ", "Chuo ", "Suberu ", "Reng ", "Bian ", "Bian ", "Sip ", "Ip ", "Liao ", "Da ", "Chan ", "Gan ", "Qian ", "Yu ", "Yu ", "Qi ", "Xun ", "Yi ", "Guo ", "Mai ", "Qi ", "Za ", "Wang ", "Jia ", "Zhun ", "Ying ", "Ti ", "Yun ", "Jin ", "Hang ", "Ya ", "Fan ", "Wu ", "Da ", "E ", "Huan ", "Zhe ", "Totemo ", "Jin ", "Yuan ", "Wei ", "Lian ", "Chi ", "Che ", "Ni ", "Tiao ", "Zhi ", "Yi ", "Jiong ", "Jia ", "Chen ", "Dai ", "Er ", "Di ", "Po ", "Wang ", "Die ", "Ze ", "Tao ", "Shu ", "Tuo ", "Kep ", "Jing ", "Hui ", "Tong ", "You ", "Mi ", "Beng ", "Ji ", "Nai ", "Yi ", "Jie ", "Zhui ", "Lie ", "Xun "];
  }
});

// node_modules/unidecode/data/x90.js
var require_x90 = __commonJS({
  "node_modules/unidecode/data/x90.js"(exports2, module2) {
    module2.exports = ["Tui ", "Song ", "Gua ", "Tao ", "Pang ", "Hou ", "Ni ", "Dun ", "Jiong ", "Xuan ", "Xun ", "Bu ", "You ", "Xiao ", "Qiu ", "Tou ", "Zhu ", "Qiu ", "Di ", "Di ", "Tu ", "Jing ", "Ti ", "Dou ", "Yi ", "Zhe ", "Tong ", "Guang ", "Wu ", "Shi ", "Cheng ", "Su ", "Zao ", "Qun ", "Feng ", "Lian ", "Suo ", "Hui ", "Li ", "Sako ", "Lai ", "Ben ", "Cuo ", "Jue ", "Beng ", "Huan ", "Dai ", "Lu ", "You ", "Zhou ", "Jin ", "Yu ", "Chuo ", "Kui ", "Wei ", "Ti ", "Yi ", "Da ", "Yuan ", "Luo ", "Bi ", "Nuo ", "Yu ", "Dang ", "Sui ", "Dun ", "Sui ", "Yan ", "Chuan ", "Chi ", "Ti ", "Yu ", "Shi ", "Zhen ", "You ", "Yun ", "E ", "Bian ", "Guo ", "E ", "Xia ", "Huang ", "Qiu ", "Dao ", "Da ", "Wei ", "Appare ", "Yi ", "Gou ", "Yao ", "Chu ", "Liu ", "Xun ", "Ta ", "Di ", "Chi ", "Yuan ", "Su ", "Ta ", "Qian ", "[?] ", "Yao ", "Guan ", "Zhang ", "Ao ", "Shi ", "Ce ", "Chi ", "Su ", "Zao ", "Zhe ", "Dun ", "Di ", "Lou ", "Chi ", "Cuo ", "Lin ", "Zun ", "Rao ", "Qian ", "Xuan ", "Yu ", "Yi ", "Wu ", "Liao ", "Ju ", "Shi ", "Bi ", "Yao ", "Mai ", "Xie ", "Sui ", "Huan ", "Zhan ", "Teng ", "Er ", "Miao ", "Bian ", "Bian ", "La ", "Li ", "Yuan ", "Yao ", "Luo ", "Li ", "Yi ", "Ting ", "Deng ", "Qi ", "Yong ", "Shan ", "Han ", "Yu ", "Mang ", "Ru ", "Qiong ", "[?] ", "Kuang ", "Fu ", "Kang ", "Bin ", "Fang ", "Xing ", "Na ", "Xin ", "Shen ", "Bang ", "Yuan ", "Cun ", "Huo ", "Xie ", "Bang ", "Wu ", "Ju ", "You ", "Han ", "Tai ", "Qiu ", "Bi ", "Pei ", "Bing ", "Shao ", "Bei ", "Wa ", "Di ", "Zou ", "Ye ", "Lin ", "Kuang ", "Gui ", "Zhu ", "Shi ", "Ku ", "Yu ", "Gai ", "Ge ", "Xi ", "Zhi ", "Ji ", "Xun ", "Hou ", "Xing ", "Jiao ", "Xi ", "Gui ", "Nuo ", "Lang ", "Jia ", "Kuai ", "Zheng ", "Otoko ", "Yun ", "Yan ", "Cheng ", "Dou ", "Chi ", "Lu ", "Fu ", "Wu ", "Fu ", "Gao ", "Hao ", "Lang ", "Jia ", "Geng ", "Jun ", "Ying ", "Bo ", "Xi ", "Bei ", "Li ", "Yun ", "Bu ", "Xiao ", "Qi ", "Pi ", "Qing ", "Guo ", "Zhou ", "Tan ", "Zou ", "Ping ", "Lai ", "Ni ", "Chen ", "You ", "Bu ", "Xiang ", "Dan ", "Ju ", "Yong ", "Qiao ", "Yi ", "Du ", "Yan ", "Mei "];
  }
});

// node_modules/unidecode/data/x91.js
var require_x91 = __commonJS({
  "node_modules/unidecode/data/x91.js"(exports2, module2) {
    module2.exports = ["Ruo ", "Bei ", "E ", "Yu ", "Juan ", "Yu ", "Yun ", "Hou ", "Kui ", "Xiang ", "Xiang ", "Sou ", "Tang ", "Ming ", "Xi ", "Ru ", "Chu ", "Zi ", "Zou ", "Ju ", "Wu ", "Xiang ", "Yun ", "Hao ", "Yong ", "Bi ", "Mo ", "Chao ", "Fu ", "Liao ", "Yin ", "Zhuan ", "Hu ", "Qiao ", "Yan ", "Zhang ", "Fan ", "Qiao ", "Xu ", "Deng ", "Bi ", "Xin ", "Bi ", "Ceng ", "Wei ", "Zheng ", "Mao ", "Shan ", "Lin ", "Po ", "Dan ", "Meng ", "Ye ", "Cao ", "Kuai ", "Feng ", "Meng ", "Zou ", "Kuang ", "Lian ", "Zan ", "Chan ", "You ", "Qi ", "Yan ", "Chan ", "Zan ", "Ling ", "Huan ", "Xi ", "Feng ", "Zan ", "Li ", "You ", "Ding ", "Qiu ", "Zhuo ", "Pei ", "Zhou ", "Yi ", "Hang ", "Yu ", "Jiu ", "Yan ", "Zui ", "Mao ", "Dan ", "Xu ", "Tou ", "Zhen ", "Fen ", "Sakenomoto ", "[?] ", "Yun ", "Tai ", "Tian ", "Qia ", "Tuo ", "Zuo ", "Han ", "Gu ", "Su ", "Po ", "Chou ", "Zai ", "Ming ", "Luo ", "Chuo ", "Chou ", "You ", "Tong ", "Zhi ", "Xian ", "Jiang ", "Cheng ", "Yin ", "Tu ", "Xiao ", "Mei ", "Ku ", "Suan ", "Lei ", "Pu ", "Zui ", "Hai ", "Yan ", "Xi ", "Niang ", "Wei ", "Lu ", "Lan ", "Yan ", "Tao ", "Pei ", "Zhan ", "Chun ", "Tan ", "Zui ", "Chuo ", "Cu ", "Kun ", "Ti ", "Mian ", "Du ", "Hu ", "Xu ", "Xing ", "Tan ", "Jiu ", "Chun ", "Yun ", "Po ", "Ke ", "Sou ", "Mi ", "Quan ", "Chou ", "Cuo ", "Yun ", "Yong ", "Ang ", "Zha ", "Hai ", "Tang ", "Jiang ", "Piao ", "Shan ", "Yu ", "Li ", "Zao ", "Lao ", "Yi ", "Jiang ", "Pu ", "Jiao ", "Xi ", "Tan ", "Po ", "Nong ", "Yi ", "Li ", "Ju ", "Jiao ", "Yi ", "Niang ", "Ru ", "Xun ", "Chou ", "Yan ", "Ling ", "Mi ", "Mi ", "Niang ", "Xin ", "Jiao ", "Xi ", "Mi ", "Yan ", "Bian ", "Cai ", "Shi ", "You ", "Shi ", "Shi ", "Li ", "Zhong ", "Ye ", "Liang ", "Li ", "Jin ", "Jin ", "Qiu ", "Yi ", "Diao ", "Dao ", "Zhao ", "Ding ", "Po ", "Qiu ", "He ", "Fu ", "Zhen ", "Zhi ", "Ba ", "Luan ", "Fu ", "Nai ", "Diao ", "Shan ", "Qiao ", "Kou ", "Chuan ", "Zi ", "Fan ", "Yu ", "Hua ", "Han ", "Gong ", "Qi ", "Mang ", "Ri ", "Di ", "Si ", "Xi ", "Yi ", "Chai ", "Shi ", "Tu ", "Xi ", "Nu ", "Qian ", "Ishiyumi ", "Jian ", "Pi ", "Ye ", "Yin "];
  }
});

// node_modules/unidecode/data/x92.js
var require_x92 = __commonJS({
  "node_modules/unidecode/data/x92.js"(exports2, module2) {
    module2.exports = ["Ba ", "Fang ", "Chen ", "Xing ", "Tou ", "Yue ", "Yan ", "Fu ", "Pi ", "Na ", "Xin ", "E ", "Jue ", "Dun ", "Gou ", "Yin ", "Qian ", "Ban ", "Ji ", "Ren ", "Chao ", "Niu ", "Fen ", "Yun ", "Ji ", "Qin ", "Pi ", "Guo ", "Hong ", "Yin ", "Jun ", "Shi ", "Yi ", "Zhong ", "Nie ", "Gai ", "Ri ", "Huo ", "Tai ", "Kang ", "Habaki ", "Irori ", "Ngaak ", "[?] ", "Duo ", "Zi ", "Ni ", "Tu ", "Shi ", "Min ", "Gu ", "E ", "Ling ", "Bing ", "Yi ", "Gu ", "Ba ", "Pi ", "Yu ", "Si ", "Zuo ", "Bu ", "You ", "Dian ", "Jia ", "Zhen ", "Shi ", "Shi ", "Tie ", "Ju ", "Zhan ", "Shi ", "She ", "Xuan ", "Zhao ", "Bao ", "He ", "Bi ", "Sheng ", "Chu ", "Shi ", "Bo ", "Zhu ", "Chi ", "Za ", "Po ", "Tong ", "Qian ", "Fu ", "Zhai ", "Liu ", "Qian ", "Fu ", "Li ", "Yue ", "Pi ", "Yang ", "Ban ", "Bo ", "Jie ", "Gou ", "Shu ", "Zheng ", "Mu ", "Ni ", "Nie ", "Di ", "Jia ", "Mu ", "Dan ", "Shen ", "Yi ", "Si ", "Kuang ", "Ka ", "Bei ", "Jian ", "Tong ", "Xing ", "Hong ", "Jiao ", "Chi ", "Er ", "Ge ", "Bing ", "Shi ", "Mou ", "Jia ", "Yin ", "Jun ", "Zhou ", "Chong ", "Shang ", "Tong ", "Mo ", "Lei ", "Ji ", "Yu ", "Xu ", "Ren ", "Zun ", "Zhi ", "Qiong ", "Shan ", "Chi ", "Xian ", "Xing ", "Quan ", "Pi ", "Tie ", "Zhu ", "Hou ", "Ming ", "Kua ", "Yao ", "Xian ", "Xian ", "Xiu ", "Jun ", "Cha ", "Lao ", "Ji ", "Pi ", "Ru ", "Mi ", "Yi ", "Yin ", "Guang ", "An ", "Diou ", "You ", "Se ", "Kao ", "Qian ", "Luan ", "Kasugai ", "Ai ", "Diao ", "Han ", "Rui ", "Shi ", "Keng ", "Qiu ", "Xiao ", "Zhe ", "Xiu ", "Zang ", "Ti ", "Cuo ", "Gua ", "Gong ", "Zhong ", "Dou ", "Lu ", "Mei ", "Lang ", "Wan ", "Xin ", "Yun ", "Bei ", "Wu ", "Su ", "Yu ", "Chan ", "Ting ", "Bo ", "Han ", "Jia ", "Hong ", "Cuan ", "Feng ", "Chan ", "Wan ", "Zhi ", "Si ", "Xuan ", "Wu ", "Wu ", "Tiao ", "Gong ", "Zhuo ", "Lue ", "Xing ", "Qian ", "Shen ", "Han ", "Lue ", "Xie ", "Chu ", "Zheng ", "Ju ", "Xian ", "Tie ", "Mang ", "Pu ", "Li ", "Pan ", "Rui ", "Cheng ", "Gao ", "Li ", "Te ", "Pyeng ", "Zhu ", "[?] ", "Tu ", "Liu ", "Zui ", "Ju ", "Chang ", "Yuan ", "Jian ", "Gang ", "Diao ", "Tao ", "Chang "];
  }
});

// node_modules/unidecode/data/x93.js
var require_x93 = __commonJS({
  "node_modules/unidecode/data/x93.js"(exports2, module2) {
    module2.exports = ["Lun ", "Kua ", "Ling ", "Bei ", "Lu ", "Li ", "Qiang ", "Pou ", "Juan ", "Min ", "Zui ", "Peng ", "An ", "Pi ", "Xian ", "Ya ", "Zhui ", "Lei ", "A ", "Kong ", "Ta ", "Kun ", "Du ", "Wei ", "Chui ", "Zi ", "Zheng ", "Ben ", "Nie ", "Cong ", "Qun ", "Tan ", "Ding ", "Qi ", "Qian ", "Zhuo ", "Qi ", "Yu ", "Jin ", "Guan ", "Mao ", "Chang ", "Tian ", "Xi ", "Lian ", "Tao ", "Gu ", "Cuo ", "Shu ", "Zhen ", "Lu ", "Meng ", "Lu ", "Hua ", "Biao ", "Ga ", "Lai ", "Ken ", "Kazari ", "Bu ", "Nai ", "Wan ", "Zan ", "[?] ", "De ", "Xian ", "[?] ", "Huo ", "Liang ", "[?] ", "Men ", "Kai ", "Ying ", "Di ", "Lian ", "Guo ", "Xian ", "Du ", "Tu ", "Wei ", "Cong ", "Fu ", "Rou ", "Ji ", "E ", "Rou ", "Chen ", "Ti ", "Zha ", "Hong ", "Yang ", "Duan ", "Xia ", "Yu ", "Keng ", "Xing ", "Huang ", "Wei ", "Fu ", "Zhao ", "Cha ", "Qie ", "She ", "Hong ", "Kui ", "Tian ", "Mou ", "Qiao ", "Qiao ", "Hou ", "Tou ", "Cong ", "Huan ", "Ye ", "Min ", "Jian ", "Duan ", "Jian ", "Song ", "Kui ", "Hu ", "Xuan ", "Duo ", "Jie ", "Zhen ", "Bian ", "Zhong ", "Zi ", "Xiu ", "Ye ", "Mei ", "Pai ", "Ai ", "Jie ", "[?] ", "Mei ", "Chuo ", "Ta ", "Bang ", "Xia ", "Lian ", "Suo ", "Xi ", "Liu ", "Zu ", "Ye ", "Nou ", "Weng ", "Rong ", "Tang ", "Suo ", "Qiang ", "Ge ", "Shuo ", "Chui ", "Bo ", "Pan ", "Sa ", "Bi ", "Sang ", "Gang ", "Zi ", "Wu ", "Ying ", "Huang ", "Tiao ", "Liu ", "Kai ", "Sun ", "Sha ", "Sou ", "Wan ", "Hao ", "Zhen ", "Zhen ", "Luo ", "Yi ", "Yuan ", "Tang ", "Nie ", "Xi ", "Jia ", "Ge ", "Ma ", "Juan ", "Kasugai ", "Habaki ", "Suo ", "[?] ", "[?] ", "[?] ", "Na ", "Lu ", "Suo ", "Ou ", "Zu ", "Tuan ", "Xiu ", "Guan ", "Xuan ", "Lian ", "Shou ", "Ao ", "Man ", "Mo ", "Luo ", "Bi ", "Wei ", "Liu ", "Di ", "Qiao ", "Cong ", "Yi ", "Lu ", "Ao ", "Keng ", "Qiang ", "Cui ", "Qi ", "Chang ", "Tang ", "Man ", "Yong ", "Chan ", "Feng ", "Jing ", "Biao ", "Shu ", "Lou ", "Xiu ", "Cong ", "Long ", "Zan ", "Jian ", "Cao ", "Li ", "Xia ", "Xi ", "Kang ", "[?] ", "Beng ", "[?] ", "[?] ", "Zheng ", "Lu ", "Hua ", "Ji ", "Pu ", "Hui ", "Qiang ", "Po ", "Lin ", "Suo ", "Xiu ", "San ", "Cheng "];
  }
});

// node_modules/unidecode/data/x94.js
var require_x94 = __commonJS({
  "node_modules/unidecode/data/x94.js"(exports2, module2) {
    module2.exports = ["Kui ", "Si ", "Liu ", "Nao ", "Heng ", "Pie ", "Sui ", "Fan ", "Qiao ", "Quan ", "Yang ", "Tang ", "Xiang ", "Jue ", "Jiao ", "Zun ", "Liao ", "Jie ", "Lao ", "Dui ", "Tan ", "Zan ", "Ji ", "Jian ", "Zhong ", "Deng ", "Ya ", "Ying ", "Dui ", "Jue ", "Nou ", "Ti ", "Pu ", "Tie ", "[?] ", "[?] ", "Ding ", "Shan ", "Kai ", "Jian ", "Fei ", "Sui ", "Lu ", "Juan ", "Hui ", "Yu ", "Lian ", "Zhuo ", "Qiao ", "Qian ", "Zhuo ", "Lei ", "Bi ", "Tie ", "Huan ", "Ye ", "Duo ", "Guo ", "Dang ", "Ju ", "Fen ", "Da ", "Bei ", "Yi ", "Ai ", "Zong ", "Xun ", "Diao ", "Zhu ", "Heng ", "Zhui ", "Ji ", "Nie ", "Ta ", "Huo ", "Qing ", "Bin ", "Ying ", "Kui ", "Ning ", "Xu ", "Jian ", "Jian ", "Yari ", "Cha ", "Zhi ", "Mie ", "Li ", "Lei ", "Ji ", "Zuan ", "Kuang ", "Shang ", "Peng ", "La ", "Du ", "Shuo ", "Chuo ", "Lu ", "Biao ", "Bao ", "Lu ", "[?] ", "[?] ", "Long ", "E ", "Lu ", "Xin ", "Jian ", "Lan ", "Bo ", "Jian ", "Yao ", "Chan ", "Xiang ", "Jian ", "Xi ", "Guan ", "Cang ", "Nie ", "Lei ", "Cuan ", "Qu ", "Pan ", "Luo ", "Zuan ", "Luan ", "Zao ", "Nie ", "Jue ", "Tang ", "Shu ", "Lan ", "Jin ", "Qiu ", "Yi ", "Zhen ", "Ding ", "Zhao ", "Po ", "Diao ", "Tu ", "Qian ", "Chuan ", "Shan ", "Ji ", "Fan ", "Diao ", "Men ", "Nu ", "Xi ", "Chai ", "Xing ", "Gai ", "Bu ", "Tai ", "Ju ", "Dun ", "Chao ", "Zhong ", "Na ", "Bei ", "Gang ", "Ban ", "Qian ", "Yao ", "Qin ", "Jun ", "Wu ", "Gou ", "Kang ", "Fang ", "Huo ", "Tou ", "Niu ", "Ba ", "Yu ", "Qian ", "Zheng ", "Qian ", "Gu ", "Bo ", "E ", "Po ", "Bu ", "Ba ", "Yue ", "Zuan ", "Mu ", "Dan ", "Jia ", "Dian ", "You ", "Tie ", "Bo ", "Ling ", "Shuo ", "Qian ", "Liu ", "Bao ", "Shi ", "Xuan ", "She ", "Bi ", "Ni ", "Pi ", "Duo ", "Xing ", "Kao ", "Lao ", "Er ", "Mang ", "Ya ", "You ", "Cheng ", "Jia ", "Ye ", "Nao ", "Zhi ", "Dang ", "Tong ", "Lu ", "Diao ", "Yin ", "Kai ", "Zha ", "Zhu ", "Xian ", "Ting ", "Diu ", "Xian ", "Hua ", "Quan ", "Sha ", "Jia ", "Yao ", "Ge ", "Ming ", "Zheng ", "Se ", "Jiao ", "Yi ", "Chan ", "Chong ", "Tang ", "An ", "Yin ", "Ru ", "Zhu ", "Lao ", "Pu ", "Wu ", "Lai ", "Te ", "Lian ", "Keng "];
  }
});

// node_modules/unidecode/data/x95.js
var require_x95 = __commonJS({
  "node_modules/unidecode/data/x95.js"(exports2, module2) {
    module2.exports = ["Xiao ", "Suo ", "Li ", "Zheng ", "Chu ", "Guo ", "Gao ", "Tie ", "Xiu ", "Cuo ", "Lue ", "Feng ", "Xin ", "Liu ", "Kai ", "Jian ", "Rui ", "Ti ", "Lang ", "Qian ", "Ju ", "A ", "Qiang ", "Duo ", "Tian ", "Cuo ", "Mao ", "Ben ", "Qi ", "De ", "Kua ", "Kun ", "Chang ", "Xi ", "Gu ", "Luo ", "Chui ", "Zhui ", "Jin ", "Zhi ", "Xian ", "Juan ", "Huo ", "Pou ", "Tan ", "Ding ", "Jian ", "Ju ", "Meng ", "Zi ", "Qie ", "Ying ", "Kai ", "Qiang ", "Song ", "E ", "Cha ", "Qiao ", "Zhong ", "Duan ", "Sou ", "Huang ", "Huan ", "Ai ", "Du ", "Mei ", "Lou ", "Zi ", "Fei ", "Mei ", "Mo ", "Zhen ", "Bo ", "Ge ", "Nie ", "Tang ", "Juan ", "Nie ", "Na ", "Liu ", "Hao ", "Bang ", "Yi ", "Jia ", "Bin ", "Rong ", "Biao ", "Tang ", "Man ", "Luo ", "Beng ", "Yong ", "Jing ", "Di ", "Zu ", "Xuan ", "Liu ", "Tan ", "Jue ", "Liao ", "Pu ", "Lu ", "Dui ", "Lan ", "Pu ", "Cuan ", "Qiang ", "Deng ", "Huo ", "Lei ", "Huan ", "Zhuo ", "Lian ", "Yi ", "Cha ", "Biao ", "La ", "Chan ", "Xiang ", "Chang ", "Chang ", "Jiu ", "Ao ", "Die ", "Qu ", "Liao ", "Mi ", "Chang ", "Men ", "Ma ", "Shuan ", "Shan ", "Huo ", "Men ", "Yan ", "Bi ", "Han ", "Bi ", "San ", "Kai ", "Kang ", "Beng ", "Hong ", "Run ", "San ", "Xian ", "Xian ", "Jian ", "Min ", "Xia ", "Yuru ", "Dou ", "Zha ", "Nao ", "Jian ", "Peng ", "Xia ", "Ling ", "Bian ", "Bi ", "Run ", "He ", "Guan ", "Ge ", "Ge ", "Fa ", "Chu ", "Hong ", "Gui ", "Min ", "Se ", "Kun ", "Lang ", "Lu ", "Ting ", "Sha ", "Ju ", "Yue ", "Yue ", "Chan ", "Qu ", "Lin ", "Chang ", "Shai ", "Kun ", "Yan ", "Min ", "Yan ", "E ", "Hun ", "Yu ", "Wen ", "Xiang ", "Bao ", "Xiang ", "Qu ", "Yao ", "Wen ", "Ban ", "An ", "Wei ", "Yin ", "Kuo ", "Que ", "Lan ", "Du ", "[?] ", "Phwung ", "Tian ", "Nie ", "Ta ", "Kai ", "He ", "Que ", "Chuang ", "Guan ", "Dou ", "Qi ", "Kui ", "Tang ", "Guan ", "Piao ", "Kan ", "Xi ", "Hui ", "Chan ", "Pi ", "Dang ", "Huan ", "Ta ", "Wen ", "[?] ", "Men ", "Shuan ", "Shan ", "Yan ", "Han ", "Bi ", "Wen ", "Chuang ", "Run ", "Wei ", "Xian ", "Hong ", "Jian ", "Min ", "Kang ", "Men ", "Zha ", "Nao ", "Gui ", "Wen ", "Ta ", "Min ", "Lu ", "Kai "];
  }
});

// node_modules/unidecode/data/x96.js
var require_x96 = __commonJS({
  "node_modules/unidecode/data/x96.js"(exports2, module2) {
    module2.exports = ["Fa ", "Ge ", "He ", "Kun ", "Jiu ", "Yue ", "Lang ", "Du ", "Yu ", "Yan ", "Chang ", "Xi ", "Wen ", "Hun ", "Yan ", "E ", "Chan ", "Lan ", "Qu ", "Hui ", "Kuo ", "Que ", "Ge ", "Tian ", "Ta ", "Que ", "Kan ", "Huan ", "Fu ", "Fu ", "Le ", "Dui ", "Xin ", "Qian ", "Wu ", "Yi ", "Tuo ", "Yin ", "Yang ", "Dou ", "E ", "Sheng ", "Ban ", "Pei ", "Keng ", "Yun ", "Ruan ", "Zhi ", "Pi ", "Jing ", "Fang ", "Yang ", "Yin ", "Zhen ", "Jie ", "Cheng ", "E ", "Qu ", "Di ", "Zu ", "Zuo ", "Dian ", "Ling ", "A ", "Tuo ", "Tuo ", "Po ", "Bing ", "Fu ", "Ji ", "Lu ", "Long ", "Chen ", "Xing ", "Duo ", "Lou ", "Mo ", "Jiang ", "Shu ", "Duo ", "Xian ", "Er ", "Gui ", "Yu ", "Gai ", "Shan ", "Xun ", "Qiao ", "Xing ", "Chun ", "Fu ", "Bi ", "Xia ", "Shan ", "Sheng ", "Zhi ", "Pu ", "Dou ", "Yuan ", "Zhen ", "Chu ", "Xian ", "Tou ", "Nie ", "Yun ", "Xian ", "Pei ", "Pei ", "Zou ", "Yi ", "Dui ", "Lun ", "Yin ", "Ju ", "Chui ", "Chen ", "Pi ", "Ling ", "Tao ", "Xian ", "Lu ", "Sheng ", "Xian ", "Yin ", "Zhu ", "Yang ", "Reng ", "Shan ", "Chong ", "Yan ", "Yin ", "Yu ", "Ti ", "Yu ", "Long ", "Wei ", "Wei ", "Nie ", "Dui ", "Sui ", "An ", "Huang ", "Jie ", "Sui ", "Yin ", "Gai ", "Yan ", "Hui ", "Ge ", "Yun ", "Wu ", "Wei ", "Ai ", "Xi ", "Tang ", "Ji ", "Zhang ", "Dao ", "Ao ", "Xi ", "Yin ", "[?] ", "Rao ", "Lin ", "Tui ", "Deng ", "Pi ", "Sui ", "Sui ", "Yu ", "Xian ", "Fen ", "Ni ", "Er ", "Ji ", "Dao ", "Xi ", "Yin ", "E ", "Hui ", "Long ", "Xi ", "Li ", "Li ", "Li ", "Zhui ", "He ", "Zhi ", "Zhun ", "Jun ", "Nan ", "Yi ", "Que ", "Yan ", "Qian ", "Ya ", "Xiong ", "Ya ", "Ji ", "Gu ", "Huan ", "Zhi ", "Gou ", "Jun ", "Ci ", "Yong ", "Ju ", "Chu ", "Hu ", "Za ", "Luo ", "Yu ", "Chou ", "Diao ", "Sui ", "Han ", "Huo ", "Shuang ", "Guan ", "Chu ", "Za ", "Yong ", "Ji ", "Xi ", "Chou ", "Liu ", "Li ", "Nan ", "Xue ", "Za ", "Ji ", "Ji ", "Yu ", "Yu ", "Xue ", "Na ", "Fou ", "Se ", "Mu ", "Wen ", "Fen ", "Pang ", "Yun ", "Li ", "Li ", "Ang ", "Ling ", "Lei ", "An ", "Bao ", "Meng ", "Dian ", "Dang ", "Xing ", "Wu ", "Zhao "];
  }
});

// node_modules/unidecode/data/x97.js
var require_x97 = __commonJS({
  "node_modules/unidecode/data/x97.js"(exports2, module2) {
    module2.exports = ["Xu ", "Ji ", "Mu ", "Chen ", "Xiao ", "Zha ", "Ting ", "Zhen ", "Pei ", "Mei ", "Ling ", "Qi ", "Chou ", "Huo ", "Sha ", "Fei ", "Weng ", "Zhan ", "Yin ", "Ni ", "Chou ", "Tun ", "Lin ", "[?] ", "Dong ", "Ying ", "Wu ", "Ling ", "Shuang ", "Ling ", "Xia ", "Hong ", "Yin ", "Mo ", "Mai ", "Yun ", "Liu ", "Meng ", "Bin ", "Wu ", "Wei ", "Huo ", "Yin ", "Xi ", "Yi ", "Ai ", "Dan ", "Deng ", "Xian ", "Yu ", "Lu ", "Long ", "Dai ", "Ji ", "Pang ", "Yang ", "Ba ", "Pi ", "Wei ", "[?] ", "Xi ", "Ji ", "Mai ", "Meng ", "Meng ", "Lei ", "Li ", "Huo ", "Ai ", "Fei ", "Dai ", "Long ", "Ling ", "Ai ", "Feng ", "Li ", "Bao ", "[?] ", "He ", "He ", "Bing ", "Qing ", "Qing ", "Jing ", "Tian ", "Zhen ", "Jing ", "Cheng ", "Qing ", "Jing ", "Jing ", "Dian ", "Jing ", "Tian ", "Fei ", "Fei ", "Kao ", "Mi ", "Mian ", "Mian ", "Pao ", "Ye ", "Tian ", "Hui ", "Ye ", "Ge ", "Ding ", "Cha ", "Jian ", "Ren ", "Di ", "Du ", "Wu ", "Ren ", "Qin ", "Jin ", "Xue ", "Niu ", "Ba ", "Yin ", "Sa ", "Na ", "Mo ", "Zu ", "Da ", "Ban ", "Yi ", "Yao ", "Tao ", "Tuo ", "Jia ", "Hong ", "Pao ", "Yang ", "Tomo ", "Yin ", "Jia ", "Tao ", "Ji ", "Xie ", "An ", "An ", "Hen ", "Gong ", "Kohaze ", "Da ", "Qiao ", "Ting ", "Wan ", "Ying ", "Sui ", "Tiao ", "Qiao ", "Xuan ", "Kong ", "Beng ", "Ta ", "Zhang ", "Bing ", "Kuo ", "Ju ", "La ", "Xie ", "Rou ", "Bang ", "Yi ", "Qiu ", "Qiu ", "He ", "Xiao ", "Mu ", "Ju ", "Jian ", "Bian ", "Di ", "Jian ", "On ", "Tao ", "Gou ", "Ta ", "Bei ", "Xie ", "Pan ", "Ge ", "Bi ", "Kuo ", "Tang ", "Lou ", "Gui ", "Qiao ", "Xue ", "Ji ", "Jian ", "Jiang ", "Chan ", "Da ", "Huo ", "Xian ", "Qian ", "Du ", "Wa ", "Jian ", "Lan ", "Wei ", "Ren ", "Fu ", "Mei ", "Juan ", "Ge ", "Wei ", "Qiao ", "Han ", "Chang ", "[?] ", "Rou ", "Xun ", "She ", "Wei ", "Ge ", "Bei ", "Tao ", "Gou ", "Yun ", "[?] ", "Bi ", "Wei ", "Hui ", "Du ", "Wa ", "Du ", "Wei ", "Ren ", "Fu ", "Han ", "Wei ", "Yun ", "Tao ", "Jiu ", "Jiu ", "Xian ", "Xie ", "Xian ", "Ji ", "Yin ", "Za ", "Yun ", "Shao ", "Le ", "Peng ", "Heng ", "Ying ", "Yun ", "Peng ", "Yin ", "Yin ", "Xiang "];
  }
});

// node_modules/unidecode/data/x98.js
var require_x98 = __commonJS({
  "node_modules/unidecode/data/x98.js"(exports2, module2) {
    module2.exports = ["Hu ", "Ye ", "Ding ", "Qing ", "Pan ", "Xiang ", "Shun ", "Han ", "Xu ", "Yi ", "Xu ", "Gu ", "Song ", "Kui ", "Qi ", "Hang ", "Yu ", "Wan ", "Ban ", "Dun ", "Di ", "Dan ", "Pan ", "Po ", "Ling ", "Ce ", "Jing ", "Lei ", "He ", "Qiao ", "E ", "E ", "Wei ", "Jie ", "Gua ", "Shen ", "Yi ", "Shen ", "Hai ", "Dui ", "Pian ", "Ping ", "Lei ", "Fu ", "Jia ", "Tou ", "Hui ", "Kui ", "Jia ", "Le ", "Tian ", "Cheng ", "Ying ", "Jun ", "Hu ", "Han ", "Jing ", "Tui ", "Tui ", "Pin ", "Lai ", "Tui ", "Zi ", "Zi ", "Chui ", "Ding ", "Lai ", "Yan ", "Han ", "Jian ", "Ke ", "Cui ", "Jiong ", "Qin ", "Yi ", "Sai ", "Ti ", "E ", "E ", "Yan ", "Hun ", "Kan ", "Yong ", "Zhuan ", "Yan ", "Xian ", "Xin ", "Yi ", "Yuan ", "Sang ", "Dian ", "Dian ", "Jiang ", "Ku ", "Lei ", "Liao ", "Piao ", "Yi ", "Man ", "Qi ", "Rao ", "Hao ", "Qiao ", "Gu ", "Xun ", "Qian ", "Hui ", "Zhan ", "Ru ", "Hong ", "Bin ", "Xian ", "Pin ", "Lu ", "Lan ", "Nie ", "Quan ", "Ye ", "Ding ", "Qing ", "Han ", "Xiang ", "Shun ", "Xu ", "Xu ", "Wan ", "Gu ", "Dun ", "Qi ", "Ban ", "Song ", "Hang ", "Yu ", "Lu ", "Ling ", "Po ", "Jing ", "Jie ", "Jia ", "Tian ", "Han ", "Ying ", "Jiong ", "Hai ", "Yi ", "Pin ", "Hui ", "Tui ", "Han ", "Ying ", "Ying ", "Ke ", "Ti ", "Yong ", "E ", "Zhuan ", "Yan ", "E ", "Nie ", "Man ", "Dian ", "Sang ", "Hao ", "Lei ", "Zhan ", "Ru ", "Pin ", "Quan ", "Feng ", "Biao ", "Oroshi ", "Fu ", "Xia ", "Zhan ", "Biao ", "Sa ", "Ba ", "Tai ", "Lie ", "Gua ", "Xuan ", "Shao ", "Ju ", "Bi ", "Si ", "Wei ", "Yang ", "Yao ", "Sou ", "Kai ", "Sao ", "Fan ", "Liu ", "Xi ", "Liao ", "Piao ", "Piao ", "Liu ", "Biao ", "Biao ", "Biao ", "Liao ", "[?] ", "Se ", "Feng ", "Biao ", "Feng ", "Yang ", "Zhan ", "Biao ", "Sa ", "Ju ", "Si ", "Sou ", "Yao ", "Liu ", "Piao ", "Biao ", "Biao ", "Fei ", "Fan ", "Fei ", "Fei ", "Shi ", "Shi ", "Can ", "Ji ", "Ding ", "Si ", "Tuo ", "Zhan ", "Sun ", "Xiang ", "Tun ", "Ren ", "Yu ", "Juan ", "Chi ", "Yin ", "Fan ", "Fan ", "Sun ", "Yin ", "Zhu ", "Yi ", "Zhai ", "Bi ", "Jie ", "Tao ", "Liu ", "Ci ", "Tie ", "Si ", "Bao ", "Shi ", "Duo "];
  }
});

// node_modules/unidecode/data/x99.js
var require_x99 = __commonJS({
  "node_modules/unidecode/data/x99.js"(exports2, module2) {
    module2.exports = ["Hai ", "Ren ", "Tian ", "Jiao ", "Jia ", "Bing ", "Yao ", "Tong ", "Ci ", "Xiang ", "Yang ", "Yang ", "Er ", "Yan ", "Le ", "Yi ", "Can ", "Bo ", "Nei ", "E ", "Bu ", "Jun ", "Dou ", "Su ", "Yu ", "Shi ", "Yao ", "Hun ", "Guo ", "Shi ", "Jian ", "Zhui ", "Bing ", "Xian ", "Bu ", "Ye ", "Tan ", "Fei ", "Zhang ", "Wei ", "Guan ", "E ", "Nuan ", "Hun ", "Hu ", "Huang ", "Tie ", "Hui ", "Jian ", "Hou ", "He ", "Xing ", "Fen ", "Wei ", "Gu ", "Cha ", "Song ", "Tang ", "Bo ", "Gao ", "Xi ", "Kui ", "Liu ", "Sou ", "Tao ", "Ye ", "Yun ", "Mo ", "Tang ", "Man ", "Bi ", "Yu ", "Xiu ", "Jin ", "San ", "Kui ", "Zhuan ", "Shan ", "Chi ", "Dan ", "Yi ", "Ji ", "Rao ", "Cheng ", "Yong ", "Tao ", "Hui ", "Xiang ", "Zhan ", "Fen ", "Hai ", "Meng ", "Yan ", "Mo ", "Chan ", "Xiang ", "Luo ", "Zuan ", "Nang ", "Shi ", "Ding ", "Ji ", "Tuo ", "Xing ", "Tun ", "Xi ", "Ren ", "Yu ", "Chi ", "Fan ", "Yin ", "Jian ", "Shi ", "Bao ", "Si ", "Duo ", "Yi ", "Er ", "Rao ", "Xiang ", "Jia ", "Le ", "Jiao ", "Yi ", "Bing ", "Bo ", "Dou ", "E ", "Yu ", "Nei ", "Jun ", "Guo ", "Hun ", "Xian ", "Guan ", "Cha ", "Kui ", "Gu ", "Sou ", "Chan ", "Ye ", "Mo ", "Bo ", "Liu ", "Xiu ", "Jin ", "Man ", "San ", "Zhuan ", "Nang ", "Shou ", "Kui ", "Guo ", "Xiang ", "Fen ", "Ba ", "Ni ", "Bi ", "Bo ", "Tu ", "Han ", "Fei ", "Jian ", "An ", "Ai ", "Fu ", "Xian ", "Wen ", "Xin ", "Fen ", "Bin ", "Xing ", "Ma ", "Yu ", "Feng ", "Han ", "Di ", "Tuo ", "Tuo ", "Chi ", "Xun ", "Zhu ", "Zhi ", "Pei ", "Xin ", "Ri ", "Sa ", "Yin ", "Wen ", "Zhi ", "Dan ", "Lu ", "You ", "Bo ", "Bao ", "Kuai ", "Tuo ", "Yi ", "Qu ", "[?] ", "Qu ", "Jiong ", "Bo ", "Zhao ", "Yuan ", "Peng ", "Zhou ", "Ju ", "Zhu ", "Nu ", "Ju ", "Pi ", "Zang ", "Jia ", "Ling ", "Zhen ", "Tai ", "Fu ", "Yang ", "Shi ", "Bi ", "Tuo ", "Tuo ", "Si ", "Liu ", "Ma ", "Pian ", "Tao ", "Zhi ", "Rong ", "Teng ", "Dong ", "Xun ", "Quan ", "Shen ", "Jiong ", "Er ", "Hai ", "Bo ", "Zhu ", "Yin ", "Luo ", "Shuu ", "Dan ", "Xie ", "Liu ", "Ju ", "Song ", "Qin ", "Mang ", "Liang ", "Han ", "Tu ", "Xuan ", "Tui ", "Jun "];
  }
});

// node_modules/unidecode/data/x9a.js
var require_x9a = __commonJS({
  "node_modules/unidecode/data/x9a.js"(exports2, module2) {
    module2.exports = ["E ", "Cheng ", "Xin ", "Ai ", "Lu ", "Zhui ", "Zhou ", "She ", "Pian ", "Kun ", "Tao ", "Lai ", "Zong ", "Ke ", "Qi ", "Qi ", "Yan ", "Fei ", "Sao ", "Yan ", "Jie ", "Yao ", "Wu ", "Pian ", "Cong ", "Pian ", "Qian ", "Fei ", "Huang ", "Jian ", "Huo ", "Yu ", "Ti ", "Quan ", "Xia ", "Zong ", "Kui ", "Rou ", "Si ", "Gua ", "Tuo ", "Kui ", "Sou ", "Qian ", "Cheng ", "Zhi ", "Liu ", "Pang ", "Teng ", "Xi ", "Cao ", "Du ", "Yan ", "Yuan ", "Zou ", "Sao ", "Shan ", "Li ", "Zhi ", "Shuang ", "Lu ", "Xi ", "Luo ", "Zhang ", "Mo ", "Ao ", "Can ", "Piao ", "Cong ", "Qu ", "Bi ", "Zhi ", "Yu ", "Xu ", "Hua ", "Bo ", "Su ", "Xiao ", "Lin ", "Chan ", "Dun ", "Liu ", "Tuo ", "Zeng ", "Tan ", "Jiao ", "Tie ", "Yan ", "Luo ", "Zhan ", "Jing ", "Yi ", "Ye ", "Tuo ", "Bin ", "Zou ", "Yan ", "Peng ", "Lu ", "Teng ", "Xiang ", "Ji ", "Shuang ", "Ju ", "Xi ", "Huan ", "Li ", "Biao ", "Ma ", "Yu ", "Tuo ", "Xun ", "Chi ", "Qu ", "Ri ", "Bo ", "Lu ", "Zang ", "Shi ", "Si ", "Fu ", "Ju ", "Zou ", "Zhu ", "Tuo ", "Nu ", "Jia ", "Yi ", "Tai ", "Xiao ", "Ma ", "Yin ", "Jiao ", "Hua ", "Luo ", "Hai ", "Pian ", "Biao ", "Li ", "Cheng ", "Yan ", "Xin ", "Qin ", "Jun ", "Qi ", "Qi ", "Ke ", "Zhui ", "Zong ", "Su ", "Can ", "Pian ", "Zhi ", "Kui ", "Sao ", "Wu ", "Ao ", "Liu ", "Qian ", "Shan ", "Piao ", "Luo ", "Cong ", "Chan ", "Zou ", "Ji ", "Shuang ", "Xiang ", "Gu ", "Wei ", "Wei ", "Wei ", "Yu ", "Gan ", "Yi ", "Ang ", "Tou ", "Xie ", "Bao ", "Bi ", "Chi ", "Ti ", "Di ", "Ku ", "Hai ", "Qiao ", "Gou ", "Kua ", "Ge ", "Tui ", "Geng ", "Pian ", "Bi ", "Ke ", "Ka ", "Yu ", "Sui ", "Lou ", "Bo ", "Xiao ", "Pang ", "Bo ", "Ci ", "Kuan ", "Bin ", "Mo ", "Liao ", "Lou ", "Nao ", "Du ", "Zang ", "Sui ", "Ti ", "Bin ", "Kuan ", "Lu ", "Gao ", "Gao ", "Qiao ", "Kao ", "Qiao ", "Lao ", "Zao ", "Biao ", "Kun ", "Kun ", "Ti ", "Fang ", "Xiu ", "Ran ", "Mao ", "Dan ", "Kun ", "Bin ", "Fa ", "Tiao ", "Peng ", "Zi ", "Fa ", "Ran ", "Ti ", "Pao ", "Pi ", "Mao ", "Fu ", "Er ", "Rong ", "Qu ", "Gong ", "Xiu ", "Gua ", "Ji ", "Peng ", "Zhua ", "Shao ", "Sha "];
  }
});

// node_modules/unidecode/data/x9b.js
var require_x9b = __commonJS({
  "node_modules/unidecode/data/x9b.js"(exports2, module2) {
    module2.exports = ["Ti ", "Li ", "Bin ", "Zong ", "Ti ", "Peng ", "Song ", "Zheng ", "Quan ", "Zong ", "Shun ", "Jian ", "Duo ", "Hu ", "La ", "Jiu ", "Qi ", "Lian ", "Zhen ", "Bin ", "Peng ", "Mo ", "San ", "Man ", "Man ", "Seng ", "Xu ", "Lie ", "Qian ", "Qian ", "Nong ", "Huan ", "Kuai ", "Ning ", "Bin ", "Lie ", "Rang ", "Dou ", "Dou ", "Nao ", "Hong ", "Xi ", "Dou ", "Han ", "Dou ", "Dou ", "Jiu ", "Chang ", "Yu ", "Yu ", "Li ", "Juan ", "Fu ", "Qian ", "Gui ", "Zong ", "Liu ", "Gui ", "Shang ", "Yu ", "Gui ", "Mei ", "Ji ", "Qi ", "Jie ", "Kui ", "Hun ", "Ba ", "Po ", "Mei ", "Xu ", "Yan ", "Xiao ", "Liang ", "Yu ", "Tui ", "Qi ", "Wang ", "Liang ", "Wei ", "Jian ", "Chi ", "Piao ", "Bi ", "Mo ", "Ji ", "Xu ", "Chou ", "Yan ", "Zhan ", "Yu ", "Dao ", "Ren ", "Ji ", "Eri ", "Gong ", "Tuo ", "Diao ", "Ji ", "Xu ", "E ", "E ", "Sha ", "Hang ", "Tun ", "Mo ", "Jie ", "Shen ", "Fan ", "Yuan ", "Bi ", "Lu ", "Wen ", "Hu ", "Lu ", "Za ", "Fang ", "Fen ", "Na ", "You ", "Namazu ", "Todo ", "He ", "Xia ", "Qu ", "Han ", "Pi ", "Ling ", "Tuo ", "Bo ", "Qiu ", "Ping ", "Fu ", "Bi ", "Ji ", "Wei ", "Ju ", "Diao ", "Bo ", "You ", "Gun ", "Pi ", "Nian ", "Xing ", "Tai ", "Bao ", "Fu ", "Zha ", "Ju ", "Gu ", "Kajika ", "Tong ", "[?] ", "Ta ", "Jie ", "Shu ", "Hou ", "Xiang ", "Er ", "An ", "Wei ", "Tiao ", "Zhu ", "Yin ", "Lie ", "Luo ", "Tong ", "Yi ", "Qi ", "Bing ", "Wei ", "Jiao ", "Bu ", "Gui ", "Xian ", "Ge ", "Hui ", "Bora ", "Mate ", "Kao ", "Gori ", "Duo ", "Jun ", "Ti ", "Man ", "Xiao ", "Za ", "Sha ", "Qin ", "Yu ", "Nei ", "Zhe ", "Gun ", "Geng ", "Su ", "Wu ", "Qiu ", "Ting ", "Fu ", "Wan ", "You ", "Li ", "Sha ", "Sha ", "Gao ", "Meng ", "Ugui ", "Asari ", "Subashiri ", "Kazunoko ", "Yong ", "Ni ", "Zi ", "Qi ", "Qing ", "Xiang ", "Nei ", "Chun ", "Ji ", "Diao ", "Qie ", "Gu ", "Zhou ", "Dong ", "Lai ", "Fei ", "Ni ", "Yi ", "Kun ", "Lu ", "Jiu ", "Chang ", "Jing ", "Lun ", "Ling ", "Zou ", "Li ", "Meng ", "Zong ", "Zhi ", "Nian ", "Shachi ", "Dojou ", "Sukesou ", "Shi ", "Shen ", "Hun ", "Shi ", "Hou ", "Xing ", "Zhu ", "La ", "Zong ", "Ji ", "Bian ", "Bian "];
  }
});

// node_modules/unidecode/data/x9c.js
var require_x9c = __commonJS({
  "node_modules/unidecode/data/x9c.js"(exports2, module2) {
    module2.exports = ["Huan ", "Quan ", "Ze ", "Wei ", "Wei ", "Yu ", "Qun ", "Rou ", "Die ", "Huang ", "Lian ", "Yan ", "Qiu ", "Qiu ", "Jian ", "Bi ", "E ", "Yang ", "Fu ", "Sai ", "Jian ", "Xia ", "Tuo ", "Hu ", "Muroaji ", "Ruo ", "Haraka ", "Wen ", "Jian ", "Hao ", "Wu ", "Fang ", "Sao ", "Liu ", "Ma ", "Shi ", "Shi ", "Yin ", "Z ", "Teng ", "Ta ", "Yao ", "Ge ", "Rong ", "Qian ", "Qi ", "Wen ", "Ruo ", "Hatahata ", "Lian ", "Ao ", "Le ", "Hui ", "Min ", "Ji ", "Tiao ", "Qu ", "Jian ", "Sao ", "Man ", "Xi ", "Qiu ", "Biao ", "Ji ", "Ji ", "Zhu ", "Jiang ", "Qiu ", "Zhuan ", "Yong ", "Zhang ", "Kang ", "Xue ", "Bie ", "Jue ", "Qu ", "Xiang ", "Bo ", "Jiao ", "Xun ", "Su ", "Huang ", "Zun ", "Shan ", "Shan ", "Fan ", "Jue ", "Lin ", "Xun ", "Miao ", "Xi ", "Eso ", "Kyou ", "Fen ", "Guan ", "Hou ", "Kuai ", "Zei ", "Sao ", "Zhan ", "Gan ", "Gui ", "Sheng ", "Li ", "Chang ", "Hatahata ", "Shiira ", "Mutsu ", "Ru ", "Ji ", "Xu ", "Huo ", "Shiira ", "Li ", "Lie ", "Li ", "Mie ", "Zhen ", "Xiang ", "E ", "Lu ", "Guan ", "Li ", "Xian ", "Yu ", "Dao ", "Ji ", "You ", "Tun ", "Lu ", "Fang ", "Ba ", "He ", "Bo ", "Ping ", "Nian ", "Lu ", "You ", "Zha ", "Fu ", "Bo ", "Bao ", "Hou ", "Pi ", "Tai ", "Gui ", "Jie ", "Kao ", "Wei ", "Er ", "Tong ", "Ze ", "Hou ", "Kuai ", "Ji ", "Jiao ", "Xian ", "Za ", "Xiang ", "Xun ", "Geng ", "Li ", "Lian ", "Jian ", "Li ", "Shi ", "Tiao ", "Gun ", "Sha ", "Wan ", "Jun ", "Ji ", "Yong ", "Qing ", "Ling ", "Qi ", "Zou ", "Fei ", "Kun ", "Chang ", "Gu ", "Ni ", "Nian ", "Diao ", "Jing ", "Shen ", "Shi ", "Zi ", "Fen ", "Die ", "Bi ", "Chang ", "Shi ", "Wen ", "Wei ", "Sai ", "E ", "Qiu ", "Fu ", "Huang ", "Quan ", "Jiang ", "Bian ", "Sao ", "Ao ", "Qi ", "Ta ", "Yin ", "Yao ", "Fang ", "Jian ", "Le ", "Biao ", "Xue ", "Bie ", "Man ", "Min ", "Yong ", "Wei ", "Xi ", "Jue ", "Shan ", "Lin ", "Zun ", "Huo ", "Gan ", "Li ", "Zhan ", "Guan ", "Niao ", "Yi ", "Fu ", "Li ", "Jiu ", "Bu ", "Yan ", "Fu ", "Diao ", "Ji ", "Feng ", "Nio ", "Gan ", "Shi ", "Feng ", "Ming ", "Bao ", "Yuan ", "Zhi ", "Hu ", "Qin ", "Fu ", "Fen ", "Wen ", "Jian ", "Shi ", "Yu "];
  }
});

// node_modules/unidecode/data/x9d.js
var require_x9d = __commonJS({
  "node_modules/unidecode/data/x9d.js"(exports2, module2) {
    module2.exports = ["Fou ", "Yiao ", "Jue ", "Jue ", "Pi ", "Huan ", "Zhen ", "Bao ", "Yan ", "Ya ", "Zheng ", "Fang ", "Feng ", "Wen ", "Ou ", "Te ", "Jia ", "Nu ", "Ling ", "Mie ", "Fu ", "Tuo ", "Wen ", "Li ", "Bian ", "Zhi ", "Ge ", "Yuan ", "Zi ", "Qu ", "Xiao ", "Zhi ", "Dan ", "Ju ", "You ", "Gu ", "Zhong ", "Yu ", "Yang ", "Rong ", "Ya ", "Tie ", "Yu ", "Shigi ", "Ying ", "Zhui ", "Wu ", "Er ", "Gua ", "Ai ", "Zhi ", "Yan ", "Heng ", "Jiao ", "Ji ", "Lie ", "Zhu ", "Ren ", "Yi ", "Hong ", "Luo ", "Ru ", "Mou ", "Ge ", "Ren ", "Jiao ", "Xiu ", "Zhou ", "Zhi ", "Luo ", "Chidori ", "Toki ", "Ten ", "Luan ", "Jia ", "Ji ", "Yu ", "Huan ", "Tuo ", "Bu ", "Wu ", "Juan ", "Yu ", "Bo ", "Xun ", "Xun ", "Bi ", "Xi ", "Jun ", "Ju ", "Tu ", "Jing ", "Ti ", "E ", "E ", "Kuang ", "Hu ", "Wu ", "Shen ", "Lai ", "Ikaruga ", "Kakesu ", "Lu ", "Ping ", "Shu ", "Fu ", "An ", "Zhao ", "Peng ", "Qin ", "Qian ", "Bei ", "Diao ", "Lu ", "Que ", "Jian ", "Ju ", "Tu ", "Ya ", "Yuan ", "Qi ", "Li ", "Ye ", "Zhui ", "Kong ", "Zhui ", "Kun ", "Sheng ", "Qi ", "Jing ", "Yi ", "Yi ", "Jing ", "Zi ", "Lai ", "Dong ", "Qi ", "Chun ", "Geng ", "Ju ", "Qu ", "Isuka ", "Kikuitadaki ", "Ji ", "Shu ", "[?] ", "Chi ", "Miao ", "Rou ", "An ", "Qiu ", "Ti ", "Hu ", "Ti ", "E ", "Jie ", "Mao ", "Fu ", "Chun ", "Tu ", "Yan ", "He ", "Yuan ", "Pian ", "Yun ", "Mei ", "Hu ", "Ying ", "Dun ", "Mu ", "Ju ", "Tsugumi ", "Cang ", "Fang ", "Gu ", "Ying ", "Yuan ", "Xuan ", "Weng ", "Shi ", "He ", "Chu ", "Tang ", "Xia ", "Ruo ", "Liu ", "Ji ", "Gu ", "Jian ", "Zhun ", "Han ", "Zi ", "Zi ", "Ni ", "Yao ", "Yan ", "Ji ", "Li ", "Tian ", "Kou ", "Ti ", "Ti ", "Ni ", "Tu ", "Ma ", "Jiao ", "Gao ", "Tian ", "Chen ", "Li ", "Zhuan ", "Zhe ", "Ao ", "Yao ", "Yi ", "Ou ", "Chi ", "Zhi ", "Liao ", "Rong ", "Lou ", "Bi ", "Shuang ", "Zhuo ", "Yu ", "Wu ", "Jue ", "Yin ", "Quan ", "Si ", "Jiao ", "Yi ", "Hua ", "Bi ", "Ying ", "Su ", "Huang ", "Fan ", "Jiao ", "Liao ", "Yan ", "Kao ", "Jiu ", "Xian ", "Xian ", "Tu ", "Mai ", "Zun ", "Yu ", "Ying ", "Lu ", "Tuan ", "Xian ", "Xue ", "Yi ", "Pi "];
  }
});

// node_modules/unidecode/data/x9e.js
var require_x9e = __commonJS({
  "node_modules/unidecode/data/x9e.js"(exports2, module2) {
    module2.exports = ["Shu ", "Luo ", "Qi ", "Yi ", "Ji ", "Zhe ", "Yu ", "Zhan ", "Ye ", "Yang ", "Pi ", "Ning ", "Huo ", "Mi ", "Ying ", "Meng ", "Di ", "Yue ", "Yu ", "Lei ", "Bao ", "Lu ", "He ", "Long ", "Shuang ", "Yue ", "Ying ", "Guan ", "Qu ", "Li ", "Luan ", "Niao ", "Jiu ", "Ji ", "Yuan ", "Ming ", "Shi ", "Ou ", "Ya ", "Cang ", "Bao ", "Zhen ", "Gu ", "Dong ", "Lu ", "Ya ", "Xiao ", "Yang ", "Ling ", "Zhi ", "Qu ", "Yuan ", "Xue ", "Tuo ", "Si ", "Zhi ", "Er ", "Gua ", "Xiu ", "Heng ", "Zhou ", "Ge ", "Luan ", "Hong ", "Wu ", "Bo ", "Li ", "Juan ", "Hu ", "E ", "Yu ", "Xian ", "Ti ", "Wu ", "Que ", "Miao ", "An ", "Kun ", "Bei ", "Peng ", "Qian ", "Chun ", "Geng ", "Yuan ", "Su ", "Hu ", "He ", "E ", "Gu ", "Qiu ", "Zi ", "Mei ", "Mu ", "Ni ", "Yao ", "Weng ", "Liu ", "Ji ", "Ni ", "Jian ", "He ", "Yi ", "Ying ", "Zhe ", "Liao ", "Liao ", "Jiao ", "Jiu ", "Yu ", "Lu ", "Xuan ", "Zhan ", "Ying ", "Huo ", "Meng ", "Guan ", "Shuang ", "Lu ", "Jin ", "Ling ", "Jian ", "Xian ", "Cuo ", "Jian ", "Jian ", "Yan ", "Cuo ", "Lu ", "You ", "Cu ", "Ji ", "Biao ", "Cu ", "Biao ", "Zhu ", "Jun ", "Zhu ", "Jian ", "Mi ", "Mi ", "Wu ", "Liu ", "Chen ", "Jun ", "Lin ", "Ni ", "Qi ", "Lu ", "Jiu ", "Jun ", "Jing ", "Li ", "Xiang ", "Yan ", "Jia ", "Mi ", "Li ", "She ", "Zhang ", "Lin ", "Jing ", "Ji ", "Ling ", "Yan ", "Cu ", "Mai ", "Mai ", "Ge ", "Chao ", "Fu ", "Mian ", "Mian ", "Fu ", "Pao ", "Qu ", "Qu ", "Mou ", "Fu ", "Xian ", "Lai ", "Qu ", "Mian ", "[?] ", "Feng ", "Fu ", "Qu ", "Mian ", "Ma ", "Mo ", "Mo ", "Hui ", "Ma ", "Zou ", "Nen ", "Fen ", "Huang ", "Huang ", "Jin ", "Guang ", "Tian ", "Tou ", "Heng ", "Xi ", "Kuang ", "Heng ", "Shu ", "Li ", "Nian ", "Chi ", "Hei ", "Hei ", "Yi ", "Qian ", "Dan ", "Xi ", "Tuan ", "Mo ", "Mo ", "Qian ", "Dai ", "Chu ", "You ", "Dian ", "Yi ", "Xia ", "Yan ", "Qu ", "Mei ", "Yan ", "Jing ", "Yu ", "Li ", "Dang ", "Du ", "Can ", "Yin ", "An ", "Yan ", "Tan ", "An ", "Zhen ", "Dai ", "Can ", "Yi ", "Mei ", "Dan ", "Yan ", "Du ", "Lu ", "Zhi ", "Fen ", "Fu ", "Fu ", "Min ", "Min ", "Yuan "];
  }
});

// node_modules/unidecode/data/x9f.js
var require_x9f = __commonJS({
  "node_modules/unidecode/data/x9f.js"(exports2, module2) {
    module2.exports = ["Cu ", "Qu ", "Chao ", "Wa ", "Zhu ", "Zhi ", "Mang ", "Ao ", "Bie ", "Tuo ", "Bi ", "Yuan ", "Chao ", "Tuo ", "Ding ", "Mi ", "Nai ", "Ding ", "Zi ", "Gu ", "Gu ", "Dong ", "Fen ", "Tao ", "Yuan ", "Pi ", "Chang ", "Gao ", "Qi ", "Yuan ", "Tang ", "Teng ", "Shu ", "Shu ", "Fen ", "Fei ", "Wen ", "Ba ", "Diao ", "Tuo ", "Tong ", "Qu ", "Sheng ", "Shi ", "You ", "Shi ", "Ting ", "Wu ", "Nian ", "Jing ", "Hun ", "Ju ", "Yan ", "Tu ", "Ti ", "Xi ", "Xian ", "Yan ", "Lei ", "Bi ", "Yao ", "Qiu ", "Han ", "Wu ", "Wu ", "Hou ", "Xi ", "Ge ", "Zha ", "Xiu ", "Weng ", "Zha ", "Nong ", "Nang ", "Qi ", "Zhai ", "Ji ", "Zi ", "Ji ", "Ji ", "Qi ", "Ji ", "Chi ", "Chen ", "Chen ", "He ", "Ya ", "Ken ", "Xie ", "Pao ", "Cuo ", "Shi ", "Zi ", "Chi ", "Nian ", "Ju ", "Tiao ", "Ling ", "Ling ", "Chu ", "Quan ", "Xie ", "Ken ", "Nie ", "Jiu ", "Yao ", "Chuo ", "Kun ", "Yu ", "Chu ", "Yi ", "Ni ", "Cuo ", "Zou ", "Qu ", "Nen ", "Xian ", "Ou ", "E ", "Wo ", "Yi ", "Chuo ", "Zou ", "Dian ", "Chu ", "Jin ", "Ya ", "Chi ", "Chen ", "He ", "Ken ", "Ju ", "Ling ", "Pao ", "Tiao ", "Zi ", "Ken ", "Yu ", "Chuo ", "Qu ", "Wo ", "Long ", "Pang ", "Gong ", "Pang ", "Yan ", "Long ", "Long ", "Gong ", "Kan ", "Ta ", "Ling ", "Ta ", "Long ", "Gong ", "Kan ", "Gui ", "Qiu ", "Bie ", "Gui ", "Yue ", "Chui ", "He ", "Jue ", "Xie ", "Yu ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xa0.js
var require_xa0 = __commonJS({
  "node_modules/unidecode/data/xa0.js"(exports2, module2) {
    module2.exports = ["it", "ix", "i", "ip", "iet", "iex", "ie", "iep", "at", "ax", "a", "ap", "uox", "uo", "uop", "ot", "ox", "o", "op", "ex", "e", "wu", "bit", "bix", "bi", "bip", "biet", "biex", "bie", "biep", "bat", "bax", "ba", "bap", "buox", "buo", "buop", "bot", "box", "bo", "bop", "bex", "be", "bep", "but", "bux", "bu", "bup", "burx", "bur", "byt", "byx", "by", "byp", "byrx", "byr", "pit", "pix", "pi", "pip", "piex", "pie", "piep", "pat", "pax", "pa", "pap", "puox", "puo", "puop", "pot", "pox", "po", "pop", "put", "pux", "pu", "pup", "purx", "pur", "pyt", "pyx", "py", "pyp", "pyrx", "pyr", "bbit", "bbix", "bbi", "bbip", "bbiet", "bbiex", "bbie", "bbiep", "bbat", "bbax", "bba", "bbap", "bbuox", "bbuo", "bbuop", "bbot", "bbox", "bbo", "bbop", "bbex", "bbe", "bbep", "bbut", "bbux", "bbu", "bbup", "bburx", "bbur", "bbyt", "bbyx", "bby", "bbyp", "nbit", "nbix", "nbi", "nbip", "nbiex", "nbie", "nbiep", "nbat", "nbax", "nba", "nbap", "nbot", "nbox", "nbo", "nbop", "nbut", "nbux", "nbu", "nbup", "nburx", "nbur", "nbyt", "nbyx", "nby", "nbyp", "nbyrx", "nbyr", "hmit", "hmix", "hmi", "hmip", "hmiex", "hmie", "hmiep", "hmat", "hmax", "hma", "hmap", "hmuox", "hmuo", "hmuop", "hmot", "hmox", "hmo", "hmop", "hmut", "hmux", "hmu", "hmup", "hmurx", "hmur", "hmyx", "hmy", "hmyp", "hmyrx", "hmyr", "mit", "mix", "mi", "mip", "miex", "mie", "miep", "mat", "max", "ma", "map", "muot", "muox", "muo", "muop", "mot", "mox", "mo", "mop", "mex", "me", "mut", "mux", "mu", "mup", "murx", "mur", "myt", "myx", "my", "myp", "fit", "fix", "fi", "fip", "fat", "fax", "fa", "fap", "fox", "fo", "fop", "fut", "fux", "fu", "fup", "furx", "fur", "fyt", "fyx", "fy", "fyp", "vit", "vix", "vi", "vip", "viet", "viex", "vie", "viep", "vat", "vax", "va", "vap", "vot", "vox", "vo", "vop", "vex", "vep", "vut", "vux", "vu", "vup", "vurx", "vur", "vyt", "vyx", "vy", "vyp", "vyrx", "vyr"];
  }
});

// node_modules/unidecode/data/xa1.js
var require_xa1 = __commonJS({
  "node_modules/unidecode/data/xa1.js"(exports2, module2) {
    module2.exports = ["dit", "dix", "di", "dip", "diex", "die", "diep", "dat", "dax", "da", "dap", "duox", "duo", "dot", "dox", "do", "dop", "dex", "de", "dep", "dut", "dux", "du", "dup", "durx", "dur", "tit", "tix", "ti", "tip", "tiex", "tie", "tiep", "tat", "tax", "ta", "tap", "tuot", "tuox", "tuo", "tuop", "tot", "tox", "to", "top", "tex", "te", "tep", "tut", "tux", "tu", "tup", "turx", "tur", "ddit", "ddix", "ddi", "ddip", "ddiex", "ddie", "ddiep", "ddat", "ddax", "dda", "ddap", "dduox", "dduo", "dduop", "ddot", "ddox", "ddo", "ddop", "ddex", "dde", "ddep", "ddut", "ddux", "ddu", "ddup", "ddurx", "ddur", "ndit", "ndix", "ndi", "ndip", "ndiex", "ndie", "ndat", "ndax", "nda", "ndap", "ndot", "ndox", "ndo", "ndop", "ndex", "nde", "ndep", "ndut", "ndux", "ndu", "ndup", "ndurx", "ndur", "hnit", "hnix", "hni", "hnip", "hniet", "hniex", "hnie", "hniep", "hnat", "hnax", "hna", "hnap", "hnuox", "hnuo", "hnot", "hnox", "hnop", "hnex", "hne", "hnep", "hnut", "nit", "nix", "ni", "nip", "niex", "nie", "niep", "nax", "na", "nap", "nuox", "nuo", "nuop", "not", "nox", "no", "nop", "nex", "ne", "nep", "nut", "nux", "nu", "nup", "nurx", "nur", "hlit", "hlix", "hli", "hlip", "hliex", "hlie", "hliep", "hlat", "hlax", "hla", "hlap", "hluox", "hluo", "hluop", "hlox", "hlo", "hlop", "hlex", "hle", "hlep", "hlut", "hlux", "hlu", "hlup", "hlurx", "hlur", "hlyt", "hlyx", "hly", "hlyp", "hlyrx", "hlyr", "lit", "lix", "li", "lip", "liet", "liex", "lie", "liep", "lat", "lax", "la", "lap", "luot", "luox", "luo", "luop", "lot", "lox", "lo", "lop", "lex", "le", "lep", "lut", "lux", "lu", "lup", "lurx", "lur", "lyt", "lyx", "ly", "lyp", "lyrx", "lyr", "git", "gix", "gi", "gip", "giet", "giex", "gie", "giep", "gat", "gax", "ga", "gap", "guot", "guox", "guo", "guop", "got", "gox", "go", "gop", "get", "gex", "ge", "gep", "gut", "gux", "gu", "gup", "gurx", "gur", "kit", "kix", "ki", "kip", "kiex", "kie", "kiep", "kat"];
  }
});

// node_modules/unidecode/data/xa2.js
var require_xa2 = __commonJS({
  "node_modules/unidecode/data/xa2.js"(exports2, module2) {
    module2.exports = ["kax", "ka", "kap", "kuox", "kuo", "kuop", "kot", "kox", "ko", "kop", "ket", "kex", "ke", "kep", "kut", "kux", "ku", "kup", "kurx", "kur", "ggit", "ggix", "ggi", "ggiex", "ggie", "ggiep", "ggat", "ggax", "gga", "ggap", "gguot", "gguox", "gguo", "gguop", "ggot", "ggox", "ggo", "ggop", "gget", "ggex", "gge", "ggep", "ggut", "ggux", "ggu", "ggup", "ggurx", "ggur", "mgiex", "mgie", "mgat", "mgax", "mga", "mgap", "mguox", "mguo", "mguop", "mgot", "mgox", "mgo", "mgop", "mgex", "mge", "mgep", "mgut", "mgux", "mgu", "mgup", "mgurx", "mgur", "hxit", "hxix", "hxi", "hxip", "hxiet", "hxiex", "hxie", "hxiep", "hxat", "hxax", "hxa", "hxap", "hxuot", "hxuox", "hxuo", "hxuop", "hxot", "hxox", "hxo", "hxop", "hxex", "hxe", "hxep", "ngiex", "ngie", "ngiep", "ngat", "ngax", "nga", "ngap", "nguot", "nguox", "nguo", "ngot", "ngox", "ngo", "ngop", "ngex", "nge", "ngep", "hit", "hiex", "hie", "hat", "hax", "ha", "hap", "huot", "huox", "huo", "huop", "hot", "hox", "ho", "hop", "hex", "he", "hep", "wat", "wax", "wa", "wap", "wuox", "wuo", "wuop", "wox", "wo", "wop", "wex", "we", "wep", "zit", "zix", "zi", "zip", "ziex", "zie", "ziep", "zat", "zax", "za", "zap", "zuox", "zuo", "zuop", "zot", "zox", "zo", "zop", "zex", "ze", "zep", "zut", "zux", "zu", "zup", "zurx", "zur", "zyt", "zyx", "zy", "zyp", "zyrx", "zyr", "cit", "cix", "ci", "cip", "ciet", "ciex", "cie", "ciep", "cat", "cax", "ca", "cap", "cuox", "cuo", "cuop", "cot", "cox", "co", "cop", "cex", "ce", "cep", "cut", "cux", "cu", "cup", "curx", "cur", "cyt", "cyx", "cy", "cyp", "cyrx", "cyr", "zzit", "zzix", "zzi", "zzip", "zziet", "zziex", "zzie", "zziep", "zzat", "zzax", "zza", "zzap", "zzox", "zzo", "zzop", "zzex", "zze", "zzep", "zzux", "zzu", "zzup", "zzurx", "zzur", "zzyt", "zzyx", "zzy", "zzyp", "zzyrx", "zzyr", "nzit", "nzix", "nzi", "nzip", "nziex", "nzie", "nziep", "nzat", "nzax", "nza", "nzap", "nzuox", "nzuo", "nzox", "nzop", "nzex", "nze", "nzux", "nzu"];
  }
});

// node_modules/unidecode/data/xa3.js
var require_xa3 = __commonJS({
  "node_modules/unidecode/data/xa3.js"(exports2, module2) {
    module2.exports = ["nzup", "nzurx", "nzur", "nzyt", "nzyx", "nzy", "nzyp", "nzyrx", "nzyr", "sit", "six", "si", "sip", "siex", "sie", "siep", "sat", "sax", "sa", "sap", "suox", "suo", "suop", "sot", "sox", "so", "sop", "sex", "se", "sep", "sut", "sux", "su", "sup", "surx", "sur", "syt", "syx", "sy", "syp", "syrx", "syr", "ssit", "ssix", "ssi", "ssip", "ssiex", "ssie", "ssiep", "ssat", "ssax", "ssa", "ssap", "ssot", "ssox", "sso", "ssop", "ssex", "sse", "ssep", "ssut", "ssux", "ssu", "ssup", "ssyt", "ssyx", "ssy", "ssyp", "ssyrx", "ssyr", "zhat", "zhax", "zha", "zhap", "zhuox", "zhuo", "zhuop", "zhot", "zhox", "zho", "zhop", "zhet", "zhex", "zhe", "zhep", "zhut", "zhux", "zhu", "zhup", "zhurx", "zhur", "zhyt", "zhyx", "zhy", "zhyp", "zhyrx", "zhyr", "chat", "chax", "cha", "chap", "chuot", "chuox", "chuo", "chuop", "chot", "chox", "cho", "chop", "chet", "chex", "che", "chep", "chux", "chu", "chup", "churx", "chur", "chyt", "chyx", "chy", "chyp", "chyrx", "chyr", "rrax", "rra", "rruox", "rruo", "rrot", "rrox", "rro", "rrop", "rret", "rrex", "rre", "rrep", "rrut", "rrux", "rru", "rrup", "rrurx", "rrur", "rryt", "rryx", "rry", "rryp", "rryrx", "rryr", "nrat", "nrax", "nra", "nrap", "nrox", "nro", "nrop", "nret", "nrex", "nre", "nrep", "nrut", "nrux", "nru", "nrup", "nrurx", "nrur", "nryt", "nryx", "nry", "nryp", "nryrx", "nryr", "shat", "shax", "sha", "shap", "shuox", "shuo", "shuop", "shot", "shox", "sho", "shop", "shet", "shex", "she", "shep", "shut", "shux", "shu", "shup", "shurx", "shur", "shyt", "shyx", "shy", "shyp", "shyrx", "shyr", "rat", "rax", "ra", "rap", "ruox", "ruo", "ruop", "rot", "rox", "ro", "rop", "rex", "re", "rep", "rut", "rux", "ru", "rup", "rurx", "rur", "ryt", "ryx", "ry", "ryp", "ryrx", "ryr", "jit", "jix", "ji", "jip", "jiet", "jiex", "jie", "jiep", "juot", "juox", "juo", "juop", "jot", "jox", "jo", "jop", "jut", "jux", "ju", "jup", "jurx", "jur", "jyt", "jyx", "jy", "jyp", "jyrx", "jyr", "qit", "qix", "qi", "qip"];
  }
});

// node_modules/unidecode/data/xa4.js
var require_xa4 = __commonJS({
  "node_modules/unidecode/data/xa4.js"(exports2, module2) {
    module2.exports = ["qiet", "qiex", "qie", "qiep", "quot", "quox", "quo", "quop", "qot", "qox", "qo", "qop", "qut", "qux", "qu", "qup", "qurx", "qur", "qyt", "qyx", "qy", "qyp", "qyrx", "qyr", "jjit", "jjix", "jji", "jjip", "jjiet", "jjiex", "jjie", "jjiep", "jjuox", "jjuo", "jjuop", "jjot", "jjox", "jjo", "jjop", "jjut", "jjux", "jju", "jjup", "jjurx", "jjur", "jjyt", "jjyx", "jjy", "jjyp", "njit", "njix", "nji", "njip", "njiet", "njiex", "njie", "njiep", "njuox", "njuo", "njot", "njox", "njo", "njop", "njux", "nju", "njup", "njurx", "njur", "njyt", "njyx", "njy", "njyp", "njyrx", "njyr", "nyit", "nyix", "nyi", "nyip", "nyiet", "nyiex", "nyie", "nyiep", "nyuox", "nyuo", "nyuop", "nyot", "nyox", "nyo", "nyop", "nyut", "nyux", "nyu", "nyup", "xit", "xix", "xi", "xip", "xiet", "xiex", "xie", "xiep", "xuox", "xuo", "xot", "xox", "xo", "xop", "xyt", "xyx", "xy", "xyp", "xyrx", "xyr", "yit", "yix", "yi", "yip", "yiet", "yiex", "yie", "yiep", "yuot", "yuox", "yuo", "yuop", "yot", "yox", "yo", "yop", "yut", "yux", "yu", "yup", "yurx", "yur", "yyt", "yyx", "yy", "yyp", "yyrx", "yyr", "[?]", "[?]", "[?]", "Qot", "Li", "Kit", "Nyip", "Cyp", "Ssi", "Ggop", "Gep", "Mi", "Hxit", "Lyr", "Bbut", "Mop", "Yo", "Put", "Hxuo", "Tat", "Ga", "[?]", "[?]", "Ddur", "Bur", "Gguo", "Nyop", "Tu", "Op", "Jjut", "Zot", "Pyt", "Hmo", "Yit", "Vur", "Shy", "Vep", "Za", "Jo", "[?]", "Jjy", "Got", "Jjie", "Wo", "Du", "Shur", "Lie", "Cy", "Cuop", "Cip", "Hxop", "Shat", "[?]", "Shop", "Che", "Zziet", "[?]", "Ke", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xac.js
var require_xac = __commonJS({
  "node_modules/unidecode/data/xac.js"(exports2, module2) {
    module2.exports = ["ga", "gag", "gagg", "gags", "gan", "ganj", "ganh", "gad", "gal", "galg", "galm", "galb", "gals", "galt", "galp", "galh", "gam", "gab", "gabs", "gas", "gass", "gang", "gaj", "gac", "gak", "gat", "gap", "gah", "gae", "gaeg", "gaegg", "gaegs", "gaen", "gaenj", "gaenh", "gaed", "gael", "gaelg", "gaelm", "gaelb", "gaels", "gaelt", "gaelp", "gaelh", "gaem", "gaeb", "gaebs", "gaes", "gaess", "gaeng", "gaej", "gaec", "gaek", "gaet", "gaep", "gaeh", "gya", "gyag", "gyagg", "gyags", "gyan", "gyanj", "gyanh", "gyad", "gyal", "gyalg", "gyalm", "gyalb", "gyals", "gyalt", "gyalp", "gyalh", "gyam", "gyab", "gyabs", "gyas", "gyass", "gyang", "gyaj", "gyac", "gyak", "gyat", "gyap", "gyah", "gyae", "gyaeg", "gyaegg", "gyaegs", "gyaen", "gyaenj", "gyaenh", "gyaed", "gyael", "gyaelg", "gyaelm", "gyaelb", "gyaels", "gyaelt", "gyaelp", "gyaelh", "gyaem", "gyaeb", "gyaebs", "gyaes", "gyaess", "gyaeng", "gyaej", "gyaec", "gyaek", "gyaet", "gyaep", "gyaeh", "geo", "geog", "geogg", "geogs", "geon", "geonj", "geonh", "geod", "geol", "geolg", "geolm", "geolb", "geols", "geolt", "geolp", "geolh", "geom", "geob", "geobs", "geos", "geoss", "geong", "geoj", "geoc", "geok", "geot", "geop", "geoh", "ge", "geg", "gegg", "gegs", "gen", "genj", "genh", "ged", "gel", "gelg", "gelm", "gelb", "gels", "gelt", "gelp", "gelh", "gem", "geb", "gebs", "ges", "gess", "geng", "gej", "gec", "gek", "get", "gep", "geh", "gyeo", "gyeog", "gyeogg", "gyeogs", "gyeon", "gyeonj", "gyeonh", "gyeod", "gyeol", "gyeolg", "gyeolm", "gyeolb", "gyeols", "gyeolt", "gyeolp", "gyeolh", "gyeom", "gyeob", "gyeobs", "gyeos", "gyeoss", "gyeong", "gyeoj", "gyeoc", "gyeok", "gyeot", "gyeop", "gyeoh", "gye", "gyeg", "gyegg", "gyegs", "gyen", "gyenj", "gyenh", "gyed", "gyel", "gyelg", "gyelm", "gyelb", "gyels", "gyelt", "gyelp", "gyelh", "gyem", "gyeb", "gyebs", "gyes", "gyess", "gyeng", "gyej", "gyec", "gyek", "gyet", "gyep", "gyeh", "go", "gog", "gogg", "gogs", "gon", "gonj", "gonh", "god", "gol", "golg", "golm", "golb", "gols", "golt", "golp", "golh", "gom", "gob", "gobs", "gos", "goss", "gong", "goj", "goc", "gok", "got", "gop", "goh", "gwa", "gwag", "gwagg", "gwags"];
  }
});

// node_modules/unidecode/data/xad.js
var require_xad = __commonJS({
  "node_modules/unidecode/data/xad.js"(exports2, module2) {
    module2.exports = ["gwan", "gwanj", "gwanh", "gwad", "gwal", "gwalg", "gwalm", "gwalb", "gwals", "gwalt", "gwalp", "gwalh", "gwam", "gwab", "gwabs", "gwas", "gwass", "gwang", "gwaj", "gwac", "gwak", "gwat", "gwap", "gwah", "gwae", "gwaeg", "gwaegg", "gwaegs", "gwaen", "gwaenj", "gwaenh", "gwaed", "gwael", "gwaelg", "gwaelm", "gwaelb", "gwaels", "gwaelt", "gwaelp", "gwaelh", "gwaem", "gwaeb", "gwaebs", "gwaes", "gwaess", "gwaeng", "gwaej", "gwaec", "gwaek", "gwaet", "gwaep", "gwaeh", "goe", "goeg", "goegg", "goegs", "goen", "goenj", "goenh", "goed", "goel", "goelg", "goelm", "goelb", "goels", "goelt", "goelp", "goelh", "goem", "goeb", "goebs", "goes", "goess", "goeng", "goej", "goec", "goek", "goet", "goep", "goeh", "gyo", "gyog", "gyogg", "gyogs", "gyon", "gyonj", "gyonh", "gyod", "gyol", "gyolg", "gyolm", "gyolb", "gyols", "gyolt", "gyolp", "gyolh", "gyom", "gyob", "gyobs", "gyos", "gyoss", "gyong", "gyoj", "gyoc", "gyok", "gyot", "gyop", "gyoh", "gu", "gug", "gugg", "gugs", "gun", "gunj", "gunh", "gud", "gul", "gulg", "gulm", "gulb", "guls", "gult", "gulp", "gulh", "gum", "gub", "gubs", "gus", "guss", "gung", "guj", "guc", "guk", "gut", "gup", "guh", "gweo", "gweog", "gweogg", "gweogs", "gweon", "gweonj", "gweonh", "gweod", "gweol", "gweolg", "gweolm", "gweolb", "gweols", "gweolt", "gweolp", "gweolh", "gweom", "gweob", "gweobs", "gweos", "gweoss", "gweong", "gweoj", "gweoc", "gweok", "gweot", "gweop", "gweoh", "gwe", "gweg", "gwegg", "gwegs", "gwen", "gwenj", "gwenh", "gwed", "gwel", "gwelg", "gwelm", "gwelb", "gwels", "gwelt", "gwelp", "gwelh", "gwem", "gweb", "gwebs", "gwes", "gwess", "gweng", "gwej", "gwec", "gwek", "gwet", "gwep", "gweh", "gwi", "gwig", "gwigg", "gwigs", "gwin", "gwinj", "gwinh", "gwid", "gwil", "gwilg", "gwilm", "gwilb", "gwils", "gwilt", "gwilp", "gwilh", "gwim", "gwib", "gwibs", "gwis", "gwiss", "gwing", "gwij", "gwic", "gwik", "gwit", "gwip", "gwih", "gyu", "gyug", "gyugg", "gyugs", "gyun", "gyunj", "gyunh", "gyud", "gyul", "gyulg", "gyulm", "gyulb", "gyuls", "gyult", "gyulp", "gyulh", "gyum", "gyub", "gyubs", "gyus", "gyuss", "gyung", "gyuj", "gyuc", "gyuk", "gyut", "gyup", "gyuh", "geu", "geug", "geugg", "geugs", "geun", "geunj", "geunh", "geud"];
  }
});

// node_modules/unidecode/data/xae.js
var require_xae = __commonJS({
  "node_modules/unidecode/data/xae.js"(exports2, module2) {
    module2.exports = ["geul", "geulg", "geulm", "geulb", "geuls", "geult", "geulp", "geulh", "geum", "geub", "geubs", "geus", "geuss", "geung", "geuj", "geuc", "geuk", "geut", "geup", "geuh", "gyi", "gyig", "gyigg", "gyigs", "gyin", "gyinj", "gyinh", "gyid", "gyil", "gyilg", "gyilm", "gyilb", "gyils", "gyilt", "gyilp", "gyilh", "gyim", "gyib", "gyibs", "gyis", "gyiss", "gying", "gyij", "gyic", "gyik", "gyit", "gyip", "gyih", "gi", "gig", "gigg", "gigs", "gin", "ginj", "ginh", "gid", "gil", "gilg", "gilm", "gilb", "gils", "gilt", "gilp", "gilh", "gim", "gib", "gibs", "gis", "giss", "ging", "gij", "gic", "gik", "git", "gip", "gih", "gga", "ggag", "ggagg", "ggags", "ggan", "gganj", "gganh", "ggad", "ggal", "ggalg", "ggalm", "ggalb", "ggals", "ggalt", "ggalp", "ggalh", "ggam", "ggab", "ggabs", "ggas", "ggass", "ggang", "ggaj", "ggac", "ggak", "ggat", "ggap", "ggah", "ggae", "ggaeg", "ggaegg", "ggaegs", "ggaen", "ggaenj", "ggaenh", "ggaed", "ggael", "ggaelg", "ggaelm", "ggaelb", "ggaels", "ggaelt", "ggaelp", "ggaelh", "ggaem", "ggaeb", "ggaebs", "ggaes", "ggaess", "ggaeng", "ggaej", "ggaec", "ggaek", "ggaet", "ggaep", "ggaeh", "ggya", "ggyag", "ggyagg", "ggyags", "ggyan", "ggyanj", "ggyanh", "ggyad", "ggyal", "ggyalg", "ggyalm", "ggyalb", "ggyals", "ggyalt", "ggyalp", "ggyalh", "ggyam", "ggyab", "ggyabs", "ggyas", "ggyass", "ggyang", "ggyaj", "ggyac", "ggyak", "ggyat", "ggyap", "ggyah", "ggyae", "ggyaeg", "ggyaegg", "ggyaegs", "ggyaen", "ggyaenj", "ggyaenh", "ggyaed", "ggyael", "ggyaelg", "ggyaelm", "ggyaelb", "ggyaels", "ggyaelt", "ggyaelp", "ggyaelh", "ggyaem", "ggyaeb", "ggyaebs", "ggyaes", "ggyaess", "ggyaeng", "ggyaej", "ggyaec", "ggyaek", "ggyaet", "ggyaep", "ggyaeh", "ggeo", "ggeog", "ggeogg", "ggeogs", "ggeon", "ggeonj", "ggeonh", "ggeod", "ggeol", "ggeolg", "ggeolm", "ggeolb", "ggeols", "ggeolt", "ggeolp", "ggeolh", "ggeom", "ggeob", "ggeobs", "ggeos", "ggeoss", "ggeong", "ggeoj", "ggeoc", "ggeok", "ggeot", "ggeop", "ggeoh", "gge", "ggeg", "ggegg", "ggegs", "ggen", "ggenj", "ggenh", "gged", "ggel", "ggelg", "ggelm", "ggelb", "ggels", "ggelt", "ggelp", "ggelh", "ggem", "ggeb", "ggebs", "gges", "ggess", "ggeng", "ggej", "ggec", "ggek", "gget", "ggep", "ggeh", "ggyeo", "ggyeog", "ggyeogg", "ggyeogs", "ggyeon", "ggyeonj", "ggyeonh", "ggyeod", "ggyeol", "ggyeolg", "ggyeolm", "ggyeolb"];
  }
});

// node_modules/unidecode/data/xaf.js
var require_xaf = __commonJS({
  "node_modules/unidecode/data/xaf.js"(exports2, module2) {
    module2.exports = ["ggyeols", "ggyeolt", "ggyeolp", "ggyeolh", "ggyeom", "ggyeob", "ggyeobs", "ggyeos", "ggyeoss", "ggyeong", "ggyeoj", "ggyeoc", "ggyeok", "ggyeot", "ggyeop", "ggyeoh", "ggye", "ggyeg", "ggyegg", "ggyegs", "ggyen", "ggyenj", "ggyenh", "ggyed", "ggyel", "ggyelg", "ggyelm", "ggyelb", "ggyels", "ggyelt", "ggyelp", "ggyelh", "ggyem", "ggyeb", "ggyebs", "ggyes", "ggyess", "ggyeng", "ggyej", "ggyec", "ggyek", "ggyet", "ggyep", "ggyeh", "ggo", "ggog", "ggogg", "ggogs", "ggon", "ggonj", "ggonh", "ggod", "ggol", "ggolg", "ggolm", "ggolb", "ggols", "ggolt", "ggolp", "ggolh", "ggom", "ggob", "ggobs", "ggos", "ggoss", "ggong", "ggoj", "ggoc", "ggok", "ggot", "ggop", "ggoh", "ggwa", "ggwag", "ggwagg", "ggwags", "ggwan", "ggwanj", "ggwanh", "ggwad", "ggwal", "ggwalg", "ggwalm", "ggwalb", "ggwals", "ggwalt", "ggwalp", "ggwalh", "ggwam", "ggwab", "ggwabs", "ggwas", "ggwass", "ggwang", "ggwaj", "ggwac", "ggwak", "ggwat", "ggwap", "ggwah", "ggwae", "ggwaeg", "ggwaegg", "ggwaegs", "ggwaen", "ggwaenj", "ggwaenh", "ggwaed", "ggwael", "ggwaelg", "ggwaelm", "ggwaelb", "ggwaels", "ggwaelt", "ggwaelp", "ggwaelh", "ggwaem", "ggwaeb", "ggwaebs", "ggwaes", "ggwaess", "ggwaeng", "ggwaej", "ggwaec", "ggwaek", "ggwaet", "ggwaep", "ggwaeh", "ggoe", "ggoeg", "ggoegg", "ggoegs", "ggoen", "ggoenj", "ggoenh", "ggoed", "ggoel", "ggoelg", "ggoelm", "ggoelb", "ggoels", "ggoelt", "ggoelp", "ggoelh", "ggoem", "ggoeb", "ggoebs", "ggoes", "ggoess", "ggoeng", "ggoej", "ggoec", "ggoek", "ggoet", "ggoep", "ggoeh", "ggyo", "ggyog", "ggyogg", "ggyogs", "ggyon", "ggyonj", "ggyonh", "ggyod", "ggyol", "ggyolg", "ggyolm", "ggyolb", "ggyols", "ggyolt", "ggyolp", "ggyolh", "ggyom", "ggyob", "ggyobs", "ggyos", "ggyoss", "ggyong", "ggyoj", "ggyoc", "ggyok", "ggyot", "ggyop", "ggyoh", "ggu", "ggug", "ggugg", "ggugs", "ggun", "ggunj", "ggunh", "ggud", "ggul", "ggulg", "ggulm", "ggulb", "gguls", "ggult", "ggulp", "ggulh", "ggum", "ggub", "ggubs", "ggus", "gguss", "ggung", "gguj", "gguc", "gguk", "ggut", "ggup", "gguh", "ggweo", "ggweog", "ggweogg", "ggweogs", "ggweon", "ggweonj", "ggweonh", "ggweod", "ggweol", "ggweolg", "ggweolm", "ggweolb", "ggweols", "ggweolt", "ggweolp", "ggweolh", "ggweom", "ggweob", "ggweobs", "ggweos", "ggweoss", "ggweong", "ggweoj", "ggweoc", "ggweok", "ggweot", "ggweop", "ggweoh", "ggwe", "ggweg", "ggwegg", "ggwegs", "ggwen", "ggwenj", "ggwenh", "ggwed", "ggwel", "ggwelg", "ggwelm", "ggwelb", "ggwels", "ggwelt", "ggwelp", "ggwelh"];
  }
});

// node_modules/unidecode/data/xb0.js
var require_xb0 = __commonJS({
  "node_modules/unidecode/data/xb0.js"(exports2, module2) {
    module2.exports = ["ggwem", "ggweb", "ggwebs", "ggwes", "ggwess", "ggweng", "ggwej", "ggwec", "ggwek", "ggwet", "ggwep", "ggweh", "ggwi", "ggwig", "ggwigg", "ggwigs", "ggwin", "ggwinj", "ggwinh", "ggwid", "ggwil", "ggwilg", "ggwilm", "ggwilb", "ggwils", "ggwilt", "ggwilp", "ggwilh", "ggwim", "ggwib", "ggwibs", "ggwis", "ggwiss", "ggwing", "ggwij", "ggwic", "ggwik", "ggwit", "ggwip", "ggwih", "ggyu", "ggyug", "ggyugg", "ggyugs", "ggyun", "ggyunj", "ggyunh", "ggyud", "ggyul", "ggyulg", "ggyulm", "ggyulb", "ggyuls", "ggyult", "ggyulp", "ggyulh", "ggyum", "ggyub", "ggyubs", "ggyus", "ggyuss", "ggyung", "ggyuj", "ggyuc", "ggyuk", "ggyut", "ggyup", "ggyuh", "ggeu", "ggeug", "ggeugg", "ggeugs", "ggeun", "ggeunj", "ggeunh", "ggeud", "ggeul", "ggeulg", "ggeulm", "ggeulb", "ggeuls", "ggeult", "ggeulp", "ggeulh", "ggeum", "ggeub", "ggeubs", "ggeus", "ggeuss", "ggeung", "ggeuj", "ggeuc", "ggeuk", "ggeut", "ggeup", "ggeuh", "ggyi", "ggyig", "ggyigg", "ggyigs", "ggyin", "ggyinj", "ggyinh", "ggyid", "ggyil", "ggyilg", "ggyilm", "ggyilb", "ggyils", "ggyilt", "ggyilp", "ggyilh", "ggyim", "ggyib", "ggyibs", "ggyis", "ggyiss", "ggying", "ggyij", "ggyic", "ggyik", "ggyit", "ggyip", "ggyih", "ggi", "ggig", "ggigg", "ggigs", "ggin", "gginj", "gginh", "ggid", "ggil", "ggilg", "ggilm", "ggilb", "ggils", "ggilt", "ggilp", "ggilh", "ggim", "ggib", "ggibs", "ggis", "ggiss", "gging", "ggij", "ggic", "ggik", "ggit", "ggip", "ggih", "na", "nag", "nagg", "nags", "nan", "nanj", "nanh", "nad", "nal", "nalg", "nalm", "nalb", "nals", "nalt", "nalp", "nalh", "nam", "nab", "nabs", "nas", "nass", "nang", "naj", "nac", "nak", "nat", "nap", "nah", "nae", "naeg", "naegg", "naegs", "naen", "naenj", "naenh", "naed", "nael", "naelg", "naelm", "naelb", "naels", "naelt", "naelp", "naelh", "naem", "naeb", "naebs", "naes", "naess", "naeng", "naej", "naec", "naek", "naet", "naep", "naeh", "nya", "nyag", "nyagg", "nyags", "nyan", "nyanj", "nyanh", "nyad", "nyal", "nyalg", "nyalm", "nyalb", "nyals", "nyalt", "nyalp", "nyalh", "nyam", "nyab", "nyabs", "nyas", "nyass", "nyang", "nyaj", "nyac", "nyak", "nyat", "nyap", "nyah", "nyae", "nyaeg", "nyaegg", "nyaegs", "nyaen", "nyaenj", "nyaenh", "nyaed", "nyael", "nyaelg", "nyaelm", "nyaelb", "nyaels", "nyaelt", "nyaelp", "nyaelh", "nyaem", "nyaeb", "nyaebs", "nyaes"];
  }
});

// node_modules/unidecode/data/xb1.js
var require_xb1 = __commonJS({
  "node_modules/unidecode/data/xb1.js"(exports2, module2) {
    module2.exports = ["nyaess", "nyaeng", "nyaej", "nyaec", "nyaek", "nyaet", "nyaep", "nyaeh", "neo", "neog", "neogg", "neogs", "neon", "neonj", "neonh", "neod", "neol", "neolg", "neolm", "neolb", "neols", "neolt", "neolp", "neolh", "neom", "neob", "neobs", "neos", "neoss", "neong", "neoj", "neoc", "neok", "neot", "neop", "neoh", "ne", "neg", "negg", "negs", "nen", "nenj", "nenh", "ned", "nel", "nelg", "nelm", "nelb", "nels", "nelt", "nelp", "nelh", "nem", "neb", "nebs", "nes", "ness", "neng", "nej", "nec", "nek", "net", "nep", "neh", "nyeo", "nyeog", "nyeogg", "nyeogs", "nyeon", "nyeonj", "nyeonh", "nyeod", "nyeol", "nyeolg", "nyeolm", "nyeolb", "nyeols", "nyeolt", "nyeolp", "nyeolh", "nyeom", "nyeob", "nyeobs", "nyeos", "nyeoss", "nyeong", "nyeoj", "nyeoc", "nyeok", "nyeot", "nyeop", "nyeoh", "nye", "nyeg", "nyegg", "nyegs", "nyen", "nyenj", "nyenh", "nyed", "nyel", "nyelg", "nyelm", "nyelb", "nyels", "nyelt", "nyelp", "nyelh", "nyem", "nyeb", "nyebs", "nyes", "nyess", "nyeng", "nyej", "nyec", "nyek", "nyet", "nyep", "nyeh", "no", "nog", "nogg", "nogs", "non", "nonj", "nonh", "nod", "nol", "nolg", "nolm", "nolb", "nols", "nolt", "nolp", "nolh", "nom", "nob", "nobs", "nos", "noss", "nong", "noj", "noc", "nok", "not", "nop", "noh", "nwa", "nwag", "nwagg", "nwags", "nwan", "nwanj", "nwanh", "nwad", "nwal", "nwalg", "nwalm", "nwalb", "nwals", "nwalt", "nwalp", "nwalh", "nwam", "nwab", "nwabs", "nwas", "nwass", "nwang", "nwaj", "nwac", "nwak", "nwat", "nwap", "nwah", "nwae", "nwaeg", "nwaegg", "nwaegs", "nwaen", "nwaenj", "nwaenh", "nwaed", "nwael", "nwaelg", "nwaelm", "nwaelb", "nwaels", "nwaelt", "nwaelp", "nwaelh", "nwaem", "nwaeb", "nwaebs", "nwaes", "nwaess", "nwaeng", "nwaej", "nwaec", "nwaek", "nwaet", "nwaep", "nwaeh", "noe", "noeg", "noegg", "noegs", "noen", "noenj", "noenh", "noed", "noel", "noelg", "noelm", "noelb", "noels", "noelt", "noelp", "noelh", "noem", "noeb", "noebs", "noes", "noess", "noeng", "noej", "noec", "noek", "noet", "noep", "noeh", "nyo", "nyog", "nyogg", "nyogs", "nyon", "nyonj", "nyonh", "nyod", "nyol", "nyolg", "nyolm", "nyolb", "nyols", "nyolt", "nyolp", "nyolh", "nyom", "nyob", "nyobs", "nyos", "nyoss", "nyong", "nyoj", "nyoc"];
  }
});

// node_modules/unidecode/data/xb2.js
var require_xb2 = __commonJS({
  "node_modules/unidecode/data/xb2.js"(exports2, module2) {
    module2.exports = ["nyok", "nyot", "nyop", "nyoh", "nu", "nug", "nugg", "nugs", "nun", "nunj", "nunh", "nud", "nul", "nulg", "nulm", "nulb", "nuls", "nult", "nulp", "nulh", "num", "nub", "nubs", "nus", "nuss", "nung", "nuj", "nuc", "nuk", "nut", "nup", "nuh", "nweo", "nweog", "nweogg", "nweogs", "nweon", "nweonj", "nweonh", "nweod", "nweol", "nweolg", "nweolm", "nweolb", "nweols", "nweolt", "nweolp", "nweolh", "nweom", "nweob", "nweobs", "nweos", "nweoss", "nweong", "nweoj", "nweoc", "nweok", "nweot", "nweop", "nweoh", "nwe", "nweg", "nwegg", "nwegs", "nwen", "nwenj", "nwenh", "nwed", "nwel", "nwelg", "nwelm", "nwelb", "nwels", "nwelt", "nwelp", "nwelh", "nwem", "nweb", "nwebs", "nwes", "nwess", "nweng", "nwej", "nwec", "nwek", "nwet", "nwep", "nweh", "nwi", "nwig", "nwigg", "nwigs", "nwin", "nwinj", "nwinh", "nwid", "nwil", "nwilg", "nwilm", "nwilb", "nwils", "nwilt", "nwilp", "nwilh", "nwim", "nwib", "nwibs", "nwis", "nwiss", "nwing", "nwij", "nwic", "nwik", "nwit", "nwip", "nwih", "nyu", "nyug", "nyugg", "nyugs", "nyun", "nyunj", "nyunh", "nyud", "nyul", "nyulg", "nyulm", "nyulb", "nyuls", "nyult", "nyulp", "nyulh", "nyum", "nyub", "nyubs", "nyus", "nyuss", "nyung", "nyuj", "nyuc", "nyuk", "nyut", "nyup", "nyuh", "neu", "neug", "neugg", "neugs", "neun", "neunj", "neunh", "neud", "neul", "neulg", "neulm", "neulb", "neuls", "neult", "neulp", "neulh", "neum", "neub", "neubs", "neus", "neuss", "neung", "neuj", "neuc", "neuk", "neut", "neup", "neuh", "nyi", "nyig", "nyigg", "nyigs", "nyin", "nyinj", "nyinh", "nyid", "nyil", "nyilg", "nyilm", "nyilb", "nyils", "nyilt", "nyilp", "nyilh", "nyim", "nyib", "nyibs", "nyis", "nyiss", "nying", "nyij", "nyic", "nyik", "nyit", "nyip", "nyih", "ni", "nig", "nigg", "nigs", "nin", "ninj", "ninh", "nid", "nil", "nilg", "nilm", "nilb", "nils", "nilt", "nilp", "nilh", "nim", "nib", "nibs", "nis", "niss", "ning", "nij", "nic", "nik", "nit", "nip", "nih", "da", "dag", "dagg", "dags", "dan", "danj", "danh", "dad", "dal", "dalg", "dalm", "dalb", "dals", "dalt", "dalp", "dalh", "dam", "dab", "dabs", "das", "dass", "dang", "daj", "dac", "dak", "dat", "dap", "dah"];
  }
});

// node_modules/unidecode/data/xb3.js
var require_xb3 = __commonJS({
  "node_modules/unidecode/data/xb3.js"(exports2, module2) {
    module2.exports = ["dae", "daeg", "daegg", "daegs", "daen", "daenj", "daenh", "daed", "dael", "daelg", "daelm", "daelb", "daels", "daelt", "daelp", "daelh", "daem", "daeb", "daebs", "daes", "daess", "daeng", "daej", "daec", "daek", "daet", "daep", "daeh", "dya", "dyag", "dyagg", "dyags", "dyan", "dyanj", "dyanh", "dyad", "dyal", "dyalg", "dyalm", "dyalb", "dyals", "dyalt", "dyalp", "dyalh", "dyam", "dyab", "dyabs", "dyas", "dyass", "dyang", "dyaj", "dyac", "dyak", "dyat", "dyap", "dyah", "dyae", "dyaeg", "dyaegg", "dyaegs", "dyaen", "dyaenj", "dyaenh", "dyaed", "dyael", "dyaelg", "dyaelm", "dyaelb", "dyaels", "dyaelt", "dyaelp", "dyaelh", "dyaem", "dyaeb", "dyaebs", "dyaes", "dyaess", "dyaeng", "dyaej", "dyaec", "dyaek", "dyaet", "dyaep", "dyaeh", "deo", "deog", "deogg", "deogs", "deon", "deonj", "deonh", "deod", "deol", "deolg", "deolm", "deolb", "deols", "deolt", "deolp", "deolh", "deom", "deob", "deobs", "deos", "deoss", "deong", "deoj", "deoc", "deok", "deot", "deop", "deoh", "de", "deg", "degg", "degs", "den", "denj", "denh", "ded", "del", "delg", "delm", "delb", "dels", "delt", "delp", "delh", "dem", "deb", "debs", "des", "dess", "deng", "dej", "dec", "dek", "det", "dep", "deh", "dyeo", "dyeog", "dyeogg", "dyeogs", "dyeon", "dyeonj", "dyeonh", "dyeod", "dyeol", "dyeolg", "dyeolm", "dyeolb", "dyeols", "dyeolt", "dyeolp", "dyeolh", "dyeom", "dyeob", "dyeobs", "dyeos", "dyeoss", "dyeong", "dyeoj", "dyeoc", "dyeok", "dyeot", "dyeop", "dyeoh", "dye", "dyeg", "dyegg", "dyegs", "dyen", "dyenj", "dyenh", "dyed", "dyel", "dyelg", "dyelm", "dyelb", "dyels", "dyelt", "dyelp", "dyelh", "dyem", "dyeb", "dyebs", "dyes", "dyess", "dyeng", "dyej", "dyec", "dyek", "dyet", "dyep", "dyeh", "do", "dog", "dogg", "dogs", "don", "donj", "donh", "dod", "dol", "dolg", "dolm", "dolb", "dols", "dolt", "dolp", "dolh", "dom", "dob", "dobs", "dos", "doss", "dong", "doj", "doc", "dok", "dot", "dop", "doh", "dwa", "dwag", "dwagg", "dwags", "dwan", "dwanj", "dwanh", "dwad", "dwal", "dwalg", "dwalm", "dwalb", "dwals", "dwalt", "dwalp", "dwalh", "dwam", "dwab", "dwabs", "dwas", "dwass", "dwang", "dwaj", "dwac", "dwak", "dwat", "dwap", "dwah", "dwae", "dwaeg", "dwaegg", "dwaegs"];
  }
});

// node_modules/unidecode/data/xb4.js
var require_xb4 = __commonJS({
  "node_modules/unidecode/data/xb4.js"(exports2, module2) {
    module2.exports = ["dwaen", "dwaenj", "dwaenh", "dwaed", "dwael", "dwaelg", "dwaelm", "dwaelb", "dwaels", "dwaelt", "dwaelp", "dwaelh", "dwaem", "dwaeb", "dwaebs", "dwaes", "dwaess", "dwaeng", "dwaej", "dwaec", "dwaek", "dwaet", "dwaep", "dwaeh", "doe", "doeg", "doegg", "doegs", "doen", "doenj", "doenh", "doed", "doel", "doelg", "doelm", "doelb", "doels", "doelt", "doelp", "doelh", "doem", "doeb", "doebs", "does", "doess", "doeng", "doej", "doec", "doek", "doet", "doep", "doeh", "dyo", "dyog", "dyogg", "dyogs", "dyon", "dyonj", "dyonh", "dyod", "dyol", "dyolg", "dyolm", "dyolb", "dyols", "dyolt", "dyolp", "dyolh", "dyom", "dyob", "dyobs", "dyos", "dyoss", "dyong", "dyoj", "dyoc", "dyok", "dyot", "dyop", "dyoh", "du", "dug", "dugg", "dugs", "dun", "dunj", "dunh", "dud", "dul", "dulg", "dulm", "dulb", "duls", "dult", "dulp", "dulh", "dum", "dub", "dubs", "dus", "duss", "dung", "duj", "duc", "duk", "dut", "dup", "duh", "dweo", "dweog", "dweogg", "dweogs", "dweon", "dweonj", "dweonh", "dweod", "dweol", "dweolg", "dweolm", "dweolb", "dweols", "dweolt", "dweolp", "dweolh", "dweom", "dweob", "dweobs", "dweos", "dweoss", "dweong", "dweoj", "dweoc", "dweok", "dweot", "dweop", "dweoh", "dwe", "dweg", "dwegg", "dwegs", "dwen", "dwenj", "dwenh", "dwed", "dwel", "dwelg", "dwelm", "dwelb", "dwels", "dwelt", "dwelp", "dwelh", "dwem", "dweb", "dwebs", "dwes", "dwess", "dweng", "dwej", "dwec", "dwek", "dwet", "dwep", "dweh", "dwi", "dwig", "dwigg", "dwigs", "dwin", "dwinj", "dwinh", "dwid", "dwil", "dwilg", "dwilm", "dwilb", "dwils", "dwilt", "dwilp", "dwilh", "dwim", "dwib", "dwibs", "dwis", "dwiss", "dwing", "dwij", "dwic", "dwik", "dwit", "dwip", "dwih", "dyu", "dyug", "dyugg", "dyugs", "dyun", "dyunj", "dyunh", "dyud", "dyul", "dyulg", "dyulm", "dyulb", "dyuls", "dyult", "dyulp", "dyulh", "dyum", "dyub", "dyubs", "dyus", "dyuss", "dyung", "dyuj", "dyuc", "dyuk", "dyut", "dyup", "dyuh", "deu", "deug", "deugg", "deugs", "deun", "deunj", "deunh", "deud", "deul", "deulg", "deulm", "deulb", "deuls", "deult", "deulp", "deulh", "deum", "deub", "deubs", "deus", "deuss", "deung", "deuj", "deuc", "deuk", "deut", "deup", "deuh", "dyi", "dyig", "dyigg", "dyigs", "dyin", "dyinj", "dyinh", "dyid"];
  }
});

// node_modules/unidecode/data/xb5.js
var require_xb5 = __commonJS({
  "node_modules/unidecode/data/xb5.js"(exports2, module2) {
    module2.exports = ["dyil", "dyilg", "dyilm", "dyilb", "dyils", "dyilt", "dyilp", "dyilh", "dyim", "dyib", "dyibs", "dyis", "dyiss", "dying", "dyij", "dyic", "dyik", "dyit", "dyip", "dyih", "di", "dig", "digg", "digs", "din", "dinj", "dinh", "did", "dil", "dilg", "dilm", "dilb", "dils", "dilt", "dilp", "dilh", "dim", "dib", "dibs", "dis", "diss", "ding", "dij", "dic", "dik", "dit", "dip", "dih", "dda", "ddag", "ddagg", "ddags", "ddan", "ddanj", "ddanh", "ddad", "ddal", "ddalg", "ddalm", "ddalb", "ddals", "ddalt", "ddalp", "ddalh", "ddam", "ddab", "ddabs", "ddas", "ddass", "ddang", "ddaj", "ddac", "ddak", "ddat", "ddap", "ddah", "ddae", "ddaeg", "ddaegg", "ddaegs", "ddaen", "ddaenj", "ddaenh", "ddaed", "ddael", "ddaelg", "ddaelm", "ddaelb", "ddaels", "ddaelt", "ddaelp", "ddaelh", "ddaem", "ddaeb", "ddaebs", "ddaes", "ddaess", "ddaeng", "ddaej", "ddaec", "ddaek", "ddaet", "ddaep", "ddaeh", "ddya", "ddyag", "ddyagg", "ddyags", "ddyan", "ddyanj", "ddyanh", "ddyad", "ddyal", "ddyalg", "ddyalm", "ddyalb", "ddyals", "ddyalt", "ddyalp", "ddyalh", "ddyam", "ddyab", "ddyabs", "ddyas", "ddyass", "ddyang", "ddyaj", "ddyac", "ddyak", "ddyat", "ddyap", "ddyah", "ddyae", "ddyaeg", "ddyaegg", "ddyaegs", "ddyaen", "ddyaenj", "ddyaenh", "ddyaed", "ddyael", "ddyaelg", "ddyaelm", "ddyaelb", "ddyaels", "ddyaelt", "ddyaelp", "ddyaelh", "ddyaem", "ddyaeb", "ddyaebs", "ddyaes", "ddyaess", "ddyaeng", "ddyaej", "ddyaec", "ddyaek", "ddyaet", "ddyaep", "ddyaeh", "ddeo", "ddeog", "ddeogg", "ddeogs", "ddeon", "ddeonj", "ddeonh", "ddeod", "ddeol", "ddeolg", "ddeolm", "ddeolb", "ddeols", "ddeolt", "ddeolp", "ddeolh", "ddeom", "ddeob", "ddeobs", "ddeos", "ddeoss", "ddeong", "ddeoj", "ddeoc", "ddeok", "ddeot", "ddeop", "ddeoh", "dde", "ddeg", "ddegg", "ddegs", "dden", "ddenj", "ddenh", "dded", "ddel", "ddelg", "ddelm", "ddelb", "ddels", "ddelt", "ddelp", "ddelh", "ddem", "ddeb", "ddebs", "ddes", "ddess", "ddeng", "ddej", "ddec", "ddek", "ddet", "ddep", "ddeh", "ddyeo", "ddyeog", "ddyeogg", "ddyeogs", "ddyeon", "ddyeonj", "ddyeonh", "ddyeod", "ddyeol", "ddyeolg", "ddyeolm", "ddyeolb", "ddyeols", "ddyeolt", "ddyeolp", "ddyeolh", "ddyeom", "ddyeob", "ddyeobs", "ddyeos", "ddyeoss", "ddyeong", "ddyeoj", "ddyeoc", "ddyeok", "ddyeot", "ddyeop", "ddyeoh", "ddye", "ddyeg", "ddyegg", "ddyegs", "ddyen", "ddyenj", "ddyenh", "ddyed", "ddyel", "ddyelg", "ddyelm", "ddyelb"];
  }
});

// node_modules/unidecode/data/xb6.js
var require_xb6 = __commonJS({
  "node_modules/unidecode/data/xb6.js"(exports2, module2) {
    module2.exports = ["ddyels", "ddyelt", "ddyelp", "ddyelh", "ddyem", "ddyeb", "ddyebs", "ddyes", "ddyess", "ddyeng", "ddyej", "ddyec", "ddyek", "ddyet", "ddyep", "ddyeh", "ddo", "ddog", "ddogg", "ddogs", "ddon", "ddonj", "ddonh", "ddod", "ddol", "ddolg", "ddolm", "ddolb", "ddols", "ddolt", "ddolp", "ddolh", "ddom", "ddob", "ddobs", "ddos", "ddoss", "ddong", "ddoj", "ddoc", "ddok", "ddot", "ddop", "ddoh", "ddwa", "ddwag", "ddwagg", "ddwags", "ddwan", "ddwanj", "ddwanh", "ddwad", "ddwal", "ddwalg", "ddwalm", "ddwalb", "ddwals", "ddwalt", "ddwalp", "ddwalh", "ddwam", "ddwab", "ddwabs", "ddwas", "ddwass", "ddwang", "ddwaj", "ddwac", "ddwak", "ddwat", "ddwap", "ddwah", "ddwae", "ddwaeg", "ddwaegg", "ddwaegs", "ddwaen", "ddwaenj", "ddwaenh", "ddwaed", "ddwael", "ddwaelg", "ddwaelm", "ddwaelb", "ddwaels", "ddwaelt", "ddwaelp", "ddwaelh", "ddwaem", "ddwaeb", "ddwaebs", "ddwaes", "ddwaess", "ddwaeng", "ddwaej", "ddwaec", "ddwaek", "ddwaet", "ddwaep", "ddwaeh", "ddoe", "ddoeg", "ddoegg", "ddoegs", "ddoen", "ddoenj", "ddoenh", "ddoed", "ddoel", "ddoelg", "ddoelm", "ddoelb", "ddoels", "ddoelt", "ddoelp", "ddoelh", "ddoem", "ddoeb", "ddoebs", "ddoes", "ddoess", "ddoeng", "ddoej", "ddoec", "ddoek", "ddoet", "ddoep", "ddoeh", "ddyo", "ddyog", "ddyogg", "ddyogs", "ddyon", "ddyonj", "ddyonh", "ddyod", "ddyol", "ddyolg", "ddyolm", "ddyolb", "ddyols", "ddyolt", "ddyolp", "ddyolh", "ddyom", "ddyob", "ddyobs", "ddyos", "ddyoss", "ddyong", "ddyoj", "ddyoc", "ddyok", "ddyot", "ddyop", "ddyoh", "ddu", "ddug", "ddugg", "ddugs", "ddun", "ddunj", "ddunh", "ddud", "ddul", "ddulg", "ddulm", "ddulb", "dduls", "ddult", "ddulp", "ddulh", "ddum", "ddub", "ddubs", "ddus", "dduss", "ddung", "dduj", "dduc", "dduk", "ddut", "ddup", "dduh", "ddweo", "ddweog", "ddweogg", "ddweogs", "ddweon", "ddweonj", "ddweonh", "ddweod", "ddweol", "ddweolg", "ddweolm", "ddweolb", "ddweols", "ddweolt", "ddweolp", "ddweolh", "ddweom", "ddweob", "ddweobs", "ddweos", "ddweoss", "ddweong", "ddweoj", "ddweoc", "ddweok", "ddweot", "ddweop", "ddweoh", "ddwe", "ddweg", "ddwegg", "ddwegs", "ddwen", "ddwenj", "ddwenh", "ddwed", "ddwel", "ddwelg", "ddwelm", "ddwelb", "ddwels", "ddwelt", "ddwelp", "ddwelh", "ddwem", "ddweb", "ddwebs", "ddwes", "ddwess", "ddweng", "ddwej", "ddwec", "ddwek", "ddwet", "ddwep", "ddweh", "ddwi", "ddwig", "ddwigg", "ddwigs", "ddwin", "ddwinj", "ddwinh", "ddwid", "ddwil", "ddwilg", "ddwilm", "ddwilb", "ddwils", "ddwilt", "ddwilp", "ddwilh"];
  }
});

// node_modules/unidecode/data/xb7.js
var require_xb7 = __commonJS({
  "node_modules/unidecode/data/xb7.js"(exports2, module2) {
    module2.exports = ["ddwim", "ddwib", "ddwibs", "ddwis", "ddwiss", "ddwing", "ddwij", "ddwic", "ddwik", "ddwit", "ddwip", "ddwih", "ddyu", "ddyug", "ddyugg", "ddyugs", "ddyun", "ddyunj", "ddyunh", "ddyud", "ddyul", "ddyulg", "ddyulm", "ddyulb", "ddyuls", "ddyult", "ddyulp", "ddyulh", "ddyum", "ddyub", "ddyubs", "ddyus", "ddyuss", "ddyung", "ddyuj", "ddyuc", "ddyuk", "ddyut", "ddyup", "ddyuh", "ddeu", "ddeug", "ddeugg", "ddeugs", "ddeun", "ddeunj", "ddeunh", "ddeud", "ddeul", "ddeulg", "ddeulm", "ddeulb", "ddeuls", "ddeult", "ddeulp", "ddeulh", "ddeum", "ddeub", "ddeubs", "ddeus", "ddeuss", "ddeung", "ddeuj", "ddeuc", "ddeuk", "ddeut", "ddeup", "ddeuh", "ddyi", "ddyig", "ddyigg", "ddyigs", "ddyin", "ddyinj", "ddyinh", "ddyid", "ddyil", "ddyilg", "ddyilm", "ddyilb", "ddyils", "ddyilt", "ddyilp", "ddyilh", "ddyim", "ddyib", "ddyibs", "ddyis", "ddyiss", "ddying", "ddyij", "ddyic", "ddyik", "ddyit", "ddyip", "ddyih", "ddi", "ddig", "ddigg", "ddigs", "ddin", "ddinj", "ddinh", "ddid", "ddil", "ddilg", "ddilm", "ddilb", "ddils", "ddilt", "ddilp", "ddilh", "ddim", "ddib", "ddibs", "ddis", "ddiss", "dding", "ddij", "ddic", "ddik", "ddit", "ddip", "ddih", "ra", "rag", "ragg", "rags", "ran", "ranj", "ranh", "rad", "ral", "ralg", "ralm", "ralb", "rals", "ralt", "ralp", "ralh", "ram", "rab", "rabs", "ras", "rass", "rang", "raj", "rac", "rak", "rat", "rap", "rah", "rae", "raeg", "raegg", "raegs", "raen", "raenj", "raenh", "raed", "rael", "raelg", "raelm", "raelb", "raels", "raelt", "raelp", "raelh", "raem", "raeb", "raebs", "raes", "raess", "raeng", "raej", "raec", "raek", "raet", "raep", "raeh", "rya", "ryag", "ryagg", "ryags", "ryan", "ryanj", "ryanh", "ryad", "ryal", "ryalg", "ryalm", "ryalb", "ryals", "ryalt", "ryalp", "ryalh", "ryam", "ryab", "ryabs", "ryas", "ryass", "ryang", "ryaj", "ryac", "ryak", "ryat", "ryap", "ryah", "ryae", "ryaeg", "ryaegg", "ryaegs", "ryaen", "ryaenj", "ryaenh", "ryaed", "ryael", "ryaelg", "ryaelm", "ryaelb", "ryaels", "ryaelt", "ryaelp", "ryaelh", "ryaem", "ryaeb", "ryaebs", "ryaes", "ryaess", "ryaeng", "ryaej", "ryaec", "ryaek", "ryaet", "ryaep", "ryaeh", "reo", "reog", "reogg", "reogs", "reon", "reonj", "reonh", "reod", "reol", "reolg", "reolm", "reolb", "reols", "reolt", "reolp", "reolh", "reom", "reob", "reobs", "reos"];
  }
});

// node_modules/unidecode/data/xb8.js
var require_xb8 = __commonJS({
  "node_modules/unidecode/data/xb8.js"(exports2, module2) {
    module2.exports = ["reoss", "reong", "reoj", "reoc", "reok", "reot", "reop", "reoh", "re", "reg", "regg", "regs", "ren", "renj", "renh", "red", "rel", "relg", "relm", "relb", "rels", "relt", "relp", "relh", "rem", "reb", "rebs", "res", "ress", "reng", "rej", "rec", "rek", "ret", "rep", "reh", "ryeo", "ryeog", "ryeogg", "ryeogs", "ryeon", "ryeonj", "ryeonh", "ryeod", "ryeol", "ryeolg", "ryeolm", "ryeolb", "ryeols", "ryeolt", "ryeolp", "ryeolh", "ryeom", "ryeob", "ryeobs", "ryeos", "ryeoss", "ryeong", "ryeoj", "ryeoc", "ryeok", "ryeot", "ryeop", "ryeoh", "rye", "ryeg", "ryegg", "ryegs", "ryen", "ryenj", "ryenh", "ryed", "ryel", "ryelg", "ryelm", "ryelb", "ryels", "ryelt", "ryelp", "ryelh", "ryem", "ryeb", "ryebs", "ryes", "ryess", "ryeng", "ryej", "ryec", "ryek", "ryet", "ryep", "ryeh", "ro", "rog", "rogg", "rogs", "ron", "ronj", "ronh", "rod", "rol", "rolg", "rolm", "rolb", "rols", "rolt", "rolp", "rolh", "rom", "rob", "robs", "ros", "ross", "rong", "roj", "roc", "rok", "rot", "rop", "roh", "rwa", "rwag", "rwagg", "rwags", "rwan", "rwanj", "rwanh", "rwad", "rwal", "rwalg", "rwalm", "rwalb", "rwals", "rwalt", "rwalp", "rwalh", "rwam", "rwab", "rwabs", "rwas", "rwass", "rwang", "rwaj", "rwac", "rwak", "rwat", "rwap", "rwah", "rwae", "rwaeg", "rwaegg", "rwaegs", "rwaen", "rwaenj", "rwaenh", "rwaed", "rwael", "rwaelg", "rwaelm", "rwaelb", "rwaels", "rwaelt", "rwaelp", "rwaelh", "rwaem", "rwaeb", "rwaebs", "rwaes", "rwaess", "rwaeng", "rwaej", "rwaec", "rwaek", "rwaet", "rwaep", "rwaeh", "roe", "roeg", "roegg", "roegs", "roen", "roenj", "roenh", "roed", "roel", "roelg", "roelm", "roelb", "roels", "roelt", "roelp", "roelh", "roem", "roeb", "roebs", "roes", "roess", "roeng", "roej", "roec", "roek", "roet", "roep", "roeh", "ryo", "ryog", "ryogg", "ryogs", "ryon", "ryonj", "ryonh", "ryod", "ryol", "ryolg", "ryolm", "ryolb", "ryols", "ryolt", "ryolp", "ryolh", "ryom", "ryob", "ryobs", "ryos", "ryoss", "ryong", "ryoj", "ryoc", "ryok", "ryot", "ryop", "ryoh", "ru", "rug", "rugg", "rugs", "run", "runj", "runh", "rud", "rul", "rulg", "rulm", "rulb", "ruls", "rult", "rulp", "rulh", "rum", "rub", "rubs", "rus", "russ", "rung", "ruj", "ruc"];
  }
});

// node_modules/unidecode/data/xb9.js
var require_xb9 = __commonJS({
  "node_modules/unidecode/data/xb9.js"(exports2, module2) {
    module2.exports = ["ruk", "rut", "rup", "ruh", "rweo", "rweog", "rweogg", "rweogs", "rweon", "rweonj", "rweonh", "rweod", "rweol", "rweolg", "rweolm", "rweolb", "rweols", "rweolt", "rweolp", "rweolh", "rweom", "rweob", "rweobs", "rweos", "rweoss", "rweong", "rweoj", "rweoc", "rweok", "rweot", "rweop", "rweoh", "rwe", "rweg", "rwegg", "rwegs", "rwen", "rwenj", "rwenh", "rwed", "rwel", "rwelg", "rwelm", "rwelb", "rwels", "rwelt", "rwelp", "rwelh", "rwem", "rweb", "rwebs", "rwes", "rwess", "rweng", "rwej", "rwec", "rwek", "rwet", "rwep", "rweh", "rwi", "rwig", "rwigg", "rwigs", "rwin", "rwinj", "rwinh", "rwid", "rwil", "rwilg", "rwilm", "rwilb", "rwils", "rwilt", "rwilp", "rwilh", "rwim", "rwib", "rwibs", "rwis", "rwiss", "rwing", "rwij", "rwic", "rwik", "rwit", "rwip", "rwih", "ryu", "ryug", "ryugg", "ryugs", "ryun", "ryunj", "ryunh", "ryud", "ryul", "ryulg", "ryulm", "ryulb", "ryuls", "ryult", "ryulp", "ryulh", "ryum", "ryub", "ryubs", "ryus", "ryuss", "ryung", "ryuj", "ryuc", "ryuk", "ryut", "ryup", "ryuh", "reu", "reug", "reugg", "reugs", "reun", "reunj", "reunh", "reud", "reul", "reulg", "reulm", "reulb", "reuls", "reult", "reulp", "reulh", "reum", "reub", "reubs", "reus", "reuss", "reung", "reuj", "reuc", "reuk", "reut", "reup", "reuh", "ryi", "ryig", "ryigg", "ryigs", "ryin", "ryinj", "ryinh", "ryid", "ryil", "ryilg", "ryilm", "ryilb", "ryils", "ryilt", "ryilp", "ryilh", "ryim", "ryib", "ryibs", "ryis", "ryiss", "rying", "ryij", "ryic", "ryik", "ryit", "ryip", "ryih", "ri", "rig", "rigg", "rigs", "rin", "rinj", "rinh", "rid", "ril", "rilg", "rilm", "rilb", "rils", "rilt", "rilp", "rilh", "rim", "rib", "ribs", "ris", "riss", "ring", "rij", "ric", "rik", "rit", "rip", "rih", "ma", "mag", "magg", "mags", "man", "manj", "manh", "mad", "mal", "malg", "malm", "malb", "mals", "malt", "malp", "malh", "mam", "mab", "mabs", "mas", "mass", "mang", "maj", "mac", "mak", "mat", "map", "mah", "mae", "maeg", "maegg", "maegs", "maen", "maenj", "maenh", "maed", "mael", "maelg", "maelm", "maelb", "maels", "maelt", "maelp", "maelh", "maem", "maeb", "maebs", "maes", "maess", "maeng", "maej", "maec", "maek", "maet", "maep", "maeh"];
  }
});

// node_modules/unidecode/data/xba.js
var require_xba = __commonJS({
  "node_modules/unidecode/data/xba.js"(exports2, module2) {
    module2.exports = ["mya", "myag", "myagg", "myags", "myan", "myanj", "myanh", "myad", "myal", "myalg", "myalm", "myalb", "myals", "myalt", "myalp", "myalh", "myam", "myab", "myabs", "myas", "myass", "myang", "myaj", "myac", "myak", "myat", "myap", "myah", "myae", "myaeg", "myaegg", "myaegs", "myaen", "myaenj", "myaenh", "myaed", "myael", "myaelg", "myaelm", "myaelb", "myaels", "myaelt", "myaelp", "myaelh", "myaem", "myaeb", "myaebs", "myaes", "myaess", "myaeng", "myaej", "myaec", "myaek", "myaet", "myaep", "myaeh", "meo", "meog", "meogg", "meogs", "meon", "meonj", "meonh", "meod", "meol", "meolg", "meolm", "meolb", "meols", "meolt", "meolp", "meolh", "meom", "meob", "meobs", "meos", "meoss", "meong", "meoj", "meoc", "meok", "meot", "meop", "meoh", "me", "meg", "megg", "megs", "men", "menj", "menh", "med", "mel", "melg", "melm", "melb", "mels", "melt", "melp", "melh", "mem", "meb", "mebs", "mes", "mess", "meng", "mej", "mec", "mek", "met", "mep", "meh", "myeo", "myeog", "myeogg", "myeogs", "myeon", "myeonj", "myeonh", "myeod", "myeol", "myeolg", "myeolm", "myeolb", "myeols", "myeolt", "myeolp", "myeolh", "myeom", "myeob", "myeobs", "myeos", "myeoss", "myeong", "myeoj", "myeoc", "myeok", "myeot", "myeop", "myeoh", "mye", "myeg", "myegg", "myegs", "myen", "myenj", "myenh", "myed", "myel", "myelg", "myelm", "myelb", "myels", "myelt", "myelp", "myelh", "myem", "myeb", "myebs", "myes", "myess", "myeng", "myej", "myec", "myek", "myet", "myep", "myeh", "mo", "mog", "mogg", "mogs", "mon", "monj", "monh", "mod", "mol", "molg", "molm", "molb", "mols", "molt", "molp", "molh", "mom", "mob", "mobs", "mos", "moss", "mong", "moj", "moc", "mok", "mot", "mop", "moh", "mwa", "mwag", "mwagg", "mwags", "mwan", "mwanj", "mwanh", "mwad", "mwal", "mwalg", "mwalm", "mwalb", "mwals", "mwalt", "mwalp", "mwalh", "mwam", "mwab", "mwabs", "mwas", "mwass", "mwang", "mwaj", "mwac", "mwak", "mwat", "mwap", "mwah", "mwae", "mwaeg", "mwaegg", "mwaegs", "mwaen", "mwaenj", "mwaenh", "mwaed", "mwael", "mwaelg", "mwaelm", "mwaelb", "mwaels", "mwaelt", "mwaelp", "mwaelh", "mwaem", "mwaeb", "mwaebs", "mwaes", "mwaess", "mwaeng", "mwaej", "mwaec", "mwaek", "mwaet", "mwaep", "mwaeh", "moe", "moeg", "moegg", "moegs"];
  }
});

// node_modules/unidecode/data/xbb.js
var require_xbb = __commonJS({
  "node_modules/unidecode/data/xbb.js"(exports2, module2) {
    module2.exports = ["moen", "moenj", "moenh", "moed", "moel", "moelg", "moelm", "moelb", "moels", "moelt", "moelp", "moelh", "moem", "moeb", "moebs", "moes", "moess", "moeng", "moej", "moec", "moek", "moet", "moep", "moeh", "myo", "myog", "myogg", "myogs", "myon", "myonj", "myonh", "myod", "myol", "myolg", "myolm", "myolb", "myols", "myolt", "myolp", "myolh", "myom", "myob", "myobs", "myos", "myoss", "myong", "myoj", "myoc", "myok", "myot", "myop", "myoh", "mu", "mug", "mugg", "mugs", "mun", "munj", "munh", "mud", "mul", "mulg", "mulm", "mulb", "muls", "mult", "mulp", "mulh", "mum", "mub", "mubs", "mus", "muss", "mung", "muj", "muc", "muk", "mut", "mup", "muh", "mweo", "mweog", "mweogg", "mweogs", "mweon", "mweonj", "mweonh", "mweod", "mweol", "mweolg", "mweolm", "mweolb", "mweols", "mweolt", "mweolp", "mweolh", "mweom", "mweob", "mweobs", "mweos", "mweoss", "mweong", "mweoj", "mweoc", "mweok", "mweot", "mweop", "mweoh", "mwe", "mweg", "mwegg", "mwegs", "mwen", "mwenj", "mwenh", "mwed", "mwel", "mwelg", "mwelm", "mwelb", "mwels", "mwelt", "mwelp", "mwelh", "mwem", "mweb", "mwebs", "mwes", "mwess", "mweng", "mwej", "mwec", "mwek", "mwet", "mwep", "mweh", "mwi", "mwig", "mwigg", "mwigs", "mwin", "mwinj", "mwinh", "mwid", "mwil", "mwilg", "mwilm", "mwilb", "mwils", "mwilt", "mwilp", "mwilh", "mwim", "mwib", "mwibs", "mwis", "mwiss", "mwing", "mwij", "mwic", "mwik", "mwit", "mwip", "mwih", "myu", "myug", "myugg", "myugs", "myun", "myunj", "myunh", "myud", "myul", "myulg", "myulm", "myulb", "myuls", "myult", "myulp", "myulh", "myum", "myub", "myubs", "myus", "myuss", "myung", "myuj", "myuc", "myuk", "myut", "myup", "myuh", "meu", "meug", "meugg", "meugs", "meun", "meunj", "meunh", "meud", "meul", "meulg", "meulm", "meulb", "meuls", "meult", "meulp", "meulh", "meum", "meub", "meubs", "meus", "meuss", "meung", "meuj", "meuc", "meuk", "meut", "meup", "meuh", "myi", "myig", "myigg", "myigs", "myin", "myinj", "myinh", "myid", "myil", "myilg", "myilm", "myilb", "myils", "myilt", "myilp", "myilh", "myim", "myib", "myibs", "myis", "myiss", "mying", "myij", "myic", "myik", "myit", "myip", "myih", "mi", "mig", "migg", "migs", "min", "minj", "minh", "mid"];
  }
});

// node_modules/unidecode/data/xbc.js
var require_xbc = __commonJS({
  "node_modules/unidecode/data/xbc.js"(exports2, module2) {
    module2.exports = ["mil", "milg", "milm", "milb", "mils", "milt", "milp", "milh", "mim", "mib", "mibs", "mis", "miss", "ming", "mij", "mic", "mik", "mit", "mip", "mih", "ba", "bag", "bagg", "bags", "ban", "banj", "banh", "bad", "bal", "balg", "balm", "balb", "bals", "balt", "balp", "balh", "bam", "bab", "babs", "bas", "bass", "bang", "baj", "bac", "bak", "bat", "bap", "bah", "bae", "baeg", "baegg", "baegs", "baen", "baenj", "baenh", "baed", "bael", "baelg", "baelm", "baelb", "baels", "baelt", "baelp", "baelh", "baem", "baeb", "baebs", "baes", "baess", "baeng", "baej", "baec", "baek", "baet", "baep", "baeh", "bya", "byag", "byagg", "byags", "byan", "byanj", "byanh", "byad", "byal", "byalg", "byalm", "byalb", "byals", "byalt", "byalp", "byalh", "byam", "byab", "byabs", "byas", "byass", "byang", "byaj", "byac", "byak", "byat", "byap", "byah", "byae", "byaeg", "byaegg", "byaegs", "byaen", "byaenj", "byaenh", "byaed", "byael", "byaelg", "byaelm", "byaelb", "byaels", "byaelt", "byaelp", "byaelh", "byaem", "byaeb", "byaebs", "byaes", "byaess", "byaeng", "byaej", "byaec", "byaek", "byaet", "byaep", "byaeh", "beo", "beog", "beogg", "beogs", "beon", "beonj", "beonh", "beod", "beol", "beolg", "beolm", "beolb", "beols", "beolt", "beolp", "beolh", "beom", "beob", "beobs", "beos", "beoss", "beong", "beoj", "beoc", "beok", "beot", "beop", "beoh", "be", "beg", "begg", "begs", "ben", "benj", "benh", "bed", "bel", "belg", "belm", "belb", "bels", "belt", "belp", "belh", "bem", "beb", "bebs", "bes", "bess", "beng", "bej", "bec", "bek", "bet", "bep", "beh", "byeo", "byeog", "byeogg", "byeogs", "byeon", "byeonj", "byeonh", "byeod", "byeol", "byeolg", "byeolm", "byeolb", "byeols", "byeolt", "byeolp", "byeolh", "byeom", "byeob", "byeobs", "byeos", "byeoss", "byeong", "byeoj", "byeoc", "byeok", "byeot", "byeop", "byeoh", "bye", "byeg", "byegg", "byegs", "byen", "byenj", "byenh", "byed", "byel", "byelg", "byelm", "byelb", "byels", "byelt", "byelp", "byelh", "byem", "byeb", "byebs", "byes", "byess", "byeng", "byej", "byec", "byek", "byet", "byep", "byeh", "bo", "bog", "bogg", "bogs", "bon", "bonj", "bonh", "bod", "bol", "bolg", "bolm", "bolb"];
  }
});

// node_modules/unidecode/data/xbd.js
var require_xbd = __commonJS({
  "node_modules/unidecode/data/xbd.js"(exports2, module2) {
    module2.exports = ["bols", "bolt", "bolp", "bolh", "bom", "bob", "bobs", "bos", "boss", "bong", "boj", "boc", "bok", "bot", "bop", "boh", "bwa", "bwag", "bwagg", "bwags", "bwan", "bwanj", "bwanh", "bwad", "bwal", "bwalg", "bwalm", "bwalb", "bwals", "bwalt", "bwalp", "bwalh", "bwam", "bwab", "bwabs", "bwas", "bwass", "bwang", "bwaj", "bwac", "bwak", "bwat", "bwap", "bwah", "bwae", "bwaeg", "bwaegg", "bwaegs", "bwaen", "bwaenj", "bwaenh", "bwaed", "bwael", "bwaelg", "bwaelm", "bwaelb", "bwaels", "bwaelt", "bwaelp", "bwaelh", "bwaem", "bwaeb", "bwaebs", "bwaes", "bwaess", "bwaeng", "bwaej", "bwaec", "bwaek", "bwaet", "bwaep", "bwaeh", "boe", "boeg", "boegg", "boegs", "boen", "boenj", "boenh", "boed", "boel", "boelg", "boelm", "boelb", "boels", "boelt", "boelp", "boelh", "boem", "boeb", "boebs", "boes", "boess", "boeng", "boej", "boec", "boek", "boet", "boep", "boeh", "byo", "byog", "byogg", "byogs", "byon", "byonj", "byonh", "byod", "byol", "byolg", "byolm", "byolb", "byols", "byolt", "byolp", "byolh", "byom", "byob", "byobs", "byos", "byoss", "byong", "byoj", "byoc", "byok", "byot", "byop", "byoh", "bu", "bug", "bugg", "bugs", "bun", "bunj", "bunh", "bud", "bul", "bulg", "bulm", "bulb", "buls", "bult", "bulp", "bulh", "bum", "bub", "bubs", "bus", "buss", "bung", "buj", "buc", "buk", "but", "bup", "buh", "bweo", "bweog", "bweogg", "bweogs", "bweon", "bweonj", "bweonh", "bweod", "bweol", "bweolg", "bweolm", "bweolb", "bweols", "bweolt", "bweolp", "bweolh", "bweom", "bweob", "bweobs", "bweos", "bweoss", "bweong", "bweoj", "bweoc", "bweok", "bweot", "bweop", "bweoh", "bwe", "bweg", "bwegg", "bwegs", "bwen", "bwenj", "bwenh", "bwed", "bwel", "bwelg", "bwelm", "bwelb", "bwels", "bwelt", "bwelp", "bwelh", "bwem", "bweb", "bwebs", "bwes", "bwess", "bweng", "bwej", "bwec", "bwek", "bwet", "bwep", "bweh", "bwi", "bwig", "bwigg", "bwigs", "bwin", "bwinj", "bwinh", "bwid", "bwil", "bwilg", "bwilm", "bwilb", "bwils", "bwilt", "bwilp", "bwilh", "bwim", "bwib", "bwibs", "bwis", "bwiss", "bwing", "bwij", "bwic", "bwik", "bwit", "bwip", "bwih", "byu", "byug", "byugg", "byugs", "byun", "byunj", "byunh", "byud", "byul", "byulg", "byulm", "byulb", "byuls", "byult", "byulp", "byulh"];
  }
});

// node_modules/unidecode/data/xbe.js
var require_xbe = __commonJS({
  "node_modules/unidecode/data/xbe.js"(exports2, module2) {
    module2.exports = ["byum", "byub", "byubs", "byus", "byuss", "byung", "byuj", "byuc", "byuk", "byut", "byup", "byuh", "beu", "beug", "beugg", "beugs", "beun", "beunj", "beunh", "beud", "beul", "beulg", "beulm", "beulb", "beuls", "beult", "beulp", "beulh", "beum", "beub", "beubs", "beus", "beuss", "beung", "beuj", "beuc", "beuk", "beut", "beup", "beuh", "byi", "byig", "byigg", "byigs", "byin", "byinj", "byinh", "byid", "byil", "byilg", "byilm", "byilb", "byils", "byilt", "byilp", "byilh", "byim", "byib", "byibs", "byis", "byiss", "bying", "byij", "byic", "byik", "byit", "byip", "byih", "bi", "big", "bigg", "bigs", "bin", "binj", "binh", "bid", "bil", "bilg", "bilm", "bilb", "bils", "bilt", "bilp", "bilh", "bim", "bib", "bibs", "bis", "biss", "bing", "bij", "bic", "bik", "bit", "bip", "bih", "bba", "bbag", "bbagg", "bbags", "bban", "bbanj", "bbanh", "bbad", "bbal", "bbalg", "bbalm", "bbalb", "bbals", "bbalt", "bbalp", "bbalh", "bbam", "bbab", "bbabs", "bbas", "bbass", "bbang", "bbaj", "bbac", "bbak", "bbat", "bbap", "bbah", "bbae", "bbaeg", "bbaegg", "bbaegs", "bbaen", "bbaenj", "bbaenh", "bbaed", "bbael", "bbaelg", "bbaelm", "bbaelb", "bbaels", "bbaelt", "bbaelp", "bbaelh", "bbaem", "bbaeb", "bbaebs", "bbaes", "bbaess", "bbaeng", "bbaej", "bbaec", "bbaek", "bbaet", "bbaep", "bbaeh", "bbya", "bbyag", "bbyagg", "bbyags", "bbyan", "bbyanj", "bbyanh", "bbyad", "bbyal", "bbyalg", "bbyalm", "bbyalb", "bbyals", "bbyalt", "bbyalp", "bbyalh", "bbyam", "bbyab", "bbyabs", "bbyas", "bbyass", "bbyang", "bbyaj", "bbyac", "bbyak", "bbyat", "bbyap", "bbyah", "bbyae", "bbyaeg", "bbyaegg", "bbyaegs", "bbyaen", "bbyaenj", "bbyaenh", "bbyaed", "bbyael", "bbyaelg", "bbyaelm", "bbyaelb", "bbyaels", "bbyaelt", "bbyaelp", "bbyaelh", "bbyaem", "bbyaeb", "bbyaebs", "bbyaes", "bbyaess", "bbyaeng", "bbyaej", "bbyaec", "bbyaek", "bbyaet", "bbyaep", "bbyaeh", "bbeo", "bbeog", "bbeogg", "bbeogs", "bbeon", "bbeonj", "bbeonh", "bbeod", "bbeol", "bbeolg", "bbeolm", "bbeolb", "bbeols", "bbeolt", "bbeolp", "bbeolh", "bbeom", "bbeob", "bbeobs", "bbeos", "bbeoss", "bbeong", "bbeoj", "bbeoc", "bbeok", "bbeot", "bbeop", "bbeoh", "bbe", "bbeg", "bbegg", "bbegs", "bben", "bbenj", "bbenh", "bbed", "bbel", "bbelg", "bbelm", "bbelb", "bbels", "bbelt", "bbelp", "bbelh", "bbem", "bbeb", "bbebs", "bbes"];
  }
});

// node_modules/unidecode/data/xbf.js
var require_xbf = __commonJS({
  "node_modules/unidecode/data/xbf.js"(exports2, module2) {
    module2.exports = ["bbess", "bbeng", "bbej", "bbec", "bbek", "bbet", "bbep", "bbeh", "bbyeo", "bbyeog", "bbyeogg", "bbyeogs", "bbyeon", "bbyeonj", "bbyeonh", "bbyeod", "bbyeol", "bbyeolg", "bbyeolm", "bbyeolb", "bbyeols", "bbyeolt", "bbyeolp", "bbyeolh", "bbyeom", "bbyeob", "bbyeobs", "bbyeos", "bbyeoss", "bbyeong", "bbyeoj", "bbyeoc", "bbyeok", "bbyeot", "bbyeop", "bbyeoh", "bbye", "bbyeg", "bbyegg", "bbyegs", "bbyen", "bbyenj", "bbyenh", "bbyed", "bbyel", "bbyelg", "bbyelm", "bbyelb", "bbyels", "bbyelt", "bbyelp", "bbyelh", "bbyem", "bbyeb", "bbyebs", "bbyes", "bbyess", "bbyeng", "bbyej", "bbyec", "bbyek", "bbyet", "bbyep", "bbyeh", "bbo", "bbog", "bbogg", "bbogs", "bbon", "bbonj", "bbonh", "bbod", "bbol", "bbolg", "bbolm", "bbolb", "bbols", "bbolt", "bbolp", "bbolh", "bbom", "bbob", "bbobs", "bbos", "bboss", "bbong", "bboj", "bboc", "bbok", "bbot", "bbop", "bboh", "bbwa", "bbwag", "bbwagg", "bbwags", "bbwan", "bbwanj", "bbwanh", "bbwad", "bbwal", "bbwalg", "bbwalm", "bbwalb", "bbwals", "bbwalt", "bbwalp", "bbwalh", "bbwam", "bbwab", "bbwabs", "bbwas", "bbwass", "bbwang", "bbwaj", "bbwac", "bbwak", "bbwat", "bbwap", "bbwah", "bbwae", "bbwaeg", "bbwaegg", "bbwaegs", "bbwaen", "bbwaenj", "bbwaenh", "bbwaed", "bbwael", "bbwaelg", "bbwaelm", "bbwaelb", "bbwaels", "bbwaelt", "bbwaelp", "bbwaelh", "bbwaem", "bbwaeb", "bbwaebs", "bbwaes", "bbwaess", "bbwaeng", "bbwaej", "bbwaec", "bbwaek", "bbwaet", "bbwaep", "bbwaeh", "bboe", "bboeg", "bboegg", "bboegs", "bboen", "bboenj", "bboenh", "bboed", "bboel", "bboelg", "bboelm", "bboelb", "bboels", "bboelt", "bboelp", "bboelh", "bboem", "bboeb", "bboebs", "bboes", "bboess", "bboeng", "bboej", "bboec", "bboek", "bboet", "bboep", "bboeh", "bbyo", "bbyog", "bbyogg", "bbyogs", "bbyon", "bbyonj", "bbyonh", "bbyod", "bbyol", "bbyolg", "bbyolm", "bbyolb", "bbyols", "bbyolt", "bbyolp", "bbyolh", "bbyom", "bbyob", "bbyobs", "bbyos", "bbyoss", "bbyong", "bbyoj", "bbyoc", "bbyok", "bbyot", "bbyop", "bbyoh", "bbu", "bbug", "bbugg", "bbugs", "bbun", "bbunj", "bbunh", "bbud", "bbul", "bbulg", "bbulm", "bbulb", "bbuls", "bbult", "bbulp", "bbulh", "bbum", "bbub", "bbubs", "bbus", "bbuss", "bbung", "bbuj", "bbuc", "bbuk", "bbut", "bbup", "bbuh", "bbweo", "bbweog", "bbweogg", "bbweogs", "bbweon", "bbweonj", "bbweonh", "bbweod", "bbweol", "bbweolg", "bbweolm", "bbweolb", "bbweols", "bbweolt", "bbweolp", "bbweolh", "bbweom", "bbweob", "bbweobs", "bbweos", "bbweoss", "bbweong", "bbweoj", "bbweoc"];
  }
});

// node_modules/unidecode/data/xc0.js
var require_xc0 = __commonJS({
  "node_modules/unidecode/data/xc0.js"(exports2, module2) {
    module2.exports = ["bbweok", "bbweot", "bbweop", "bbweoh", "bbwe", "bbweg", "bbwegg", "bbwegs", "bbwen", "bbwenj", "bbwenh", "bbwed", "bbwel", "bbwelg", "bbwelm", "bbwelb", "bbwels", "bbwelt", "bbwelp", "bbwelh", "bbwem", "bbweb", "bbwebs", "bbwes", "bbwess", "bbweng", "bbwej", "bbwec", "bbwek", "bbwet", "bbwep", "bbweh", "bbwi", "bbwig", "bbwigg", "bbwigs", "bbwin", "bbwinj", "bbwinh", "bbwid", "bbwil", "bbwilg", "bbwilm", "bbwilb", "bbwils", "bbwilt", "bbwilp", "bbwilh", "bbwim", "bbwib", "bbwibs", "bbwis", "bbwiss", "bbwing", "bbwij", "bbwic", "bbwik", "bbwit", "bbwip", "bbwih", "bbyu", "bbyug", "bbyugg", "bbyugs", "bbyun", "bbyunj", "bbyunh", "bbyud", "bbyul", "bbyulg", "bbyulm", "bbyulb", "bbyuls", "bbyult", "bbyulp", "bbyulh", "bbyum", "bbyub", "bbyubs", "bbyus", "bbyuss", "bbyung", "bbyuj", "bbyuc", "bbyuk", "bbyut", "bbyup", "bbyuh", "bbeu", "bbeug", "bbeugg", "bbeugs", "bbeun", "bbeunj", "bbeunh", "bbeud", "bbeul", "bbeulg", "bbeulm", "bbeulb", "bbeuls", "bbeult", "bbeulp", "bbeulh", "bbeum", "bbeub", "bbeubs", "bbeus", "bbeuss", "bbeung", "bbeuj", "bbeuc", "bbeuk", "bbeut", "bbeup", "bbeuh", "bbyi", "bbyig", "bbyigg", "bbyigs", "bbyin", "bbyinj", "bbyinh", "bbyid", "bbyil", "bbyilg", "bbyilm", "bbyilb", "bbyils", "bbyilt", "bbyilp", "bbyilh", "bbyim", "bbyib", "bbyibs", "bbyis", "bbyiss", "bbying", "bbyij", "bbyic", "bbyik", "bbyit", "bbyip", "bbyih", "bbi", "bbig", "bbigg", "bbigs", "bbin", "bbinj", "bbinh", "bbid", "bbil", "bbilg", "bbilm", "bbilb", "bbils", "bbilt", "bbilp", "bbilh", "bbim", "bbib", "bbibs", "bbis", "bbiss", "bbing", "bbij", "bbic", "bbik", "bbit", "bbip", "bbih", "sa", "sag", "sagg", "sags", "san", "sanj", "sanh", "sad", "sal", "salg", "salm", "salb", "sals", "salt", "salp", "salh", "sam", "sab", "sabs", "sas", "sass", "sang", "saj", "sac", "sak", "sat", "sap", "sah", "sae", "saeg", "saegg", "saegs", "saen", "saenj", "saenh", "saed", "sael", "saelg", "saelm", "saelb", "saels", "saelt", "saelp", "saelh", "saem", "saeb", "saebs", "saes", "saess", "saeng", "saej", "saec", "saek", "saet", "saep", "saeh", "sya", "syag", "syagg", "syags", "syan", "syanj", "syanh", "syad", "syal", "syalg", "syalm", "syalb", "syals", "syalt", "syalp", "syalh", "syam", "syab", "syabs", "syas", "syass", "syang", "syaj", "syac", "syak", "syat", "syap", "syah"];
  }
});

// node_modules/unidecode/data/xc1.js
var require_xc1 = __commonJS({
  "node_modules/unidecode/data/xc1.js"(exports2, module2) {
    module2.exports = ["syae", "syaeg", "syaegg", "syaegs", "syaen", "syaenj", "syaenh", "syaed", "syael", "syaelg", "syaelm", "syaelb", "syaels", "syaelt", "syaelp", "syaelh", "syaem", "syaeb", "syaebs", "syaes", "syaess", "syaeng", "syaej", "syaec", "syaek", "syaet", "syaep", "syaeh", "seo", "seog", "seogg", "seogs", "seon", "seonj", "seonh", "seod", "seol", "seolg", "seolm", "seolb", "seols", "seolt", "seolp", "seolh", "seom", "seob", "seobs", "seos", "seoss", "seong", "seoj", "seoc", "seok", "seot", "seop", "seoh", "se", "seg", "segg", "segs", "sen", "senj", "senh", "sed", "sel", "selg", "selm", "selb", "sels", "selt", "selp", "selh", "sem", "seb", "sebs", "ses", "sess", "seng", "sej", "sec", "sek", "set", "sep", "seh", "syeo", "syeog", "syeogg", "syeogs", "syeon", "syeonj", "syeonh", "syeod", "syeol", "syeolg", "syeolm", "syeolb", "syeols", "syeolt", "syeolp", "syeolh", "syeom", "syeob", "syeobs", "syeos", "syeoss", "syeong", "syeoj", "syeoc", "syeok", "syeot", "syeop", "syeoh", "sye", "syeg", "syegg", "syegs", "syen", "syenj", "syenh", "syed", "syel", "syelg", "syelm", "syelb", "syels", "syelt", "syelp", "syelh", "syem", "syeb", "syebs", "syes", "syess", "syeng", "syej", "syec", "syek", "syet", "syep", "syeh", "so", "sog", "sogg", "sogs", "son", "sonj", "sonh", "sod", "sol", "solg", "solm", "solb", "sols", "solt", "solp", "solh", "som", "sob", "sobs", "sos", "soss", "song", "soj", "soc", "sok", "sot", "sop", "soh", "swa", "swag", "swagg", "swags", "swan", "swanj", "swanh", "swad", "swal", "swalg", "swalm", "swalb", "swals", "swalt", "swalp", "swalh", "swam", "swab", "swabs", "swas", "swass", "swang", "swaj", "swac", "swak", "swat", "swap", "swah", "swae", "swaeg", "swaegg", "swaegs", "swaen", "swaenj", "swaenh", "swaed", "swael", "swaelg", "swaelm", "swaelb", "swaels", "swaelt", "swaelp", "swaelh", "swaem", "swaeb", "swaebs", "swaes", "swaess", "swaeng", "swaej", "swaec", "swaek", "swaet", "swaep", "swaeh", "soe", "soeg", "soegg", "soegs", "soen", "soenj", "soenh", "soed", "soel", "soelg", "soelm", "soelb", "soels", "soelt", "soelp", "soelh", "soem", "soeb", "soebs", "soes", "soess", "soeng", "soej", "soec", "soek", "soet", "soep", "soeh", "syo", "syog", "syogg", "syogs"];
  }
});

// node_modules/unidecode/data/xc2.js
var require_xc2 = __commonJS({
  "node_modules/unidecode/data/xc2.js"(exports2, module2) {
    module2.exports = ["syon", "syonj", "syonh", "syod", "syol", "syolg", "syolm", "syolb", "syols", "syolt", "syolp", "syolh", "syom", "syob", "syobs", "syos", "syoss", "syong", "syoj", "syoc", "syok", "syot", "syop", "syoh", "su", "sug", "sugg", "sugs", "sun", "sunj", "sunh", "sud", "sul", "sulg", "sulm", "sulb", "suls", "sult", "sulp", "sulh", "sum", "sub", "subs", "sus", "suss", "sung", "suj", "suc", "suk", "sut", "sup", "suh", "sweo", "sweog", "sweogg", "sweogs", "sweon", "sweonj", "sweonh", "sweod", "sweol", "sweolg", "sweolm", "sweolb", "sweols", "sweolt", "sweolp", "sweolh", "sweom", "sweob", "sweobs", "sweos", "sweoss", "sweong", "sweoj", "sweoc", "sweok", "sweot", "sweop", "sweoh", "swe", "sweg", "swegg", "swegs", "swen", "swenj", "swenh", "swed", "swel", "swelg", "swelm", "swelb", "swels", "swelt", "swelp", "swelh", "swem", "sweb", "swebs", "swes", "swess", "sweng", "swej", "swec", "swek", "swet", "swep", "sweh", "swi", "swig", "swigg", "swigs", "swin", "swinj", "swinh", "swid", "swil", "swilg", "swilm", "swilb", "swils", "swilt", "swilp", "swilh", "swim", "swib", "swibs", "swis", "swiss", "swing", "swij", "swic", "swik", "swit", "swip", "swih", "syu", "syug", "syugg", "syugs", "syun", "syunj", "syunh", "syud", "syul", "syulg", "syulm", "syulb", "syuls", "syult", "syulp", "syulh", "syum", "syub", "syubs", "syus", "syuss", "syung", "syuj", "syuc", "syuk", "syut", "syup", "syuh", "seu", "seug", "seugg", "seugs", "seun", "seunj", "seunh", "seud", "seul", "seulg", "seulm", "seulb", "seuls", "seult", "seulp", "seulh", "seum", "seub", "seubs", "seus", "seuss", "seung", "seuj", "seuc", "seuk", "seut", "seup", "seuh", "syi", "syig", "syigg", "syigs", "syin", "syinj", "syinh", "syid", "syil", "syilg", "syilm", "syilb", "syils", "syilt", "syilp", "syilh", "syim", "syib", "syibs", "syis", "syiss", "sying", "syij", "syic", "syik", "syit", "syip", "syih", "si", "sig", "sigg", "sigs", "sin", "sinj", "sinh", "sid", "sil", "silg", "silm", "silb", "sils", "silt", "silp", "silh", "sim", "sib", "sibs", "sis", "siss", "sing", "sij", "sic", "sik", "sit", "sip", "sih", "ssa", "ssag", "ssagg", "ssags", "ssan", "ssanj", "ssanh", "ssad"];
  }
});

// node_modules/unidecode/data/xc3.js
var require_xc3 = __commonJS({
  "node_modules/unidecode/data/xc3.js"(exports2, module2) {
    module2.exports = ["ssal", "ssalg", "ssalm", "ssalb", "ssals", "ssalt", "ssalp", "ssalh", "ssam", "ssab", "ssabs", "ssas", "ssass", "ssang", "ssaj", "ssac", "ssak", "ssat", "ssap", "ssah", "ssae", "ssaeg", "ssaegg", "ssaegs", "ssaen", "ssaenj", "ssaenh", "ssaed", "ssael", "ssaelg", "ssaelm", "ssaelb", "ssaels", "ssaelt", "ssaelp", "ssaelh", "ssaem", "ssaeb", "ssaebs", "ssaes", "ssaess", "ssaeng", "ssaej", "ssaec", "ssaek", "ssaet", "ssaep", "ssaeh", "ssya", "ssyag", "ssyagg", "ssyags", "ssyan", "ssyanj", "ssyanh", "ssyad", "ssyal", "ssyalg", "ssyalm", "ssyalb", "ssyals", "ssyalt", "ssyalp", "ssyalh", "ssyam", "ssyab", "ssyabs", "ssyas", "ssyass", "ssyang", "ssyaj", "ssyac", "ssyak", "ssyat", "ssyap", "ssyah", "ssyae", "ssyaeg", "ssyaegg", "ssyaegs", "ssyaen", "ssyaenj", "ssyaenh", "ssyaed", "ssyael", "ssyaelg", "ssyaelm", "ssyaelb", "ssyaels", "ssyaelt", "ssyaelp", "ssyaelh", "ssyaem", "ssyaeb", "ssyaebs", "ssyaes", "ssyaess", "ssyaeng", "ssyaej", "ssyaec", "ssyaek", "ssyaet", "ssyaep", "ssyaeh", "sseo", "sseog", "sseogg", "sseogs", "sseon", "sseonj", "sseonh", "sseod", "sseol", "sseolg", "sseolm", "sseolb", "sseols", "sseolt", "sseolp", "sseolh", "sseom", "sseob", "sseobs", "sseos", "sseoss", "sseong", "sseoj", "sseoc", "sseok", "sseot", "sseop", "sseoh", "sse", "sseg", "ssegg", "ssegs", "ssen", "ssenj", "ssenh", "ssed", "ssel", "sselg", "sselm", "sselb", "ssels", "sselt", "sselp", "sselh", "ssem", "sseb", "ssebs", "sses", "ssess", "sseng", "ssej", "ssec", "ssek", "sset", "ssep", "sseh", "ssyeo", "ssyeog", "ssyeogg", "ssyeogs", "ssyeon", "ssyeonj", "ssyeonh", "ssyeod", "ssyeol", "ssyeolg", "ssyeolm", "ssyeolb", "ssyeols", "ssyeolt", "ssyeolp", "ssyeolh", "ssyeom", "ssyeob", "ssyeobs", "ssyeos", "ssyeoss", "ssyeong", "ssyeoj", "ssyeoc", "ssyeok", "ssyeot", "ssyeop", "ssyeoh", "ssye", "ssyeg", "ssyegg", "ssyegs", "ssyen", "ssyenj", "ssyenh", "ssyed", "ssyel", "ssyelg", "ssyelm", "ssyelb", "ssyels", "ssyelt", "ssyelp", "ssyelh", "ssyem", "ssyeb", "ssyebs", "ssyes", "ssyess", "ssyeng", "ssyej", "ssyec", "ssyek", "ssyet", "ssyep", "ssyeh", "sso", "ssog", "ssogg", "ssogs", "sson", "ssonj", "ssonh", "ssod", "ssol", "ssolg", "ssolm", "ssolb", "ssols", "ssolt", "ssolp", "ssolh", "ssom", "ssob", "ssobs", "ssos", "ssoss", "ssong", "ssoj", "ssoc", "ssok", "ssot", "ssop", "ssoh", "sswa", "sswag", "sswagg", "sswags", "sswan", "sswanj", "sswanh", "sswad", "sswal", "sswalg", "sswalm", "sswalb"];
  }
});

// node_modules/unidecode/data/xc4.js
var require_xc4 = __commonJS({
  "node_modules/unidecode/data/xc4.js"(exports2, module2) {
    module2.exports = ["sswals", "sswalt", "sswalp", "sswalh", "sswam", "sswab", "sswabs", "sswas", "sswass", "sswang", "sswaj", "sswac", "sswak", "sswat", "sswap", "sswah", "sswae", "sswaeg", "sswaegg", "sswaegs", "sswaen", "sswaenj", "sswaenh", "sswaed", "sswael", "sswaelg", "sswaelm", "sswaelb", "sswaels", "sswaelt", "sswaelp", "sswaelh", "sswaem", "sswaeb", "sswaebs", "sswaes", "sswaess", "sswaeng", "sswaej", "sswaec", "sswaek", "sswaet", "sswaep", "sswaeh", "ssoe", "ssoeg", "ssoegg", "ssoegs", "ssoen", "ssoenj", "ssoenh", "ssoed", "ssoel", "ssoelg", "ssoelm", "ssoelb", "ssoels", "ssoelt", "ssoelp", "ssoelh", "ssoem", "ssoeb", "ssoebs", "ssoes", "ssoess", "ssoeng", "ssoej", "ssoec", "ssoek", "ssoet", "ssoep", "ssoeh", "ssyo", "ssyog", "ssyogg", "ssyogs", "ssyon", "ssyonj", "ssyonh", "ssyod", "ssyol", "ssyolg", "ssyolm", "ssyolb", "ssyols", "ssyolt", "ssyolp", "ssyolh", "ssyom", "ssyob", "ssyobs", "ssyos", "ssyoss", "ssyong", "ssyoj", "ssyoc", "ssyok", "ssyot", "ssyop", "ssyoh", "ssu", "ssug", "ssugg", "ssugs", "ssun", "ssunj", "ssunh", "ssud", "ssul", "ssulg", "ssulm", "ssulb", "ssuls", "ssult", "ssulp", "ssulh", "ssum", "ssub", "ssubs", "ssus", "ssuss", "ssung", "ssuj", "ssuc", "ssuk", "ssut", "ssup", "ssuh", "ssweo", "ssweog", "ssweogg", "ssweogs", "ssweon", "ssweonj", "ssweonh", "ssweod", "ssweol", "ssweolg", "ssweolm", "ssweolb", "ssweols", "ssweolt", "ssweolp", "ssweolh", "ssweom", "ssweob", "ssweobs", "ssweos", "ssweoss", "ssweong", "ssweoj", "ssweoc", "ssweok", "ssweot", "ssweop", "ssweoh", "sswe", "ssweg", "sswegg", "sswegs", "sswen", "sswenj", "sswenh", "sswed", "sswel", "sswelg", "sswelm", "sswelb", "sswels", "sswelt", "sswelp", "sswelh", "sswem", "ssweb", "sswebs", "sswes", "sswess", "ssweng", "sswej", "sswec", "sswek", "sswet", "sswep", "ssweh", "sswi", "sswig", "sswigg", "sswigs", "sswin", "sswinj", "sswinh", "sswid", "sswil", "sswilg", "sswilm", "sswilb", "sswils", "sswilt", "sswilp", "sswilh", "sswim", "sswib", "sswibs", "sswis", "sswiss", "sswing", "sswij", "sswic", "sswik", "sswit", "sswip", "sswih", "ssyu", "ssyug", "ssyugg", "ssyugs", "ssyun", "ssyunj", "ssyunh", "ssyud", "ssyul", "ssyulg", "ssyulm", "ssyulb", "ssyuls", "ssyult", "ssyulp", "ssyulh", "ssyum", "ssyub", "ssyubs", "ssyus", "ssyuss", "ssyung", "ssyuj", "ssyuc", "ssyuk", "ssyut", "ssyup", "ssyuh", "sseu", "sseug", "sseugg", "sseugs", "sseun", "sseunj", "sseunh", "sseud", "sseul", "sseulg", "sseulm", "sseulb", "sseuls", "sseult", "sseulp", "sseulh"];
  }
});

// node_modules/unidecode/data/xc5.js
var require_xc5 = __commonJS({
  "node_modules/unidecode/data/xc5.js"(exports2, module2) {
    module2.exports = ["sseum", "sseub", "sseubs", "sseus", "sseuss", "sseung", "sseuj", "sseuc", "sseuk", "sseut", "sseup", "sseuh", "ssyi", "ssyig", "ssyigg", "ssyigs", "ssyin", "ssyinj", "ssyinh", "ssyid", "ssyil", "ssyilg", "ssyilm", "ssyilb", "ssyils", "ssyilt", "ssyilp", "ssyilh", "ssyim", "ssyib", "ssyibs", "ssyis", "ssyiss", "ssying", "ssyij", "ssyic", "ssyik", "ssyit", "ssyip", "ssyih", "ssi", "ssig", "ssigg", "ssigs", "ssin", "ssinj", "ssinh", "ssid", "ssil", "ssilg", "ssilm", "ssilb", "ssils", "ssilt", "ssilp", "ssilh", "ssim", "ssib", "ssibs", "ssis", "ssiss", "ssing", "ssij", "ssic", "ssik", "ssit", "ssip", "ssih", "a", "ag", "agg", "ags", "an", "anj", "anh", "ad", "al", "alg", "alm", "alb", "als", "alt", "alp", "alh", "am", "ab", "abs", "as", "ass", "ang", "aj", "ac", "ak", "at", "ap", "ah", "ae", "aeg", "aegg", "aegs", "aen", "aenj", "aenh", "aed", "ael", "aelg", "aelm", "aelb", "aels", "aelt", "aelp", "aelh", "aem", "aeb", "aebs", "aes", "aess", "aeng", "aej", "aec", "aek", "aet", "aep", "aeh", "ya", "yag", "yagg", "yags", "yan", "yanj", "yanh", "yad", "yal", "yalg", "yalm", "yalb", "yals", "yalt", "yalp", "yalh", "yam", "yab", "yabs", "yas", "yass", "yang", "yaj", "yac", "yak", "yat", "yap", "yah", "yae", "yaeg", "yaegg", "yaegs", "yaen", "yaenj", "yaenh", "yaed", "yael", "yaelg", "yaelm", "yaelb", "yaels", "yaelt", "yaelp", "yaelh", "yaem", "yaeb", "yaebs", "yaes", "yaess", "yaeng", "yaej", "yaec", "yaek", "yaet", "yaep", "yaeh", "eo", "eog", "eogg", "eogs", "eon", "eonj", "eonh", "eod", "eol", "eolg", "eolm", "eolb", "eols", "eolt", "eolp", "eolh", "eom", "eob", "eobs", "eos", "eoss", "eong", "eoj", "eoc", "eok", "eot", "eop", "eoh", "e", "eg", "egg", "egs", "en", "enj", "enh", "ed", "el", "elg", "elm", "elb", "els", "elt", "elp", "elh", "em", "eb", "ebs", "es", "ess", "eng", "ej", "ec", "ek", "et", "ep", "eh", "yeo", "yeog", "yeogg", "yeogs", "yeon", "yeonj", "yeonh", "yeod", "yeol", "yeolg", "yeolm", "yeolb", "yeols", "yeolt", "yeolp", "yeolh", "yeom", "yeob", "yeobs", "yeos"];
  }
});

// node_modules/unidecode/data/xc6.js
var require_xc6 = __commonJS({
  "node_modules/unidecode/data/xc6.js"(exports2, module2) {
    module2.exports = ["yeoss", "yeong", "yeoj", "yeoc", "yeok", "yeot", "yeop", "yeoh", "ye", "yeg", "yegg", "yegs", "yen", "yenj", "yenh", "yed", "yel", "yelg", "yelm", "yelb", "yels", "yelt", "yelp", "yelh", "yem", "yeb", "yebs", "yes", "yess", "yeng", "yej", "yec", "yek", "yet", "yep", "yeh", "o", "og", "ogg", "ogs", "on", "onj", "onh", "od", "ol", "olg", "olm", "olb", "ols", "olt", "olp", "olh", "om", "ob", "obs", "os", "oss", "ong", "oj", "oc", "ok", "ot", "op", "oh", "wa", "wag", "wagg", "wags", "wan", "wanj", "wanh", "wad", "wal", "walg", "walm", "walb", "wals", "walt", "walp", "walh", "wam", "wab", "wabs", "was", "wass", "wang", "waj", "wac", "wak", "wat", "wap", "wah", "wae", "waeg", "waegg", "waegs", "waen", "waenj", "waenh", "waed", "wael", "waelg", "waelm", "waelb", "waels", "waelt", "waelp", "waelh", "waem", "waeb", "waebs", "waes", "waess", "waeng", "waej", "waec", "waek", "waet", "waep", "waeh", "oe", "oeg", "oegg", "oegs", "oen", "oenj", "oenh", "oed", "oel", "oelg", "oelm", "oelb", "oels", "oelt", "oelp", "oelh", "oem", "oeb", "oebs", "oes", "oess", "oeng", "oej", "oec", "oek", "oet", "oep", "oeh", "yo", "yog", "yogg", "yogs", "yon", "yonj", "yonh", "yod", "yol", "yolg", "yolm", "yolb", "yols", "yolt", "yolp", "yolh", "yom", "yob", "yobs", "yos", "yoss", "yong", "yoj", "yoc", "yok", "yot", "yop", "yoh", "u", "ug", "ugg", "ugs", "un", "unj", "unh", "ud", "ul", "ulg", "ulm", "ulb", "uls", "ult", "ulp", "ulh", "um", "ub", "ubs", "us", "uss", "ung", "uj", "uc", "uk", "ut", "up", "uh", "weo", "weog", "weogg", "weogs", "weon", "weonj", "weonh", "weod", "weol", "weolg", "weolm", "weolb", "weols", "weolt", "weolp", "weolh", "weom", "weob", "weobs", "weos", "weoss", "weong", "weoj", "weoc", "weok", "weot", "weop", "weoh", "we", "weg", "wegg", "wegs", "wen", "wenj", "wenh", "wed", "wel", "welg", "welm", "welb", "wels", "welt", "welp", "welh", "wem", "web", "webs", "wes", "wess", "weng", "wej", "wec"];
  }
});

// node_modules/unidecode/data/xc7.js
var require_xc7 = __commonJS({
  "node_modules/unidecode/data/xc7.js"(exports2, module2) {
    module2.exports = ["wek", "wet", "wep", "weh", "wi", "wig", "wigg", "wigs", "win", "winj", "winh", "wid", "wil", "wilg", "wilm", "wilb", "wils", "wilt", "wilp", "wilh", "wim", "wib", "wibs", "wis", "wiss", "wing", "wij", "wic", "wik", "wit", "wip", "wih", "yu", "yug", "yugg", "yugs", "yun", "yunj", "yunh", "yud", "yul", "yulg", "yulm", "yulb", "yuls", "yult", "yulp", "yulh", "yum", "yub", "yubs", "yus", "yuss", "yung", "yuj", "yuc", "yuk", "yut", "yup", "yuh", "eu", "eug", "eugg", "eugs", "eun", "eunj", "eunh", "eud", "eul", "eulg", "eulm", "eulb", "euls", "eult", "eulp", "eulh", "eum", "eub", "eubs", "eus", "euss", "eung", "euj", "euc", "euk", "eut", "eup", "euh", "yi", "yig", "yigg", "yigs", "yin", "yinj", "yinh", "yid", "yil", "yilg", "yilm", "yilb", "yils", "yilt", "yilp", "yilh", "yim", "yib", "yibs", "yis", "yiss", "ying", "yij", "yic", "yik", "yit", "yip", "yih", "i", "ig", "igg", "igs", "in", "inj", "inh", "id", "il", "ilg", "ilm", "ilb", "ils", "ilt", "ilp", "ilh", "im", "ib", "ibs", "is", "iss", "ing", "ij", "ic", "ik", "it", "ip", "ih", "ja", "jag", "jagg", "jags", "jan", "janj", "janh", "jad", "jal", "jalg", "jalm", "jalb", "jals", "jalt", "jalp", "jalh", "jam", "jab", "jabs", "jas", "jass", "jang", "jaj", "jac", "jak", "jat", "jap", "jah", "jae", "jaeg", "jaegg", "jaegs", "jaen", "jaenj", "jaenh", "jaed", "jael", "jaelg", "jaelm", "jaelb", "jaels", "jaelt", "jaelp", "jaelh", "jaem", "jaeb", "jaebs", "jaes", "jaess", "jaeng", "jaej", "jaec", "jaek", "jaet", "jaep", "jaeh", "jya", "jyag", "jyagg", "jyags", "jyan", "jyanj", "jyanh", "jyad", "jyal", "jyalg", "jyalm", "jyalb", "jyals", "jyalt", "jyalp", "jyalh", "jyam", "jyab", "jyabs", "jyas", "jyass", "jyang", "jyaj", "jyac", "jyak", "jyat", "jyap", "jyah", "jyae", "jyaeg", "jyaegg", "jyaegs", "jyaen", "jyaenj", "jyaenh", "jyaed", "jyael", "jyaelg", "jyaelm", "jyaelb", "jyaels", "jyaelt", "jyaelp", "jyaelh", "jyaem", "jyaeb", "jyaebs", "jyaes", "jyaess", "jyaeng", "jyaej", "jyaec", "jyaek", "jyaet", "jyaep", "jyaeh"];
  }
});

// node_modules/unidecode/data/xc8.js
var require_xc8 = __commonJS({
  "node_modules/unidecode/data/xc8.js"(exports2, module2) {
    module2.exports = ["jeo", "jeog", "jeogg", "jeogs", "jeon", "jeonj", "jeonh", "jeod", "jeol", "jeolg", "jeolm", "jeolb", "jeols", "jeolt", "jeolp", "jeolh", "jeom", "jeob", "jeobs", "jeos", "jeoss", "jeong", "jeoj", "jeoc", "jeok", "jeot", "jeop", "jeoh", "je", "jeg", "jegg", "jegs", "jen", "jenj", "jenh", "jed", "jel", "jelg", "jelm", "jelb", "jels", "jelt", "jelp", "jelh", "jem", "jeb", "jebs", "jes", "jess", "jeng", "jej", "jec", "jek", "jet", "jep", "jeh", "jyeo", "jyeog", "jyeogg", "jyeogs", "jyeon", "jyeonj", "jyeonh", "jyeod", "jyeol", "jyeolg", "jyeolm", "jyeolb", "jyeols", "jyeolt", "jyeolp", "jyeolh", "jyeom", "jyeob", "jyeobs", "jyeos", "jyeoss", "jyeong", "jyeoj", "jyeoc", "jyeok", "jyeot", "jyeop", "jyeoh", "jye", "jyeg", "jyegg", "jyegs", "jyen", "jyenj", "jyenh", "jyed", "jyel", "jyelg", "jyelm", "jyelb", "jyels", "jyelt", "jyelp", "jyelh", "jyem", "jyeb", "jyebs", "jyes", "jyess", "jyeng", "jyej", "jyec", "jyek", "jyet", "jyep", "jyeh", "jo", "jog", "jogg", "jogs", "jon", "jonj", "jonh", "jod", "jol", "jolg", "jolm", "jolb", "jols", "jolt", "jolp", "jolh", "jom", "job", "jobs", "jos", "joss", "jong", "joj", "joc", "jok", "jot", "jop", "joh", "jwa", "jwag", "jwagg", "jwags", "jwan", "jwanj", "jwanh", "jwad", "jwal", "jwalg", "jwalm", "jwalb", "jwals", "jwalt", "jwalp", "jwalh", "jwam", "jwab", "jwabs", "jwas", "jwass", "jwang", "jwaj", "jwac", "jwak", "jwat", "jwap", "jwah", "jwae", "jwaeg", "jwaegg", "jwaegs", "jwaen", "jwaenj", "jwaenh", "jwaed", "jwael", "jwaelg", "jwaelm", "jwaelb", "jwaels", "jwaelt", "jwaelp", "jwaelh", "jwaem", "jwaeb", "jwaebs", "jwaes", "jwaess", "jwaeng", "jwaej", "jwaec", "jwaek", "jwaet", "jwaep", "jwaeh", "joe", "joeg", "joegg", "joegs", "joen", "joenj", "joenh", "joed", "joel", "joelg", "joelm", "joelb", "joels", "joelt", "joelp", "joelh", "joem", "joeb", "joebs", "joes", "joess", "joeng", "joej", "joec", "joek", "joet", "joep", "joeh", "jyo", "jyog", "jyogg", "jyogs", "jyon", "jyonj", "jyonh", "jyod", "jyol", "jyolg", "jyolm", "jyolb", "jyols", "jyolt", "jyolp", "jyolh", "jyom", "jyob", "jyobs", "jyos", "jyoss", "jyong", "jyoj", "jyoc", "jyok", "jyot", "jyop", "jyoh", "ju", "jug", "jugg", "jugs"];
  }
});

// node_modules/unidecode/data/xc9.js
var require_xc9 = __commonJS({
  "node_modules/unidecode/data/xc9.js"(exports2, module2) {
    module2.exports = ["jun", "junj", "junh", "jud", "jul", "julg", "julm", "julb", "juls", "jult", "julp", "julh", "jum", "jub", "jubs", "jus", "juss", "jung", "juj", "juc", "juk", "jut", "jup", "juh", "jweo", "jweog", "jweogg", "jweogs", "jweon", "jweonj", "jweonh", "jweod", "jweol", "jweolg", "jweolm", "jweolb", "jweols", "jweolt", "jweolp", "jweolh", "jweom", "jweob", "jweobs", "jweos", "jweoss", "jweong", "jweoj", "jweoc", "jweok", "jweot", "jweop", "jweoh", "jwe", "jweg", "jwegg", "jwegs", "jwen", "jwenj", "jwenh", "jwed", "jwel", "jwelg", "jwelm", "jwelb", "jwels", "jwelt", "jwelp", "jwelh", "jwem", "jweb", "jwebs", "jwes", "jwess", "jweng", "jwej", "jwec", "jwek", "jwet", "jwep", "jweh", "jwi", "jwig", "jwigg", "jwigs", "jwin", "jwinj", "jwinh", "jwid", "jwil", "jwilg", "jwilm", "jwilb", "jwils", "jwilt", "jwilp", "jwilh", "jwim", "jwib", "jwibs", "jwis", "jwiss", "jwing", "jwij", "jwic", "jwik", "jwit", "jwip", "jwih", "jyu", "jyug", "jyugg", "jyugs", "jyun", "jyunj", "jyunh", "jyud", "jyul", "jyulg", "jyulm", "jyulb", "jyuls", "jyult", "jyulp", "jyulh", "jyum", "jyub", "jyubs", "jyus", "jyuss", "jyung", "jyuj", "jyuc", "jyuk", "jyut", "jyup", "jyuh", "jeu", "jeug", "jeugg", "jeugs", "jeun", "jeunj", "jeunh", "jeud", "jeul", "jeulg", "jeulm", "jeulb", "jeuls", "jeult", "jeulp", "jeulh", "jeum", "jeub", "jeubs", "jeus", "jeuss", "jeung", "jeuj", "jeuc", "jeuk", "jeut", "jeup", "jeuh", "jyi", "jyig", "jyigg", "jyigs", "jyin", "jyinj", "jyinh", "jyid", "jyil", "jyilg", "jyilm", "jyilb", "jyils", "jyilt", "jyilp", "jyilh", "jyim", "jyib", "jyibs", "jyis", "jyiss", "jying", "jyij", "jyic", "jyik", "jyit", "jyip", "jyih", "ji", "jig", "jigg", "jigs", "jin", "jinj", "jinh", "jid", "jil", "jilg", "jilm", "jilb", "jils", "jilt", "jilp", "jilh", "jim", "jib", "jibs", "jis", "jiss", "jing", "jij", "jic", "jik", "jit", "jip", "jih", "jja", "jjag", "jjagg", "jjags", "jjan", "jjanj", "jjanh", "jjad", "jjal", "jjalg", "jjalm", "jjalb", "jjals", "jjalt", "jjalp", "jjalh", "jjam", "jjab", "jjabs", "jjas", "jjass", "jjang", "jjaj", "jjac", "jjak", "jjat", "jjap", "jjah", "jjae", "jjaeg", "jjaegg", "jjaegs", "jjaen", "jjaenj", "jjaenh", "jjaed"];
  }
});

// node_modules/unidecode/data/xca.js
var require_xca = __commonJS({
  "node_modules/unidecode/data/xca.js"(exports2, module2) {
    module2.exports = ["jjael", "jjaelg", "jjaelm", "jjaelb", "jjaels", "jjaelt", "jjaelp", "jjaelh", "jjaem", "jjaeb", "jjaebs", "jjaes", "jjaess", "jjaeng", "jjaej", "jjaec", "jjaek", "jjaet", "jjaep", "jjaeh", "jjya", "jjyag", "jjyagg", "jjyags", "jjyan", "jjyanj", "jjyanh", "jjyad", "jjyal", "jjyalg", "jjyalm", "jjyalb", "jjyals", "jjyalt", "jjyalp", "jjyalh", "jjyam", "jjyab", "jjyabs", "jjyas", "jjyass", "jjyang", "jjyaj", "jjyac", "jjyak", "jjyat", "jjyap", "jjyah", "jjyae", "jjyaeg", "jjyaegg", "jjyaegs", "jjyaen", "jjyaenj", "jjyaenh", "jjyaed", "jjyael", "jjyaelg", "jjyaelm", "jjyaelb", "jjyaels", "jjyaelt", "jjyaelp", "jjyaelh", "jjyaem", "jjyaeb", "jjyaebs", "jjyaes", "jjyaess", "jjyaeng", "jjyaej", "jjyaec", "jjyaek", "jjyaet", "jjyaep", "jjyaeh", "jjeo", "jjeog", "jjeogg", "jjeogs", "jjeon", "jjeonj", "jjeonh", "jjeod", "jjeol", "jjeolg", "jjeolm", "jjeolb", "jjeols", "jjeolt", "jjeolp", "jjeolh", "jjeom", "jjeob", "jjeobs", "jjeos", "jjeoss", "jjeong", "jjeoj", "jjeoc", "jjeok", "jjeot", "jjeop", "jjeoh", "jje", "jjeg", "jjegg", "jjegs", "jjen", "jjenj", "jjenh", "jjed", "jjel", "jjelg", "jjelm", "jjelb", "jjels", "jjelt", "jjelp", "jjelh", "jjem", "jjeb", "jjebs", "jjes", "jjess", "jjeng", "jjej", "jjec", "jjek", "jjet", "jjep", "jjeh", "jjyeo", "jjyeog", "jjyeogg", "jjyeogs", "jjyeon", "jjyeonj", "jjyeonh", "jjyeod", "jjyeol", "jjyeolg", "jjyeolm", "jjyeolb", "jjyeols", "jjyeolt", "jjyeolp", "jjyeolh", "jjyeom", "jjyeob", "jjyeobs", "jjyeos", "jjyeoss", "jjyeong", "jjyeoj", "jjyeoc", "jjyeok", "jjyeot", "jjyeop", "jjyeoh", "jjye", "jjyeg", "jjyegg", "jjyegs", "jjyen", "jjyenj", "jjyenh", "jjyed", "jjyel", "jjyelg", "jjyelm", "jjyelb", "jjyels", "jjyelt", "jjyelp", "jjyelh", "jjyem", "jjyeb", "jjyebs", "jjyes", "jjyess", "jjyeng", "jjyej", "jjyec", "jjyek", "jjyet", "jjyep", "jjyeh", "jjo", "jjog", "jjogg", "jjogs", "jjon", "jjonj", "jjonh", "jjod", "jjol", "jjolg", "jjolm", "jjolb", "jjols", "jjolt", "jjolp", "jjolh", "jjom", "jjob", "jjobs", "jjos", "jjoss", "jjong", "jjoj", "jjoc", "jjok", "jjot", "jjop", "jjoh", "jjwa", "jjwag", "jjwagg", "jjwags", "jjwan", "jjwanj", "jjwanh", "jjwad", "jjwal", "jjwalg", "jjwalm", "jjwalb", "jjwals", "jjwalt", "jjwalp", "jjwalh", "jjwam", "jjwab", "jjwabs", "jjwas", "jjwass", "jjwang", "jjwaj", "jjwac", "jjwak", "jjwat", "jjwap", "jjwah", "jjwae", "jjwaeg", "jjwaegg", "jjwaegs", "jjwaen", "jjwaenj", "jjwaenh", "jjwaed", "jjwael", "jjwaelg", "jjwaelm", "jjwaelb"];
  }
});

// node_modules/unidecode/data/xcb.js
var require_xcb = __commonJS({
  "node_modules/unidecode/data/xcb.js"(exports2, module2) {
    module2.exports = ["jjwaels", "jjwaelt", "jjwaelp", "jjwaelh", "jjwaem", "jjwaeb", "jjwaebs", "jjwaes", "jjwaess", "jjwaeng", "jjwaej", "jjwaec", "jjwaek", "jjwaet", "jjwaep", "jjwaeh", "jjoe", "jjoeg", "jjoegg", "jjoegs", "jjoen", "jjoenj", "jjoenh", "jjoed", "jjoel", "jjoelg", "jjoelm", "jjoelb", "jjoels", "jjoelt", "jjoelp", "jjoelh", "jjoem", "jjoeb", "jjoebs", "jjoes", "jjoess", "jjoeng", "jjoej", "jjoec", "jjoek", "jjoet", "jjoep", "jjoeh", "jjyo", "jjyog", "jjyogg", "jjyogs", "jjyon", "jjyonj", "jjyonh", "jjyod", "jjyol", "jjyolg", "jjyolm", "jjyolb", "jjyols", "jjyolt", "jjyolp", "jjyolh", "jjyom", "jjyob", "jjyobs", "jjyos", "jjyoss", "jjyong", "jjyoj", "jjyoc", "jjyok", "jjyot", "jjyop", "jjyoh", "jju", "jjug", "jjugg", "jjugs", "jjun", "jjunj", "jjunh", "jjud", "jjul", "jjulg", "jjulm", "jjulb", "jjuls", "jjult", "jjulp", "jjulh", "jjum", "jjub", "jjubs", "jjus", "jjuss", "jjung", "jjuj", "jjuc", "jjuk", "jjut", "jjup", "jjuh", "jjweo", "jjweog", "jjweogg", "jjweogs", "jjweon", "jjweonj", "jjweonh", "jjweod", "jjweol", "jjweolg", "jjweolm", "jjweolb", "jjweols", "jjweolt", "jjweolp", "jjweolh", "jjweom", "jjweob", "jjweobs", "jjweos", "jjweoss", "jjweong", "jjweoj", "jjweoc", "jjweok", "jjweot", "jjweop", "jjweoh", "jjwe", "jjweg", "jjwegg", "jjwegs", "jjwen", "jjwenj", "jjwenh", "jjwed", "jjwel", "jjwelg", "jjwelm", "jjwelb", "jjwels", "jjwelt", "jjwelp", "jjwelh", "jjwem", "jjweb", "jjwebs", "jjwes", "jjwess", "jjweng", "jjwej", "jjwec", "jjwek", "jjwet", "jjwep", "jjweh", "jjwi", "jjwig", "jjwigg", "jjwigs", "jjwin", "jjwinj", "jjwinh", "jjwid", "jjwil", "jjwilg", "jjwilm", "jjwilb", "jjwils", "jjwilt", "jjwilp", "jjwilh", "jjwim", "jjwib", "jjwibs", "jjwis", "jjwiss", "jjwing", "jjwij", "jjwic", "jjwik", "jjwit", "jjwip", "jjwih", "jjyu", "jjyug", "jjyugg", "jjyugs", "jjyun", "jjyunj", "jjyunh", "jjyud", "jjyul", "jjyulg", "jjyulm", "jjyulb", "jjyuls", "jjyult", "jjyulp", "jjyulh", "jjyum", "jjyub", "jjyubs", "jjyus", "jjyuss", "jjyung", "jjyuj", "jjyuc", "jjyuk", "jjyut", "jjyup", "jjyuh", "jjeu", "jjeug", "jjeugg", "jjeugs", "jjeun", "jjeunj", "jjeunh", "jjeud", "jjeul", "jjeulg", "jjeulm", "jjeulb", "jjeuls", "jjeult", "jjeulp", "jjeulh", "jjeum", "jjeub", "jjeubs", "jjeus", "jjeuss", "jjeung", "jjeuj", "jjeuc", "jjeuk", "jjeut", "jjeup", "jjeuh", "jjyi", "jjyig", "jjyigg", "jjyigs", "jjyin", "jjyinj", "jjyinh", "jjyid", "jjyil", "jjyilg", "jjyilm", "jjyilb", "jjyils", "jjyilt", "jjyilp", "jjyilh"];
  }
});

// node_modules/unidecode/data/xcc.js
var require_xcc = __commonJS({
  "node_modules/unidecode/data/xcc.js"(exports2, module2) {
    module2.exports = ["jjyim", "jjyib", "jjyibs", "jjyis", "jjyiss", "jjying", "jjyij", "jjyic", "jjyik", "jjyit", "jjyip", "jjyih", "jji", "jjig", "jjigg", "jjigs", "jjin", "jjinj", "jjinh", "jjid", "jjil", "jjilg", "jjilm", "jjilb", "jjils", "jjilt", "jjilp", "jjilh", "jjim", "jjib", "jjibs", "jjis", "jjiss", "jjing", "jjij", "jjic", "jjik", "jjit", "jjip", "jjih", "ca", "cag", "cagg", "cags", "can", "canj", "canh", "cad", "cal", "calg", "calm", "calb", "cals", "calt", "calp", "calh", "cam", "cab", "cabs", "cas", "cass", "cang", "caj", "cac", "cak", "cat", "cap", "cah", "cae", "caeg", "caegg", "caegs", "caen", "caenj", "caenh", "caed", "cael", "caelg", "caelm", "caelb", "caels", "caelt", "caelp", "caelh", "caem", "caeb", "caebs", "caes", "caess", "caeng", "caej", "caec", "caek", "caet", "caep", "caeh", "cya", "cyag", "cyagg", "cyags", "cyan", "cyanj", "cyanh", "cyad", "cyal", "cyalg", "cyalm", "cyalb", "cyals", "cyalt", "cyalp", "cyalh", "cyam", "cyab", "cyabs", "cyas", "cyass", "cyang", "cyaj", "cyac", "cyak", "cyat", "cyap", "cyah", "cyae", "cyaeg", "cyaegg", "cyaegs", "cyaen", "cyaenj", "cyaenh", "cyaed", "cyael", "cyaelg", "cyaelm", "cyaelb", "cyaels", "cyaelt", "cyaelp", "cyaelh", "cyaem", "cyaeb", "cyaebs", "cyaes", "cyaess", "cyaeng", "cyaej", "cyaec", "cyaek", "cyaet", "cyaep", "cyaeh", "ceo", "ceog", "ceogg", "ceogs", "ceon", "ceonj", "ceonh", "ceod", "ceol", "ceolg", "ceolm", "ceolb", "ceols", "ceolt", "ceolp", "ceolh", "ceom", "ceob", "ceobs", "ceos", "ceoss", "ceong", "ceoj", "ceoc", "ceok", "ceot", "ceop", "ceoh", "ce", "ceg", "cegg", "cegs", "cen", "cenj", "cenh", "ced", "cel", "celg", "celm", "celb", "cels", "celt", "celp", "celh", "cem", "ceb", "cebs", "ces", "cess", "ceng", "cej", "cec", "cek", "cet", "cep", "ceh", "cyeo", "cyeog", "cyeogg", "cyeogs", "cyeon", "cyeonj", "cyeonh", "cyeod", "cyeol", "cyeolg", "cyeolm", "cyeolb", "cyeols", "cyeolt", "cyeolp", "cyeolh", "cyeom", "cyeob", "cyeobs", "cyeos", "cyeoss", "cyeong", "cyeoj", "cyeoc", "cyeok", "cyeot", "cyeop", "cyeoh", "cye", "cyeg", "cyegg", "cyegs", "cyen", "cyenj", "cyenh", "cyed", "cyel", "cyelg", "cyelm", "cyelb", "cyels", "cyelt", "cyelp", "cyelh", "cyem", "cyeb", "cyebs", "cyes"];
  }
});

// node_modules/unidecode/data/xcd.js
var require_xcd = __commonJS({
  "node_modules/unidecode/data/xcd.js"(exports2, module2) {
    module2.exports = ["cyess", "cyeng", "cyej", "cyec", "cyek", "cyet", "cyep", "cyeh", "co", "cog", "cogg", "cogs", "con", "conj", "conh", "cod", "col", "colg", "colm", "colb", "cols", "colt", "colp", "colh", "com", "cob", "cobs", "cos", "coss", "cong", "coj", "coc", "cok", "cot", "cop", "coh", "cwa", "cwag", "cwagg", "cwags", "cwan", "cwanj", "cwanh", "cwad", "cwal", "cwalg", "cwalm", "cwalb", "cwals", "cwalt", "cwalp", "cwalh", "cwam", "cwab", "cwabs", "cwas", "cwass", "cwang", "cwaj", "cwac", "cwak", "cwat", "cwap", "cwah", "cwae", "cwaeg", "cwaegg", "cwaegs", "cwaen", "cwaenj", "cwaenh", "cwaed", "cwael", "cwaelg", "cwaelm", "cwaelb", "cwaels", "cwaelt", "cwaelp", "cwaelh", "cwaem", "cwaeb", "cwaebs", "cwaes", "cwaess", "cwaeng", "cwaej", "cwaec", "cwaek", "cwaet", "cwaep", "cwaeh", "coe", "coeg", "coegg", "coegs", "coen", "coenj", "coenh", "coed", "coel", "coelg", "coelm", "coelb", "coels", "coelt", "coelp", "coelh", "coem", "coeb", "coebs", "coes", "coess", "coeng", "coej", "coec", "coek", "coet", "coep", "coeh", "cyo", "cyog", "cyogg", "cyogs", "cyon", "cyonj", "cyonh", "cyod", "cyol", "cyolg", "cyolm", "cyolb", "cyols", "cyolt", "cyolp", "cyolh", "cyom", "cyob", "cyobs", "cyos", "cyoss", "cyong", "cyoj", "cyoc", "cyok", "cyot", "cyop", "cyoh", "cu", "cug", "cugg", "cugs", "cun", "cunj", "cunh", "cud", "cul", "culg", "culm", "culb", "culs", "cult", "culp", "culh", "cum", "cub", "cubs", "cus", "cuss", "cung", "cuj", "cuc", "cuk", "cut", "cup", "cuh", "cweo", "cweog", "cweogg", "cweogs", "cweon", "cweonj", "cweonh", "cweod", "cweol", "cweolg", "cweolm", "cweolb", "cweols", "cweolt", "cweolp", "cweolh", "cweom", "cweob", "cweobs", "cweos", "cweoss", "cweong", "cweoj", "cweoc", "cweok", "cweot", "cweop", "cweoh", "cwe", "cweg", "cwegg", "cwegs", "cwen", "cwenj", "cwenh", "cwed", "cwel", "cwelg", "cwelm", "cwelb", "cwels", "cwelt", "cwelp", "cwelh", "cwem", "cweb", "cwebs", "cwes", "cwess", "cweng", "cwej", "cwec", "cwek", "cwet", "cwep", "cweh", "cwi", "cwig", "cwigg", "cwigs", "cwin", "cwinj", "cwinh", "cwid", "cwil", "cwilg", "cwilm", "cwilb", "cwils", "cwilt", "cwilp", "cwilh", "cwim", "cwib", "cwibs", "cwis", "cwiss", "cwing", "cwij", "cwic"];
  }
});

// node_modules/unidecode/data/xce.js
var require_xce = __commonJS({
  "node_modules/unidecode/data/xce.js"(exports2, module2) {
    module2.exports = ["cwik", "cwit", "cwip", "cwih", "cyu", "cyug", "cyugg", "cyugs", "cyun", "cyunj", "cyunh", "cyud", "cyul", "cyulg", "cyulm", "cyulb", "cyuls", "cyult", "cyulp", "cyulh", "cyum", "cyub", "cyubs", "cyus", "cyuss", "cyung", "cyuj", "cyuc", "cyuk", "cyut", "cyup", "cyuh", "ceu", "ceug", "ceugg", "ceugs", "ceun", "ceunj", "ceunh", "ceud", "ceul", "ceulg", "ceulm", "ceulb", "ceuls", "ceult", "ceulp", "ceulh", "ceum", "ceub", "ceubs", "ceus", "ceuss", "ceung", "ceuj", "ceuc", "ceuk", "ceut", "ceup", "ceuh", "cyi", "cyig", "cyigg", "cyigs", "cyin", "cyinj", "cyinh", "cyid", "cyil", "cyilg", "cyilm", "cyilb", "cyils", "cyilt", "cyilp", "cyilh", "cyim", "cyib", "cyibs", "cyis", "cyiss", "cying", "cyij", "cyic", "cyik", "cyit", "cyip", "cyih", "ci", "cig", "cigg", "cigs", "cin", "cinj", "cinh", "cid", "cil", "cilg", "cilm", "cilb", "cils", "cilt", "cilp", "cilh", "cim", "cib", "cibs", "cis", "ciss", "cing", "cij", "cic", "cik", "cit", "cip", "cih", "ka", "kag", "kagg", "kags", "kan", "kanj", "kanh", "kad", "kal", "kalg", "kalm", "kalb", "kals", "kalt", "kalp", "kalh", "kam", "kab", "kabs", "kas", "kass", "kang", "kaj", "kac", "kak", "kat", "kap", "kah", "kae", "kaeg", "kaegg", "kaegs", "kaen", "kaenj", "kaenh", "kaed", "kael", "kaelg", "kaelm", "kaelb", "kaels", "kaelt", "kaelp", "kaelh", "kaem", "kaeb", "kaebs", "kaes", "kaess", "kaeng", "kaej", "kaec", "kaek", "kaet", "kaep", "kaeh", "kya", "kyag", "kyagg", "kyags", "kyan", "kyanj", "kyanh", "kyad", "kyal", "kyalg", "kyalm", "kyalb", "kyals", "kyalt", "kyalp", "kyalh", "kyam", "kyab", "kyabs", "kyas", "kyass", "kyang", "kyaj", "kyac", "kyak", "kyat", "kyap", "kyah", "kyae", "kyaeg", "kyaegg", "kyaegs", "kyaen", "kyaenj", "kyaenh", "kyaed", "kyael", "kyaelg", "kyaelm", "kyaelb", "kyaels", "kyaelt", "kyaelp", "kyaelh", "kyaem", "kyaeb", "kyaebs", "kyaes", "kyaess", "kyaeng", "kyaej", "kyaec", "kyaek", "kyaet", "kyaep", "kyaeh", "keo", "keog", "keogg", "keogs", "keon", "keonj", "keonh", "keod", "keol", "keolg", "keolm", "keolb", "keols", "keolt", "keolp", "keolh", "keom", "keob", "keobs", "keos", "keoss", "keong", "keoj", "keoc", "keok", "keot", "keop", "keoh"];
  }
});

// node_modules/unidecode/data/xcf.js
var require_xcf = __commonJS({
  "node_modules/unidecode/data/xcf.js"(exports2, module2) {
    module2.exports = ["ke", "keg", "kegg", "kegs", "ken", "kenj", "kenh", "ked", "kel", "kelg", "kelm", "kelb", "kels", "kelt", "kelp", "kelh", "kem", "keb", "kebs", "kes", "kess", "keng", "kej", "kec", "kek", "ket", "kep", "keh", "kyeo", "kyeog", "kyeogg", "kyeogs", "kyeon", "kyeonj", "kyeonh", "kyeod", "kyeol", "kyeolg", "kyeolm", "kyeolb", "kyeols", "kyeolt", "kyeolp", "kyeolh", "kyeom", "kyeob", "kyeobs", "kyeos", "kyeoss", "kyeong", "kyeoj", "kyeoc", "kyeok", "kyeot", "kyeop", "kyeoh", "kye", "kyeg", "kyegg", "kyegs", "kyen", "kyenj", "kyenh", "kyed", "kyel", "kyelg", "kyelm", "kyelb", "kyels", "kyelt", "kyelp", "kyelh", "kyem", "kyeb", "kyebs", "kyes", "kyess", "kyeng", "kyej", "kyec", "kyek", "kyet", "kyep", "kyeh", "ko", "kog", "kogg", "kogs", "kon", "konj", "konh", "kod", "kol", "kolg", "kolm", "kolb", "kols", "kolt", "kolp", "kolh", "kom", "kob", "kobs", "kos", "koss", "kong", "koj", "koc", "kok", "kot", "kop", "koh", "kwa", "kwag", "kwagg", "kwags", "kwan", "kwanj", "kwanh", "kwad", "kwal", "kwalg", "kwalm", "kwalb", "kwals", "kwalt", "kwalp", "kwalh", "kwam", "kwab", "kwabs", "kwas", "kwass", "kwang", "kwaj", "kwac", "kwak", "kwat", "kwap", "kwah", "kwae", "kwaeg", "kwaegg", "kwaegs", "kwaen", "kwaenj", "kwaenh", "kwaed", "kwael", "kwaelg", "kwaelm", "kwaelb", "kwaels", "kwaelt", "kwaelp", "kwaelh", "kwaem", "kwaeb", "kwaebs", "kwaes", "kwaess", "kwaeng", "kwaej", "kwaec", "kwaek", "kwaet", "kwaep", "kwaeh", "koe", "koeg", "koegg", "koegs", "koen", "koenj", "koenh", "koed", "koel", "koelg", "koelm", "koelb", "koels", "koelt", "koelp", "koelh", "koem", "koeb", "koebs", "koes", "koess", "koeng", "koej", "koec", "koek", "koet", "koep", "koeh", "kyo", "kyog", "kyogg", "kyogs", "kyon", "kyonj", "kyonh", "kyod", "kyol", "kyolg", "kyolm", "kyolb", "kyols", "kyolt", "kyolp", "kyolh", "kyom", "kyob", "kyobs", "kyos", "kyoss", "kyong", "kyoj", "kyoc", "kyok", "kyot", "kyop", "kyoh", "ku", "kug", "kugg", "kugs", "kun", "kunj", "kunh", "kud", "kul", "kulg", "kulm", "kulb", "kuls", "kult", "kulp", "kulh", "kum", "kub", "kubs", "kus", "kuss", "kung", "kuj", "kuc", "kuk", "kut", "kup", "kuh", "kweo", "kweog", "kweogg", "kweogs"];
  }
});

// node_modules/unidecode/data/xd0.js
var require_xd0 = __commonJS({
  "node_modules/unidecode/data/xd0.js"(exports2, module2) {
    module2.exports = ["kweon", "kweonj", "kweonh", "kweod", "kweol", "kweolg", "kweolm", "kweolb", "kweols", "kweolt", "kweolp", "kweolh", "kweom", "kweob", "kweobs", "kweos", "kweoss", "kweong", "kweoj", "kweoc", "kweok", "kweot", "kweop", "kweoh", "kwe", "kweg", "kwegg", "kwegs", "kwen", "kwenj", "kwenh", "kwed", "kwel", "kwelg", "kwelm", "kwelb", "kwels", "kwelt", "kwelp", "kwelh", "kwem", "kweb", "kwebs", "kwes", "kwess", "kweng", "kwej", "kwec", "kwek", "kwet", "kwep", "kweh", "kwi", "kwig", "kwigg", "kwigs", "kwin", "kwinj", "kwinh", "kwid", "kwil", "kwilg", "kwilm", "kwilb", "kwils", "kwilt", "kwilp", "kwilh", "kwim", "kwib", "kwibs", "kwis", "kwiss", "kwing", "kwij", "kwic", "kwik", "kwit", "kwip", "kwih", "kyu", "kyug", "kyugg", "kyugs", "kyun", "kyunj", "kyunh", "kyud", "kyul", "kyulg", "kyulm", "kyulb", "kyuls", "kyult", "kyulp", "kyulh", "kyum", "kyub", "kyubs", "kyus", "kyuss", "kyung", "kyuj", "kyuc", "kyuk", "kyut", "kyup", "kyuh", "keu", "keug", "keugg", "keugs", "keun", "keunj", "keunh", "keud", "keul", "keulg", "keulm", "keulb", "keuls", "keult", "keulp", "keulh", "keum", "keub", "keubs", "keus", "keuss", "keung", "keuj", "keuc", "keuk", "keut", "keup", "keuh", "kyi", "kyig", "kyigg", "kyigs", "kyin", "kyinj", "kyinh", "kyid", "kyil", "kyilg", "kyilm", "kyilb", "kyils", "kyilt", "kyilp", "kyilh", "kyim", "kyib", "kyibs", "kyis", "kyiss", "kying", "kyij", "kyic", "kyik", "kyit", "kyip", "kyih", "ki", "kig", "kigg", "kigs", "kin", "kinj", "kinh", "kid", "kil", "kilg", "kilm", "kilb", "kils", "kilt", "kilp", "kilh", "kim", "kib", "kibs", "kis", "kiss", "king", "kij", "kic", "kik", "kit", "kip", "kih", "ta", "tag", "tagg", "tags", "tan", "tanj", "tanh", "tad", "tal", "talg", "talm", "talb", "tals", "talt", "talp", "talh", "tam", "tab", "tabs", "tas", "tass", "tang", "taj", "tac", "tak", "tat", "tap", "tah", "tae", "taeg", "taegg", "taegs", "taen", "taenj", "taenh", "taed", "tael", "taelg", "taelm", "taelb", "taels", "taelt", "taelp", "taelh", "taem", "taeb", "taebs", "taes", "taess", "taeng", "taej", "taec", "taek", "taet", "taep", "taeh", "tya", "tyag", "tyagg", "tyags", "tyan", "tyanj", "tyanh", "tyad"];
  }
});

// node_modules/unidecode/data/xd1.js
var require_xd1 = __commonJS({
  "node_modules/unidecode/data/xd1.js"(exports2, module2) {
    module2.exports = ["tyal", "tyalg", "tyalm", "tyalb", "tyals", "tyalt", "tyalp", "tyalh", "tyam", "tyab", "tyabs", "tyas", "tyass", "tyang", "tyaj", "tyac", "tyak", "tyat", "tyap", "tyah", "tyae", "tyaeg", "tyaegg", "tyaegs", "tyaen", "tyaenj", "tyaenh", "tyaed", "tyael", "tyaelg", "tyaelm", "tyaelb", "tyaels", "tyaelt", "tyaelp", "tyaelh", "tyaem", "tyaeb", "tyaebs", "tyaes", "tyaess", "tyaeng", "tyaej", "tyaec", "tyaek", "tyaet", "tyaep", "tyaeh", "teo", "teog", "teogg", "teogs", "teon", "teonj", "teonh", "teod", "teol", "teolg", "teolm", "teolb", "teols", "teolt", "teolp", "teolh", "teom", "teob", "teobs", "teos", "teoss", "teong", "teoj", "teoc", "teok", "teot", "teop", "teoh", "te", "teg", "tegg", "tegs", "ten", "tenj", "tenh", "ted", "tel", "telg", "telm", "telb", "tels", "telt", "telp", "telh", "tem", "teb", "tebs", "tes", "tess", "teng", "tej", "tec", "tek", "tet", "tep", "teh", "tyeo", "tyeog", "tyeogg", "tyeogs", "tyeon", "tyeonj", "tyeonh", "tyeod", "tyeol", "tyeolg", "tyeolm", "tyeolb", "tyeols", "tyeolt", "tyeolp", "tyeolh", "tyeom", "tyeob", "tyeobs", "tyeos", "tyeoss", "tyeong", "tyeoj", "tyeoc", "tyeok", "tyeot", "tyeop", "tyeoh", "tye", "tyeg", "tyegg", "tyegs", "tyen", "tyenj", "tyenh", "tyed", "tyel", "tyelg", "tyelm", "tyelb", "tyels", "tyelt", "tyelp", "tyelh", "tyem", "tyeb", "tyebs", "tyes", "tyess", "tyeng", "tyej", "tyec", "tyek", "tyet", "tyep", "tyeh", "to", "tog", "togg", "togs", "ton", "tonj", "tonh", "tod", "tol", "tolg", "tolm", "tolb", "tols", "tolt", "tolp", "tolh", "tom", "tob", "tobs", "tos", "toss", "tong", "toj", "toc", "tok", "tot", "top", "toh", "twa", "twag", "twagg", "twags", "twan", "twanj", "twanh", "twad", "twal", "twalg", "twalm", "twalb", "twals", "twalt", "twalp", "twalh", "twam", "twab", "twabs", "twas", "twass", "twang", "twaj", "twac", "twak", "twat", "twap", "twah", "twae", "twaeg", "twaegg", "twaegs", "twaen", "twaenj", "twaenh", "twaed", "twael", "twaelg", "twaelm", "twaelb", "twaels", "twaelt", "twaelp", "twaelh", "twaem", "twaeb", "twaebs", "twaes", "twaess", "twaeng", "twaej", "twaec", "twaek", "twaet", "twaep", "twaeh", "toe", "toeg", "toegg", "toegs", "toen", "toenj", "toenh", "toed", "toel", "toelg", "toelm", "toelb"];
  }
});

// node_modules/unidecode/data/xd2.js
var require_xd2 = __commonJS({
  "node_modules/unidecode/data/xd2.js"(exports2, module2) {
    module2.exports = ["toels", "toelt", "toelp", "toelh", "toem", "toeb", "toebs", "toes", "toess", "toeng", "toej", "toec", "toek", "toet", "toep", "toeh", "tyo", "tyog", "tyogg", "tyogs", "tyon", "tyonj", "tyonh", "tyod", "tyol", "tyolg", "tyolm", "tyolb", "tyols", "tyolt", "tyolp", "tyolh", "tyom", "tyob", "tyobs", "tyos", "tyoss", "tyong", "tyoj", "tyoc", "tyok", "tyot", "tyop", "tyoh", "tu", "tug", "tugg", "tugs", "tun", "tunj", "tunh", "tud", "tul", "tulg", "tulm", "tulb", "tuls", "tult", "tulp", "tulh", "tum", "tub", "tubs", "tus", "tuss", "tung", "tuj", "tuc", "tuk", "tut", "tup", "tuh", "tweo", "tweog", "tweogg", "tweogs", "tweon", "tweonj", "tweonh", "tweod", "tweol", "tweolg", "tweolm", "tweolb", "tweols", "tweolt", "tweolp", "tweolh", "tweom", "tweob", "tweobs", "tweos", "tweoss", "tweong", "tweoj", "tweoc", "tweok", "tweot", "tweop", "tweoh", "twe", "tweg", "twegg", "twegs", "twen", "twenj", "twenh", "twed", "twel", "twelg", "twelm", "twelb", "twels", "twelt", "twelp", "twelh", "twem", "tweb", "twebs", "twes", "twess", "tweng", "twej", "twec", "twek", "twet", "twep", "tweh", "twi", "twig", "twigg", "twigs", "twin", "twinj", "twinh", "twid", "twil", "twilg", "twilm", "twilb", "twils", "twilt", "twilp", "twilh", "twim", "twib", "twibs", "twis", "twiss", "twing", "twij", "twic", "twik", "twit", "twip", "twih", "tyu", "tyug", "tyugg", "tyugs", "tyun", "tyunj", "tyunh", "tyud", "tyul", "tyulg", "tyulm", "tyulb", "tyuls", "tyult", "tyulp", "tyulh", "tyum", "tyub", "tyubs", "tyus", "tyuss", "tyung", "tyuj", "tyuc", "tyuk", "tyut", "tyup", "tyuh", "teu", "teug", "teugg", "teugs", "teun", "teunj", "teunh", "teud", "teul", "teulg", "teulm", "teulb", "teuls", "teult", "teulp", "teulh", "teum", "teub", "teubs", "teus", "teuss", "teung", "teuj", "teuc", "teuk", "teut", "teup", "teuh", "tyi", "tyig", "tyigg", "tyigs", "tyin", "tyinj", "tyinh", "tyid", "tyil", "tyilg", "tyilm", "tyilb", "tyils", "tyilt", "tyilp", "tyilh", "tyim", "tyib", "tyibs", "tyis", "tyiss", "tying", "tyij", "tyic", "tyik", "tyit", "tyip", "tyih", "ti", "tig", "tigg", "tigs", "tin", "tinj", "tinh", "tid", "til", "tilg", "tilm", "tilb", "tils", "tilt", "tilp", "tilh"];
  }
});

// node_modules/unidecode/data/xd3.js
var require_xd3 = __commonJS({
  "node_modules/unidecode/data/xd3.js"(exports2, module2) {
    module2.exports = ["tim", "tib", "tibs", "tis", "tiss", "ting", "tij", "tic", "tik", "tit", "tip", "tih", "pa", "pag", "pagg", "pags", "pan", "panj", "panh", "pad", "pal", "palg", "palm", "palb", "pals", "palt", "palp", "palh", "pam", "pab", "pabs", "pas", "pass", "pang", "paj", "pac", "pak", "pat", "pap", "pah", "pae", "paeg", "paegg", "paegs", "paen", "paenj", "paenh", "paed", "pael", "paelg", "paelm", "paelb", "paels", "paelt", "paelp", "paelh", "paem", "paeb", "paebs", "paes", "paess", "paeng", "paej", "paec", "paek", "paet", "paep", "paeh", "pya", "pyag", "pyagg", "pyags", "pyan", "pyanj", "pyanh", "pyad", "pyal", "pyalg", "pyalm", "pyalb", "pyals", "pyalt", "pyalp", "pyalh", "pyam", "pyab", "pyabs", "pyas", "pyass", "pyang", "pyaj", "pyac", "pyak", "pyat", "pyap", "pyah", "pyae", "pyaeg", "pyaegg", "pyaegs", "pyaen", "pyaenj", "pyaenh", "pyaed", "pyael", "pyaelg", "pyaelm", "pyaelb", "pyaels", "pyaelt", "pyaelp", "pyaelh", "pyaem", "pyaeb", "pyaebs", "pyaes", "pyaess", "pyaeng", "pyaej", "pyaec", "pyaek", "pyaet", "pyaep", "pyaeh", "peo", "peog", "peogg", "peogs", "peon", "peonj", "peonh", "peod", "peol", "peolg", "peolm", "peolb", "peols", "peolt", "peolp", "peolh", "peom", "peob", "peobs", "peos", "peoss", "peong", "peoj", "peoc", "peok", "peot", "peop", "peoh", "pe", "peg", "pegg", "pegs", "pen", "penj", "penh", "ped", "pel", "pelg", "pelm", "pelb", "pels", "pelt", "pelp", "pelh", "pem", "peb", "pebs", "pes", "pess", "peng", "pej", "pec", "pek", "pet", "pep", "peh", "pyeo", "pyeog", "pyeogg", "pyeogs", "pyeon", "pyeonj", "pyeonh", "pyeod", "pyeol", "pyeolg", "pyeolm", "pyeolb", "pyeols", "pyeolt", "pyeolp", "pyeolh", "pyeom", "pyeob", "pyeobs", "pyeos", "pyeoss", "pyeong", "pyeoj", "pyeoc", "pyeok", "pyeot", "pyeop", "pyeoh", "pye", "pyeg", "pyegg", "pyegs", "pyen", "pyenj", "pyenh", "pyed", "pyel", "pyelg", "pyelm", "pyelb", "pyels", "pyelt", "pyelp", "pyelh", "pyem", "pyeb", "pyebs", "pyes", "pyess", "pyeng", "pyej", "pyec", "pyek", "pyet", "pyep", "pyeh", "po", "pog", "pogg", "pogs", "pon", "ponj", "ponh", "pod", "pol", "polg", "polm", "polb", "pols", "polt", "polp", "polh", "pom", "pob", "pobs", "pos"];
  }
});

// node_modules/unidecode/data/xd4.js
var require_xd4 = __commonJS({
  "node_modules/unidecode/data/xd4.js"(exports2, module2) {
    module2.exports = ["poss", "pong", "poj", "poc", "pok", "pot", "pop", "poh", "pwa", "pwag", "pwagg", "pwags", "pwan", "pwanj", "pwanh", "pwad", "pwal", "pwalg", "pwalm", "pwalb", "pwals", "pwalt", "pwalp", "pwalh", "pwam", "pwab", "pwabs", "pwas", "pwass", "pwang", "pwaj", "pwac", "pwak", "pwat", "pwap", "pwah", "pwae", "pwaeg", "pwaegg", "pwaegs", "pwaen", "pwaenj", "pwaenh", "pwaed", "pwael", "pwaelg", "pwaelm", "pwaelb", "pwaels", "pwaelt", "pwaelp", "pwaelh", "pwaem", "pwaeb", "pwaebs", "pwaes", "pwaess", "pwaeng", "pwaej", "pwaec", "pwaek", "pwaet", "pwaep", "pwaeh", "poe", "poeg", "poegg", "poegs", "poen", "poenj", "poenh", "poed", "poel", "poelg", "poelm", "poelb", "poels", "poelt", "poelp", "poelh", "poem", "poeb", "poebs", "poes", "poess", "poeng", "poej", "poec", "poek", "poet", "poep", "poeh", "pyo", "pyog", "pyogg", "pyogs", "pyon", "pyonj", "pyonh", "pyod", "pyol", "pyolg", "pyolm", "pyolb", "pyols", "pyolt", "pyolp", "pyolh", "pyom", "pyob", "pyobs", "pyos", "pyoss", "pyong", "pyoj", "pyoc", "pyok", "pyot", "pyop", "pyoh", "pu", "pug", "pugg", "pugs", "pun", "punj", "punh", "pud", "pul", "pulg", "pulm", "pulb", "puls", "pult", "pulp", "pulh", "pum", "pub", "pubs", "pus", "puss", "pung", "puj", "puc", "puk", "put", "pup", "puh", "pweo", "pweog", "pweogg", "pweogs", "pweon", "pweonj", "pweonh", "pweod", "pweol", "pweolg", "pweolm", "pweolb", "pweols", "pweolt", "pweolp", "pweolh", "pweom", "pweob", "pweobs", "pweos", "pweoss", "pweong", "pweoj", "pweoc", "pweok", "pweot", "pweop", "pweoh", "pwe", "pweg", "pwegg", "pwegs", "pwen", "pwenj", "pwenh", "pwed", "pwel", "pwelg", "pwelm", "pwelb", "pwels", "pwelt", "pwelp", "pwelh", "pwem", "pweb", "pwebs", "pwes", "pwess", "pweng", "pwej", "pwec", "pwek", "pwet", "pwep", "pweh", "pwi", "pwig", "pwigg", "pwigs", "pwin", "pwinj", "pwinh", "pwid", "pwil", "pwilg", "pwilm", "pwilb", "pwils", "pwilt", "pwilp", "pwilh", "pwim", "pwib", "pwibs", "pwis", "pwiss", "pwing", "pwij", "pwic", "pwik", "pwit", "pwip", "pwih", "pyu", "pyug", "pyugg", "pyugs", "pyun", "pyunj", "pyunh", "pyud", "pyul", "pyulg", "pyulm", "pyulb", "pyuls", "pyult", "pyulp", "pyulh", "pyum", "pyub", "pyubs", "pyus", "pyuss", "pyung", "pyuj", "pyuc"];
  }
});

// node_modules/unidecode/data/xd5.js
var require_xd5 = __commonJS({
  "node_modules/unidecode/data/xd5.js"(exports2, module2) {
    module2.exports = ["pyuk", "pyut", "pyup", "pyuh", "peu", "peug", "peugg", "peugs", "peun", "peunj", "peunh", "peud", "peul", "peulg", "peulm", "peulb", "peuls", "peult", "peulp", "peulh", "peum", "peub", "peubs", "peus", "peuss", "peung", "peuj", "peuc", "peuk", "peut", "peup", "peuh", "pyi", "pyig", "pyigg", "pyigs", "pyin", "pyinj", "pyinh", "pyid", "pyil", "pyilg", "pyilm", "pyilb", "pyils", "pyilt", "pyilp", "pyilh", "pyim", "pyib", "pyibs", "pyis", "pyiss", "pying", "pyij", "pyic", "pyik", "pyit", "pyip", "pyih", "pi", "pig", "pigg", "pigs", "pin", "pinj", "pinh", "pid", "pil", "pilg", "pilm", "pilb", "pils", "pilt", "pilp", "pilh", "pim", "pib", "pibs", "pis", "piss", "ping", "pij", "pic", "pik", "pit", "pip", "pih", "ha", "hag", "hagg", "hags", "han", "hanj", "hanh", "had", "hal", "halg", "halm", "halb", "hals", "halt", "halp", "halh", "ham", "hab", "habs", "has", "hass", "hang", "haj", "hac", "hak", "hat", "hap", "hah", "hae", "haeg", "haegg", "haegs", "haen", "haenj", "haenh", "haed", "hael", "haelg", "haelm", "haelb", "haels", "haelt", "haelp", "haelh", "haem", "haeb", "haebs", "haes", "haess", "haeng", "haej", "haec", "haek", "haet", "haep", "haeh", "hya", "hyag", "hyagg", "hyags", "hyan", "hyanj", "hyanh", "hyad", "hyal", "hyalg", "hyalm", "hyalb", "hyals", "hyalt", "hyalp", "hyalh", "hyam", "hyab", "hyabs", "hyas", "hyass", "hyang", "hyaj", "hyac", "hyak", "hyat", "hyap", "hyah", "hyae", "hyaeg", "hyaegg", "hyaegs", "hyaen", "hyaenj", "hyaenh", "hyaed", "hyael", "hyaelg", "hyaelm", "hyaelb", "hyaels", "hyaelt", "hyaelp", "hyaelh", "hyaem", "hyaeb", "hyaebs", "hyaes", "hyaess", "hyaeng", "hyaej", "hyaec", "hyaek", "hyaet", "hyaep", "hyaeh", "heo", "heog", "heogg", "heogs", "heon", "heonj", "heonh", "heod", "heol", "heolg", "heolm", "heolb", "heols", "heolt", "heolp", "heolh", "heom", "heob", "heobs", "heos", "heoss", "heong", "heoj", "heoc", "heok", "heot", "heop", "heoh", "he", "heg", "hegg", "hegs", "hen", "henj", "henh", "hed", "hel", "helg", "helm", "helb", "hels", "helt", "help", "helh", "hem", "heb", "hebs", "hes", "hess", "heng", "hej", "hec", "hek", "het", "hep", "heh"];
  }
});

// node_modules/unidecode/data/xd6.js
var require_xd6 = __commonJS({
  "node_modules/unidecode/data/xd6.js"(exports2, module2) {
    module2.exports = ["hyeo", "hyeog", "hyeogg", "hyeogs", "hyeon", "hyeonj", "hyeonh", "hyeod", "hyeol", "hyeolg", "hyeolm", "hyeolb", "hyeols", "hyeolt", "hyeolp", "hyeolh", "hyeom", "hyeob", "hyeobs", "hyeos", "hyeoss", "hyeong", "hyeoj", "hyeoc", "hyeok", "hyeot", "hyeop", "hyeoh", "hye", "hyeg", "hyegg", "hyegs", "hyen", "hyenj", "hyenh", "hyed", "hyel", "hyelg", "hyelm", "hyelb", "hyels", "hyelt", "hyelp", "hyelh", "hyem", "hyeb", "hyebs", "hyes", "hyess", "hyeng", "hyej", "hyec", "hyek", "hyet", "hyep", "hyeh", "ho", "hog", "hogg", "hogs", "hon", "honj", "honh", "hod", "hol", "holg", "holm", "holb", "hols", "holt", "holp", "holh", "hom", "hob", "hobs", "hos", "hoss", "hong", "hoj", "hoc", "hok", "hot", "hop", "hoh", "hwa", "hwag", "hwagg", "hwags", "hwan", "hwanj", "hwanh", "hwad", "hwal", "hwalg", "hwalm", "hwalb", "hwals", "hwalt", "hwalp", "hwalh", "hwam", "hwab", "hwabs", "hwas", "hwass", "hwang", "hwaj", "hwac", "hwak", "hwat", "hwap", "hwah", "hwae", "hwaeg", "hwaegg", "hwaegs", "hwaen", "hwaenj", "hwaenh", "hwaed", "hwael", "hwaelg", "hwaelm", "hwaelb", "hwaels", "hwaelt", "hwaelp", "hwaelh", "hwaem", "hwaeb", "hwaebs", "hwaes", "hwaess", "hwaeng", "hwaej", "hwaec", "hwaek", "hwaet", "hwaep", "hwaeh", "hoe", "hoeg", "hoegg", "hoegs", "hoen", "hoenj", "hoenh", "hoed", "hoel", "hoelg", "hoelm", "hoelb", "hoels", "hoelt", "hoelp", "hoelh", "hoem", "hoeb", "hoebs", "hoes", "hoess", "hoeng", "hoej", "hoec", "hoek", "hoet", "hoep", "hoeh", "hyo", "hyog", "hyogg", "hyogs", "hyon", "hyonj", "hyonh", "hyod", "hyol", "hyolg", "hyolm", "hyolb", "hyols", "hyolt", "hyolp", "hyolh", "hyom", "hyob", "hyobs", "hyos", "hyoss", "hyong", "hyoj", "hyoc", "hyok", "hyot", "hyop", "hyoh", "hu", "hug", "hugg", "hugs", "hun", "hunj", "hunh", "hud", "hul", "hulg", "hulm", "hulb", "huls", "hult", "hulp", "hulh", "hum", "hub", "hubs", "hus", "huss", "hung", "huj", "huc", "huk", "hut", "hup", "huh", "hweo", "hweog", "hweogg", "hweogs", "hweon", "hweonj", "hweonh", "hweod", "hweol", "hweolg", "hweolm", "hweolb", "hweols", "hweolt", "hweolp", "hweolh", "hweom", "hweob", "hweobs", "hweos", "hweoss", "hweong", "hweoj", "hweoc", "hweok", "hweot", "hweop", "hweoh", "hwe", "hweg", "hwegg", "hwegs"];
  }
});

// node_modules/unidecode/data/xd7.js
var require_xd7 = __commonJS({
  "node_modules/unidecode/data/xd7.js"(exports2, module2) {
    module2.exports = ["hwen", "hwenj", "hwenh", "hwed", "hwel", "hwelg", "hwelm", "hwelb", "hwels", "hwelt", "hwelp", "hwelh", "hwem", "hweb", "hwebs", "hwes", "hwess", "hweng", "hwej", "hwec", "hwek", "hwet", "hwep", "hweh", "hwi", "hwig", "hwigg", "hwigs", "hwin", "hwinj", "hwinh", "hwid", "hwil", "hwilg", "hwilm", "hwilb", "hwils", "hwilt", "hwilp", "hwilh", "hwim", "hwib", "hwibs", "hwis", "hwiss", "hwing", "hwij", "hwic", "hwik", "hwit", "hwip", "hwih", "hyu", "hyug", "hyugg", "hyugs", "hyun", "hyunj", "hyunh", "hyud", "hyul", "hyulg", "hyulm", "hyulb", "hyuls", "hyult", "hyulp", "hyulh", "hyum", "hyub", "hyubs", "hyus", "hyuss", "hyung", "hyuj", "hyuc", "hyuk", "hyut", "hyup", "hyuh", "heu", "heug", "heugg", "heugs", "heun", "heunj", "heunh", "heud", "heul", "heulg", "heulm", "heulb", "heuls", "heult", "heulp", "heulh", "heum", "heub", "heubs", "heus", "heuss", "heung", "heuj", "heuc", "heuk", "heut", "heup", "heuh", "hyi", "hyig", "hyigg", "hyigs", "hyin", "hyinj", "hyinh", "hyid", "hyil", "hyilg", "hyilm", "hyilb", "hyils", "hyilt", "hyilp", "hyilh", "hyim", "hyib", "hyibs", "hyis", "hyiss", "hying", "hyij", "hyic", "hyik", "hyit", "hyip", "hyih", "hi", "hig", "higg", "higs", "hin", "hinj", "hinh", "hid", "hil", "hilg", "hilm", "hilb", "hils", "hilt", "hilp", "hilh", "him", "hib", "hibs", "his", "hiss", "hing", "hij", "hic", "hik", "hit", "hip", "hih", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xf9.js
var require_xf9 = __commonJS({
  "node_modules/unidecode/data/xf9.js"(exports2, module2) {
    module2.exports = ["Kay ", "Kayng ", "Ke ", "Ko ", "Kol ", "Koc ", "Kwi ", "Kwi ", "Kyun ", "Kul ", "Kum ", "Na ", "Na ", "Na ", "La ", "Na ", "Na ", "Na ", "Na ", "Na ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nam ", "Nam ", "Nam ", "Nam ", "Nap ", "Nap ", "Nap ", "Nang ", "Nang ", "Nang ", "Nang ", "Nang ", "Nay ", "Nayng ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Non ", "Nong ", "Nong ", "Nong ", "Nong ", "Noy ", "Noy ", "Noy ", "Noy ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nuk ", "Nuk ", "Num ", "Nung ", "Nung ", "Nung ", "Nung ", "Nung ", "Twu ", "La ", "Lak ", "Lak ", "Lan ", "Lyeng ", "Lo ", "Lyul ", "Li ", "Pey ", "Pen ", "Pyen ", "Pwu ", "Pwul ", "Pi ", "Sak ", "Sak ", "Sam ", "Sayk ", "Sayng ", "Sep ", "Sey ", "Sway ", "Sin ", "Sim ", "Sip ", "Ya ", "Yak ", "Yak ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Yek ", "Yek ", "Yek ", "Yek ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yem ", "Yem ", "Yem ", "Yem ", "Yem ", "Yep ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yey ", "Yey ", "Yey ", "Yey ", "O ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yong ", "Wun ", "Wen ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yuk ", "Yuk ", "Yuk ", "Yun ", "Yun ", "Yun ", "Yun ", "Yul ", "Yul ", "Yul ", "Yul ", "Yung ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "Ik ", "Ik ", "In ", "In ", "In ", "In ", "In ", "In ", "In ", "Im ", "Im ", "Im ", "Ip ", "Ip ", "Ip ", "Cang ", "Cek ", "Ci ", "Cip ", "Cha ", "Chek "];
  }
});

// node_modules/unidecode/data/xfa.js
var require_xfa = __commonJS({
  "node_modules/unidecode/data/xfa.js"(exports2, module2) {
    module2.exports = ["Chey ", "Thak ", "Thak ", "Thang ", "Thayk ", "Thong ", "Pho ", "Phok ", "Hang ", "Hang ", "Hyen ", "Hwak ", "Wu ", "Huo ", "[?] ", "[?] ", "Zhong ", "[?] ", "Qing ", "[?] ", "[?] ", "Xi ", "Zhu ", "Yi ", "Li ", "Shen ", "Xiang ", "Fu ", "Jing ", "Jing ", "Yu ", "[?] ", "Hagi ", "[?] ", "Zhu ", "[?] ", "[?] ", "Yi ", "Du ", "[?] ", "[?] ", "[?] ", "Fan ", "Si ", "Guan ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfb.js
var require_xfb = __commonJS({
  "node_modules/unidecode/data/xfb.js"(exports2, module2) {
    module2.exports = ["ff", "fi", "fl", "ffi", "ffl", "st", "st", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "mn", "me", "mi", "vn", "mkh", "[?]", "[?]", "[?]", "[?]", "[?]", "yi", "", "ay", "`", "", "d", "h", "k", "l", "m", "m", "t", "+", "sh", "s", "sh", "s", "a", "a", "", "b", "g", "d", "h", "v", "z", "[?]", "t", "y", "k", "k", "l", "[?]", "l", "[?]", "n", "n", "[?]", "p", "p", "[?]", "ts", "ts", "r", "sh", "t", "vo", "b", "k", "p", "l", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfc.js
var require_xfc = __commonJS({
  "node_modules/unidecode/data/xfc.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfd.js
var require_xfd = __commonJS({
  "node_modules/unidecode/data/xfd.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfe.js
var require_xfe = __commonJS({
  "node_modules/unidecode/data/xfe.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "~", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "..", "--", "-", "_", "_", "(", ") ", "{", "} ", "[", "] ", "[(", ")] ", "<<", ">> ", "<", "> ", "[", "] ", "{", "}", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", ",", ",", ".", "", ";", ":", "?", "!", "-", "(", ")", "{", "}", "{", "}", "#", "&", "*", "+", "-", "<", ">", "=", "", "\\", "$", "%", "@", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", ""];
  }
});

// node_modules/unidecode/data/xff.js
var require_xff = __commonJS({
  "node_modules/unidecode/data/xff.js"(exports2, module2) {
    module2.exports = ["[?]", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "[?]", "[?]", ".", "[", "]", ",", "*", "wo", "a", "i", "u", "e", "o", "ya", "yu", "yo", "tu", "+", "a", "i", "u", "e", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "n", ":", ";", "", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "[?]", "[?]", "[?]", "a", "ae", "ya", "yae", "eo", "e", "[?]", "[?]", "yeo", "ye", "o", "wa", "wae", "oe", "[?]", "[?]", "yo", "u", "weo", "we", "wi", "yu", "[?]", "[?]", "eu", "yi", "i", "[?]", "[?]", "[?]", "/C", "PS", "!", "-", "|", "Y=", "W=", "[?]", "|", "-", "|", "-", "|", "#", "O", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "{", "|", "}", "", "", "", ""];
  }
});

// node_modules/unidecode/unidecode.js
var require_unidecode = __commonJS({
  "node_modules/unidecode/unidecode.js"(exports2, module2) {
    "use strict";
    var tr = {};
    var utf8_rx = /(?![\x00-\x7F]|[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3})./g;
    module2.exports = function(str) {
      return str.replace(utf8_rx, unidecode_internal_replace);
    };
    function unidecode_internal_replace(match) {
      var utf16 = utf8_to_utf16(match);
      if (utf16 > 65535) {
        return "_";
      } else {
        var h = utf16 >> 8;
        var l = utf16 & 255;
        if (h > 24 && h < 30)
          return "";
        if (h > 215 && h < 249)
          return "";
        if (!tr[h]) {
          switch (dec2hex(h)) {
            case "00":
              tr[h] = require_x00();
              break;
            case "01":
              tr[h] = require_x01();
              break;
            case "02":
              tr[h] = require_x02();
              break;
            case "03":
              tr[h] = require_x03();
              break;
            case "04":
              tr[h] = require_x04();
              break;
            case "05":
              tr[h] = require_x05();
              break;
            case "06":
              tr[h] = require_x06();
              break;
            case "07":
              tr[h] = require_x07();
              break;
            case "09":
              tr[h] = require_x09();
              break;
            case "0a":
              tr[h] = require_x0a();
              break;
            case "0b":
              tr[h] = require_x0b();
              break;
            case "0c":
              tr[h] = require_x0c();
              break;
            case "0d":
              tr[h] = require_x0d();
              break;
            case "0e":
              tr[h] = require_x0e();
              break;
            case "0f":
              tr[h] = require_x0f();
              break;
            case "10":
              tr[h] = require_x10();
              break;
            case "11":
              tr[h] = require_x11();
              break;
            case "12":
              tr[h] = require_x12();
              break;
            case "13":
              tr[h] = require_x13();
              break;
            case "14":
              tr[h] = require_x14();
              break;
            case "15":
              tr[h] = require_x15();
              break;
            case "16":
              tr[h] = require_x16();
              break;
            case "17":
              tr[h] = require_x17();
              break;
            case "18":
              tr[h] = require_x18();
              break;
            case "1e":
              tr[h] = require_x1e();
              break;
            case "1f":
              tr[h] = require_x1f();
              break;
            case "20":
              tr[h] = require_x20();
              break;
            case "21":
              tr[h] = require_x21();
              break;
            case "22":
              tr[h] = require_x22();
              break;
            case "23":
              tr[h] = require_x23();
              break;
            case "24":
              tr[h] = require_x24();
              break;
            case "25":
              tr[h] = require_x25();
              break;
            case "26":
              tr[h] = require_x26();
              break;
            case "27":
              tr[h] = require_x27();
              break;
            case "28":
              tr[h] = require_x28();
              break;
            case "2e":
              tr[h] = require_x2e();
              break;
            case "2f":
              tr[h] = require_x2f();
              break;
            case "30":
              tr[h] = require_x30();
              break;
            case "31":
              tr[h] = require_x31();
              break;
            case "32":
              tr[h] = require_x32();
              break;
            case "33":
              tr[h] = require_x33();
              break;
            case "4d":
              tr[h] = require_x4d();
              break;
            case "4e":
              tr[h] = require_x4e();
              break;
            case "4f":
              tr[h] = require_x4f();
              break;
            case "50":
              tr[h] = require_x50();
              break;
            case "51":
              tr[h] = require_x51();
              break;
            case "52":
              tr[h] = require_x52();
              break;
            case "53":
              tr[h] = require_x53();
              break;
            case "54":
              tr[h] = require_x54();
              break;
            case "55":
              tr[h] = require_x55();
              break;
            case "56":
              tr[h] = require_x56();
              break;
            case "57":
              tr[h] = require_x57();
              break;
            case "58":
              tr[h] = require_x58();
              break;
            case "59":
              tr[h] = require_x59();
              break;
            case "5a":
              tr[h] = require_x5a();
              break;
            case "5b":
              tr[h] = require_x5b();
              break;
            case "5c":
              tr[h] = require_x5c();
              break;
            case "5d":
              tr[h] = require_x5d();
              break;
            case "5e":
              tr[h] = require_x5e();
              break;
            case "5f":
              tr[h] = require_x5f();
              break;
            case "60":
              tr[h] = require_x60();
              break;
            case "61":
              tr[h] = require_x61();
              break;
            case "62":
              tr[h] = require_x62();
              break;
            case "63":
              tr[h] = require_x63();
              break;
            case "64":
              tr[h] = require_x64();
              break;
            case "65":
              tr[h] = require_x65();
              break;
            case "66":
              tr[h] = require_x66();
              break;
            case "67":
              tr[h] = require_x67();
              break;
            case "68":
              tr[h] = require_x68();
              break;
            case "69":
              tr[h] = require_x69();
              break;
            case "6a":
              tr[h] = require_x6a();
              break;
            case "6b":
              tr[h] = require_x6b();
              break;
            case "6c":
              tr[h] = require_x6c();
              break;
            case "6d":
              tr[h] = require_x6d();
              break;
            case "6e":
              tr[h] = require_x6e();
              break;
            case "6f":
              tr[h] = require_x6f();
              break;
            case "70":
              tr[h] = require_x70();
              break;
            case "71":
              tr[h] = require_x71();
              break;
            case "72":
              tr[h] = require_x72();
              break;
            case "73":
              tr[h] = require_x73();
              break;
            case "74":
              tr[h] = require_x74();
              break;
            case "75":
              tr[h] = require_x75();
              break;
            case "76":
              tr[h] = require_x76();
              break;
            case "77":
              tr[h] = require_x77();
              break;
            case "78":
              tr[h] = require_x78();
              break;
            case "79":
              tr[h] = require_x79();
              break;
            case "7a":
              tr[h] = require_x7a();
              break;
            case "7b":
              tr[h] = require_x7b();
              break;
            case "7c":
              tr[h] = require_x7c();
              break;
            case "7d":
              tr[h] = require_x7d();
              break;
            case "7e":
              tr[h] = require_x7e();
              break;
            case "7f":
              tr[h] = require_x7f();
              break;
            case "80":
              tr[h] = require_x80();
              break;
            case "81":
              tr[h] = require_x81();
              break;
            case "82":
              tr[h] = require_x82();
              break;
            case "83":
              tr[h] = require_x83();
              break;
            case "84":
              tr[h] = require_x84();
              break;
            case "85":
              tr[h] = require_x85();
              break;
            case "86":
              tr[h] = require_x86();
              break;
            case "87":
              tr[h] = require_x87();
              break;
            case "88":
              tr[h] = require_x88();
              break;
            case "89":
              tr[h] = require_x89();
              break;
            case "8a":
              tr[h] = require_x8a();
              break;
            case "8b":
              tr[h] = require_x8b();
              break;
            case "8c":
              tr[h] = require_x8c();
              break;
            case "8d":
              tr[h] = require_x8d();
              break;
            case "8e":
              tr[h] = require_x8e();
              break;
            case "8f":
              tr[h] = require_x8f();
              break;
            case "90":
              tr[h] = require_x90();
              break;
            case "91":
              tr[h] = require_x91();
              break;
            case "92":
              tr[h] = require_x92();
              break;
            case "93":
              tr[h] = require_x93();
              break;
            case "94":
              tr[h] = require_x94();
              break;
            case "95":
              tr[h] = require_x95();
              break;
            case "96":
              tr[h] = require_x96();
              break;
            case "97":
              tr[h] = require_x97();
              break;
            case "98":
              tr[h] = require_x98();
              break;
            case "99":
              tr[h] = require_x99();
              break;
            case "9a":
              tr[h] = require_x9a();
              break;
            case "9b":
              tr[h] = require_x9b();
              break;
            case "9c":
              tr[h] = require_x9c();
              break;
            case "9d":
              tr[h] = require_x9d();
              break;
            case "9e":
              tr[h] = require_x9e();
              break;
            case "9f":
              tr[h] = require_x9f();
              break;
            case "a0":
              tr[h] = require_xa0();
              break;
            case "a1":
              tr[h] = require_xa1();
              break;
            case "a2":
              tr[h] = require_xa2();
              break;
            case "a3":
              tr[h] = require_xa3();
              break;
            case "a4":
              tr[h] = require_xa4();
              break;
            case "ac":
              tr[h] = require_xac();
              break;
            case "ad":
              tr[h] = require_xad();
              break;
            case "ae":
              tr[h] = require_xae();
              break;
            case "af":
              tr[h] = require_xaf();
              break;
            case "b0":
              tr[h] = require_xb0();
              break;
            case "b1":
              tr[h] = require_xb1();
              break;
            case "b2":
              tr[h] = require_xb2();
              break;
            case "b3":
              tr[h] = require_xb3();
              break;
            case "b4":
              tr[h] = require_xb4();
              break;
            case "b5":
              tr[h] = require_xb5();
              break;
            case "b6":
              tr[h] = require_xb6();
              break;
            case "b7":
              tr[h] = require_xb7();
              break;
            case "b8":
              tr[h] = require_xb8();
              break;
            case "b9":
              tr[h] = require_xb9();
              break;
            case "ba":
              tr[h] = require_xba();
              break;
            case "bb":
              tr[h] = require_xbb();
              break;
            case "bc":
              tr[h] = require_xbc();
              break;
            case "bd":
              tr[h] = require_xbd();
              break;
            case "be":
              tr[h] = require_xbe();
              break;
            case "bf":
              tr[h] = require_xbf();
              break;
            case "c0":
              tr[h] = require_xc0();
              break;
            case "c1":
              tr[h] = require_xc1();
              break;
            case "c2":
              tr[h] = require_xc2();
              break;
            case "c3":
              tr[h] = require_xc3();
              break;
            case "c4":
              tr[h] = require_xc4();
              break;
            case "c5":
              tr[h] = require_xc5();
              break;
            case "c6":
              tr[h] = require_xc6();
              break;
            case "c7":
              tr[h] = require_xc7();
              break;
            case "c8":
              tr[h] = require_xc8();
              break;
            case "c9":
              tr[h] = require_xc9();
              break;
            case "ca":
              tr[h] = require_xca();
              break;
            case "cb":
              tr[h] = require_xcb();
              break;
            case "cc":
              tr[h] = require_xcc();
              break;
            case "cd":
              tr[h] = require_xcd();
              break;
            case "ce":
              tr[h] = require_xce();
              break;
            case "cf":
              tr[h] = require_xcf();
              break;
            case "d0":
              tr[h] = require_xd0();
              break;
            case "d1":
              tr[h] = require_xd1();
              break;
            case "d2":
              tr[h] = require_xd2();
              break;
            case "d3":
              tr[h] = require_xd3();
              break;
            case "d4":
              tr[h] = require_xd4();
              break;
            case "d5":
              tr[h] = require_xd5();
              break;
            case "d6":
              tr[h] = require_xd6();
              break;
            case "d7":
              tr[h] = require_xd7();
              break;
            case "f9":
              tr[h] = require_xf9();
              break;
            case "fa":
              tr[h] = require_xfa();
              break;
            case "fb":
              tr[h] = require_xfb();
              break;
            case "fc":
              tr[h] = require_xfc();
              break;
            case "fd":
              tr[h] = require_xfd();
              break;
            case "fe":
              tr[h] = require_xfe();
              break;
            case "ff":
              tr[h] = require_xff();
              break;
            default:
              return "";
          }
        }
        return tr[h][l];
      }
    }
    function dec2hex(i) {
      return (i + 256).toString(16).substr(-2);
    }
    function utf8_to_utf16(raw) {
      var b1, b2, b3, b4, x, y, z;
      while (Array.isArray(raw))
        raw = raw[0];
      switch (raw.length) {
        case 1:
          return ord(raw);
        case 2:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          x = (b1 & 3) << 6 | b2 & 63;
          y = (b1 & 28) >> 2;
          return y << 8 | x;
        case 3:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          x = (b2 & 3) << 6 | b3 & 63;
          y = (b1 & 15) << 4 | (b2 & 60) >> 2;
          return y << 8 | x;
        default:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          b4 = ord(raw.substr(3, 1));
          x = (b3 & 3) << 6 | b4 & 63;
          y = (b2 & 15) << 4 | (b3 & 60) >> 2;
          z = (b1 & 7) << 5 | (b2 & 48) >> 4;
          return z << 16 | y << 8 | x;
      }
    }
    function ord(string2) {
      var str = string2 + "", code = str.charCodeAt(0);
      if (55296 <= code && code <= 56319) {
        var hi = code;
        if (str.length === 1) {
          return code;
        }
        var low = str.charCodeAt(1);
        return (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
      if (56320 <= code && code <= 57343) {
        return code;
      }
      return code;
    }
  }
});

// src/util/node.ts
var import_util, fs, path, os, crypto, styles, debounce, readline, child_process, glob, minimatch, which, semver, vm, net, stripAnsi, fastDiff, unidecode;
var init_node = __esm({
  "src/util/node.ts"() {
    "use strict";
    import_util = require("util");
    fs = require("fs");
    path = require("path");
    os = require("os");
    crypto = require("crypto");
    styles = require_ansi_styles();
    debounce = require_debounce();
    readline = require("readline");
    child_process = require("child_process");
    glob = require_glob();
    minimatch = require_minimatch2();
    which = require_which();
    semver = require_semver2();
    vm = require("vm");
    net = require("net");
    stripAnsi = require_strip_ansi();
    fastDiff = require_diff2();
    unidecode = require_unidecode();
  }
});

// src/logger/log.ts
function textToLogLevel(level2) {
  let str = level2.toLowerCase();
  switch (str) {
    case "trace":
      return 0 /* Trace */;
    case "debug":
      return 1 /* Debug */;
    case "info":
      return 2 /* Info */;
    case "error":
      return 4 /* Error */;
    case "warn":
    case "warning":
      return 3 /* Warning */;
    case "off":
      return 5 /* Off */;
    default:
      return 2 /* Info */;
  }
}
function format(args, depth = 2, color = false, hidden = false) {
  let result = "";
  for (let i = 0; i < args.length; i++) {
    let a = args[i];
    if (typeof a === "object") {
      try {
        a = (0, import_util.inspect)(a, hidden, depth, color);
      } catch (e) {
      }
    }
    if (color && (typeof a === "boolean" || typeof a === "number")) {
      a = `${yellowOpen}${a}${yellowClose}`;
    }
    result += (i > 0 ? " " : "") + a;
  }
  return result;
}
function stringifyLogLevel(level2) {
  switch (level2) {
    case 1 /* Debug */:
      return "DEBUG";
    case 4 /* Error */:
      return "ERROR";
    case 2 /* Info */:
      return "INFO";
    case 0 /* Trace */:
      return "TRACE";
    case 3 /* Warning */:
      return "WARN";
  }
  return "";
}
function getTimestamp(date) {
  return `${toTwoDigits(date.getHours())}:${toTwoDigits(date.getMinutes())}:${toTwoDigits(date.getSeconds())}.${toThreeDigits(date.getMilliseconds())}`;
}
var MAX_FILE_SIZE, yellowOpen, yellowClose, DEFAULT_LOG_LEVEL, toTwoDigits, toThreeDigits, AbstractLogger, FileLogger;
var init_log = __esm({
  "src/logger/log.ts"() {
    "use strict";
    init_node();
    MAX_FILE_SIZE = 5 * 1024 * 1024;
    yellowOpen = "\x1B[33m";
    yellowClose = "\x1B[39m";
    DEFAULT_LOG_LEVEL = 2 /* Info */;
    toTwoDigits = (v) => v < 10 ? `0${v}` : v.toString();
    toThreeDigits = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v.toString();
    AbstractLogger = class {
      constructor() {
        this.level = DEFAULT_LOG_LEVEL;
      }
      setLevel(level2) {
        if (this.level !== level2) {
          this.level = level2;
        }
      }
      getLevel() {
        return this.level;
      }
    };
    FileLogger = class extends AbstractLogger {
      constructor(fsPath2, level2, config) {
        super();
        this.fsPath = fsPath2;
        this.backupIndex = 1;
        this.useConsole = false;
        this.loggers = /* @__PURE__ */ new Map();
        this.config = Object.assign({
          userFormatters: true,
          color: false,
          depth: 2,
          showHidden: false
        }, config);
        this.setLevel(level2);
        this.promise = this.initialize();
      }
      switchConsole() {
        this.useConsole = !this.useConsole;
      }
      format(args) {
        let { color, showHidden, depth } = this.config;
        return format(args, depth, color, showHidden);
      }
      createLogger(scope) {
        let logger57 = this.loggers.has(scope) ? this.loggers.get(scope) : {
          category: scope,
          mark: () => {
          },
          getLevel: () => {
            return this.getLevel();
          },
          trace: (...args) => {
            if (this.level <= 0 /* Trace */) {
              this._log(0 /* Trace */, scope, args, this.getCurrentTimestamp());
            }
          },
          debug: (...args) => {
            if (this.level <= 1 /* Debug */) {
              this._log(1 /* Debug */, scope, args, this.getCurrentTimestamp());
            }
          },
          log: (...args) => {
            if (this.level <= 2 /* Info */) {
              this._log(2 /* Info */, scope, args, this.getCurrentTimestamp());
            }
          },
          info: (...args) => {
            if (this.level <= 2 /* Info */) {
              this._log(2 /* Info */, scope, args, this.getCurrentTimestamp());
            }
          },
          warn: (...args) => {
            if (this.level <= 3 /* Warning */) {
              this._log(3 /* Warning */, scope, args, this.getCurrentTimestamp());
            }
          },
          error: (...args) => {
            if (this.level <= 4 /* Error */) {
              this._log(4 /* Error */, scope, args, this.getCurrentTimestamp());
            }
          },
          fatal: (...args) => {
            if (this.level <= 4 /* Error */) {
              this._log(4 /* Error */, scope, args, this.getCurrentTimestamp());
            }
          },
          flush: () => {
            return this.promise;
          }
        };
        this.loggers.set(scope, logger57);
        return logger57;
      }
      async initialize() {
        return Promise.resolve();
      }
      shouldBackup(size) {
        return size > MAX_FILE_SIZE;
      }
      _log(level2, scope, args, time) {
        if (this.useConsole) {
          let method = level2 === 4 /* Error */ ? "error" : "log";
          console[method](`${stringifyLogLevel(level2)} [${scope}]`, format(args, null, true));
        } else {
          let message = this.format(args);
          this.promise = this.promise.then(() => {
            let fn = async () => {
              let text;
              if (this.config.userFormatters !== false) {
                let parts = [time, stringifyLogLevel(level2), `(pid:${process.pid})`, `[${scope}]`];
                text = `${parts.join(" ")} - ${message}
`;
              } else {
                text = message;
              }
              await (0, import_util.promisify)(fs.appendFile)(this.fsPath, text, { encoding: "utf8", flag: "a+" });
              let stat = await (0, import_util.promisify)(fs.stat)(this.fsPath);
              if (this.shouldBackup(stat.size)) {
                let newFile = this.getBackupResource();
                await (0, import_util.promisify)(fs.rename)(this.fsPath, newFile);
              }
            };
            return fn();
          }).catch((err) => {
            !global.REVISION && console.error(err);
          });
        }
      }
      getCurrentTimestamp() {
        const currentTime = new Date();
        return `${currentTime.getFullYear()}-${toTwoDigits(currentTime.getMonth() + 1)}-${toTwoDigits(currentTime.getDate())}T${getTimestamp(currentTime)}`;
      }
      getBackupResource() {
        this.backupIndex = this.backupIndex > 5 ? 1 : this.backupIndex;
        return path.join(path.dirname(this.fsPath), `${path.basename(this.fsPath)}_${this.backupIndex++}`);
      }
    };
  }
});

// src/util/index.ts
function getConditionValue(value, testValue) {
  return false ? testValue : value;
}
function defaultValue(val, defaultValue2) {
  return val == null ? defaultValue2 : val;
}
function wait(ms) {
  if (ms <= 0)
    return Promise.resolve(void 0);
  return new Promise((resolve) => {
    let timer = setTimeout(() => {
      resolve(void 0);
    }, ms);
    timer.unref();
  });
}
function waitWithToken(ms, token) {
  return new Promise((resolve) => {
    let disposable = token.onCancellationRequested(() => {
      clearTimeout(timer);
      resolve(true);
    });
    let timer = setTimeout(() => {
      disposable.dispose();
      resolve(false);
    }, ms);
    timer.unref();
  });
}
function waitNextTick() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      resolve(void 0);
    });
  });
}
function waitImmediate() {
  return new Promise((resolve) => {
    setImmediate(() => {
      resolve(void 0);
    });
  });
}
function delay(func2, defaultDelay) {
  let timer;
  let fn = (ms) => {
    if (timer)
      clearTimeout(timer);
    timer = setTimeout(() => {
      func2();
    }, ms ?? defaultDelay);
    timer.unref();
  };
  Object.defineProperty(fn, "clear", {
    get: () => {
      return () => {
        clearTimeout(timer);
      };
    }
  });
  return fn;
}
function concurrent(arr, fn, limit = 3) {
  if (arr.length == 0)
    return Promise.resolve();
  let finished = 0;
  let total = arr.length;
  let remain = arr.slice();
  return new Promise((resolve) => {
    let run = (val) => {
      let cb = () => {
        finished = finished + 1;
        if (finished == total) {
          resolve();
        } else if (remain.length) {
          let next = remain.shift();
          run(next);
        }
      };
      fn(val).then(cb, cb);
    };
    for (let i = 0; i < Math.min(limit, remain.length); i++) {
      let val = remain.shift();
      run(val);
    }
  });
}
function disposeAll(disposables) {
  while (disposables.length) {
    const item = disposables.pop();
    item == null ? void 0 : item.dispose();
  }
}
var pariedCharacters;
var init_util = __esm({
  "src/util/index.ts"() {
    "use strict";
    pariedCharacters = /* @__PURE__ */ new Map([
      ["<", ">"],
      [">", "<"],
      ["{", "}"],
      ["[", "]"],
      ["(", ")"]
    ]);
  }
});

// src/logger/index.ts
var logger_exports = {};
__export(logger_exports, {
  createLogger: () => createLogger,
  emptyFile: () => emptyFile,
  getLoggerFile: () => getLoggerFile,
  getTimestamp: () => getTimestamp,
  logger: () => logger,
  resolveLogFilepath: () => resolveLogFilepath
});
function resolveLogFilepath() {
  let file = process.env.NVIM_COC_LOG_FILE;
  if (file)
    return file;
  let dir = process.env.XDG_RUNTIME_DIR;
  if (dir) {
    try {
      fs.accessSync(dir, fs.constants.R_OK | fs.constants.W_OK);
      return path.join(dir, `coc-nvim-${process.pid}.log`);
    } catch (err) {
    }
  }
  let tmpdir = os.tmpdir();
  dir = path.join(tmpdir, `coc.nvim-${process.pid}`);
  fs.mkdirSync(dir, { recursive: true });
  return path.join(dir, `coc-nvim.log`);
}
function emptyFile(filepath) {
  if (fs.existsSync(filepath)) {
    try {
      fs.writeFileSync(filepath, "", { encoding: "utf8", mode: 438 });
    } catch (e) {
    }
  }
}
function getLoggerFile() {
  return logfile;
}
function createLogger(category = "coc.nvim") {
  return logger.createLogger(category);
}
var logfile, level, logger;
var init_logger = __esm({
  "src/logger/index.ts"() {
    "use strict";
    init_log();
    init_node();
    init_util();
    init_log();
    logfile = resolveLogFilepath();
    emptyFile(logfile);
    level = getConditionValue(process.env.NVIM_COC_LOG_LEVEL || "info", "off");
    logger = new FileLogger(logfile, textToLogLevel(level), {
      color: !global.REVISION && process.platform !== "win32",
      userFormatters: true
    });
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/buffer-global.js"(exports2, module2) {
    module2.exports = c("undefined" !== typeof Buffer && Buffer) || c(exports2.Buffer) || c("undefined" !== typeof window && window.Buffer) || exports2.Buffer;
    function c(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = alloc(0);
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Array(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-buffer.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var exports2 = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
    exports2.alloc = Bufferish.hasBuffer && Buffer3.alloc || alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return Buffer3.alloc(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer3.from && Buffer3.from.length !== 1) {
        return Buffer3.from(value);
      } else {
        return new Buffer3(value);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-uint8array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Uint8Array(size);
    }
    function from(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/buffer-lite.js"(exports2) {
    exports2.copy = copy;
    exports2.toString = toString;
    exports2.write = write;
    function write(string2, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string2.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string2.charCodeAt(i++);
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 2048) {
          buffer[index++] = 192 | chr >>> 6;
          buffer[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer[index++] = 224 | chr >>> 12;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string2.charCodeAt(i++) - 56320) + 65536;
          buffer[index++] = 240 | chr >>> 18;
          buffer[index++] = 128 | chr >>> 12 & 63;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString(encoding2, start, end) {
      var buffer = this;
      var index = start | 0;
      if (!end)
        end = buffer.length;
      var string2 = "";
      var chr = 0;
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string2 += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string2 += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string2 += String.fromCharCode(chr);
        }
      }
      return string2;
    }
    function copy(target, targetStart, start, end) {
      var i;
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (!targetStart)
        targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-proto.js"(exports2) {
    var BufferLite = require_buffer_lite();
    exports2.copy = copy;
    exports2.slice = slice;
    exports2.toString = toString;
    exports2.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var brokenTypedArray = isBufferShim && !Buffer3.TYPED_ARRAY_SUPPORT;
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    function toString(encoding2, start, end) {
      var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish.js"(exports2) {
    var Buffer3 = exports2.global = require_buffer_global();
    var hasBuffer = exports2.hasBuffer = Buffer3 && !!Buffer3.isBuffer;
    var hasArrayBuffer = exports2.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
    exports2.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports2.isBuffer = hasBuffer ? Buffer3.isBuffer : _false;
    var isView = exports2.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports2.alloc = alloc;
    exports2.concat = concat;
    exports2.from = from;
    var BufferArray = exports2.Array = require_bufferish_array();
    var BufferBuffer = exports2.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports2.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports2.prototype = require_bufferish_proto();
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc(size) {
      return auto(this).alloc(size);
    }
    function concat(list2, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list2, dryrun);
      }
      var ref = this !== exports2 && this || list2[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list2, append);
      return result;
      function dryrun(buffer) {
        length += buffer.length;
      }
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : Array.isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name2, key) {
      name2 = "[object " + name2 + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name2;
      };
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext-buffer.js"(exports2) {
    exports2.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer))
        return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext-packer.js"(exports2) {
    exports2.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec) {
      codec.addExtPacker(14, Error, [packError, encode]);
      codec.addExtPacker(1, EvalError, [packError, encode]);
      codec.addExtPacker(2, RangeError, [packError, encode]);
      codec.addExtPacker(3, ReferenceError, [packError, encode]);
      codec.addExtPacker(4, SyntaxError, [packError, encode]);
      codec.addExtPacker(5, TypeError, [packError, encode]);
      codec.addExtPacker(6, URIError, [packError, encode]);
      codec.addExtPacker(10, RegExp, [packRegExp, encode]);
      codec.addExtPacker(11, Boolean, [packValueOf, encode]);
      codec.addExtPacker(12, String, [packValueOf, encode]);
      codec.addExtPacker(13, Date, [Number, encode]);
      codec.addExtPacker(15, Number, [packValueOf, encode]);
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtPacker(17, Int8Array, packTypedArray);
        codec.addExtPacker(18, Uint8Array, packTypedArray);
        codec.addExtPacker(19, Int16Array, packTypedArray);
        codec.addExtPacker(20, Uint16Array, packTypedArray);
        codec.addExtPacker(21, Int32Array, packTypedArray);
        codec.addExtPacker(22, Uint32Array, packTypedArray);
        codec.addExtPacker(23, Float32Array, packTypedArray);
        if ("undefined" !== typeof Float64Array) {
          codec.addExtPacker(24, Float64Array, packTypedArray);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(27, Buffer3, Bufferish.from);
      }
    }
    function encode(input) {
      if (!_encode)
        _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports2) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports3) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name2, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name2;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber2;
        proto.toString = toString;
        proto.toJSON = toNumber2;
        proto.toArray = toArray2;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports3[name2] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if ("string" === typeof value) {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber2() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low)
              break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray2(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && "string" !== typeof buffer[offset];
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    }(typeof exports2 === "object" && typeof exports2.nodeName !== "string" ? exports2 : exports2 || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-uint8.js"(exports2) {
    var constant = exports2.uint8 = new Array(256);
    for (i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    var i;
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-token.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer3.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer3.prototype || {};
    exports2.getWriteToken = getWriteToken;
    function getWriteToken(options2) {
      if (options2 && options2.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options2 && options2.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE);
      token[203] = writeN(203, 8, writeDoubleBE);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write2(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write2(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
      token[204] = write1(204);
      token[205] = write2(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write2(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write2(218);
      token[219] = write4(219);
      token[220] = write2(220);
      token[221] = write4(221);
      token[222] = write2(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer3.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer3.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer3.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer3.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer3.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer3.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer3.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer3.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer3.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer3.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer3.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer3.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer3.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer3.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer3.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer3.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer3.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer3.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer3.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer3.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer3.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-type.js"(exports2) {
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
    var HAS_MAP = "undefined" !== typeof Map;
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports2.getWriteType = getWriteType;
    function getWriteType(options2) {
      var token = WriteToken.getWriteToken(options2);
      var useraw = options2 && options2.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options2 && options2.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options2 && options2.usemap;
      var map = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number2,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number2(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string2;
        function string2(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null)
          return nil(encoder, value);
        if (isBuffer(value))
          return bin(encoder, value);
        if (Array.isArray(value))
          return array(encoder, value);
        if (Uint64BE.isUint64BE(value))
          return uint64(encoder, value);
        if (Int64BE.isInt64BE(value))
          return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer)
          value = packer(value);
        if (value instanceof ExtBuffer)
          return ext(encoder, value);
        map(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer(value))
          return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
      function obj_to_map(encoder, value) {
        var keys = [];
        for (let [key, val] of Object.entries(value)) {
          if (val !== void 0)
            keys.push(key);
        }
        var length = keys.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        keys.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map))
          return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/codec-base.js"(exports2) {
    exports2.createCodec = createCodec;
    exports2.install = install;
    exports2.filter = filter2;
    var Bufferish = require_bufferish();
    function Codec(options2) {
      if (!(this instanceof Codec))
        return new Codec(options2);
      this.options = options2;
      this.init();
    }
    Codec.prototype.init = function() {
      var options2 = this.options;
      if (options2 && options2.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a, b) {
      return a && b ? ab : a || b;
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    function join(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator, value);
      };
      function iterator(value, filter3) {
        return filter3(value);
      }
    }
    function filter2(filter3) {
      return Array.isArray(filter3) ? join(filter3) : filter3;
    }
    function createCodec(options2) {
      return new Codec(options2);
    }
    exports2.preset = createCodec({ preset: true });
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getEncoder(options2) {
      var writeType = WriteType.getWriteType(options2);
      return encode;
      function encode(encoder, value) {
        var func2 = writeType[typeof value];
        if (!func2)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func2(encoder, value);
      }
    }
    function init() {
      var options2 = this.options;
      this.encode = getEncoder(options2);
      if (options2 && options2.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name2 = Class.name;
      if (name2 && name2 !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name2] = extPacker;
      } else {
        var list2 = this.extEncoderList || (this.extEncoderList = []);
        list2.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e)
        return e;
      var list2 = this.extEncoderList || (this.extEncoderList = []);
      var len = list2.length;
      for (var i = 0; i < len; i++) {
        var pair = list2[i];
        if (c === pair[0])
          return pair[1];
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/flex-buffer.js"(exports2) {
    exports2.FlexDecoder = FlexDecoder;
    exports2.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder))
        return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder))
        return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write2,
        fetch: fetch2,
        flush,
        push,
        pull,
        read,
        reserve,
        offset: 0
      };
      function write2(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE)
              throw e;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length)
          throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write,
        fetch: fetch3,
        flush,
        push,
        pull: pull2,
        read,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch3() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value)
            this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    function write() {
      throw new Error("method not implemented: write()");
    }
    function fetch2() {
      throw new Error("method not implemented: fetch()");
    }
    function read() {
      var length = this.buffers && this.buffers.length;
      if (!length)
        return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin2;
      function mixin2(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encode-buffer.js"(exports2) {
    exports2.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options2) {
      if (!(this instanceof EncodeBuffer))
        return new EncodeBuffer(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec = this.codec = options2.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encode.js"(exports2) {
    exports2.encode = encode;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode(input, options2) {
      var encoder = new EncodeBuffer(options2);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext-unpacker.js"(exports2) {
    exports2.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(14, [decode, unpackError(Error)]);
      codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
      codec.addExtUnpacker(10, [decode, unpackRegExp]);
      codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(12, [decode, unpackClass(String)]);
      codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtUnpacker(17, unpackClass(Int8Array));
        codec.addExtUnpacker(18, unpackClass(Uint8Array));
        codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if ("undefined" !== typeof Float64Array) {
          codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec.addExtUnpacker(26, unpackArrayBuffer);
        codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(27, unpackClass(Buffer3));
      }
    }
    function decode(input) {
      if (!_decode)
        _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/read-format.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports2.getReadFormat = getReadFormat;
    exports2.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = "undefined" !== typeof Map;
    var NO_ASSERT = true;
    function getReadFormat(options2) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options2 && options2.binarraybuffer;
      var int64 = options2 && options2.int64;
      var usemap = HAS_MAP && options2 && options2.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = /* @__PURE__ */ new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack)
        throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return buffer[start++] << 8 | buffer[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = buffer[start++] << 8 | buffer[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
    }
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/read-token.js"(exports2) {
    var ReadFormat = require_read_format();
    exports2.getReadToken = getReadToken;
    function getReadToken(options2) {
      var format3 = ReadFormat.getReadFormat(options2);
      if (options2 && options2.useraw) {
        return init_useraw(format3);
      } else {
        return init_token(format3);
      }
    }
    function init_token(format3) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format3.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format3.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format3.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format3.uint8, format3.bin);
      token[197] = flex(format3.uint16, format3.bin);
      token[198] = flex(format3.uint32, format3.bin);
      token[199] = flex(format3.uint8, format3.ext);
      token[200] = flex(format3.uint16, format3.ext);
      token[201] = flex(format3.uint32, format3.ext);
      token[202] = format3.float32;
      token[203] = format3.float64;
      token[204] = format3.uint8;
      token[205] = format3.uint16;
      token[206] = format3.uint32;
      token[207] = format3.uint64;
      token[208] = format3.int8;
      token[209] = format3.int16;
      token[210] = format3.int32;
      token[211] = format3.int64;
      token[212] = fix(1, format3.ext);
      token[213] = fix(2, format3.ext);
      token[214] = fix(4, format3.ext);
      token[215] = fix(8, format3.ext);
      token[216] = fix(16, format3.ext);
      token[217] = flex(format3.uint8, format3.str);
      token[218] = flex(format3.uint16, format3.str);
      token[219] = flex(format3.uint32, format3.str);
      token[220] = flex(format3.uint16, format3.array);
      token[221] = flex(format3.uint32, format3.array);
      token[222] = flex(format3.uint16, format3.map);
      token[223] = flex(format3.uint32, format3.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format3) {
      var i;
      var token = init_token(format3).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format3.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/read-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getDecoder(options2) {
      var readToken = ReadToken.getReadToken(options2);
      return decode;
      function decode(decoder) {
        var type = readUint8(decoder);
        var func2 = readToken[type];
        if (!func2)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func2(decoder);
      }
    }
    function init() {
      var options2 = this.options;
      this.decode = getDecoder(options2);
      if (options2 && options2.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decode-buffer.js"(exports2) {
    exports2.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options2) {
      if (!(this instanceof DecodeBuffer))
        return new DecodeBuffer(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec = this.codec = options2.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decode.js"(exports2) {
    exports2.decode = decode;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode(input, options2) {
      var decoder = new DecodeBuffer(options2);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encoder.js"(exports2) {
    exports2.Encoder = Encoder;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options2) {
      if (!(this instanceof Encoder))
        return new Encoder(options2);
      EncodeBuffer.call(this, options2);
    }
    Encoder.prototype = new EncodeBuffer();
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length)
        this.encode(chunk);
      this.flush();
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decoder.js"(exports2) {
    exports2.Decoder = Decoder;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options2) {
      if (!(this instanceof Decoder))
        return new Decoder(options2);
      DecodeBuffer.call(this, options2);
    }
    Decoder.prototype = new DecodeBuffer();
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length)
        this.write(chunk);
      this.flush();
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encode-stream.js"(exports2) {
    exports2.createEncodeStream = EncodeStream;
    var util = require("util");
    var Transform2 = require("stream").Transform;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    util.inherits(EncodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function EncodeStream(options2) {
      if (!(this instanceof EncodeStream))
        return new EncodeStream(options2);
      if (options2) {
        options2.objectMode = true;
      } else {
        options2 = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options2);
      var stream = this;
      var encoder = this.encoder = new EncodeBuffer(options2);
      encoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    EncodeStream.prototype._transform = function(chunk, encoding2, callback) {
      this.encoder.write(chunk);
      if (callback)
        callback();
    };
    EncodeStream.prototype._flush = function(callback) {
      this.encoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decode-stream.js"(exports2) {
    exports2.createDecodeStream = DecodeStream;
    var util = require("util");
    var Transform2 = require("stream").Transform;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    util.inherits(DecodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function DecodeStream(options2) {
      if (!(this instanceof DecodeStream))
        return new DecodeStream(options2);
      if (options2) {
        options2.objectMode = true;
      } else {
        options2 = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options2);
      var stream = this;
      var decoder = this.decoder = new DecodeBuffer(options2);
      decoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    DecodeStream.prototype._transform = function(chunk, encoding2, callback) {
      this.decoder.write(chunk);
      this.decoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/codec.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/index.js
var require_msgpack_lite = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/index.js"(exports2) {
    exports2.encode = require_encode().encode;
    exports2.decode = require_decode().decode;
    exports2.Encoder = require_encoder().Encoder;
    exports2.Decoder = require_decoder().Decoder;
    exports2.createEncodeStream = require_encode_stream().createEncodeStream;
    exports2.createDecodeStream = require_decode_stream().createDecodeStream;
    exports2.createCodec = require_ext().createCodec;
    exports2.codec = require_codec().codec;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseApi = void 0;
    var BaseApi = class {
      constructor({ data, client }) {
        this.data = data;
        if (client) {
          this.client = client;
        } else {
          Object.defineProperty(this, "client", {
            value: this
          });
        }
      }
      get transport() {
        return this.client._transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      async request(name2, args = []) {
        Error.captureStackTrace(args);
        return new Promise((resolve, reject) => {
          this.transport.request(name2, this.getArgsByPrefix(args), (err, res) => {
            if (err) {
              let e = new Error(err[1]);
              if (!name2.endsWith("get_var")) {
                let stack = args.stack;
                e.stack = `Error: request error on "${name2}" - ${err[1]}
` + stack.split(/\r?\n/).slice(3).join("\n");
                this.client.logError(`request error on "${name2}"`, args, e);
              }
              reject(e);
            } else {
              resolve(res);
            }
          });
        });
      }
      getArgsByPrefix(args) {
        if (this.prefix !== "nvim_" && args[0] != this) {
          let id = this.transport.isVim ? this.data : this;
          return [id, ...args];
        }
        return args;
      }
      getVar(name2) {
        return this.request(`${this.prefix}get_var`, [name2]).then((res) => res, (_err) => {
          return null;
        });
      }
      setVar(name2, value, isNotify = false) {
        if (isNotify) {
          this.notify(`${this.prefix}set_var`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_var`, [name2, value]);
      }
      deleteVar(name2) {
        this.notify(`${this.prefix}del_var`, [name2]);
      }
      getOption(name2) {
        return this.request(`${this.prefix}get_option`, [name2]);
      }
      setOption(name2, value, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}set_option`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_option`, [name2, value]);
      }
      notify(name2, args = []) {
        this.transport.notify(name2, this.getArgsByPrefix(args));
      }
      toJSON() {
        var _a2;
        return (_a2 = this.data) !== null && _a2 !== void 0 ? _a2 : 0;
      }
    };
    exports2.BaseApi = BaseApi;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buffer = void 0;
    var Base_1 = require_Base();
    var Buffer3 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_buf_";
      }
      async attach(sendBuffer = false, options2 = {}) {
        return await this.request(`${this.prefix}attach`, [sendBuffer, options2]);
      }
      async detach() {
        return await this.request(`${this.prefix}detach`, []);
      }
      get id() {
        return this.data;
      }
      get length() {
        return this.request(`${this.prefix}line_count`, []);
      }
      get lines() {
        return this.getLines();
      }
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options2 = {}) {
        return this.request(`${this.prefix}get_commands`, [options2]);
      }
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          start,
          end,
          indexing
        ]);
      }
      setLines(lines, opts, notify = false) {
        let { start, end, strictIndexing } = opts !== null && opts !== void 0 ? opts : {};
        start = start !== null && start !== void 0 ? start : 0;
        end = end !== null && end !== void 0 ? end : start + 1;
        const indexing = strictIndexing !== null && strictIndexing !== void 0 ? strictIndexing : true;
        const method = notify ? "notify" : "request";
        return this[method](`${this.prefix}set_lines`, [
          start,
          end,
          indexing,
          typeof lines === "string" ? [lines] : lines
        ]);
      }
      setVirtualText(src_id, line, chunks, opts = {}) {
        this.client.call("coc#vtext#add", [this.id, src_id, line, chunks, opts], true);
        return Promise.resolve(src_id);
      }
      deleteExtMark(ns_id, id) {
        this.notify(`${this.prefix}del_extmark`, [
          ns_id,
          id
        ]);
      }
      async getExtMarkById(ns_id, id, opts = {}) {
        return this.request(`${this.prefix}get_extmark_by_id`, [ns_id, id, opts]);
      }
      async getExtMarks(ns_id, start, end, opts = {}) {
        return this.request(`${this.prefix}get_extmarks`, [ns_id, start, end, opts]);
      }
      setExtMark(ns_id, line, col, opts = {}) {
        this.notify(`${this.prefix}set_extmark`, [
          ns_id,
          line,
          col,
          opts
        ]);
      }
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
      }
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      get name() {
        return this.request(`${this.prefix}get_name`, []);
      }
      setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      mark(name2) {
        return this.request(`${this.prefix}get_mark`, [name2]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      setKeymap(mode, lhs, rhs, opts = {}) {
        let option = opts.expr ? Object.assign({ replace_keycodes: true }, opts) : opts;
        this.notify(`${this.prefix}set_keymap`, [mode, lhs, rhs, option]);
      }
      deleteKeymap(mode, lhs) {
        this.notify(`${this.prefix}del_keymap`, [mode, lhs]);
      }
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
      }
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
      }
      addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        if (!hlGroup)
          throw new Error("hlGroup should not empty");
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId4 = typeof _srcId !== "undefined" ? _srcId : -1;
        const method = srcId4 == 0 ? "request" : "notify";
        let res = this[method](`${this.prefix}add_highlight`, [
          srcId4,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
        return method === "request" ? res : Promise.resolve(null);
      }
      clearHighlight(args = {}) {
        const defaults3 = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId: srcId4, lineStart, lineEnd } = Object.assign({}, defaults3, args);
        return this.notify(`${this.prefix}clear_highlight`, [
          srcId4,
          lineStart,
          lineEnd
        ]);
      }
      highlightRanges(srcId4, hlGroup, ranges) {
        this.client.call("coc#highlight#ranges", [this.id, srcId4, hlGroup, ranges], true);
      }
      clearNamespace(key, lineStart = 0, lineEnd = -1) {
        this.client.call("coc#highlight#clear_highlight", [this.id, key, lineStart, lineEnd], true);
      }
      placeSign(sign) {
        let opts = { lnum: sign.lnum };
        if (typeof sign.priority === "number")
          opts.priority = sign.priority;
        this.client.call("sign_place", [sign.id || 0, sign.group || "", sign.name, this.id, opts], true);
      }
      unplaceSign(opts) {
        let details = { buffer: this.id };
        if (opts.id != null)
          details.id = opts.id;
        this.client.call("sign_unplace", [opts.group || "", details], true);
      }
      async getSigns(opts) {
        let res = await this.client.call("sign_getplaced", [this.id, opts || {}]);
        return res[0].signs;
      }
      async getHighlights(ns, start = 0, end = -1) {
        let res = [];
        let arr = await this.client.call("coc#highlight#get_highlights", [this.id, ns, start, end]);
        for (let item of arr) {
          res.push({
            hlGroup: item[0],
            lnum: item[1],
            colStart: item[2],
            colEnd: item[3],
            id: item[4]
          });
        }
        return res;
      }
      updateHighlights(ns, highlights, opts = {}) {
        if (typeof opts === "number") {
          this.client.logError("Bad option for buffer.updateHighlights()", new Error());
          return;
        }
        let start = typeof opts.start === "number" ? opts.start : 0;
        let end = typeof opts.end === "number" ? opts.end : -1;
        let changedtick = typeof opts.changedtick === "number" ? opts.changedtick : null;
        let priority = typeof opts.priority === "number" ? opts.priority : null;
        if (start == 0 && end == -1) {
          let arr = highlights.map((o) => [o.hlGroup, o.lnum, o.colStart, o.colEnd, o.combine === false ? 0 : 1, o.start_incl ? 1 : 0, o.end_incl ? 1 : 0]);
          this.client.call("coc#highlight#buffer_update", [this.id, ns, arr, priority, changedtick], true);
          return;
        }
        this.client.call("coc#highlight#update_highlights", [this.id, ns, highlights, start, end, priority, changedtick], true);
      }
      listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this.id, eventName, cb);
        if (disposables) {
          disposables.push({
            dispose: () => {
              this.client.detachBufferEvent(this.id, eventName, cb);
            }
          });
        }
      }
    };
    exports2.Buffer = Buffer3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = void 0;
    var Base_1 = require_Base();
    var Window2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_win_";
      }
      get id() {
        return this.data;
      }
      setBuffer(buffer) {
        return this.request(`${this.prefix}set_buf`, [buffer]);
      }
      get buffer() {
        return this.request(`${this.prefix}get_buf`, []);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_tabpage`, []);
      }
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, []);
      }
      setCursor(pos, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_cursor`, [pos]);
      }
      get height() {
        return this.request(`${this.prefix}get_height`, []);
      }
      setHeight(height, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [height]);
      }
      get width() {
        return this.request(`${this.prefix}get_width`, []);
      }
      setWidth(width, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_width`, [width]);
      }
      get position() {
        return this.request(`${this.prefix}get_position`, []);
      }
      get row() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[0]);
      }
      get col() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[1]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      setConfig(options2, isNotify) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_config`, [options2]);
      }
      getConfig() {
        return this.request(`${this.prefix}get_config`, []);
      }
      close(force, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}close`, [force]);
          return null;
        }
        return this.request(`${this.prefix}close`, [force]);
      }
      highlightRanges(hlGroup, ranges, priority = 10, isNotify) {
        if (isNotify) {
          this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority], true);
          return void 0;
        }
        return this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority]);
      }
      clearMatchGroup(hlGroup) {
        this.client.call("coc#highlight#clear_match_group", [this.id, hlGroup], true);
      }
      clearMatches(ids) {
        this.client.call("coc#highlight#clear_matches", [this.id, ids], true);
      }
    };
    exports2.Window = Window2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Tabpage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = void 0;
    var Base_1 = require_Base();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_tabpage_";
      }
      get id() {
        return this.data;
      }
      get windows() {
        return this.request(`${this.prefix}list_wins`, []);
      }
      get window() {
        return this.request(`${this.prefix}get_win`, []);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      getOption() {
        throw new Error("Tabpage does not have `getOption`");
      }
      setOption() {
        throw new Error("Tabpage does not have `setOption`");
      }
    };
    exports2.Tabpage = Tabpage;
  }
});

// node_modules/@chemzqm/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = exports2.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType = exports2.ExtType || (exports2.ExtType = {}));
    exports2.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/@chemzqm/neovim/lib/utils/buffered.js
var require_buffered = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/buffered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var MIN_SIZE = Buffer.poolSize;
    var waterMark = 10 * 1024 * 1024;
    var Buffered = class extends stream_1.Transform {
      constructor() {
        super({
          readableHighWaterMark: waterMark,
          writableHighWaterMark: waterMark
        });
        this.chunks = null;
        this.timer = null;
      }
      sendData() {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          this.push(Buffer.concat(chunks));
        }
      }
      _transform(chunk, _encoding, callback) {
        const { chunks, timer } = this;
        if (timer)
          clearTimeout(timer);
        if (chunk.length < MIN_SIZE) {
          if (!chunks)
            return callback(null, chunk);
          chunks.push(chunk);
          this.sendData();
          callback();
        } else {
          if (!chunks) {
            this.chunks = [chunk];
          } else {
            chunks.push(chunk);
          }
          this.timer = setTimeout(this.sendData.bind(this), 20);
          callback();
        }
      }
      _flush(callback) {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          callback(null, buf);
        } else {
          callback();
        }
      }
    };
    exports2.default = Buffered;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/logger.js
var require_logger = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/logger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLogger = exports2.level = exports2.nullLogger = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var util_1 = require("util");
    var debugging = process.env.COC_NODE_CLIENT_DEBUG == "1" && process.env.COC_TESTER == "1";
    exports2.nullLogger = {
      debug: () => {
      },
      info: () => {
      },
      warn: () => {
      },
      error: () => {
      },
      trace: () => {
      }
    };
    function getLogFile() {
      let file = process.env.NODE_CLIENT_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir)
        return path_1.default.join(dir, "node-client.log");
      return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
    }
    var LOG_FILE_PATH = getLogFile();
    exports2.level = debugging ? "debug" : process.env.NODE_CLIENT_LOG_LEVEL || "info";
    var invalid = !debugging && process.getuid && process.getuid() == 0;
    if (!invalid && !debugging) {
      try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, "", { encoding: "utf8", mode: 438 });
      } catch (_e) {
        invalid = true;
      }
    }
    function toObject2(arg) {
      if (arg == null) {
        return arg;
      }
      if (Array.isArray(arg)) {
        return arg.map((o) => toObject2(o));
      }
      if (typeof arg == "object" && typeof arg.prefix == "string" && typeof arg.data == "number") {
        return "[" + arg.prefix + arg.data + "]";
      }
      return arg;
    }
    function toString(arg) {
      if (debugging)
        return (0, util_1.inspect)(arg, { depth: null, colors: true, compact: false });
      if (arg == null)
        return String(arg);
      if (typeof arg == "object")
        return JSON.stringify(arg, null, 2);
      return String(arg);
    }
    var toTwoDigits2 = (v) => v < 10 ? `0${v}` : v.toString();
    var toThreeDigits2 = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v.toString();
    function toTimeString(currentTime) {
      return `${toTwoDigits2(currentTime.getHours())}:${toTwoDigits2(currentTime.getMinutes())}:${toTwoDigits2(currentTime.getSeconds())}.${toThreeDigits2(currentTime.getMilliseconds())}`;
    }
    var Logger = class {
      constructor(name2) {
        this.name = name2;
      }
      get stream() {
        if (this._stream)
          return this._stream;
        if (debugging) {
          this._stream = process.stdout;
        } else {
          this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: "utf8" });
        }
        return this._stream;
      }
      getText(level2, data, meta) {
        let more = "";
        if (meta.length) {
          let arr = toObject2(meta);
          more = " " + arr.map((o) => toString(o)).join(", ");
        }
        return `${toTimeString(new Date())} ${level2.toUpperCase()} [${this.name}] - ${data}${more}
`;
      }
      debug(data, ...meta) {
        if (exports2.level != "debug" || invalid)
          return;
        this.stream.write(this.getText("debug", data, meta));
      }
      info(data, ...meta) {
        if (invalid)
          return;
        this.stream.write(this.getText("info", data, meta));
      }
      warn(data, ...meta) {
        if (invalid)
          return;
        this.stream.write(this.getText("warn", data, meta));
      }
      error(data, ...meta) {
        if (invalid)
          return;
        let stream = debugging ? process.stderr : this.stream;
        stream.write(this.getText("error", data, meta));
      }
      trace(data, ...meta) {
        if (exports2.level != "trace" || invalid)
          return;
        this.stream.write(this.getText("trace", data, meta));
      }
    };
    function createLogger2(name2) {
      return new Logger(name2);
    }
    exports2.createLogger = createLogger2;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/base.js
var require_base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var logger_1 = require_logger();
    var debug = logger_1.level === "debug";
    var logger57 = (0, logger_1.createLogger)("transport");
    var Transport3 = class extends events_1.EventEmitter {
      constructor(logger58, isVim2) {
        super();
        this.logger = logger58;
        this.isVim = isVim2;
        this.pauseLevel = 0;
        this.paused = /* @__PURE__ */ new Map();
      }
      debug(key, ...meta) {
        if (!debug)
          return;
        logger57.debug(key, ...meta);
      }
      info(key, ...meta) {
        logger57.info(key, ...meta);
      }
      debugMessage(msg) {
        if (!debug)
          return;
        const msgType = msg[0];
        if (msgType == 0) {
          logger57.debug("receive request:", msg.slice(1));
        } else if (msgType == 1) {
        } else if (msgType == 2) {
          logger57.debug("receive notification:", msg.slice(1));
        } else {
          logger57.debug("unknown message:", msg);
        }
      }
      pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
      }
      cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
          this.paused.delete(pauseLevel);
          this.pauseLevel = pauseLevel - 1;
        }
      }
      resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
          return isNotify ? null : Promise.resolve([[], null]);
        let obj = {};
        Error.captureStackTrace(obj);
        this.pauseLevel = pauseLevel - 1;
        let list2 = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list2 && list2.length) {
          return new Promise((resolve, reject) => {
            if (!isNotify) {
              return this.request("nvim_call_atomic", [list2], (err, res) => {
                if (err) {
                  let e = new Error(`call_atomic error: ${err[1]}`);
                  e.stack = obj.stack.replace(/^Error/, `Error: ${e.message}`);
                  return reject(e);
                }
                if (Array.isArray(res) && res[1] != null) {
                  let [index, errType, message] = res[1];
                  let [fname, args] = list2[index];
                  let e = new Error(`call_atomic request error on "${fname}": ${message}`);
                  e.stack = obj.stack.replace(/^Error/, `Error: ${e.message}`);
                  this.logger.error(`call_atomic request error ${errType} on "${fname}"`, args, message, e);
                  return reject(e);
                }
                resolve(res);
              });
            }
            this.notify("nvim_call_atomic", [list2]);
            resolve(void 0);
          });
        }
        return isNotify ? null : Promise.resolve([[], void 0]);
      }
    };
    exports2.default = Transport3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/nvim.js
var require_nvim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/nvim.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NvimTransport = void 0;
    var msgpack = __importStar(require_msgpack_lite());
    var types_1 = require_types();
    var buffered_1 = __importDefault(require_buffered());
    var base_1 = __importDefault(require_base());
    var NvimTransport = class extends base_1.default {
      constructor(logger57) {
        super(logger57, false);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on("data", (msg) => {
          this.parseMessage(msg);
        });
        this.decodeStream.on("end", () => {
          this.detach();
          this.emit("detach");
        });
      }
      parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
          let method = msg[2].toString();
          this.emit("request", method, msg[3], this.createResponse(method, msg[1]));
        } else if (msgType === 1) {
          const id = msg[1];
          const handler = this.pending.get(id);
          if (handler) {
            this.pending.delete(id);
            let err = msg[2];
            if (err && err.length != 2) {
              err = [0, err.toString()];
            }
            handler(err, msg[3]);
          }
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          console.error(`Invalid message type ${msgType}`);
        }
      }
      setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
          codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
          codec.addExtUnpacker(id, (data) => new constructor({
            client: this.client,
            data: msgpack.decode(data)
          }));
        });
        this.codec = codec;
        return this.codec;
      }
      attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
        for (let handler of this.pending.values()) {
          handler([0, "transport disconnected"]);
        }
        this.pending.clear();
      }
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug("request to nvim:", id, method, args);
        this.encodeStream.write(msgpack.encode([0, id, method, args], {
          codec: this.codec
        }));
        this.pending.set(id, (err, res) => {
          this.debug("response of nvim:", id, Date.now() - startTs, res, err);
          cb(err, res);
        });
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        this.debug("nvim notification:", method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
          codec: this.codec
        }));
      }
      send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
          codec: this.codec
        }));
      }
      createResponse(method, requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            this.debug("response of client:", requestId, `${Date.now() - startTs}ms`, resp, isError == true);
            called = true;
            encodeStream.write(msgpack.encode([
              1,
              requestId,
              isError ? resp : null,
              !isError ? resp : null
            ]));
          }
        };
      }
    };
    exports2.NvimTransport = NvimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/constants.js
var require_constants2 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTester = exports2.isCocNvim = void 0;
    exports2.isCocNvim = true;
    exports2.isTester = process.env.COC_TESTER == "1";
  }
});

// node_modules/@chemzqm/neovim/lib/transport/connection.js
var require_connection = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/connection.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    var logger_1 = require_logger();
    var logger57 = (0, logger_1.createLogger)("connection");
    var NR_CODE = 10;
    var Connection2 = class extends events_1.default {
      constructor(readable, writeable) {
        super();
        this.writeable = writeable;
        let cached = [];
        let hasCache = false;
        readable.once("data", (buf) => {
          if (!Buffer.isBuffer(buf))
            throw new Error(`Vim connection expect buffer from readable stream.`);
        });
        let onData = (buf) => {
          let start = 0;
          let len = buf.byteLength;
          for (let i = 0; i < len; i++) {
            if (buf[i] === NR_CODE) {
              let b = buf.slice(start, i);
              if (hasCache) {
                cached.push(b);
                let concated = Buffer.concat(cached);
                hasCache = false;
                cached = [];
                this.parseData(concated.toString("utf8"));
              } else {
                this.parseData(b.toString("utf8"));
              }
              start = i + 1;
            }
          }
          if (start < len) {
            cached.push(start == 0 ? buf : buf.slice(start));
            hasCache = true;
          }
        };
        readable.on("data", onData);
        let onClose = () => {
          logger57.warn("readable stream closed.");
        };
        readable.on("close", onClose);
        this.clean = () => {
          readable.off("data", onData);
          readable.off("close", onClose);
        };
      }
      parseData(str) {
        if (str.length == 0)
          return;
        let arr;
        try {
          arr = JSON.parse(str);
        } catch (e) {
          console.error(`Invalid data from vim: ${str}`);
          return;
        }
        let [id, obj] = arr;
        if (id > 0) {
          logger57.debug("received request:", id, obj);
          this.emit("request", id, obj);
        } else if (id == 0) {
          logger57.debug("received notification:", obj);
          this.emit("notification", obj);
        } else {
          logger57.debug("received response:", id, obj);
          this.emit("response", id, obj);
        }
      }
      response(requestId, data) {
        this.send([requestId, data || null]);
      }
      notify(event, data) {
        this.send([0, [event, data || null]]);
      }
      send(arr) {
        logger57.debug("send to vim:", arr);
        this.writeable.write(JSON.stringify(arr) + "\n");
      }
      redraw(force) {
        this.send(["redraw", force ? "force" : ""]);
      }
      command(cmd) {
        this.send(["ex", cmd]);
      }
      expr(expr) {
        this.send(["expr", expr]);
      }
      call(func2, args, requestId) {
        if (typeof requestId === "number") {
          this.send(["call", func2, args, requestId]);
          return;
        }
        this.send(["call", func2, args]);
      }
      dispose() {
        if (typeof this.clean === "function") {
          this.clean();
          this.clean = void 0;
        }
        this.removeAllListeners();
      }
    };
    exports2.default = Connection2;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/request.js
var require_request = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var func2 = constants_1.isCocNvim ? "coc#api#call" : "nvim#api#call";
    var Request = class {
      constructor(connection, cb, id) {
        this.connection = connection;
        this.cb = cb;
        this.id = id;
      }
      request(method, args = []) {
        this.method = method;
        this.connection.call(func2, [method.slice(5), args], this.id);
      }
      callback(client, err, result) {
        let { method, cb } = this;
        if (err)
          return cb([0, err.toString()]);
        switch (method) {
          case "nvim_list_wins":
          case "nvim_tabpage_list_wins":
            return cb(null, result.map((o) => client.createWindow(o)));
          case "nvim_tabpage_get_win":
          case "nvim_get_current_win":
          case "nvim_open_win":
            return cb(null, client.createWindow(result));
          case "nvim_list_bufs":
            return cb(null, result.map((o) => client.createBuffer(o)));
          case "nvim_win_get_buf":
          case "nvim_create_buf":
          case "nvim_get_current_buf":
            return cb(null, client.createBuffer(result));
          case "nvim_list_tabpages":
            return cb(null, result.map((o) => client.createTabpage(o)));
          case "nvim_win_get_tabpage":
          case "nvim_get_current_tabpage":
            return cb(null, client.createTabpage(result));
          default:
            return cb(null, result);
        }
      }
    };
    exports2.default = Request;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/vim.js
var require_vim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/vim.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VimTransport = void 0;
    var constants_1 = require_constants2();
    var base_1 = __importDefault(require_base());
    var connection_1 = __importDefault(require_connection());
    var request_1 = __importDefault(require_request());
    var VimTransport = class extends base_1.default {
      constructor(logger57) {
        super(logger57, true);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.errText = "";
        this.outText = "";
        this.notifyMethod = constants_1.isCocNvim ? "coc#api#notify" : "nvim#api#notify";
      }
      attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on("request", (id, obj) => {
          let [method, args] = obj;
          this.emit("request", method, args, this.createResponse(method, id));
        });
        connection.on("notification", (obj) => {
          let [event, args] = obj;
          this.emit("notification", event.toString(), args);
        });
        connection.on("response", (id, obj) => {
          let req = this.pending.get(id);
          if (req) {
            this.pending.delete(id);
            let err = null;
            let result = null;
            if (!Array.isArray(obj)) {
              err = obj;
            } else {
              err = obj[0];
              result = obj[1];
            }
            req.callback(this.client, err, result);
          }
        });
      }
      send(arr) {
        this.connection.send(arr);
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.connection.dispose();
        for (let req of this.pending.values()) {
          req.callback(this.client, "connection disconnected", null);
        }
        this.pending.clear();
      }
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let req = new request_1.default(this.connection, (err, res) => {
          cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        let fname = method.slice(5);
        if (fname == "err_write") {
          this.errText = this.errText + args[0].toString();
          return;
        }
        if (fname == "out_write") {
          let msg = args[0].toString() || "";
          if (!msg.includes("\n")) {
            this.outText = this.outText + msg;
          } else {
            let text = this.outText + args[0].toString();
            this.outText = "";
            this.connection.call(this.notifyMethod, [fname, [text]]);
          }
          return;
        }
        if (fname == "err_writeln") {
          let text = this.errText + args[0].toString();
          this.errText = "";
          this.connection.call(this.notifyMethod, [fname, [text]]);
          return;
        }
        this.connection.call(this.notifyMethod, [fname, args]);
      }
      createResponse(method, requestId) {
        let called = false;
        let { connection } = this;
        return {
          send: (resp, isError) => {
            if (called || !this.attached)
              return;
            called = true;
            let err = null;
            if (isError)
              err = typeof resp === "string" ? resp : resp.toString();
            connection.response(requestId, [err, isError ? null : resp]);
          }
        };
      }
    };
    exports2.VimTransport = VimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Neovim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Neovim = void 0;
    var Base_1 = require_Base();
    var constants_1 = require_constants2();
    function getArgs(args) {
      if (!args)
        return [];
      if (Array.isArray(args))
        return args;
      return [args];
    }
    var Neovim2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
      }
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      get buffer() {
        return this.request(`${this.prefix}get_current_buf`);
      }
      async setBuffer(buffer) {
        await this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      createNamespace(name2 = "") {
        if (constants_1.isCocNvim) {
          name2 = name2.startsWith("coc-") ? name2.slice(4) : name2;
          return this.request(`${this.prefix}call_function`, ["coc#highlight#create_namespace", [name2]]);
        }
        return this.request(`${this.prefix}create_namespace`, [name2]);
      }
      get namespaces() {
        return this.request(`${this.prefix}get_namespaces`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options2 = {}) {
        return this.request(`${this.prefix}get_commands`, [options2]);
      }
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_current_tabpage`);
      }
      async setTabpage(tabpage) {
        await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      get windows() {
        return this.getWindows();
      }
      get window() {
        return this.request(`${this.prefix}get_current_win`);
      }
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      async setWindow(win) {
        await this.request(`${this.prefix}set_current_win`, [win]);
      }
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      setDirectory(dir) {
        return this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      get line() {
        return this.getLine();
      }
      createNewBuffer(listed = false, scratch = false) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      openFloatWindow(buffer, enter, options2) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options2]);
      }
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      setKeymap(mode, lhs, rhs, opts = {}) {
        let option = opts.expr ? Object.assign({ replace_keycodes: true }, opts) : opts;
        this.notify(`${this.prefix}set_keymap`, [mode, lhs, rhs, option]);
      }
      deleteKeymap(mode, lhs) {
        this.notify(`${this.prefix}del_keymap`, [mode, lhs]);
      }
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      getColorByName(name2) {
        return this.request(`${this.prefix}get_color_by_name`, [name2]);
      }
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      getHighlightByName(name2, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name2, isRgb]);
      }
      getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
      }
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      lua(code, args = []) {
        return this.request(`${this.prefix}exec_lua`, [code, args]);
      }
      executeLua(code, args = []) {
        const _args = getArgs(args);
        return this.lua(code, _args);
      }
      callDictFunction(dict, fname, args = []) {
        const _args = getArgs(args);
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      call(fname, args = [], isNotify) {
        const _args = getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, [fname, _args]);
          return null;
        }
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      callTimer(fname, args = [], isNotify) {
        const _args = getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return null;
        }
        if (this.transport.isVim) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve(null);
            }, 20);
          });
        }
        return this.request(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
      }
      callAsync(fname, args = []) {
        const _args = getArgs(args);
        return this.client.sendAsyncRequest(fname, _args);
      }
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      command(arg, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}command`, [arg]);
          return null;
        }
        return this.request(`${this.prefix}command`, [arg]);
      }
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      exec(src, output = false) {
        return this.request(`${this.prefix}exec`, [src, output]);
      }
      getVvar(name2) {
        return this.request(`${this.prefix}get_vvar`, [name2]);
      }
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      inputMouse(button, action, modifier, row, col, grid = 0) {
        return this.request(`${this.prefix}input_mouse`, [button, action, modifier, grid, row, col]);
      }
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      outWrite(str) {
        this.notify(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        this.outWrite(`${str}
`);
      }
      errWrite(str) {
        this.notify(`${this.prefix}err_write`, [str]);
      }
      errWriteLine(str) {
        this.notify(`${this.prefix}err_writeln`, [str]);
      }
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options2) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options2]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      uiSetOption(name2, value) {
        return this.request(`${this.prefix}ui_set_option`, [name2, value]);
      }
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      setClientInfo(name2, version2, type, methods2, attributes) {
        this.notify(`${this.prefix}set_client_info`, [
          name2,
          version2,
          type,
          methods2,
          attributes
        ]);
      }
      async quit() {
        this.command("qa!", true);
        if (this.transport) {
          this.transport.detach();
        }
      }
    };
    exports2.Neovim = Neovim2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NeovimClient = exports2.AsyncResponse = void 0;
    var nvim_1 = require_nvim();
    var vim_1 = require_vim();
    var constants_1 = require_constants2();
    var Buffer_1 = require_Buffer();
    var Neovim_1 = require_Neovim();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var events_1 = require("events");
    var functionsOnVim = [
      "nvim_buf_attach",
      "nvim_get_mode",
      "nvim_list_runtime_paths",
      "nvim_win_del_var",
      "nvim_create_buf",
      "nvim_exec",
      "nvim_tabpage_list_wins",
      "nvim_buf_del_var",
      "nvim_buf_get_mark",
      "nvim_tabpage_set_var",
      "nvim_create_namespace",
      "nvim_win_get_position",
      "nvim_win_set_height",
      "nvim_call_atomic",
      "nvim_buf_detach",
      "nvim_buf_line_count",
      "nvim_set_current_buf",
      "nvim_set_current_dir",
      "nvim_get_var",
      "nvim_del_current_line",
      "nvim_win_set_width",
      "nvim_out_write",
      "nvim_win_is_valid",
      "nvim_set_current_win",
      "nvim_get_current_tabpage",
      "nvim_tabpage_is_valid",
      "nvim_set_var",
      "nvim_win_get_height",
      "nvim_win_get_buf",
      "nvim_win_get_width",
      "nvim_buf_set_name",
      "nvim_subscribe",
      "nvim_get_current_win",
      "nvim_feedkeys",
      "nvim_get_vvar",
      "nvim_tabpage_get_number",
      "nvim_get_current_buf",
      "nvim_win_get_option",
      "nvim_win_get_cursor",
      "nvim_get_current_line",
      "nvim_win_get_var",
      "nvim_buf_get_var",
      "nvim_set_current_tabpage",
      "nvim_buf_clear_namespace",
      "nvim_err_write",
      "nvim_del_var",
      "nvim_call_dict_function",
      "nvim_set_current_line",
      "nvim_get_api_info",
      "nvim_unsubscribe",
      "nvim_get_option",
      "nvim_list_wins",
      "nvim_set_client_info",
      "nvim_win_set_cursor",
      "nvim_win_set_option",
      "nvim_eval",
      "nvim_tabpage_get_var",
      "nvim_buf_get_option",
      "nvim_tabpage_del_var",
      "nvim_buf_get_name",
      "nvim_list_bufs",
      "nvim_win_set_buf",
      "nvim_win_close",
      "nvim_command_output",
      "nvim_command",
      "nvim_tabpage_get_win",
      "nvim_win_set_var",
      "nvim_buf_add_highlight",
      "nvim_buf_set_var",
      "nvim_win_get_number",
      "nvim_strwidth",
      "nvim_buf_set_lines",
      "nvim_err_writeln",
      "nvim_buf_set_option",
      "nvim_list_tabpages",
      "nvim_set_option",
      "nvim_buf_get_lines",
      "nvim_buf_get_changedtick",
      "nvim_win_get_tabpage",
      "nvim_call_function",
      "nvim_buf_is_valid"
    ];
    var AsyncResponse = class {
      constructor(requestId, cb) {
        this.requestId = requestId;
        this.cb = cb;
        this.finished = false;
      }
      finish(err, res) {
        if (this.finished)
          return;
        this.finished = true;
        if (err) {
          this.cb(new Error(err));
          return;
        }
        this.cb(null, res);
      }
    };
    exports2.AsyncResponse = AsyncResponse;
    function applyMixins(derivedCtor, constructors) {
      constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
          Object.defineProperty(derivedCtor.prototype, name2, Object.getOwnPropertyDescriptor(baseCtor.prototype, name2) || /* @__PURE__ */ Object.create(null));
        });
      });
    }
    var NeovimClient = class extends Neovim_1.Neovim {
      constructor(logger57, isVim2) {
        super({});
        this.logger = logger57;
        this.isVim = isVim2;
        this.requestId = 1;
        this.responses = /* @__PURE__ */ new Map();
        this.attachedBuffers = /* @__PURE__ */ new Map();
        this._transport = isVim2 ? new vim_1.VimTransport(logger57) : new nvim_1.NvimTransport(logger57);
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      get transport() {
        return this._transport;
      }
      echoError(msg) {
        let prefix = constants_1.isCocNvim ? "[coc.nvim] " : "";
        if (msg instanceof Error) {
          if (!constants_1.isTester)
            this.errWriteLine(prefix + msg.message + " use :CocOpenLog for details");
          this.logError(msg.message || "Unknown error", msg);
        } else {
          if (!constants_1.isTester)
            this.errWriteLine(prefix + msg);
          this.logError(msg.toString(), new Error());
        }
      }
      logError(msg, ...args) {
        if (constants_1.isTester)
          console.error(msg, ...args);
        if (!this.logger)
          return;
        this.logger.error(msg, ...args);
      }
      createBuffer(id) {
        return new Buffer_1.Buffer({
          data: id,
          client: this
        });
      }
      createWindow(id) {
        return new Window_1.Window({
          data: id,
          client: this
        });
      }
      createTabpage(id) {
        return new Tabpage_1.Tabpage({
          data: id,
          client: this
        });
      }
      redrawVim(force) {
        if (!this.isVim)
          return;
        this.transport.notify("nvim_command", ["redraw" + (force ? "!" : "")]);
      }
      attach({ reader, writer }, requestApi = true) {
        this.transport.attach(writer, reader, this);
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        if (requestApi) {
          this._isReady = this.generateApi().catch((err) => {
            this.logger.error(err);
            return false;
          });
        } else {
          this._channelId = -1;
          this._isReady = Promise.resolve(true);
        }
      }
      detach() {
        this.attachedBuffers.clear();
        this.transport.detach();
        this.removeAllListeners();
      }
      get channelId() {
        return this._isReady.then(() => {
          return this._channelId;
        });
      }
      handleRequest(method, args, resp) {
        this.emit("request", method, args, resp);
      }
      sendAsyncRequest(method, args) {
        let id = this.requestId;
        this.requestId = id + 1;
        this.notify("nvim_call_function", ["coc#rpc#async_request", [id, method, args || []]]);
        return new Promise((resolve, reject) => {
          let response = new AsyncResponse(id, (err, res) => {
            if (err)
              return reject(err);
            resolve(res);
          });
          this.responses.set(id, response);
        });
      }
      handleNotification(method, args) {
        if (method.endsWith("_event")) {
          if (method.startsWith("nvim_buf_")) {
            const shortName = method.replace(/nvim_buf_(.*)_event/, "$1");
            const { id } = args[0];
            if (!this.attachedBuffers.has(id))
              return;
            const bufferMap = this.attachedBuffers.get(id);
            const cbs = bufferMap.get(shortName) || [];
            cbs.forEach((cb) => cb(...args));
            if (shortName === "detach") {
              this.attachedBuffers.delete(id);
            }
            return;
          }
          if (method == "nvim_async_request_event") {
            const [id, method2, arr] = args;
            this.handleRequest(method2, arr, {
              send: (resp, isError) => {
                this.notify("nvim_call_function", ["coc#rpc#async_response", [id, resp, isError]]);
              }
            });
            return;
          }
          if (method == "nvim_async_response_event") {
            const [id, err, res] = args;
            const response = this.responses.get(id);
            if (!response) {
              this.logError(`Response not found for request ${id}`);
              return;
            }
            this.responses.delete(id);
            response.finish(err, res);
            return;
          }
          if (method === "nvim_error_event") {
            this.logger.error(`Error event from nvim:`, args[0], args[1]);
            this.emit("vim_error", args[1]);
            return;
          }
          this.logger.warn(`Unhandled event: ${method}`, args);
        } else {
          this.emit("notification", method, args);
        }
      }
      requestApi() {
        return new Promise((resolve, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
            } else {
              resolve(res);
            }
          });
        });
      }
      async generateApi() {
        let results = await this.requestApi();
        const [channelId, metadata] = results;
        this._channelId = channelId;
        return true;
      }
      attachBufferEvent(bufnr, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(bufnr) || /* @__PURE__ */ new Map();
        const cbs = bufferMap.get(eventName) || [];
        if (cbs.includes(cb))
          return;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(bufnr, bufferMap);
        return;
      }
      detachBufferEvent(bufnr, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(bufnr);
        if (!bufferMap || !bufferMap.has(eventName))
          return;
        const handlers = bufferMap.get(eventName).filter((handler) => handler !== cb);
        bufferMap.set(eventName, handlers);
      }
      pauseNotification() {
        let o = {};
        Error.captureStackTrace(o);
        if (this.transport.pauseLevel != 0) {
          this.logError(`Nested nvim.pauseNotification() detected, please avoid it:`, o.stack);
        }
        this.transport.pauseNotification();
        process.nextTick(() => {
          if (this.transport.pauseLevel > 0) {
            this.logError(`resumeNotification not called within same tick:`, o.stack);
          }
        });
      }
      resumeNotification(redrawVim, notify) {
        if (this.isVim && redrawVim) {
          this.transport.notify("nvim_command", ["redraw"]);
        }
        if (notify) {
          this.transport.resumeNotification(true);
          return Promise.resolve(null);
        }
        return this.transport.resumeNotification();
      }
      hasFunction(name2) {
        if (!this.isVim)
          return true;
        return functionsOnVim.includes(name2);
      }
    };
    exports2.NeovimClient = NeovimClient;
    applyMixins(NeovimClient, [events_1.EventEmitter]);
  }
});

// node_modules/@chemzqm/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/@chemzqm/neovim/lib/attach/attach.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attach = void 0;
    var net_1 = require("net");
    var client_1 = require_client();
    var logger_1 = require_logger();
    function attach2({ reader: _reader, writer: _writer, proc, socket }, logger57 = null, requestApi = true) {
      let writer;
      let reader;
      let neovim;
      if (!logger57)
        logger57 = logger_1.nullLogger;
      if (socket) {
        const client = (0, net_1.createConnection)(socket);
        writer = client;
        reader = client;
        client.once("close", () => {
          neovim.detach();
        });
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
        proc.once("disconnect", () => {
          neovim.detach();
        });
      }
      writer.on("error", (err) => {
        if (err.code == "EPIPE") {
          neovim.detach();
        }
      });
      if (writer && reader) {
        neovim = new client_1.NeovimClient(logger57, process.env.VIM_NODE_RPC == "1");
        neovim.attach({
          writer,
          reader
        }, requestApi);
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
    exports2.attach = attach2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = exports2.Window = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var client_2 = require_client();
    Object.defineProperty(exports2, "NeovimClient", { enumerable: true, get: function() {
      return client_2.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/@chemzqm/neovim/lib/index.js
var require_lib = __commonJS({
  "node_modules/@chemzqm/neovim/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = exports2.Tabpage = exports2.Buffer = exports2.Neovim = exports2.attach = void 0;
    var attach_1 = require_attach();
    Object.defineProperty(exports2, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
    var index_1 = require_api();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
  }
});

// node_modules/vscode-uri/lib/esm/index.js
var LIB, URI, Utils;
var init_esm = __esm({
  "node_modules/vscode-uri/lib/esm/index.js"() {
    (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", o = 0, i = -1, a = 0, h = 0; h <= t3.length; ++h) {
            if (h < t3.length)
              r3 = t3.charCodeAt(h);
            else {
              if (47 === r3)
                break;
              r3 = 47;
            }
            if (47 === r3) {
              if (i === h - 1 || 1 === a)
                ;
              else if (i !== h - 1 && 2 === a) {
                if (n3.length < 2 || 2 !== o || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var s = n3.lastIndexOf("/");
                    if (s !== n3.length - 1) {
                      -1 === s ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, s)).length - 1 - n3.lastIndexOf("/"), i = h, a = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", o = 0, i = h, a = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
              } else
                n3.length > 0 ? n3 += "/" + t3.slice(i + 1, h) : n3 = t3.slice(i + 1, h), o = h - i - 1;
              i = h, a = 0;
            } else
              46 === r3 && -1 !== a ? ++a : a = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var a;
            i >= 0 ? a = arguments[i] : (void 0 === t3 && (t3 = process.cwd()), a = t3), e2(a), 0 !== a.length && (n3 = a + "/" + n3, o = 47 === a.charCodeAt(0));
          }
          return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          var n3 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var o = arguments[r3];
            e2(o), o.length > 0 && (void 0 === t3 ? t3 = o : t3 += "/" + o);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
            return "";
          for (var o = 1; o < t3.length && 47 === t3.charCodeAt(o); ++o)
            ;
          for (var i = t3.length, a = i - o, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h)
            ;
          for (var s = r3.length - h, c = a < s ? a : s, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (s > c) {
                if (47 === r3.charCodeAt(h + u))
                  return r3.slice(h + u + 1);
                if (0 === u)
                  return r3.slice(h + u);
              } else
                a > c && (47 === t3.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(o + u);
            if (l !== r3.charCodeAt(h + u))
              break;
            47 === l && (f = u);
          }
          var p = "";
          for (u = o + f + 1; u <= i; ++u)
            u !== i && 47 !== t3.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
            if (47 === (r3 = t3.charCodeAt(a))) {
              if (!i) {
                o = a;
                break;
              }
            } else
              i = false;
          return -1 === o ? n3 ? "/" : "." : n3 && 1 === o ? "//" : t3.slice(0, o);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3)
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, o = 0, i = -1, a = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var h = r3.length - 1, s = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!a) {
                  o = n3 + 1;
                  break;
                }
              } else
                -1 === s && (a = false, s = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (i = n3) : (h = -1, i = s));
            }
            return o === i ? i = s : -1 === i && (i = t3.length), t3.slice(o, i);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3)
            if (47 === t3.charCodeAt(n3)) {
              if (!a) {
                o = n3 + 1;
                break;
              }
            } else
              -1 === i && (a = false, i = n3 + 1);
          return -1 === i ? "" : t3.slice(o, i);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, o = -1, i = true, a = 0, h = t3.length - 1; h >= 0; --h) {
            var s = t3.charCodeAt(h);
            if (47 !== s)
              -1 === o && (i = false, o = h + 1), 46 === s ? -1 === r3 ? r3 = h : 1 !== a && (a = 1) : -1 !== r3 && (a = -1);
            else if (!i) {
              n3 = h + 1;
              break;
            }
          }
          return -1 === r3 || -1 === o || 0 === a || 1 === a && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3)
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length)
            return r3;
          var n3, o = t3.charCodeAt(0), i = 47 === o;
          i ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var a = -1, h = 0, s = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
            if (47 !== (o = t3.charCodeAt(f)))
              -1 === s && (c = false, s = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
            else if (!c) {
              h = f + 1;
              break;
            }
          return -1 === a || -1 === s || 0 === u || 1 === u && a === s - 1 && a === h + 1 ? -1 !== s && (r3.base = r3.name = 0 === h && i ? t3.slice(1, s) : t3.slice(h, s)) : (0 === h && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a, s)), h > 0 ? r3.dir = t3.slice(0, h - 1) : i && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      } }, e = {};
      function r(n2) {
        var o = e[n2];
        if (void 0 !== o)
          return o.exports;
        var i = e[n2] = { exports: {} };
        return t[n2](i, i.exports, r), i.exports;
      }
      r.d = (t2, e2) => {
        for (var n2 in e2)
          r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
      }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var n = {};
      (() => {
        var t2;
        if (r.r(n), r.d(n, { URI: () => g, Utils: () => O }), "object" == typeof process)
          t2 = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          var e2 = navigator.userAgent;
          t2 = e2.indexOf("Windows") >= 0;
        }
        var o, i, a = (o = function(t3, e3) {
          return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var r2 in e4)
              Object.prototype.hasOwnProperty.call(e4, r2) && (t4[r2] = e4[r2]);
          }, o(t3, e3);
        }, function(t3, e3) {
          if ("function" != typeof e3 && null !== e3)
            throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
          function r2() {
            this.constructor = t3;
          }
          o(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r2.prototype = e3.prototype, new r2());
        }), h = /^\w[\w\d+.-]*$/, s = /^\//, c = /^\/\//;
        function f(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
          if (t3.scheme && !h.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!s.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (c.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, g = function() {
          function e3(t3, e4, r2, n2, o2, i2) {
            void 0 === i2 && (i2 = false), "object" == typeof t3 ? (this.scheme = t3.scheme || u, this.authority = t3.authority || u, this.path = t3.path || u, this.query = t3.query || u, this.fragment = t3.fragment || u) : (this.scheme = function(t4, e5) {
              return t4 || e5 ? t4 : "file";
            }(t3, i2), this.authority = e4 || u, this.path = function(t4, e5) {
              switch (t4) {
                case "https":
                case "http":
                case "file":
                  e5 ? e5[0] !== l && (e5 = l + e5) : e5 = l;
              }
              return e5;
            }(this.scheme, r2 || u), this.query = n2 || u, this.fragment = o2 || u, f(this, i2));
          }
          return e3.isUri = function(t3) {
            return t3 instanceof e3 || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
          }, Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return C(this, false);
          }, enumerable: false, configurable: true }), e3.prototype.with = function(t3) {
            if (!t3)
              return this;
            var e4 = t3.scheme, r2 = t3.authority, n2 = t3.path, o2 = t3.query, i2 = t3.fragment;
            return void 0 === e4 ? e4 = this.scheme : null === e4 && (e4 = u), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = u), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = u), void 0 === o2 ? o2 = this.query : null === o2 && (o2 = u), void 0 === i2 ? i2 = this.fragment : null === i2 && (i2 = u), e4 === this.scheme && r2 === this.authority && n2 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e4, r2, n2, o2, i2);
          }, e3.parse = function(t3, e4) {
            void 0 === e4 && (e4 = false);
            var r2 = p.exec(t3);
            return r2 ? new v(r2[2] || u, _(r2[4] || u), _(r2[5] || u), _(r2[7] || u), _(r2[9] || u), e4) : new v(u, u, u, u, u);
          }, e3.file = function(e4) {
            var r2 = u;
            if (t2 && (e4 = e4.replace(/\\/g, l)), e4[0] === l && e4[1] === l) {
              var n2 = e4.indexOf(l, 2);
              -1 === n2 ? (r2 = e4.substring(2), e4 = l) : (r2 = e4.substring(2, n2), e4 = e4.substring(n2) || l);
            }
            return new v("file", r2, e4, u, u);
          }, e3.from = function(t3) {
            var e4 = new v(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
            return f(e4, true), e4;
          }, e3.prototype.toString = function(t3) {
            return void 0 === t3 && (t3 = false), A(this, t3);
          }, e3.prototype.toJSON = function() {
            return this;
          }, e3.revive = function(t3) {
            if (t3) {
              if (t3 instanceof e3)
                return t3;
              var r2 = new v(t3);
              return r2._formatted = t3.external, r2._fsPath = t3._sep === d ? t3.fsPath : null, r2;
            }
            return t3;
          }, e3;
        }(), d = t2 ? 1 : void 0, v = function(t3) {
          function e3() {
            var e4 = null !== t3 && t3.apply(this, arguments) || this;
            return e4._formatted = null, e4._fsPath = null, e4;
          }
          return a(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
          }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), t4 ? A(this, true) : (this._formatted || (this._formatted = A(this, false)), this._formatted);
          }, e3.prototype.toJSON = function() {
            var t4 = { $mid: 1 };
            return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = d), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
          }, e3;
        }(g), y = ((i = {})[58] = "%3A", i[47] = "%2F", i[63] = "%3F", i[35] = "%23", i[91] = "%5B", i[93] = "%5D", i[64] = "%40", i[33] = "%21", i[36] = "%24", i[38] = "%26", i[39] = "%27", i[40] = "%28", i[41] = "%29", i[42] = "%2A", i[43] = "%2B", i[44] = "%2C", i[59] = "%3B", i[61] = "%3D", i[32] = "%20", i);
        function m(t3, e3, r2) {
          for (var n2 = void 0, o2 = -1, i2 = 0; i2 < t3.length; i2++) {
            var a2 = t3.charCodeAt(i2);
            if (a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 >= 48 && a2 <= 57 || 45 === a2 || 46 === a2 || 95 === a2 || 126 === a2 || e3 && 47 === a2 || r2 && 91 === a2 || r2 && 93 === a2 || r2 && 58 === a2)
              -1 !== o2 && (n2 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), void 0 !== n2 && (n2 += t3.charAt(i2));
            else {
              void 0 === n2 && (n2 = t3.substr(0, i2));
              var h2 = y[a2];
              void 0 !== h2 ? (-1 !== o2 && (n2 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), n2 += h2) : -1 === o2 && (o2 = i2);
            }
          }
          return -1 !== o2 && (n2 += encodeURIComponent(t3.substring(o2))), void 0 !== n2 ? n2 : t3;
        }
        function b(t3) {
          for (var e3 = void 0, r2 = 0; r2 < t3.length; r2++) {
            var n2 = t3.charCodeAt(r2);
            35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += y[n2]) : void 0 !== e3 && (e3 += t3[r2]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function C(e3, r2) {
          var n2;
          return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? "//".concat(e3.authority).concat(e3.path) : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
        }
        function A(t3, e3) {
          var r2 = e3 ? b : m, n2 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, h2 = t3.query, s2 = t3.fragment;
          if (o2 && (n2 += o2, n2 += ":"), (i2 || "file" === o2) && (n2 += l, n2 += l), i2) {
            var c2 = i2.indexOf("@");
            if (-1 !== c2) {
              var f2 = i2.substr(0, c2);
              i2 = i2.substr(c2 + 1), -1 === (c2 = f2.lastIndexOf(":")) ? n2 += r2(f2, false, false) : (n2 += r2(f2.substr(0, c2), false, false), n2 += ":", n2 += r2(f2.substr(c2 + 1), false, true)), n2 += "@";
            }
            -1 === (c2 = (i2 = i2.toLowerCase()).lastIndexOf(":")) ? n2 += r2(i2, false, true) : (n2 += r2(i2.substr(0, c2), false, true), n2 += i2.substr(c2));
          }
          if (a2) {
            if (a2.length >= 3 && 47 === a2.charCodeAt(0) && 58 === a2.charCodeAt(2))
              (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
            else if (a2.length >= 2 && 58 === a2.charCodeAt(1)) {
              var u2;
              (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
            }
            n2 += r2(a2, true, false);
          }
          return h2 && (n2 += "?", n2 += r2(h2, false, false)), s2 && (n2 += "#", n2 += e3 ? s2 : m(s2, false, false)), n2;
        }
        function w(t3) {
          try {
            return decodeURIComponent(t3);
          } catch (e3) {
            return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
          }
        }
        var x = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function _(t3) {
          return t3.match(x) ? t3.replace(x, function(t4) {
            return w(t4);
          }) : t3;
        }
        var O, P = r(470), j = function(t3, e3, r2) {
          if (r2 || 2 === arguments.length)
            for (var n2, o2 = 0, i2 = e3.length; o2 < i2; o2++)
              !n2 && o2 in e3 || (n2 || (n2 = Array.prototype.slice.call(e3, 0, o2)), n2[o2] = e3[o2]);
          return t3.concat(n2 || Array.prototype.slice.call(e3));
        }, I = P.posix || P, U = "/";
        !function(t3) {
          t3.joinPath = function(t4) {
            for (var e3 = [], r2 = 1; r2 < arguments.length; r2++)
              e3[r2 - 1] = arguments[r2];
            return t4.with({ path: I.join.apply(I, j([t4.path], e3, false)) });
          }, t3.resolvePath = function(t4) {
            for (var e3 = [], r2 = 1; r2 < arguments.length; r2++)
              e3[r2 - 1] = arguments[r2];
            var n2 = t4.path, o2 = false;
            n2[0] !== U && (n2 = U + n2, o2 = true);
            var i2 = I.resolve.apply(I, j([n2], e3, false));
            return o2 && i2[0] === U && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
          }, t3.dirname = function(t4) {
            if (0 === t4.path.length || t4.path === U)
              return t4;
            var e3 = I.dirname(t4.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return I.basename(t4.path);
          }, t3.extname = function(t4) {
            return I.extname(t4.path);
          };
        }(O || (O = {}));
      })(), LIB = n;
    })();
    ({ URI, Utils } = LIB);
  }
});

// src/util/errors.ts
function assert(condition) {
  if (!condition) {
    throw new BugIndicatingError("Assertion Failed");
  }
}
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
function notLoaded(uri) {
  return new Error(`File ${uri} not loaded`);
}
function illegalArgument(name2) {
  if (name2) {
    return new Error(`Illegal argument: ${name2}`);
  } else {
    return new Error("Illegal argument");
  }
}
function directoryNotExists(dir) {
  return new Error(`Directory ${dir} not exists`);
}
function fileExists(filepath) {
  return new Error(`File ${filepath} already exists`);
}
function fileNotExists(filepath) {
  return new Error(`File ${filepath} not exists`);
}
function shouldNotAsync(method) {
  return new Error(`${method} should not be called in an asynchronize manner`);
}
function badScheme(uri) {
  return new Error(`Change of ${uri} not supported`);
}
var canceledName, CancellationError, BugIndicatingError;
var init_errors = __esm({
  "src/util/errors.ts"() {
    "use strict";
    canceledName = "Canceled";
    CancellationError = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
    BugIndicatingError = class extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, BugIndicatingError.prototype);
        debugger;
      }
    };
  }
});

// src/util/is.ts
function isUrl(url) {
  try {
    new import_url.URL(url);
    return true;
  } catch (e) {
    return false;
  }
}
function isCommand(obj) {
  if (!obj || !string(obj.title) || !string(obj.command) || obj.command.length == 0)
    return false;
  return true;
}
function isMarkdown(content) {
  if (content != null && content["kind"] == "markdown") {
    return true;
  }
  return false;
}
function isCompletionItem(obj) {
  return obj && typeof obj.label === "string";
}
function isCompletionList(obj) {
  return !Array.isArray(obj) && Array.isArray(obj.items);
}
function boolean(value) {
  return typeof value === "boolean";
}
function string(value) {
  return typeof value === "string";
}
function number(value) {
  return typeof value === "number";
}
function func(value) {
  return typeof value == "function";
}
function objectLiteral(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
var import_url;
var init_is = __esm({
  "src/util/is.ts"() {
    "use strict";
    import_url = require("url");
  }
});

// src/util/object.ts
function isEmpty(obj) {
  if (!obj)
    return true;
  if (Array.isArray(obj))
    return obj.length == 0;
  return Object.keys(obj).length == 0;
}
function toObject(obj) {
  return obj == null ? {} : obj;
}
function omitUndefined(obj) {
  const result = {};
  Object.entries(obj).forEach(([key, val]) => {
    if (val !== void 0)
      result[key] = val;
  });
  return result;
}
function deepIterate(obj, fn) {
  Object.entries(obj).forEach(([key, val]) => {
    fn(obj, key);
    if (Array.isArray(val)) {
      val.forEach((node) => {
        if (objectLiteral(node)) {
          deepIterate(node, fn);
        }
      });
    } else if (objectLiteral(val)) {
      deepIterate(val, fn);
    }
  });
  return obj;
}
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    let obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key of Object.keys(obj2)) {
      let prop = obj2[key];
      if (typeof prop === "object" && !Object.isFrozen(prop)) {
        stack.push(prop);
      }
    }
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!objectLiteral(destination)) {
    return source;
  }
  if (objectLiteral(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (objectLiteral(destination[key]) && objectLiteral(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
var _hasOwnProperty;
var init_object = __esm({
  "src/util/object.ts"() {
    "use strict";
    init_is();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL2() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL3) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL3.install = install;
    })(RAL2 || (RAL2 = {}));
    exports2.default = RAL2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable38;
    (function(Disposable39) {
      function create(func2) {
        return {
          dispose: func2
        };
      }
      Disposable39.create = create;
    })(Disposable38 = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding2 = "utf-8") {
        this._encoding = encoding2;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding2 = "utf-8") {
        super(encoding2);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding2) {
        return Buffer.from(value, encoding2);
      }
      toString(value, encoding2) {
        if (value instanceof Buffer) {
          return value.toString(encoding2);
        } else {
          return new util_1.TextDecoder(encoding2).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding2) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding2, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding2) => new MessageBuffer(encoding2)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options2) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options2.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options2) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options2.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options2.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes2;
    (function(ErrorCodes3) {
      ErrorCodes3.ParseError = -32700;
      ErrorCodes3.InvalidRequest = -32600;
      ErrorCodes3.MethodNotFound = -32601;
      ErrorCodes3.InvalidParams = -32602;
      ErrorCodes3.InternalError = -32603;
      ErrorCodes3.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes3.serverErrorStart = -32099;
      ErrorCodes3.MessageWriteError = -32099;
      ErrorCodes3.MessageReadError = -32098;
      ErrorCodes3.PendingResponseRejected = -32097;
      ErrorCodes3.ConnectionInactive = -32096;
      ErrorCodes3.ServerNotInitialized = -32002;
      ErrorCodes3.UnknownErrorCode = -32001;
      ErrorCodes3.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes3.serverErrorEnd = -32e3;
    })(ErrorCodes2 = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError2 = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes2.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError2.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError2;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType02 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType02;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType2;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType2;
    var NotificationType02 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType02;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType22;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message = exports2.Message || (exports2.Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch2;
    (function(Touch3) {
      Touch3.None = 0;
      Touch3.First = 1;
      Touch3.AsOld = Touch3.First;
      Touch3.Last = 2;
      Touch3.AsNew = Touch3.Last;
    })(Touch2 = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap2 = class {
      constructor() {
        this[_a2] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a3;
        return (_a3 = this._head) == null ? void 0 : _a3.value;
      }
      get last() {
        var _a3;
        return (_a3 = this._tail) == null ? void 0 : _a3.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch2.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch2.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch2.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch2.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch2.None:
              this.addItemLast(item);
              break;
            case Touch2.First:
              this.addItemFirst(item);
              break;
            case Touch2.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch2.First && touch !== Touch2.Last) {
          return;
        }
        if (touch === Touch2.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch2.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap2;
    var LRUCache2 = class extends LinkedMap2 {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch2.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch2.None);
      }
      set(key, value) {
        super.set(key, value, Touch2.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event45;
    (function(Event46) {
      const _disposable = { dispose() {
      } };
      Event46.None = function() {
        return _disposable;
      };
    })(Event45 = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter2 = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter2._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter2;
    Emitter2._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var CancellationToken22;
    (function(CancellationToken23) {
      CancellationToken23.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken23.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken23.None || candidate === CancellationToken23.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken23.is = is;
    })(CancellationToken22 = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource2 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken22.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken22.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var MessageReader2;
    (function(MessageReader3) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader3.is = is;
    })(MessageReader2 = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options2) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options2 === void 0 || typeof options2 === "string") {
          charset = options2 ?? "utf-8";
        } else {
          charset = options2.charset ?? "utf-8";
          if (options2.contentDecoder !== void 0) {
            contentDecoder = options2.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options2.contentDecoders !== void 0) {
            for (const decoder of options2.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options2.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options2.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options2.contentTypeDecoders !== void 0) {
            for (const decoder of options2.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options2) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options2);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout2) {
        this._partialMessageTimeout = timeout2;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout2) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout2 });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter2;
    (function(MessageWriter3) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter3.is = is;
    })(MessageWriter2 = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options2) {
        if (options2 === void 0 || typeof options2 === "string") {
          return { charset: options2 ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options2.charset ?? "utf-8", contentEncoder: options2.contentEncoder, contentTypeEncoder: options2.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options2) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options2);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
    var ProgressNotification2;
    (function(ProgressNotification3) {
      ProgressNotification3.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification2 || (ProgressNotification2 = {}));
    var ProgressType2 = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType2;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace2;
    (function(Trace3) {
      Trace3[Trace3["Off"] = 0] = "Off";
      Trace3[Trace3["Messages"] = 1] = "Messages";
      Trace3[Trace3["Compact"] = 2] = "Compact";
      Trace3[Trace3["Verbose"] = 3] = "Verbose";
    })(Trace2 = exports2.Trace || (exports2.Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues = exports2.TraceValues || (exports2.TraceValues = {}));
    (function(Trace3) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace3.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace3.Off;
          case "messages":
            return Trace3.Messages;
          case "compact":
            return Trace3.Compact;
          case "verbose":
            return Trace3.Verbose;
          default:
            return Trace3.Off;
        }
      }
      Trace3.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace3.Off:
            return "off";
          case Trace3.Messages:
            return "messages";
          case Trace3.Compact:
            return "compact";
          case Trace3.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace3.toString = toString;
    })(Trace2 = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat2;
    (function(TraceFormat3) {
      TraceFormat3["Text"] = "text";
      TraceFormat3["JSON"] = "json";
    })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat3) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return TraceFormat3.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat3.JSON;
        } else {
          return TraceFormat3.Text;
        }
      }
      TraceFormat3.fromString = fromString;
    })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options2) {
      const logger57 = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace2.Off;
      let traceFormat = TraceFormat2.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options2 && options2.cancellationStrategy ? options2.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options2 == null ? void 0 : options2.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger57.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger57.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger57.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger57.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger57.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger57.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger57.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger57.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger57.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification2.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger57.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger57.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger57.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger57.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger57.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger57.error("Received empty message.");
          return;
        }
        logger57.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace2.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace2.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if ((trace === Trace2.Verbose || trace === Trace2.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if ((trace === Trace2.Verbose || trace === Trace2.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace2.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch(() => logger57.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification2.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger57.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger57.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version2,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage).catch(() => logger57.error(`Sending request failed.`));
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises.set(id, responsePromise);
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat2.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat2.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace2.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace2.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is2.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace2.Verbose || trace === Trace2.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification2.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api2();
    var path2 = require("path");
    var os2 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api2(), exports2);
    var IPCMessageReader2 = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader2;
    var IPCMessageWriter2 = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter2;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding2 = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding2);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options2) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options2);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader2 = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding2) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding2);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader2;
    var StreamMessageWriter2 = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options2) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options2);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter2;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName2() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path2.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path2.join(os2.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName2;
    function createClientPipeTransport2(pipeName, encoding2 = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding2),
            new SocketMessageWriter(socket, encoding2)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport2;
    function createServerPipeTransport(pipeName, encoding2 = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding2),
        new SocketMessageWriter(socket, encoding2)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport2(port, encoding2 = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding2),
            new SocketMessageWriter(socket, encoding2)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport2;
    function createServerSocketTransport(port, encoding2 = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding2),
        new SocketMessageWriter(socket, encoding2)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger57, options2) {
      if (!logger57) {
        logger57 = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader2(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter2(output) : output;
      if (api_1.ConnectionStrategy.is(options2)) {
        options2 = { connectionStrategy: options2 };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger57, options2);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeActionTriggerKind: () => CodeActionTriggerKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemLabelDetails: () => CompletionItemLabelDetails,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  DocumentUri: () => DocumentUri,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InlayHint: () => InlayHint,
  InlayHintKind: () => InlayHintKind,
  InlayHintLabelPart: () => InlayHintLabelPart,
  InlineValueContext: () => InlineValueContext,
  InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
  InlineValueText: () => InlineValueText,
  InlineValueVariableLookup: () => InlineValueVariableLookup,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectionRange: () => SelectionRange,
  SemanticTokenModifiers: () => SemanticTokenModifiers,
  SemanticTokenTypes: () => SemanticTokenTypes,
  SemanticTokens: () => SemanticTokens,
  SignatureInformation: () => SignatureInformation,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  URI: () => URI2,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  WorkspaceFolder: () => WorkspaceFolder,
  WorkspaceSymbol: () => WorkspaceSymbol,
  integer: () => integer,
  uinteger: () => uinteger
});
var DocumentUri, URI2, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, WorkspaceFolder, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (DocumentUri = {}));
    (function(URI3) {
      function is(value) {
        return typeof value === "string";
      }
      URI3.is = is;
    })(URI2 || (URI2 = {}));
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
      }
      integer2.is = is;
    })(integer || (integer = {}));
    (function(uinteger3) {
      uinteger3.MIN_VALUE = 0;
      uinteger3.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
      }
      uinteger3.is = is;
    })(uinteger || (uinteger = {}));
    (function(Position10) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position10.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position10.is = is;
    })(Position || (Position = {}));
    (function(Range13) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
      }
      Range13.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range13.is = is;
    })(Range || (Range = {}));
    (function(Location3) {
      function create(uri, range) {
        return { uri, range };
      }
      Location3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location3.is = is;
    })(Location || (Location = {}));
    (function(LocationLink3) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink3.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color2) {
      function create(red, green, blue2, alpha) {
        return {
          red,
          green,
          blue: blue2,
          alpha
        };
      }
      Color2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color2.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation3) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation3.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation3) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation3.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind3) {
      FoldingRangeKind3.Comment = "comment";
      FoldingRangeKind3.Imports = "imports";
      FoldingRangeKind3.Region = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange3) {
      function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
          result.collapsedText = collapsedText;
        }
        return result;
      }
      FoldingRange3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange3.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2.Error = 1;
      DiagnosticSeverity2.Warning = 2;
      DiagnosticSeverity2.Information = 3;
      DiagnosticSeverity2.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag2) {
      DiagnosticTag2.Unnecessary = 1;
      DiagnosticTag2.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic7) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic7.create = create;
      function is(value) {
        var _a2;
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic7.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command2) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command2.is = is;
    })(Command || (Command = {}));
    (function(TextEdit10) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit10.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit10.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit10.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit10.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation5) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation5.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation5.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        var candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile2) {
      function create(uri, options2, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile2) {
      function create(oldUri, newUri, options2, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile2) {
      function create(uri, options2, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options2 !== void 0 && (options2.recursive !== void 0 || options2.ignoreIfNotExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit7) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit7.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit2) {
        this.edits.push(edit2);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }();
    ChangeAnnotations = function() {
      function ChangeAnnotations2(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options2);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options2, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options2);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options2, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options2);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options2, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange2;
    }();
    (function(TextDocumentIdentifier3) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier3.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version2, text) {
        return { uri, languageId, version: version2, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind2) {
      MarkupKind2.PlainText = "plaintext";
      MarkupKind2.Markdown = "markdown";
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
      }
      MarkupKind2.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent2.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind2) {
      CompletionItemKind2.Text = 1;
      CompletionItemKind2.Method = 2;
      CompletionItemKind2.Function = 3;
      CompletionItemKind2.Constructor = 4;
      CompletionItemKind2.Field = 5;
      CompletionItemKind2.Variable = 6;
      CompletionItemKind2.Class = 7;
      CompletionItemKind2.Interface = 8;
      CompletionItemKind2.Module = 9;
      CompletionItemKind2.Property = 10;
      CompletionItemKind2.Unit = 11;
      CompletionItemKind2.Value = 12;
      CompletionItemKind2.Enum = 13;
      CompletionItemKind2.Keyword = 14;
      CompletionItemKind2.Snippet = 15;
      CompletionItemKind2.Color = 16;
      CompletionItemKind2.File = 17;
      CompletionItemKind2.Reference = 18;
      CompletionItemKind2.Folder = 19;
      CompletionItemKind2.EnumMember = 20;
      CompletionItemKind2.Constant = 21;
      CompletionItemKind2.Struct = 22;
      CompletionItemKind2.Event = 23;
      CompletionItemKind2.Operator = 24;
      CompletionItemKind2.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat2) {
      InsertTextFormat2.PlainText = 1;
      InsertTextFormat2.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag2) {
      CompletionItemTag2.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode3) {
      InsertTextMode3.asIs = 1;
      InsertTextMode3.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItemLabelDetails3) {
      function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      CompletionItemLabelDetails3.is = is;
    })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
    (function(CompletionItem5) {
      function create(label) {
        return { label };
      }
      CompletionItem5.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList3) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList3.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover3) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover3.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind2) {
      DocumentHighlightKind2.Text = 1;
      DocumentHighlightKind2.Read = 2;
      DocumentHighlightKind2.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight4) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight4.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind5) {
      SymbolKind5.File = 1;
      SymbolKind5.Module = 2;
      SymbolKind5.Namespace = 3;
      SymbolKind5.Package = 4;
      SymbolKind5.Class = 5;
      SymbolKind5.Method = 6;
      SymbolKind5.Property = 7;
      SymbolKind5.Field = 8;
      SymbolKind5.Constructor = 9;
      SymbolKind5.Enum = 10;
      SymbolKind5.Interface = 11;
      SymbolKind5.Function = 12;
      SymbolKind5.Variable = 13;
      SymbolKind5.Constant = 14;
      SymbolKind5.String = 15;
      SymbolKind5.Number = 16;
      SymbolKind5.Boolean = 17;
      SymbolKind5.Array = 18;
      SymbolKind5.Object = 19;
      SymbolKind5.Key = 20;
      SymbolKind5.Null = 21;
      SymbolKind5.EnumMember = 22;
      SymbolKind5.Struct = 23;
      SymbolKind5.Event = 24;
      SymbolKind5.Operator = 25;
      SymbolKind5.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag2) {
      SymbolTag2.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation9) {
      function create(name2, kind, range, uri, containerName) {
        var result = {
          name: name2,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation9.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(WorkspaceSymbol2) {
      function create(name2, kind, uri, range) {
        return range !== void 0 ? { name: name2, kind, location: { uri, range } } : { name: name2, kind, location: { uri } };
      }
      WorkspaceSymbol2.create = create;
    })(WorkspaceSymbol || (WorkspaceSymbol = {}));
    (function(DocumentSymbol6) {
      function create(name2, detail, kind, range, selectionRange, children) {
        var result = {
          name: name2,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol6.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol6.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind6) {
      CodeActionKind6.Empty = "";
      CodeActionKind6.QuickFix = "quickfix";
      CodeActionKind6.Refactor = "refactor";
      CodeActionKind6.RefactorExtract = "refactor.extract";
      CodeActionKind6.RefactorInline = "refactor.inline";
      CodeActionKind6.RefactorRewrite = "refactor.rewrite";
      CodeActionKind6.Source = "source";
      CodeActionKind6.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind6.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
    (function(CodeActionContext5) {
      function create(diagnostics, only, triggerKind) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        if (triggerKind !== void 0 && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext5.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext5.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction6) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction6.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction6.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens3) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens3.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions4) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions4.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink4) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink4.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange5) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange5.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange5.is(candidate.parent));
      }
      SelectionRange5.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
      SemanticTokenTypes2["decorator"] = "decorator";
    })(SemanticTokenTypes || (SemanticTokenTypes = {}));
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
    (function(SemanticTokens6) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens6.is = is;
    })(SemanticTokens || (SemanticTokens = {}));
    (function(InlineValueText2) {
      function create(range, text) {
        return { range, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (InlineValueText = {}));
    (function(InlineValueVariableLookup2) {
      function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
    (function(InlineValueEvaluatableExpression2) {
      function create(range, expression) {
        return { range, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
    (function(InlineValueContext3) {
      function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
      }
      InlineValueContext3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValueContext3.is = is;
    })(InlineValueContext || (InlineValueContext = {}));
    (function(InlayHintKind2) {
      InlayHintKind2.Type = 1;
      InlayHintKind2.Parameter = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      InlayHintKind2.is = is;
    })(InlayHintKind || (InlayHintKind = {}));
    (function(InlayHintLabelPart2) {
      function create(value) {
        return { value };
      }
      InlayHintLabelPart2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
      }
      InlayHintLabelPart2.is = is;
    })(InlayHintLabelPart || (InlayHintLabelPart = {}));
    (function(InlayHint3) {
      function create(position, label, kind) {
        var result = { position, label };
        if (kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      InlayHint3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
      }
      InlayHint3.is = is;
    })(InlayHint || (InlayHint = {}));
    (function(WorkspaceFolder2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
      }
      WorkspaceFolder2.is = is;
    })(WorkspaceFolder || (WorkspaceFolder = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument3) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument(uri, languageId, version2, content);
      }
      TextDocument3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument3.is = is;
      function applyEdits3(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort3(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document2.offsetAt(e.range.start);
          var endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument3.applyEdits = applyEdits3;
      function mergeSort3(data, compare2) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort3(left, compare2);
        mergeSort3(right, compare2);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare2(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(event, version2) {
        this._content = event.text;
        this._version = version2;
        this._lineOffsets = void 0;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument3;
    }();
    (function(Is2) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean2(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean2;
      function string2(value) {
        return toString.call(value) === "[object String]";
      }
      Is2.string = string2;
      function number2(value) {
        return toString.call(value) === "[object Number]";
      }
      Is2.number = number2;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger3(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger3;
      function func2(value) {
        return toString.call(value) === "[object Function]";
      }
      Is2.func = func2;
      function objectLiteral2(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral2;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection = exports2.MessageDirection || (exports2.MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType02 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType02;
    var ProtocolRequestType2 = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType2;
    var ProtocolNotificationType02 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType02;
    var ProtocolNotificationType2 = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral2(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest2;
    (function(ImplementationRequest3) {
      ImplementationRequest3.method = "textDocument/implementation";
      ImplementationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest3.type = new messages_1.ProtocolRequestType(ImplementationRequest3.method);
    })(ImplementationRequest2 = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest2;
    (function(TypeDefinitionRequest3) {
      TypeDefinitionRequest3.method = "textDocument/typeDefinition";
      TypeDefinitionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest3.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest3.method);
    })(TypeDefinitionRequest2 = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest2;
    (function(WorkspaceFoldersRequest3) {
      WorkspaceFoldersRequest3.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest3.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest3.method);
    })(WorkspaceFoldersRequest2 = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification2;
    (function(DidChangeWorkspaceFoldersNotification3) {
      DidChangeWorkspaceFoldersNotification3.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification3.method);
    })(DidChangeWorkspaceFoldersNotification2 = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest2;
    (function(ConfigurationRequest3) {
      ConfigurationRequest3.method = "workspace/configuration";
      ConfigurationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest3.type = new messages_1.ProtocolRequestType(ConfigurationRequest3.method);
    })(ConfigurationRequest2 = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest2;
    (function(DocumentColorRequest3) {
      DocumentColorRequest3.method = "textDocument/documentColor";
      DocumentColorRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest3.type = new messages_1.ProtocolRequestType(DocumentColorRequest3.method);
    })(DocumentColorRequest2 = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest2;
    (function(ColorPresentationRequest3) {
      ColorPresentationRequest3.method = "textDocument/colorPresentation";
      ColorPresentationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest3.type = new messages_1.ProtocolRequestType(ColorPresentationRequest3.method);
    })(ColorPresentationRequest2 = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest2;
    (function(FoldingRangeRequest3) {
      FoldingRangeRequest3.method = "textDocument/foldingRange";
      FoldingRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest3.type = new messages_1.ProtocolRequestType(FoldingRangeRequest3.method);
    })(FoldingRangeRequest2 = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest2;
    (function(DeclarationRequest3) {
      DeclarationRequest3.method = "textDocument/declaration";
      DeclarationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest3.type = new messages_1.ProtocolRequestType(DeclarationRequest3.method);
    })(DeclarationRequest2 = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest2;
    (function(SelectionRangeRequest3) {
      SelectionRangeRequest3.method = "textDocument/selectionRange";
      SelectionRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest3.type = new messages_1.ProtocolRequestType(SelectionRangeRequest3.method);
    })(SelectionRangeRequest2 = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress2;
    (function(WorkDoneProgress3) {
      WorkDoneProgress3.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress3.type;
      }
      WorkDoneProgress3.is = is;
    })(WorkDoneProgress2 = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest2;
    (function(WorkDoneProgressCreateRequest3) {
      WorkDoneProgressCreateRequest3.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest3.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest3.method);
    })(WorkDoneProgressCreateRequest2 = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification2;
    (function(WorkDoneProgressCancelNotification3) {
      WorkDoneProgressCancelNotification3.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification3.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification3.method);
    })(WorkDoneProgressCancelNotification2 = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest2;
    (function(CallHierarchyPrepareRequest3) {
      CallHierarchyPrepareRequest3.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest3.method);
    })(CallHierarchyPrepareRequest2 = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest2;
    (function(CallHierarchyIncomingCallsRequest3) {
      CallHierarchyIncomingCallsRequest3.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest3.method);
    })(CallHierarchyIncomingCallsRequest2 = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest2;
    (function(CallHierarchyOutgoingCallsRequest3) {
      CallHierarchyOutgoingCallsRequest3.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest3.method);
    })(CallHierarchyOutgoingCallsRequest2 = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat2;
    (function(TokenFormat3) {
      TokenFormat3.Relative = "relative";
    })(TokenFormat2 = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType2;
    (function(SemanticTokensRegistrationType3) {
      SemanticTokensRegistrationType3.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType3.type = new messages_1.RegistrationType(SemanticTokensRegistrationType3.method);
    })(SemanticTokensRegistrationType2 = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest2;
    (function(SemanticTokensRequest3) {
      SemanticTokensRequest3.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensRequest3.method);
      SemanticTokensRequest3.registrationMethod = SemanticTokensRegistrationType2.method;
    })(SemanticTokensRequest2 = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest2;
    (function(SemanticTokensDeltaRequest3) {
      SemanticTokensDeltaRequest3.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest3.method);
      SemanticTokensDeltaRequest3.registrationMethod = SemanticTokensRegistrationType2.method;
    })(SemanticTokensDeltaRequest2 = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest2;
    (function(SemanticTokensRangeRequest3) {
      SemanticTokensRangeRequest3.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest3.method);
      SemanticTokensRangeRequest3.registrationMethod = SemanticTokensRegistrationType2.method;
    })(SemanticTokensRangeRequest2 = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest2;
    (function(SemanticTokensRefreshRequest3) {
      SemanticTokensRefreshRequest3.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRefreshRequest3.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest3.method);
    })(SemanticTokensRefreshRequest2 = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest2;
    (function(ShowDocumentRequest3) {
      ShowDocumentRequest3.method = "window/showDocument";
      ShowDocumentRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest3.type = new messages_1.ProtocolRequestType(ShowDocumentRequest3.method);
    })(ShowDocumentRequest2 = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest2;
    (function(LinkedEditingRangeRequest3) {
      LinkedEditingRangeRequest3.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest3.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest3.method);
    })(LinkedEditingRangeRequest2 = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind2;
    (function(FileOperationPatternKind3) {
      FileOperationPatternKind3.file = "file";
      FileOperationPatternKind3.folder = "folder";
    })(FileOperationPatternKind2 = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest2;
    (function(WillCreateFilesRequest3) {
      WillCreateFilesRequest3.method = "workspace/willCreateFiles";
      WillCreateFilesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest3.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest3.method);
    })(WillCreateFilesRequest2 = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification2;
    (function(DidCreateFilesNotification3) {
      DidCreateFilesNotification3.method = "workspace/didCreateFiles";
      DidCreateFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification3.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification3.method);
    })(DidCreateFilesNotification2 = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest2;
    (function(WillRenameFilesRequest3) {
      WillRenameFilesRequest3.method = "workspace/willRenameFiles";
      WillRenameFilesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest3.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest3.method);
    })(WillRenameFilesRequest2 = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification2;
    (function(DidRenameFilesNotification3) {
      DidRenameFilesNotification3.method = "workspace/didRenameFiles";
      DidRenameFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification3.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification3.method);
    })(DidRenameFilesNotification2 = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification2;
    (function(DidDeleteFilesNotification3) {
      DidDeleteFilesNotification3.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification3.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification3.method);
    })(DidDeleteFilesNotification2 = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest2;
    (function(WillDeleteFilesRequest3) {
      WillDeleteFilesRequest3.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest3.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest3.method);
    })(WillDeleteFilesRequest2 = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel2;
    (function(UniquenessLevel3) {
      UniquenessLevel3.document = "document";
      UniquenessLevel3.project = "project";
      UniquenessLevel3.group = "group";
      UniquenessLevel3.scheme = "scheme";
      UniquenessLevel3.global = "global";
    })(UniquenessLevel2 = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind2;
    (function(MonikerKind3) {
      MonikerKind3.$import = "import";
      MonikerKind3.$export = "export";
      MonikerKind3.local = "local";
    })(MonikerKind2 = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest2;
    (function(TypeHierarchyPrepareRequest3) {
      TypeHierarchyPrepareRequest3.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest3.method);
    })(TypeHierarchyPrepareRequest2 = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest2;
    (function(TypeHierarchySupertypesRequest3) {
      TypeHierarchySupertypesRequest3.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest3.method);
    })(TypeHierarchySupertypesRequest2 = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest2;
    (function(TypeHierarchySubtypesRequest3) {
      TypeHierarchySubtypesRequest3.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest3.method);
    })(TypeHierarchySubtypesRequest2 = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest2;
    (function(InlineValueRequest3) {
      InlineValueRequest3.method = "textDocument/inlineValue";
      InlineValueRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest3.type = new messages_1.ProtocolRequestType(InlineValueRequest3.method);
    })(InlineValueRequest2 = exports2.InlineValueRequest || (exports2.InlineValueRequest = {}));
    var InlineValueRefreshRequest2;
    (function(InlineValueRefreshRequest3) {
      InlineValueRefreshRequest3.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRefreshRequest3.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest3.method);
    })(InlineValueRefreshRequest2 = exports2.InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest2;
    (function(InlayHintRequest3) {
      InlayHintRequest3.method = "textDocument/inlayHint";
      InlayHintRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest3.type = new messages_1.ProtocolRequestType(InlayHintRequest3.method);
    })(InlayHintRequest2 = exports2.InlayHintRequest || (exports2.InlayHintRequest = {}));
    var InlayHintResolveRequest2;
    (function(InlayHintResolveRequest3) {
      InlayHintResolveRequest3.method = "inlayHint/resolve";
      InlayHintResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest3.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest3.method);
    })(InlayHintResolveRequest2 = exports2.InlayHintResolveRequest || (exports2.InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest2;
    (function(InlayHintRefreshRequest3) {
      InlayHintRefreshRequest3.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRefreshRequest3.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest3.method);
    })(InlayHintRefreshRequest2 = exports2.InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData2;
    (function(DiagnosticServerCancellationData3) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData3.is = is;
    })(DiagnosticServerCancellationData2 = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind2;
    (function(DocumentDiagnosticReportKind3) {
      DocumentDiagnosticReportKind3.Full = "full";
      DocumentDiagnosticReportKind3.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind2 = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest2;
    (function(DocumentDiagnosticRequest3) {
      DocumentDiagnosticRequest3.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest3.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest3.method);
      DocumentDiagnosticRequest3.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest2 = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest2;
    (function(WorkspaceDiagnosticRequest3) {
      WorkspaceDiagnosticRequest3.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest3.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest3.method);
      WorkspaceDiagnosticRequest3.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest2 = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest2;
    (function(DiagnosticRefreshRequest3) {
      DiagnosticRefreshRequest3.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DiagnosticRefreshRequest3.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest3.method);
    })(DiagnosticRefreshRequest2 = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals2(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals2;
    })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version2, cells) {
        return { uri, notebookType, version: version2, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var TextDocumentFilter2;
    (function(TextDocumentFilter3) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
      }
      TextDocumentFilter3.is = is;
    })(TextDocumentFilter2 = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !TextDocumentFilter2.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest2;
    (function(RegistrationRequest3) {
      RegistrationRequest3.method = "client/registerCapability";
      RegistrationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest3.type = new messages_1.ProtocolRequestType(RegistrationRequest3.method);
    })(RegistrationRequest2 = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest2;
    (function(UnregistrationRequest3) {
      UnregistrationRequest3.method = "client/unregisterCapability";
      UnregistrationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest3.type = new messages_1.ProtocolRequestType(UnregistrationRequest3.method);
    })(UnregistrationRequest2 = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind2;
    (function(ResourceOperationKind3) {
      ResourceOperationKind3.Create = "create";
      ResourceOperationKind3.Rename = "rename";
      ResourceOperationKind3.Delete = "delete";
    })(ResourceOperationKind2 = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind2;
    (function(FailureHandlingKind3) {
      FailureHandlingKind3.Abort = "abort";
      FailureHandlingKind3.Transactional = "transactional";
      FailureHandlingKind3.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind3.Undo = "undo";
    })(FailureHandlingKind2 = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var PositionEncodingKind2;
    (function(PositionEncodingKind3) {
      PositionEncodingKind3.UTF8 = "utf-8";
      PositionEncodingKind3.UTF16 = "utf-16";
      PositionEncodingKind3.UTF32 = "utf-32";
    })(PositionEncodingKind2 = exports2.PositionEncodingKind || (exports2.PositionEncodingKind = {}));
    var StaticRegistrationOptions2;
    (function(StaticRegistrationOptions3) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions3.hasId = hasId;
    })(StaticRegistrationOptions2 = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions2;
    (function(TextDocumentRegistrationOptions3) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions3.is = is;
    })(TextDocumentRegistrationOptions2 = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions2;
    (function(WorkDoneProgressOptions3) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions3.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions3.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions2 = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest2;
    (function(InitializeRequest3) {
      InitializeRequest3.method = "initialize";
      InitializeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest3.type = new messages_1.ProtocolRequestType(InitializeRequest3.method);
    })(InitializeRequest2 = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes = exports2.InitializeErrorCodes || (exports2.InitializeErrorCodes = {}));
    var InitializedNotification2;
    (function(InitializedNotification3) {
      InitializedNotification3.method = "initialized";
      InitializedNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification3.type = new messages_1.ProtocolNotificationType(InitializedNotification3.method);
    })(InitializedNotification2 = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest2;
    (function(ShutdownRequest3) {
      ShutdownRequest3.method = "shutdown";
      ShutdownRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest3.type = new messages_1.ProtocolRequestType0(ShutdownRequest3.method);
    })(ShutdownRequest2 = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification2;
    (function(ExitNotification3) {
      ExitNotification3.method = "exit";
      ExitNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification3.type = new messages_1.ProtocolNotificationType0(ExitNotification3.method);
    })(ExitNotification2 = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification2;
    (function(DidChangeConfigurationNotification3) {
      DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
    })(DidChangeConfigurationNotification2 = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType2;
    (function(MessageType3) {
      MessageType3.Error = 1;
      MessageType3.Warning = 2;
      MessageType3.Info = 3;
      MessageType3.Log = 4;
    })(MessageType2 = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification2;
    (function(ShowMessageNotification3) {
      ShowMessageNotification3.method = "window/showMessage";
      ShowMessageNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification3.type = new messages_1.ProtocolNotificationType(ShowMessageNotification3.method);
    })(ShowMessageNotification2 = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest2;
    (function(ShowMessageRequest3) {
      ShowMessageRequest3.method = "window/showMessageRequest";
      ShowMessageRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest3.type = new messages_1.ProtocolRequestType(ShowMessageRequest3.method);
    })(ShowMessageRequest2 = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification2;
    (function(LogMessageNotification3) {
      LogMessageNotification3.method = "window/logMessage";
      LogMessageNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification3.type = new messages_1.ProtocolNotificationType(LogMessageNotification3.method);
    })(LogMessageNotification2 = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification2;
    (function(DidOpenTextDocumentNotification3) {
      DidOpenTextDocumentNotification3.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification3.method);
    })(DidOpenTextDocumentNotification2 = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification2;
    (function(DidChangeTextDocumentNotification3) {
      DidChangeTextDocumentNotification3.method = "textDocument/didChange";
      DidChangeTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification3.method);
    })(DidChangeTextDocumentNotification2 = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification2;
    (function(DidCloseTextDocumentNotification3) {
      DidCloseTextDocumentNotification3.method = "textDocument/didClose";
      DidCloseTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification3.method);
    })(DidCloseTextDocumentNotification2 = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification2;
    (function(DidSaveTextDocumentNotification3) {
      DidSaveTextDocumentNotification3.method = "textDocument/didSave";
      DidSaveTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification3.method);
    })(DidSaveTextDocumentNotification2 = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason3;
    (function(TextDocumentSaveReason4) {
      TextDocumentSaveReason4.Manual = 1;
      TextDocumentSaveReason4.AfterDelay = 2;
      TextDocumentSaveReason4.FocusOut = 3;
    })(TextDocumentSaveReason3 = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification2;
    (function(WillSaveTextDocumentNotification3) {
      WillSaveTextDocumentNotification3.method = "textDocument/willSave";
      WillSaveTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification3.method);
    })(WillSaveTextDocumentNotification2 = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest2;
    (function(WillSaveTextDocumentWaitUntilRequest3) {
      WillSaveTextDocumentWaitUntilRequest3.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest3.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest3.method);
    })(WillSaveTextDocumentWaitUntilRequest2 = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification2;
    (function(DidChangeWatchedFilesNotification3) {
      DidChangeWatchedFilesNotification3.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification3.method);
    })(DidChangeWatchedFilesNotification2 = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType2;
    (function(FileChangeType3) {
      FileChangeType3.Created = 1;
      FileChangeType3.Changed = 2;
      FileChangeType3.Deleted = 3;
    })(FileChangeType2 = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var RelativePattern3;
    (function(RelativePattern4) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
      }
      RelativePattern4.is = is;
    })(RelativePattern3 = exports2.RelativePattern || (exports2.RelativePattern = {}));
    var WatchKind2;
    (function(WatchKind3) {
      WatchKind3.Create = 1;
      WatchKind3.Change = 2;
      WatchKind3.Delete = 4;
    })(WatchKind2 = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification2;
    (function(PublishDiagnosticsNotification3) {
      PublishDiagnosticsNotification3.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification3.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification3.method);
    })(PublishDiagnosticsNotification2 = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind2;
    (function(CompletionTriggerKind3) {
      CompletionTriggerKind3.Invoked = 1;
      CompletionTriggerKind3.TriggerCharacter = 2;
      CompletionTriggerKind3.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind2 = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest2;
    (function(CompletionRequest3) {
      CompletionRequest3.method = "textDocument/completion";
      CompletionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest3.type = new messages_1.ProtocolRequestType(CompletionRequest3.method);
    })(CompletionRequest2 = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest2;
    (function(CompletionResolveRequest3) {
      CompletionResolveRequest3.method = "completionItem/resolve";
      CompletionResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest3.type = new messages_1.ProtocolRequestType(CompletionResolveRequest3.method);
    })(CompletionResolveRequest2 = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest2;
    (function(HoverRequest3) {
      HoverRequest3.method = "textDocument/hover";
      HoverRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest3.type = new messages_1.ProtocolRequestType(HoverRequest3.method);
    })(HoverRequest2 = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind2;
    (function(SignatureHelpTriggerKind3) {
      SignatureHelpTriggerKind3.Invoked = 1;
      SignatureHelpTriggerKind3.TriggerCharacter = 2;
      SignatureHelpTriggerKind3.ContentChange = 3;
    })(SignatureHelpTriggerKind2 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest2;
    (function(SignatureHelpRequest3) {
      SignatureHelpRequest3.method = "textDocument/signatureHelp";
      SignatureHelpRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest3.type = new messages_1.ProtocolRequestType(SignatureHelpRequest3.method);
    })(SignatureHelpRequest2 = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest2;
    (function(DefinitionRequest3) {
      DefinitionRequest3.method = "textDocument/definition";
      DefinitionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest3.type = new messages_1.ProtocolRequestType(DefinitionRequest3.method);
    })(DefinitionRequest2 = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest2;
    (function(ReferencesRequest3) {
      ReferencesRequest3.method = "textDocument/references";
      ReferencesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest3.type = new messages_1.ProtocolRequestType(ReferencesRequest3.method);
    })(ReferencesRequest2 = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest2;
    (function(DocumentHighlightRequest3) {
      DocumentHighlightRequest3.method = "textDocument/documentHighlight";
      DocumentHighlightRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest3.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest3.method);
    })(DocumentHighlightRequest2 = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest2;
    (function(DocumentSymbolRequest3) {
      DocumentSymbolRequest3.method = "textDocument/documentSymbol";
      DocumentSymbolRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest3.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest3.method);
    })(DocumentSymbolRequest2 = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest2;
    (function(CodeActionRequest3) {
      CodeActionRequest3.method = "textDocument/codeAction";
      CodeActionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest3.type = new messages_1.ProtocolRequestType(CodeActionRequest3.method);
    })(CodeActionRequest2 = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest2;
    (function(CodeActionResolveRequest3) {
      CodeActionResolveRequest3.method = "codeAction/resolve";
      CodeActionResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest3.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest3.method);
    })(CodeActionResolveRequest2 = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest2;
    (function(WorkspaceSymbolRequest3) {
      WorkspaceSymbolRequest3.method = "workspace/symbol";
      WorkspaceSymbolRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest3.method);
    })(WorkspaceSymbolRequest2 = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest2;
    (function(WorkspaceSymbolResolveRequest3) {
      WorkspaceSymbolResolveRequest3.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest3.method);
    })(WorkspaceSymbolResolveRequest2 = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest2;
    (function(CodeLensRequest3) {
      CodeLensRequest3.method = "textDocument/codeLens";
      CodeLensRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest3.type = new messages_1.ProtocolRequestType(CodeLensRequest3.method);
    })(CodeLensRequest2 = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest2;
    (function(CodeLensResolveRequest3) {
      CodeLensResolveRequest3.method = "codeLens/resolve";
      CodeLensResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest3.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest3.method);
    })(CodeLensResolveRequest2 = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest2;
    (function(CodeLensRefreshRequest3) {
      CodeLensRefreshRequest3.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest3.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest3.method);
    })(CodeLensRefreshRequest2 = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest2;
    (function(DocumentLinkRequest3) {
      DocumentLinkRequest3.method = "textDocument/documentLink";
      DocumentLinkRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkRequest3.method);
    })(DocumentLinkRequest2 = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest2;
    (function(DocumentLinkResolveRequest3) {
      DocumentLinkResolveRequest3.method = "documentLink/resolve";
      DocumentLinkResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest3.method);
    })(DocumentLinkResolveRequest2 = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest2;
    (function(DocumentFormattingRequest3) {
      DocumentFormattingRequest3.method = "textDocument/formatting";
      DocumentFormattingRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest3.method);
    })(DocumentFormattingRequest2 = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest2;
    (function(DocumentRangeFormattingRequest3) {
      DocumentRangeFormattingRequest3.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest3.method);
    })(DocumentRangeFormattingRequest2 = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest2;
    (function(DocumentOnTypeFormattingRequest3) {
      DocumentOnTypeFormattingRequest3.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest3.method);
    })(DocumentOnTypeFormattingRequest2 = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior2;
    (function(PrepareSupportDefaultBehavior3) {
      PrepareSupportDefaultBehavior3.Identifier = 1;
    })(PrepareSupportDefaultBehavior2 = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest2;
    (function(RenameRequest3) {
      RenameRequest3.method = "textDocument/rename";
      RenameRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest3.type = new messages_1.ProtocolRequestType(RenameRequest3.method);
    })(RenameRequest2 = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest2;
    (function(PrepareRenameRequest3) {
      PrepareRenameRequest3.method = "textDocument/prepareRename";
      PrepareRenameRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest3.type = new messages_1.ProtocolRequestType(PrepareRenameRequest3.method);
    })(PrepareRenameRequest2 = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest2;
    (function(ExecuteCommandRequest3) {
      ExecuteCommandRequest3.method = "workspace/executeCommand";
      ExecuteCommandRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest3.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest3.method);
    })(ExecuteCommandRequest2 = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest2;
    (function(ApplyWorkspaceEditRequest3) {
      ApplyWorkspaceEditRequest3.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest3.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest2 = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection2(input, output, logger57, options2) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options2)) {
        options2 = { connectionStrategy: options2 };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger57, options2);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar((init_main(), __toCommonJS(main_exports)), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection3();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes2;
    (function(LSPErrorCodes3) {
      LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes3.RequestFailed = -32803;
      LSPErrorCodes3.ServerCancelled = -32802;
      LSPErrorCodes3.ContentModified = -32801;
      LSPErrorCodes3.RequestCancelled = -32800;
      LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes2 = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api3(), exports2);
    function createProtocolConnection2(input, output, logger57, options2) {
      return (0, node_1.createMessageConnection)(input, output, logger57, options2);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// src/util/protocol.ts
var import_node3;
var init_protocol = __esm({
  "src/util/protocol.ts"() {
    "use strict";
    import_node3 = __toESM(require_node2());
  }
});

// src/util/array.ts
function toArray(item) {
  return Array.isArray(item) ? item : item == null ? [] : [item];
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function compareValue(n, r) {
  if (n < r[0])
    return 1;
  if (n > r[1])
    return -1;
  return 0;
}
function intable(n, table) {
  let low = 0;
  let high = table.length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareValue(n, table[mid]);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return true;
    }
  }
  return false;
}
function binarySearch(array, key, comparator) {
  return binarySearch2(array.length, (i) => comparator(array[i], key));
}
function binarySearch2(length, compareToKey) {
  let low = 0;
  let high = length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareToKey(mid);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
function intersect(array, other) {
  for (let item of other) {
    if (array.includes(item)) {
      return true;
    }
  }
  return false;
}
function splitArray(array, fn) {
  let res = [[], []];
  for (let item of array) {
    if (fn(item)) {
      res[0].push(item);
    } else {
      res[1].push(item);
    }
  }
  return res;
}
function groupBy(array, fn) {
  let res = [[], []];
  array.forEach((v) => {
    if (fn(v)) {
      res[0].push(v);
    } else {
      res[1].push(v);
    }
  });
  return res;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => array.indexOf(element) === position);
  }
  const seen = /* @__PURE__ */ Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
var init_array = __esm({
  "src/util/array.ts"() {
    "use strict";
  }
});

// src/util/charCode.ts
var init_charCode = __esm({
  "src/util/charCode.ts"() {
    "use strict";
  }
});

// src/util/string.ts
function toErrorText(error) {
  return error instanceof Error ? error.message : error.toString();
}
function toInteger(text) {
  let n = parseInt(text, 10);
  return isNaN(n) ? void 0 : n;
}
function toText(text) {
  return text ?? "";
}
function toBase64(text) {
  return global.Buffer.from(text).toString("base64");
}
function isHighlightGroupCharCode(code) {
  if (intable(code, asciiTable))
    return true;
  return code === 95 /* Underline */ || code === 46 /* Period */ || code === 64 /* AtSign */;
}
function isEmojiImprecise(x) {
  return x >= 127462 && x <= 127487 || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
function getCharIndexes(input, character) {
  let res = [];
  for (let i = 0; i < input.length; i++) {
    if (input[i] == character)
      res.push(i);
  }
  return res;
}
function isHighSurrogate(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319;
}
function isLowSurrogate(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343;
}
function byteLength(str, start = 0) {
  if (start === 0)
    return Buffer.byteLength(str, encoding);
  let len = 0;
  let unitIndex = 0;
  for (let codePoint of str) {
    let n = codePoint.codePointAt(0);
    if (unitIndex >= start) {
      len += utf8_code2len(n);
    }
    unitIndex += n >= UTF8_4BYTES_START ? 2 : 1;
  }
  return len;
}
function byteIndex(content, index) {
  let byteLength2 = 0;
  let codePoint;
  let prevCodePoint;
  let max = Math.min(index, content.length);
  for (let i = 0; i < max; i++) {
    codePoint = content.charCodeAt(i);
    if (isLowSurrogate(codePoint)) {
      if (prevCodePoint && isHighSurrogate(prevCodePoint)) {
        byteLength2 += 1;
      } else {
        byteLength2 += 3;
      }
    } else {
      byteLength2 += utf8_code2len(codePoint);
    }
    prevCodePoint = codePoint;
  }
  return byteLength2;
}
function upperFirst(str) {
  return (str == null ? void 0 : str.length) > 0 ? str[0].toUpperCase() + str.slice(1) : "";
}
function characterIndex(content, byteIndex2) {
  if (byteIndex2 == 0)
    return 0;
  let characterIndex2 = 0;
  let total = 0;
  for (let codePoint of content) {
    let code = codePoint.codePointAt(0);
    if (code >= UTF8_4BYTES_START) {
      characterIndex2 += 2;
      total += 4;
    } else {
      characterIndex2 += 1;
      total += utf8_code2len(code);
    }
    if (total >= byteIndex2)
      break;
  }
  return characterIndex2;
}
function utf8_code2len(code) {
  if (code < UTF8_2BYTES_START)
    return 1;
  if (code < UTF8_3BYTES_START)
    return 2;
  if (code < UTF8_4BYTES_START)
    return 3;
  return 4;
}
function byteSlice(content, start, end) {
  let si = characterIndex(content, start);
  let ei = end === void 0 ? void 0 : characterIndex(content, end);
  return content.slice(si, ei);
}
function isAlphabet(code) {
  if (code >= 65 && code <= 90)
    return true;
  if (code >= 97 && code <= 122)
    return true;
  return false;
}
function contentToLines(content, eol) {
  if (eol && content.endsWith("\n")) {
    return content.slice(0, -1).split("\n");
  }
  return content.split("\n");
}
function hasUpperCase(str) {
  for (let i = 0, l = str.length; i < l; i++) {
    let code = str.charCodeAt(i);
    if (code >= 65 && code <= 90) {
      return true;
    }
  }
  return false;
}
function smartMatch(a, b) {
  if (a === b)
    return true;
  let c = b.charCodeAt(0);
  if (c >= 65 && c <= 90) {
    if (c + 32 === a.charCodeAt(0))
      return true;
  }
  return false;
}
function smartcaseIndex(input, other) {
  if (input.length > other.length)
    return -1;
  if (input.length === 0)
    return 0;
  if (!hasUpperCase(input)) {
    return other.toLowerCase().indexOf(input);
  }
  let total = input.length;
  let checked = 0;
  for (let i = 0; i < other.length; i++) {
    let ch = other[i];
    if (smartMatch(input[checked], ch)) {
      checked++;
      if (checked === total) {
        return i - checked + 1;
      }
    } else if (checked > 0) {
      i = i - checked;
      checked = 0;
    }
  }
  return -1;
}
function bytes(text, max) {
  max = max ?? text.length;
  let lens = new Uint8Array(max);
  let ascii = true;
  let prevCodePoint;
  for (let i = 0; i < max; i++) {
    let code = text.charCodeAt(i);
    let len;
    if (isLowSurrogate(code)) {
      if (prevCodePoint && isHighSurrogate(prevCodePoint)) {
        len = 1;
      } else {
        len = 3;
      }
    } else {
      len = utf8_code2len(code);
    }
    if (ascii && len > 1)
      ascii = false;
    lens[i] = len;
    prevCodePoint = code;
  }
  return (characterIndex2) => {
    if (characterIndex2 === 0)
      return 0;
    if (ascii)
      return Math.min(characterIndex2, max);
    let res = 0;
    for (let i = 0; i < Math.min(characterIndex2, max); i++) {
      res += lens[i];
    }
    return res;
  };
}
var UTF8_2BYTES_START, UTF8_3BYTES_START, UTF8_4BYTES_START, encoding, asciiTable;
var init_string = __esm({
  "src/util/string.ts"() {
    "use strict";
    init_array();
    init_charCode();
    UTF8_2BYTES_START = 128;
    UTF8_3BYTES_START = 2048;
    UTF8_4BYTES_START = 65536;
    encoding = "utf8";
    asciiTable = [
      [48, 57],
      [65, 90],
      [97, 122]
    ];
  }
});

// src/events.ts
function shouldIgnore(err) {
  if (err instanceof CancellationError || err instanceof Error && err.message.includes("transport disconnected"))
    return true;
  return false;
}
var logger2, SYNC_AUTOCMDS, Events, events_default;
var init_events = __esm({
  "src/events.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_errors();
    init_is();
    init_object();
    init_protocol();
    init_string();
    logger2 = createLogger("events");
    SYNC_AUTOCMDS = ["BufWritePre"];
    Events = class {
      constructor() {
        this.handlers = /* @__PURE__ */ new Map();
        this._bufnr = 1;
        this._recentInserts = [];
        this._lastChange = 0;
        this._insertMode = false;
        this._pumAlignTop = false;
        this._pumVisible = false;
        this._completing = false;
        this._requesting = false;
        this._ready = false;
        this.timeout = 1e3;
      }
      set requesting(val) {
        this._requesting = val;
      }
      get requesting() {
        return this._requesting;
      }
      get ready() {
        return this._ready;
      }
      set completing(completing) {
        this._completing = completing;
        this._pumVisible = completing;
      }
      get completing() {
        return this._completing;
      }
      get cursor() {
        return this._cursor ?? { bufnr: this._bufnr, col: 1, lnum: 1, insert: false };
      }
      get bufnr() {
        return this._bufnr;
      }
      get pumvisible() {
        return this._pumVisible;
      }
      get pumAlignTop() {
        return this._pumAlignTop;
      }
      get insertMode() {
        return this._insertMode;
      }
      get lastChangeTs() {
        return this._lastChange;
      }
      race(events, token) {
        let disposables = [];
        return new Promise((resolve) => {
          if (number(token)) {
            let timer = setTimeout(() => {
              disposeAll(disposables);
              resolve(void 0);
            }, token);
            disposables.push(import_node3.Disposable.create(() => {
              clearTimeout(timer);
            }));
          } else if (import_node3.CancellationToken.is(token)) {
            token.onCancellationRequested(() => {
              disposeAll(disposables);
              resolve(void 0);
            }, null, disposables);
          }
          events.forEach((ev) => {
            this.on(ev, (...args) => {
              disposeAll(disposables);
              resolve({ name: ev, args });
            }, null, disposables);
          });
        });
      }
      async fire(event, args) {
        if (event === "ready" /* Ready */) {
          this._ready = true;
        } else if (event == "InsertEnter" /* InsertEnter */) {
          this._insertMode = true;
        } else if (event == "InsertLeave" /* InsertLeave */) {
          this._last_pum_insert = void 0;
          this._insertMode = false;
          this._pumVisible = false;
          this._recentInserts = [];
        } else if (event == "CursorHoldI" /* CursorHoldI */ || event == "CursorMovedI" /* CursorMovedI */) {
          this._bufnr = args[0];
          if (!this._insertMode) {
            this._insertMode = true;
            void this.fire("InsertEnter" /* InsertEnter */, [args[0]]);
          }
        } else if (event == "CursorHold" /* CursorHold */ || event == "CursorMoved" /* CursorMoved */) {
          this._bufnr = args[0];
          if (this._insertMode) {
            this._insertMode = false;
            void this.fire("InsertLeave" /* InsertLeave */, [args[0]]);
          }
        } else if (event == "MenuPopupChanged" /* MenuPopupChanged */) {
          this._pumVisible = true;
          this._pumAlignTop = args[1] > args[0].row;
        } else if (event == "InsertCharPre" /* InsertCharPre */) {
          this._recentInserts.push([args[1], args[0]]);
        } else if (event == "TextChanged" /* TextChanged */) {
          this._lastChange = Date.now();
        } else if (event == "BufEnter" /* BufEnter */) {
          this._bufnr = args[0];
        } else if (event == "TextChangedI" /* TextChangedI */ || event == "TextChangedP" /* TextChangedP */) {
          let info = args[1];
          let pre = byteSlice(info.line ?? "", 0, info.col - 1);
          let arr;
          if (this._last_pum_insert != null && this._last_pum_insert == pre) {
            arr = [];
            event = "TextChangedP" /* TextChangedP */;
          } else {
            arr = this._recentInserts.filter((o) => o[0] == args[0]);
          }
          this._last_pum_insert = void 0;
          this._bufnr = args[0];
          this._recentInserts = [];
          this._lastChange = Date.now();
          info.pre = pre;
          this._cursor = Object.freeze({
            bufnr: args[0],
            lnum: info.lnum,
            col: info.col,
            insert: true
          });
          if (arr.length && pre.length) {
            let character = pre.slice(-1);
            if (arr.findIndex((o) => o[1] == character) !== -1) {
              info.insertChar = character;
              process.nextTick(() => {
                void this.fire("TextInsert" /* TextInsert */, [...args, character]);
              });
            }
          }
        } else if (event == "PumInsert" /* PumInsert */) {
          this._last_pum_insert = args[0];
          return;
        }
        if (event == "CursorMoved" /* CursorMoved */ || event == "CursorMovedI" /* CursorMovedI */) {
          args.push(this._recentInserts.length > 0);
          let cursor = {
            bufnr: args[0],
            lnum: args[1][0],
            col: args[1][1],
            insert: event == "CursorMovedI" /* CursorMovedI */
          };
          if (this._last_pum_insert && byteLength(this._last_pum_insert) + 1 == cursor.col)
            return;
          if (this._cursor && equals(this._cursor, cursor))
            return;
          this._cursor = cursor;
        }
        let cbs = this.handlers.get(event);
        if (cbs == null ? void 0 : cbs.length) {
          let fns = cbs.slice();
          let traceSlow = SYNC_AUTOCMDS.includes(event);
          await Promise.allSettled(fns.map((fn) => {
            let promiseFn = async () => {
              let timer;
              if (traceSlow) {
                timer = setTimeout(() => {
                  console.error(`Slow "${event}" handler detected`, fn["stack"]);
                  logger2.error(`Slow "${event}" handler detected`, fn["stack"]);
                }, this.timeout);
              }
              try {
                await fn(args);
              } catch (e) {
                let res = shouldIgnore(e);
                if (!res)
                  logger2.error(`Error on event: ${event}`, e);
              }
              clearTimeout(timer);
            };
            return promiseFn();
          }));
        }
      }
      on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
          let arr = disposables || [];
          for (let ev of event) {
            this.on(ev, handler, thisArg, arr);
          }
          return import_node3.Disposable.create(() => {
            disposeAll(arr);
          });
        } else {
          let arr = this.handlers.get(event) || [];
          let wrappedhandler = (args) => new Promise((resolve, reject) => {
            try {
              Promise.resolve(handler.apply(thisArg ?? null, args)).then(() => {
                resolve(void 0);
              }, (e) => {
                reject(e);
              });
            } catch (e) {
              reject(e);
            }
          });
          Error.captureStackTrace(wrappedhandler);
          arr.push(wrappedhandler);
          this.handlers.set(event, arr);
          let disposable = import_node3.Disposable.create(() => {
            let idx = arr.indexOf(wrappedhandler);
            if (idx !== -1) {
              arr.splice(idx, 1);
            }
          });
          if (Array.isArray(disposables)) {
            disposables.push(disposable);
          }
          return disposable;
        }
      }
    };
    events_default = new Events();
  }
});

// package.json
var require_package = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "coc.nvim-master",
      version: "0.0.82",
      description: "LSP based intellisense engine for neovim & vim8.",
      main: "./build/index.js",
      engines: {
        node: ">=14.14.0"
      },
      type: "commonjs",
      scripts: {
        lint: "eslint . --ext .ts --quiet",
        "lint:typecheck": "tsc -p tsconfig.json",
        build: "node esbuild.js",
        test: "./node_modules/.bin/jest --forceExit",
        "test-build": "./node_modules/.bin/jest --coverage --forceExit",
        prepare: "node esbuild.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/neoclide/coc.nvim.git"
      },
      keywords: [
        "complete",
        "neovim"
      ],
      author: "Qiming Zhao <chemzqm@gmail.com>",
      bugs: {
        url: "https://github.com/neoclide/coc.nvim/issues"
      },
      homepage: "https://github.com/neoclide/coc.nvim#readme",
      jest: {
        globals: {
          __TEST__: true
        },
        projects: [
          "<rootDir>"
        ],
        watchman: false,
        clearMocks: true,
        globalSetup: "./jest.js",
        testEnvironment: "node",
        coveragePathIgnorePatterns: [
          "<rootDir>/src/__tests__/*"
        ],
        moduleFileExtensions: [
          "ts",
          "tsx",
          "json",
          "js"
        ],
        transform: {
          "^.+\\.tsx?$": [
            "@swc/jest"
          ]
        },
        testRegex: "src/__tests__/.*\\.(test|spec)\\.ts$",
        coverageReporters: [
          "text",
          "lcov"
        ],
        coverageDirectory: "./coverage/"
      },
      devDependencies: {
        "@swc/core": "^1.3.21",
        "@swc/jest": "^0.2.23",
        "@types/bser": "^2.0.1",
        "@types/cli-table": "^0.3.0",
        "@types/debounce": "^3.0.0",
        "@types/fb-watchman": "^2.0.0",
        "@types/follow-redirects": "^1.14.1",
        "@types/glob": "^7.2.0",
        "@types/jest": "^27.0.3",
        "@types/marked": "^4.0.1",
        "@types/minimatch": "^5.1.2",
        "@types/mkdirp": "^1.0.1",
        "@types/node": "14.14",
        "@types/semver": "^7.3.4",
        "@types/tar": "^4.0.5",
        "@types/unidecode": "^0.1.1",
        "@types/uuid": "^8.3.0",
        "@types/which": "^1.3.2",
        "@typescript-eslint/eslint-plugin": "^5.44.0",
        "@typescript-eslint/parser": "^5.44.0",
        browserslist: "^4.21.4",
        bser: "^2.1.1",
        esbuild: "^0.15.13",
        eslint: "^8.28.0",
        "eslint-plugin-jest": "^27.1.5",
        "eslint-plugin-jsdoc": "^39.6.2",
        jest: "29.3.1",
        typescript: "^4.9.3",
        "vscode-languageserver": "^8.0.2"
      },
      dependencies: {
        "@chemzqm/neovim": "^6.1.1",
        "ansi-styles": "^5.0.0",
        bytes: "^3.1.0",
        "caniuse-lite": "^1.0.30001431",
        "cli-table": "^0.3.4",
        "content-disposition": "^0.5.3",
        debounce: "^1.2.0",
        "decompress-response": "^6.0.0",
        "fast-diff": "^1.2.0",
        "fb-watchman": "^2.0.1",
        "follow-redirects": "^1.15.2",
        glob: "^7.2.0",
        "http-proxy-agent": "^5.0.0",
        "https-proxy-agent": "^5.0.0",
        "jsonc-parser": "^3.0.0",
        marked: "^4.0.12",
        minimatch: "^5.1.0",
        semver: "^7.3.2",
        "strip-ansi": "^6.0.0",
        tar: "^6.1.9",
        tslib: "^2.0.3",
        unidecode: "^0.1.8",
        "unzip-stream": "^0.3.1",
        uuid: "^7.0.3",
        "vscode-languageserver-protocol": "^3.17.2",
        "vscode-languageserver-textdocument": "^1.0.5",
        "vscode-languageserver-types": "^3.17.2",
        "vscode-uri": "^3.0.3",
        which: "^2.0.2"
      }
    };
  }
});

// src/util/constants.ts
var import_package, ASCII_END, VERSION, isVim, APIVERSION, floatHighlightGroup, CONFIG_FILE_NAME, configHome, dataHome, userConfigFile, pluginRoot, watchmanCommand;
var init_constants = __esm({
  "src/util/constants.ts"() {
    "use strict";
    import_package = __toESM(require_package());
    init_util();
    init_node();
    ASCII_END = 128;
    VERSION = import_package.version;
    isVim = process.env.VIM_NODE_RPC == "1";
    APIVERSION = 34;
    floatHighlightGroup = "CocFloating";
    CONFIG_FILE_NAME = "coc-settings.json";
    configHome = defaultValue(process.env.COC_VIMCONFIG, path.join(os.homedir(), ".vim"));
    dataHome = defaultValue(process.env.COC_DATA_HOME, path.join(os.homedir(), ".config/coc"));
    userConfigFile = path.join(path.normalize(configHome), CONFIG_FILE_NAME);
    pluginRoot = getConditionValue(path.dirname(__dirname), path.resolve(__dirname, "../.."));
    watchmanCommand = "watchman";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia = false) {
  const len = text.length;
  let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    let digits = 0;
    let value2 = 0;
    while (digits < count || !exact) {
      let ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    let start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    let end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    let result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        const ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            const ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    let code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        const start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenStartLine: () => lineStartOffset,
    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
    getTokenError: () => scanError
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
var init_scanner = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
    (function(CharacterCodes2) {
      CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
      CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
      CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
      CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
      CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
      CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
      CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
      CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
      CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
      CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
      CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
      CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
      CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
      CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
      CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
      CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
      CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
      CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
      CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
      CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
      CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
      CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
      CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
      CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
      CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
      CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
      CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
      CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
      CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
      CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
      CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
      CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
      CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
      CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
      CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
      CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
      CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
      CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
      CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
      CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
      CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
      CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
      CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
      CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
      CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
      CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
      CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
      CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
      CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
      CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
      CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
      CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
      CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
      CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
      CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
      CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
      CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
      CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
      CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
      CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
      CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
      CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
      CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
      CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
      CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
      CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
      CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
      CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
      CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
      CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
      CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
      CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
      CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
      CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
      CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
      CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
      CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
      CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
      CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
      CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
    })(CharacterCodes || (CharacterCodes = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/format.js
function format2(documentText, range, options2) {
  let initialIndentLevel;
  let formatText;
  let formatTextStart;
  let rangeStart;
  let rangeEnd;
  if (range) {
    rangeStart = range.offset;
    rangeEnd = rangeStart + range.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    let endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options2);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  const eol = getEOL(options2, documentText);
  let numberLineBreaks = 0;
  let indentLevel = 0;
  let indentValue;
  if (options2.insertSpaces) {
    indentValue = repeat(" ", options2.tabSize || 4);
  } else {
    indentValue = "	";
  }
  let scanner = createScanner(formatText, false);
  let hasError = false;
  function newLinesAndIndent() {
    if (numberLineBreaks > 1) {
      return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
    } else {
      return eol + repeat(indentValue, initialIndentLevel + indentLevel);
    }
  }
  function scanNext() {
    let token = scanner.scan();
    numberLineBreaks = 0;
    while (token === 15 || token === 14) {
      if (token === 14 && options2.keepLines) {
        numberLineBreaks += 1;
      } else if (token === 14) {
        numberLineBreaks = 1;
      }
      token = scanner.scan();
    }
    hasError = token === 16 || scanner.getTokenError() !== 0;
    return token;
  }
  const editOperations = [];
  function addEdit(text, startOffset, endOffset) {
    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
    }
  }
  let firstToken = scanNext();
  if (options2.keepLines && numberLineBreaks > 0) {
    addEdit(repeat(eol, numberLineBreaks), 0, 0);
  }
  if (firstToken !== 17) {
    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
    let initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
    let secondToken = scanNext();
    let replaceContent = "";
    let needsLineBreak = false;
    while (numberLineBreaks === 0 && (secondToken === 12 || secondToken === 13)) {
      let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
      needsLineBreak = secondToken === 12;
      replaceContent = needsLineBreak ? newLinesAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
      }
      ;
      if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines && firstToken !== 1) {
        replaceContent = newLinesAndIndent();
      } else if (options2.keepLines) {
        replaceContent = " ";
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
      }
      ;
      if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines && firstToken !== 3) {
        replaceContent = newLinesAndIndent();
      } else if (options2.keepLines) {
        replaceContent = " ";
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines) {
            replaceContent = newLinesAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 5:
          if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines) {
            replaceContent = newLinesAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 12:
          replaceContent = newLinesAndIndent();
          break;
        case 13:
          if (numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 6:
          if (options2.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 10:
          if (options2.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (secondToken === 6 && !needsLineBreak) {
            replaceContent = "";
          }
          break;
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (options2.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else {
            if ((secondToken === 12 || secondToken === 13) && !needsLineBreak) {
              replaceContent = " ";
            } else if (secondToken !== 5 && secondToken !== 17) {
              hasError = true;
            }
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (numberLineBreaks > 0 && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLinesAndIndent();
      }
    }
    if (secondToken === 17) {
      if (options2.keepLines && numberLineBreaks > 0) {
        replaceContent = newLinesAndIndent();
      } else {
        replaceContent = options2.insertFinalNewline ? eol : "";
      }
    }
    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  let result = "";
  for (let i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options2) {
  let i = 0;
  let nChars = 0;
  const tabSize = options2.tabSize || 4;
  while (i < content.length) {
    let ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options2, text) {
  for (let i = 0; i < text.length; i++) {
    const ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options2 && options2.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
var init_format = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    "use strict";
    init_scanner();
  }
});

// node_modules/jsonc-parser/lib/esm/impl/parser.js
function parse(text, errors = [], options2 = ParseOptions.DEFAULT) {
  let currentProperty = null;
  let currentParent = [];
  const previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  const visitor = {
    onObjectBegin: () => {
      const object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: (name2) => {
      currentProperty = name2;
    },
    onObjectEnd: () => {
      currentParent = previousParents.pop();
    },
    onArrayBegin: () => {
      const array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: () => {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options2);
  return currentParent[0];
}
function parseTree(text, errors = [], options2 = ParseOptions.DEFAULT) {
  let currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  const visitor = {
    onObjectBegin: (offset) => {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: (name2, offset, length) => {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name2, offset, length, parent: currentParent });
    },
    onObjectEnd: (offset, length) => {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: (offset, length) => {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: (offset, length) => {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: (value, offset, length) => {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: (sep, offset, length) => {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options2);
  const result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path2) {
  if (!root) {
    return void 0;
  }
  let node = root;
  for (let segment of path2) {
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      let found = false;
      for (const propertyNode of node.children) {
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      const index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text, visitor, options2 = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text, false);
  const _jsonPath = [];
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toNoArgVisitWithPath(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisitWithPath(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  const disallowComments = options2 && options2.disallowComments;
  const allowTrailingComma = options2 && options2.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError2(14);
          break;
        case 5:
          handleError2(15);
          break;
        case 3:
          handleError2(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError2(11);
          }
          break;
        case 2:
          handleError2(12);
          break;
        case 6:
          handleError2(16);
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError2(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError2(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError2(error, skipUntilAfter = [], skipUntil = []) {
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
      _jsonPath.push(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        const tokenValue = _scanner.getTokenValue();
        let value = Number(tokenValue);
        if (isNaN(value)) {
          handleError2(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError2(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError2(4, [], [2, 5]);
      }
    } else {
      handleError2(5, [], [2, 5]);
    }
    _jsonPath.pop();
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError2(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError2(6, [], []);
      }
      if (!parseProperty()) {
        handleError2(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError2(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let isFirstElement = true;
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError2(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError2(6, [], []);
      }
      if (isFirstElement) {
        _jsonPath.push(0);
        isFirstElement = false;
      } else {
        _jsonPath[_jsonPath.length - 1]++;
      }
      if (!parseValue()) {
        handleError2(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (!isFirstElement) {
      _jsonPath.pop();
    }
    if (_scanner.getToken() !== 4) {
      handleError2(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options2.allowEmptyContent) {
      return true;
    }
    handleError2(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError2(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError2(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}
var ParseOptions;
var init_parser = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    "use strict";
    init_scanner();
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/edit.js
function setProperty(text, originalPath, value, options2) {
  const path2 = originalPath.slice();
  const errors = [];
  const root = parseTree(text, errors);
  let parent = void 0;
  let lastSegment = void 0;
  while (path2.length > 0) {
    lastSegment = path2.pop();
    parent = findNodeAtLocation(root, path2);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = { [lastSegment]: value };
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options2);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    const existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        const propertyIndex = parent.children.indexOf(existing.parent);
        let removeBegin;
        let removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          let previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            let next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, options2);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options2);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
      const index = options2.getInsertionIndex ? options2.getInsertionIndex(parent.children.map((p) => p.children[0].value)) : parent.children.length;
      let edit2;
      if (index > 0) {
        let previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit2, options2);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    const insertIndex = lastSegment;
    if (insertIndex === -1) {
      const newProperty = `${JSON.stringify(value)}`;
      let edit2;
      if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        const previous = parent.children[parent.children.length - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options2);
    } else if (value === void 0 && parent.children.length >= 0) {
      const removalIndex = lastSegment;
      const toRemove = parent.children[removalIndex];
      let edit2;
      if (parent.children.length === 1) {
        edit2 = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        let previous = parent.children[removalIndex - 1];
        let offset = previous.offset + previous.length;
        let parentEndOffset = parent.offset + parent.length;
        edit2 = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit2 = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit2, options2);
    } else if (value !== void 0) {
      let edit2;
      const newProperty = `${JSON.stringify(value)}`;
      if (!options2.isArrayInsertion && parent.children.length > lastSegment) {
        const toModify = parent.children[lastSegment];
        edit2 = { offset: toModify.offset, length: toModify.length, content: newProperty };
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        const previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options2);
    } else {
      throw new Error(`Can not ${value === void 0 ? "remove" : options2.isArrayInsertion ? "insert" : "modify"} Array index ${insertIndex} as length is not sufficient`);
    }
  } else {
    throw new Error(`Can not add ${typeof lastSegment !== "number" ? "index" : "property"} to parent of type ${parent.type}`);
  }
}
function withFormatting(text, edit2, options2) {
  if (!options2.formattingOptions) {
    return [edit2];
  }
  let newText = applyEdit(text, edit2);
  let begin = edit2.offset;
  let end = edit2.offset + edit2.content.length;
  if (edit2.length === 0 || edit2.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  const edits = format2(newText, { offset: begin, length: end - begin }, { ...options2.formattingOptions, keepLines: false });
  for (let i = edits.length - 1; i >= 0; i--) {
    const edit3 = edits[i];
    newText = applyEdit(newText, edit3);
    begin = Math.min(begin, edit3.offset);
    end = Math.max(end, edit3.offset + edit3.length);
    end += edit3.content.length - edit3.length;
  }
  const editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit2) {
  return text.substring(0, edit2.offset) + edit2.content + text.substring(edit2.offset + edit2.length);
}
var init_edit = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    "use strict";
    init_format();
    init_parser();
  }
});

// node_modules/jsonc-parser/lib/esm/main.js
function printParseErrorCode(code) {
  switch (code) {
    case 1:
      return "InvalidSymbol";
    case 2:
      return "InvalidNumberFormat";
    case 3:
      return "PropertyNameExpected";
    case 4:
      return "ValueExpected";
    case 5:
      return "ColonExpected";
    case 6:
      return "CommaExpected";
    case 7:
      return "CloseBraceExpected";
    case 8:
      return "CloseBracketExpected";
    case 9:
      return "EndOfFileExpected";
    case 10:
      return "InvalidCommentToken";
    case 11:
      return "UnexpectedEndOfComment";
    case 12:
      return "UnexpectedEndOfString";
    case 13:
      return "UnexpectedEndOfNumber";
    case 14:
      return "InvalidUnicode";
    case 15:
      return "InvalidEscapeCharacter";
    case 16:
      return "InvalidCharacter";
  }
  return "<unknown ParseErrorCode>";
}
function modify(text, path2, value, options2) {
  return setProperty(text, path2, value, options2);
}
function applyEdits(text, edits) {
  let sortedEdits = edits.slice(0).sort((a, b) => {
    const diff = a.offset - b.offset;
    if (diff === 0) {
      return a.length - b.length;
    }
    return diff;
  });
  let lastModifiedOffset = text.length;
  for (let i = sortedEdits.length - 1; i >= 0; i--) {
    let e = sortedEdits[i];
    if (e.offset + e.length <= lastModifiedOffset) {
      text = applyEdit(text, e);
    } else {
      throw new Error("Overlapping edit");
    }
    lastModifiedOffset = e.offset;
  }
  return text;
}
var ScanError, SyntaxKind, parse2, visit2, ParseErrorCode;
var init_main2 = __esm({
  "node_modules/jsonc-parser/lib/esm/main.js"() {
    "use strict";
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    (function(ScanError2) {
      ScanError2[ScanError2["None"] = 0] = "None";
      ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
      ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
      ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
      ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
      ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
      ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError || (ScanError = {}));
    (function(SyntaxKind2) {
      SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
      SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
      SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
      SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
      SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
      SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
      SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
      SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
      SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
      SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
      SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
      SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
      SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
      SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
      SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
      SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
      SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
    })(SyntaxKind || (SyntaxKind = {}));
    parse2 = parse;
    visit2 = visit;
    (function(ParseErrorCode3) {
      ParseErrorCode3[ParseErrorCode3["InvalidSymbol"] = 1] = "InvalidSymbol";
      ParseErrorCode3[ParseErrorCode3["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
      ParseErrorCode3[ParseErrorCode3["PropertyNameExpected"] = 3] = "PropertyNameExpected";
      ParseErrorCode3[ParseErrorCode3["ValueExpected"] = 4] = "ValueExpected";
      ParseErrorCode3[ParseErrorCode3["ColonExpected"] = 5] = "ColonExpected";
      ParseErrorCode3[ParseErrorCode3["CommaExpected"] = 6] = "CommaExpected";
      ParseErrorCode3[ParseErrorCode3["CloseBraceExpected"] = 7] = "CloseBraceExpected";
      ParseErrorCode3[ParseErrorCode3["CloseBracketExpected"] = 8] = "CloseBracketExpected";
      ParseErrorCode3[ParseErrorCode3["EndOfFileExpected"] = 9] = "EndOfFileExpected";
      ParseErrorCode3[ParseErrorCode3["InvalidCommentToken"] = 10] = "InvalidCommentToken";
      ParseErrorCode3[ParseErrorCode3["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
      ParseErrorCode3[ParseErrorCode3["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
      ParseErrorCode3[ParseErrorCode3["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
      ParseErrorCode3[ParseErrorCode3["InvalidUnicode"] = 14] = "InvalidUnicode";
      ParseErrorCode3[ParseErrorCode3["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
      ParseErrorCode3[ParseErrorCode3["InvalidCharacter"] = 16] = "InvalidCharacter";
    })(ParseErrorCode || (ParseErrorCode = {}));
  }
});

// src/util/platform.ts
function getPlatform(process2) {
  let { platform: platform2 } = process2;
  if (platform2 === "win32")
    return 3 /* Windows */;
  if (platform2 === "darwin")
    return 1 /* Mac */;
  if (platform2 === "linux")
    return 2 /* Linux */;
  return 4 /* Unknown */;
}
var _platform, platform, isWindows, isMacintosh;
var init_platform = __esm({
  "src/util/platform.ts"() {
    "use strict";
    _platform = getPlatform(process);
    platform = _platform;
    isWindows = _platform === 3 /* Windows */;
    isMacintosh = _platform === 1 /* Mac */;
  }
});

// src/util/fs.ts
function watchFile(filepath, onChange, immediate = false) {
  let callback = debounce(onChange, 100);
  try {
    let watcher = fs.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    if (immediate) {
      setTimeout(onChange, 10);
    }
    return import_node3.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return import_node3.Disposable.create(() => {
      callback.clear();
    });
  }
}
function loadJson(filepath) {
  try {
    let errors = [];
    let text = fs.readFileSync(filepath, "utf8");
    let data = parse2(text, errors, { allowTrailingComma: true });
    if (errors.length > 0) {
      logger3.error(`Error on parse json file ${filepath}`, errors);
    }
    return data ?? {};
  } catch (e) {
    return {};
  }
}
function writeJson(filepath, obj) {
  let dir = path.dirname(filepath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    logger3.info(`Creating directory ${dir}`);
  }
  fs.writeFileSync(filepath, JSON.stringify(toObject(obj), null, 2), "utf8");
}
async function statAsync(filepath) {
  let stat = null;
  try {
    stat = await (0, import_util.promisify)(fs.stat)(filepath);
  } catch (e) {
  }
  return stat;
}
function isDirectory(filepath) {
  if (!filepath || !path.isAbsolute(filepath) || !fs.existsSync(filepath))
    return false;
  let stat = fs.statSync(filepath);
  return stat.isDirectory();
}
async function remove(filepath) {
  if (!filepath)
    return;
  try {
    await (0, import_util.promisify)(fs.rm)(filepath, { force: true, recursive: true });
  } catch (e) {
    return;
  }
}
async function getFileType(filepath) {
  try {
    const stat = await (0, import_util.promisify)(fs.lstat)(filepath);
    if (stat.isFile()) {
      return 1 /* File */;
    }
    if (stat.isDirectory()) {
      return 2 /* Directory */;
    }
    if (stat.isSymbolicLink()) {
      return 64 /* SymbolicLink */;
    }
    return 0 /* Unknown */;
  } catch (e) {
    return void 0;
  }
}
async function isGitIgnored(fullpath) {
  if (!fullpath)
    return false;
  let stat = await statAsync(fullpath);
  if (!stat || !stat.isFile())
    return false;
  let root = null;
  try {
    let { stdout } = await (0, import_util.promisify)(exec)("git rev-parse --show-toplevel", { cwd: path.dirname(fullpath) });
    root = stdout.trim();
  } catch (e) {
  }
  if (!root)
    return false;
  let file = path.relative(root, fullpath);
  try {
    let { stdout } = await (0, import_util.promisify)(exec)(`git check-ignore ${file}`, { cwd: root });
    return stdout.trim() == file;
  } catch (e) {
  }
  return false;
}
function isFolderIgnored(folder, ignored) {
  if (isFalsyOrEmpty(ignored))
    return false;
  return ignored.some((p) => minimatch(folder, p, { dot: true }));
}
function resolveRoot(folder, subs, cwd2, bottomup = false, checkCwd = true, ignored = []) {
  let dir = normalizeFilePath(folder);
  if (checkCwd && cwd2 && isParentFolder(cwd2, dir, true) && !isFolderIgnored(cwd2, ignored) && inDirectory(cwd2, subs))
    return cwd2;
  let parts = dir.split(path.sep);
  if (bottomup) {
    while (parts.length > 0) {
      let dir2 = parts.join(path.sep);
      if (!isFolderIgnored(dir2, ignored) && inDirectory(dir2, subs)) {
        return dir2;
      }
      parts.pop();
    }
    return null;
  } else {
    let curr = [parts.shift()];
    for (let part of parts) {
      curr.push(part);
      let dir2 = curr.join(path.sep);
      if (!isFolderIgnored(dir2, ignored) && inDirectory(dir2, subs)) {
        return dir2;
      }
    }
    return null;
  }
}
function checkFolder(dir, patterns, token) {
  return new Promise((resolve, reject) => {
    if (isFalsyOrEmpty(patterns))
      return resolve(false);
    let disposable;
    if (token) {
      disposable = token.onCancellationRequested(() => {
        gl.abort();
        reject(new CancellationError());
      });
    }
    let find = false;
    let pattern = patterns.length == 1 ? patterns[0] : `{${patterns.join(",")}}`;
    let gl = glob(pattern, {
      nosort: true,
      ignore: ["node_modules/**", ".git/**"],
      dot: true,
      cwd: dir,
      nodir: true,
      absolute: false
    }, (_err) => {
      if (disposable)
        disposable.dispose();
      resolve(find);
    });
    gl.on("match", () => {
      if (disposable)
        disposable.dispose();
      find = true;
      gl.abort();
      resolve(true);
    });
    gl.on("end", () => {
      if (disposable)
        disposable.dispose();
      resolve(find);
    });
  });
}
function inDirectory(dir, subs) {
  try {
    let files = fs.readdirSync(dir);
    for (let pattern of subs) {
      let is_wildcard = pattern.includes("*");
      let res = is_wildcard ? minimatch.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0 : files.includes(pattern);
      if (res)
        return true;
    }
  } catch (e) {
  }
  return false;
}
function findMatch(dir, subs) {
  try {
    let files = fs.readdirSync(dir);
    for (let pattern of subs) {
      let isWildcard = pattern.includes("*");
      if (isWildcard) {
        let filtered = files.filter(minimatch.filter(pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }));
        if (filtered.length > 0)
          return filtered[0];
      } else {
        let file = files.find((s) => s === pattern);
        if (file)
          return file;
      }
    }
  } catch (e) {
  }
  return void 0;
}
function findUp(name2, cwd2) {
  let root = path.parse(cwd2).root;
  let subs = toArray(name2);
  while (cwd2 && cwd2 !== root) {
    let find = findMatch(cwd2, subs);
    if (find)
      return path.join(cwd2, find);
    cwd2 = path.dirname(cwd2);
  }
  return null;
}
function readFile(fullpath, encoding2) {
  return new Promise((resolve, reject) => {
    fs.readFile(fullpath, encoding2, (err, content) => {
      if (err)
        reject(err);
      resolve(content);
    });
  });
}
function getFileLineCount(filepath) {
  let i;
  let count = 0;
  return new Promise((resolve, reject) => {
    fs.createReadStream(filepath).on("error", (e) => reject(e)).on("data", (chunk) => {
      for (i = 0; i < chunk.length; ++i)
        if (chunk[i] == 10)
          count++;
    }).on("end", () => resolve(count));
  });
}
function readFileLines(fullpath, start, end) {
  if (!fs.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  let res = [];
  const input = fs.createReadStream(fullpath, { encoding: "utf8" });
  const rl = readline.createInterface({
    input,
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve, reject) => {
    rl.on("line", (line) => {
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n == end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve(res);
      input.close();
    });
    rl.on("error", reject);
  });
}
function readFileLine(fullpath, count) {
  if (!fs.existsSync(fullpath))
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  const input = fs.createReadStream(fullpath, { encoding: "utf8" });
  const rl = readline.createInterface({ input, crlfDelay: Infinity, terminal: false });
  let n = 0;
  let result = "";
  return new Promise((resolve, reject) => {
    rl.on("line", (line) => {
      if (n == count) {
        result = line;
        rl.close();
        input.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve(result);
    });
    rl.on("error", reject);
  });
}
async function lineToLocation(fsPath2, match, text) {
  let uri = URI.file(fsPath2).toString();
  if (!fs.existsSync(fsPath2))
    return Location.create(uri, Range.create(0, 0, 0, 0));
  const rl = readline.createInterface({
    input: fs.createReadStream(fsPath2, { encoding: "utf8" })
  });
  let n = 0;
  let line = await new Promise((resolve) => {
    let find = false;
    rl.on("line", (line2) => {
      if (line2.includes(match)) {
        find = true;
        rl.removeAllListeners();
        rl.close();
        resolve(line2);
        return;
      }
      n = n + 1;
    });
    rl.on("close", () => {
      if (!find)
        resolve(void 0);
    });
  });
  if (line != null) {
    let character = text == null ? 0 : line.indexOf(text);
    if (character == 0)
      character = line.match(/^\s*/)[0].length;
    let end = Position.create(n, character + (text ? text.length : 0));
    return Location.create(uri, Range.create(Position.create(n, character), end));
  }
  return Location.create(uri, Range.create(0, 0, 0, 0));
}
function sameFile(fullpath, other, caseInsensitive) {
  caseInsensitive = typeof caseInsensitive == "boolean" ? caseInsensitive : isWindows || isMacintosh;
  if (!fullpath || !other)
    return false;
  fullpath = normalizeFilePath(fullpath);
  other = normalizeFilePath(other);
  if (caseInsensitive)
    return fullpath.toLowerCase() === other.toLowerCase();
  return fullpath === other;
}
function fileStartsWith(dir, pdir, caseInsensitive = isWindows || isMacintosh) {
  if (caseInsensitive)
    return dir.toLowerCase().startsWith(pdir.toLowerCase());
  return dir.startsWith(pdir);
}
async function writeFile(fullpath, content) {
  await (0, import_util.promisify)(fs.writeFile)(fullpath, content, { encoding: "utf8" });
}
function isFile(uri) {
  return uri.startsWith("file:");
}
function normalizeFilePath(filepath) {
  return URI.file(path.resolve(path.normalize(filepath))).fsPath;
}
function isParentFolder(folder, filepath, checkEqual = false) {
  let pdir = normalizeFilePath(folder);
  let dir = normalizeFilePath(filepath);
  if (sameFile(pdir, dir))
    return checkEqual ? true : false;
  return fileStartsWith(dir, pdir) && dir[pdir.length] == path.sep;
}
var logger3, exec, FileType;
var init_fs = __esm({
  "src/util/fs.ts"() {
    "use strict";
    init_main2();
    init_main();
    init_esm();
    init_logger();
    init_node();
    init_protocol();
    init_array();
    init_errors();
    init_node();
    init_object();
    init_platform();
    logger3 = createLogger("util-fs");
    exec = child_process.exec;
    FileType = /* @__PURE__ */ ((FileType2) => {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
      return FileType2;
    })(FileType || {});
  }
});

// src/model/mru.ts
var Mru;
var init_mru = __esm({
  "src/model/mru.ts"() {
    "use strict";
    init_array();
    init_constants();
    init_fs();
    init_node();
    Mru = class {
      constructor(name2, base, maximum = 5e3) {
        this.maximum = maximum;
        this.file = path.join(base || dataHome, name2);
        let dir = path.dirname(this.file);
        fs.mkdirSync(dir, { recursive: true });
      }
      async load() {
        try {
          let lines = await readFileLines(this.file, 0, this.maximum);
          if (lines.length > this.maximum) {
            let newLines = lines.slice(0, this.maximum);
            await writeFile(this.file, newLines.join("\n"));
            return distinct(newLines);
          }
          return distinct(lines);
        } catch (e) {
          return [];
        }
      }
      loadSync() {
        try {
          let content = fs.readFileSync(this.file, "utf8");
          content = content.trim();
          return content.length ? content.trim().split("\n") : [];
        } catch (e) {
          return [];
        }
      }
      async add(item) {
        let buf;
        try {
          buf = fs.readFileSync(this.file);
          if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) {
            buf = buf.slice(3);
          }
          buf = Buffer.concat([Buffer.from(item, "utf8"), new Uint8Array([10]), buf]);
        } catch (e) {
          buf = Buffer.concat([Buffer.from(item, "utf8"), new Uint8Array([10])]);
        }
        await (0, import_util.promisify)(fs.writeFile)(this.file, buf);
      }
      async remove(item) {
        let items = await this.load();
        let len = items.length;
        items = items.filter((s) => s != item);
        if (items.length != len) {
          await writeFile(this.file, items.join("\n"));
        }
      }
      async clean() {
        try {
          await (0, import_util.promisify)(fs.unlink)(this.file);
        } catch (e) {
        }
      }
    };
  }
});

// src/configuration/types.ts
var ConfigurationUpdateTarget;
var init_types = __esm({
  "src/configuration/types.ts"() {
    "use strict";
    ConfigurationUpdateTarget = /* @__PURE__ */ ((ConfigurationUpdateTarget3) => {
      ConfigurationUpdateTarget3[ConfigurationUpdateTarget3["Global"] = 1] = "Global";
      ConfigurationUpdateTarget3[ConfigurationUpdateTarget3["Workspace"] = 2] = "Workspace";
      ConfigurationUpdateTarget3[ConfigurationUpdateTarget3["WorkspaceFolder"] = 3] = "WorkspaceFolder";
      return ConfigurationUpdateTarget3;
    })(ConfigurationUpdateTarget || {});
  }
});

// src/util/registry.ts
function convertScope(key, scope, defaultScope) {
  if (sourcePrefixes.some((p) => key.startsWith(p)))
    return 1 /* APPLICATION */;
  if (scope === "application" /* Application */)
    return 1 /* APPLICATION */;
  if (scope === "window" /* Window */)
    return 2 /* WINDOW */;
  if (scope === "resource" /* Resource */ || scope === "machine-overridable" /* MachineOverridable */)
    return 3 /* RESOURCE */;
  if (scope === "language-overridable" /* LanguageOverridable */)
    return 4 /* LANGUAGE_OVERRIDABLE */;
  return defaultScope;
}
function convertProperties(properties, defaultScope = 2 /* WINDOW */) {
  let obj = {};
  for (let [key, def] of Object.entries(toObject(properties))) {
    let data = deepClone(def);
    data.scope = convertScope(key, def.scope, defaultScope);
    obj[key] = data;
  }
  return obj;
}
var RegistryImpl, Registry, sourcePrefixes;
var init_registry = __esm({
  "src/util/registry.ts"() {
    "use strict";
    init_types();
    init_errors();
    init_is();
    init_object();
    RegistryImpl = class {
      constructor() {
        this.data = /* @__PURE__ */ new Map();
      }
      add(id, data) {
        assert(typeof id === "string");
        assert(objectLiteral(data));
        assert(!this.data.has(id));
        this.data.set(id, data);
      }
      knows(id) {
        return this.data.has(id);
      }
      as(id) {
        return this.data.get(id) || null;
      }
    };
    Registry = new RegistryImpl();
    sourcePrefixes = ["coc.source.", "list.source."];
  }
});

// src/util/extensionRegistry.ts
function getExtensionDefinitions() {
  let obj = {};
  for (let extensionInfo of extensionRegistry.getExtensions().extensions) {
    let definitions = extensionInfo.definitions;
    Object.entries(toObject(definitions)).forEach(([key, val]) => {
      obj[key] = val;
    });
  }
  return obj;
}
function validRootPattern(rootPattern) {
  return rootPattern && typeof rootPattern.filetype === "string" && !isFalsyOrEmpty(rootPattern.patterns);
}
function validCommandContribution(cmd) {
  return cmd && typeof cmd.command === "string" && typeof cmd.title === "string";
}
function getProperties(configuration2) {
  let obj = {};
  if (Array.isArray(configuration2)) {
    for (let item of configuration2) {
      Object.assign(obj, toObject(item["properties"]));
    }
  } else if (objectLiteral(configuration2["properties"])) {
    obj = configuration2["properties"];
  }
  return obj;
}
function parseExtensionName(stack, level2 = 2) {
  let line = stack.split(/\r?\n/).slice(level2)[0];
  if (!line)
    return void 0;
  line = line.replace(/^\s*at\s*/, "");
  let filepath;
  if (line.endsWith(")")) {
    let ms = line.match(/(\((.*?):\d+:\d+\))$/);
    if (ms)
      filepath = ms[2];
  } else {
    let ms = line.match(/(.*?):\d+:\d+$/);
    if (ms)
      filepath = ms[1];
  }
  if (!filepath)
    return void 0;
  let arr = Array.from(extensionRegistry.getExtensions().extensions);
  let find = arr.find((o) => sameFile(toText(o.filepath), filepath));
  if (find)
    return find.name;
  find = arr.find((o) => isParentFolder(o.directory, filepath));
  if (find)
    return find.name;
  if (isParentFolder(pluginRoot, filepath))
    return "coc.nvim";
}
var Extensions, ExtensionRegistry, extensionRegistry;
var init_extensionRegistry = __esm({
  "src/util/extensionRegistry.ts"() {
    "use strict";
    init_array();
    init_constants();
    init_fs();
    init_is();
    init_object();
    init_registry();
    init_string();
    Extensions = {
      ExtensionContribution: "base.contributions.extensions"
    };
    ExtensionRegistry = class {
      constructor() {
        this.extensionsById = /* @__PURE__ */ new Map();
      }
      get onCommands() {
        let res = [];
        for (let item of this.extensionsById.values()) {
          let { commands, onCommands } = item;
          for (let cmd of onCommands) {
            if (typeof cmd === "string") {
              let find = commands.find((o) => o.command === cmd);
              let title = find == null ? "" : find.title;
              res.push({ id: cmd, title });
            }
          }
        }
        return res;
      }
      getCommandTitle(id) {
        for (let item of this.extensionsById.values()) {
          for (let cmd of toArray(item.commands)) {
            if (cmd.command === id)
              return cmd.title;
          }
        }
        return void 0;
      }
      get commands() {
        let res = [];
        for (let item of this.extensionsById.values()) {
          res.push(...toArray(item.commands).filter(validCommandContribution));
        }
        return res;
      }
      getRootPatternsByFiletype(filetype) {
        let res = [];
        for (let item of this.extensionsById.values()) {
          for (let p of toArray(item.rootPatterns).filter(validRootPattern)) {
            if (p.filetype === filetype)
              res.push(...p.patterns.filter((s) => typeof s === "string"));
          }
        }
        return res;
      }
      unregistExtension(id) {
        this.extensionsById.delete(id);
      }
      registerExtension(id, info) {
        this.extensionsById.set(id, info);
      }
      getExtension(id) {
        return this.extensionsById.get(id);
      }
      getExtensions() {
        return { extensions: this.extensionsById.values() };
      }
    };
    extensionRegistry = new ExtensionRegistry();
    Registry.add(Extensions.ExtensionContribution, extensionRegistry);
  }
});

// src/commands.ts
var logger4, CommandItem, extensionRegistry2, CommandManager, commands_default;
var init_commands = __esm({
  "src/commands.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_mru();
    init_array();
    init_extensionRegistry();
    init_protocol();
    init_registry();
    init_string();
    logger4 = createLogger("commands");
    CommandItem = class {
      constructor(id, impl, thisArg, internal) {
        this.id = id;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
      }
      execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, toArray(args));
      }
      dispose() {
        this.thisArg = null;
        this.impl = null;
      }
    };
    extensionRegistry2 = Registry.as(Extensions.ExtensionContribution);
    CommandManager = class {
      constructor() {
        this.commands = /* @__PURE__ */ new Map();
        this.titles = /* @__PURE__ */ new Map();
        this.mru = new Mru("commands");
      }
      get commandList() {
        let res = [];
        for (let item of this.commands.values()) {
          if (!item.internal) {
            let { id } = item;
            let title = this.titles.get(id) ?? extensionRegistry2.getCommandTitle(id);
            res.push({ id, title: toText(title) });
          }
        }
        return res;
      }
      dispose() {
        for (const registration of this.commands.values()) {
          registration.dispose();
        }
        this.commands.clear();
      }
      execute(command) {
        return this.executeCommand(command.command, ...command.arguments ?? []);
      }
      register(command, internal, description) {
        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
          this.registerCommand(id, command.execute, command, internal);
          if (description)
            this.titles.set(id, description);
        }
        return command;
      }
      has(id) {
        return this.commands.has(id);
      }
      unregister(id) {
        let item = this.commands.get(id);
        if (!item)
          return;
        item.dispose();
        this.commands.delete(id);
      }
      registerCommand(id, impl, thisArg, internal = false) {
        if (id.startsWith("_"))
          internal = true;
        if (this.commands.has(id))
          logger4.warn(`Command ${id} already registered`);
        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
        return import_node3.Disposable.create(() => {
          this.commands.delete(id);
        });
      }
      executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd)
          throw new Error(`Command: ${command} not found`);
        return Promise.resolve(cmd.execute.apply(cmd, rest));
      }
      async fireCommand(id, ...args) {
        await events_default.fire("Command", [id]);
        let start = Date.now();
        let res = await this.executeCommand(id, ...args);
        if (args.length == 0) {
          await this.addRecent(id, events_default.lastChangeTs > start);
        }
        return res;
      }
      async addRecent(cmd, repeat2) {
        await this.mru.add(cmd);
        if (repeat2)
          this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`, true);
      }
      async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
          await this.executeCommand(first);
          await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
      }
    };
    commands_default = new CommandManager();
  }
});

// src/util/numbers.ts
function toNumber(n, defaultValue2 = 0) {
  return number(n) ? n : defaultValue2;
}
function boolToNumber(val) {
  return val ? 1 : 0;
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
var init_numbers = __esm({
  "src/util/numbers.ts"() {
    "use strict";
    init_is();
  }
});

// src/model/outputChannel.ts
var BufferChannel;
var init_outputChannel = __esm({
  "src/model/outputChannel.ts"() {
    "use strict";
    BufferChannel = class {
      constructor(name2, nvim, onDispose) {
        this.name = name2;
        this.nvim = nvim;
        this.onDispose = onDispose;
        this.lines = [""];
        this._disposed = false;
        this.created = false;
        if (!/^[\w\s-.]+$/.test(name2))
          throw new Error(`Invalid channel name "${name2}", only word characters and white space allowed.`);
      }
      get content() {
        return this.lines.join("\n");
      }
      _append(value) {
        let { nvim } = this;
        if (!nvim)
          return;
        let idx = this.lines.length - 1;
        let newlines = value.split(/\r?\n/);
        let lastline = this.lines[idx] + newlines[0];
        this.lines[idx] = lastline;
        let append = newlines.slice(1);
        this.lines = this.lines.concat(append);
        if (!this.created)
          return;
        nvim.pauseNotification();
        nvim.call("setbufline", [this.bufname, "$", lastline], true);
        if (append.length) {
          nvim.call("appendbufline", [this.bufname, "$", append], true);
        }
        nvim.resumeNotification(false, true);
      }
      append(value) {
        if (!this.validate())
          return;
        this._append(value);
      }
      appendLine(value) {
        if (!this.validate())
          return;
        this._append(value + "\n");
      }
      clear(keep) {
        let { nvim } = this;
        if (!this.validate() || !nvim)
          return;
        this.lines = keep ? this.lines.slice(-keep) : [];
        if (!this.created)
          return;
        nvim.pauseNotification();
        nvim.call("deletebufline", [this.bufname, 1, "$"], true);
        if (this.lines.length) {
          nvim.call("appendbufline", [this.bufname, "$", this.lines], true);
        }
        nvim.resumeNotification(true, true);
      }
      hide() {
        this.created = false;
        if (this.nvim)
          this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);
      }
      get bufname() {
        return `output:///${this.name}`;
      }
      show(preserveFocus, cmd = "vs") {
        let { nvim } = this;
        if (!nvim)
          return;
        nvim.pauseNotification();
        nvim.command(`exe '${cmd} '.fnameescape('${this.bufname}')`, true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        nvim.resumeNotification(true, true);
        this.created = true;
      }
      validate() {
        return !this._disposed;
      }
      dispose() {
        if (this.onDispose)
          this.onDispose();
        this._disposed = true;
        this.hide();
        this.lines = [];
      }
    };
  }
});

// src/core/channels.ts
var Channels, channels_default;
var init_channels = __esm({
  "src/core/channels.ts"() {
    "use strict";
    init_events();
    init_outputChannel();
    Channels = class {
      constructor() {
        this.outputChannels = /* @__PURE__ */ new Map();
        this.bufnrs = /* @__PURE__ */ new Map();
        this.disposable = events_default.on("BufUnload", (bufnr) => {
          let name2 = this.bufnrs.get(bufnr);
          if (name2) {
            let channel = this.outputChannels.get(name2);
            if (channel)
              channel.created = false;
          }
        });
      }
      getProvider(nvim) {
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async (uri) => {
            let channel = this.get(uri.path.slice(1));
            if (!channel)
              return "";
            nvim.pauseNotification();
            nvim.call("bufnr", ["%"], true);
            nvim.command("setlocal nospell nofoldenable nowrap noswapfile", true);
            nvim.command("setlocal buftype=nofile bufhidden=hide", true);
            nvim.command("setfiletype log", true);
            let res = await nvim.resumeNotification();
            this.bufnrs.set(res[0][0], channel.name);
            channel.created = true;
            return channel.content;
          }
        };
        return provider;
      }
      get names() {
        return Array.from(this.outputChannels.keys());
      }
      get(channelName) {
        return this.outputChannels.get(channelName);
      }
      create(name2, nvim) {
        if (this.outputChannels.has(name2))
          return this.outputChannels.get(name2);
        let channel = new BufferChannel(name2, nvim, () => {
          this.outputChannels.delete(name2);
        });
        this.outputChannels.set(name2, channel);
        return channel;
      }
      show(name2, cmd, preserveFocus) {
        let channel = this.outputChannels.get(name2);
        if (!channel)
          return;
        channel.show(preserveFocus, cmd);
      }
      dispose() {
        this.disposable.dispose();
        for (let channel of this.outputChannels.values()) {
          channel.dispose();
        }
        this.outputChannels.clear();
      }
    };
    channels_default = new Channels();
  }
});

// src/model/dialog.ts
var Dialog;
var init_dialog = __esm({
  "src/model/dialog.ts"() {
    "use strict";
    init_protocol();
    init_events();
    init_util();
    init_array();
    Dialog = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._onDidClose = new import_node3.Emitter();
        this.onDidClose = this._onDidClose.event;
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback)
              config.callback(-1);
          }
        }, null, this.disposables);
        let btns = toArray(config.buttons).filter((o) => o.disabled != true);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback)
              config.callback(btns[idx].index);
          }
        }, null, this.disposables);
      }
      get lines() {
        return [...this.config.content.split(/\r?\n/)];
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, highlights, buttons } = this.config;
        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
        let highlight = this.config.highlight || preferences.floatHighlight;
        let opts = { maxwidth: preferences.maxWidth || 80 };
        if (title)
          opts.title = title;
        if (close || typeof close === "undefined")
          opts.close = 1;
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (highlight)
          opts.highlight = highlight;
        if (highlights)
          opts.highlights = highlights;
        if (borderhighlight)
          opts.borderhighlight = [borderhighlight];
        if (buttons)
          opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        if (preferences.rounded)
          opts.rounded = 1;
        if (Array.isArray(opts.buttons))
          opts.getchar = 1;
        let [_winid, bufnr] = await nvim.call("coc#dialog#create_dialog", [this.lines, opts]);
        this.bufnr = bufnr;
        nvim.command("redraw", true);
      }
      get winid() {
        if (!this.bufnr)
          return Promise.resolve(null);
        return this.nvim.call("bufwinid", [this.bufnr]);
      }
      dispose() {
        this._onDidClose.fire();
        this.bufnr = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/input.ts
var InputBox;
var init_input = __esm({
  "src/model/input.ts"() {
    "use strict";
    init_protocol();
    init_events();
    init_util();
    init_object();
    init_string();
    InputBox = class {
      constructor(nvim, defaultValue2) {
        this.nvim = nvim;
        this.disposables = [];
        this.accepted = false;
        this._disposed = false;
        this._dimension = [0, 0, 0, 0];
        this._onDidFinish = new import_node3.Emitter();
        this._onDidChange = new import_node3.Emitter();
        this.clear = false;
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChange = this._onDidChange.event;
        this._input = defaultValue2;
        this.disposables.push(this._onDidFinish);
        this.disposables.push(this._onDidChange);
        let _title;
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            _title = newTitle;
            if (this._winid)
              nvim.call("coc#dialog#change_title", [this._winid, newTitle], true);
          },
          get: () => {
            return _title;
          }
        });
        let _loading = false;
        Object.defineProperty(this, "loading", {
          set: (loading) => {
            _loading = loading;
            if (this._winid)
              nvim.call("coc#dialog#change_loading", [this._winid, loading], true);
          },
          get: () => {
            return _loading;
          }
        });
        let _borderhighlight;
        Object.defineProperty(this, "borderhighlight", {
          set: (borderhighlight) => {
            _borderhighlight = borderhighlight;
            if (this._winid)
              nvim.call("coc#dialog#change_border_hl", [this._winid, borderhighlight], true);
          },
          get: () => {
            return _borderhighlight;
          }
        });
        Object.defineProperty(this, "value", {
          set: (value) => {
            value = toText(value);
            if (value !== this._input) {
              this.clearVirtualText();
              this._input = value;
              this.nvim.call("coc#dialog#change_input_value", [this.winid, this.bufnr, value], true);
              this._onDidChange.fire(value);
            }
          },
          get: () => {
            return this._input;
          }
        });
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this._bufnr) {
            this._winid = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("PromptInsert", (value, bufnr) => {
          if (bufnr == this._bufnr) {
            this._input = value;
            this.accepted = true;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("TextChangedI", (bufnr, info) => {
          if (bufnr == this._bufnr && this._input !== info.line) {
            this.clearVirtualText();
            this._input = info.line;
            this._onDidChange.fire(info.line);
          }
        }, null, this.disposables);
      }
      clearVirtualText() {
        if (this.clear && this.bufnr) {
          this.clear = false;
          let buf = this.nvim.createBuffer(this.bufnr);
          buf.clearNamespace("input-box");
        }
      }
      get dimension() {
        let { _dimension } = this;
        return { width: _dimension[0], height: _dimension[1], row: _dimension[2], col: _dimension[3] };
      }
      get bufnr() {
        return this._bufnr;
      }
      get winid() {
        return this._winid;
      }
      async show(title, preferences) {
        this.title = title;
        this.borderhighlight = preferences.borderhighlight ?? "CocFloating";
        this.loading = false;
        if (preferences.placeHolder && !this._input && !this.nvim.isVim) {
          this.clear = true;
        }
        let config = omitUndefined(preferences);
        let res = await this.nvim.call("coc#dialog#create_prompt_win", [title, this._input, config]);
        if (!res)
          throw new Error("Unable to open input window");
        this._bufnr = res[0];
        this._winid = res[1];
        this._dimension = res[2];
        return true;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        this.nvim.call("coc#float#close", [this._winid ?? -1], true);
        this._onDidFinish.fire(this.accepted ? this._input : null);
        this._winid = void 0;
        this._bufnr = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/popup.ts
var Popup;
var init_popup = __esm({
  "src/model/popup.ts"() {
    "use strict";
    init_constants();
    Popup = class {
      constructor(nvim, winid, bufnr, linecount, _currIndex = 0) {
        this.nvim = nvim;
        this.winid = winid;
        this.bufnr = bufnr;
        this.linecount = linecount;
        this._currIndex = _currIndex;
      }
      get currIndex() {
        return this._currIndex;
      }
      close() {
        this.nvim.call("coc#float#close", [this.winid], true);
      }
      refreshScrollbar() {
        if (!isVim)
          this.nvim.call("coc#float#nvim_scrollbar", [this.winid], true);
      }
      execute(cmd) {
        this.nvim.call("coc#compat#execute", [this.winid, cmd], true);
      }
      async getWininfo() {
        return await this.nvim.call("coc#float#get_wininfo", [this.winid]);
      }
      async scrollForward() {
        let { nvim, bufnr } = this;
        let buf = nvim.createBuffer(bufnr);
        let total = await buf.length;
        let { botline } = await this.getWininfo();
        if (botline >= total || botline == 0)
          return;
        nvim.pauseNotification();
        this.setCursor(botline - 1);
        this.execute(`silent! noa setl scrolloff=0`);
        this.execute(`normal! ${botline}Gzt`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async scrollBackward() {
        let { nvim } = this;
        let { topline } = await this.getWininfo();
        if (topline == 1)
          return;
        nvim.pauseNotification();
        this.setCursor(topline - 1);
        this.execute(`normal! ${topline}Gzb`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      setCursor(index, redraw = false) {
        let { nvim, bufnr, winid, linecount } = this;
        if (index < 0) {
          index = 0;
        } else if (index > linecount - 1) {
          index = linecount - 1;
        }
        this._currIndex = index;
        nvim.call("coc#dialog#set_cursor", [winid, bufnr, index + 1], true);
        if (redraw) {
          this.refreshScrollbar();
          nvim.command("redraw", true);
        }
      }
    };
  }
});

// src/model/menu.ts
function isMenuItem(item) {
  if (!item)
    return false;
  return typeof item.text === "string";
}
function toIndexText(n) {
  return n < 99 ? `${n + 1}. ` : "  ";
}
var Menu;
var init_menu = __esm({
  "src/model/menu.ts"() {
    "use strict";
    init_protocol();
    init_events();
    init_util();
    init_string();
    init_popup();
    Menu = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.currIndex = 0;
        this.contentHeight = 0;
        this.disposables = [];
        this.keyMappings = /* @__PURE__ */ new Map();
        this.shortcutIndexes = /* @__PURE__ */ new Set();
        this._disposed = false;
        this._onDidClose = new import_node3.Emitter();
        this.onDidClose = this._onDidClose.event;
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            this._onDidClose.fire(-1);
            this.dispose();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(-1);
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(-1);
          this.dispose();
        });
        this.addKeys(["\r", "<cr>"], () => {
          this.selectCurrent();
        });
        let setCursorIndex = (idx) => {
          nvim.pauseNotification();
          this.setCursor(idx + this.contentHeight);
          this.win.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys("<C-f>", async () => {
          await this.win.scrollForward();
        });
        this.addKeys("<C-b>", async () => {
          await this.win.scrollBackward();
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        let timer;
        let firstNumber;
        const choose = (n) => {
          let disabled = this.isDisabled(n);
          if (disabled)
            return;
          this._onDidClose.fire(n);
          this.dispose();
        };
        this.addKeys(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], (character) => {
          if (timer)
            clearTimeout(timer);
          let n = parseInt(character, 10);
          if (isNaN(n) || n > this.total)
            return;
          if (firstNumber == null && n == 0)
            return;
          if (firstNumber) {
            let count = firstNumber * 10 + n;
            firstNumber = void 0;
            choose(count - 1);
            return;
          }
          if (this.total < 10 || n * 10 > this.total) {
            choose(n - 1);
            return;
          }
          timer = setTimeout(async () => {
            choose(n - 1);
          }, 200);
          firstNumber = n;
        });
        if (this.config.shortcuts) {
          this.addShortcuts(choose);
        }
      }
      addShortcuts(choose) {
        let { items } = this.config;
        let texts = items.map((o) => {
          return isMenuItem(o) ? o.text : o;
        });
        texts.forEach((text, idx) => {
          if (text.length) {
            let s = text[0];
            if (isAlphabet(s.charCodeAt(0)) && !this.keyMappings.has(s)) {
              this.shortcutIndexes.add(idx);
              this.addKeys(s, () => {
                choose(idx);
              });
            }
          }
        });
      }
      isDisabled(idx) {
        let { items } = this.config;
        let item = items[idx];
        if (isMenuItem(item) && item.disabled) {
          return true;
        }
        return false;
      }
      async show(preferences = {}) {
        let { nvim, shortcutIndexes } = this;
        let { title, items, borderhighlight, position, content } = this.config;
        let opts = {};
        if (title)
          opts.title = title;
        if (position === "center")
          opts.relative = "editor";
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (borderhighlight) {
          opts.borderhighlight = borderhighlight;
        } else if (preferences.floatBorderHighlight) {
          opts.borderhighlight = preferences.floatBorderHighlight;
        }
        if (preferences.rounded)
          opts.rounded = 1;
        if (typeof content === "string")
          opts.content = content;
        if (preferences.confirmKey) {
          this.addKeys(preferences.confirmKey, () => {
            this.selectCurrent();
          });
        }
        let highlights = [];
        let lines = items.map((v, i) => {
          let text = isMenuItem(v) ? v.text : v;
          let pre = toIndexText(i);
          if (shortcutIndexes.has(i)) {
            highlights.push({
              lnum: i,
              hlGroup: preferences.shortcutHighlight || "MoreMsg",
              colStart: byteLength(pre),
              colEnd: byteLength(pre) + 1
            });
          }
          return pre + text.trim();
        });
        lines.forEach((line, i) => {
          let item = items[i];
          if (isMenuItem(item) && item.disabled) {
            highlights.push({
              hlGroup: "CocDisabled",
              lnum: i,
              colStart: 0,
              colEnd: byteLength(line)
            });
          }
        });
        if (highlights.length)
          opts.highlights = highlights;
        let [winid, bufnr, contentHeight] = await nvim.call("coc#dialog#create_menu", [lines, opts]);
        nvim.command("redraw", true);
        if (this._disposed)
          return;
        this.win = new Popup(nvim, winid, bufnr, lines.length + contentHeight, contentHeight);
        this.bufnr = bufnr;
        this.contentHeight = contentHeight;
        this.attachEvents();
        nvim.call("coc#prompt#start_prompt", ["menu"], true);
      }
      selectCurrent() {
        if (this.isDisabled(this.currIndex)) {
          let item = this.config.items[this.currIndex];
          if (item.disabled["reason"]) {
            this.nvim.outWriteLine(`Item disabled: ${item.disabled["reason"]}`);
          }
          return;
        }
        this._onDidClose.fire(this.currIndex);
        this.dispose();
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a2;
        if (this._disposed)
          return;
        this._disposed = true;
        disposeAll(this.disposables);
        this.shortcutIndexes.clear();
        this.keyMappings.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["menu"], true);
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this.bufnr = void 0;
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "menu" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn)
          await Promise.resolve(fn(character));
      }
      setCursor(index) {
        this.currIndex = index - this.contentHeight;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/picker.ts
function toPickerItems(items) {
  return items.map((item) => typeof item === "string" ? { label: item } : item);
}
var Picker;
var init_picker = __esm({
  "src/model/picker.ts"() {
    "use strict";
    init_events();
    init_util();
    init_protocol();
    init_string();
    init_popup();
    Picker = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.picked = /* @__PURE__ */ new Set();
        this.disposables = [];
        this.keyMappings = /* @__PURE__ */ new Map();
        this._onDidClose = new import_node3.Emitter();
        this.onDidClose = this._onDidClose.event;
        for (let i = 0; i < config.items.length; i++) {
          let item = config.items[i];
          if (item.picked)
            this.picked.add(i);
        }
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a2;
            (_a2 = this.win) == null ? void 0 : _a2.close();
          });
        }
        this.disposables.push(this._onDidClose);
      }
      get currIndex() {
        return this.win ? this.win.currIndex : 0;
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(void 0);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr != this.bufnr)
            return;
          if (idx == 0) {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected.length > 0 ? selected : void 0);
          } else {
            this._onDidClose.fire(void 0);
          }
          this.dispose();
        }, null, this.disposables);
        this.addKeymappings();
      }
      addKeymappings() {
        let { nvim } = this;
        const toggleSelect = (idx) => {
          if (this.picked.has(idx)) {
            this.picked.delete(idx);
          } else {
            this.picked.add(idx);
          }
        };
        this.addKeys("<LeftRelease>", async () => {
          let [winid, lnum, col] = await nvim.call("coc#ui#get_mouse");
          nvim.pauseNotification();
          if (winid == this.win.winid) {
            if (col <= 3) {
              toggleSelect(lnum - 1);
              this.changeLine(lnum - 1);
            } else {
              this.win.setCursor(lnum - 1);
            }
          }
          nvim.call("win_gotoid", [winid], true);
          nvim.call("cursor", [lnum, col], true);
          nvim.call("coc#float#nvim_float_click", [], true);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(void 0);
          this.dispose();
        });
        this.addKeys("<cr>", () => {
          if (this.picked.size == 0) {
            this._onDidClose.fire(void 0);
          } else {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected);
          }
          this.dispose();
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          this.win.setCursor(this.currIndex + 1, true);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          this.win.setCursor(this.currIndex - 1, true);
        });
        this.addKeys(["g"], () => {
          this.win.setCursor(0, true);
        });
        this.addKeys(["G"], () => {
          this.win.setCursor(this.total - 1, true);
        });
        this.addKeys(" ", async () => {
          let idx = this.currIndex;
          toggleSelect(idx);
          nvim.pauseNotification();
          this.changeLine(idx);
          this.win.setCursor(this.currIndex + 1);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys("<C-f>", async () => {
          await this.win.scrollForward();
        });
        this.addKeys("<C-b>", async () => {
          await this.win.scrollBackward();
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = { close: 1, cursorline: 1 };
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (title)
          opts.title = title;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
          opts.borderhighlight = [preferences.floatBorderHighlight];
        if (preferences.pickerButtons) {
          let shortcut = preferences.pickerButtonShortcut;
          opts.buttons = ["Submit" + (shortcut ? " <cr>" : ""), "Cancel" + (shortcut ? " <esc>" : "")];
        }
        if (preferences.rounded)
          opts.rounded = 1;
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(void 0);
            this.dispose();
          });
        }
        let lines = [];
        let highlights = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let line = `[${item.picked ? "x" : " "}] ${item.label}`;
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            highlights.push({ hlGroup: "Comment", lnum: i, colStart: start, colEnd: byteLength(line) });
          }
          lines.push(line);
        }
        if (highlights.length)
          opts.highlights = highlights;
        let res = await nvim.call("coc#dialog#create_dialog", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1], lines.length);
        this.bufnr = res[1];
        nvim.call("coc#prompt#start_prompt", ["picker"], true);
        this.attachEvents();
        this.win.setCursor(0, true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a2;
        this.picked.clear();
        this.keyMappings.clear();
        disposeAll(this.disposables);
        this.nvim.call("coc#prompt#stop_prompt", ["picker"], true);
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "picker" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn)
          await Promise.resolve(fn(character));
      }
      changeLine(index) {
        let { nvim } = this;
        let item = this.config.items[index];
        if (!item)
          return;
        let line = `[${this.picked.has(index) ? "x" : " "}] ${item.label}`;
        let col = byteLength(line);
        if (item.description)
          line = line + ` ${item.description}`;
        nvim.call("setbufline", [this.bufnr, index + 1, line], true);
        let buf = nvim.createBuffer(this.bufnr);
        buf.addHighlight({ hlGroup: "Comment", line: index, srcId: 1, colStart: col, colEnd: -1 });
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/util/filter.ts
function initTable() {
  const table = [];
  const row = [];
  for (let i = 0; i <= _maxLen; i++) {
    row[i] = 0;
  }
  for (let i = 0; i <= _maxLen; i++) {
    table.push(row.slice(0));
  }
  return table;
}
function initArr(maxLen) {
  const row = [];
  for (let i = 0; i <= maxLen; i++) {
    row[i] = 0;
  }
  return row;
}
function isUpperCaseAtPos(pos, word, wordLow) {
  return word[pos] !== wordLow[pos];
}
function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2) {
  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options2);
}
function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options2) {
  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2);
  if (top && !aggressive) {
    return top;
  }
  if (pattern.length >= 3) {
    const tries = Math.min(7, pattern.length - 1);
    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
      const newPattern = nextTypoPermutation(pattern, movingPatternPos);
      if (newPattern) {
        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options2);
        if (candidate) {
          candidate[0] -= 3;
          if (!top || candidate[0] > top[0]) {
            top = candidate;
          }
        }
      }
    }
  }
  return top;
}
function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options2 = { boostFullMatch: true, firstMatchCanBeWeak: false }) {
  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
  const wordLen = word.length > _maxLen ? _maxLen : word.length;
  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {
    return void 0;
  }
  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {
    return void 0;
  }
  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);
  let row = 1;
  let column = 1;
  let patternPos = patternStart;
  let wordPos = wordStart;
  const hasStrongFirstMatch = [false];
  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
    const minWordMatchPos = _minWordMatchPos[patternPos];
    const maxWordMatchPos = _maxWordMatchPos[patternPos];
    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;
    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {
      let score3 = Number.MIN_SAFE_INTEGER;
      let canComeDiag = false;
      if (wordPos <= maxWordMatchPos) {
        score3 = _doScore(
          pattern,
          patternLow,
          patternPos,
          patternStart,
          word,
          wordLow,
          wordPos,
          wordLen,
          wordStart,
          _diag[row - 1][column - 1] === 0,
          hasStrongFirstMatch
        );
      }
      let diagScore = 0;
      canComeDiag = true;
      diagScore = score3 + _table[row - 1][column - 1];
      const canComeLeft = wordPos > minWordMatchPos;
      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;
      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;
      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;
      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {
        _table[row][column] = leftLeftScore;
        _arrows[row][column] = 3 /* LeftLeft */;
        _diag[row][column] = 0;
      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {
        _table[row][column] = leftScore;
        _arrows[row][column] = 2 /* Left */;
        _diag[row][column] = 0;
      } else {
        _table[row][column] = diagScore;
        _arrows[row][column] = 1 /* Diag */;
        _diag[row][column] = _diag[row - 1][column - 1] + 1;
      }
    }
  }
  if (!hasStrongFirstMatch[0] && !options2.firstMatchCanBeWeak) {
    return void 0;
  }
  row--;
  column--;
  const result = [_table[row][column], wordStart];
  let backwardsDiagLength = 0;
  let maxMatchColumn = 0;
  while (row >= 1) {
    let diagColumn = column;
    do {
      const arrow = _arrows[row][diagColumn];
      if (arrow === 3 /* LeftLeft */) {
        diagColumn = diagColumn - 2;
      } else if (arrow === 2 /* Left */) {
        diagColumn = diagColumn - 1;
      } else {
        break;
      }
    } while (diagColumn >= 1);
    if (backwardsDiagLength > 1 && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && backwardsDiagLength + 1 > _diag[row][diagColumn]) {
      diagColumn = column;
    }
    if (diagColumn === column) {
      backwardsDiagLength++;
    } else {
      backwardsDiagLength = 1;
    }
    if (!maxMatchColumn) {
      maxMatchColumn = diagColumn;
    }
    row--;
    column = diagColumn - 1;
    result.push(column);
  }
  if (wordLen === patternLen && options2.boostFullMatch) {
    result[0] += 2;
  }
  const skippedCharsCount = maxMatchColumn - patternLen;
  result[0] -= skippedCharsCount;
  return result;
}
function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2) {
  const max = Math.min(13, pattern.length);
  for (; patternPos < max; patternPos++) {
    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2);
    if (result) {
      return result;
    }
  }
  return [0, wordPos];
}
function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {
  if (patternLow[patternPos] !== wordLow[wordPos]) {
    return Number.MIN_SAFE_INTEGER;
  }
  let score3 = 1;
  let isGapLocation = false;
  if (wordPos === patternPos - patternStart) {
    score3 = pattern[patternPos] === word[wordPos] ? 7 : 5;
  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
    score3 = pattern[patternPos] === word[wordPos] ? 7 : 5;
    isGapLocation = true;
  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
    score3 = 5;
  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
    score3 = 5;
    isGapLocation = true;
  }
  if (score3 > 1 && patternPos === patternStart) {
    outFirstMatchStrong[0] = true;
  }
  if (!isGapLocation) {
    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);
  }
  if (patternPos === patternStart) {
    if (wordPos > wordStart) {
      score3 -= isGapLocation ? 3 : 5;
    }
  } else {
    if (newMatchStart) {
      score3 += isGapLocation ? 2 : 0;
    } else {
      score3 += isGapLocation ? 0 : 1;
    }
  }
  if (wordPos + 1 === wordLen) {
    score3 -= isGapLocation ? 3 : 5;
  }
  return score3;
}
function isSeparatorAtPos(value, index) {
  const code = value.codePointAt(index);
  switch (code) {
    case 95 /* Underline */:
    case 45 /* Dash */:
    case 46 /* Period */:
    case 32 /* Space */:
    case 47 /* Slash */:
    case 92 /* Backslash */:
    case 39 /* SingleQuote */:
    case 34 /* DoubleQuote */:
    case 58 /* Colon */:
    case 36 /* DollarSign */:
    case 60 /* LessThan */:
    case 62 /* GreaterThan */:
    case 40 /* OpenParen */:
    case 41 /* CloseParen */:
    case 91 /* OpenSquareBracket */:
    case 93 /* CloseSquareBracket */:
    case 123 /* OpenCurlyBrace */:
    case 125 /* CloseCurlyBrace */:
      return true;
    case void 0:
      return false;
    default:
      if (isEmojiImprecise(code)) {
        return true;
      }
      return false;
  }
}
function isWhitespaceAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }
  const code = value.charCodeAt(index);
  switch (code) {
    case 32 /* Space */:
    case 9 /* Tab */:
      return true;
    default:
      return false;
  }
}
function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {
  while (patternPos < patternLen && wordPos < wordLen) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      if (fillMinWordPosArr) {
        _minWordMatchPos[patternPos] = wordPos;
      }
      patternPos += 1;
    }
    wordPos += 1;
  }
  return patternPos === patternLen;
}
function _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {
  let patternPos = patternLen - 1;
  let wordPos = wordLen - 1;
  while (patternPos >= patternStart && wordPos >= wordStart) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      _maxWordMatchPos[patternPos] = wordPos;
      patternPos--;
    }
    wordPos--;
  }
}
function nextTypoPermutation(pattern, patternPos) {
  if (patternPos + 1 >= pattern.length) {
    return void 0;
  }
  const swap1 = pattern[patternPos];
  const swap2 = pattern[patternPos + 1];
  if (swap1 === swap2) {
    return void 0;
  }
  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);
}
var _maxLen, _minWordMatchPos, _maxWordMatchPos, _diag, _table, _arrows;
var init_filter = __esm({
  "src/util/filter.ts"() {
    "use strict";
    init_charCode();
    init_string();
    _maxLen = 128;
    _minWordMatchPos = initArr(2 * _maxLen);
    _maxWordMatchPos = initArr(2 * _maxLen);
    _diag = initTable();
    _table = initTable();
    _arrows = initTable();
  }
});

// src/model/fuzzyMatch.ts
async function initFuzzyWasm() {
  const buffer = await (0, import_util.promisify)(fs.readFile)(wasmFile);
  const res = await global.WebAssembly.instantiate(buffer, { env: {} });
  return res.instance.exports;
}
function toSpans(label, score3) {
  let res = [];
  for (let span of matchSpansReverse(label, score3, 2)) {
    res.push(span);
  }
  return res;
}
function* matchSpansReverse(text, positions, endIndex = 0, max = Number.MAX_SAFE_INTEGER) {
  let len = positions.length;
  if (len <= endIndex)
    return;
  let byteIndex2 = bytes(text, Math.min(positions[endIndex] + 1, max));
  let start;
  let prev;
  for (let i = len - 1; i >= endIndex; i--) {
    let curr = positions[i];
    if (curr >= max) {
      if (start != null)
        yield [byteIndex2(start), byteIndex2(prev + 1)];
      break;
    }
    if (prev != void 0) {
      let d = curr - prev;
      if (d == 1) {
        prev = curr;
      } else if (d > 1) {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        start = curr;
      } else {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        break;
      }
    } else {
      start = curr;
    }
    prev = curr;
    if (i == endIndex) {
      yield [byteIndex2(start), byteIndex2(prev + 1)];
    }
  }
}
function* matchSpans(text, positions, max) {
  max = max ? Math.min(max, text.length) : text.length;
  let byteIndex2 = bytes(text, Math.min(text.length, 4096));
  let start;
  let prev;
  let len = positions.length;
  for (let i = 0; i < len; i++) {
    let curr = positions[i];
    if (curr >= max) {
      if (start != null)
        yield [byteIndex2(start), byteIndex2(prev + 1)];
      break;
    }
    if (prev != void 0) {
      let d = curr - prev;
      if (d == 1) {
        prev = curr;
      } else if (d > 1) {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        start = curr;
      } else {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        break;
      }
    } else {
      start = curr;
    }
    prev = curr;
    if (i == len - 1) {
      yield [byteIndex2(start), byteIndex2(prev + 1)];
    }
  }
}
var wasmFile, FuzzyMatch;
var init_fuzzyMatch = __esm({
  "src/model/fuzzyMatch.ts"() {
    "use strict";
    init_constants();
    init_filter();
    init_node();
    init_string();
    wasmFile = path.join(pluginRoot, "bin/fuzzy.wasm");
    FuzzyMatch = class {
      constructor(exports2) {
        this.exports = exports2;
        this.patternLength = 0;
        this.matchSeq = false;
        this.sizes = [2048, 1024, 1024];
      }
      matchSpans(text, positions, max) {
        return matchSpans(text, positions, max);
      }
      matchScoreSpans(text, score3) {
        return matchSpansReverse(text, score3, 2);
      }
      createScoreFunction(pattern, patternPos, options2, kind) {
        let lowPattern = pattern.toLowerCase();
        let fn;
        if (kind === "any") {
          fn = anyScore;
        } else if (kind === "aggressive") {
          fn = fuzzyScoreGracefulAggressive;
        } else {
          fn = fuzzyScore;
        }
        return (word, wordPos = 0) => {
          return fn(pattern, lowPattern, patternPos, word, word.toLowerCase(), wordPos, options2);
        };
      }
      getSizes() {
        return this.sizes;
      }
      setPattern(pattern, matchSeq = false) {
        if (pattern.length > 256)
          pattern = pattern.slice(0, 256);
        this.matchSeq = matchSeq;
        this.patternLength = matchSeq ? pattern.length : pattern.replace(/(\s|\t)/g, "").length;
        if (this.patternPtr == null) {
          let { malloc } = this.exports;
          let { sizes } = this;
          this.contentPtr = malloc(sizes[0]);
          this.patternPtr = malloc(sizes[1]);
          this.resultPtr = malloc(sizes[2]);
        }
        let buf = Buffer.from(pattern, "utf8");
        let len = buf.length;
        let bytes2 = new Uint8Array(this.exports.memory.buffer, this.patternPtr, len + 1);
        bytes2.set(buf);
        bytes2[len] = 0;
      }
      changeContent(text) {
        let { sizes } = this;
        if (text.length > 4096)
          text = text.slice(0, 4096);
        let buf = Buffer.from(text, "utf8");
        let len = buf.length;
        if (len > sizes[0]) {
          let { malloc, free } = this.exports;
          free(this.contentPtr);
          let byteLength2 = len + 1;
          this.contentPtr = malloc(byteLength2);
          sizes[0] = byteLength2;
        }
        let bytes2 = new Uint8Array(this.exports.memory.buffer, this.contentPtr, len + 1);
        bytes2.set(buf);
        bytes2[len] = 0;
      }
      match(text) {
        if (this.patternPtr == null)
          throw new Error("setPattern not called before match");
        if (this.patternLength === 0)
          return { score: 100, positions: new Uint32Array() };
        this.changeContent(text);
        let { fuzzyMatch: fuzzyMatch2, memory } = this.exports;
        let { resultPtr } = this;
        let score3 = fuzzyMatch2(this.contentPtr, this.patternPtr, resultPtr, this.matchSeq ? 1 : 0);
        if (!score3)
          return void 0;
        const u32 = new Uint32Array(memory.buffer, resultPtr, this.patternLength);
        return { score: score3, positions: u32.slice() };
      }
      matchHighlights(text, hlGroup) {
        let res = this.match(text);
        if (!res)
          return void 0;
        let highlights = [];
        for (let span of this.matchSpans(text, res.positions)) {
          highlights.push({ span, hlGroup });
        }
        return { score: res.score, highlights };
      }
      free() {
        let ptrs = [this.contentPtr, this.patternPtr, this.resultPtr];
        let { free } = this.exports;
        ptrs.forEach((p) => {
          if (p != null)
            free(p);
        });
        this.contentPtr = this.patternPtr = this.resultPtr = void 0;
      }
    };
  }
});

// src/model/strwidth.ts
async function initStrWidthWasm() {
  const buffer = await (0, import_util.promisify)(fs.readFile)(wasmPath);
  const res = await global.WebAssembly.instantiate(buffer, { env: {} });
  return res.instance.exports;
}
var wasmPath, instance, StrWidth;
var init_strwidth = __esm({
  "src/model/strwidth.ts"() {
    "use strict";
    init_constants();
    init_node();
    wasmPath = path.join(pluginRoot, "bin/strwidth.wasm");
    StrWidth = class {
      constructor(exports2) {
        this.exports = exports2;
        this.cache = /* @__PURE__ */ new Map();
        this.bytes = new Uint8Array(exports2.memory.buffer);
        this.contentPtr = exports2.malloc(4096);
      }
      setAmbw(ambiguousAsDouble) {
        this.exports.setAmbw(ambiguousAsDouble ? 1 : 0);
        this.cache.clear();
      }
      getWidth(content, cache = false) {
        let l = content.length;
        if (l === 0)
          return 0;
        if (l > 4095) {
          content = content.slice(0, 4095);
        }
        if (cache && this.cache.has(content)) {
          return this.cache.get(content);
        }
        let { contentPtr } = this;
        let buf = Buffer.from(content, "utf8");
        let len = buf.length;
        this.bytes.set(buf, contentPtr);
        this.bytes[contentPtr + len] = 0;
        let res = this.exports.strWidth(contentPtr);
        if (cache)
          this.cache.set(content, res);
        return res;
      }
      static async create() {
        if (instance)
          return instance;
        let api = await initStrWidthWasm();
        instance = new StrWidth(api);
        return instance;
      }
    };
  }
});

// src/model/quickpick.ts
var logger5, QuickPick;
var init_quickpick = __esm({
  "src/model/quickpick.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_util();
    init_array();
    init_filter();
    init_protocol();
    init_string();
    init_fuzzyMatch();
    init_input();
    init_popup();
    init_strwidth();
    logger5 = createLogger("quickpick");
    QuickPick = class {
      constructor(nvim, preferences = {}) {
        this.nvim = nvim;
        this.preferences = preferences;
        this.canSelectMany = false;
        this.matchOnDescription = false;
        this.maxHeight = 10;
        this.filteredItems = [];
        this.disposables = [];
        this._changed = false;
        this._onDidFinish = new import_node3.Emitter();
        this._onDidChangeSelection = new import_node3.Emitter();
        this._onDidChangeValue = new import_node3.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeValue = this._onDidChangeValue.event;
        let items = [];
        let input = this.input = new InputBox(this.nvim, "");
        if (preferences.maxHeight)
          this.maxHeight = preferences.maxHeight;
        Object.defineProperty(this, "items", {
          set: (list2) => {
            items = toArray(list2);
            this.selectedItems = items.filter((o) => o.picked);
            this.filterItems("");
          },
          get: () => items
        });
        Object.defineProperty(this, "activeItems", {
          set: (list2) => {
            items = toArray(list2);
            this.filteredItems = items;
            this.showFilteredItems();
          },
          get: () => this.filteredItems
        });
        Object.defineProperty(this, "value", {
          set: (value) => {
            this.input.value = value;
          },
          get: () => this.input.value
        });
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            input.title = toText(newTitle);
          },
          get: () => input.title ?? ""
        });
        Object.defineProperty(this, "loading", {
          set: (loading) => {
            input.loading = loading;
          },
          get: () => input.loading
        });
        input.onDidChange((value) => {
          this._changed = false;
          this._onDidChangeValue.fire(value);
          if (this._changed) {
            this._changed = false;
            return;
          }
          this.filterItems(value);
        }, this);
        input.onDidFinish(this.onFinish, this);
      }
      get maxWidth() {
        return this.preferences.maxWidth ?? 80;
      }
      get currIndex() {
        return this.win ? this.win.currIndex : 0;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      get winid() {
        var _a2;
        return (_a2 = this.win) == null ? void 0 : _a2.winid;
      }
      setCursor(index) {
        var _a2;
        (_a2 = this.win) == null ? void 0 : _a2.setCursor(index, true);
      }
      attachEvents(inputBufnr) {
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.bufnr = void 0;
            this.win = void 0;
          }
        }, null, this.disposables);
        events_default.on("PromptKeyPress", async (bufnr, key) => {
          if (bufnr == inputBufnr) {
            if (key == "<C-f>") {
              await this.win.scrollForward();
            } else if (key == "<C-b>") {
              await this.win.scrollBackward();
            } else if (["<C-j>", "<C-n>", "<down>"].includes(key)) {
              this.setCursor(this.currIndex + 1);
            } else if (["<C-k>", "<C-p>", "<up>"].includes(key)) {
              this.setCursor(this.currIndex - 1);
            } else if (this.canSelectMany && key == "<C-@>") {
              this.toggePicked(this.currIndex);
            }
          }
        }, null, this.disposables);
      }
      async show() {
        let { nvim, items, input, width, preferences, maxHeight } = this;
        let { lines, highlights } = this.buildList(items, input.value);
        let minWidth;
        if (typeof width === "number") {
          minWidth = Math.min(width, this.maxWidth);
        } else {
          let sw = await StrWidth.create();
          minWidth = Math.max(40, Math.min(80, lines.reduce((p, c) => Math.max(p, sw.getWidth(c)), 0)));
        }
        let rounded = !!preferences.rounded;
        await input.show(this.title, {
          position: "center",
          placeHolder: this.placeHolder,
          marginTop: 10,
          border: [1, 1, 0, 1],
          list: true,
          rounded,
          minWidth,
          maxWidth: this.maxWidth,
          highlight: preferences.floatHighlight,
          borderhighlight: preferences.floatBorderHighlight
        });
        let opts = { lines, rounded, maxHeight, highlights };
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
          opts.borderhighlight = preferences.floatBorderHighlight;
        let res = await nvim.call("coc#dialog#create_list", [input.winid, input.dimension, opts]);
        if (!res)
          throw new Error("Unable to open list window.");
        this.win = new Popup(nvim, res[0], res[1], lines.length);
        this.win.refreshScrollbar();
        this.bufnr = res[1];
        this.setCursor(0);
        this.attachEvents(input.bufnr);
      }
      buildList(items, input, loose = false) {
        let { selectedItems, canSelectMany } = this;
        let filteredItems = [];
        let filtered = [];
        let emptyInput = input.length === 0;
        let lowInput = input.toLowerCase();
        const scoreFn = loose ? anyScore : fuzzyScoreGracefulAggressive;
        const wordPos = canSelectMany ? 4 : 0;
        for (let index = 0; index < items.length; index++) {
          const item = items[index];
          let filterText = this.toFilterText(item);
          let spans = [];
          let score3 = 0;
          let descriptionSpan;
          if (!emptyInput) {
            let res = scoreFn(input, lowInput, 0, filterText, filterText.toLowerCase(), wordPos, { boostFullMatch: false, firstMatchCanBeWeak: true });
            if (!res)
              continue;
            score3 = loose ? 0 : res[0];
            spans = toSpans(filterText, res);
          }
          let picked = selectedItems.includes(item);
          let line = canSelectMany ? `[${picked ? "x" : " "}] ${item.label}` : item.label;
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            descriptionSpan = [start, start + 1 + byteLength(item.description)];
          }
          let lineItem = { line, descriptionSpan, index, score: score3, spans };
          filtered.push(lineItem);
        }
        let lines = [];
        let highlights = [];
        filtered.sort((a, b) => {
          if (a.score != b.score)
            return b.score - a.score;
          return a.index - b.index;
        });
        const toHighlight = (lnum, span, hlGroup, pre) => {
          return { lnum, colStart: span[0] + pre, colEnd: span[1] + pre, hlGroup };
        };
        filtered.forEach((item, index) => {
          lines.push(item.line);
          item.spans.forEach((span) => {
            highlights.push(toHighlight(index, span, "CocSearch", wordPos));
          });
          if (item.descriptionSpan) {
            highlights.push(toHighlight(index, item.descriptionSpan, "Comment", 0));
          }
          filteredItems.push(items[item.index]);
        });
        this.filteredItems = filteredItems;
        return { lines, highlights };
      }
      _filter(items, input, loose = false) {
        if (!this.win)
          return;
        this._changed = true;
        let { lines, highlights } = this.buildList(items, input, loose);
        this.nvim.call("coc#dialog#update_list", [this.win.winid, this.win.bufnr, lines, highlights], true);
        this.win.linecount = lines.length;
        this.setCursor(0);
      }
      filterItems(input) {
        this._filter(this.items, input);
      }
      showFilteredItems() {
        let { input, filteredItems } = this;
        this._filter(filteredItems, input.value, true);
      }
      onFinish(input) {
        let items = input == null ? null : this.getSelectedItems();
        if (!this.canSelectMany && input !== void 0 && !isFalsyOrEmpty(items)) {
          this._onDidChangeSelection.fire(items);
        }
        this.nvim.call("coc#float#close", [this.winid], true);
        setTimeout(() => {
          this._onDidFinish.fire(items);
          this.dispose();
        }, 30);
      }
      getSelectedItems() {
        let { canSelectMany } = this;
        if (canSelectMany)
          return this.selectedItems;
        return toArray(this.filteredItems[this.currIndex]);
      }
      toggePicked(index) {
        let { nvim, filteredItems, selectedItems } = this;
        let item = filteredItems[index];
        if (!item)
          return;
        let idx = selectedItems.indexOf(item);
        if (idx != -1) {
          selectedItems.splice(idx, 1);
        } else {
          selectedItems.push(item);
        }
        let text = idx == -1 ? "x" : " ";
        nvim.pauseNotification();
        this.win.execute(`normal! ^1lr${text}`);
        this.win.setCursor(this.win.currIndex + 1);
        nvim.resumeNotification(true, true);
        this._onDidChangeSelection.fire(selectedItems);
      }
      toFilterText(item) {
        let { label, description } = item;
        let { canSelectMany } = this;
        let line = `${canSelectMany ? "    " : ""}${label.replace(/\r?\n/, "")}`;
        return this.matchOnDescription ? line + " " + (description ?? "") : line;
      }
      dispose() {
        var _a2;
        this.bufnr = void 0;
        this.input.dispose();
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this._onDidFinish.dispose();
        this._onDidChangeSelection.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/mutex.ts
var Mutex;
var init_mutex = __esm({
  "src/util/mutex.ts"() {
    "use strict";
    Mutex = class {
      constructor() {
        this.tasks = [];
        this.count = 1;
      }
      sched() {
        if (this.count > 0 && this.tasks.length > 0) {
          this.count--;
          let next = this.tasks.shift();
          next();
        }
      }
      reset() {
        this.tasks = [];
        this.count = 1;
      }
      get busy() {
        return this.count == 0;
      }
      acquire() {
        return new Promise((res) => {
          let task = () => {
            let released = false;
            res(() => {
              if (!released) {
                released = true;
                this.count++;
                this.sched();
              }
            });
          };
          this.tasks.push(task);
          process.nextTick(this.sched.bind(this));
        });
      }
      use(f) {
        return this.acquire().then((release) => f().then((res) => {
          release();
          return res;
        }).catch((err) => {
          release();
          throw err;
        }));
      }
    };
  }
});

// src/util/processes.ts
function isRunning(pid) {
  try {
    let res = process.kill(pid, 0);
    return res == true;
  } catch (e) {
    return e["code"] === "EPERM";
  }
}
function executable(command) {
  try {
    which.sync(command);
  } catch (e) {
    return false;
  }
  return true;
}
function runCommand(cmd, opts = {}, timeout2, isWindows2 = platform === 3 /* Windows */) {
  if (!isWindows2) {
    opts.shell = opts.shell || process.env.SHELL;
  }
  opts.maxBuffer = 500 * 1024;
  return new Promise((resolve, reject) => {
    let timer;
    let cp;
    if (timeout2) {
      timer = setTimeout(() => {
        cp.kill("SIGKILL");
        reject(new CancellationError());
      }, timeout2 * 1e3);
    }
    cp = child_process.exec(cmd, opts, (err, stdout, stderr) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}
${err}
${stderr}`));
        return;
      }
      resolve(stdout);
    });
  });
}
function terminate(process2, cwd2, pt = platform) {
  if (process2.killed)
    return;
  if (pt === 3 /* Windows */) {
    try {
      let options2 = {
        stdio: ["pipe", "pipe", "ignore"]
      };
      if (cwd2)
        options2.cwd = cwd2;
      child_process.execFileSync(
        "taskkill",
        ["/T", "/F", "/PID", process2.pid.toString()],
        options2
      );
      return true;
    } catch (err) {
      return false;
    }
  } else if (pt === 2 /* Linux */ || pt === 1 /* Mac */) {
    try {
      let filepath = path.join(pluginRoot, "bin/terminateProcess.sh");
      let result = child_process.spawnSync(filepath, [process2.pid.toString()]);
      return result.error ? false : true;
    } catch (err) {
      return false;
    }
  } else {
    process2.kill("SIGKILL");
    return true;
  }
}
var init_processes = __esm({
  "src/util/processes.ts"() {
    "use strict";
    init_constants();
    init_errors();
    init_node();
    init_platform();
  }
});

// src/model/resolver.ts
var import_strip_ansi, Resolver;
var init_resolver = __esm({
  "src/model/resolver.ts"() {
    "use strict";
    init_node();
    init_fs();
    init_processes();
    import_strip_ansi = __toESM(require_strip_ansi());
    Resolver = class {
      get nodeFolder() {
        if (!executable("npm"))
          return Promise.resolve("");
        if (this._npmFolder)
          return Promise.resolve(this._npmFolder);
        return runCommand("npm --loglevel silent root -g", {}, 3e3).then((root) => {
          this._npmFolder = (0, import_strip_ansi.default)(root).trim();
          return this._npmFolder;
        });
      }
      get yarnFolder() {
        if (!executable("yarnpkg"))
          return Promise.resolve("");
        if (this._yarnFolder)
          return Promise.resolve(this._yarnFolder);
        return runCommand("yarnpkg global dir", {}, 3e3).then((root) => {
          let folder = path.join((0, import_strip_ansi.default)(root).trim(), "node_modules");
          let exists = fs.existsSync(folder);
          if (exists)
            this._yarnFolder = folder;
          return exists ? folder : "";
        });
      }
      async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
          let s = await statAsync(path.join(yarnFolder, mod, "package.json"));
          if (s && s.isFile())
            return path.join(yarnFolder, mod);
        }
        if (nodeFolder) {
          let s = await statAsync(path.join(nodeFolder, mod, "package.json"));
          if (s && s.isFile())
            return path.join(nodeFolder, mod);
        }
        return null;
      }
    };
  }
});

// src/core/funcs.ts
function has(env, feature) {
  if (!feature.startsWith("nvim-") && !feature.startsWith("patch-")) {
    throw new Error("Feature param could only starts with nvim and patch");
  }
  if (!env.isVim && feature.startsWith("patch-")) {
    return false;
  }
  if (env.isVim && feature.startsWith("nvim-")) {
    return false;
  }
  if (env.isVim) {
    let [_, major, minor, patch] = env.version.match(/^(\d)(\d{2})(\d+)$/);
    let version2 = `${major}.${parseInt(minor, 10)}.${parseInt(patch, 10)}`;
    return semver.gte(version2, feature.slice(6));
  }
  return semver.gte(env.version, feature.slice(5));
}
async function callAsync(nvim, method, args) {
  if (!isVim)
    return await nvim.call(method, args);
  return await nvim.callAsync("coc#util#with_callback", [method, args]);
}
function createNameSpace(name2) {
  if (namespaceMap.has(name2))
    return namespaceMap.get(name2);
  NAME_SPACE = NAME_SPACE + 1;
  namespaceMap.set(name2, NAME_SPACE);
  return NAME_SPACE;
}
function getWatchmanPath(configurations) {
  const watchmanPath = configurations.initialConfiguration.get("coc.preferences.watchmanPath", "watchman");
  return which.sync(watchmanPath, { nothrow: true });
}
async function findUp2(nvim, cwd2, filename) {
  let filepath = await nvim.call("expand", "%:p");
  filepath = path.normalize(filepath);
  let isFile2 = filepath && path.isAbsolute(filepath);
  if (isFile2 && !isParentFolder(cwd2, filepath, true)) {
    return findUp(filename, path.dirname(filepath));
  }
  let res = findUp(filename, cwd2);
  if (res && res != os.homedir())
    return res;
  if (isFile2)
    return findUp(filename, path.dirname(filepath));
  return null;
}
function resolveModule(name2) {
  return resolver.resolveModule(name2);
}
function score(selector, uri, languageId, caseInsensitive = isWindows || isMacintosh) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter2 of selector) {
      const value = score(filter2, uri, languageId);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector && import_node3.TextDocumentFilter.is(selector)) {
    let u = URI.parse(uri);
    const { language, pattern, scheme } = selector;
    let ret = 0;
    if (scheme) {
      if (scheme === u.scheme) {
        ret = 5;
      } else if (scheme === "*") {
        ret = 3;
      } else {
        return 0;
      }
    }
    if (language) {
      if (language === languageId) {
        ret = 10;
      } else if (language === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let p = caseInsensitive ? pattern.toLowerCase() : pattern;
      let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
      if (p === f || minimatch(f, p, { dot: true })) {
        ret = 5;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
var NAME_SPACE, resolver, namespaceMap;
var init_funcs = __esm({
  "src/core/funcs.ts"() {
    "use strict";
    init_esm();
    init_resolver();
    init_constants();
    init_fs();
    init_node();
    init_platform();
    init_protocol();
    NAME_SPACE = 2e3;
    resolver = new Resolver();
    namespaceMap = /* @__PURE__ */ new Map();
  }
});

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
function unescape2(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
function edit(regex2, opt) {
  regex2 = typeof regex2 === "string" ? regex2 : regex2.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex2 = regex2.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex2, opt);
    }
  };
  return obj;
}
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level2 = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level2++;
    } else if (str[i] === b[1]) {
      level2--;
      if (level2 < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length)
      return done();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  function onError(e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      if (opt.async) {
        return Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => {
          return Parser.parse(tokens, opt);
        }).catch(onError);
      }
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    onError(e);
  }
}
var defaults, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, nonWordAndColonTest, originIndependentUrl, baseUrls, justDomain, protocol, domain, noopTest, Tokenizer, block, inline, Lexer, Renderer, TextRenderer, Slugger, Parser, options, setOptions, use, walkTokens, parseInline, parser, lexer;
var init_marked_esm = __esm({
  "node_modules/marked/lib/marked.esm.js"() {
    defaults = getDefaults();
    escapeTest = /[&<>"']/;
    escapeReplace = new RegExp(escapeTest.source, "g");
    escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    getEscapeReplacement = (ch) => escapeReplacements[ch];
    unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    caret = /(^|[^\[])\^/g;
    nonWordAndColonTest = /[^\w:]/g;
    originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    baseUrls = {};
    justDomain = /^[^:]+:\/*[^/]*$/;
    protocol = /^([^:]+:)[\s\S]*$/;
    domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    noopTest = { exec: function noopTest2() {
    } };
    Tokenizer = class {
      constructor(options2) {
        this.options = options2 || defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *>[ \t]?/gm, "");
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0];
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
              while (src) {
                rawLine = src.split("\n", 1)[0];
                line = rawLine;
                if (this.options.pedantic) {
                  line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (nextBulletRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (line.search(/[^ ]/) >= indent || !line.trim()) {
                  itemContents += "\n" + line.slice(indent);
                } else if (!blankLine) {
                  itemContents += "\n" + line;
                } else {
                  break;
                }
                if (!blankLine && !line.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          const l = list2.items.length;
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            if (!list2.loose) {
              const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
              list2.loose = hasMultipleLineBreaks;
            }
          }
          if (list2.loose) {
            for (i = 0; i < l; i++) {
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            token.type = "paragraph";
            token.text = text;
            token.tokens = this.lexer.inline(text);
          }
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
          return {
            type: "def",
            tag,
            raw: cap[0],
            href,
            title
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1]).map((c) => {
              return { text: c };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
                return { text: c };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links2) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links2[link.toLowerCase()];
          if (!link) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
            if (Math.min(lLength, rLength) % 2) {
              const text2 = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: text2,
                tokens: this.lexer.inlineTokens(text2)
              };
            }
            const text = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }
      autolink(src, mangle2) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src, mangle2) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src, smartypants2) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
    block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit(
        `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
      ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    Lexer = class {
      constructor(options2) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options2 || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      static get rules() {
        return {
          block,
          inline
        };
      }
      static lex(src, options2) {
        const lexer2 = new Lexer(options2);
        return lexer2.lex(src);
      }
      static lexInline(src, options2) {
        const lexer2 = new Lexer(options2);
        return lexer2.inlineTokens(src);
      }
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
            return leading + "    ".repeat(tabs.length);
          });
        }
        let token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
      }
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links2 = Object.keys(this.tokens.links);
          if (links2.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
    Renderer = class {
      constructor(options2) {
        this.options = options2 || defaults;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return `<blockquote>
${quote}</blockquote>
`;
      }
      html(html) {
        return html;
      }
      heading(text, level2, raw, slugger) {
        if (this.options.headerIds) {
          const id = this.options.headerPrefix + slugger.slug(raw);
          return `<h${level2} id="${id}">${text}</h${level2}>
`;
        }
        return `<h${level2}>${text}</h${level2}>
`;
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text) {
        return `<li>${text}</li>
`;
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text) {
        return `<p>${text}</p>
`;
      }
      table(header, body) {
        if (body)
          body = `<tbody>${body}</tbody>`;
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return `<tr>
${content}</tr>
`;
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
        return tag + content + `</${type}>
`;
      }
      strong(text) {
        return `<strong>${text}</strong>`;
      }
      em(text) {
        return `<em>${text}</em>`;
      }
      codespan(text) {
        return `<code>${text}</code>`;
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text) {
        return `<del>${text}</del>`;
      }
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
    TextRenderer = class {
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
    Slugger = class {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      slug(value, options2 = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options2.dryrun);
      }
    };
    Parser = class {
      constructor(options2) {
        this.options = options2 || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      static parse(tokens, options2) {
        const parser2 = new Parser(options2);
        return parser2.parse(tokens);
      }
      static parseInline(tokens, options2) {
        const parser2 = new Parser(options2);
        return parser2.parseInline(tokens);
      }
      parse(tokens, top = true) {
        let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape2(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger
              );
              continue;
            }
            case "code": {
              out += this.renderer.code(
                token.text,
                token.lang,
                token.escaped
              );
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[j].tokens),
                  { header: true, align: token.align[j] }
                );
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k].tokens),
                    { header: false, align: token.align[k] }
                  );
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i, token, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
    marked.options = marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = getDefaults;
    marked.defaults = defaults;
    marked.use = function(...args) {
      const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = merge({}, pack);
        opts.async = marked.defaults.async || opts.async;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer = marked.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret = pack.renderer[prop].apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.walkTokens) {
          const walkTokens2 = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(pack.walkTokens.call(this, token));
            if (walkTokens2) {
              values = values.concat(walkTokens2.call(this, token));
            }
            return values;
          };
        }
        marked.setOptions(opts);
      });
    };
    marked.walkTokens = function(tokens, callback) {
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(marked, token));
        switch (token.type) {
          case "table": {
            for (const cell of token.header) {
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }
            for (const row of token.rows) {
              for (const cell of row) {
                values = values.concat(marked.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            values = values.concat(marked.walkTokens(token.items, callback));
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked.walkTokens(token.tokens, callback));
            }
          }
        }
      }
      return values;
    };
    marked.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.parse = marked;
    options = marked.options;
    setOptions = marked.setOptions;
    use = marked.use;
    walkTokens = marked.walkTokens;
    parseInline = marked.parseInline;
    parser = Parser.parse;
    lexer = Lexer.lex;
  }
});

// src/util/ansiparse.ts
function parseAnsiHighlights(line, markdown = false) {
  let items = ansiparse(line);
  let highlights = [];
  let newLabel = "";
  for (let item of items) {
    if (!item.text)
      continue;
    let { foreground, background } = item;
    let len = byteLength(newLabel);
    let span = [len, len + byteLength(item.text)];
    if (foreground && background) {
      let hlGroup = `CocList${upperFirst(foreground)}${upperFirst(background)}`;
      highlights.push({ span, hlGroup });
    } else if (foreground) {
      let hlGroup;
      if (markdown) {
        if (foreground == "yellow") {
          hlGroup = "CocMarkdownCode";
        } else if (foreground == "blue") {
          hlGroup = "CocMarkdownLink";
        } else if (foreground == "magenta") {
          hlGroup = "CocMarkdownHeader";
        } else {
          hlGroup = `CocListFg${upperFirst(foreground)}`;
        }
      } else {
        hlGroup = `CocListFg${upperFirst(foreground)}`;
      }
      highlights.push({ span, hlGroup });
    } else if (background) {
      let hlGroup = `CocListBg${upperFirst(background)}`;
      highlights.push({ span, hlGroup });
    }
    if (item.bold) {
      highlights.push({ span, hlGroup: "CocBold" });
    } else if (item.italic) {
      highlights.push({ span, hlGroup: "CocItalic" });
    } else if (item.underline) {
      highlights.push({ span, hlGroup: "CocUnderline" });
    } else if (item.strikethrough) {
      highlights.push({ span, hlGroup: "CocStrikeThrough" });
    }
    newLabel = newLabel + item.text;
  }
  return { line: newLabel, highlights };
}
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "\x1B" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        if (matchingText == "" && (str[i + 1] == "m" || str[i + 1] == "K")) {
          if (state.foreground || state.background) {
            state.text = "";
            result.push(state);
          }
          state = {};
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles2[ansiCode]) {
            state[styles2[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          } else if (ansiCode == 29) {
            state.strikethrough = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "\x1B") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + toText(matchingControl);
    result.push(state);
  }
  return result;
}
var foregroundColors, backgroundColors, styles2;
var init_ansiparse = __esm({
  "src/util/ansiparse.ts"() {
    "use strict";
    init_string();
    foregroundColors = {
      30: "black",
      31: "red",
      32: "green",
      33: "yellow",
      34: "blue",
      35: "magenta",
      36: "cyan",
      37: "white",
      90: "grey"
    };
    backgroundColors = {
      40: "black",
      41: "red",
      42: "green",
      43: "yellow",
      44: "blue",
      45: "magenta",
      46: "cyan",
      47: "white"
    };
    styles2 = {
      1: "bold",
      3: "italic",
      4: "underline",
      9: "strikethrough"
    };
  }
});

// src/markdown/styles.ts
function gray(str) {
  return `${styles.gray.open}${str}${styles.gray.close}`;
}
function magenta(str) {
  return `${styles.magenta.open}${str}${styles.magenta.close}`;
}
function bold(str) {
  return `${styles.bold.open}${str}${styles.bold.close}`;
}
function underline(str) {
  return `${styles.underline.open}${str}${styles.underline.close}`;
}
function strikethrough(str) {
  return `${styles.strikethrough.open}${str}${styles.strikethrough.close}`;
}
function italic(str) {
  return `${styles.italic.open}${str}${styles.italic.close}`;
}
function yellow(str) {
  return `${styles.yellow.open}${str}${styles.yellow.close}`;
}
function blue(str) {
  return `${styles.blue.open}${str}${styles.blue.close}`;
}
var init_styles = __esm({
  "src/markdown/styles.ts"() {
    "use strict";
    init_node();
  }
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/colors/lib/styles.js"(exports2, module2) {
    var styles3 = {};
    module2["exports"] = styles3;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles3[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/colors/lib/system/supports-colors.js"(exports2, module2) {
    var argv = process.argv;
    module2.exports = function() {
      if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
        return false;
      }
      if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options2) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options2) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function is_char(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options3) {
        var result = "", counts, l;
        options3 = options3 || {};
        options3["up"] = options3["up"] || true;
        options3["mid"] = options3["mid"] || true;
        options3["down"] = options3["down"] || true;
        options3["size"] = options3["size"] || "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (is_char(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options3.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.min = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.min = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options3[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text);
    };
  }
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/colors/lib/maps/america.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/colors/lib/maps/zebra.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/colors/lib/maps/rainbow.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/colors/lib/maps/random.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    }();
  }
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    colors.supportsColor = require_supports_colors();
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      return ansiStyles[style].open + str + ansiStyles[style].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles3 = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles3);
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!colors.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      return str;
    }
    function applyTheme(theme) {
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            return colors[theme[style2]](str);
          };
        })(style);
      }
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles3).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/cli-table/lib/utils.js
var require_utils = __commonJS({
  "node_modules/cli-table/lib/utils.js"(exports2) {
    exports2.repeat = function(str, times) {
      return Array(times + 1).join(str);
    };
    exports2.pad = function(str, len, pad2, dir) {
      if (len + 1 >= str.length)
        switch (dir) {
          case "left":
            str = Array(len + 1 - str.length).join(pad2) + str;
            break;
          case "both":
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad2) + str + Array(right + 1).join(pad2);
            break;
          default:
            str = str + Array(len + 1 - str.length).join(pad2);
        }
      ;
      return str;
    };
    exports2.truncate = function(str, length, chr) {
      chr = chr || "\u2026";
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    function options2(defaults3, opts) {
      for (var p in opts) {
        if (p === "__proto__" || p === "constructor" || p === "prototype") {
          continue;
        }
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults3[p] = defaults3[p] || {};
          options2(defaults3[p], opts[p]);
        } else {
          defaults3[p] = opts[p];
        }
      }
      return defaults3;
    }
    exports2.options = options2;
    exports2.strlen = function(str) {
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code, "");
      var split = stripped.split("\n");
      return split.reduce(function(memo, s) {
        return s.length > memo ? s.length : memo;
      }, 0);
    };
  }
});

// node_modules/cli-table/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/cli-table/lib/index.js"(exports2, module2) {
    var colors = require_safe();
    var utils = require_utils();
    var repeat2 = utils.repeat;
    var truncate = utils.truncate;
    var pad2 = utils.pad;
    function Table(options2) {
      this.options = utils.options({
        chars: {
          "top": "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          "bottom": "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          "left": "\u2502",
          "left-mid": "\u251C",
          "mid": "\u2500",
          "mid-mid": "\u253C",
          "right": "\u2502",
          "right-mid": "\u2524",
          "middle": "\u2502"
        },
        truncate: "\u2026",
        colWidths: [],
        colAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["grey"],
          compact: false
        },
        head: []
      }, options2);
      if (options2 && options2.rows) {
        for (var i = 0; i < options2.rows.length; i++) {
          this.push(options2.rows[i]);
        }
      }
    }
    Table.prototype.__proto__ = Array.prototype;
    Table.prototype.__defineGetter__("width", function() {
      var str = this.toString().split("\n");
      if (str.length)
        return str[0].length;
      return 0;
    });
    Table.prototype.render;
    Table.prototype.toString = function() {
      var ret = "", options2 = this.options, style = options2.style, head = options2.head, chars = options2.chars, truncater = options2.truncate, colWidths = options2.colWidths || new Array(this.head.length), totalWidth = 0;
      if (!head.length && !this.length)
        return "";
      if (!colWidths.length) {
        var all_rows = this.slice(0);
        if (head.length) {
          all_rows = all_rows.concat([head]);
        }
        ;
        all_rows.forEach(function(cells) {
          if (typeof cells === "object" && cells.length) {
            extractColumnWidths(cells);
          } else {
            var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
            colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
            if (typeof value_cell === "object" && value_cell.length) {
              extractColumnWidths(value_cell, 1);
            } else {
              colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
            }
          }
        });
      }
      ;
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
        function(a, b) {
          return a + b;
        }
      )) + colWidths.length + 1;
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i) {
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      }
      ;
      function get_width(obj) {
        return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
      }
      function line(line2, left, right, intersection) {
        var width = 0, line2 = left + repeat2(line2, totalWidth - 2) + right;
        colWidths.forEach(function(w, i) {
          if (i == colWidths.length - 1)
            return;
          width += w + 1;
          line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
        });
        return applyStyles(options2.style.border, line2);
      }
      ;
      function lineTop() {
        var l2 = line(
          chars.top,
          chars["top-left"] || chars.top,
          chars["top-right"] || chars.top,
          chars["top-mid"]
        );
        if (l2)
          ret += l2 + "\n";
      }
      ;
      function generateRow(items, style2) {
        var cells = [], max_height = 0;
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
        items.forEach(function(item, i) {
          var contents = item.toString().split("\n").reduce(function(memo, l2) {
            memo.push(string2(l2, i));
            return memo;
          }, []);
          var height = contents.length;
          if (height > max_height) {
            max_height = height;
          }
          ;
          cells.push({ contents, height });
        });
        var lines = new Array(max_height);
        cells.forEach(function(cell, i) {
          cell.contents.forEach(function(line2, j2) {
            if (!lines[j2]) {
              lines[j2] = [];
            }
            ;
            if (style2 || first_cell_head && i === 0 && options2.style.head) {
              line2 = applyStyles(options2.style.head, line2);
            }
            lines[j2].push(line2);
          });
          for (var j = cell.height, l2 = max_height; j < l2; j++) {
            if (!lines[j]) {
              lines[j] = [];
            }
            ;
            lines[j].push(string2("", i));
          }
        });
        var ret2 = "";
        lines.forEach(function(line2, index) {
          if (ret2.length > 0) {
            ret2 += "\n" + applyStyles(options2.style.border, chars.left);
          }
          ret2 += line2.join(applyStyles(options2.style.border, chars.middle)) + applyStyles(options2.style.border, chars.right);
        });
        return applyStyles(options2.style.border, chars.left) + ret2;
      }
      ;
      function applyStyles(styles3, subject) {
        if (!subject)
          return "";
        styles3.forEach(function(style2) {
          subject = colors[style2](subject);
        });
        return subject;
      }
      ;
      function string2(str, index) {
        var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0), align = options2.colAligns[index] || "left";
        return repeat2(" ", style["padding-left"] || 0) + (length == width ? str : length < width ? pad2(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat2(" ", style["padding-right"] || 0);
      }
      ;
      if (head.length) {
        lineTop();
        ret += generateRow(head, style.head) + "\n";
      }
      if (this.length)
        this.forEach(function(cells, i) {
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style.compact || i < !!head.length ? 1 : cells.length == 0) {
              var l2 = line(
                chars.mid,
                chars["left-mid"],
                chars["right-mid"],
                chars["mid-mid"]
              );
              if (l2)
                ret += l2 + "\n";
            }
          }
          if (cells.hasOwnProperty("length") && !cells.length) {
            return;
          } else {
            ret += generateRow(cells) + "\n";
          }
          ;
        });
      var l = line(
        chars.bottom,
        chars["bottom-left"] || chars.bottom,
        chars["bottom-right"] || chars.bottom,
        chars["bottom-mid"]
      );
      if (l)
        ret += l;
      else
        ret = ret.slice(0, -1);
      return ret;
    };
    module2.exports = Table;
    module2.exports.version = "0.0.1";
  }
});

// src/markdown/renderer.ts
function identity(str) {
  return str;
}
function cleanUpHtml(input) {
  return gray(input.replace(/(<([^>]+)>)/ig, ""));
}
function fixHardReturn(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, "\n") : text;
}
function indentLines(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
}
function identify(indent, text) {
  if (!text)
    return text;
  return indent + text.split("\n").join("\n" + indent);
}
function fixNestedLists(body, indent) {
  let regex2 = new RegExp(
    "(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$",
    "gm"
  );
  return body.replace(regex2, "$1\n" + indent + "$2$3");
}
function toSpaces(str) {
  return " ".repeat(str.length);
}
function bulletPointLine(indent, line) {
  return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
}
function bulletPointLines(lines, indent) {
  let transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
}
function numberedLine(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
}
function numberedLines(lines, indent) {
  let transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
}
function list(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
}
function section(text) {
  return text + "\n\n";
}
function undoColon(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
}
function generateTableRow(text, escape2 = null) {
  if (!text)
    return [];
  escape2 = escape2 || identity;
  let lines = escape2(text).split("\n");
  let data = [];
  lines.forEach(function(line) {
    if (!line)
      return;
    let parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function unescapeEntities(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
var TABLE_CELL_SPLIT, TABLE_ROW_WRAP, TABLE_ROW_WRAP_REGEXP, COLON_REPLACER, COLON_REPLACER_REGEXP, HARD_RETURN, defaultOptions, BULLET_POINT_REGEX, NUMBERED_POINT_REGEX, POINT_REGEX, isPointedLine, BULLET_POINT, numberedPoint, links, Renderer2, renderer_default;
var init_renderer = __esm({
  "src/markdown/renderer.ts"() {
    "use strict";
    init_object();
    init_styles();
    TABLE_CELL_SPLIT = "^*||*^";
    TABLE_ROW_WRAP = "*|*|*|*";
    TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
    COLON_REPLACER = "*#COLON|*";
    COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
    HARD_RETURN = /\r/g;
    defaultOptions = {
      code: identity,
      blockquote: identity,
      html: cleanUpHtml,
      heading: magenta,
      firstHeading: magenta,
      hr: identity,
      listitem: identity,
      list,
      table: identity,
      paragraph: identity,
      strong: bold,
      em: italic,
      codespan: yellow,
      del: strikethrough,
      link: underline,
      href: underline,
      text: identity,
      unescape: true,
      emoji: false,
      width: 80,
      showSectionPrefix: false,
      tab: 2,
      tableOptions: {}
    };
    BULLET_POINT_REGEX = "\\*";
    NUMBERED_POINT_REGEX = "\\d+\\.";
    POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
    isPointedLine = function(line, indent) {
      return line.match("^(?:" + indent + ")*" + POINT_REGEX) != null;
    };
    BULLET_POINT = "* ";
    numberedPoint = function(n) {
      return n + ". ";
    };
    links = /* @__PURE__ */ new Map();
    Renderer2 = class {
      constructor(options2 = {}, highlightOptions = {}) {
        this.options = options2;
        this.highlightOptions = highlightOptions;
        this.o = Object.assign({}, defaultOptions, options2);
        this.tab = "  ";
        this.tableSettings = this.o.tableOptions;
        this.unescape = unescapeEntities;
        this.highlightOptions = toObject(highlightOptions);
        this.transform = this.compose(undoColon, this.unescape);
      }
      text(t) {
        return this.o.text(t);
      }
      code(code, lang, _escaped) {
        return "``` " + lang + "\n" + code + "\n```\n";
      }
      blockquote(quote) {
        return section(this.o.blockquote(identify(this.tab, quote.trim())));
      }
      html(html) {
        return this.o.html(html);
      }
      heading(text, level2, _raw) {
        text = this.transform(text);
        return section(
          level2 === 1 ? this.o.firstHeading(text) : this.o.heading(text)
        );
      }
      hr() {
        return `\u2500\u2500\u2500
`;
      }
      list(body, ordered) {
        body = this.o.list(body, ordered, this.tab);
        return section(fixNestedLists(indentLines(this.tab, body), this.tab));
      }
      listitem(text) {
        let transform = this.compose(this.o.listitem, this.transform);
        let isNested = text.indexOf("\n") !== -1;
        if (isNested)
          text = text.trim();
        return "\n" + BULLET_POINT + transform(text);
      }
      checkbox(checked) {
        return "[" + (checked ? "X" : " ") + "] ";
      }
      paragraph(text) {
        let transform = this.compose(this.o.paragraph, this.transform);
        text = transform(text);
        return section(text);
      }
      table(header, body) {
        const Table = require_lib2();
        let table = new Table(
          Object.assign(
            {},
            {
              head: generateTableRow(header)[0]
            },
            this.tableSettings
          )
        );
        generateTableRow(body, this.transform).forEach(function(row) {
          table.push(row);
        });
        return section(this.o.table(table.toString()));
      }
      tablerow(content) {
        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
      }
      tablecell(content, _flags) {
        return content + TABLE_CELL_SPLIT;
      }
      strong(text) {
        return this.o.strong(text);
      }
      em(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.em(text);
      }
      codespan(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
      }
      br() {
        return "\n";
      }
      del(text) {
        return this.o.del(text);
      }
      link(href, title, text) {
        let prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
        } catch (e) {
          return "";
        }
        if (prot.startsWith("javascript:")) {
          return "";
        }
        if (text && href && text != href) {
          links.set(text, href);
        }
        if (text && text != href)
          return blue(text);
        let out = this.o.href(href);
        return this.o.link(out);
      }
      image(href, title, text) {
        let out = "![" + text;
        return out + "](" + href + ")";
      }
      compose(...funcs) {
        return (...args) => {
          for (let i = funcs.length; i-- > 0; ) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      }
      static getLinks() {
        let res = [];
        for (let [text, href] of links.entries()) {
          res.push(`${blue(text)}: ${href}`);
        }
        links.clear();
        return res;
      }
    };
    renderer_default = Renderer2;
  }
});

// src/markdown/index.ts
function toFiletype(match) {
  if (!match)
    return TXT;
  let mapped = filetyepsMap[match];
  return string(mapped) ? mapped : match;
}
function parseDocuments(docs, opts = {}) {
  let lines = [];
  let highlights = [];
  let codes = [];
  let idx = 0;
  for (let doc of docs) {
    let currline = lines.length;
    let { content, filetype } = doc;
    let hls = doc.highlights;
    if (filetype == MARKDOWN) {
      let info = parseMarkdown(content, opts);
      codes.push(...info.codes.map((o) => {
        o.startLine = o.startLine + currline;
        o.endLine = o.endLine + currline;
        return o;
      }));
      highlights.push(...info.highlights.map((o) => {
        o.lnum = o.lnum + currline;
        return o;
      }));
      lines.push(...info.lines);
    } else {
      let parts = content.trim().split(/\r?\n/);
      let hlGroup = FiletypeHighlights[doc.filetype];
      if (string(hlGroup)) {
        codes.push({ hlGroup, startLine: currline, endLine: currline + parts.length });
      } else {
        codes.push({ filetype: doc.filetype, startLine: currline, endLine: currline + parts.length });
      }
      lines.push(...parts);
    }
    if (Array.isArray(hls)) {
      highlights.push(...hls.map((o) => {
        return Object.assign({}, o, { lnum: o.lnum + currline });
      }));
    }
    if (Array.isArray(doc.active)) {
      let arr = getHighlightItems(content, currline, doc.active);
      if (arr.length)
        highlights.push(...arr);
    }
    if (idx != docs.length - 1) {
      highlights.push({
        lnum: lines.length,
        hlGroup: DIVIDING_LINE_HI_GROUP,
        colStart: 0,
        colEnd: -1
      });
      lines.push(DIVIDE_CHARACTER);
    }
    idx = idx + 1;
  }
  return { lines, highlights, codes };
}
function getHighlightItems(content, currline, active) {
  let res = [];
  let [start, end] = active;
  let lines = content.split(/\r?\n/);
  let used = 0;
  let inRange = false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!inRange) {
      if (used + line.length > start) {
        inRange = true;
        let colStart = byteIndex(line, start - used);
        if (used + line.length > end) {
          let colEnd = byteIndex(line, end - used);
          inRange = false;
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
          break;
        } else {
          let colEnd = byteLength(line);
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
        }
      }
    } else {
      if (used + line.length > end) {
        let colEnd = byteIndex(line, end - used);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
        inRange = false;
        break;
      } else {
        let colEnd = byteLength(line);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
      }
    }
    used = used + line.length + 1;
  }
  return res;
}
function parseMarkdown(content, opts) {
  marked.setOptions({
    renderer: new renderer_default(),
    gfm: true,
    breaks: boolean(opts.breaks) ? opts.breaks : true
  });
  let lines = [];
  let highlights = [];
  let codes = [];
  let currline = 0;
  let inCodeBlock = false;
  let filetype;
  let startLnum = 0;
  let parsed = marked(content);
  let links2 = renderer_default.getLinks();
  parsed = parsed.replace(/\s*$/, "");
  if (links2.length) {
    parsed = parsed + "\n\n" + links2.join("\n");
  }
  let parsedLines = parsed.split(/\n/);
  for (let i = 0; i < parsedLines.length; i++) {
    let line = parsedLines[i];
    if (!line.length) {
      let pre = lines[lines.length - 1];
      if (!pre)
        continue;
      let next = parsedLines[i + 1];
      if (!next || next.startsWith(DOTS) || next.startsWith(DIVIDE_CHARACTER))
        continue;
      lines.push(line);
      currline++;
      continue;
    }
    if (opts.excludeImages && line.indexOf("![") !== -1) {
      line = line.replace(/\s*!\[.*?\]\(.*?\)/g, "");
      if (!stripAnsi(line).trim().length)
        continue;
    }
    let ms = line.match(/^\s*```\s*(\S+)?/);
    if (ms) {
      if (!inCodeBlock) {
        let pre = parsedLines[i - 1];
        if (pre && /^\s*```\s*/.test(pre)) {
          lines.push("");
          currline++;
        }
        inCodeBlock = true;
        filetype = toFiletype(ms[1]);
        startLnum = currline;
      } else {
        inCodeBlock = false;
        codes.push({
          filetype,
          startLine: startLnum,
          endLine: currline
        });
      }
      continue;
    }
    if (inCodeBlock) {
      lines.push(line);
      currline++;
      continue;
    }
    let res = parseAnsiHighlights(line, true);
    if (line === DIVIDE_LINE) {
      highlights.push({
        hlGroup: DIVIDING_LINE_HI_GROUP,
        lnum: currline,
        colStart: 0,
        colEnd: -1
      });
    } else if (res.highlights) {
      for (let hi of res.highlights) {
        let { hlGroup, span } = hi;
        highlights.push({
          hlGroup,
          lnum: currline,
          colStart: span[0],
          colEnd: span[1]
        });
      }
    }
    lines.push(res.line);
    currline++;
  }
  return { lines, highlights, codes };
}
var FiletypeHighlights, filetyepsMap, ACTIVE_HL_GROUP, DIVIDING_LINE_HI_GROUP, MARKDOWN, DOTS, TXT, DIVIDE_CHARACTER, DIVIDE_LINE;
var init_markdown = __esm({
  "src/markdown/index.ts"() {
    "use strict";
    init_marked_esm();
    init_ansiparse();
    init_is();
    init_node();
    init_string();
    init_renderer();
    FiletypeHighlights = /* @__PURE__ */ ((FiletypeHighlights2) => {
      FiletypeHighlights2["Error"] = "CocErrorFloat";
      FiletypeHighlights2["Warning"] = "CocWarningFloat";
      FiletypeHighlights2["Info"] = "CocInfoFloat";
      FiletypeHighlights2["Hint"] = "CocHintFloat";
      return FiletypeHighlights2;
    })(FiletypeHighlights || {});
    filetyepsMap = {
      js: "javascript",
      ts: "typescript",
      bash: "sh"
    };
    ACTIVE_HL_GROUP = "CocFloatActive";
    DIVIDING_LINE_HI_GROUP = "CocFloatDividingLine";
    MARKDOWN = "markdown";
    DOTS = "```";
    TXT = "txt";
    DIVIDE_CHARACTER = "\u2500";
    DIVIDE_LINE = "\u2500\u2500\u2500";
  }
});

// src/model/floatFactory.ts
var debounceTime, FloatFactoryImpl;
var init_floatFactory = __esm({
  "src/model/floatFactory.ts"() {
    "use strict";
    init_node();
    init_events();
    init_markdown();
    init_util();
    init_array();
    init_mutex();
    init_object();
    init_protocol();
    init_constants();
    debounceTime = getConditionValue(100, 10);
    FloatFactoryImpl = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.winid = 0;
        this._bufnr = 0;
        this.mutex = new Mutex();
        this.disposables = [];
        this.onCursorMoved = debounce(this._onCursorMoved.bind(this), debounceTime);
      }
      bindEvents(autoHide, alignTop) {
        let eventNames = ["InsertLeave", "InsertEnter", "BufEnter"];
        for (let ev of eventNames) {
          events_default.on(ev, (bufnr) => {
            if (bufnr == this._bufnr)
              return;
            this.close();
          }, null, this.disposables);
        }
        events_default.on("MenuPopupChanged", () => {
          if (events_default.pumAlignTop == alignTop) {
            this.close();
          }
        }, null, this.disposables);
        this.disposables.push(import_node3.Disposable.create(() => {
          this.onCursorMoved.clear();
        }));
        events_default.on("CursorMoved", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
        events_default.on("CursorMovedI", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
      }
      unbind() {
        if (this.disposables.length) {
          disposeAll(this.disposables);
          this.disposables = [];
        }
      }
      _onCursorMoved(autoHide, bufnr, cursor) {
        if (bufnr == this._bufnr)
          return;
        if (bufnr == this.targetBufnr && equals(cursor, this.cursor)) {
          return;
        }
        if (bufnr != this.targetBufnr || !events_default.insertMode || autoHide) {
          this.close();
          return;
        }
      }
      async create(docs, _allowSelection = false, offsetX = 0) {
        await this.show(docs, {
          offsetX
        });
      }
      async show(docs, config = {}) {
        if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
          this.close();
          return;
        }
        let curr = Date.now();
        let release = await this.mutex.acquire();
        try {
          await this.createPopup(docs, config, curr);
          release();
        } catch (e) {
          this.nvim.echoError(e);
          release();
        }
      }
      async createPopup(docs, opts, timestamp) {
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs, { excludeImages: opts.excludeImages, breaks: opts.breaks });
        let config = {
          codes,
          highlights,
          pumAlignTop: events_default.pumAlignTop,
          preferTop: typeof opts.preferTop === "boolean" ? opts.preferTop : false,
          offsetX: opts.offsetX || 0,
          title: opts.title || "",
          close: opts.close ? 1 : 0,
          rounded: opts.rounded ? 1 : 0,
          modes: opts.modes || ["n", "i", "ic", "s"],
          zindex: 1
        };
        if (!isVim) {
          if (typeof opts.winblend === "number")
            config.winblend = opts.winblend;
          if (opts.focusable != null)
            config.focusable = opts.focusable ? 1 : 0;
          if (opts.shadow)
            config.shadow = 1;
        }
        if (opts.maxHeight)
          config.maxHeight = opts.maxHeight;
        if (opts.maxWidth)
          config.maxWidth = opts.maxWidth;
        if (opts.border === true) {
          config.border = [1, 1, 1, 1];
        } else if (Array.isArray(opts.border) && !opts.border.every((o) => o == 0)) {
          config.border = opts.border.slice(0, 4);
          config.rounded = opts.rounded ? 1 : 0;
        }
        if (opts.highlight)
          config.highlight = opts.highlight;
        if (opts.borderhighlight)
          config.borderhighlight = opts.borderhighlight;
        if (opts.cursorline)
          config.cursorline = 1;
        let autoHide = opts.autoHide === false ? false : true;
        if (autoHide)
          config.autohide = 1;
        this.unbind();
        let arr = await this.nvim.call("coc#dialog#create_cursor_float", [this.winid, this._bufnr, lines, config]);
        this.nvim.redrawVim();
        if (isFalsyOrEmpty(arr) || this.closeTs > timestamp) {
          let winid2 = arr && arr.length > 0 ? arr[2] : this.winid;
          if (winid2) {
            this.winid = 0;
            this.nvim.call("coc#float#close", [winid2], true);
            this.nvim.redrawVim();
          }
          return;
        }
        let [targetBufnr, cursor, winid, bufnr, alignTop] = arr;
        this.winid = winid;
        this._bufnr = bufnr;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        this.bindEvents(autoHide, alignTop == 1);
      }
      close() {
        let { winid, nvim } = this;
        this.closeTs = Date.now();
        this.unbind();
        if (winid) {
          this.winid = 0;
          nvim.call("coc#float#close", [winid], true);
          nvim.redrawVim();
        }
      }
      checkRetrigger(bufnr) {
        if (this.winid && this.targetBufnr == bufnr)
          return true;
        return false;
      }
      get bufnr() {
        return this._bufnr;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
      }
      get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
      }
      async activated() {
        if (!this.winid)
          return false;
        return await this.nvim.call("coc#float#valid", [this.winid]) != 0;
      }
      dispose() {
        this.cursor = void 0;
        this.onCursorMoved.clear();
        this.close();
      }
    };
  }
});

// src/core/ui.ts
async function getCursorPosition(nvim) {
  let [line, content] = await nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
  return Position.create(line, content.length);
}
async function getLineAndPosition(nvim) {
  let [text, lnum, content] = await nvim.eval(`[getline('.'), line('.'), strpart(getline('.'), 0, col('.') - 1)]`);
  return { text, line: lnum - 1, character: content.length };
}
function createFloatFactory(nvim, conf, defaults3) {
  let opts = Object.assign({}, defaults3, conf);
  let factory = new FloatFactoryImpl(nvim);
  return {
    get window() {
      return factory.window;
    },
    show: (docs, option) => {
      return factory.show(docs, option ? Object.assign({}, opts, option) : opts);
    },
    activated: () => {
      return factory.activated();
    },
    dispose: () => {
      factory.dispose();
    },
    checkRetrigger: (bufnr) => {
      return factory.checkRetrigger(bufnr);
    },
    close: () => {
      factory.close();
    }
  };
}
async function showPrompt(nvim, title) {
  let res = await nvim.callAsync("coc#dialog#prompt_confirm", [title]);
  return res == 1;
}
async function moveTo(nvim, position, redraw) {
  await nvim.call("coc#cursor#move_to", [position.line, position.character]);
  if (redraw)
    nvim.command("redraw", true);
}
async function getOffset(nvim) {
  return await nvim.call("coc#cursor#char_offset");
}
async function getCursorScreenPosition(nvim) {
  let [row, col] = await nvim.call("coc#cursor#screen_pos");
  return { row, col };
}
async function echoLines(nvim, env, lines, truncate) {
  let cmdHeight = env.cmdheight;
  if (lines.length > cmdHeight && truncate) {
    lines = lines.slice(0, cmdHeight);
  }
  let maxLen = env.columns - 12;
  lines = lines.map((line) => {
    line = line.replace(/\n/g, " ");
    if (truncate)
      line = line.slice(0, maxLen);
    return line;
  });
  if (truncate && lines.length == cmdHeight) {
    let last = lines[lines.length - 1];
    lines[cmdHeight - 1] = `${last.length >= maxLen ? last.slice(0, -4) : last} ...`;
  }
  await nvim.call("coc#ui#echo_lines", [lines]);
}
function echoMessages(nvim, msg, messageType, messageLevel) {
  let hl = "Error";
  let level2 = 2 /* Error */;
  switch (messageType) {
    case "more":
      level2 = 0 /* More */;
      hl = "MoreMsg";
      break;
    case "warning":
      level2 = 1 /* Warning */;
      hl = "WarningMsg";
      break;
  }
  if (level2 >= toMessageLevel(messageLevel)) {
    let method = isVim ? "callTimer" : "call";
    nvim[method]("coc#ui#echo_messages", [hl, ("[coc.nvim] " + msg).split("\n")], true);
  }
}
function toMessageLevel(level2) {
  switch (level2) {
    case "error":
      return 2 /* Error */;
    case "warning":
      return 1 /* Warning */;
    default:
      return 0 /* More */;
  }
}
async function getSelection(nvim, mode) {
  if (mode === "currline") {
    let line = await nvim.call("line", ["."]);
    return Range.create(line - 1, 0, line, 0);
  }
  if (mode === "cursor") {
    let position = await getCursorPosition(nvim);
    return Range.create(position, position);
  }
  let res = await nvim.call("coc#cursor#get_selection", [operateModes.includes(mode) ? 1 : 0]);
  if (!res || res[0] == -1)
    return null;
  return Range.create(res[0], res[1], res[2], res[3]);
}
async function selectRange(nvim, range, redraw) {
  let { start, end } = range;
  let [line, endLine] = await nvim.eval(`[getline(${start.line + 1}),getline(${end.line + 1})]`);
  let col = line.length > 0 ? byteIndex(line, start.character) : 0;
  let endCol;
  let endLnum;
  let toEnd = end.character == 0;
  if (toEnd) {
    endLnum = end.line == 0 ? 0 : end.line - 1;
    let pre = await nvim.call("getline", [endLnum + 1]);
    endCol = byteLength(pre);
  } else {
    endLnum = end.line;
    endCol = endLine.length > 0 ? byteIndex(endLine, end.character) : 0;
  }
  nvim.pauseNotification();
  nvim.command(`noa call cursor(${start.line + 1},${col + 1})`, true);
  nvim.command("normal! v", true);
  nvim.command(`noa call cursor(${endLnum + 1},${endCol})`, true);
  if (toEnd)
    nvim.command("normal! $", true);
  await nvim.resumeNotification(redraw);
}
var operateModes;
var init_ui = __esm({
  "src/core/ui.ts"() {
    "use strict";
    init_main();
    init_floatFactory();
    init_constants();
    init_string();
    operateModes = ["char", "line", "block"];
  }
});

// src/core/dialogs.ts
var Dialogs;
var init_dialogs = __esm({
  "src/core/dialogs.ts"() {
    "use strict";
    init_events();
    init_dialog();
    init_input();
    init_menu();
    init_picker();
    init_quickpick();
    init_util();
    init_array();
    init_constants();
    init_mutex();
    init_numbers();
    init_platform();
    init_string();
    init_funcs();
    init_ui();
    Dialogs = class {
      constructor() {
        this.mutex = new Mutex();
      }
      async showDialog(config) {
        return await this.mutex.use(async () => {
          let dialog = new Dialog(this.nvim, config);
          await dialog.show(this.dialogPreference);
          return dialog;
        });
      }
      async showPrompt(title) {
        return await this.mutex.use(() => {
          return showPrompt(this.nvim, title);
        });
      }
      async createQuickPick(config) {
        return await this.mutex.use(async () => {
          let quickpick = new QuickPick(this.nvim, this.dialogPreference);
          Object.assign(quickpick, config);
          return quickpick;
        });
      }
      async showMenuPicker(items, option, token) {
        return await this.mutex.use(async () => {
          if (token && token.isCancellationRequested)
            return -1;
          option = option || {};
          if (typeof option === "string")
            option = { title: option };
          let menu = new Menu(this.nvim, { items, ...option }, token);
          let promise = new Promise((resolve) => {
            menu.onDidClose((selected) => {
              events_default.race(["BufHidden"], 20).finally(() => {
                resolve(selected);
              });
            });
          });
          await menu.show(this.dialogPreference);
          return await promise;
        });
      }
      async showQuickPick(itemsOrItemsPromise, options2, token) {
        if (isFalsyOrEmpty(itemsOrItemsPromise))
          return void 0;
        options2 = defaultValue(options2, {});
        const items = await Promise.resolve(itemsOrItemsPromise);
        let isText = items.some((s) => typeof s === "string");
        return await this.mutex.use(() => {
          return new Promise((resolve, reject) => {
            if (token.isCancellationRequested)
              return resolve(void 0);
            let quickpick = new QuickPick(this.nvim, this.dialogPreference);
            quickpick.items = items.map((o) => typeof o === "string" ? { label: o } : o);
            quickpick.title = toText(options2.title);
            quickpick.placeHolder = options2.placeholder;
            quickpick.canSelectMany = !!options2.canPickMany;
            quickpick.matchOnDescription = options2.matchOnDescription;
            quickpick.onDidFinish((items2) => {
              if (items2 == null)
                return resolve(void 0);
              let arr = isText ? items2.map((o) => o.label) : items2;
              if (options2.canPickMany)
                return resolve(arr);
              resolve(arr[0]);
            });
            quickpick.show().catch(reject);
          });
        });
      }
      async showPickerDialog(items, title, token) {
        return await this.mutex.use(async () => {
          if (token && token.isCancellationRequested) {
            return void 0;
          }
          const picker = new Picker(this.nvim, {
            title,
            items: toPickerItems(items)
          }, token);
          let promise = new Promise((resolve) => {
            picker.onDidClose((selected) => {
              resolve(selected);
            });
          });
          await picker.show(this.dialogPreference);
          let picked = await promise;
          return picked == void 0 ? void 0 : items.filter((_, i) => picked.includes(i));
        });
      }
      async requestInput(title, env, value, option) {
        let { nvim } = this;
        const promptInput = this.configuration.get("coc.preferences.promptInput");
        const inputSupported = !isVim || has(env, "patch-8.2.750") && !isWindows;
        if (promptInput && inputSupported) {
          return await this.mutex.use(async () => {
            let input = new InputBox(nvim, toText(value));
            await input.show(title, Object.assign(this.inputPreference, defaultValue(option, {})));
            return await new Promise((resolve) => {
              input.onDidFinish((text) => {
                setTimeout(() => {
                  resolve(text);
                }, 20);
              });
            });
          });
        } else {
          return await this.mutex.use(async () => {
            let res = await callAsync(this.nvim, "input", [title + ": ", toText(value)]);
            nvim.command("normal! :<C-u>", true);
            return res;
          });
        }
      }
      async createInputBox(title, value, option) {
        let input = new InputBox(this.nvim, toText(value));
        await input.show(title, Object.assign(this.inputPreference, defaultValue(option, {})));
        return input;
      }
      get inputPreference() {
        let config = this.configuration.get("dialog");
        return {
          rounded: !!config.rounded,
          maxWidth: toNumber(config.maxWidth, 80),
          highlight: defaultValue(config.floatHighlight, floatHighlightGroup),
          borderhighlight: defaultValue(config.floatBorderHighlight, floatHighlightGroup)
        };
      }
      get dialogPreference() {
        let config = this.configuration.get("dialog");
        return {
          rounded: !!config.rounded,
          maxWidth: toNumber(config.maxWidth, 80),
          maxHeight: config.maxHeight,
          floatHighlight: defaultValue(config.floatHighlight, floatHighlightGroup),
          floatBorderHighlight: defaultValue(config.floatBorderHighlight, floatHighlightGroup),
          pickerButtons: config.pickerButtons,
          pickerButtonShortcut: config.pickerButtonShortcut,
          confirmKey: toText(config.confirmKey),
          shortcutHighlight: toText(config.shortcutHighlight)
        };
      }
    };
  }
});

// src/core/highlights.ts
function convertHighlightItem(item) {
  return [item.hlGroup, item.lnum, item.colStart, item.colEnd, item.combine ? 1 : 0, item.start_incl ? 1 : 0, item.end_incl ? 1 : 0];
}
function isSame(item, curr) {
  let arr = [item.hlGroup, item.lnum, item.colStart, item.colEnd];
  return equals(arr, curr.slice(0, 4));
}
var Highlights;
var init_highlights = __esm({
  "src/core/highlights.ts"() {
    "use strict";
    init_util();
    init_object();
    Highlights = class {
      async diffHighlights(bufnr, ns, items, region, token) {
        let args = [bufnr, ns];
        if (Array.isArray(region))
          args.push(region[0], region[1] - 1);
        let curr = await this.nvim.call("coc#highlight#get_highlights", args);
        if (!curr || (token == null ? void 0 : token.isCancellationRequested))
          return null;
        items.sort((a, b) => a.lnum - b.lnum);
        let linesToRemove = [];
        let removeMarkers = [];
        let newItems = [];
        let itemIndex = 0;
        let maxIndex = items.length - 1;
        let maxLnum = 0;
        let map = /* @__PURE__ */ new Map();
        curr.forEach((o) => {
          maxLnum = Math.max(maxLnum, o[1]);
          let arr = map.get(o[1]);
          if (arr) {
            arr.push(o);
          } else {
            map.set(o[1], [o]);
          }
        });
        if (curr.length > 0) {
          let start = Array.isArray(region) ? region[0] : 0;
          for (let i = start; i <= maxLnum; i++) {
            let exists = defaultValue(map.get(i), []);
            let added = [];
            for (let j = itemIndex; j <= maxIndex; j++) {
              let o = items[j];
              if (o.lnum == i) {
                itemIndex = j + 1;
                added.push(o);
              } else {
                itemIndex = j;
                break;
              }
            }
            if (added.length == 0) {
              if (exists.length > 0) {
                if (this.checkMarkers) {
                  removeMarkers.push(...exists.map((o) => o[4]));
                } else {
                  linesToRemove.push(i);
                }
              }
            } else {
              if (exists.length == 0) {
                newItems.push(...added.map((o) => convertHighlightItem(o)));
              } else {
                if (this.checkMarkers) {
                  let skip = 0;
                  let min = Math.min(exists.length, added.length);
                  while (skip < min) {
                    if (isSame(added[skip], exists[skip])) {
                      skip++;
                    } else {
                      break;
                    }
                  }
                  removeMarkers.push(...exists.slice(skip).map((o) => o[4]));
                  newItems.push(...added.slice(skip).map((o) => convertHighlightItem(o)));
                } else if (added.length != exists.length || !added.every((o, i2) => isSame(o, exists[i2]))) {
                  linesToRemove.push(i);
                  newItems.push(...added.map((o) => convertHighlightItem(o)));
                }
              }
            }
          }
        }
        for (let i = itemIndex; i <= maxIndex; i++) {
          newItems.push(convertHighlightItem(items[i]));
        }
        return { remove: linesToRemove, add: newItems, removeMarkers };
      }
      async applyDiffHighlights(bufnr, ns, priority, diff, notify) {
        let { nvim } = this;
        let { remove: remove2, add, removeMarkers } = diff;
        if (remove2.length === 0 && add.length === 0 && removeMarkers.length === 0)
          return;
        nvim.pauseNotification();
        if (removeMarkers.length) {
          nvim.call("coc#highlight#del_markers", [bufnr, ns, removeMarkers], true);
        }
        if (remove2.length) {
          nvim.call("coc#highlight#clear", [bufnr, ns, remove2], true);
        }
        if (add.length) {
          nvim.call("coc#highlight#set", [bufnr, ns, add, priority], true);
        }
        if (notify) {
          nvim.resumeNotification(true, true);
        } else {
          await nvim.resumeNotification(true);
        }
      }
    };
  }
});

// src/model/notification.ts
function toButtons(texts) {
  return texts.map((s, index) => {
    return { text: s, index };
  });
}
function toTitles(items) {
  return items.map((item) => typeof item === "string" ? item : item.title);
}
var Notification;
var init_notification = __esm({
  "src/model/notification.ts"() {
    "use strict";
    init_events();
    init_util();
    init_array();
    Notification = class {
      constructor(nvim, config, attachEvents = true) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        if (attachEvents) {
          events_default.on("BufWinLeave", (bufnr) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback)
                config.callback(-1);
            }
          }, null, this.disposables);
          let btns = toArray(config.buttons).filter((o) => o.disabled != true);
          events_default.on("FloatBtnClick", (bufnr, idx) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback)
                config.callback(btns[idx].index);
            }
          }, null, this.disposables);
        }
      }
      get lines() {
        return this.config.content ? this.config.content.split(/\r?\n/) : [];
      }
      async show(preferences) {
        let { nvim } = this;
        let { buttons, kind, title } = this.config;
        let opts = Object.assign({}, preferences);
        opts.kind = kind ?? "";
        if (title)
          opts.title = title;
        if (preferences.border) {
          opts.borderhighlight = kind ? `CocNotification${kind[0].toUpperCase()}${kind.slice(1)}` : preferences.highlight;
        }
        if (Array.isArray(buttons)) {
          let actions = buttons.filter((o) => !o.disabled).map((o) => o.text);
          if (actions.length)
            opts.actions = actions;
        }
        let res = await nvim.call("coc#notify#create", [this.lines, opts]);
        this._winid = res[0];
        this.bufnr = res[1];
      }
      get winid() {
        return this._winid;
      }
      dispose() {
        let { winid } = this;
        if (winid) {
          this.nvim.call("coc#notify#close", [winid], true);
          this.nvim.redrawVim();
        }
        this.bufnr = void 0;
        this._winid = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/progress.ts
function formatMessage(title, message, total) {
  let parts = [];
  if (title)
    parts.push(title);
  if (message)
    parts.push(message);
  if (total)
    parts.push(total + "%");
  return parts.join(" ");
}
var logger6, ProgressNotification;
var init_progress = __esm({
  "src/model/progress.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_protocol();
    init_notification();
    logger6 = createLogger("model-progress");
    ProgressNotification = class extends Notification {
      constructor(nvim, option) {
        const buttons = [{ index: 0, text: "Cancel" }];
        super(nvim, {
          kind: "progress",
          title: option.title,
          buttons: option.cancellable ? buttons : void 0
        }, false);
        this.option = option;
        this._onDidFinish = new import_node3.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.cancelProgress = (bufnr) => {
          if (bufnr == this.bufnr && this.tokenSource) {
            this.tokenSource.cancel();
          }
        };
        this.disposables.push(this._onDidFinish);
        events_default.on("BufWinLeave", this.cancelProgress, null, this.disposables);
        if (option.cancellable) {
          events_default.on("FloatBtnClick", (bufnr, buttonIndex) => {
            if (buttonIndex == buttons.findIndex((button) => button.text == "Cancel")) {
              this.cancelProgress(bufnr);
            }
          }, null, this.disposables);
        }
      }
      async show(preferences) {
        let { task } = this.option;
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        this.disposables.push(tokenSource);
        let total = 0;
        if (this.config.buttons || !preferences.disabled) {
          await super.show(preferences);
        } else {
          logger6.warn(`progress window disabled by "notification.disabledProgressSources"`);
        }
        task({
          report: (p) => {
            if (!this.winid)
              return;
            let { nvim } = this;
            if (p.increment) {
              total += p.increment;
              nvim.call("coc#window#set_var", [this.winid, "percent", `${total}%`], true);
            }
            if (p.message)
              nvim.call("coc#window#set_var", [this.winid, "message", p.message.replace(/\r?\n/g, " ")], true);
          }
        }, tokenSource.token).then((res) => {
          this._onDidFinish.fire(res);
          this.dispose();
        }, (err) => {
          if (err)
            this.nvim.echoError(err);
          this._onDidFinish.fire(void 0);
          this.dispose();
        });
      }
    };
  }
});

// src/core/notifications.ts
var Notifications;
var init_notifications = __esm({
  "src/core/notifications.ts"() {
    "use strict";
    init_notification();
    init_progress();
    init_util();
    init_extensionRegistry();
    init_numbers();
    init_protocol();
    init_string();
    init_ui();
    Notifications = class {
      constructor(dialogs) {
        this.dialogs = dialogs;
      }
      async _showMessage(kind, message, items, stack) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, kind);
        if (items.length > 0) {
          let source = parseExtensionName(stack);
          return await this.showMessagePicker(`Choose action (${source})`, message, `Coc${kind}Float`, items);
        }
        await this.createNotification(kind.toLowerCase(), message, [], stack);
        return void 0;
      }
      createNotification(kind, message, items, stack) {
        return new Promise((resolve, reject) => {
          let config = {
            kind,
            content: message,
            buttons: toButtons(items),
            callback: (idx) => {
              resolve(idx);
            }
          };
          let notification = new Notification(this.nvim, config);
          notification.show(this.getNotificationPreference(stack)).catch(reject);
        });
      }
      async showMessagePicker(title, content, hlGroup, items) {
        let texts = items.map((o) => typeof o === "string" ? o : o.title);
        let res = await this.dialogs.showMenuPicker(texts, {
          position: "center",
          content,
          title: title.replace(/\r?\n/, " "),
          borderhighlight: hlGroup
        });
        return items[res];
      }
      async showConfirm(message, items, kind) {
        if (!items || items.length == 0) {
          let msgType = kind == "Info" ? "more" : kind == "Error" ? "error" : "warning";
          this.echoMessages(message, msgType);
          return void 0;
        }
        let titles = toTitles(items);
        let choices = titles.map((s, i) => `${i + 1}${s}`);
        let res = await this.nvim.callAsync("coc#util#with_callback", ["confirm", [message, choices.join("\n"), 0, kind]]);
        return items[res - 1];
      }
      echoMessages(msg, messageType) {
        let level2 = this.configuration.get("coc.preferences.messageLevel", "more");
        echoMessages(this.nvim, msg, messageType, level2);
      }
      async showNotification(config, stack) {
        let notification = new Notification(this.nvim, config);
        await notification.show(this.getNotificationPreference(stack));
      }
      async withProgress(options2, task) {
        let config = this.configuration.get("notification");
        let stack = Error().stack;
        if (config.statusLineProgress) {
          return await this.createStatusLineProgress(options2, task);
        }
        let progress = new ProgressNotification(this.nvim, {
          task,
          title: options2.title,
          cancellable: options2.cancellable
        });
        let minWidth = toNumber(config.minProgressWidth, 30);
        let promise = new Promise((resolve) => {
          progress.onDidFinish(resolve);
        });
        await progress.show(Object.assign(this.getNotificationPreference(stack, options2.source), { minWidth }));
        return await promise;
      }
      async createStatusLineProgress(options2, task) {
        let { title } = options2;
        let statusItem = this.statusLine.createStatusBarItem(0, true);
        statusItem.text = toText(title);
        statusItem.show();
        let total = 0;
        let result = await task({
          report: (p) => {
            if (p.increment) {
              total += p.increment;
            }
            statusItem.text = formatMessage(title, p.message, total);
          }
        }, import_node3.CancellationToken.None);
        statusItem.dispose();
        return result;
      }
      get enableMessageDialog() {
        return this.configuration.get("coc.preferences.enableMessageDialog", false);
      }
      getNotificationPreference(stack, source) {
        if (!source)
          source = parseExtensionName(stack);
        let config = this.configuration.get("notification");
        let disabledList = defaultValue(config.disabledProgressSources, []);
        let disabled = Array.isArray(disabledList) && (disabledList.includes("*") || disabledList.includes(source));
        return {
          border: config.border,
          focusable: config.focusable,
          marginRight: toNumber(config.marginRight, 10),
          timeout: toNumber(config.timeout, 1e4),
          maxWidth: toNumber(config.maxWidth, 60),
          maxHeight: toNumber(config.maxHeight, 10),
          highlight: config.highlightGroup,
          winblend: toNumber(config.winblend, 30),
          disabled,
          source
        };
      }
    };
  }
});

// src/model/terminal.ts
var TerminalModel;
var init_terminal = __esm({
  "src/model/terminal.ts"() {
    "use strict";
    TerminalModel = class {
      constructor(cmd, args, nvim, _name, strictEnv) {
        this.cmd = cmd;
        this.args = args;
        this.nvim = nvim;
        this._name = _name;
        this.strictEnv = strictEnv;
        this.pid = 0;
      }
      async start(cwd2, env) {
        let { nvim } = this;
        let cmd = [this.cmd, ...this.args];
        let [bufnr, pid] = await nvim.call("coc#terminal#start", [cmd, cwd2, env || {}, !!this.strictEnv]);
        this.bufnr = bufnr;
        this.pid = pid;
      }
      onExit(code) {
        this.exitStatus = { code: code === -1 ? void 0 : code };
      }
      get name() {
        return this._name || this.cmd;
      }
      get processId() {
        return Promise.resolve(this.pid);
      }
      sendText(text, addNewLine = true) {
        if (!this.bufnr)
          return;
        this.nvim.call("coc#terminal#send", [this.bufnr, text, addNewLine], true);
      }
      async show(preserveFocus) {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return false;
        let [loaded, curr, winids] = await nvim.eval(`[bufloaded(${bufnr}),win_getid(),win_findbuf(${bufnr})]`);
        if (!loaded)
          return false;
        let winid = winids[0];
        if (winid && curr == winid)
          return true;
        nvim.pauseNotification();
        if (!winid) {
          nvim.command(`below ${bufnr}sb`, true);
          nvim.command("resize 8", true);
          nvim.call("coc#util#do_autocmd", ["CocTerminalOpen"], true);
        } else {
          nvim.call("win_gotoid", [winid], true);
        }
        nvim.command("normal! G", true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        await nvim.resumeNotification();
        return true;
      }
      async hide() {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        await nvim.eval(`coc#window#close(bufwinid(${bufnr}))`);
      }
      dispose() {
        if (!this.exitStatus) {
          this.exitStatus = { code: void 0 };
        }
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        this.bufnr = void 0;
        nvim.call("coc#terminal#close", [bufnr], true);
      }
    };
  }
});

// src/core/terminals.ts
var Terminals;
var init_terminals = __esm({
  "src/core/terminals.ts"() {
    "use strict";
    init_events();
    init_terminal();
    init_util();
    init_object();
    init_protocol();
    Terminals = class {
      constructor() {
        this._terminals = /* @__PURE__ */ new Map();
        this.disposables = [];
        this._onDidOpenTerminal = new import_node3.Emitter();
        this._onDidCloseTerminal = new import_node3.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        events_default.on("BufUnload", (bufnr) => {
          if (this._terminals.has(bufnr)) {
            let terminal = this._terminals.get(bufnr);
            this._onDidCloseTerminal.fire(terminal);
            this._terminals.delete(bufnr);
          }
        }, null, this.disposables);
        events_default.on("TermExit", (bufnr, status) => {
          let terminal = this._terminals.get(bufnr);
          if (terminal) {
            terminal.onExit(status);
            terminal.dispose();
          }
        }, null, this.disposables);
      }
      get terminals() {
        return Array.from(this._terminals.values());
      }
      async createTerminal(nvim, opts) {
        let cwd2 = opts.cwd;
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd)
          cmd = await nvim.getOption("shell");
        if (!cwd2)
          cwd2 = await nvim.call("getcwd");
        let terminal = new TerminalModel(cmd, args || [], nvim, opts.name, opts.strictEnv);
        await terminal.start(cwd2, opts.env);
        this._terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
      }
      async runTerminalCommand(nvim, cmd, cwd2, keepfocus) {
        return await nvim.callAsync("coc#ui#run_terminal", { cmd, cwd: cwd2, keepfocus: keepfocus ? 1 : 0 });
      }
      async openTerminal(nvim, cmd, opts) {
        return await nvim.call("coc#ui#open_terminal", { cmd, ...toObject(opts) });
      }
      reset() {
        for (let terminal of this._terminals.values()) {
          terminal.dispose();
        }
        this._terminals.clear();
      }
      dispose() {
        this._onDidOpenTerminal.dispose();
        this._onDidCloseTerminal.dispose();
        disposeAll(this.disposables);
        this.reset();
      }
    };
  }
});

// data/schema.json
var require_schema = __commonJS({
  "data/schema.json"(exports2, module2) {
    module2.exports = {
      description: "Configuration file for coc.nvim",
      additionalProperties: false,
      definitions: {
        floatConfig: {
          type: "object",
          properties: {
            border: {
              type: "boolean",
              default: false,
              description: "Set to true to use borders."
            },
            rounded: {
              type: "boolean",
              default: false,
              description: "Use rounded borders when border is true."
            },
            highlight: {
              type: "string",
              default: "CocFloating",
              description: "Background highlight group of float window."
            },
            title: {
              type: "string",
              default: "",
              description: "Title used by float window."
            },
            borderhighlight: {
              type: "string",
              default: "CocFloating",
              description: "Border highlight group of float window."
            },
            close: {
              type: "boolean",
              default: false,
              description: "Set to true to draw close icon"
            },
            maxWidth: {
              type: "integer",
              description: "Maximum width of float window, include border."
            },
            maxHeight: {
              type: "integer",
              minimum: 2,
              description: "Maximum height of float window, include border."
            },
            focusable: {
              type: "boolean",
              default: true,
              description: "Enable focus by user actions (wincmds, mouse events), neovim only."
            },
            shadow: {
              type: "boolean",
              default: false,
              description: "Drop shadow effect by blending with the background, neovim only."
            },
            winblend: {
              type: "integer",
              default: 0,
              minimum: 0,
              maximum: 100,
              description: "Enables pseudo-transparency by set 'winblend' option of window, neovim only."
            }
          }
        },
        "languageserver.enable": {
          type: "boolean",
          description: "Enable the languageserver, restart coc.nvim required after change.",
          default: true
        },
        "languageserver.filetypes": {
          type: "array",
          default: [],
          description: "Supported filetypes, add * in array for all filetypes.",
          items: {
            type: "string"
          }
        },
        "languageserver.cwd": {
          type: "string",
          default: "",
          description: "Working directory of languageserver, absolute path or relative to workspace folder, use workspace root by default"
        },
        "languageserver.settings": {
          type: "object",
          default: {},
          description: "Settings of languageserver"
        },
        "languageserver.initializationOptions": {
          type: "object",
          default: {},
          description: "initializationOptions passed to languageserver"
        },
        "languageserver.env": {
          type: "object",
          default: null,
          description: "Environment variables for child process."
        },
        "languageserver.stdioEncoding": {
          type: "string",
          default: "utf8",
          description: "Encoding used for stdio of child process."
        },
        "languageserver.rootPatterns": {
          type: "array",
          default: [],
          description: "Root patterns used to resolve rootPath from current file, default to workspace root",
          items: {
            type: "string"
          }
        },
        "languageserver.requireRootPattern": {
          type: "boolean",
          default: false,
          description: "If true, doesn't start server when root pattern not found."
        },
        "languageserver.ignoredRootPaths": {
          type: "array",
          default: [],
          description: "Absolute root paths that language server should not use as rootPath, higher priority than rootPatterns.",
          items: {
            type: "string"
          }
        },
        "languageserver.additionalSchemes": {
          type: "array",
          default: [],
          description: "Additional URI schemes, default schemes including file & untitled.",
          items: {
            type: "string"
          }
        },
        "languageserver.revealOutputChannelOn": {
          type: "string",
          default: "never",
          description: "Configure message level to show the output channel buffer",
          enum: ["info", "warn", "error", "never"]
        },
        "languageserver.progressOnInitialization": {
          type: "boolean",
          default: false,
          description: "Enable progress report on languageserver initialize."
        },
        "languageserver.trace.server": {
          type: "string",
          default: "off",
          enum: ["off", "messages", "verbose"],
          description: "Trace level of communication between server and client"
        },
        "languageserver.trace.server.verbosity": {
          type: "string",
          default: "off",
          enum: ["off", "messages", "verbose"],
          description: "Trace level of communication between server and client"
        },
        "languageserver.trace.server.format": {
          type: "string",
          default: "text",
          enum: ["text", "json"],
          description: "Text format of trace messages."
        },
        "languageserver.disableDynamicRegister": {
          type: "boolean",
          default: false,
          description: "Disable dynamic registerCapability feature for this languageserver to avoid duplicate feature registration."
        },
        "languageserver.disableSnippetCompletion": {
          type: "boolean",
          default: false,
          description: "Disable completion snippet feature for this languageserver, the languageserver may not respect it."
        },
        "languageserver.disabledFeatures": {
          type: "array",
          default: [],
          description: "Disabled features for this languageserver.",
          items: {
            type: "string",
            enum: [
              "completion",
              "configuration",
              "workspaceFolders",
              "diagnostics",
              "willSave",
              "willSaveUntil",
              "didSaveTextDocument",
              "fileSystemWatcher",
              "hover",
              "signatureHelp",
              "definition",
              "references",
              "documentHighlight",
              "documentSymbol",
              "workspaceSymbol",
              "codeAction",
              "codeLens",
              "formatting",
              "documentFormatting",
              "documentRangeFormatting",
              "documentOnTypeFormatting",
              "rename",
              "documentLink",
              "executeCommand",
              "pullConfiguration",
              "typeDefinition",
              "implementation",
              "declaration",
              "color",
              "foldingRange",
              "selectionRange",
              "progress",
              "callHierarchy",
              "linkedEditing",
              "inlayHint",
              "inlineValue",
              "typeHierarchy",
              "pullDiagnostic",
              "fileEvents",
              "semanticTokens"
            ]
          }
        },
        "languageserver.formatterPriority": {
          type: "number",
          default: 0,
          description: "Priority of this languageserver's formatter."
        },
        languageServerSocket: {
          type: "object",
          required: ["port", "filetypes"],
          additionalProperties: false,
          properties: {
            port: {
              type: "integer",
              description: "Port number of socket server"
            },
            host: {
              type: "string",
              default: "127.0.0.1",
              description: "Host of server"
            },
            enable: {
              $ref: "#/definitions/languageserver.enable"
            },
            disableSnippetCompletion: {
              $ref: "#/definitions/languageserver.disableSnippetCompletion"
            },
            disableDynamicRegister: {
              $ref: "#/definitions/languageserver.disableDynamicRegister"
            },
            disabledFeatures: {
              $ref: "#/definitions/languageserver.disabledFeatures"
            },
            formatterPriority: {
              $ref: "#/definitions/languageserver.formatterPriority"
            },
            rootPatterns: {
              $ref: "#/definitions/languageserver.rootPatterns"
            },
            requireRootPattern: {
              $ref: "#/definitions/languageserver.requireRootPattern"
            },
            ignoredRootPaths: {
              $ref: "#/definitions/languageserver.ignoredRootPaths"
            },
            filetypes: {
              $ref: "#/definitions/languageserver.filetypes"
            },
            additionalSchemes: {
              $ref: "#/definitions/languageserver.additionalSchemes"
            },
            revealOutputChannelOn: {
              $ref: "#/definitions/languageserver.revealOutputChannelOn"
            },
            progressOnInitialization: {
              $ref: "#/definitions/languageserver.progressOnInitialization"
            },
            initializationOptions: {
              $ref: "#/definitions/languageserver.initializationOptions"
            },
            settings: {
              $ref: "#/definitions/languageserver.settings"
            },
            stdioEncoding: {
              $ref: "#/definitions/languageserver.stdioEncoding"
            },
            "trace.server": {
              $ref: "#/definitions/languageserver.trace.server"
            },
            "trace.server.verbosity": {
              $ref: "#/definitions/languageserver.trace.server.verbosity"
            },
            "trace.server.format": {
              $ref: "#/definitions/languageserver.trace.server.format"
            }
          }
        },
        languageServerModule: {
          type: "object",
          required: ["module", "filetypes"],
          additionalProperties: false,
          properties: {
            module: {
              type: "string",
              default: "",
              description: "Absolute path of Javascript file, should works in IPC mode"
            },
            args: {
              type: "array",
              default: [],
              description: "Extra arguments of module",
              items: {
                type: "string"
              }
            },
            runtime: {
              type: "string",
              default: "",
              description: "Absolute path of node runtime."
            },
            execArgv: {
              type: "array",
              default: [],
              description: 'ARGV passed to node when using module, normally used for debugging, ex: ["--nolazy", "--inspect-brk=6045"]',
              items: {
                type: "string"
              }
            },
            transport: {
              type: "string",
              default: "ipc",
              description: "Transport kind used by server, could be 'ipc', 'stdio', 'socket' and 'pipe'",
              enum: ["ipc", "stdio", "socket", "pipe"]
            },
            transportPort: {
              type: "integer",
              description: "Port number used when transport is 'socket'"
            },
            enable: {
              $ref: "#/definitions/languageserver.enable"
            },
            disableSnippetCompletion: {
              $ref: "#/definitions/languageserver.disableSnippetCompletion"
            },
            disableDynamicRegister: {
              $ref: "#/definitions/languageserver.disableDynamicRegister"
            },
            disabledFeatures: {
              $ref: "#/definitions/languageserver.disabledFeatures"
            },
            formatterPriority: {
              $ref: "#/definitions/languageserver.formatterPriority"
            },
            rootPatterns: {
              $ref: "#/definitions/languageserver.rootPatterns"
            },
            requireRootPattern: {
              $ref: "#/definitions/languageserver.requireRootPattern"
            },
            ignoredRootPaths: {
              $ref: "#/definitions/languageserver.ignoredRootPaths"
            },
            filetypes: {
              $ref: "#/definitions/languageserver.filetypes"
            },
            additionalSchemes: {
              $ref: "#/definitions/languageserver.additionalSchemes"
            },
            revealOutputChannelOn: {
              $ref: "#/definitions/languageserver.revealOutputChannelOn"
            },
            progressOnInitialization: {
              $ref: "#/definitions/languageserver.progressOnInitialization"
            },
            initializationOptions: {
              $ref: "#/definitions/languageserver.initializationOptions"
            },
            settings: {
              $ref: "#/definitions/languageserver.settings"
            },
            stdioEncoding: {
              $ref: "#/definitions/languageserver.stdioEncoding"
            },
            "trace.server": {
              $ref: "#/definitions/languageserver.trace.server"
            },
            "trace.server.verbosity": {
              $ref: "#/definitions/languageserver.trace.server.verbosity"
            },
            "trace.server.format": {
              $ref: "#/definitions/languageserver.trace.server.format"
            }
          }
        },
        languageServerCommand: {
          type: "object",
          required: ["command", "filetypes"],
          additionalProperties: false,
          properties: {
            command: {
              type: "string",
              default: "",
              description: "Executable in $PATH to start languageserver, should not used with module"
            },
            args: {
              type: "array",
              default: [],
              description: "Arguments of command",
              items: {
                type: "string"
              }
            },
            detached: {
              type: "boolean",
              default: false,
              description: "Detach the languageserver process"
            },
            shell: {
              type: "boolean",
              default: false,
              description: "Use shell for process"
            },
            enable: {
              $ref: "#/definitions/languageserver.enable"
            },
            disableSnippetCompletion: {
              $ref: "#/definitions/languageserver.disableSnippetCompletion"
            },
            disableDynamicRegister: {
              $ref: "#/definitions/languageserver.disableDynamicRegister"
            },
            disabledFeatures: {
              $ref: "#/definitions/languageserver.disabledFeatures"
            },
            formatterPriority: {
              $ref: "#/definitions/languageserver.formatterPriority"
            },
            rootPatterns: {
              $ref: "#/definitions/languageserver.rootPatterns"
            },
            requireRootPattern: {
              $ref: "#/definitions/languageserver.requireRootPattern"
            },
            ignoredRootPaths: {
              $ref: "#/definitions/languageserver.ignoredRootPaths"
            },
            filetypes: {
              $ref: "#/definitions/languageserver.filetypes"
            },
            additionalSchemes: {
              $ref: "#/definitions/languageserver.additionalSchemes"
            },
            revealOutputChannelOn: {
              $ref: "#/definitions/languageserver.revealOutputChannelOn"
            },
            progressOnInitialization: {
              $ref: "#/definitions/languageserver.progressOnInitialization"
            },
            initializationOptions: {
              $ref: "#/definitions/languageserver.initializationOptions"
            },
            settings: {
              $ref: "#/definitions/languageserver.settings"
            },
            stdioEncoding: {
              $ref: "#/definitions/languageserver.stdioEncoding"
            },
            "trace.server": {
              $ref: "#/definitions/languageserver.trace.server"
            },
            "trace.server.verbosity": {
              $ref: "#/definitions/languageserver.trace.server.verbosity"
            },
            "trace.server.format": {
              $ref: "#/definitions/languageserver.trace.server.format"
            }
          }
        }
      },
      properties: {
        "callHierarchy.enableTooltip": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable tooltip to show relative filepath of call hierarchy."
        },
        "callHierarchy.openCommand": {
          type: "string",
          scope: "application",
          default: "edit",
          description: "Open command for callHierarchy tree view."
        },
        "callHierarchy.splitCommand": {
          type: "string",
          scope: "application",
          default: "botright 30vs",
          description: "Window split command used by callHierarchy tree view."
        },
        "coc.preferences.rootPatterns": {
          type: ["array", "null"],
          default: null,
          scope: "application",
          description: "Root patterns to resolve workspaceFolder from parent folders of opened files, resolved from up to down.",
          deprecationMessage: "Use 'workspace.rootPatterns' instead.",
          items: {
            type: "string"
          }
        },
        "coc.preferences.bracketEnterImprove": {
          type: "boolean",
          scope: "language-overridable",
          description: "Improve enter inside bracket `<> {} [] ()` by add new empty line below and place cursor to it. Works with `coc#on_enter()`",
          default: true
        },
        "coc.preferences.currentFunctionSymbolAutoUpdate": {
          type: "boolean",
          scope: "language-overridable",
          description: "Automatically update the value of b:coc_current_function on CursorHold event",
          default: false
        },
        "coc.preferences.enableLinkedEditing": {
          type: "boolean",
          scope: "language-overridable",
          default: false,
          description: "Enable linked editing support."
        },
        "coc.preferences.enableMarkdown": {
          type: "boolean",
          scope: "application",
          description: "Tell the language server that markdown text format is supported, note that markdown text may not rendered as expected.",
          default: true
        },
        "coc.preferences.enableMessageDialog": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Enable messages shown in notification dialog."
        },
        "coc.preferences.excludeImageLinksInMarkdownDocument": {
          type: "boolean",
          description: "Exclude image links from markdown text in float window.",
          scope: "application",
          default: true
        },
        "coc.preferences.enableGFMBreaksInMarkdownDocument": {
          type: "boolean",
          description: "Exclude GFM breaks in markdown document.",
          scope: "application",
          default: true
        },
        "coc.preferences.extensionUpdateCheck": {
          type: "string",
          scope: "application",
          default: "never",
          description: "Interval for check extension update, could be daily, weekly, never",
          enum: ["daily", "weekly", "never"]
        },
        "coc.preferences.floatActions": {
          type: "boolean",
          scope: "application",
          description: "Set to false to disable float/popup support for actions menu.",
          default: true
        },
        "coc.preferences.formatOnSave": {
          type: "boolean",
          description: "Set to true to enable formatting on save.",
          scope: "language-overridable",
          default: false
        },
        "coc.preferences.formatOnSaveFiletypes": {
          type: ["null", "array"],
          scope: "resource",
          default: null,
          description: "Filetypes that should run format on save.",
          deprecationMessage: "Use coc.preferences.formatOnSave as language override configuration instead, see :h coc-configuration-scope",
          items: {
            type: "string"
          }
        },
        "coc.preferences.formatOnType": {
          type: "boolean",
          description: "Set to true to enable formatting on typing.",
          scope: "language-overridable",
          default: false
        },
        "coc.preferences.formatOnTypeFiletypes": {
          type: ["null", "array"],
          default: null,
          scope: "resource",
          description: "Filetypes that should run format on typing, only works when `coc.preferences.formatOnType` is `true`",
          deprecationMessage: "Use coc.preferences.formatOnType as language override configuration instead, see :h coc-configuration-scope",
          items: {
            type: "string"
          }
        },
        "coc.preferences.jumpCommand": {
          anyOf: [
            {
              type: "string",
              enum: [
                "edit",
                "split",
                "vsplit",
                "tabe",
                "drop",
                "tab drop",
                "pedit"
              ]
            },
            { type: "string", minimum: 1 }
          ],
          scope: "application",
          description: "Command used for location jump, like goto definition, goto references etc. Can be also a custom command that gives file as an argument.",
          default: "edit"
        },
        "coc.preferences.maxFileSize": {
          type: "string",
          scope: "application",
          default: "10MB",
          description: "Maximum file size in bytes that coc.nvim should handle, default '10MB'"
        },
        "coc.preferences.messageLevel": {
          type: "string",
          scope: "application",
          description: "Message level for filter echoed messages, could be 'more', 'warning' and 'error'",
          default: "more",
          enum: ["more", "warning", "error"]
        },
        "coc.preferences.promptInput": {
          type: "boolean",
          description: "Use prompt buffer in float window for user input.",
          scope: "application",
          default: true
        },
        "coc.preferences.renameFillCurrent": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Disable to stop Refactor-Rename float/popup window from populating with old name in the New Name field."
        },
        "coc.preferences.silentAutoupdate": {
          type: "boolean",
          description: "Not open split window with update status when performing auto update.",
          scope: "application",
          default: true
        },
        "coc.preferences.useQuickfixForLocations": {
          type: "boolean",
          scope: "application",
          description: "Use vim's quickfix list for jump locations,\n need restart on change.",
          default: false
        },
        "coc.preferences.watchmanPath": {
          type: "string",
          scope: "application",
          description: "executable path for https://facebook.github.io/watchman/, detected from $PATH by default",
          default: null
        },
        "coc.preferences.willSaveHandlerTimeout": {
          type: "integer",
          scope: "application",
          default: 500,
          minimum: 200,
          maximum: 5e3,
          description: "Will save handler timeout"
        },
        "coc.source.around.disableSyntaxes": {
          type: "array",
          default: [],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.around.enable": {
          type: "boolean",
          scope: "application",
          default: true
        },
        "coc.source.around.priority": {
          type: "integer",
          scope: "application",
          default: 1
        },
        "coc.source.around.shortcut": {
          type: "string",
          scope: "application",
          default: "A"
        },
        "coc.source.buffer.disableSyntaxes": {
          type: "array",
          default: [],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.buffer.enable": {
          type: "boolean",
          scope: "application",
          default: true
        },
        "coc.source.buffer.ignoreGitignore": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Ignore git ignored files for buffer words"
        },
        "coc.source.buffer.priority": {
          type: "integer",
          scope: "application",
          default: 1
        },
        "coc.source.buffer.shortcut": {
          type: "string",
          scope: "application",
          default: "B"
        },
        "coc.source.file.disableSyntaxes": {
          type: "array",
          default: [],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.file.enable": {
          type: "boolean",
          scope: "application",
          default: true
        },
        "coc.source.file.ignoreHidden": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Ignore completion for hidden files"
        },
        "coc.source.file.ignorePatterns": {
          type: "array",
          scope: "application",
          default: [],
          description: "Ignore patterns of matcher",
          items: {
            type: "string"
          }
        },
        "coc.source.file.priority": {
          type: "integer",
          scope: "application",
          default: 10
        },
        "coc.source.file.shortcut": {
          type: "string",
          scope: "application",
          default: "F"
        },
        "coc.source.file.triggerCharacters": {
          type: "array",
          default: ["/", "\\"],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.file.trimSameExts": {
          type: "array",
          scope: "application",
          default: [".ts", ".js"],
          description: "Trim same extension on file completion",
          items: {
            type: "string"
          }
        },
        "codeLens.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable codeLens feature, require neovim with set virtual text feature.",
          default: false
        },
        "codeLens.position": {
          type: "string",
          scope: "resource",
          enum: ["top", "eol", "right_align"],
          description: "Position of codeLens, requires nvim >= 0.6.0",
          default: "top"
        },
        "codeLens.separator": {
          type: "string",
          scope: "resource",
          description: "Separator text for codeLens in virtual text",
          default: ""
        },
        "codeLens.subseparator": {
          type: "string",
          scope: "resource",
          description: "Subseparator between codeLenses in virtual text",
          default: " | "
        },
        "colors.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable colors highlight feature, for termainal vim, 'termguicolors' option should be enabled and the termainal support gui colors.",
          default: false
        },
        "colors.filetypes": {
          type: ["array", "null"],
          default: null,
          scope: "resource",
          deprecationMessage: "Use colors.enable as language override configuration instead, see :h coc-configuration-scope",
          description: 'Filetypes that should be enabled for colors highlight feature, use "*" for all filetypes.',
          items: {
            type: "string"
          }
        },
        "colors.highlightPriority": {
          type: "number",
          scope: "application",
          description: "Priority for colors highlights, works on vim8 and neovim >= 0.6.0",
          default: 1e3,
          maximum: 4096
        },
        "cursors.cancelKey": {
          type: "string",
          scope: "application",
          default: "<esc>",
          description: "Key used for cancel cursors session."
        },
        "cursors.nextKey": {
          type: "string",
          scope: "application",
          default: "<C-n>",
          description: "Key used for jump to next cursors position."
        },
        "cursors.previousKey": {
          type: "string",
          scope: "application",
          default: "<C-p>",
          description: "Key used for jump to previous cursors position."
        },
        "cursors.wrapscan": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Searches wrap around the first or last cursors range."
        },
        "diagnostic.autoRefresh": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable automatically refresh diagnostics, use diagnosticRefresh action when it's disabled.",
          default: true
        },
        "diagnostic.checkCurrentLine": {
          type: "boolean",
          scope: "language-overridable",
          description: "When enabled, show all diagnostics of current line if there are none at the current position.",
          default: false
        },
        "diagnostic.displayByAle": {
          type: "boolean",
          scope: "language-overridable",
          description: "Use Ale for display diagnostics in vim, will disable coc for display diagnostics, restart required on change.",
          default: false
        },
        "diagnostic.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Set to false to disable diagnostic display",
          default: true
        },
        "diagnostic.enableHighlightLineNumber": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable highlighting line numbers for diagnostics, only works with neovim."
        },
        "diagnostic.enableMessage": {
          type: "string",
          scope: "application",
          default: "always",
          description: "When to enable show messages of diagnostics.",
          enum: ["always", "jump", "never"]
        },
        "diagnostic.enableSign": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Enable signs for diagnostics."
        },
        "diagnostic.errorSign": {
          type: "string",
          scope: "application",
          description: "Text of error sign",
          default: ">>"
        },
        "diagnostic.filetypeMap": {
          type: "object",
          scope: "application",
          description: 'A map between buffer filetype and the filetype assigned to diagnostics. To syntax highlight diagnostics with their parent buffer type use `"default": "bufferType"`',
          default: {}
        },
        "diagnostic.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure float window style of diagnostic message.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxHeight: {},
            maxWidth: {},
            winblend: {},
            focusable: {},
            shadow: {}
          }
        },
        "diagnostic.format": {
          type: "string",
          scope: "language-overridable",
          description: "Define the diagnostic format that shown in float window or echoed, available parts: source, code, severity, message",
          default: "%message (%source%code)"
        },
        "diagnostic.highlightLimit": {
          type: "number",
          scope: "language-overridable",
          description: "Limit count for highlighted diagnostics, too many diagnostic highlights could make vim stop responding",
          default: 1e3
        },
        "diagnostic.highlightPriority": {
          type: "number",
          scope: "language-overridable",
          description: "Priority for diagnostic highlights, works on vim8 and neovim >= 0.6.0",
          default: 4096,
          maximum: 4096,
          minimum: 110
        },
        "diagnostic.hintSign": {
          type: "string",
          scope: "application",
          description: "Text of hint sign",
          default: ">>"
        },
        "diagnostic.infoSign": {
          type: "string",
          scope: "application",
          description: "Text of info sign",
          default: ">>"
        },
        "diagnostic.level": {
          type: "string",
          scope: "resource",
          description: "Used for filter diagnostics by diagnostic severity.",
          default: "hint",
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.locationlistLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostics in locationlist.",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.locationlistUpdate": {
          type: "boolean",
          scope: "language-overridable",
          description: "Update locationlist on diagnostics change, only works with locationlist opened by :CocDiagnostics command and first window of associated buffer.",
          default: true
        },
        "diagnostic.messageDelay": {
          type: "number",
          scope: "application",
          description: "How long to wait (in milliseconds) before displaying the diagnostic message with echo or float",
          default: 200
        },
        "diagnostic.messageLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostic message in float window/popup.",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.messageTarget": {
          type: "string",
          scope: "language-overridable",
          description: "Diagnostic message target.",
          default: "float",
          enum: ["echo", "float"]
        },
        "diagnostic.refreshOnInsertMode": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable diagnostic refresh on insert mode, default false.",
          default: false
        },
        "diagnostic.separateRelatedInformationAsDiagnostics": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Separate related information as diagnostics."
        },
        "diagnostic.showDeprecated": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Show diagnostics with deprecated tag."
        },
        "diagnostic.showUnused": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Show diagnostics with unused tag, affects highlight, sign, virtual text, message"
        },
        "diagnostic.signLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostics displayed in signcolumn.",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.signPriority": {
          type: "number",
          scope: "resource",
          description: "Priority of diagnostic signs, default to 10",
          default: 10
        },
        "diagnostic.virtualText": {
          type: "boolean",
          scope: "language-overridable",
          description: "Use virtual text to display diagnostics, requires neovim >= 0.5.0 or vim >= 9.0.0067.",
          default: false
        },
        "diagnostic.virtualTextAlign": {
          type: "string",
          scope: "language-overridable",
          description: "Position of virtual text, default 'after'. Vim9 only",
          default: "after",
          enum: ["after", "right", "below"]
        },
        "diagnostic.virtualTextCurrentLineOnly": {
          type: "boolean",
          scope: "language-overridable",
          description: "Only show virtualText diagnostic on current cursor line",
          default: true
        },
        "diagnostic.virtualTextFormat": {
          type: "string",
          scope: "language-overridable",
          description: "Define the virtual text diagnostic format, available parts: source, code, severity, message",
          default: "%message"
        },
        "diagnostic.virtualTextLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostic message in virtual text by level",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.virtualTextLimitInOneLine": {
          type: "integer",
          scope: "language-overridable",
          minimum: 1,
          description: "The maximum number of diagnostic messages to disaply in one line",
          default: 999
        },
        "diagnostic.virtualTextLineSeparator": {
          type: "string",
          scope: "language-overridable",
          description: "The text that will mark a line end from the diagnostic message",
          default: " \\ "
        },
        "diagnostic.virtualTextLines": {
          type: "number",
          scope: "language-overridable",
          description: "The number of non empty lines from a diagnostic to display",
          default: 3
        },
        "diagnostic.virtualTextPrefix": {
          type: "string",
          scope: "language-overridable",
          description: "The prefix added virtual text diagnostics",
          default: " "
        },
        "diagnostic.virtualTextWinCol": {
          type: ["number", "null"],
          scope: "language-overridable",
          description: "Window column number to align virtual text, neovim only.",
          default: null
        },
        "diagnostic.warningSign": {
          type: "string",
          scope: "application",
          description: "Text of warning sign",
          default: "\u26A0"
        },
        "dialog.confirmKey": {
          type: "string",
          default: "<cr>",
          scope: "application",
          description: "Confirm key for confirm selection used by menu and picker, you can always use <esc> to cancel."
        },
        "dialog.floatBorderHighlight": {
          type: ["string", "null"],
          default: null,
          scope: "application",
          description: "Highlight group for border of dialog window/popup, default to 'CocFloating'"
        },
        "dialog.floatHighlight": {
          type: ["string", "null"],
          default: null,
          scope: "application",
          description: "Highlight group for dialog window/popup, default to 'CocFloating'"
        },
        "dialog.maxHeight": {
          type: "number",
          default: 30,
          scope: "application",
          description: "Maximum height of dialog window."
        },
        "dialog.maxWidth": {
          type: "number",
          default: 80,
          scope: "application",
          description: "Maximum width of dialog window."
        },
        "dialog.pickerButtonShortcut": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Show shortcut in buttons of picker dialog window/popup, used when dialog.pickerButtons is true."
        },
        "dialog.pickerButtons": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Show buttons for picker dialog window/popup."
        },
        "dialog.rounded": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "use rounded border for dialog window."
        },
        "dialog.shortcutHighlight": {
          type: "string",
          default: "MoreMsg",
          scope: "application",
          description: "Highlight group for shortcut character in menu dialog, default to 'MoreMsg'"
        },
        "documentHighlight.priority": {
          type: "number",
          default: -1,
          scope: "resource",
          description: "Match priority used by document highlight, see ':h matchadd'"
        },
        "documentHighlight.timeout": {
          type: "integer",
          default: 300,
          minimum: 200,
          maximum: 5e3,
          scope: "resource",
          description: "Timeout for document highlight, in milliseconds."
        },
        "floatFactory.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure default style float window/popup created by float factory (created around cursor and automatically closed)",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxWidth: {},
            maxHeight: {},
            winblend: {},
            focusable: {},
            shadow: {}
          }
        },
        "hover.autoHide": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Automatically hide hover float window on CursorMove or InsertEnter."
        },
        "hover.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure float window style of hover documents.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxHeight: {},
            maxWidth: {},
            winblend: {},
            focusable: {},
            shadow: {}
          }
        },
        "hover.previewMaxHeight": {
          type: "number",
          scope: "resource",
          default: 12,
          description: "Max height of preview window for hover."
        },
        "hover.target": {
          type: "string",
          default: "float",
          scope: "resource",
          description: "Target to show hover information, default is floating window when possible.",
          enum: ["preview", "echo", "float"]
        },
        "http.proxy": {
          type: "string",
          default: "",
          pattern: "^https?://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
          description: "The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables.",
          scope: "application"
        },
        "http.proxyAuthorization": {
          type: ["null", "string"],
          description: "The value to send as the `Proxy-Authorization` header for every network request.",
          default: null,
          scope: "application"
        },
        "http.proxyCA": {
          type: "string",
          description: "CA (file) to use as Certificate Authority",
          default: null,
          scope: "application"
        },
        "http.proxyStrictSSL": {
          type: "boolean",
          description: "Controls whether the proxy server certificate should be verified against the list of supplied CAs",
          default: true,
          scope: "application"
        },
        "inlayHint.enable": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Enable inlay hint support"
        },
        "inlayHint.enableParameter": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Enable inlay hints for parameters."
        },
        "inlayHint.display": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Display inlay hints."
        },
        "inlayHint.filetypes": {
          type: ["array", "null"],
          scope: "application",
          description: "Filetypes that enable inlayHint, all filetypes are enabled by default",
          deprecationMessage: "Use inlayHint.enable with language scope instead, see :h coc-configuration-scope",
          default: null,
          items: {
            type: "string"
          }
        },
        "inlayHint.parameterSeparator": {
          type: "string",
          scope: "language-overridable",
          default: "",
          description: "Separator for parameter inlay hint, neovim only."
        },
        "inlayHint.refreshOnInsertMode": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Refresh inlayHints on insert mode."
        },
        "inlayHint.subSeparator": {
          type: "string",
          scope: "language-overridable",
          default: " ",
          description: "Separator for chained inlay hints, neovim only."
        },
        "inlayHint.typeSeparator": {
          type: "string",
          scope: "language-overridable",
          default: "",
          description: "Separator for type inlay hint, neovim only."
        },
        "links.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable document links",
          default: true
        },
        "links.tooltip": {
          type: "boolean",
          scope: "application",
          description: "Show tooltip of link under cursor on CursorHold.",
          default: false
        },
        "links.highlight": {
          type: "boolean",
          scope: "application",
          description: "Use CocLink highlight group to highlight links",
          default: false
        },
        "list.floatPreview": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Enable preview with float window/popup, default: `false`"
        },
        "list.alignColumns": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Whether to align lists in columns, default: `false`"
        },
        "list.extendedSearchMode": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable extended search mode which allows multiple search patterns delimited by spaces."
        },
        "list.height": {
          type: "number",
          scope: "application",
          default: 10,
          description: "Height of split list window."
        },
        "list.indicator": {
          type: "string",
          default: ">",
          scope: "application",
          description: "The character used as first character in prompt line."
        },
        "list.insertMappings": {
          type: "object",
          scope: "application",
          default: {},
          description: "Custom keymappings on insert mode."
        },
        "list.interactiveDebounceTime": {
          type: "number",
          default: 100,
          scope: "application",
          description: "Debounce time for input change on interactive mode."
        },
        "list.limitLines": {
          type: ["number", "null"],
          scope: "application",
          default: null,
          description: "Limit lines for list buffer."
        },
        "list.maxPreviewHeight": {
          type: "number",
          scope: "application",
          default: 12,
          description: "Max height for preview window of list."
        },
        "list.menuAction": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Use menu picker instead of confirm() for choose action."
        },
        "list.nextKeymap": {
          type: "string",
          scope: "application",
          default: "<C-j>",
          description: "Key used for select next line on insert mode."
        },
        "list.normalMappings": {
          type: "object",
          scope: "application",
          default: {},
          description: "Custom keymappings on normal mode."
        },
        "list.previewHighlightGroup": {
          type: "string",
          scope: "application",
          default: "Search",
          description: "Highlight group used for highlight the range in preview window."
        },
        "list.previewSplitRight": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Use vsplit for preview window."
        },
        "list.previewToplineOffset": {
          type: "number",
          scope: "application",
          default: 3,
          description: "Topline offset for list previews"
        },
        "list.previewToplineStyle": {
          type: "string",
          scope: "application",
          default: "offset",
          description: "Topline style for list previews",
          enum: ["offset", "middle"]
        },
        "list.previousKeymap": {
          type: "string",
          scope: "application",
          default: "<C-k>",
          description: "Key used for select previous line on insert mode."
        },
        "list.selectedSignText": {
          type: "string",
          scope: "application",
          default: "*",
          description: "Sign text for selected lines."
        },
        "list.signOffset": {
          type: "number",
          scope: "application",
          default: 900,
          description: "Sign offset of list, should be different from other plugins."
        },
        "list.smartCase": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Use smartcase match for fuzzy match and strict match, --ignore-case will be ignored, may not affect interactive list."
        },
        "list.source.diagnostics.includeCode": {
          type: "boolean",
          scope: "application",
          description: "Whether to show the diagnostic code in the list.",
          default: true
        },
        "list.source.diagnostics.pathFormat": {
          type: "string",
          scope: "application",
          description: "Decide how the filepath is shown in the list.",
          enum: ["full", "short", "filename", "hidden"],
          default: "full"
        },
        "list.source.outline.ctagsFiletypes": {
          type: "array",
          scope: "application",
          default: [],
          description: "Filetypes that should use ctags for outline instead of language server.",
          items: {
            type: "string"
          }
        },
        "list.source.symbols.excludes": {
          type: "array",
          scope: "application",
          default: [],
          description: "Patterns of minimatch for filepath to exclude from symbols list.",
          items: {
            type: "string"
          }
        },
        "list.statusLineSegments": {
          type: ["array", "null"],
          scope: "application",
          default: [
            '%#CocListMode#-- %{coc#list#status("mode")} --%*',
            '%{coc#list#status("loading")}',
            '%{coc#list#status("args")}',
            '(%L/%{coc#list#status("total")})',
            "%=",
            '%#CocListPath# %{coc#list#status("cwd")} %l/%L%*'
          ],
          items: {
            types: "string"
          },
          description: "An array of statusline segments that will be used to draw the status line for list windows."
        },
        "notification.statusLineProgress": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Show progress notification in status line, instead of float window/popup."
        },
        "notification.border": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Enable rounded border for notification windows."
        },
        "notification.disabledProgressSources": {
          type: "array",
          default: [],
          scope: "application",
          description: "Sources that should be disabled for message progress, use * to disable all message only progresses",
          items: {
            type: "string"
          }
        },
        "notification.focusable": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Enable focus by user actions (wincmds, mouse events), neovim only."
        },
        "notification.highlightGroup": {
          type: "string",
          default: "Normal",
          scope: "application",
          description: "Highlight group of notification dialog."
        },
        "notification.marginRight": {
          type: "integer",
          default: 10,
          scope: "application",
          description: "Margin right to the right of editor window."
        },
        "notification.maxHeight": {
          type: "integer",
          default: 10,
          scope: "application",
          description: "Maximum content height of notification dialog."
        },
        "notification.maxWidth": {
          type: "integer",
          default: 60,
          scope: "application",
          description: "Maximum content width of notification dialog."
        },
        "notification.minProgressWidth": {
          type: "integer",
          default: 30,
          scope: "application",
          description: "Minimal with of progress notification."
        },
        "notification.timeout": {
          type: "integer",
          default: 1e4,
          scope: "application",
          description: "Timeout for auto close notifications, in milliseconds."
        },
        "notification.winblend": {
          type: "integer",
          default: 30,
          minimum: 0,
          maximum: 100,
          scope: "application",
          description: "Winblend option of notification window, neovim only."
        },
        "npm.binPath": {
          type: "string",
          scope: "application",
          default: "npm",
          description: "Command or absolute path to npm or yarn."
        },
        "outline.autoPreview": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Enable auto preview on cursor move."
        },
        "outline.autoWidth": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Automatically increase window width to avoid wrapped lines."
        },
        "outline.checkBufferSwitch": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Recreate outline view after user changed to another buffer on current tab."
        },
        "outline.codeActionKinds": {
          type: "array",
          scope: "application",
          default: ["", "quickfix", "refactor"],
          description: "Filter code actions in actions menu by kinds.",
          items: {
            type: "string",
            enum: ["", "quickfix", "refactor", "source"]
          }
        },
        "outline.detailAsDescription": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Show detail as description aside with label, when false detail will be shown in tooltip on cursor hold."
        },
        "outline.expandLevel": {
          type: "number",
          scope: "application",
          default: 1,
          description: "Expand level of tree nodes."
        },
        "outline.followCursor": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Reveal item in outline tree on cursor hold."
        },
        "outline.keepWindow": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Jump back to original window after outline is shown."
        },
        "outline.previewBorder": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Use border for preview window."
        },
        "outline.previewBorderHighlightGroup": {
          type: "string",
          scope: "application",
          default: "Normal",
          description: "Border highlight group of preview window."
        },
        "outline.previewBorderRounded": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Use rounded border for preview window."
        },
        "outline.previewHighlightGroup": {
          type: "string",
          scope: "application",
          default: "Normal",
          description: "Highlight group of preview window."
        },
        "outline.previewMaxWidth": {
          type: "number",
          scope: "application",
          default: 80,
          description: "Max width of preview window."
        },
        "outline.previewWinblend": {
          type: "integer",
          scope: "application",
          default: 0,
          minimum: 0,
          maximum: 100,
          description: "Enables pseudo-transparency by set 'winblend' option of window, neovim only."
        },
        "outline.showLineNumber": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Show line number of symbols."
        },
        "outline.sortBy": {
          type: "string",
          scope: "application",
          default: "category",
          description: "Sort method for symbols.",
          enum: ["position", "name", "category"]
        },
        "outline.splitCommand": {
          type: "string",
          scope: "application",
          default: "botright 30vs",
          description: "Window split command used by outline."
        },
        "outline.switchSortKey": {
          type: "string",
          scope: "application",
          default: "<C-s>",
          description: "The key used to switch sort method for symbols provider of current tree view."
        },
        "outline.togglePreviewKey": {
          type: "string",
          scope: "application",
          default: "p",
          description: "The key used to toggle auto preview feature."
        },
        "pullDiagnostic.ignored": {
          type: "array",
          default: [],
          scope: "application",
          description: "Minimatch patterns to match full filepath that should be ignored for pullDiagnostic.",
          items: {
            type: "string"
          }
        },
        "pullDiagnostic.onChange": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Whether to pull for diagnostics on document change."
        },
        "pullDiagnostic.onSave": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Whether to pull for diagnostics on document save."
        },
        "pullDiagnostic.workspace": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Whether to pull for workspace diagnostics when possible."
        },
        "refactor.afterContext": {
          type: "number",
          scope: "application",
          default: 3,
          description: "Print num lines of trailing context after each match."
        },
        "refactor.beforeContext": {
          type: "number",
          scope: "application",
          default: 3,
          description: "Print num lines of leading context before each match."
        },
        "refactor.openCommand": {
          type: "string",
          scope: "application",
          description: "Open command for refactor window.",
          default: "vsplit"
        },
        "refactor.saveToFile": {
          type: "boolean",
          scope: "application",
          description: "Save changed buffer to file when write refactor buffer with ':noa wa' command.",
          default: true
        },
        "refactor.showMenu": {
          type: "string",
          scope: "application",
          default: "<Tab>",
          description: "Refactor buffer local mapping to bring up menu for this chunk."
        },
        "semanticTokens.combinedModifiers": {
          type: "array",
          scope: "language-overridable",
          description: "Semantic token modifiers that should have highlight combined with syntax highlights.",
          default: ["deprecated"],
          items: {
            type: "string"
          }
        },
        "semanticTokens.enable": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Enable semantic tokens support"
        },
        "semanticTokens.filetypes": {
          type: ["array", "null"],
          scope: "resource",
          description: 'Filetypes that enable semantic tokens highlighting or ["*"] for any filetype',
          deprecationMessage: "Use semanticTokens.enable configuration with language scope instead, see :h coc-configuration-scope",
          default: null,
          items: {
            type: "string"
          }
        },
        "semanticTokens.highlightPriority": {
          type: "number",
          scope: "language-overridable",
          description: "Priority for semantic tokens highlight.",
          default: 2048,
          maximum: 4096
        },
        "semanticTokens.incrementTypes": {
          type: "array",
          scope: "language-overridable",
          description: "Semantic token types that should increase highlight when insert at the start and end position of token.",
          default: ["variable", "string", "parameter"],
          items: {
            type: "string"
          }
        },
        "signature.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable show signature help when trigger character typed.",
          default: true
        },
        "signature.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure float window style of signature documents.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxHeight: {},
            maxWidth: {},
            winblend: {},
            focusable: {},
            shadow: {}
          }
        },
        "signature.hideOnTextChange": {
          type: "boolean",
          scope: "language-overridable",
          description: "Hide signature float window when text changed on insert mode.",
          default: false
        },
        "signature.preferShownAbove": {
          type: "boolean",
          scope: "application",
          description: "Show signature help float window above cursor when possible, require restart service on change.",
          default: true
        },
        "signature.target": {
          type: "string",
          scope: "language-overridable",
          description: "Target of signature help, use float when possible by default.",
          default: "float",
          enum: ["float", "echo"]
        },
        "signature.triggerSignatureWait": {
          type: "integer",
          scope: "language-overridable",
          default: 500,
          minimum: 200,
          maximum: 1e3,
          description: "Timeout for trigger signature help, in milliseconds."
        },
        "snippet.highlight": {
          type: "boolean",
          scope: "resource",
          description: "Use highlight group 'CocSnippetVisual' to highlight placeholders with same index of current one.",
          default: false
        },
        "snippet.nextPlaceholderOnDelete": {
          type: "boolean",
          scope: "resource",
          description: "Automatically jump to the next placeholder when the current one is completely deleted.",
          default: false
        },
        "snippet.statusText": {
          type: "string",
          scope: "application",
          default: "SNIP",
          description: "Text shown in statusline to indicate snippet session is activated."
        },
        "suggest.acceptSuggestionOnCommitCharacter": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character."
        },
        "suggest.asciiCharactersOnly": {
          type: "boolean",
          description: "Trigger suggest with ASCII characters only",
          scope: "language-overridable",
          default: false
        },
        "suggest.asciiMatch": {
          type: "boolean",
          description: "Convert unicode characters to ascii for match",
          scope: "language-overridable",
          default: true
        },
        "suggest.autoTrigger": {
          type: "string",
          scope: "language-overridable",
          default: "always",
          description: "How should completion be triggered",
          enum: ["always", "trigger", "none"]
        },
        "suggest.completionItemKindLabels": {
          type: "object",
          default: {},
          scope: "application",
          description: "Set custom labels to completion items' kinds.",
          properties: {
            text: { type: "string" },
            method: { type: "string" },
            function: { type: "string" },
            constructor: { type: "string" },
            field: { type: "string" },
            variable: { type: "string" },
            class: { type: "string" },
            interface: { type: "string" },
            module: { type: "string" },
            property: { type: "string" },
            unit: { type: "string" },
            value: { type: "string" },
            enum: { type: "string" },
            keyword: { type: "string" },
            snippet: { type: "string" },
            color: { type: "string" },
            file: { type: "string" },
            reference: { type: "string" },
            folder: { type: "string" },
            enumMember: { type: "string" },
            constant: { type: "string" },
            struct: { type: "string" },
            event: { type: "string" },
            operator: { type: "string" },
            typeParameter: { type: "string" },
            default: { type: "string" }
          },
          additionalProperties: false
        },
        "suggest.defaultSortMethod": {
          type: "string",
          description: "Default sorting behavior for suggested completion items.",
          default: "length",
          scope: "language-overridable",
          enum: ["length", "alphabetical", "none"]
        },
        "suggest.detailField": {
          type: "string",
          scope: "application",
          default: "preview",
          description: "Where to show the detail text of CompleteItem from LS.",
          enum: ["abbr", "preview"]
        },
        "suggest.detailMaxLength": {
          type: "number",
          scope: "application",
          description: "Max length of detail that should be shown in popup menu.",
          deprecationMessage: "Use suggest.labelMaxLength instead.",
          default: 100
        },
        "suggest.enableFloat": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable float window with documentation aside with popupmenu.",
          default: true
        },
        "suggest.enablePreselect": {
          type: "boolean",
          scope: "application",
          description: "Enable preselect feature of LSP, works when suggest.noselect is false.",
          default: true
        },
        "suggest.filterGraceful": {
          type: "boolean",
          description: "Controls whether filtering and sorting suggestions accounts for small typos.",
          scope: "language-overridable",
          default: true
        },
        "suggest.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure style of popup menu and documentation window of completion.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            maxWidth: {},
            winblend: {},
            shadow: {}
          }
        },
        "suggest.formatItems": {
          type: "array",
          scope: "application",
          items: {
            enum: ["abbr", "menu", "kind", "shortcut"]
          },
          contains: {
            enum: ["abbr"]
          },
          uniqueItems: true,
          description: "Items shown in popup menu in order.",
          default: ["abbr", "menu", "kind", "shortcut"]
        },
        "suggest.highPrioritySourceLimit": {
          type: "integer",
          minimum: 1,
          maximum: 100,
          scope: "language-overridable",
          description: "Max items count for source priority bigger than or equal to 90."
        },
        "suggest.insertMode": {
          type: "string",
          scope: "language-overridable",
          default: "replace",
          description: "Controls whether words are overwritten when accepting completions.",
          enum: ["insert", "replace"]
        },
        "suggest.ignoreRegexps": {
          type: "array",
          scope: "language-overridable",
          items: {
            type: "string"
          },
          description: "Regexps to ignore when trigger suggest",
          default: []
        },
        "suggest.invalidInsertCharacters": {
          type: "array",
          items: {
            type: "string"
          },
          scope: "application",
          description: "Invalid character for strip valid word when inserting text of complete item.",
          default: ["\r", "\n"]
        },
        "suggest.labelMaxLength": {
          type: "number",
          scope: "application",
          description: "Max length of abbr that shown as label of complete item.",
          default: 200
        },
        "suggest.languageSourcePriority": {
          type: "number",
          default: 99,
          scope: "language-overridable",
          description: "Priority of language sources."
        },
        "suggest.localityBonus": {
          type: "boolean",
          description: "Controls whether sorting favors words that appear close to the cursor.",
          scope: "language-overridable",
          default: true
        },
        "suggest.lowPrioritySourceLimit": {
          type: "integer",
          minimum: 1,
          maximum: 100,
          scope: "language-overridable",
          description: "Max items count for source priority lower than 90."
        },
        "suggest.maxCompleteItemCount": {
          type: "number",
          default: 256,
          scope: "language-overridable",
          description: "Maximum number of complete items shown in vim"
        },
        "suggest.minTriggerInputLength": {
          type: "integer",
          default: 1,
          scope: "language-overridable",
          description: "Minimal input length for trigger completion, default 1"
        },
        "suggest.noselect": {
          type: "boolean",
          scope: "application",
          description: "Not make vim select first item on popupmenu shown",
          default: false
        },
        "suggest.preferCompleteThanJumpPlaceholder": {
          type: "boolean",
          description: "Confirm completion instead of jump to next placeholder when completion is activated.",
          scope: "resource",
          default: false
        },
        "suggest.pumFloatConfig": {
          type: ["object", "null"],
          scope: "application",
          description: "Configure style of popup menu, suggest.floatConfig is used when not specified.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          default: null,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            winblend: {},
            shadow: {}
          }
        },
        "suggest.removeDuplicateItems": {
          type: "boolean",
          description: "Remove completion items with duplicated word for all sources, snippet items are excluded.",
          scope: "language-overridable",
          default: false
        },
        "suggest.reversePumAboveCursor": {
          type: "boolean",
          scope: "application",
          description: "Reverse order of complete items when pum shown above cursor.",
          default: false
        },
        "suggest.selection": {
          type: "string",
          scope: "application",
          default: "first",
          description: "Controls how suggestions are pre-selected when showing the suggest list.",
          enum: ["first", "recentlyUsed", "recentlyUsedByPrefix"]
        },
        "suggest.snippetIndicator": {
          type: "string",
          default: "~",
          scope: "application",
          description: "The character used in abbr of complete item to indicate the item could be expand as snippet."
        },
        "suggest.snippetsSupport": {
          type: "boolean",
          scope: "language-overridable",
          description: "Set to false to disable snippets support of completion.",
          default: true
        },
        "suggest.timeout": {
          type: "integer",
          default: 5e3,
          minimum: 500,
          maximum: 15e3,
          scope: "language-overridable",
          description: "Timeout for completion, in milliseconds."
        },
        "suggest.triggerAfterInsertEnter": {
          type: "boolean",
          description: "Trigger completion after InsertEnter, auto trigger should be 'always' to enable this option",
          scope: "language-overridable",
          default: false
        },
        "suggest.triggerCompletionWait": {
          type: "integer",
          default: 0,
          minimum: 0,
          maximum: 50,
          scope: "language-overridable",
          description: "Wait time between text change and completion start, cancel completion when text changed during wait."
        },
        "suggest.virtualText": {
          type: "boolean",
          scope: "application",
          description: "Show virtual text for insert word of selected item, requires neovim >= 0.5.0 or vim >= 9.0.0067",
          default: false
        },
        "tree.closedIcon": {
          type: "string",
          scope: "application",
          default: "+",
          description: "Closed icon of tree view."
        },
        "tree.key.actions": {
          type: "string",
          scope: "application",
          default: "<tab>",
          description: "Trigger key to invoke actions."
        },
        "tree.key.activeFilter": {
          type: "string",
          scope: "application",
          default: "f",
          description: "Trigger key active filter."
        },
        "tree.key.close": {
          type: "string",
          scope: "application",
          default: "<esc>",
          description: "Trigger key to dispose the tree and close tree window."
        },
        "tree.key.collapseAll": {
          type: "string",
          scope: "application",
          default: "M",
          description: "Trigger key to collapse all tree node."
        },
        "tree.key.invoke": {
          type: "string",
          scope: "application",
          default: "<cr>",
          description: "Trigger key to invoke default command of current node or selection."
        },
        "tree.key.selectNext": {
          type: "string",
          scope: "application",
          default: "<C-j>",
          description: "Trigger key to select next item during filter."
        },
        "tree.key.selectPrevious": {
          type: "string",
          scope: "application",
          default: "<C-k>",
          description: "Trigger key to select previous item during filter."
        },
        "tree.key.toggle": {
          type: "string",
          scope: "application",
          default: "t",
          description: "Trigger key to toggle expand state of tree node, does nothing with leaf node."
        },
        "tree.key.toggleSelection": {
          type: "string",
          scope: "application",
          default: "<space>",
          description: "Trigger key to select/unselect item"
        },
        "tree.openedIcon": {
          type: "string",
          scope: "application",
          default: "-",
          description: "Opened icon of tree view."
        },
        "typeHierarchy.enableTooltip": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable tooltip to show relative filepath of type hierarchy."
        },
        "typeHierarchy.openCommand": {
          type: "string",
          scope: "application",
          default: "edit",
          description: "Open command for type hierarchy tree view."
        },
        "typeHierarchy.splitCommand": {
          type: "string",
          scope: "application",
          default: "botright 30vs",
          description: "Window split command used by type hierarchy tree view."
        },
        "workspace.rootPatterns": {
          type: "array",
          default: [".git", ".hg", ".projections.json"],
          scope: "application",
          description: "Root patterns to resolve workspaceFolder from parent folders of opened files, resolved from up to down.",
          items: {
            type: "string"
          }
        },
        "workspace.bottomUpFiletypes": {
          type: "array",
          default: [],
          scope: "application",
          description: 'Filetypes that should have workspace folder should resolved from base directory of file, or ["*"] for any filetype.',
          items: {
            type: "string"
          }
        },
        "workspace.ignoredFiletypes": {
          type: "array",
          default: [],
          scope: "application",
          description: "Filetypes that should be ignored for workspace folder resolve.",
          items: {
            type: "string"
          }
        },
        "workspace.ignoredFolders": {
          type: "array",
          default: ["$HOME"],
          scope: "application",
          description: "List of folders that should not be resolved as workspace folder, environment variables and minimatch patterns can be used.",
          items: {
            type: "string"
          }
        },
        "workspace.openOutputCommand": {
          type: "string",
          default: "vs",
          scope: "resource",
          description: "Command used to open output channel."
        },
        "workspace.openResourceCommand": {
          type: "string",
          default: "tab drop",
          scope: "application",
          description: "Command to open files that not loaded, load files as hidden buffers when empty."
        },
        "workspace.workspaceFolderCheckCwd": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Whether the current working directory should be used first when checking patterns match for workspace folder."
        },
        "workspace.workspaceFolderFallbackCwd": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Use current working directory as workspace folder when no root patterns resolved."
        },
        languageserver: {
          type: "object",
          default: {},
          scope: "resource",
          description: "Dictionary of languageservers, key is used as id of languageserver, restart coc.nvim required after change.",
          patternProperties: {
            "^[_a-zA-Z]+$": {
              oneOf: [
                {
                  $ref: "#/definitions/languageServerModule"
                },
                {
                  $ref: "#/definitions/languageServerCommand"
                },
                {
                  $ref: "#/definitions/languageServerSocket"
                }
              ]
            }
          }
        }
      }
    };
  }
});

// src/util/jsonRegistry.ts
var Extensions2, JSONContributionRegistry, jsonContributionRegistry;
var init_jsonRegistry = __esm({
  "src/util/jsonRegistry.ts"() {
    "use strict";
    init_protocol();
    init_registry();
    Extensions2 = {
      JSONContribution: "base.contributions.json"
    };
    JSONContributionRegistry = class {
      constructor() {
        this._onDidChangeSchema = new import_node3.Emitter();
        this.onDidChangeSchema = this._onDidChangeSchema.event;
        this.schemasById = {};
      }
      registerSchema(uri, unresolvedSchemaContent) {
        this.schemasById[uri] = unresolvedSchemaContent;
        this._onDidChangeSchema.fire(uri);
      }
      notifySchemaChanged(uri) {
        this._onDidChangeSchema.fire(uri);
      }
      getSchemaContributions() {
        return {
          schemas: this.schemasById
        };
      }
    };
    jsonContributionRegistry = new JSONContributionRegistry();
    Registry.add(Extensions2.JSONContribution, jsonContributionRegistry);
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
function mergeSort(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  var p = data.length / 2 | 0;
  var left = data.slice(0, p);
  var right = data.slice(p);
  mergeSort(left, compare2);
  mergeSort(right, compare2);
  var leftIdx = 0;
  var rightIdx = 0;
  var i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    var ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
  if (textOffset === void 0) {
    textOffset = 0;
  }
  var result = isAtLineStart ? [textOffset] : [];
  for (var i = 0; i < text.length; i++) {
    var ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  var start = range.start;
  var end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  var range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var __spreadArray, FullTextDocument2, TextDocument2;
var init_main3 = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    FullTextDocument2 = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(changes, version2) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
          var change = changes_1[_i];
          if (FullTextDocument3.isIncremental(change)) {
            var range = getWellformedRange(change.range);
            var startOffset = this.offsetAt(range.start);
            var endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            var startLine = Math.max(range.start.line, 0);
            var endLine = Math.max(range.end.line, 0);
            var lineOffsets = this._lineOffsets;
            var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            var diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (FullTextDocument3.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version2;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.isIncremental = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      };
      FullTextDocument3.isFull = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      };
      return FullTextDocument3;
    }();
    (function(TextDocument3) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument2(uri, languageId, version2, content);
      }
      TextDocument3.create = create;
      function update(document2, changes, version2) {
        if (document2 instanceof FullTextDocument2) {
          document2.update(changes, version2);
          return document2;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument3.update = update;
      function applyEdits3(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
          var e = sortedEdits_1[_i];
          var startOffset = document2.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document2.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument3.applyEdits = applyEdits3;
    })(TextDocument2 || (TextDocument2 = {}));
  }
});

// src/configuration/util.ts
function expand(input) {
  return input.replace(/\$\{(.*?)\}/g, (match, name2) => {
    if (name2.startsWith("env:")) {
      let key = name2.split(":")[1];
      return process.env[key] ?? match;
    }
    switch (name2) {
      case "userHome":
        return os.homedir();
      case "cwd":
        return process.cwd();
      default:
        return match;
    }
  });
}
function expandObject(obj) {
  if (obj == null)
    return obj;
  if (typeof obj === "string")
    return expand(obj);
  if (Array.isArray(obj))
    return obj.map((obj2) => expandObject(obj2));
  if (objectLiteral(obj)) {
    for (let key of Object.keys(obj)) {
      obj[key] = expandObject(obj[key]);
    }
    return obj;
  }
  return obj;
}
function convertTarget(updateTarget) {
  let target;
  switch (updateTarget) {
    case 1 /* Global */:
      target = 1 /* User */;
      break;
    case 2 /* Workspace */:
      target = 2 /* Workspace */;
      break;
    default:
      target = 3 /* WorkspaceFolder */;
  }
  return target;
}
function scopeToOverrides(scope) {
  let overrides;
  if (typeof scope === "string") {
    overrides = { resource: scope };
  } else if (URI.isUri(scope)) {
    overrides = { resource: scope.toString() };
  } else if (scope != null) {
    let uri = scope["uri"];
    let languageId = scope["languageId"];
    overrides = { resource: uri, overrideIdentifier: languageId };
  }
  return overrides;
}
function overrideIdentifiersFromKey(key) {
  const identifiers = [];
  if (OVERRIDE_PROPERTY_REGEX.test(key)) {
    let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    while (matches == null ? void 0 : matches.length) {
      const identifier = matches[1].trim();
      if (identifier) {
        identifiers.push(identifier);
      }
      matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    }
  }
  return distinct(identifiers);
}
function mergeConfigProperties(obj) {
  let res = {};
  for (let key of Object.keys(obj)) {
    if (key.indexOf(".") == -1) {
      res[key] = obj[key];
    } else {
      let parts = key.split(".");
      let pre = res;
      let len = parts.length;
      for (let i = 0; i < len; i++) {
        let k = parts[i];
        if (i == len - 1) {
          pre[k] = obj[key];
        } else {
          pre[k] = pre[k] || {};
          pre = pre[k];
        }
      }
    }
  }
  return res;
}
function convertErrors(content, errors) {
  let items = [];
  let document2 = TextDocument2.create(documentUri, "json", 0, content);
  for (let err of errors) {
    const range = Range.create(document2.positionAt(err.offset), document2.positionAt(err.offset + err.length));
    items.push(Diagnostic.create(range, printParseErrorCode(err.error), DiagnosticSeverity.Error));
  }
  return items;
}
function toValuesTree(properties, conflictReporter, doExpand = false) {
  const root = /* @__PURE__ */ Object.create(null);
  for (const key in properties) {
    addToValueTree(root, key, properties[key], conflictReporter, doExpand);
  }
  return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter, doExpand = false) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    const s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "undefined":
        obj = curr[s] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        if (conflictReporter)
          conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object" && curr !== null) {
    if (doExpand) {
      curr[last] = expandObject(value);
    } else {
      curr[last] = value;
    }
  } else {
    if (conflictReporter)
      conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).includes(first)) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue2) {
  function accessSetting(config2, path3) {
    let current = config2;
    for (let i = 0; i < path3.length; i++) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[path3[i]];
    }
    return current;
  }
  const path2 = settingPath.split(".");
  const result = accessSetting(config, path2);
  return typeof result === "undefined" ? defaultValue2 : result;
}
function toJSONObject(obj) {
  if (obj) {
    if (Array.isArray(obj)) {
      return obj.map(toJSONObject);
    } else if (typeof obj === "object") {
      const res = /* @__PURE__ */ Object.create(null);
      for (const key in obj) {
        res[key] = toJSONObject(obj[key]);
      }
      return res;
    }
  }
  return obj;
}
function compareConfigurationContents(to, from) {
  const added = to ? from ? to.keys.filter((key) => from.keys.indexOf(key) === -1) : [...to.keys] : [];
  const removed = from ? to ? from.keys.filter((key) => to.keys.indexOf(key) === -1) : [...from.keys] : [];
  const updated = [];
  if (to && from) {
    for (const key of from.keys) {
      if (to.keys.indexOf(key) !== -1) {
        const value1 = getConfigurationValue(from.contents, key);
        const value2 = getConfigurationValue(to.contents, key);
        if (!equals(value1, value2)) {
          updated.push(key);
        }
      }
    }
  }
  return { added, removed, updated };
}
function getDefaultValue(type) {
  const t = Array.isArray(type) ? type[0] : type;
  switch (t) {
    case "boolean":
      return false;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
function lookUp(tree, key) {
  if (key) {
    if (tree && hasOwnProperty(tree, key))
      return tree[key];
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
var documentUri, OVERRIDE_IDENTIFIER_PATTERN, OVERRIDE_IDENTIFIER_REGEX, OVERRIDE_PROPERTY_PATTERN, OVERRIDE_PROPERTY_REGEX;
var init_util2 = __esm({
  "src/configuration/util.ts"() {
    "use strict";
    init_main2();
    init_main3();
    init_main();
    init_esm();
    init_array();
    init_is();
    init_node();
    init_object();
    init_types();
    documentUri = "file:///1";
    OVERRIDE_IDENTIFIER_PATTERN = `\\[([^\\]]+)\\]`;
    OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, "g");
    OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;
    OVERRIDE_PROPERTY_REGEX = new RegExp(OVERRIDE_PROPERTY_PATTERN);
  }
});

// src/configuration/model.ts
var ConfigurationModel;
var init_model = __esm({
  "src/configuration/model.ts"() {
    "use strict";
    init_array();
    init_is();
    init_object();
    init_util2();
    ConfigurationModel = class {
      constructor(_contents = {}, _keys = [], _overrides = []) {
        this._contents = _contents;
        this._keys = _keys;
        this._overrides = _overrides;
        this.frozen = false;
        this.overrideConfigurations = /* @__PURE__ */ new Map();
      }
      get contents() {
        return this.checkAndFreeze(this._contents);
      }
      get overrides() {
        return this.checkAndFreeze(this._overrides);
      }
      get keys() {
        return this.checkAndFreeze(this._keys);
      }
      get isFrozen() {
        return this.frozen;
      }
      checkAndFreeze(data) {
        if (this.frozen && !Object.isFrozen(data)) {
          return deepFreeze(data);
        }
        return data;
      }
      isEmpty() {
        return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
      }
      clone() {
        return new ConfigurationModel(deepClone(this._contents), [...this.keys], deepClone(this.overrides));
      }
      toJSON() {
        return {
          contents: this.contents,
          overrides: this.overrides,
          keys: this.keys
        };
      }
      getValue(section2) {
        let res = section2 ? getConfigurationValue(this.contents, section2) : this.contents;
        return res;
      }
      getOverrideValue(section2, overrideIdentifier) {
        const overrideContents = this.getContentsForOverrideIdentifier(overrideIdentifier);
        return overrideContents ? section2 ? getConfigurationValue(overrideContents, section2) : overrideContents : void 0;
      }
      getKeysForOverrideIdentifier(identifier) {
        const keys = [];
        for (const override of this.overrides) {
          if (override.identifiers.includes(identifier)) {
            keys.push(...override.keys);
          }
        }
        return distinct(keys);
      }
      getAllOverrideIdentifiers() {
        const result = [];
        for (const override of this.overrides) {
          result.push(...override.identifiers);
        }
        return distinct(result);
      }
      override(identifier) {
        let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
        if (!overrideConfigurationModel) {
          overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);
          this.overrideConfigurations.set(identifier, overrideConfigurationModel);
        }
        return overrideConfigurationModel;
      }
      merge(...others) {
        const contents = deepClone(this._contents);
        const overrides = deepClone(this._overrides);
        const keys = [...this._keys];
        for (const other of others) {
          if (other.isEmpty()) {
            continue;
          }
          this.mergeContents(contents, other.contents);
          for (const otherOverride of other.overrides) {
            const [override] = overrides.filter((o) => equals(o.identifiers, otherOverride.identifiers));
            if (override) {
              this.mergeContents(override.contents, otherOverride.contents);
              override.keys.push(...otherOverride.keys);
              override.keys = distinct(override.keys);
            } else {
              overrides.push(deepClone(otherOverride));
            }
          }
          for (const key of other.keys) {
            if (keys.indexOf(key) === -1) {
              keys.push(key);
            }
          }
        }
        return new ConfigurationModel(contents, keys, overrides);
      }
      freeze() {
        this.frozen = true;
        return this;
      }
      mergeContents(source, target) {
        for (const key of Object.keys(target)) {
          if (key in source) {
            if (objectLiteral(source[key]) && objectLiteral(target[key])) {
              this.mergeContents(source[key], target[key]);
              continue;
            }
          }
          source[key] = deepClone(target[key]);
        }
      }
      setValue(key, value) {
        this.addKey(key);
        addToValueTree(this.contents, key, value, (e) => {
          console.error(e);
        });
      }
      removeValue(key) {
        if (this.removeKey(key)) {
          removeFromValueTree(this.contents, key);
        }
      }
      addKey(key) {
        let index = this.keys.length;
        for (let i = 0; i < index; i++) {
          if (key.indexOf(this.keys[i]) === 0) {
            index = i;
          }
        }
        this.keys.splice(index, 1, key);
      }
      removeKey(key) {
        const index = this.keys.indexOf(key);
        if (index !== -1) {
          this.keys.splice(index, 1);
          return true;
        }
        return false;
      }
      createOverrideConfigurationModel(identifier) {
        const overrideContents = this.getContentsForOverrideIdentifier(identifier);
        if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
          return this;
        }
        const contents = {};
        for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
          let contentsForKey = this.contents[key];
          const overrideContentsForKey = overrideContents[key];
          if (overrideContentsForKey) {
            if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
              contentsForKey = deepClone(contentsForKey);
              this.mergeContents(contentsForKey, overrideContentsForKey);
            } else {
              contentsForKey = overrideContentsForKey;
            }
          }
          contents[key] = contentsForKey;
        }
        return new ConfigurationModel(contents, this._keys, this.overrides);
      }
      getContentsForOverrideIdentifier(identifier) {
        let contentsForIdentifierOnly = null;
        let contents = null;
        const mergeContents = (contentsToMerge) => {
          if (contentsToMerge) {
            if (contents) {
              this.mergeContents(contents, contentsToMerge);
            } else {
              contents = deepClone(contentsToMerge);
            }
          }
        };
        for (const override of this.overrides) {
          if (equals(override.identifiers, [identifier])) {
            contentsForIdentifierOnly = override.contents;
          } else if (override.identifiers.includes(identifier)) {
            mergeContents(override.contents);
          }
        }
        mergeContents(contentsForIdentifierOnly);
        return contents;
      }
    };
  }
});

// src/configuration/configuration.ts
function compare(from, to) {
  const { added, removed, updated } = compareConfigurationContents(to, from);
  const overrides = [];
  const fromOverrideIdentifiers = (from == null ? void 0 : from.getAllOverrideIdentifiers()) ?? [];
  const toOverrideIdentifiers = (to == null ? void 0 : to.getAllOverrideIdentifiers()) ?? [];
  if (to) {
    const addedOverrideIdentifiers = toOverrideIdentifiers.filter((key) => !fromOverrideIdentifiers.includes(key));
    for (const identifier of addedOverrideIdentifiers) {
      overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);
    }
  }
  if (from) {
    const removedOverrideIdentifiers = fromOverrideIdentifiers.filter((key) => !toOverrideIdentifiers.includes(key));
    for (const identifier of removedOverrideIdentifiers) {
      overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);
    }
  }
  if (to && from) {
    for (const identifier of fromOverrideIdentifiers) {
      if (toOverrideIdentifiers.includes(identifier)) {
        const result = compareConfigurationContents({ contents: from.getOverrideValue(void 0, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(void 0, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });
        overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);
      }
    }
  }
  return { added, removed, updated, overrides };
}
var FolderConfigutions, Configuration;
var init_configuration = __esm({
  "src/configuration/configuration.ts"() {
    "use strict";
    init_esm();
    init_types();
    init_array();
    init_fs();
    init_object();
    init_model();
    init_util2();
    FolderConfigutions = class {
      constructor() {
        this._folderConfigurations = /* @__PURE__ */ new Map();
      }
      get keys() {
        return this._folderConfigurations.keys();
      }
      has(folder) {
        for (let key of this.keys) {
          if (sameFile(folder, key))
            return true;
        }
        return false;
      }
      set(folder, model) {
        let key = normalizeFilePath(folder);
        this._folderConfigurations.set(key, model);
      }
      get(folder) {
        let key = normalizeFilePath(folder);
        return this._folderConfigurations.get(key);
      }
      delete(folder) {
        let key = normalizeFilePath(folder);
        this._folderConfigurations.delete(key);
      }
      forEach(fn) {
        this._folderConfigurations.forEach(fn);
      }
      getConfigurationByResource(uri) {
        let u = URI.parse(uri);
        if (u.scheme !== "file")
          return void 0;
        let folders = Array.from(this._folderConfigurations.keys());
        folders.sort((a, b) => b.length - a.length);
        let fullpath = u.fsPath;
        for (let folder of folders) {
          if (isParentFolder(folder, fullpath, true)) {
            return { folder, model: this._folderConfigurations.get(folder) };
          }
        }
        return void 0;
      }
    };
    Configuration = class {
      constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new FolderConfigutions(), _memoryConfiguration = new ConfigurationModel()) {
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._folderConfigurations = _folderConfigurations;
        this._memoryConfiguration = _memoryConfiguration;
        this._workspaceConsolidatedConfiguration = null;
        this._resolvedFolderConfigurations = /* @__PURE__ */ new Map();
        this._memoryConfigurationByResource = /* @__PURE__ */ new Map();
      }
      updateValue(key, value, overrides = {}) {
        let memoryConfiguration;
        if (overrides.resource) {
          memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
          if (!memoryConfiguration) {
            memoryConfiguration = new ConfigurationModel();
            this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
          }
        } else {
          memoryConfiguration = this._memoryConfiguration;
        }
        if (value === void 0) {
          memoryConfiguration.removeValue(key);
        } else {
          memoryConfiguration.setValue(key, value);
        }
        if (!overrides.resource) {
          this._workspaceConsolidatedConfiguration = null;
        }
      }
      hasFolder(folder) {
        return this._folderConfigurations.has(folder);
      }
      addFolderConfiguration(folder, model, resource) {
        this._folderConfigurations.set(folder, model);
        if (resource) {
          this._resolvedFolderConfigurations.set(resource, folder);
        }
      }
      deleteFolderConfiguration(fsPath2) {
        this._folderConfigurations.delete(fsPath2);
      }
      getWorkspaceConsolidateConfiguration() {
        if (!this._workspaceConsolidatedConfiguration) {
          this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
          this._workspaceConsolidatedConfiguration = this._workspaceConsolidatedConfiguration.freeze();
        }
        return this._workspaceConsolidatedConfiguration;
      }
      getFolderConfigurationModelForResource(uri) {
        let folder = this._resolvedFolderConfigurations.get(uri);
        if (folder)
          return this._folderConfigurations.get(folder);
        let conf = this._folderConfigurations.getConfigurationByResource(uri);
        if (!conf)
          return void 0;
        this._resolvedFolderConfigurations.set(uri, conf.folder);
        return conf.model;
      }
      resolveFolder(uri) {
        let folder = this._resolvedFolderConfigurations.get(uri);
        if (folder)
          return folder;
        let folders = Array.from(this._folderConfigurations.keys);
        folders.sort((a, b) => b.length - a.length);
        for (let folder2 of folders) {
          if (isParentFolder(folder2, URI.parse(uri).fsPath, true)) {
            this._resolvedFolderConfigurations.set(uri, folder2);
            return folder2;
          }
        }
        return void 0;
      }
      getConsolidatedConfigurationModel(overrides) {
        let configuration2 = this.getWorkspaceConsolidateConfiguration();
        if (overrides.resource) {
          let folderConfiguration = this.getFolderConfigurationModelForResource(overrides.resource);
          if (folderConfiguration) {
            configuration2 = configuration2.merge(folderConfiguration);
          }
          const memoryConfigurationForResource = this._memoryConfigurationByResource.get(overrides.resource);
          if (memoryConfigurationForResource) {
            configuration2 = configuration2.merge(memoryConfigurationForResource);
          }
        }
        if (overrides.overrideIdentifier) {
          configuration2 = configuration2.override(overrides.overrideIdentifier);
        }
        return configuration2;
      }
      getValue(section2, overrides) {
        let configuration2 = this.getConsolidatedConfigurationModel(overrides);
        return configuration2.getValue(section2);
      }
      inspect(key, overrides) {
        const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(overrides);
        const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource);
        const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
        const defaultValue2 = overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key);
        const userValue = overrides.overrideIdentifier ? this._userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._userConfiguration.freeze().getValue(key);
        const workspaceValue = overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key);
        const workspaceFolderValue = folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : void 0;
        const memoryValue = overrides.overrideIdentifier ? memoryConfigurationModel.override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.getValue(key);
        const value = consolidateConfigurationModel.getValue(key);
        const overrideIdentifiers = distinct(consolidateConfigurationModel.overrides.map((override) => override.identifiers).flat()).filter((overrideIdentifier) => consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== void 0);
        return {
          defaultValue: defaultValue2,
          userValue,
          workspaceValue,
          workspaceFolderValue,
          memoryValue,
          value,
          default: defaultValue2 !== void 0 ? { value: this._defaultConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          user: userValue !== void 0 ? { value: this._userConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._userConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          workspace: workspaceValue !== void 0 ? { value: this._workspaceConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          workspaceFolder: workspaceFolderValue !== void 0 ? { value: folderConfigurationModel == null ? void 0 : folderConfigurationModel.freeze().getValue(key), override: overrides.overrideIdentifier ? folderConfigurationModel == null ? void 0 : folderConfigurationModel.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          memory: memoryValue !== void 0 ? { value: memoryConfigurationModel.getValue(key), override: overrides.overrideIdentifier ? memoryConfigurationModel.getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          overrideIdentifiers: overrideIdentifiers.length ? overrideIdentifiers : void 0
        };
      }
      get defaults() {
        return this._defaultConfiguration;
      }
      get user() {
        return this._userConfiguration;
      }
      get workspace() {
        return this._workspaceConfiguration;
      }
      get memory() {
        return this._memoryConfiguration;
      }
      getConfigurationModel(target, folder) {
        switch (target) {
          case 0 /* Default */:
            return this._defaultConfiguration;
          case 1 /* User */:
            return this._userConfiguration;
          case 2 /* Workspace */:
            return this._workspaceConfiguration;
          case 3 /* WorkspaceFolder */:
            return this._folderConfigurations.get(folder) ?? new ConfigurationModel();
          default:
            return this._memoryConfiguration;
        }
      }
      updateFolderConfiguration(folder, model) {
        this._folderConfigurations.set(folder, model);
      }
      updateUserConfiguration(model) {
        this._userConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      updateWorkspaceConfiguration(model) {
        this._workspaceConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      updateDefaultConfiguration(model) {
        this._defaultConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      updateMemoryConfiguration(model) {
        this._memoryConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      compareAndUpdateMemoryConfiguration(memory) {
        const { added, updated, removed, overrides } = compare(this._memoryConfiguration, memory);
        const keys = [...added, ...updated, ...removed];
        if (keys.length) {
          this.updateMemoryConfiguration(memory);
        }
        return { keys, overrides };
      }
      compareAndUpdateUserConfiguration(user) {
        const { added, updated, removed, overrides } = compare(this._userConfiguration, user);
        const keys = [...added, ...updated, ...removed];
        if (keys.length) {
          this.updateUserConfiguration(user);
        }
        return { keys, overrides };
      }
      compareAndUpdateDefaultConfiguration(defaults3, keys) {
        const overrides = [];
        if (!keys) {
          const { added, updated, removed } = compare(this._defaultConfiguration, defaults3);
          keys = [...added, ...updated, ...removed];
        }
        for (const key of keys) {
          for (const overrideIdentifier of overrideIdentifiersFromKey(key)) {
            const fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);
            const toKeys = defaults3.getKeysForOverrideIdentifier(overrideIdentifier);
            const keys2 = [
              ...toKeys.filter((key2) => fromKeys.indexOf(key2) === -1),
              ...fromKeys.filter((key2) => toKeys.indexOf(key2) === -1),
              ...fromKeys.filter((key2) => !equals(this._defaultConfiguration.override(overrideIdentifier).getValue(key2), defaults3.override(overrideIdentifier).getValue(key2)))
            ];
            overrides.push([overrideIdentifier, keys2]);
          }
        }
        this.updateDefaultConfiguration(defaults3);
        return { keys, overrides };
      }
      compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {
        const { added, updated, removed, overrides } = compare(this._workspaceConfiguration, workspaceConfiguration);
        const keys = [...added, ...updated, ...removed];
        if (keys.length) {
          this.updateWorkspaceConfiguration(workspaceConfiguration);
        }
        return { keys, overrides };
      }
      compareAndUpdateFolderConfiguration(folder, folderConfiguration) {
        const currentFolderConfiguration = this._folderConfigurations.get(folder);
        const { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);
        const keys = [...added, ...updated, ...removed];
        if (keys.length || !currentFolderConfiguration) {
          this.updateFolderConfiguration(folder, folderConfiguration);
        }
        return { keys, overrides };
      }
      compareAndDeleteFolderConfiguration(folder) {
        const folderConfig = this._folderConfigurations.get(folder);
        if (!folderConfig)
          return;
        this.deleteFolderConfiguration(folder);
        const { added, updated, removed, overrides } = compare(folderConfig, void 0);
        return { keys: [...added, ...updated, ...removed], overrides };
      }
      allKeys() {
        const keys = /* @__PURE__ */ new Set();
        this._defaultConfiguration.freeze().keys.forEach((key) => keys.add(key));
        this._userConfiguration.freeze().keys.forEach((key) => keys.add(key));
        this._workspaceConfiguration.freeze().keys.forEach((key) => keys.add(key));
        this._folderConfigurations.forEach((folderConfiguration) => folderConfiguration.freeze().keys.forEach((key) => keys.add(key)));
        return [...keys.values()];
      }
      toData() {
        let { _defaultConfiguration, _userConfiguration, _workspaceConfiguration, _folderConfigurations } = this;
        let folders = [];
        _folderConfigurations.forEach((model, fsPath2) => {
          folders.push([fsPath2, model.toJSON()]);
        });
        return {
          defaults: _defaultConfiguration.toJSON(),
          user: _userConfiguration.toJSON(),
          workspace: _workspaceConfiguration.toJSON(),
          folders
        };
      }
      static parse(data) {
        const defaultConfiguration = this.parseConfigurationModel(data.defaults);
        const userConfiguration = this.parseConfigurationModel(data.user);
        const workspaceConfiguration = this.parseConfigurationModel(data.workspace);
        const folderConfigurations = new FolderConfigutions();
        data.folders.forEach((value) => {
          folderConfigurations.set(value[0], this.parseConfigurationModel(value[1]));
        });
        return new Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, folderConfigurations);
      }
      static parseConfigurationModel(model) {
        return new ConfigurationModel(model.contents, model.keys, model.overrides).freeze();
      }
    };
  }
});

// src/configuration/event.ts
var ConfigurationChangeEvent;
var init_event = __esm({
  "src/configuration/event.ts"() {
    "use strict";
    init_object();
    init_configuration();
    init_model();
    init_util2();
    ConfigurationChangeEvent = class {
      constructor(change, previous, currentConfiguration) {
        this.change = change;
        this.previous = previous;
        this.currentConfiguration = currentConfiguration;
        this._previousConfiguration = void 0;
        const keysSet = /* @__PURE__ */ new Set();
        change.keys.forEach((key) => keysSet.add(key));
        change.overrides.forEach(([, keys]) => keys.forEach((key) => keysSet.add(key)));
        this.affectedKeys = [...keysSet.values()];
        const configurationModel = new ConfigurationModel();
        this.affectedKeys.forEach((key) => configurationModel.setValue(key, {}));
        this.affectedKeysTree = configurationModel.contents;
      }
      get previousConfiguration() {
        if (!this._previousConfiguration && this.previous) {
          this._previousConfiguration = Configuration.parse(this.previous);
        }
        return this._previousConfiguration;
      }
      affectsConfiguration(section2, scope) {
        let overrides = scope ? scopeToOverrides(scope) : void 0;
        if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, section2)) {
          if (overrides) {
            const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section2, overrides) : void 0;
            const value2 = this.currentConfiguration.getValue(section2, overrides);
            return !equals(value1, value2);
          }
          return true;
        }
        return false;
      }
      doesAffectedKeysTreeContains(affectedKeysTree, section2) {
        let requestedTree = toValuesTree({ [section2]: true }, () => {
        });
        let key;
        while (typeof requestedTree === "object" && (key = Object.keys(requestedTree)[0])) {
          affectedKeysTree = affectedKeysTree[key];
          if (!affectedKeysTree) {
            return false;
          }
          requestedTree = requestedTree[key];
        }
        return true;
      }
    };
  }
});

// src/configuration/parser.ts
var logger7, ConfigurationModelParser;
var init_parser2 = __esm({
  "src/configuration/parser.ts"() {
    "use strict";
    init_main2();
    init_main();
    init_logger();
    init_model();
    init_util2();
    logger7 = createLogger("parser");
    ConfigurationModelParser = class {
      constructor(_name) {
        this._name = _name;
        this._raw = null;
        this._configurationModel = null;
        this._parseErrors = [];
      }
      get configurationModel() {
        return this._configurationModel || new ConfigurationModel();
      }
      get errors() {
        return this._parseErrors;
      }
      parse(content, options2) {
        if (content != null) {
          const raw = this.doParseContent(content);
          this.parseRaw(raw, options2);
        }
      }
      parseRaw(raw, options2) {
        this._raw = raw;
        const { contents, keys, overrides } = this.doParseRaw(raw, options2);
        this._configurationModel = new ConfigurationModel(contents, keys, overrides);
      }
      doParseContent(content) {
        let raw = {};
        let currentProperty = null;
        let currentParent = [];
        const previousParents = [];
        const _errors = [];
        function onValue(value) {
          if (Array.isArray(currentParent)) {
            currentParent.push(value);
          } else if (currentProperty !== null) {
            currentParent[currentProperty] = value;
          }
        }
        const visitor = {
          onObjectBegin: () => {
            const object = {};
            onValue(object);
            previousParents.push(currentParent);
            currentParent = object;
            currentProperty = null;
          },
          onObjectProperty: (name2) => {
            currentProperty = name2;
          },
          onObjectEnd: () => {
            currentParent = previousParents.pop();
          },
          onArrayBegin: () => {
            const array = [];
            onValue(array);
            previousParents.push(currentParent);
            currentParent = array;
            currentProperty = null;
          },
          onArrayEnd: () => {
            currentParent = previousParents.pop();
          },
          onLiteralValue: onValue,
          onError: (error, offset, length) => {
            _errors.push({ error, length, offset });
          }
        };
        if (content) {
          try {
            visit2(content, visitor, { allowTrailingComma: true, allowEmptyContent: true });
            raw = currentParent[0] ?? {};
            if (_errors.length > 0) {
              this._parseErrors = convertErrors(content, _errors);
            }
          } catch (e) {
            this._parseErrors = [{
              range: Range.create(0, 0, 0, 0),
              message: `Error on parse configuration file ${this._name}: ${e}`
            }];
          }
        }
        return raw;
      }
      doParseRaw(raw, _options) {
        const onError = (message) => {
          console.error(`Conflict in settings file ${this._name}: ${message}`);
        };
        const contents = toValuesTree(raw, onError, true);
        const keys = Object.keys(raw);
        const overrides = this.toOverrides(raw, onError);
        return { contents, keys, overrides, restricted: [] };
      }
      toOverrides(raw, conflictReporter) {
        const overrides = [];
        for (const key of Object.keys(raw)) {
          if (OVERRIDE_PROPERTY_REGEX.test(key)) {
            const overrideRaw = {};
            for (const keyInOverrideRaw in raw[key]) {
              overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
            }
            overrides.push({
              identifiers: overrideIdentifiersFromKey(key),
              keys: Object.keys(overrideRaw),
              contents: toValuesTree(overrideRaw, conflictReporter, true)
            });
          }
        }
        return overrides;
      }
    };
  }
});

// src/configuration/registry.ts
function validateProperty(property, _schema = void 0) {
  if (!property.trim()) {
    return "Cannot register an empty property";
  }
  if (OVERRIDE_PROPERTY_REGEX.test(property)) {
    return `Cannot register ${property}. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings`;
  }
  if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
    return `Cannot register '${property}'. This property is already registered.`;
  }
  return null;
}
var EXCLUDE_KEYS, Extensions3, allSettings, resourceSettings, resourceLanguageSettingsSchemaId, contributionRegistry, ConfigurationRegistry, configurationRegistry;
var init_registry2 = __esm({
  "src/configuration/registry.ts"() {
    "use strict";
    init_array();
    init_jsonRegistry();
    init_object();
    init_protocol();
    init_registry();
    init_types();
    init_util2();
    EXCLUDE_KEYS = ["log-path", "logPath"];
    Extensions3 = {
      Configuration: "base.contributions.configuration"
    };
    allSettings = { properties: {}, patternProperties: {} };
    resourceSettings = { properties: {}, patternProperties: {} };
    resourceLanguageSettingsSchemaId = "vscode://schemas/settings/resourceLanguage";
    contributionRegistry = Registry.as(Extensions2.JSONContribution);
    ConfigurationRegistry = class {
      constructor() {
        this._onDidSchemaChange = new import_node3.Emitter();
        this.onDidSchemaChange = this._onDidSchemaChange.event;
        this._onDidUpdateConfiguration = new import_node3.Emitter();
        this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
        this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: "Unknown coc.nvim configuration property", allowTrailingCommas: true, allowComments: true };
        this.configurationProperties = {};
        this.excludedConfigurationProperties = {};
        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
        this.registerOverridePropertyPatternKey();
      }
      registerConfiguration(configuration2, validate = true) {
        this.registerConfigurations([configuration2], validate);
      }
      registerConfigurations(configurations, validate = true) {
        const properties = this.doRegisterConfigurations(configurations, validate);
        contributionRegistry.notifySchemaChanged(resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
      }
      deregisterConfigurations(configurations) {
        const properties = this.doDeregisterConfigurations(configurations);
        contributionRegistry.notifySchemaChanged(resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
      }
      updateConfigurations({ add, remove: remove2 }) {
        const properties = [];
        properties.push(...this.doDeregisterConfigurations(remove2));
        properties.push(...this.doRegisterConfigurations(add, false));
        contributionRegistry.notifySchemaChanged(resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties: distinct(properties) });
      }
      doRegisterConfigurations(configurations, validate) {
        const properties = [];
        configurations.forEach((configuration2) => {
          properties.push(...this.validateAndRegisterProperties(configuration2, validate, configuration2.extensionInfo));
          this.registerJSONConfiguration(configuration2);
        });
        return properties;
      }
      doDeregisterConfigurations(configurations) {
        const properties = [];
        const deregisterConfiguration = (configuration2) => {
          for (const key in toObject(configuration2.properties)) {
            properties.push(key);
            delete this.configurationProperties[key];
            this.removeFromSchema(key, configuration2.properties[key]);
          }
        };
        for (const configuration2 of configurations) {
          deregisterConfiguration(configuration2);
        }
        return properties;
      }
      validateAndRegisterProperties(configuration2, validate, extensionInfo, scope = 1 /* APPLICATION */) {
        scope = configuration2.scope == null ? scope : configuration2.scope;
        const propertyKeys = [];
        const properties = configuration2.properties;
        for (const key in toObject(properties)) {
          const property = properties[key];
          if (validate && validateProperty(key, property)) {
            delete properties[key];
            continue;
          }
          property.source = extensionInfo;
          property.defaultDefaultValue = properties[key].default;
          this.updatePropertyDefaultValue(key, property);
          property.scope = property.scope == null ? scope : property.scope;
          if (extensionInfo)
            property.description = (property.description ? `${property.description}
` : "") + `From ${extensionInfo.id}`;
          if (property.hasOwnProperty("included") && !property.included) {
            this.excludedConfigurationProperties[key] = properties[key];
            delete properties[key];
            continue;
          } else {
            this.configurationProperties[key] = properties[key];
          }
          if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
            properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
          }
          propertyKeys.push(key);
        }
        return propertyKeys;
      }
      getConfigurationProperties() {
        return this.configurationProperties;
      }
      getExcludedConfigurationProperties() {
        return this.excludedConfigurationProperties;
      }
      registerJSONConfiguration(configuration2) {
        const register4 = (configuration3) => {
          const properties = configuration3.properties;
          for (const key in toObject(properties)) {
            this.updateSchema(key, properties[key]);
          }
        };
        register4(configuration2);
      }
      updateSchema(key, property) {
        allSettings.properties[key] = property;
        switch (property.scope) {
          case 2 /* WINDOW */:
          case 3 /* RESOURCE */:
            resourceSettings.properties[key] = property;
            break;
          case 4 /* LANGUAGE_OVERRIDABLE */:
            resourceSettings.properties[key] = property;
            this.resourceLanguageSettingsSchema.properties[key] = property;
            break;
        }
      }
      removeFromSchema(key, property) {
        delete allSettings.properties[key];
        switch (property.scope) {
          case 2 /* WINDOW */:
          case 3 /* RESOURCE */:
          case 4 /* LANGUAGE_OVERRIDABLE */:
            delete resourceSettings.properties[key];
            delete this.resourceLanguageSettingsSchema.properties[key];
            break;
        }
      }
      registerOverridePropertyPatternKey() {
        const resourceLanguagePropertiesSchema = {
          type: "object",
          description: "Configure editor settings to be overridden for a language.",
          errorMessage: "This setting does not support per-language configuration.",
          $ref: resourceLanguageSettingsSchemaId
        };
        allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
      }
      updatePropertyDefaultValue(key, property) {
        let defaultValue2 = property.defaultDefaultValue;
        if (typeof defaultValue2 === "undefined" && !EXCLUDE_KEYS.some((k) => key.includes(k))) {
          defaultValue2 = getDefaultValue(property.type);
        }
        property.default = defaultValue2;
        property.defaultValueSource = void 0;
      }
    };
    configurationRegistry = new ConfigurationRegistry();
    Registry.add(Extensions3.Configuration, configurationRegistry);
  }
});

// src/configuration/index.ts
var import_schema, logger8, userSettingsSchemaId, folderSettingsSchemaId, jsonRegistry, configuration, Configurations;
var init_configuration2 = __esm({
  "src/configuration/index.ts"() {
    "use strict";
    init_esm();
    import_schema = __toESM(require_schema());
    init_logger();
    init_util();
    init_array();
    init_constants();
    init_extensionRegistry();
    init_fs();
    init_is();
    init_jsonRegistry();
    init_node();
    init_object();
    init_protocol();
    init_registry();
    init_configuration();
    init_event();
    init_model();
    init_parser2();
    init_registry2();
    init_types();
    init_util2();
    logger8 = createLogger("configurations");
    userSettingsSchemaId = "vscode://schemas/settings/user";
    folderSettingsSchemaId = "vscode://schemas/settings/folder";
    jsonRegistry = Registry.as(Extensions2.JSONContribution);
    configuration = Registry.as(Extensions3.Configuration);
    Configurations = class {
      constructor(userConfigFile2, _proxy, noWatch = false, cwd2 = process.cwd()) {
        this.userConfigFile = userConfigFile2;
        this._proxy = _proxy;
        this.noWatch = noWatch;
        this._watchedFiles = /* @__PURE__ */ new Set();
        this._errors = /* @__PURE__ */ new Map();
        this._onError = new import_node3.Emitter();
        this._onChange = new import_node3.Emitter();
        this.disposables = [];
        this._initialized = false;
        this.cached = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let defaultConfiguration = this.loadDefaultConfigurations();
        let userConfiguration = this.parseConfigurationModel(this.userConfigFile);
        this._configuration = new Configuration(defaultConfiguration, userConfiguration);
        this.watchFile(this.userConfigFile, 1 /* User */);
        let filepath = this.folderToConfigfile(cwd2);
        if (filepath)
          this.addFolderFile(filepath, true);
        this._initialConfiguration = this.getConfiguration(void 0, null);
      }
      get initialConfiguration() {
        return this._initialConfiguration;
      }
      get markdownPreference() {
        let preferences = this._initialConfiguration.get("coc.preferences");
        return {
          excludeImages: preferences.excludeImageLinksInMarkdownDocument,
          breaks: preferences.enableGFMBreaksInMarkdownDocument
        };
      }
      get errors() {
        return this._errors;
      }
      get configuration() {
        return this._configuration;
      }
      flushConfigurations() {
        this._initialized = true;
        configuration.registerConfigurations(this.cached);
        this.cached = [];
      }
      updateConfigurations(add, remove2) {
        if (this._initialized) {
          if (!isFalsyOrEmpty(remove2)) {
            configuration.updateConfigurations({ add, remove: remove2 });
          } else {
            configuration.registerConfigurations(add);
          }
        } else {
          this.cached.push(...add);
        }
      }
      loadDefaultConfigurations() {
        let node = { properties: convertProperties(import_schema.default.properties) };
        configuration.registerConfiguration(node);
        configuration.onDidUpdateConfiguration((e) => {
          if (e.properties.length === 0)
            return;
          const dict = configuration.getConfigurationProperties();
          const toRemove = [];
          const root = /* @__PURE__ */ Object.create(null);
          const keys2 = [];
          for (let key of e.properties) {
            let def = dict[key];
            if (def) {
              keys2.push(key);
              let val = def.default;
              addToValueTree(root, key, val, (msg) => {
                logger8.error(`Conflict configuration: ${msg}`);
              });
            } else {
              toRemove.push(key);
            }
          }
          const model2 = this._configuration.defaults.merge(new ConfigurationModel(root, keys2));
          toRemove.forEach((key) => {
            model2.removeValue(key);
          });
          if (!this._initialized) {
            this._configuration.updateDefaultConfiguration(model2);
            this._initialConfiguration = this.getConfiguration(void 0, null);
          } else {
            this.changeConfiguration(0 /* Default */, model2, void 0, e.properties);
          }
        }, null, this.disposables);
        let properties = configuration.getConfigurationProperties();
        let config = {};
        let keys = [];
        Object.keys(properties).forEach((key) => {
          let value = properties[key].default;
          keys.push(key);
          addToValueTree(config, key, value, void 0);
        });
        let model = new ConfigurationModel(config, keys);
        return model;
      }
      getDescription(key) {
        let property = allSettings.properties[key];
        return property ? property.description : void 0;
      }
      getJSONSchema(uri) {
        if (uri === userSettingsSchemaId) {
          return {
            properties: allSettings.properties,
            patternProperties: allSettings.patternProperties,
            definitions: Object.assign(getExtensionDefinitions(), import_schema.default.definitions),
            additionalProperties: false,
            allowTrailingCommas: true,
            allowComments: true
          };
        }
        if (uri === folderSettingsSchemaId) {
          return {
            properties: resourceSettings.properties,
            patternProperties: resourceSettings.patternProperties,
            definitions: Object.assign(getExtensionDefinitions(), import_schema.default.definitions),
            errorMessage: "Configuration property may not work as folder configuration",
            additionalProperties: false,
            allowTrailingCommas: true,
            allowComments: true
          };
        }
        let schemas = jsonRegistry.getSchemaContributions().schemas;
        if (hasOwnProperty(schemas, uri))
          return schemas[uri];
        return void 0;
      }
      parseConfigurationModel(filepath) {
        if (!filepath || !fs.existsSync(filepath))
          return new ConfigurationModel();
        let parser2 = new ConfigurationModelParser(filepath);
        let content = fs.readFileSync(filepath, "utf8");
        let uri = URI.file(filepath).toString();
        parser2.parse(content);
        if (!isFalsyOrEmpty(parser2.errors)) {
          this._errors.set(uri, parser2.errors);
          this._onError.fire({ uri, diagnostics: parser2.errors });
        } else {
          this._errors.delete(uri);
          this._onError.fire({ uri, diagnostics: [] });
        }
        return parser2.configurationModel;
      }
      folderToConfigfile(folder) {
        if (sameFile(folder, os.homedir()))
          return void 0;
        let filepath = path.join(folder, `.vim/${CONFIG_FILE_NAME}`);
        if (sameFile(filepath, this.userConfigFile))
          return void 0;
        return filepath;
      }
      updateMemoryConfig(props) {
        let keys = Object.keys(props);
        if (!props || keys.length == 0)
          return;
        let memoryModel = this._configuration.memory.clone();
        let properties = configuration.getConfigurationProperties();
        keys.forEach((key) => {
          let val = props[key];
          if (val === void 0) {
            memoryModel.removeValue(key);
          } else if (properties[key] != null) {
            memoryModel.setValue(key, val);
          } else if (objectLiteral(val)) {
            for (let k of Object.keys(val)) {
              memoryModel.setValue(`${key}.${k}`, val[k]);
            }
          } else {
            memoryModel.setValue(key, val);
          }
        });
        this.changeConfiguration(4 /* Memory */, memoryModel, void 0, keys);
      }
      addFolderFile(configFilePath, fromCwd = false, resource) {
        let folder = normalizeFilePath(path.resolve(configFilePath, "../.."));
        if (this._configuration.hasFolder(folder) || !fs.existsSync(configFilePath))
          return false;
        this.watchFile(configFilePath, 3 /* WorkspaceFolder */);
        let model = this.parseConfigurationModel(configFilePath);
        this._configuration.addFolderConfiguration(folder, model, resource);
        logger8.info(`Add folder configuration from ${fromCwd ? "cwd" : "file"}:`, configFilePath);
        return true;
      }
      watchFile(filepath, target) {
        if (!fs.existsSync(filepath) || this._watchedFiles.has(filepath) || this.noWatch)
          return;
        this._watchedFiles.add(filepath);
        const folder = 3 /* WorkspaceFolder */ ? normalizeFilePath(path.resolve(filepath, "../..")) : void 0;
        let disposable = watchFile(filepath, () => {
          let model = this.parseConfigurationModel(filepath);
          this.changeConfiguration(target, model, folder);
        });
        this.disposables.push(disposable);
      }
      changeConfiguration(target, model, folder, keys) {
        const listOnly = target === 0 /* Default */ && keys && keys.every((key) => key.startsWith("list.source"));
        let configuration2 = this._configuration;
        let previous = listOnly ? void 0 : configuration2.toData();
        let change;
        if (target === 0 /* Default */) {
          change = configuration2.compareAndUpdateDefaultConfiguration(model, keys);
        } else if (target === 1 /* User */) {
          change = configuration2.compareAndUpdateUserConfiguration(model);
        } else if (target === 2 /* Workspace */) {
          change = configuration2.compareAndUpdateWorkspaceConfiguration(model);
        } else if (target === 3 /* WorkspaceFolder */) {
          change = configuration2.compareAndUpdateFolderConfiguration(folder, model);
        } else {
          change = configuration2.compareAndUpdateMemoryConfiguration(model);
        }
        if (!change || change.keys.length == 0)
          return;
        if (target !== 3 /* WorkspaceFolder */) {
          this._initialConfiguration = this.getConfiguration(void 0, null);
        }
        if (listOnly)
          return;
        let ev = new ConfigurationChangeEvent(change, previous, configuration2);
        ev.source = target;
        this._onChange.fire(ev);
      }
      getDefaultResource() {
        var _a2;
        let root = (_a2 = this._proxy) == null ? void 0 : _a2.root;
        if (!root)
          return void 0;
        return URI.file(root).toString();
      }
      getConfiguration(section2, scope) {
        let configuration2 = this._configuration;
        let overrides = scope ? scopeToOverrides(scope) : { resource: scope === null ? void 0 : this.getDefaultResource() };
        const config = Object.freeze(lookUp(configuration2.getValue(void 0, overrides), section2));
        const result = {
          has(key) {
            return typeof lookUp(config, key) !== "undefined";
          },
          get: (key, defaultValue2) => {
            let result2 = lookUp(config, key);
            if (result2 == null)
              return defaultValue2;
            return result2;
          },
          update: (key, value, updateTarget = false) => {
            var _a2;
            const resource = overrides.resource;
            let entry = section2 ? `${section2}.${key}` : key;
            let target;
            if (typeof updateTarget === "boolean") {
              target = updateTarget ? 1 /* User */ : 3 /* WorkspaceFolder */;
            } else {
              target = convertTarget(updateTarget);
            }
            let folder;
            if (target === 3 /* WorkspaceFolder */) {
              folder = this._configuration.resolveFolder(resource) ?? this.resolveWorkspaceFolderForResource(resource);
              if (!folder) {
                console.error(`Unable to locate workspace folder configuration for ${resource}`);
                logger8.error(`Unable to locate workspace folder configuration`, resource, Error().stack);
                return;
              }
            }
            let model = this._configuration.getConfigurationModel(target, folder).clone();
            if (value === void 0) {
              model.removeValue(entry);
            } else {
              model.setValue(entry, value);
            }
            this.changeConfiguration(target, model, folder);
            let fsPath2;
            if (target === 3 /* WorkspaceFolder */) {
              fsPath2 = this.folderToConfigfile(folder);
            } else if (target === 1 /* User */) {
              fsPath2 = this.userConfigFile;
            }
            return fsPath2 ? (_a2 = this._proxy) == null ? void 0 : _a2.modifyConfiguration(fsPath2, entry, value) : Promise.resolve();
          },
          inspect: (key) => {
            key = section2 ? `${section2}.${key}` : key;
            const config2 = this._configuration.inspect(key, overrides);
            return {
              key,
              defaultValue: config2.defaultValue,
              globalValue: config2.userValue,
              workspaceValue: config2.workspaceValue,
              workspaceFolderValue: config2.workspaceFolderValue
            };
          }
        };
        Object.defineProperty(result, "has", {
          enumerable: false
        });
        Object.defineProperty(result, "get", {
          enumerable: false
        });
        Object.defineProperty(result, "update", {
          enumerable: false
        });
        Object.defineProperty(result, "inspect", {
          enumerable: false
        });
        if (typeof config === "object") {
          mixin(result, config, false);
        }
        return deepFreeze(result);
      }
      locateFolderConfigution(uri) {
        let folder = this._configuration.resolveFolder(uri);
        if (folder)
          return true;
        let u = URI.parse(uri);
        if (u.scheme !== "file")
          return false;
        let dir = folder = findUp(".vim", u.fsPath);
        if (!dir)
          return false;
        folder = path.dirname(dir);
        let filepath = this.folderToConfigfile(folder);
        if (filepath) {
          this.addFolderFile(filepath, false, uri);
          return true;
        }
        return false;
      }
      resolveWorkspaceFolderForResource(resource) {
        if (this._proxy && typeof this._proxy.getWorkspaceFolder === "function") {
          let uri = this._proxy.getWorkspaceFolder(resource);
          if (!uri)
            return void 0;
          let fsPath2 = uri.fsPath;
          let configFilePath = this.folderToConfigfile(fsPath2);
          if (configFilePath) {
            if (!fs.existsSync(configFilePath)) {
              fs.mkdirSync(path.dirname(configFilePath), { recursive: true });
              fs.writeFileSync(configFilePath, "{}", "utf8");
            }
            this.addFolderFile(configFilePath, false, resource);
            return fsPath2;
          }
        }
        return void 0;
      }
      reset() {
        this._errors.clear();
        let model = new ConfigurationModel();
        this.changeConfiguration(4 /* Memory */, model, void 0);
      }
      dispose() {
        this._onError.dispose();
        this._onChange.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/configuration/shape.ts
var logger9, ConfigurationProxy;
var init_shape = __esm({
  "src/configuration/shape.ts"() {
    "use strict";
    init_main2();
    init_esm();
    init_logger();
    init_node();
    logger9 = createLogger("configuration-shape");
    ConfigurationProxy = class {
      constructor(resolver2, _test = false) {
        this.resolver = resolver2;
        this._test = _test;
      }
      get root() {
        return this.resolver.root;
      }
      async modifyConfiguration(fsPath2, key, value) {
        if (this._test)
          return;
        logger9.info(`modify configuration file: ${fsPath2}`, key, value);
        let dir = path.dirname(fsPath2);
        let formattingOptions = { tabSize: 2, insertSpaces: true };
        if (!fs.existsSync(dir))
          fs.mkdirSync(dir, { recursive: true });
        let content = fs.readFileSync(fsPath2, { encoding: "utf8", flag: "a+" });
        content = content || "{}";
        let edits = modify(content, [key], value, { formattingOptions });
        content = applyEdits(content, edits);
        fs.writeFileSync(fsPath2, content, { encoding: "utf8" });
      }
      getWorkspaceFolder(resource) {
        if (typeof this.resolver.getWorkspaceFolder === "function") {
          let workspaceFolder = this.resolver.getWorkspaceFolder(resource);
          if (workspaceFolder)
            return URI.parse(workspaceFolder.uri);
        }
        return void 0;
      }
    };
  }
});

// src/core/autocmds.ts
function createCommand(id, autocmd) {
  let args = isFalsyOrEmpty(autocmd.arglist) ? "" : ", " + autocmd.arglist.join(", ");
  let event = Array.isArray(autocmd.event) ? autocmd.event.join(",") : autocmd.event;
  let pattern = autocmd.pattern != null ? autocmd.pattern : "*";
  if (/\buser\b/i.test(event)) {
    pattern = "";
  }
  let method = autocmd.request ? "request" : "notify";
  return `autocmd! ${groupName} ${event} ${pattern} call coc#rpc#${method}('doAutocmd', [${id}${args}])`;
}
var autocmdMaxId, groupName, Autocmds;
var init_autocmds = __esm({
  "src/core/autocmds.ts"() {
    "use strict";
    init_util();
    init_array();
    init_protocol();
    autocmdMaxId = 0;
    groupName = "coc_dynamic_autocmd";
    Autocmds = class {
      constructor() {
        this.autocmds = /* @__PURE__ */ new Map();
        this.disposables = [];
      }
      attach(nvim, env) {
        this.nvim = nvim;
        this.env = env;
      }
      async doAutocmd(id, args) {
        let autocmd = this.autocmds.get(id);
        if (autocmd)
          await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));
      }
      registerAutocmd(autocmd) {
        autocmdMaxId += 1;
        let id = autocmdMaxId;
        this.autocmds.set(id, autocmd);
        this.nvim.command(createCommand(id, autocmd), true);
        return import_node3.Disposable.create(() => {
          this.autocmds.delete(id);
          this.resetDynamicAutocmd();
        });
      }
      resetDynamicAutocmd() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command(`autocmd! ${groupName}`, true);
        for (let [id, autocmd] of this.autocmds.entries()) {
          nvim.command(createCommand(id, autocmd), true);
        }
        nvim.resumeNotification(false, true);
      }
      dispose() {
        this.nvim.command(`autocmd! ${groupName}`, true);
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/contentProvider.ts
function getAutocmdCommand(scheme) {
  let rhs = `call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<afile>')]) | filetype detect`;
  return `autocmd! coc_dynamic_content BufReadCmd,FileReadCmd,SourceCmd ${scheme}:/* ${rhs}`;
}
var ContentProvider;
var init_contentProvider = __esm({
  "src/core/contentProvider.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_util();
    init_protocol();
    init_string();
    ContentProvider = class {
      constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.providers = /* @__PURE__ */ new Map();
        this._onDidProviderChange = new import_node3.Emitter();
        this.onDidProviderChange = this._onDidProviderChange.event;
      }
      attach(nvim) {
        this.nvim = nvim;
        events_default.on("BufReadCmd", this.onBufReadCmd, this, this.disposables);
      }
      get schemes() {
        return Array.from(this.providers.keys());
      }
      async onBufReadCmd(scheme, uri) {
        let provider = this.providers.get(scheme);
        if (!provider)
          return;
        let tokenSource = new import_node3.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(URI.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines(toText(content).split(/\r?\n/), {
          start: 0,
          end: -1,
          strictIndexing: false
        });
        process.nextTick(() => {
          void events_default.fire("BufCreate", [buf.id]);
        });
      }
      resetAutocmds() {
        let { nvim, schemes } = this;
        nvim.pauseNotification();
        nvim.command(`autocmd! coc_dynamic_content`, true);
        for (let scheme of schemes) {
          nvim.command(getAutocmdCommand(scheme), true);
        }
        nvim.resumeNotification(false, true);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        this.providers.set(scheme, provider);
        this._onDidProviderChange.fire();
        let disposables = [];
        if (provider.onDidChange) {
          provider.onDidChange(async (uri) => {
            let doc = this.documents.getDocument(uri.toString());
            if (!doc)
              return;
            let tokenSource = new import_node3.CancellationTokenSource();
            let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
            await doc.buffer.setLines(content.split(/\r?\n/), {
              start: 0,
              end: -1,
              strictIndexing: false
            });
          }, null, disposables);
        }
        this.nvim.command(getAutocmdCommand(scheme), true);
        return import_node3.Disposable.create(() => {
          this.providers.delete(scheme);
          disposeAll(disposables);
          this.resetAutocmds();
          this._onDidProviderChange.fire();
        });
      }
      dispose() {
        disposeAll(this.disposables);
        this._onDidProviderChange.dispose();
        this.providers.clear();
      }
    };
  }
});

// src/util/diff.ts
function diffLines(oldLines, newLines, startLine) {
  let endOffset = 0;
  let startOffset = 0;
  let parts = oldLines.slice(startLine + 1);
  for (let i = 0; i < Math.min(parts.length, newLines.length); i++) {
    if (parts[parts.length - 1 - i] == newLines[newLines.length - 1 - i]) {
      endOffset = endOffset + 1;
    } else {
      break;
    }
  }
  for (let i = 0; i <= Math.min(startLine, newLines.length - 1 - endOffset); i++) {
    if (oldLines[i] == newLines[i]) {
      startOffset = startOffset + 1;
    } else {
      break;
    }
  }
  let replacement = newLines.slice(startOffset, newLines.length - endOffset);
  let end = oldLines.length - endOffset;
  if (end > startOffset && replacement.length) {
    let offset = 0;
    for (let i = 0; i < Math.min(replacement.length, end - startOffset); i++) {
      if (replacement[i] == oldLines[startOffset + i]) {
        offset = offset + 1;
      } else {
        break;
      }
    }
    if (offset) {
      return {
        start: startOffset + offset,
        end,
        replacement: replacement.slice(offset)
      };
    }
  }
  return {
    start: startOffset,
    end,
    replacement
  };
}
function patchLine(from, to, fill = " ") {
  if (from == to)
    return to;
  let idx = to.indexOf(from);
  if (idx !== -1)
    return fill.repeat(idx) + from;
  let result = fastDiff(from, to);
  let str = "";
  for (let item of result) {
    if (item[0] == fastDiff.DELETE) {
      return to;
    } else if (item[0] == fastDiff.INSERT) {
      str = str + fill.repeat(byteLength(item[1]));
    } else {
      str = str + item[1];
    }
  }
  return str;
}
function getTextEdit(oldLines, newLines, cursor, insertMode) {
  let ol = oldLines.length;
  let nl = newLines.length;
  let n = cursor ? cursor.line : Math.min(ol, nl);
  let used = 0;
  for (let i = 0; i < n; i++) {
    if (newLines[i] === oldLines[i]) {
      used += 1;
    } else {
      break;
    }
  }
  if (ol == nl && used == ol)
    return void 0;
  let delta = nl - ol;
  let r = Math.min(ol - used, nl - used);
  let e = 0;
  for (let i = 0; i < r; i++) {
    if (newLines[nl - i - 1] === oldLines[ol - i - 1]) {
      e += 1;
    } else {
      break;
    }
  }
  let inserted = e == 0 ? newLines.slice(used) : newLines.slice(used, -e);
  if (delta == 0 && cursor && inserted.length == 1) {
    let newLine = newLines[used];
    let oldLine = oldLines[used];
    let nl2 = newLine.length;
    let ol2 = oldLine.length;
    if (nl2 === 0)
      return TextEdit.del(Range.create(used, 0, used, ol2));
    if (ol2 === 0)
      return TextEdit.insert(Position.create(used, 0), newLine);
    let character = Math.min(cursor.character, nl2);
    if (!insertMode && nl2 >= ol2 && character !== nl2) {
      character += 1;
    }
    let r2 = 0;
    for (let i = 0; i < nl2 - character; i++) {
      let idx = ol2 - 1 - i;
      if (idx === -1)
        break;
      if (newLine[nl2 - 1 - i] === oldLine[idx]) {
        r2 += 1;
      } else {
        break;
      }
    }
    let l = 0;
    for (let i = 0; i < Math.min(ol2 - r2, nl2 - r2); i++) {
      if (newLine[i] === oldLine[i]) {
        l += 1;
      } else {
        break;
      }
    }
    let newText = r2 === 0 ? newLine.slice(l) : newLine.slice(l, -r2);
    return TextEdit.replace(Range.create(used, l, used, ol2 - r2), newText);
  }
  let text = inserted.length > 0 ? inserted.join("\n") + "\n" : "";
  if (text.length === 0 && used === ol - e)
    return void 0;
  return TextEdit.replace(Range.create(used, 0, ol - e, 0), text);
}
var init_diff = __esm({
  "src/util/diff.ts"() {
    "use strict";
    init_main();
    init_node();
    init_string();
  }
});

// src/util/position.ts
function rangeInRange(r, range) {
  return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;
}
function equalsRange(r, range) {
  if (!samePosition(r.start, range.start))
    return false;
  return samePosition(r.end, range.end);
}
function samePosition(one, two) {
  return one.line === two.line && one.character === two.character;
}
function compareRangesUsingStarts(a, b) {
  const aStartLineNumber = a.start.line | 0;
  const bStartLineNumber = b.start.line | 0;
  if (aStartLineNumber === bStartLineNumber) {
    const aStartColumn = a.start.character | 0;
    const bStartColumn = b.start.character | 0;
    if (aStartColumn === bStartColumn) {
      const aEndLineNumber = a.end.line | 0;
      const bEndLineNumber = b.end.line | 0;
      if (aEndLineNumber === bEndLineNumber) {
        const aEndColumn = a.end.character | 0;
        const bEndColumn = b.end.character | 0;
        return aEndColumn - bEndColumn;
      }
      return aEndLineNumber - bEndLineNumber;
    }
    return aStartColumn - bStartColumn;
  }
  return aStartLineNumber - bStartLineNumber;
}
function toValidRange(range, max) {
  let { start, end } = range;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    let m = start;
    start = end;
    end = m;
  }
  start = Position.create(Math.max(0, start.line), Math.max(0, start.character));
  let endCharacter = Math.max(0, end.character);
  if (typeof max === "number" && endCharacter > max)
    endCharacter = max;
  end = Position.create(Math.max(0, end.line), endCharacter);
  return { start, end };
}
function rangeAdjacent(r, range) {
  if (comparePosition(r.end, range.start) == 0) {
    return true;
  }
  if (comparePosition(range.end, r.start) == 0) {
    return true;
  }
  return false;
}
function rangeOverlap(r, range) {
  let { start, end } = r;
  if (comparePosition(end, range.start) <= 0) {
    return false;
  }
  if (comparePosition(start, range.end) >= 0) {
    return false;
  }
  return true;
}
function rangeIntersect(r, range) {
  if (positionInRange(r.start, range) == 0) {
    return true;
  }
  if (positionInRange(r.end, range) == 0) {
    return true;
  }
  if (rangeInRange(range, r)) {
    return true;
  }
  return false;
}
function adjustRangePosition(range, position) {
  let { line, character } = position;
  let { start, end } = range;
  let endCharacter = end.line == start.line ? end.character + character : end.character;
  return Range.create(start.line + line, character + start.character, end.line + line, endCharacter);
}
function lineInRange(line, range) {
  let { start, end } = range;
  return line >= start.line && line <= end.line;
}
function emptyRange(range) {
  let { start, end } = range;
  return start.line == end.line && start.character == end.character;
}
function positionInRange(position, range) {
  let { start, end } = range;
  if (comparePosition(position, start) < 0)
    return -1;
  if (comparePosition(position, end) > 0)
    return 1;
  return 0;
}
function comparePosition(position, other) {
  if (position.line > other.line)
    return 1;
  if (other.line == position.line && position.character > other.character)
    return 1;
  if (other.line == position.line && position.character == other.character)
    return 0;
  return -1;
}
function isSingleLine(range) {
  return range.start.line == range.end.line;
}
function getEnd(start, content) {
  const lines = content.split(/\r?\n/);
  const len = lines.length;
  const lastLine = lines[len - 1];
  const end = len == 1 ? start.character + content.length : lastLine.length;
  return Position.create(start.line + len - 1, end);
}
var init_position = __esm({
  "src/util/position.ts"() {
    "use strict";
    init_main();
  }
});

// src/util/textedit.ts
function getStartLine(edit2) {
  let { start, end } = edit2.range;
  if (edit2.newText.endsWith("\n") && start.line == end.line && start.character == 0 && end.character == 0) {
    return start.line - 1;
  }
  return start.line;
}
function lineCountChange(edit2) {
  let { newText } = edit2;
  let range = getWellformedRange2(edit2.range);
  let n = range.end.line - range.start.line;
  return newText.split(/\r?\n/).length - n - 1;
}
function getWellformedRange2(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function mergeSort2(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort2(left, compare2);
  mergeSort2(right, compare2);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function mergeSortEdits(edits) {
  return mergeSort2(edits, (a, b) => {
    let diff = a.range.start.line - b.range.start.line;
    if (diff === 0) {
      return a.range.start.character - b.range.start.character;
    }
    return diff;
  });
}
function emptyWorkspaceEdit(edit2) {
  let { changes, documentChanges } = edit2;
  if (documentChanges && documentChanges.length)
    return false;
  if (changes && Object.keys(changes).length)
    return false;
  return true;
}
function getRangesFromEdit(uri, edit2) {
  let { changes, documentChanges } = edit2;
  if (changes) {
    let edits = changes[uri];
    return edits ? edits.map((e) => e.range) : void 0;
  } else if (Array.isArray(documentChanges)) {
    for (let c of documentChanges) {
      if (TextDocumentEdit.is(c) && c.textDocument.uri == uri) {
        return c.edits.map((e) => e.range);
      }
    }
  }
  return void 0;
}
function getConfirmAnnotations(changes, changeAnnotations) {
  let keys = [];
  const add = (key) => {
    var _a2;
    if (key && !keys.includes(key) && ((_a2 = changeAnnotations[key]) == null ? void 0 : _a2.needsConfirmation))
      keys.push(key);
  };
  for (let change of changes) {
    if (TextDocumentEdit.is(change)) {
      change.edits.forEach((edit2) => {
        add(edit2["annotationId"]);
      });
    } else {
      add(change.annotationId);
    }
  }
  return keys;
}
function isDeniedEdit(edit2, denied) {
  if (AnnotatedTextEdit.is(edit2) && denied.includes(edit2.annotationId))
    return true;
  return false;
}
function createFilteredChanges(documentChanges, denied) {
  let changes = [];
  documentChanges.forEach((change) => {
    if (TextDocumentEdit.is(change)) {
      let edits = change.edits.filter((edit2) => {
        return !isDeniedEdit(edit2, denied);
      });
      if (edits.length > 0) {
        changes.push({ textDocument: change.textDocument, edits });
      }
    } else if (!denied.includes(change.annotationId)) {
      changes.push(change);
    }
  });
  return changes;
}
function getAnnotationKey(change) {
  let key;
  if (TextDocumentEdit.is(change)) {
    if (AnnotatedTextEdit.is(change.edits[0])) {
      key = change.edits[0].annotationId;
    }
  } else {
    key = change.annotationId;
  }
  return key;
}
function toDocumentChanges(edit2) {
  if (edit2.documentChanges)
    return edit2.documentChanges;
  let changes = [];
  for (let [uri, edits] of Object.entries(toObject(edit2.changes))) {
    changes.push({ textDocument: { uri, version: null }, edits });
  }
  return changes;
}
function filterSortEdits(textDocument, edits) {
  let res = [];
  let end = textDocument.end;
  let checkEnd = end.line > 0 && end.character == 0;
  let prevDelete;
  for (let i = 0; i < edits.length; i++) {
    let edit2 = edits[i];
    let { newText, range } = edit2;
    let max = (textDocument.lines[range.end.line] ?? "").length;
    range = toValidRange(edit2.range, max);
    if (prevDelete) {
      if (samePosition(prevDelete, range.start) && emptyRange(range) && newText.length > 0) {
        let last = res[res.length - 1];
        last.newText = newText;
        prevDelete = void 0;
        continue;
      }
      prevDelete = void 0;
    }
    if (newText.includes("\r"))
      newText = newText.replace(/\r\n/g, "\n");
    let d = comparePosition(range.end, end);
    if (d > 0)
      range.end = { line: end.line, character: end.character };
    if (textDocument.getText(range) !== newText) {
      if (d === 0 && checkEnd && !emptyRange(range) && newText.endsWith("\n")) {
        newText = newText.slice(0, -1);
        let text = textDocument.lines[end.line - 1];
        range.end = Position.create(end.line - 1, text.length);
      } else if (newText.length == 0) {
        prevDelete = range.start;
      }
      res.push({ range, newText });
    }
  }
  return mergeSortEdits(res);
}
function applyEdits2(document2, edits) {
  if (isFalsyOrEmpty(edits))
    return void 0;
  if (edits.length == 1) {
    let { start, end } = edits[0].range;
    let { lines } = document2;
    let sl = lines[start.line] ?? "";
    let el = lines[end.line] ?? "";
    let content = sl.substring(0, start.character) + edits[0].newText + el.substring(end.character);
    if (end.line >= lines.length && document2.eol) {
      if (content == "")
        return [...lines.slice(0, start.line)];
      if (content.endsWith("\n"))
        content = content.slice(0, -1);
      return [...lines.slice(0, start.line), ...content.split("\n")];
    }
    return [...lines.slice(0, start.line), ...content.split("\n"), ...lines.slice(end.line + 1)];
  }
  let text = document2.getText();
  let lastModifiedOffset = 0;
  const spans = [];
  for (const e of edits) {
    let startOffset = document2.offsetAt(e.range.start);
    if (startOffset < lastModifiedOffset) {
      throw new Error("Overlapping edit");
    } else if (startOffset > lastModifiedOffset) {
      spans.push(text.substring(lastModifiedOffset, startOffset));
    }
    if (e.newText.length) {
      spans.push(e.newText);
    }
    lastModifiedOffset = document2.offsetAt(e.range.end);
  }
  spans.push(text.substring(lastModifiedOffset));
  let result = spans.join("");
  if (result === text)
    return void 0;
  return contentToLines(result, document2.eol);
}
function toTextChanges(lines, edits) {
  return edits.map((o) => {
    let { start, end } = o.range;
    let sl = toText(lines[start.line]);
    let sc = byteIndex(sl, start.character);
    let el = end.line == start.line ? sl : toText(lines[end.line]);
    let ec = byteIndex(el, end.character);
    let { newText } = o;
    return [newText.length > 0 ? newText.split("\n") : [], start.line, sc, end.line, ec];
  });
}
function getChangedPosition(start, edit2) {
  let { range, newText } = edit2;
  if (comparePosition(range.end, start) <= 0) {
    let lines = newText.split("\n");
    let lineCount = lines.length - (range.end.line - range.start.line) - 1;
    let character = start.character;
    if (range.end.line == start.line) {
      let last = lines[lines.length - 1].length;
      if (lines.length > 1) {
        character = last + character - range.end.character;
      } else {
        character = range.start.character + last + character - range.end.character;
      }
    }
    return { line: lineCount, character: character - start.character };
  }
  return { line: 0, character: 0 };
}
function getPosition(start, edit2) {
  let { line, character } = start;
  let { range, newText } = edit2;
  let { end } = range;
  let lines = newText.split("\n");
  let lineCount = lines.length - (end.line - range.start.line) - 1;
  let c = range.end.line - start.line;
  if (c > 0)
    return { line, character };
  if (c < 0)
    return { line: line + lineCount, character };
  if (lines.length > 1) {
    let last = lines[lines.length - 1].length;
    return { line: line + lineCount, character: last + character - end.character };
  }
  let d = range.start.character - range.end.character;
  return { line: line + lineCount, character: d + newText.length + character };
}
function getPositionFromEdits(start, edits) {
  let position = Position.create(start.line, start.character);
  let before = false;
  for (let i = edits.length - 1; i >= 0; i--) {
    let edit2 = edits[i];
    if (before) {
      position.line += lineCountChange(edit2);
      continue;
    }
    let d = comparePosition(edit2.range.end, position);
    if (d > 0)
      continue;
    if (edit2.range.end.line == position.line) {
      position = getPosition(position, edit2);
    } else {
      before = true;
      position.line += lineCountChange(edit2);
    }
  }
  return position;
}
function getChangedLineCount(start, edits) {
  let total = 0;
  for (let edit2 of edits) {
    let r = getWellformedRange2(edit2.range);
    if (comparePosition(r.end, start) <= 0) {
      total += lineCountChange(edit2);
    }
  }
  return total;
}
function mergeTextEdits(edits, oldLines, newLines) {
  let start = edits[0].range.start;
  let end = edits[edits.length - 1].range.end;
  let lr = oldLines.length - end.line;
  let cr = (oldLines[end.line] ?? "").length - end.character;
  let line = newLines.length - lr;
  let character = (newLines[line] ?? "").length - cr;
  let newText = getText(start, Position.create(line, character), newLines);
  return TextEdit.replace(Range.create(start, end), newText);
}
function getText(start, end, lines) {
  if (start.line === end.line) {
    return toText(lines[start.line]).slice(start.character, end.character);
  }
  let spans = [];
  for (let i = start.line; i <= end.line; i++) {
    let s = lines[i] ?? "";
    if (i === start.line) {
      spans.push(s.slice(start.character));
    } else if (i === end.line) {
      spans.push(s.slice(0, end.character));
    } else {
      spans.push(s);
    }
  }
  return spans.join("\n");
}
var init_textedit = __esm({
  "src/util/textedit.ts"() {
    "use strict";
    init_main();
    init_array();
    init_object();
    init_position();
    init_string();
  }
});

// src/model/chars.ts
function getCharCode(str) {
  if (/^\d+$/.test(str))
    return parseInt(str, 10);
  if (str.length > 0)
    return str.charCodeAt(0);
  return void 0;
}
function sameScope(a, b) {
  if (a < boundary)
    return b < boundary;
  return b >= boundary;
}
function* chineseSegments(text) {
  if (Intl === void 0 || typeof Intl["Segmenter"] !== "function") {
    yield text;
    return;
  }
  let res = [];
  let items = new Intl["Segmenter"]("cn", { granularity: "word" }).segment(text);
  for (let item of items) {
    if (item.isWordLike) {
      yield item.segment;
    }
  }
  return res;
}
function splitKeywordOption(iskeyword) {
  let res = [];
  let i = 0;
  let s = 0;
  let len = iskeyword.length;
  for (; i < len; i++) {
    let c = iskeyword[i];
    if (i + 1 == len && s != len) {
      res.push(iskeyword.slice(s, len));
      continue;
    }
    if (c == ",") {
      let d = i - s;
      if (d == 0)
        continue;
      if (d == 1) {
        let p = iskeyword[i - 1];
        if (p == "^" || p == ",") {
          res.push(p == "," ? "," : "^,");
          s = i + 1;
          if (p == "^" && iskeyword[i + 1] == ",") {
            i++;
            s++;
          }
          continue;
        }
      }
      res.push(iskeyword.slice(s, i));
      s = i + 1;
    }
  }
  return res;
}
var WORD_RANGES, MAX_CODE_UNIT, chineseRegex, boundary, IntegerRanges, Chars;
var init_chars = __esm({
  "src/model/chars.ts"() {
    "use strict";
    init_main();
    init_util();
    init_array();
    init_object();
    init_string();
    WORD_RANGES = [[257, 893], [895, 902], [904, 1369], [1376, 1416], [1418, 1469], [1471, 1471], [1473, 1474], [1476, 1522], [1525, 1547], [1549, 1562], [1564, 1566], [1568, 1641], [1646, 1747], [1749, 1791], [1806, 2403], [2406, 2415], [2417, 3571], [3573, 3662], [3664, 3673], [3676, 3843], [3859, 3897], [3902, 3972], [3974, 4169], [4176, 4346], [4348, 4960], [4969, 5740], [5743, 5759], [5761, 5786], [5789, 5866], [5870, 5940], [5943, 6099], [6109, 6143], [6155, 8191], [10240, 10495], [10649, 10711], [10716, 10747], [10750, 11775], [11904, 12287], [12321, 12335], [12337, 12348], [12350, 64829], [64832, 65071], [65132, 65279], [65296, 65305], [65313, 65338], [65345, 65370], [65382, 65535]];
    MAX_CODE_UNIT = 65535;
    chineseRegex = /[\u4e00-\u9fa5]/;
    boundary = 19968;
    IntegerRanges = class {
      constructor(ranges = [], wordChars = false) {
        this.ranges = ranges;
        this.wordChars = wordChars;
      }
      clone() {
        return new IntegerRanges(this.ranges.slice(), this.wordChars);
      }
      add(start, end) {
        let index = 0;
        let removeCount = 0;
        if (end != null && end < start) {
          let t = end;
          end = start;
          start = t;
        }
        end = end == null ? start : end;
        for (let r of this.ranges) {
          let [s, e] = r;
          if (e < start) {
            index++;
            continue;
          }
          if (s > end)
            break;
          removeCount++;
          if (s < start)
            start = s;
          if (e > end) {
            end = e;
            break;
          }
        }
        this.ranges.splice(index, removeCount, [start, end]);
      }
      exclude(start, end) {
        if (end != null && end < start) {
          let t = end;
          end = start;
          start = t;
        }
        end = end == null ? start : end;
        let index = 0;
        let removeCount = 0;
        let created = [];
        for (let r of this.ranges) {
          let [s, e] = r;
          if (e < start) {
            index++;
            continue;
          }
          if (s > end)
            break;
          removeCount++;
          if (s < start) {
            created.push([s, start - 1]);
          }
          if (e > end) {
            created.push([end + 1, e]);
            break;
          }
        }
        if (removeCount == 0 && created.length == 0)
          return;
        this.ranges.splice(index, removeCount, ...created);
      }
      flatten() {
        return this.ranges.reduce((p, c) => p.concat(c), []);
      }
      includes(n) {
        if (n > 256 && this.wordChars)
          return intable(n, WORD_RANGES);
        return intable(n, this.ranges);
      }
      static fromKeywordOption(iskeyword) {
        let range = new IntegerRanges();
        for (let part of splitKeywordOption(iskeyword)) {
          let exclude = part.length > 1 && part.startsWith("^");
          let method = exclude ? "exclude" : "add";
          if (exclude)
            part = part.slice(1);
          if (part === "@" && !exclude) {
            range.wordChars = true;
            range[method](65, 90);
            range[method](97, 122);
            range[method](192, 255);
          } else if (part == "@-@") {
            range[method]("@".charCodeAt(0));
          } else if (part.length == 1 || /^\d+$/.test(part)) {
            range[method](getCharCode(part));
          } else if (part.includes("-")) {
            let items = part.split("-", 2);
            let start = getCharCode(items[0]);
            let end = getCharCode(items[1]);
            if (start === void 0 || end === void 0)
              continue;
            range[method](start, end);
          }
        }
        return range;
      }
    };
    Chars = class {
      constructor(keywordOption) {
        this.ranges = IntegerRanges.fromKeywordOption(keywordOption);
      }
      addKeyword(ch) {
        this.ranges.add(ch.codePointAt(0));
      }
      clone() {
        let chars = new Chars("");
        chars.ranges = this.ranges.clone();
        return chars;
      }
      isKeywordCode(code) {
        if (code === 32 || code > MAX_CODE_UNIT)
          return false;
        if (isHighSurrogate(code))
          return false;
        return this.ranges.includes(code);
      }
      isKeywordChar(ch) {
        let code = ch.charCodeAt(0);
        return this.isKeywordCode(code);
      }
      isKeyword(word) {
        for (let i = 0, l = word.length; i < l; i++) {
          if (!this.isKeywordChar(word[i]))
            return false;
        }
        return true;
      }
      *iterateWords(text) {
        let start = -1;
        let prevCode;
        for (let i = 0, l = text.length; i < l; i++) {
          let code = text.charCodeAt(i);
          if (this.isKeywordCode(code)) {
            if (start == -1) {
              start = i;
            } else if (prevCode !== void 0 && !sameScope(prevCode, code)) {
              yield [start, i];
              start = i;
            }
          } else {
            if (start != -1) {
              yield [start, i];
              start = -1;
            }
          }
          if (i === l - 1 && start != -1) {
            yield [start, i + 1];
          }
          prevCode = code;
        }
      }
      matchLine(line, min = 2, max = 1024) {
        let res = /* @__PURE__ */ new Set();
        let l = line.length;
        if (l > max) {
          line = line.slice(0, max);
          l = max;
        }
        for (let [start, end] of this.iterateWords(line)) {
          if (end - start < min)
            continue;
          let word = line.slice(start, end);
          if (chineseRegex.test(word[0])) {
            for (let text of chineseSegments(word)) {
              res.add(text);
            }
          } else {
            res.add(word);
          }
        }
        return Array.from(res);
      }
      async computeWordRanges(lines, range, token) {
        let s = range.start.line;
        let e = range.end.line;
        let res = {};
        let ts = Date.now();
        for (let i = s; i <= e; i++) {
          let text = lines[i];
          if (text === void 0)
            break;
          let sc = i === s ? range.start.character : 0;
          if (i === s)
            text = text.slice(sc);
          if (i === e)
            text = text.slice(0, range.end.character - sc);
          if (Date.now() - ts > 15) {
            if (token && token.isCancellationRequested)
              break;
            await waitImmediate();
            ts = Date.now();
          }
          for (let [start, end] of this.iterateWords(text)) {
            let word = text.slice(start, end);
            let arr = hasOwnProperty(res, word) ? res[word] : [];
            arr.push(Range.create(i, start + sc, i, end + sc));
            res[word] = arr;
          }
        }
        return res;
      }
    };
  }
});

// src/model/textline.ts
var TextLine;
var init_textline = __esm({
  "src/model/textline.ts"() {
    "use strict";
    init_main();
    TextLine = class {
      constructor(line, text, isLastLine) {
        this._line = line;
        this._text = text;
        this._isLastLine = isLastLine;
      }
      get lineNumber() {
        return this._line;
      }
      get text() {
        return this._text;
      }
      get range() {
        return Range.create(this._line, 0, this._line, this._text.length);
      }
      get rangeIncludingLineBreak() {
        return this._isLastLine ? this.range : Range.create(this._line, 0, this._line + 1, 0);
      }
      get firstNonWhitespaceCharacterIndex() {
        return /^(\s*)/.exec(this._text)[1].length;
      }
      get isEmptyOrWhitespace() {
        return this.firstNonWhitespaceCharacterIndex === this._text.length;
      }
    };
  }
});

// src/model/textdocument.ts
function computeLinesOffsets(lines, eol) {
  const result = [];
  let textOffset = 0;
  for (let line of lines) {
    result.push(textOffset);
    textOffset += line.length + 1;
  }
  if (eol)
    result.push(textOffset);
  return result;
}
var LinesTextDocument;
var init_textdocument = __esm({
  "src/model/textdocument.ts"() {
    "use strict";
    init_main();
    init_string();
    init_textline();
    LinesTextDocument = class {
      constructor(uri, languageId, version2, lines, bufnr, eol) {
        this.uri = uri;
        this.languageId = languageId;
        this.version = version2;
        this.lines = lines;
        this.bufnr = bufnr;
        this.eol = eol;
      }
      get content() {
        if (!this._content) {
          this._content = this.lines.join("\n") + (this.eol ? "\n" : "");
        }
        return this._content;
      }
      get length() {
        if (!this._content) {
          let n = this.lines.reduce((p, c) => {
            return p + c.length + 1;
          }, 0);
          return this.eol ? n : n - 1;
        }
        return this._content.length;
      }
      get end() {
        let line = this.lineCount - 1;
        if (this.eol)
          return Position.create(line, 0);
        return Position.create(line, this.lines[line].length);
      }
      get lineCount() {
        return this.lines.length + (this.eol ? 1 : 0);
      }
      getText(range) {
        if (range) {
          let { start, end } = range;
          if (start.line === end.line) {
            if (start.character === end.character)
              return "";
            let line = toText(this.lines[start.line]);
            return line.substring(start.character, end.character);
          }
          return this.content.substring(this.offsetAt(range.start), this.offsetAt(range.end));
        }
        return this.content;
      }
      lineAt(lineOrPos) {
        const line = Position.is(lineOrPos) ? lineOrPos.line : lineOrPos;
        if (typeof line !== "number" || line < 0 || line >= this.lineCount || Math.floor(line) !== line) {
          throw new Error("Illegal value for `line`");
        }
        return new TextLine(line, this.lines[line] ?? "", line === this.lineCount - 1);
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this.content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0;
        let high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this.content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this.content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLinesOffsets(this.lines, this.eol);
        }
        return this._lineOffsets;
      }
    };
  }
});

// src/model/document.ts
function fireDetach(bufnr) {
  void events_default.fire("BufDetach", [bufnr]);
}
function fireLinesChanged(bufnr) {
  void events_default.fire("LinesChanged", [bufnr]);
}
function getUri(fullpath, id, buftype, isCygwin) {
  if (!fullpath)
    return `untitled:${id}`;
  if (path.isAbsolute(fullpath))
    return URI.file(isCygwin ? fullpath : path.normalize(fullpath)).toString();
  if (isUrl(fullpath))
    return URI.parse(fullpath).toString();
  if (buftype != "")
    return `${buftype}:${id}`;
  return `unknown:${id}`;
}
function getNotAttachReason(buftype, enabled, size) {
  if (!["", "acwrite"].includes(buftype)) {
    return `not a normal buffer, buftype "${buftype}"`;
  }
  if (enabled === 0) {
    return `b:coc_enabled = 0`;
  }
  return `buffer size ${size} exceed coc.preferences.maxFileSize`;
}
var import_buffer, debounceTime2, Document;
var init_document = __esm({
  "src/model/document.ts"() {
    "use strict";
    import_buffer = require("buffer");
    init_main();
    init_esm();
    init_events();
    init_constants();
    init_diff();
    init_util();
    init_is();
    init_node();
    init_object();
    init_position();
    init_protocol();
    init_string();
    init_textedit();
    init_chars();
    init_textdocument();
    debounceTime2 = getConditionValue(150, 15);
    Document = class {
      constructor(buffer, env, nvim, opts) {
        this.buffer = buffer;
        this.env = env;
        this.nvim = nvim;
        this.isIgnored = false;
        this.eol = true;
        this._disposed = false;
        this._attached = false;
        this._notAttachReason = "";
        this._previewwindow = false;
        this._winid = -1;
        this.disposables = [];
        this.lines = [];
        this._onDocumentChange = new import_node3.Emitter();
        this.onDocumentChange = this._onDocumentChange.event;
        this.fireContentChanges = debounce(() => {
          this._fireContentChanges();
        }, debounceTime2);
        this.fetchContent = debounce(() => {
          void this._fetchContent();
        }, debounceTime2);
        this.init(opts);
      }
      get content() {
        return this.syncLines.join("\n") + (this.eol ? "\n" : "");
      }
      get attached() {
        return this._attached;
      }
      get textDocument() {
        return this._textDocument;
      }
      get syncLines() {
        return this._textDocument.lines;
      }
      get version() {
        return this._textDocument.version;
      }
      get bufnr() {
        return this.buffer.id;
      }
      get bufname() {
        return this._bufname;
      }
      get filetype() {
        return this._filetype;
      }
      get uri() {
        return this._uri;
      }
      get isCommandLine() {
        return this.uri && this.uri.endsWith("%5BCommand%20Line%5D");
      }
      get languageId() {
        let { _filetype } = this;
        return _filetype.includes(".") ? _filetype.match(/(.*?)\./)[1] : _filetype;
      }
      get changedtick() {
        return this._changedtick;
      }
      convertFiletype(filetype) {
        switch (filetype) {
          case "javascript.jsx":
            return "javascriptreact";
          case "typescript.jsx":
          case "typescript.tsx":
            return "typescriptreact";
          case "tex":
            return "latex";
          default: {
            let map = this.env.filetypeMap;
            return String(map[filetype] || filetype);
          }
        }
      }
      get schema() {
        return URI.parse(this.uri).scheme;
      }
      get lineCount() {
        return this.lines.length;
      }
      get winid() {
        return this._winid;
      }
      get previewwindow() {
        return this._previewwindow;
      }
      init(opts) {
        let buftype = this.buftype = opts.buftype;
        this._bufname = opts.bufname;
        this._previewwindow = !!opts.previewwindow;
        this._winid = opts.winid;
        this.variables = toObject(opts.variables);
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        this._uri = getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);
        if (Array.isArray(opts.lines)) {
          this.lines = opts.lines;
          this._noFetch = true;
          this._attached = true;
          this.attach();
        } else {
          this._notAttachReason = getNotAttachReason(buftype, this.variables[`coc_enabled`], opts.size);
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.setIskeyword(opts.iskeyword, opts.lisp);
        this.createTextDocument(1, this.lines);
      }
      get notAttachReason() {
        return this._notAttachReason;
      }
      attach() {
        if (isVim)
          return;
        let lines = this.lines;
        this.buffer.attach(true).then((res) => {
          if (!res)
            fireDetach(this.bufnr);
        }, (_e) => {
          fireDetach(this.bufnr);
        });
        this.buffer.listen("lines", (buf, tick, firstline, lastline, linedata) => {
          if (tick && tick > this._changedtick) {
            this._changedtick = tick;
            lines = [...lines.slice(0, firstline), ...linedata, ...lastline == -1 ? [] : lines.slice(lastline)];
            if (lines.length == 0)
              lines = [""];
            this.lines = lines;
            fireLinesChanged(buf.id);
            if (events_default.pumvisible)
              return;
            this.fireContentChanges();
          }
        }, this.disposables);
        this.buffer.listen("detach", () => {
          fireDetach(this.bufnr);
        }, this.disposables);
      }
      get dirty() {
        return this.lines !== this.syncLines;
      }
      get hasChanged() {
        if (!this.dirty)
          return false;
        return !equals(this.lines, this.syncLines);
      }
      _fireContentChanges(edit2) {
        if (this.lines === this.syncLines)
          return;
        let textDocument = this._textDocument;
        let changes = [];
        if (!edit2) {
          let { cursor } = events_default;
          let pos;
          if (cursor.bufnr == this.bufnr) {
            let content = this.lines[cursor.lnum - 1] ?? "";
            pos = Position.create(cursor.lnum - 1, characterIndex(content, cursor.col - 1));
          }
          edit2 = getTextEdit(textDocument.lines, this.lines, pos, cursor.insert);
        }
        let original;
        if (edit2) {
          original = textDocument.getText(edit2.range);
          changes.push({ range: edit2.range, text: edit2.newText, rangeLength: original.length });
        } else {
          original = "";
        }
        let created = this.createTextDocument(this.version + (edit2 ? 1 : 0), this.lines);
        this._onDocumentChange.fire(Object.freeze({
          bufnr: this.bufnr,
          original,
          originalLines: textDocument.lines,
          textDocument: { version: created.version, uri: this.uri },
          contentChanges: changes
        }));
      }
      async applyEdits(edits, joinUndo = false, move = false) {
        if (Array.isArray(arguments[1]))
          edits = arguments[1];
        if (!this._attached || edits.length === 0)
          return;
        this._forceSync();
        let textDocument = this.textDocument;
        edits = filterSortEdits(textDocument, edits);
        let newLines = applyEdits2(textDocument, edits);
        if (!newLines)
          return;
        let lines = textDocument.lines;
        let changed = diffLines(lines, newLines, getStartLine(edits[0]));
        let isAppend = changed.start === changed.end && changed.start === lines.length;
        let original = lines.slice(changed.start, changed.end);
        let changes = [];
        if (edits.length < 200 && changed.start !== changed.end && edits[edits.length - 1].range.end.line < lines.length) {
          changes = toTextChanges(lines, edits);
        }
        let cursor;
        let isCurrent = events_default.bufnr == this.bufnr;
        let col;
        if (move && isCurrent && !isAppend) {
          let pos = Position.is(move) ? move : void 0;
          if (!pos && this.bufnr === events_default.cursor.bufnr) {
            let { col: col2, lnum } = events_default.cursor;
            pos = Position.create(lnum - 1, characterIndex(this.lines[lnum - 1], col2 - 1));
          }
          if (pos) {
            let position = getPositionFromEdits(pos, edits);
            if (comparePosition(pos, position) !== 0) {
              let content = toText(newLines[position.line]);
              let col2 = byteIndex(content, position.character) + 1;
              cursor = [position.line + 1, col2];
            }
            col = byteIndex(this.lines[pos.line], pos.character) + 1;
          }
        }
        this.nvim.pauseNotification();
        if (isCurrent && joinUndo)
          this.nvim.command("undojoin", true);
        if (isAppend) {
          this.buffer.setLines(changed.replacement, { start: -1, end: -1 }, true);
        } else {
          this.nvim.call("coc#ui#set_lines", [
            this.bufnr,
            this._changedtick,
            original,
            changed.replacement,
            changed.start,
            changed.end,
            changes,
            cursor,
            col
          ], true);
        }
        this.nvim.resumeNotification(isCurrent, true);
        let textEdit = edits.length == 1 ? edits[0] : mergeTextEdits(edits, lines, newLines);
        await waitNextTick();
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this.fireContentChanges.clear();
        this._fireContentChanges(textEdit);
        let range = Range.create(changed.start, 0, changed.start + changed.replacement.length, 0);
        return TextEdit.replace(range, original.join("\n") + (original.length > 0 ? "\n" : ""));
      }
      async changeLines(lines) {
        let filtered = [];
        let newLines = this.lines.slice();
        for (let [lnum, text] of lines) {
          if (newLines[lnum] != text) {
            filtered.push([lnum, text]);
            newLines[lnum] = text;
          }
        }
        if (!filtered.length)
          return;
        this.nvim.call("coc#ui#change_lines", [this.bufnr, filtered], true);
        this.nvim.redrawVim();
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this._forceSync();
      }
      _forceSync() {
        this.fireContentChanges.clear();
        this._fireContentChanges();
      }
      forceSync() {
        if (false) {
          this._forceSync();
        }
      }
      getOffset(lnum, col) {
        return this.textDocument.offsetAt({
          line: lnum - 1,
          character: col
        });
      }
      isWord(word) {
        return this.chars.isKeyword(word);
      }
      getStartWord(text) {
        let i = 0;
        for (; i < text.length; i++) {
          if (!this.chars.isKeywordChar(text[i]))
            break;
        }
        return text.slice(0, i);
      }
      getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars;
        if (extraChars && extraChars.length) {
          chars = this.chars.clone();
          for (let ch2 of extraChars) {
            chars.addKeyword(ch2);
          }
        }
        let line = this.getline(position.line, current);
        let ch = line[position.character];
        if (ch == null || !chars.isKeywordChar(ch))
          return null;
        let start = position.character;
        let end = position.character + 1;
        while (start >= 0) {
          let ch2 = line[start - 1];
          if (!ch2 || !chars.isKeywordChar(ch2))
            break;
          start = start - 1;
        }
        while (end <= line.length) {
          let ch2 = line[end];
          if (!ch2 || !chars.isKeywordChar(ch2))
            break;
          end = end + 1;
        }
        return Range.create(position.line, start, position.line, end);
      }
      createTextDocument(version2, lines) {
        let { uri, languageId, eol } = this;
        let textDocument = this._textDocument = new LinesTextDocument(uri, languageId, version2, lines, this.bufnr, eol);
        return textDocument;
      }
      getSymbolRanges(word) {
        let { version: version2, filetype, uri } = this;
        let textDocument = new LinesTextDocument(uri, filetype, version2, this.lines, this.bufnr, this.eol);
        let res = [];
        let content = textDocument.getText();
        let str = "";
        for (let i = 0, l = content.length; i < l; i++) {
          let ch = content[i];
          if ("-" == ch && str.length == 0) {
            continue;
          }
          let isKeyword = this.chars.isKeywordChar(ch);
          if (isKeyword) {
            str = str + ch;
          }
          if (str.length > 0 && !isKeyword && str == word) {
            res.push(Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
          }
          if (!isKeyword) {
            str = "";
          }
        }
        return res;
      }
      fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line)
          return 0;
        let { character } = position;
        let start = line.slice(0, character);
        let col = byteLength(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          col = col - byteLength(c);
        }
        return col;
      }
      addHighlights(items, hlGroup, range, opts = {}) {
        let { start, end } = range;
        if (emptyRange(range))
          return;
        for (let line = start.line; line <= end.line; line++) {
          const text = this.getline(line, false);
          let colStart = line == start.line ? byteIndex(text, start.character) : 0;
          let colEnd = line == end.line ? byteIndex(text, end.character) : import_buffer.Buffer.byteLength(text);
          if (colStart >= colEnd)
            continue;
          items.push(Object.assign({ hlGroup, lnum: line, colStart, colEnd }, opts));
        }
      }
      getline(line, current = true) {
        if (current)
          return this.lines[line] || "";
        return this.syncLines[line] || "";
      }
      getLines(start, end) {
        return this.lines.slice(start ?? 0, end ?? this.lines.length);
      }
      getDocumentContent() {
        let content = this.lines.join("\n");
        return this.eol ? content + "\n" : content;
      }
      getVar(key, defaultValue2) {
        let val = this.variables[`coc_${key}`];
        return val === void 0 ? defaultValue2 : val;
      }
      getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0)
          return { line: lnum - 1, character: 0 };
        let pre = byteSlice(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
      }
      setFiletype(filetype) {
        this._filetype = this.convertFiletype(filetype);
        let lines = this._textDocument.lines;
        this._textDocument = new LinesTextDocument(this.uri, this.languageId, 1, lines, this.bufnr, this.eol);
      }
      setIskeyword(iskeyword, lisp) {
        let chars = this.chars = new Chars(iskeyword);
        let additional = this.getVar("additional_keywords", []);
        if (lisp)
          chars.addKeyword("-");
        if (additional && Array.isArray(additional)) {
          for (let ch of additional) {
            chars.addKeyword(ch);
          }
        }
      }
      detach() {
        disposeAll(this.disposables);
        if (this._disposed)
          return;
        this._disposed = true;
        this._attached = false;
        this.lines = [];
        this.fetchContent.clear();
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
      }
      async synchronize() {
        if (!this.attached)
          return;
        let { changedtick } = this;
        await this.patchChange();
        if (changedtick != this.changedtick) {
          await wait(50);
        }
      }
      async patchChange(currentLine) {
        if (!this._attached)
          return;
        if (isVim) {
          if (currentLine) {
            let change = await this.nvim.call("coc#util#get_changeinfo", [this.bufnr]);
            if (!change || change.changedtick < this._changedtick) {
              this._forceSync();
              return;
            }
            let { lnum, line, changedtick } = change;
            let curr = this.getline(lnum - 1);
            this._changedtick = changedtick;
            if (curr == line) {
              this._forceSync();
            } else {
              let newLines = this.lines.slice();
              newLines[lnum - 1] = line;
              this.lines = newLines;
              fireLinesChanged(this.bufnr);
              this._forceSync();
            }
          } else {
            this.fetchContent.clear();
            await this._fetchContent(true);
          }
        } else {
          this._changedtick = await this.buffer.getVar("changedtick");
          this._forceSync();
        }
      }
      onTextChange(event, change) {
        if (event === "TextChanged" || event === "TextChangedI" && !change.insertChar || !this._noFetch) {
          this._noFetch = false;
          this.fetchContent();
          return;
        }
        let { line, changedtick, lnum } = change;
        if (changedtick === this.changedtick)
          return;
        let newLines = this.lines.slice();
        newLines[lnum - 1] = line;
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this._changedtick = changedtick;
        if (event !== "TextChangedP")
          this._forceSync();
      }
      async _fetchContent(sync) {
        if (!isVim || !this._attached)
          return;
        let { nvim, bufnr, changedtick } = this;
        let o = await nvim.call("coc#util#get_buf_lines", [bufnr, changedtick]);
        this._noFetch = true;
        if (o) {
          this._changedtick = o.changedtick;
          this.lines = o.lines;
          fireLinesChanged(this.bufnr);
        }
        if (sync) {
          this._forceSync();
        } else {
          this.fireContentChanges();
        }
      }
    };
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format3;
    module2.exports.parse = parse3;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options2) {
      if (typeof value === "string") {
        return parse3(value);
      }
      if (typeof value === "number") {
        return format3(value, options2);
      }
      return null;
    }
    function format3(value, options2) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options2 && options2.thousandsSeparator || "";
      var unitSeparator = options2 && options2.unitSeparator || "";
      var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
      var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
      var unit = options2 && options2.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse3(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// src/core/documents.ts
var logger10, cwd, Documents;
var init_documents = __esm({
  "src/core/documents.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_logger();
    init_document();
    init_util();
    init_fs();
    init_node();
    init_platform();
    init_protocol();
    init_string();
    logger10 = createLogger("core-documents");
    cwd = normalizeFilePath(process.cwd());
    Documents = class {
      constructor(configurations, workspaceFolder) {
        this.configurations = configurations;
        this.workspaceFolder = workspaceFolder;
        this._attached = false;
        this._currentResolve = false;
        this.disposables = [];
        this.creating = /* @__PURE__ */ new Map();
        this.buffers = /* @__PURE__ */ new Map();
        this.resolves = [];
        this._onDidOpenTextDocument = new import_node3.Emitter();
        this._onDidCloseDocument = new import_node3.Emitter();
        this._onDidChangeDocument = new import_node3.Emitter();
        this._onDidSaveDocument = new import_node3.Emitter();
        this._onWillSaveDocument = new import_node3.Emitter();
        this.onDidOpenTextDocument = this._onDidOpenTextDocument.event;
        this.onDidCloseDocument = this._onDidCloseDocument.event;
        this.onDidChangeDocument = this._onDidChangeDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this._cwd = cwd;
        this.getConfiguration();
        this.configurations.onDidChange(this.getConfiguration, this, this.disposables);
      }
      async attach(nvim, env) {
        if (this._attached)
          return;
        this.nvim = nvim;
        this._env = env;
        this._attached = true;
        let { bufnrs, bufnr } = await this.nvim.call("coc#util#all_state");
        this._bufnr = bufnr;
        await Promise.all(bufnrs.map((bufnr2) => this.createDocument(bufnr2)));
        events_default.on("BufDetach", this.onBufDetach, this, this.disposables);
        events_default.on("BufRename", async (bufnr2) => {
          this.detachBuffer(bufnr2);
          await this.createDocument(bufnr2);
        }, null, this.disposables);
        events_default.on("DirChanged", (cwd2) => {
          this._cwd = normalizeFilePath(cwd2);
        }, null, this.disposables);
        const checkCurrentBuffer = (bufnr2) => {
          this._bufnr = bufnr2;
          void this.createDocument(bufnr2);
        };
        events_default.on("CursorMoved", checkCurrentBuffer, null, this.disposables);
        events_default.on("CursorMovedI", checkCurrentBuffer, null, this.disposables);
        events_default.on("BufUnload", this.onBufUnload, this, this.disposables);
        events_default.on("BufEnter", this.onBufEnter, this, this.disposables);
        events_default.on("BufCreate", this.onBufCreate, this, this.disposables);
        events_default.on("TermOpen", this.onBufCreate, this, this.disposables);
        events_default.on("BufWritePost", this.onBufWritePost, this, this.disposables);
        events_default.on("BufWritePre", this.onBufWritePre, this, this.disposables);
        events_default.on("FileType", this.onFileTypeChange, this, this.disposables);
        events_default.on("BufEnter", (bufnr2) => {
          void this.createDocument(bufnr2);
        }, null, this.disposables);
        if (this._env.isVim) {
          ["TextChangedP", "TextChangedI", "TextChanged"].forEach((event) => {
            events_default.on(event, (bufnr2, info) => {
              let doc = this.buffers.get(bufnr2);
              if (doc && doc.attached)
                doc.onTextChange(event, info);
            }, null, this.disposables);
          });
        }
      }
      getConfiguration(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let config = this.configurations.initialConfiguration.get("coc.preferences");
          const bytes2 = require_bytes();
          this.config = {
            maxFileSize: bytes2.parse(config.maxFileSize),
            willSaveHandlerTimeout: defaultValue(config.willSaveHandlerTimeout, 500),
            useQuickfixForLocations: config.useQuickfixForLocations
          };
        }
      }
      get bufnr() {
        return this._bufnr;
      }
      get root() {
        return this._root;
      }
      get cwd() {
        return this._cwd;
      }
      get documents() {
        return Array.from(this.buffers.values()).filter((o) => o.attached);
      }
      async getCurrentUri() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = this.getDocument(bufnr);
        return doc ? doc.uri : void 0;
      }
      *attached(schema) {
        for (let doc of this.buffers.values()) {
          if (!doc.attached)
            continue;
          if (schema && doc.schema !== schema)
            continue;
          yield doc;
        }
      }
      get bufnrs() {
        return this.buffers.keys();
      }
      detach() {
        this._attached = false;
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
      }
      resolveRoot(rootPatterns, requireRootPattern = false) {
        let doc = this.getDocument(this.bufnr);
        let resolved;
        if (doc && doc.schema == "file") {
          let dir = path.dirname(URI.parse(doc.uri).fsPath);
          resolved = resolveRoot(dir, rootPatterns, this.cwd);
        } else {
          resolved = resolveRoot(this.cwd, rootPatterns);
        }
        if (requireRootPattern && !resolved) {
          throw new Error(`Required root pattern not resolved.`);
        }
        return resolved;
      }
      get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
          if (b.attached)
            docs.push(b.textDocument);
        }
        return docs;
      }
      getDocument(uri) {
        if (typeof uri === "number") {
          return this.buffers.get(uri);
        }
        const caseInsensitive = isWindows || isMacintosh;
        let u = URI.parse(uri);
        uri = u.toString();
        let isFile2 = u.scheme === "file";
        for (let doc of this.buffers.values()) {
          if (doc.uri === uri)
            return doc;
          if (isFile2 && caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
            return doc;
        }
        return null;
      }
      expand(input) {
        if (input.startsWith("~")) {
          input = os.homedir() + input.slice(1);
        }
        if (input.includes("$")) {
          let doc = this.getDocument(this.bufnr);
          let fsPath2 = doc ? URI.parse(doc.uri).fsPath : "";
          const root = this._root || this._cwd;
          input = input.replace(/\$\{(.*?)\}/g, (match, name2) => {
            if (name2.startsWith("env:")) {
              let key = name2.split(":")[1];
              let val = key ? process.env[key] : "";
              return val;
            }
            switch (name2) {
              case "userHome":
                return os.homedir();
              case "workspace":
              case "workspaceRoot":
              case "workspaceFolder":
                return root;
              case "workspaceFolderBasename":
                return path.basename(root);
              case "cwd":
                return this._cwd;
              case "file":
                return fsPath2;
              case "fileDirname":
                return fsPath2 ? path.dirname(fsPath2) : "";
              case "fileExtname":
                return fsPath2 ? path.extname(fsPath2) : "";
              case "fileBasename":
                return fsPath2 ? path.basename(fsPath2) : "";
              case "fileBasenameNoExtension": {
                let base = fsPath2 ? path.basename(fsPath2) : "";
                return base ? base.slice(0, base.length - path.extname(base).length) : "";
              }
              default:
                return match;
            }
          });
          input = input.replace(/\$[\w]+/g, (match) => {
            if (match == "$HOME")
              return os.homedir();
            return process.env[match.slice(1)] || match;
          });
        }
        return input;
      }
      get document() {
        if (this._currentResolve) {
          return new Promise((resolve) => {
            this.resolves.push(resolve);
          });
        }
        this._currentResolve = true;
        return new Promise((resolve) => {
          this.nvim.eval(`coc#util#get_bufoptions(bufnr("%"),${this.config.maxFileSize})`).then((opts) => {
            let doc;
            if (opts != null) {
              this.creating.delete(opts.bufnr);
              doc = this._createDocument(opts);
            }
            this.resolveCurrent(doc);
            resolve(doc);
            this._currentResolve = false;
          }, () => {
            resolve(void 0);
            this._currentResolve = false;
          });
        });
      }
      resolveCurrent(document2) {
        if (this.resolves.length > 0) {
          while (this.resolves.length) {
            const fn = this.resolves.pop();
            if (fn)
              fn(document2);
          }
        }
      }
      get uri() {
        let { bufnr } = this;
        if (bufnr) {
          let doc = this.getDocument(bufnr);
          if (doc)
            return doc.uri;
        }
        return null;
      }
      get filetypes() {
        let res = /* @__PURE__ */ new Set();
        for (let doc of this.attached()) {
          res.add(doc.filetype);
        }
        return res;
      }
      getLanguageId(filepath) {
        let ext = path.extname(filepath);
        if (!ext)
          return "";
        for (let doc of this.attached()) {
          let fsPath2 = URI.parse(doc.uri).fsPath;
          if (path.extname(fsPath2) == ext) {
            return doc.languageId;
          }
        }
        return "";
      }
      async getLines(uri) {
        let doc = this.getDocument(uri);
        if (doc)
          return doc.textDocument.lines;
        let u = URI.parse(uri);
        if (u.scheme !== "file")
          return [];
        try {
          let content = await readFile(u.fsPath, "utf8");
          return content.split(/\r?\n/);
        } catch (e) {
          return [];
        }
      }
      get languageIds() {
        let res = /* @__PURE__ */ new Set();
        for (let doc of this.attached()) {
          res.add(doc.languageId);
        }
        return res;
      }
      async getFormatOptions(uri) {
        let doc;
        if (uri)
          doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : 0;
        let res = await this.nvim.call("coc#util#get_format_opts", [bufnr]);
        let obj = { tabSize: res.tabsize, insertSpaces: res.expandtab == 1 };
        obj.insertFinalNewline = res.insertFinalNewline == 1;
        if (res.trimTrailingWhitespace)
          obj.trimTrailingWhitespace = true;
        if (res.trimFinalNewlines)
          obj.trimFinalNewlines = true;
        return obj;
      }
      async createDocument(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (doc)
          return doc;
        if (this.creating.has(bufnr))
          return await this.creating.get(bufnr);
        let promise = new Promise((resolve) => {
          this.nvim.call("coc#util#get_bufoptions", [bufnr, this.config.maxFileSize]).then((opts) => {
            if (!this.creating.has(bufnr)) {
              resolve(void 0);
              return;
            }
            this.creating.delete(bufnr);
            if (!opts) {
              resolve(void 0);
              return;
            }
            doc = this._createDocument(opts);
            resolve(doc);
          }, () => {
            this.creating.delete(bufnr);
            resolve(void 0);
          });
        });
        this.creating.set(bufnr, promise);
        return await promise;
      }
      async onBufCreate(bufnr) {
        this.onBufUnload(bufnr);
        await this.createDocument(bufnr);
      }
      _createDocument(opts) {
        let { bufnr } = opts;
        if (this.buffers.has(bufnr))
          return this.buffers.get(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        let doc = new Document(buffer, this._env, this.nvim, opts);
        if (opts.size > this.config.maxFileSize)
          logger10.warn(`buffer ${opts.bufnr} size exceed maxFileSize ${this.config.maxFileSize}, not attached.`);
        this.buffers.set(bufnr, doc);
        if (doc.attached) {
          if (doc.schema == "file") {
            this.configurations.locateFolderConfigution(doc.uri);
            let root = this.workspaceFolder.resolveRoot(doc, this._cwd, true, this.expand.bind(this));
            if (root && bufnr == this._bufnr)
              this.changeRoot(root);
          }
          this._onDidOpenTextDocument.fire(doc.textDocument);
          doc.onDocumentChange((e) => this._onDidChangeDocument.fire(e));
        }
        logger10.debug("buffer created", bufnr, doc.attached, doc.uri);
        return doc;
      }
      onBufEnter(bufnr) {
        this._bufnr = bufnr;
        let doc = this.buffers.get(bufnr);
        if (doc) {
          let workspaceFolder = this.workspaceFolder.getWorkspaceFolder(URI.parse(doc.uri));
          if (workspaceFolder)
            this._root = URI.parse(workspaceFolder.uri).fsPath;
        }
      }
      onBufUnload(bufnr) {
        this.creating.delete(bufnr);
        void this.onBufDetach(bufnr, false);
      }
      async onBufDetach(bufnr, checkReload = true) {
        this.detachBuffer(bufnr);
        if (checkReload) {
          let loaded = await this.nvim.call("bufloaded", [bufnr]);
          if (loaded)
            await this.createDocument(bufnr);
        }
      }
      detachBuffer(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
          return;
        logger10.debug("document detach", bufnr, doc.uri);
        this._onDidCloseDocument.fire(doc.textDocument);
        this.buffers.delete(bufnr);
        doc.detach();
      }
      async onBufWritePost(bufnr, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (doc) {
          if (doc.changedtick != changedtick)
            await doc.patchChange();
          this._onDidSaveDocument.fire(doc.textDocument);
        }
      }
      async onBufWritePre(bufnr, bufname, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (!doc || !doc.attached)
          return;
        if (doc.bufname != bufname) {
          this.detachBuffer(bufnr);
          doc = await this.createDocument(bufnr);
          if (!doc.attached)
            return;
        }
        if (doc.changedtick != changedtick) {
          await doc.synchronize();
        } else {
          await doc.patchChange();
        }
        let firing = true;
        let thenables = [];
        let event = {
          document: doc.textDocument,
          reason: import_node3.TextDocumentSaveReason.Manual,
          waitUntil: (thenable) => {
            if (!firing) {
              this.nvim.echoError(`waitUntil can't be used in async manner, check log for details`);
            } else {
              thenables.push(thenable);
            }
          }
        };
        this._onWillSaveDocument.fire(event);
        firing = false;
        let total = thenables.length;
        if (total) {
          let promise = new Promise((resolve) => {
            const willSaveHandlerTimeout = this.config.willSaveHandlerTimeout;
            let timer = setTimeout(() => {
              this.nvim.outWriteLine(`Will save handler timeout after ${willSaveHandlerTimeout}ms`);
              resolve(void 0);
            }, willSaveHandlerTimeout);
            let i = 0;
            let called = false;
            for (let p of thenables) {
              let cb = (res) => {
                if (called)
                  return;
                called = true;
                clearTimeout(timer);
                resolve(res);
              };
              p.then((res) => {
                if (Array.isArray(res) && res.length && TextEdit.is(res[0])) {
                  return cb(res);
                }
                i = i + 1;
                if (i == total)
                  cb(void 0);
              }, (e) => {
                logger10.error(`Error on will save handler:`, e);
                i = i + 1;
                if (i == total)
                  cb(void 0);
              });
            }
          });
          let edits = await promise;
          if (edits)
            await doc.applyEdits(edits, false, this.bufnr === doc.bufnr);
        }
      }
      onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc)
          return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype)
          return;
        this._onDidCloseDocument.fire(doc.textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenTextDocument.fire(doc.textDocument);
      }
      async getQuickfixList(locations) {
        let filesLines = {};
        let filepathList = locations.reduce((pre, curr) => {
          let u = URI.parse(curr.uri);
          if (u.scheme == "file" && !pre.includes(u.fsPath) && !this.getDocument(curr.uri)) {
            pre.push(u.fsPath);
          }
          return pre;
        }, []);
        await Promise.all(filepathList.map((fsPath2) => {
          return new Promise((resolve) => {
            readFile(fsPath2, "utf8").then((content) => {
              filesLines[fsPath2] = content.split(/\r?\n/);
              resolve(void 0);
            }, () => {
              resolve();
            });
          });
        }));
        return await Promise.all(locations.map((loc) => {
          let { uri, range } = loc;
          let { fsPath: fsPath2 } = URI.parse(uri);
          let text;
          let lines = filesLines[fsPath2];
          if (lines)
            text = lines[range.start.line];
          return this.getQuickfixItem(loc, text);
        }));
      }
      async showLocations(locations) {
        let { nvim } = this;
        let items = await this.getQuickfixList(locations);
        if (this.config.useQuickfixForLocations) {
          let openCommand = await nvim.getVar("coc_quickfix_open_command");
          if (typeof openCommand != "string") {
            openCommand = items.length < 10 ? `copen ${items.length}` : "copen";
          }
          nvim.pauseNotification();
          nvim.call("setqflist", [items], true);
          nvim.command(openCommand, true);
          nvim.resumeNotification(false, true);
        } else {
          await nvim.setVar("coc_jump_locations", items);
          if (this._env.locationlist) {
            nvim.command("CocList --normal --auto-preview location", true);
          } else {
            nvim.call("coc#util#do_autocmd", ["CocLocationsChange"], true);
          }
        }
      }
      async getQuickfixItem(loc, text, type = "", module2) {
        let targetRange = loc.targetRange;
        if (LocationLink.is(loc)) {
          loc = Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range } = loc;
        let { start, end } = range;
        let u = URI.parse(uri);
        if (!text && u.scheme == "file") {
          text = await this.getLine(uri, start.line);
        }
        let endLine = start.line == end.line ? text : await this.getLine(uri, end.line);
        let item = {
          uri,
          filename: u.scheme == "file" ? u.fsPath : uri,
          lnum: start.line + 1,
          end_lnum: end.line + 1,
          col: text ? byteIndex(text, start.character) + 1 : start.character + 1,
          end_col: endLine ? byteIndex(endLine, end.character) + 1 : end.character + 1,
          text: text || "",
          range
        };
        if (targetRange)
          item.targetRange = targetRange;
        if (module2)
          item.module = module2;
        if (type)
          item.type = type;
        if (doc)
          item.bufnr = doc.bufnr;
        return item;
      }
      async getLine(uri, line) {
        let document2 = this.getDocument(uri);
        if (document2 && document2.attached)
          return document2.getline(line) || "";
        if (!uri.startsWith("file:"))
          return "";
        let fsPath2 = URI.parse(uri).fsPath;
        if (!fs.existsSync(fsPath2))
          return "";
        return await readFileLine(fsPath2, line);
      }
      async readFile(uri) {
        let document2 = this.getDocument(uri);
        if (document2) {
          await document2.patchChange();
          return document2.content;
        }
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return "";
        let lines = await this.nvim.call("readfile", [u.fsPath]);
        return lines.join("\n") + "\n";
      }
      reset() {
        this.creating.clear();
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        this.buffers.clear();
        this.changeRoot(process.cwd());
      }
      changeRoot(dir) {
        this._root = normalizeFilePath(dir);
      }
      dispose() {
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        this._attached = false;
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/editors.ts
function renamed(editor, info) {
  let { document: document2, uri } = editor;
  if (document2.bufnr != info.bufnr)
    return false;
  let u = URI.parse(uri);
  if (u.scheme === "file")
    return !sameFile(u.fsPath, info.fullpath);
  return false;
}
var logger11, Editors;
var init_editors = __esm({
  "src/core/editors.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_logger();
    init_fs();
    init_protocol();
    logger11 = createLogger("core-editors");
    Editors = class {
      constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.editors = /* @__PURE__ */ new Map();
        this.tabIds = /* @__PURE__ */ new Set();
        this._onDidTabClose = new import_node3.Emitter();
        this._onDidChangeActiveTextEditor = new import_node3.Emitter();
        this._onDidChangeVisibleTextEditors = new import_node3.Emitter();
        this.onDidTabClose = this._onDidTabClose.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
      }
      get activeTextEditor() {
        return this.editors.get(this.winid);
      }
      get visibleTextEditors() {
        return Array.from(this.editors.values());
      }
      isVisible(bufnr) {
        for (let editor of this.editors.values()) {
          if (editor.bufnr == bufnr)
            return true;
        }
        return false;
      }
      onChangeCurrent(editor) {
        let id = editor.id;
        if (id === this.previousId)
          return;
        this.previousId = id;
        this._onDidChangeActiveTextEditor.fire(editor);
      }
      async attach(nvim) {
        this.nvim = nvim;
        let [winid, infos] = await nvim.eval(`[win_getid(),coc#util#editor_infos()]`);
        this.winid = winid;
        await Promise.allSettled(infos.map((info) => {
          return this.createTextEditor(info.winid);
        }));
        events_default.on("BufUnload", (bufnr) => {
          for (let [winid2, editor] of this.editors.entries()) {
            if (bufnr == editor.bufnr) {
              this.editors.delete(winid2);
            }
          }
        }, null, this.disposables);
        events_default.on("CursorHold", this.checkEditors, this, this.disposables);
        events_default.on("TabNew", (tabid) => {
          this.tabIds.add(tabid);
        }, null, this.disposables);
        events_default.on("TabClosed", this.checkTabs, this, this.disposables);
        events_default.on("WinEnter", (winid2) => {
          this.winid = winid2;
          let editor = this.editors.get(winid2);
          if (editor)
            this.onChangeCurrent(editor);
        }, null, this.disposables);
        events_default.on("WinClosed", (winid2) => {
          if (this.editors.has(winid2)) {
            this.editors.delete(winid2);
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", async (_, winid2) => {
          this.winid = winid2;
          let changed = await this.createTextEditor(winid2);
          if (changed)
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
        }, null, this.disposables);
      }
      checkTabs(ids) {
        let changed = false;
        for (let editor of this.editors.values()) {
          if (!ids.includes(editor.tabpageid)) {
            changed = true;
            this.editors.delete(editor.winid);
          }
        }
        for (let id of Array.from(this.tabIds)) {
          if (!ids.includes(id))
            this._onDidTabClose.fire(id);
        }
        this.tabIds = new Set(ids);
        if (changed)
          this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
      }
      checkUnloadedBuffers(bufnrs) {
        for (let bufnr of this.documents.bufnrs) {
          if (!bufnrs.includes(bufnr)) {
            void events_default.fire("BufUnload", [bufnr]);
          }
        }
      }
      async checkEditors() {
        let [winid, bufnrs, infos] = await this.nvim.eval(`[win_getid(),coc#util#get_loaded_bufs(),coc#util#editor_infos()]`);
        this.winid = winid;
        this.checkUnloadedBuffers(bufnrs);
        let changed = false;
        let winids = /* @__PURE__ */ new Set();
        for (let info of infos) {
          let editor = this.editors.get(info.winid);
          let create = false;
          if (!editor) {
            create = true;
          } else if (renamed(editor, info)) {
            await events_default.fire("BufRename", [info.bufnr]);
            create = true;
          } else if (editor.document.bufnr != info.bufnr || editor.tabpageid != info.tabid) {
            create = true;
          }
          if (create) {
            await this.createTextEditor(info.winid);
            changed = true;
          }
          winids.add(info.winid);
        }
        if (this.cleanupEditors(winids)) {
          changed = true;
        }
        if (changed)
          this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
      }
      cleanupEditors(winids) {
        let changed = false;
        for (let winid of Array.from(this.editors.keys())) {
          if (!winids.has(winid)) {
            changed = true;
            this.editors.delete(winid);
          }
        }
        return changed;
      }
      async createTextEditor(winid) {
        let { documents, nvim } = this;
        let opts = await nvim.call("coc#util#get_editoroption", [winid]);
        if (!opts)
          return false;
        this.tabIds.add(opts.tabpageid);
        let doc = documents.getDocument(opts.bufnr);
        if (doc && doc.attached) {
          let editor = this.fromOptions(opts);
          this.editors.set(winid, editor);
          if (winid == this.winid)
            this.onChangeCurrent(editor);
          logger11.debug("editor created winid & bufnr & tabpageid: ", winid, opts.bufnr, opts.tabpageid);
          return true;
        } else {
          this.editors.delete(opts.winid);
        }
        return false;
      }
      fromOptions(opts) {
        let { visibleRanges, bufnr } = opts;
        let document2 = this.documents.getDocument(bufnr);
        return {
          id: `${opts.tabpageid}-${opts.winid}-${document2.uri}`,
          tabpageid: opts.tabpageid,
          winid: opts.winid,
          winnr: opts.winnr,
          uri: document2.uri,
          bufnr: document2.bufnr,
          document: document2,
          visibleRanges: visibleRanges.map((o) => Range.create(o[0] - 1, 0, o[1], 0)),
          options: {
            tabSize: opts.tabSize,
            insertSpaces: !!opts.insertSpaces
          }
        };
      }
    };
  }
});

// src/model/highligher.ts
var Highlighter;
var init_highligher = __esm({
  "src/model/highligher.ts"() {
    "use strict";
    init_ansiparse();
    init_string();
    Highlighter = class {
      constructor() {
        this.lines = [];
        this._highlights = [];
      }
      addLine(line, hlGroup) {
        if (line.includes("\n")) {
          for (let content of line.split(/\r?\n/)) {
            this.addLine(content, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          this._highlights.push({
            lnum: this.lines.length,
            colStart: line.match(/^\s*/)[0].length,
            colEnd: byteLength(line),
            hlGroup
          });
        }
        if (line.includes("\x1B")) {
          let res = parseAnsiHighlights(line);
          for (let hl of res.highlights) {
            let { span, hlGroup: hlGroup2 } = hl;
            this._highlights.push({
              lnum: this.lines.length,
              colStart: span[0],
              colEnd: span[1],
              hlGroup: hlGroup2
            });
          }
          this.lines.push(res.line);
        } else {
          this.lines.push(line);
        }
      }
      addLines(lines) {
        this.lines.push(...lines);
      }
      addTexts(items) {
        let len = this.lines.length;
        let text = "";
        for (let item of items) {
          let colStart = byteLength(text);
          if (item.hlGroup) {
            this._highlights.push({
              lnum: len,
              colStart,
              colEnd: colStart + byteLength(item.text),
              hlGroup: item.hlGroup
            });
          }
          text += item.text;
        }
        this.lines.push(text);
      }
      addText(text, hlGroup) {
        if (!text)
          return;
        let { lines } = this;
        let pre = lines[lines.length - 1] || "";
        if (text.includes("\n")) {
          let parts = text.split("\n");
          this.addText(parts[0], hlGroup);
          for (let line of parts.slice(1)) {
            this.addLine(line, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          let colStart = byteLength(pre);
          this._highlights.push({
            lnum: lines.length ? lines.length - 1 : 0,
            colStart,
            colEnd: colStart + byteLength(text),
            hlGroup
          });
        }
        if (lines.length) {
          lines[lines.length - 1] = `${pre}${text}`;
        } else {
          lines.push(text);
        }
      }
      get length() {
        return this.lines.length;
      }
      getline(line) {
        return this.lines[line] || "";
      }
      get highlights() {
        return this._highlights;
      }
      get content() {
        return this.lines.join("\n");
      }
      render(buffer, start = 0, end = -1) {
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this._highlights) {
          buffer.addHighlight({
            hlGroup: item.hlGroup,
            colStart: item.colStart,
            colEnd: item.colEnd,
            line: start + item.lnum,
            srcId: -1
          });
        }
      }
    };
  }
});

// src/model/editInspect.ts
function getOriginalLine(item, change) {
  if (typeof item.lnum !== "number")
    return void 0;
  let lnum = item.lnum;
  if (change) {
    let edits = mergeSortEdits(change.edits);
    let pos = getPositionFromEdits(Position.create(lnum - 1, 0), edits);
    lnum = pos.line + 1;
  }
  return lnum;
}
function grouByAnnotation(changes, annotations) {
  var _a2;
  let map = /* @__PURE__ */ new Map();
  for (let change of changes) {
    let id = getAnnotationKey(change) ?? null;
    let key = id ? (_a2 = annotations[id]) == null ? void 0 : _a2.label : null;
    let arr = map.get(key);
    if (arr) {
      arr.push(change);
    } else {
      map.set(key, [change]);
    }
  }
  return map;
}
var global_id, EditInspect;
var init_editInspect = __esm({
  "src/model/editInspect.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_util();
    init_array();
    init_fs();
    init_node();
    init_textedit();
    init_highligher();
    global_id = 0;
    EditInspect = class {
      constructor(nvim, keymaps) {
        this.nvim = nvim;
        this.keymaps = keymaps;
        this.disposables = [];
        this.items = [];
        this.renameMap = /* @__PURE__ */ new Map();
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr == this.bufnr)
            this.dispose();
        }, null, this.disposables);
      }
      addFile(filepath, highligher, lnum) {
        this.items.push({
          index: highligher.length,
          filepath,
          lnum
        });
      }
      async show(state) {
        let { nvim } = this;
        let id = global_id++;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ buftype=nofile CocWorkspaceEdit${id}`, true);
        nvim.command(`setl bufhidden=wipe nolist`, true);
        nvim.command("setl nobuflisted wrap undolevels=-1 filetype=cocedits noswapfile", true);
        await nvim.resumeNotification(true);
        let buffer = await nvim.buffer;
        let cwd2 = await nvim.call("getcwd");
        this.bufnr = buffer.id;
        const relpath = (uri) => {
          let fsPath2 = URI.parse(uri).fsPath;
          return isParentFolder(cwd2, fsPath2, true) ? path.relative(cwd2, fsPath2) : fsPath2;
        };
        const absPath = (filepath) => {
          return path.isAbsolute(filepath) ? filepath : path.join(cwd2, filepath);
        };
        let highligher = new Highlighter();
        let changes = toArray(state.edit.documentChanges);
        let map = grouByAnnotation(changes, state.edit.changeAnnotations ?? {});
        for (let [label, changes2] of map.entries()) {
          if (label) {
            highligher.addLine(label, "MoreMsg");
            highligher.addLine("");
          }
          for (let change of changes2) {
            if (TextDocumentEdit.is(change)) {
              let linesChange = state.changes[change.textDocument.uri];
              let fsPath2 = relpath(change.textDocument.uri);
              highligher.addTexts([
                { text: "Change", hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" },
                { text: `:${linesChange.lnum}`, hlGroup: "LineNr" }
              ]);
              this.addFile(fsPath2, highligher, linesChange.lnum);
              highligher.addLine("");
              this.addChangedLines(highligher, linesChange, fsPath2, linesChange.lnum);
              highligher.addLine("");
            } else if (CreateFile.is(change) || DeleteFile.is(change)) {
              let title = DeleteFile.is(change) ? "Delete" : "Create";
              let fsPath2 = relpath(change.uri);
              highligher.addTexts([
                { text: title, hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" }
              ]);
              this.addFile(fsPath2, highligher);
              highligher.addLine("");
            } else if (RenameFile.is(change)) {
              let oldPath = relpath(change.oldUri);
              let newPath = relpath(change.newUri);
              highligher.addTexts([
                { text: "Rename", hlGroup: "Title" },
                { text: " " },
                { text: oldPath, hlGroup: "Directory" },
                { text: "->", hlGroup: "Comment" },
                { text: newPath, hlGroup: "Directory" }
              ]);
              this.renameMap.set(oldPath, newPath);
              this.addFile(newPath, highligher);
              highligher.addLine("");
            }
          }
        }
        nvim.pauseNotification();
        highligher.render(buffer);
        buffer.setOption("modifiable", false, true);
        await nvim.resumeNotification(true);
        this.disposables.push(this.keymaps.registerLocalKeymap(buffer.id, "n", "<CR>", async () => {
          let lnum = await nvim.call("line", ".");
          let col = await nvim.call("col", ".");
          let find;
          for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i];
            if (lnum >= item.index) {
              find = item;
              break;
            }
          }
          if (!find)
            return;
          let uri = URI.file(absPath(find.filepath)).toString();
          let filepath = this.renameMap.has(find.filepath) ? this.renameMap.get(find.filepath) : find.filepath;
          await nvim.call("coc#util#open_file", ["tab drop", absPath(filepath)]);
          let documentChanges = toArray(state.edit.documentChanges);
          let change = documentChanges.find((o) => TextDocumentEdit.is(o) && o.textDocument.uri == uri);
          let originLine = getOriginalLine(find, change);
          if (originLine !== void 0)
            await nvim.call("cursor", [originLine, col]);
          nvim.redrawVim();
        }, true));
        this.disposables.push(this.keymaps.registerLocalKeymap(buffer.id, "n", "<esc>", async () => {
          nvim.command("bwipeout!", true);
        }, true));
      }
      addChangedLines(highligher, linesChange, fsPath2, lnum) {
        let diffs = fastDiff(linesChange.oldLines.join("\n"), linesChange.newLines.join("\n"));
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          if (diff[0] == fastDiff.EQUAL) {
            let text = diff[1];
            if (!text.includes("\n")) {
              highligher.addText(text);
            } else {
              let parts = text.split("\n");
              highligher.addText(parts[0]);
              let curr = lnum + parts.length - 1;
              highligher.addLine("");
              highligher.addTexts([
                { text: "Change", hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" },
                { text: `:${curr}`, hlGroup: "LineNr" }
              ]);
              this.addFile(fsPath2, highligher, curr);
              highligher.addLine("");
              let last = parts[parts.length - 1];
              highligher.addText(last);
            }
            lnum += text.split("\n").length - 1;
          } else if (diff[0] == fastDiff.DELETE) {
            lnum += diff[1].split("\n").length - 1;
            highligher.addText(diff[1], "DiffDelete");
          } else {
            highligher.addText(diff[1], "DiffAdd");
          }
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/files.ts
function fileMatch(root, relpath, pattern) {
  let filepath = path.join(root, relpath);
  if (typeof pattern !== "string") {
    let base = pattern.baseUri.fsPath;
    if (!isParentFolder(base, filepath))
      return false;
    let rp = path.relative(base, filepath);
    return minimatch(rp, pattern.pattern, { dot: true });
  }
  return minimatch(relpath, pattern, { dot: true });
}
function fsPath(uri) {
  return URI.parse(uri).fsPath;
}
var logger12, Files;
var init_files = __esm({
  "src/core/files.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_logger();
    init_editInspect();
    init_errors();
    init_fs();
    init_node();
    init_protocol();
    init_string();
    init_textedit();
    logger12 = createLogger("core-files");
    Files = class {
      constructor(documents, configurations, workspaceFolderControl, keymaps) {
        this.documents = documents;
        this.configurations = configurations;
        this.workspaceFolderControl = workspaceFolderControl;
        this.keymaps = keymaps;
        this.operationTimeout = 500;
        this._onDidCreateFiles = new import_node3.Emitter();
        this._onDidRenameFiles = new import_node3.Emitter();
        this._onDidDeleteFiles = new import_node3.Emitter();
        this._onWillCreateFiles = new import_node3.Emitter();
        this._onWillRenameFiles = new import_node3.Emitter();
        this._onWillDeleteFiles = new import_node3.Emitter();
        this.onDidCreateFiles = this._onDidCreateFiles.event;
        this.onDidRenameFiles = this._onDidRenameFiles.event;
        this.onDidDeleteFiles = this._onDidDeleteFiles.event;
        this.onWillCreateFiles = this._onWillCreateFiles.event;
        this.onWillRenameFiles = this._onWillRenameFiles.event;
        this.onWillDeleteFiles = this._onWillDeleteFiles.event;
      }
      attach(nvim, env, window2) {
        this.nvim = nvim;
        this.env = env;
        this.window = window2;
      }
      async openTextDocument(uri) {
        uri = typeof uri === "string" ? URI.file(uri) : uri;
        let doc = this.documents.getDocument(uri.toString());
        if (doc) {
          await this.jumpTo(uri, null, "drop");
          return doc;
        }
        const scheme = uri.scheme;
        if (scheme == "file") {
          if (!fs.existsSync(uri.fsPath))
            throw fileNotExists(uri.fsPath);
          fs.accessSync(uri.fsPath, fs.constants.R_OK);
        }
        if (scheme == "untitled") {
          await this.nvim.call("coc#util#open_file", ["tab drop", uri.path]);
          return await this.documents.document;
        }
        return await this.loadResource(uri.toString());
      }
      async jumpTo(uri, position, openCommand) {
        if (!openCommand)
          openCommand = this.configurations.initialConfiguration.get("coc.preferences.jumpCommand", "edit");
        let { nvim } = this;
        let u = uri instanceof URI ? uri : URI.parse(uri);
        let doc = this.documents.getDocument(u.with({ fragment: "" }).toString());
        let bufnr = doc ? doc.bufnr : -1;
        if (!position && u.scheme === "file" && u.fragment) {
          let parts = u.fragment.split(",");
          let lnum = parseInt(parts[0], 10);
          if (!isNaN(lnum)) {
            let col = parts.length > 0 && /^\d+$/.test(parts[1]) ? parseInt(parts[1], 10) : void 0;
            position = Position.create(lnum - 1, col == null ? 0 : col - 1);
          }
        }
        if (bufnr != -1 && openCommand == "edit") {
          nvim.pauseNotification();
          nvim.command(`silent! normal! m'`, true);
          nvim.command(`buffer ${bufnr}`, true);
          nvim.command(`if &filetype ==# '' | filetype detect | endif`, true);
          if (position) {
            let line = doc.getline(position.line);
            let col = byteIndex(line, position.character) + 1;
            nvim.call("cursor", [position.line + 1, col], true);
          }
          await nvim.resumeNotification(true);
        } else {
          let { fsPath: fsPath2, scheme } = u;
          let pos = position == null ? null : [position.line, position.character];
          if (scheme == "file") {
            let bufname = normalizeFilePath(fsPath2);
            await this.nvim.call("coc#util#jump", [openCommand, bufname, pos]);
          } else {
            await this.nvim.call("coc#util#jump", [openCommand, uri.toString(), pos]);
          }
        }
      }
      async openResource(uri) {
        let { nvim } = this;
        let u = URI.parse(uri);
        if (/^https?/.test(u.scheme)) {
          await nvim.call("coc#ui#open_url", uri);
          return;
        }
        await this.jumpTo(uri);
        await this.documents.document;
      }
      async loadResource(uri, cmd) {
        let doc = this.documents.getDocument(uri);
        if (doc)
          return doc;
        if (!cmd) {
          const preferences = this.configurations.getConfiguration("workspace");
          cmd = preferences.get("openResourceCommand", "tab drop");
        }
        let u = URI.parse(uri);
        let bufname = u.scheme === "file" ? u.fsPath : uri;
        let bufnr;
        if (cmd) {
          let winid = await this.nvim.call("win_getid");
          bufnr = await this.nvim.call("coc#util#open_file", [cmd, bufname]);
          await this.nvim.call("win_gotoid", [winid]);
        } else {
          let arr = await this.nvim.call("coc#ui#open_files", [[bufname]]);
          bufnr = arr[0];
        }
        return await this.documents.createDocument(bufnr);
      }
      async loadResources(uris) {
        let { documents } = this;
        let files = uris.map((uri) => {
          let u = URI.parse(uri);
          return u.scheme == "file" ? u.fsPath : uri;
        });
        let bufnrs = await this.nvim.call("coc#ui#open_files", [files]);
        return await Promise.all(bufnrs.map((bufnr) => {
          return documents.createDocument(bufnr);
        }));
      }
      async createFile(filepath, opts = {}, recovers) {
        let { nvim } = this;
        let exists = fs.existsSync(filepath);
        if (exists && !opts.overwrite && !opts.ignoreIfExists) {
          throw fileExists(filepath);
        }
        if (!exists || opts.overwrite) {
          let tokenSource = new import_node3.CancellationTokenSource();
          await this.fireWaitUntilEvent(this._onWillCreateFiles, {
            files: [URI.file(filepath)],
            token: tokenSource.token
          }, recovers);
          tokenSource.cancel();
          let dir = path.dirname(filepath);
          if (!fs.existsSync(dir)) {
            let folder;
            let curr = dir;
            while (![".", "/", path.parse(dir).root].includes(curr)) {
              if (fs.existsSync(path.dirname(curr))) {
                folder = curr;
                break;
              }
              curr = path.dirname(curr);
            }
            fs.mkdirSync(dir, { recursive: true });
            recovers && recovers.push(() => {
              fs.rmSync(folder, { force: true, recursive: true });
            });
          }
          fs.writeFileSync(filepath, "", "utf8");
          recovers && recovers.push(() => {
            fs.rmSync(filepath, { force: true, recursive: true });
          });
          let doc = await this.loadResource(filepath);
          let bufnr = doc.bufnr;
          recovers && recovers.push(() => {
            void events_default.fire("BufUnload", [bufnr]);
            return nvim.command(`silent! bd! ${bufnr}`);
          });
          this._onDidCreateFiles.fire({ files: [URI.file(filepath)] });
        }
      }
      async deleteFile(filepath, opts = {}, recovers) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await statAsync(filepath);
        let isDir = stat && stat.isDirectory();
        if (!stat && !ignoreIfNotExists) {
          throw fileNotExists(filepath);
        }
        if (stat == null)
          return;
        let uri = URI.file(filepath);
        await this.fireWaitUntilEvent(this._onWillDeleteFiles, { files: [uri] }, recovers);
        if (!isDir) {
          let bufnr = await this.nvim.call("bufnr", [filepath]);
          if (bufnr) {
            void events_default.fire("BufUnload", [bufnr]);
            await this.nvim.command(`silent! bwipeout ${bufnr}`);
            recovers && recovers.push(() => {
              return this.loadResource(uri.toString());
            });
          }
        }
        let folder = path.join(os.tmpdir(), "coc-" + process.pid);
        fs.mkdirSync(folder, { recursive: true });
        let md5 = crypto.createHash("md5").update(filepath).digest("hex");
        if (isDir && recursive) {
          let dest = path.join(folder, md5);
          let dir = path.dirname(filepath);
          fs.renameSync(filepath, dest);
          recovers && recovers.push(async () => {
            fs.mkdirSync(dir, { recursive: true });
            fs.renameSync(dest, filepath);
          });
        } else if (isDir) {
          fs.rmdirSync(filepath);
          recovers && recovers.push(() => {
            fs.mkdirSync(filepath);
          });
        } else {
          let dest = path.join(folder, md5);
          let dir = path.dirname(filepath);
          fs.renameSync(filepath, dest);
          recovers && recovers.push(() => {
            fs.mkdirSync(dir, { recursive: true });
            fs.renameSync(dest, filepath);
          });
        }
        this._onDidDeleteFiles.fire({ files: [uri] });
      }
      async renameFile(oldPath, newPath, opts = {}, recovers) {
        let { nvim } = this;
        let { overwrite, ignoreIfExists } = opts;
        if (newPath === oldPath)
          return;
        let exists = fs.existsSync(newPath);
        if (exists && ignoreIfExists && !overwrite)
          return;
        if (exists && !overwrite)
          throw fileExists(newPath);
        let oldStat = await statAsync(oldPath);
        let loaded = oldStat && oldStat.isDirectory() ? 0 : await nvim.call("bufloaded", [oldPath]);
        if (!loaded && !oldStat)
          throw fileNotExists(oldPath);
        let file = { newUri: URI.parse(newPath), oldUri: URI.parse(oldPath) };
        if (!opts.skipEvent)
          await this.fireWaitUntilEvent(this._onWillRenameFiles, { files: [file] }, recovers);
        if (loaded) {
          let bufnr = await nvim.call("coc#ui#rename_file", [oldPath, newPath, oldStat != null]);
          await this.documents.onBufCreate(bufnr);
        } else {
          if (oldStat.isDirectory()) {
            for (let doc of this.documents.attached("file")) {
              let u = URI.parse(doc.uri);
              if (isParentFolder(oldPath, u.fsPath, false)) {
                let filepath = u.fsPath.replace(oldPath, newPath);
                let bufnr = await nvim.call("coc#ui#rename_file", [u.fsPath, filepath, false]);
                await this.documents.onBufCreate(bufnr);
              }
            }
          }
          fs.renameSync(oldPath, newPath);
        }
        recovers && recovers.push(() => {
          return this.renameFile(newPath, oldPath, { skipEvent: true });
        });
        if (!opts.skipEvent)
          this._onDidRenameFiles.fire({ files: [file] });
      }
      async promptAnotations(documentChanges, changeAnnotations) {
        let toConfirm = changeAnnotations ? getConfirmAnnotations(documentChanges, changeAnnotations) : [];
        let denied = [];
        for (let key of toConfirm) {
          let annotation = changeAnnotations[key];
          let res = await this.window.showMenuPicker(["Yes", "No"], {
            position: "center",
            title: "Confirm edits",
            content: annotation.label + (annotation.description ? " " + annotation.description : "")
          });
          if (res !== 0)
            denied.push(key);
        }
        return denied;
      }
      async applyEdit(edit2, nested) {
        let documentChanges = toDocumentChanges(edit2);
        let recovers = [];
        let currentOnly = false;
        try {
          let denied = await this.promptAnotations(documentChanges, edit2.changeAnnotations);
          if (denied.length > 0)
            documentChanges = createFilteredChanges(documentChanges, denied);
          let changes = {};
          let currentUri = await this.documents.getCurrentUri();
          currentOnly = documentChanges.every((o) => TextDocumentEdit.is(o) && o.textDocument.uri === currentUri);
          this.validateChanges(documentChanges);
          for (const change of documentChanges) {
            if (TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              let { uri } = textDocument;
              let doc = await this.loadResource(uri);
              let revertEdit = await doc.applyEdits(edits, false, uri === currentUri);
              if (revertEdit) {
                let version2 = doc.version;
                let { newText, range } = revertEdit;
                changes[uri] = {
                  uri,
                  lnum: range.start.line + 1,
                  newLines: doc.getLines(range.start.line, range.end.line),
                  oldLines: newText.endsWith("\n") ? newText.slice(0, -1).split("\n") : newText.split("\n")
                };
                recovers.push(async () => {
                  let doc2 = this.documents.getDocument(uri);
                  if (!doc2 || !doc2.attached || doc2.version !== version2)
                    return;
                  await doc2.applyEdits([revertEdit]);
                  textDocument.version = doc2.version;
                });
              }
            } else if (CreateFile.is(change)) {
              await this.createFile(fsPath(change.uri), change.options, recovers);
            } else if (DeleteFile.is(change)) {
              await this.deleteFile(fsPath(change.uri), change.options, recovers);
            } else if (RenameFile.is(change)) {
              await this.renameFile(fsPath(change.oldUri), fsPath(change.newUri), change.options, recovers);
            }
          }
          if (recovers.length === 0)
            return true;
          if (!nested)
            this.editState = { edit: { documentChanges, changeAnnotations: edit2.changeAnnotations }, changes, recovers, applied: true };
          this.nvim.redrawVim();
        } catch (e) {
          logger12.error("Error on applyEdits:", edit2, e);
          if (!nested)
            void this.window.showErrorMessage(`Error on applyEdits: ${e}`);
          await this.undoChanges(recovers);
          return false;
        }
        if (nested || currentOnly)
          return true;
        void this.window.showInformationMessage(`Use ':wa' to save changes or ':CocCommand workspace.inspectEdit' to inspect.`);
        return true;
      }
      async undoChanges(recovers) {
        while (recovers.length > 0) {
          let fn = recovers.pop();
          await Promise.resolve(fn());
        }
      }
      async inspectEdit() {
        if (!this.editState) {
          void this.window.showWarningMessage("No workspace edit to inspect");
          return;
        }
        let inspect2 = new EditInspect(this.nvim, this.keymaps);
        await inspect2.show(this.editState);
      }
      async undoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || !editState.applied) {
          void this.window.showWarningMessage(`No workspace edit to undo`);
          return;
        }
        editState.applied = false;
        await this.undoChanges(editState.recovers);
      }
      async redoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || editState.applied) {
          void this.window.showWarningMessage(`No workspace edit to redo`);
          return;
        }
        this.editState = void 0;
        await this.applyEdit(editState.edit);
      }
      validateChanges(documentChanges) {
        let { documents } = this;
        for (let change of documentChanges) {
          if (TextDocumentEdit.is(change)) {
            let { uri, version: version2 } = change.textDocument;
            let doc = documents.getDocument(uri);
            if (typeof version2 === "number" && version2 > 0) {
              if (!doc)
                throw notLoaded(uri);
              if (doc.version != version2)
                throw new Error(`${uri} changed before apply edit`);
            } else if (!doc && !isFile(uri)) {
              throw badScheme(uri);
            }
          } else if (CreateFile.is(change) || DeleteFile.is(change)) {
            if (!isFile(change.uri))
              throw badScheme(change.uri);
          } else if (RenameFile.is(change)) {
            if (!isFile(change.oldUri) || !isFile(change.newUri)) {
              throw badScheme(change.oldUri);
            }
          }
        }
      }
      async findFiles(include, exclude, maxResults, token) {
        let folders = this.workspaceFolderControl.workspaceFolders;
        if ((token == null ? void 0 : token.isCancellationRequested) || !folders.length || maxResults === 0)
          return [];
        maxResults = maxResults ?? Infinity;
        let roots = folders.map((o) => URI.parse(o.uri).fsPath);
        let pattern;
        if (typeof include !== "string") {
          pattern = include.pattern;
          roots = [include.baseUri.fsPath];
        } else {
          pattern = include;
        }
        let res = [];
        let exceed = false;
        for (let root of roots) {
          let files = await (0, import_util.promisify)(glob)(pattern, {
            dot: true,
            cwd: root,
            nodir: true,
            absolute: false
          });
          if (token == null ? void 0 : token.isCancellationRequested)
            return [];
          for (let file of files) {
            if (exclude && fileMatch(root, file, exclude))
              continue;
            res.push(URI.file(path.join(root, file)));
            if (res.length === maxResults) {
              exceed = true;
              break;
            }
          }
          if (exceed)
            break;
        }
        return res;
      }
      async fireWaitUntilEvent(emitter, properties, recovers) {
        let firing = true;
        let promises = [];
        emitter.fire({
          ...properties,
          waitUntil: (thenable) => {
            if (!firing)
              throw shouldNotAsync("waitUntil");
            let tp = new Promise((resolve) => {
              setTimeout(resolve, this.operationTimeout);
            });
            let promise = Promise.race([thenable, tp]).then((edit2) => {
              if (edit2 && WorkspaceEdit.is(edit2)) {
                return this.applyEdit(edit2, true);
              }
            });
            promises.push(promise);
          }
        });
        firing = false;
        await Promise.all(promises);
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  return import_crypto.default.randomBytes(16);
}
var import_crypto;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
  }
});

// node_modules/uuid/dist/esm-node/bytesToUuid.js
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join("");
}
var byteToHex, i, bytesToUuid_default;
var init_bytesToUuid = __esm({
  "node_modules/uuid/dist/esm-node/bytesToUuid.js"() {
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    bytesToUuid_default = bytesToUuid;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options2, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options2 = options2 || {};
  var node = options2.node || _nodeId;
  var clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options2.random || (options2.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options2.msecs !== void 0 ? options2.msecs : new Date().getTime();
  var nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options2.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_bytesToUuid();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options2, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options2 == "string") {
    buf = options2 === "binary" ? new Array(16) : null;
    options2 = null;
  }
  options2 = options2 || {};
  var rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_bytesToUuid();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v4();
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS({
  "node_modules/node-int64/Int64.js"(exports2, module2) {
    var VAL32 = 4294967296;
    var _HEX = [];
    for (i = 0; i < 256; i++) {
      _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
    }
    var i;
    var Int64 = module2.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    Int64.MAX_INT = Math.pow(2, 53);
    Int64.MIN_INT = -Math.pow(2, 53);
    Int64.prototype = {
      constructor: Int64,
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i2 = o + 7; i2 >= o; i2--) {
          var v = (b[i2] ^ 255) + carry;
          b[i2] = v & 255;
          carry = v >> 8;
        }
      },
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof hi == "number") {
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32)
              throw new RangeError(hi + " is outside Int64 range");
            hi = hi | 0;
          } else if (typeof hi == "string") {
            hi = (hi + "").replace(/^0x/, "");
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + " must be a Number or String");
          }
        }
        var b = this.buffer, o = this.offset;
        for (var i2 = 7; i2 >= 0; i2--) {
          b[o + i2] = lo & 255;
          lo = i2 == 4 ? hi : lo >>> 8;
        }
        if (negate)
          this._2scomp();
      },
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
        var negate = b[o] & 128, x = 0, carry = 1;
        for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
          var v = b[o + i2];
          if (negate) {
            v = (v ^ 255) + carry;
            carry = v >> 8;
            v = v & 255;
          }
          x += v * m;
        }
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
      },
      valueOf: function() {
        return this.toNumber(false);
      },
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2] = _HEX[b[o + i2]];
        }
        return out.join(sep || "");
      },
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0)
          return this.buffer;
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
      compare: function(other) {
        if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
        for (var i2 = 0; i2 < 8; i2++) {
          if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
            return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
          }
        }
        return 0;
      },
      equals: function(other) {
        return this.compare(other) === 0;
      },
      inspect: function() {
        return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
      }
    };
  }
});

// node_modules/bser/index.js
var require_bser = __commonJS({
  "node_modules/bser/index.js"(exports2) {
    var EE = require("events").EventEmitter;
    var util = require("util");
    var os2 = require("os");
    var assert2 = require("assert");
    var Int64 = require_Int64();
    var isBigEndian = os2.endianness() == "BE";
    function nextPow2(size) {
      return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
    }
    function Accumulator(initsize) {
      this.buf = Buffer.alloc(nextPow2(initsize || 8192));
      this.readOffset = 0;
      this.writeOffset = 0;
    }
    exports2.Accumulator = Accumulator;
    Accumulator.prototype.writeAvail = function() {
      return this.buf.length - this.writeOffset;
    };
    Accumulator.prototype.readAvail = function() {
      return this.writeOffset - this.readOffset;
    };
    Accumulator.prototype.reserve = function(size) {
      if (size < this.writeAvail()) {
        return;
      }
      if (this.readOffset > 0) {
        this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }
      if (size < this.writeAvail()) {
        return;
      }
      var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
      this.buf.copy(buf);
      this.buf = buf;
    };
    Accumulator.prototype.append = function(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buf, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        var size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buf.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    };
    Accumulator.prototype.assertReadableSize = function(size) {
      if (this.readAvail() < size) {
        throw new Error("wanted to read " + size + " bytes but only have " + this.readAvail());
      }
    };
    Accumulator.prototype.peekString = function(size) {
      this.assertReadableSize(size);
      return this.buf.toString("utf-8", this.readOffset, this.readOffset + size);
    };
    Accumulator.prototype.readString = function(size) {
      var str = this.peekString(size);
      this.readOffset += size;
      return str;
    };
    Accumulator.prototype.peekInt = function(size) {
      this.assertReadableSize(size);
      switch (size) {
        case 1:
          return this.buf.readInt8(this.readOffset, size);
        case 2:
          return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);
        case 4:
          return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);
        case 8:
          var big = this.buf.slice(this.readOffset, this.readOffset + 8);
          if (isBigEndian) {
            return new Int64(big);
          }
          return new Int64(byteswap64(big));
        default:
          throw new Error("invalid integer size " + size);
      }
    };
    Accumulator.prototype.readInt = function(bytes2) {
      var ival = this.peekInt(bytes2);
      if (ival instanceof Int64 && isFinite(ival.valueOf())) {
        ival = ival.valueOf();
      }
      this.readOffset += bytes2;
      return ival;
    };
    Accumulator.prototype.peekDouble = function() {
      this.assertReadableSize(8);
      return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);
    };
    Accumulator.prototype.readDouble = function() {
      var dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    };
    Accumulator.prototype.readAdvance = function(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw new Error("advance with negative offset " + size + " would seek off the start of the buffer");
      }
      this.readOffset += size;
    };
    Accumulator.prototype.writeByte = function(value) {
      this.reserve(1);
      this.buf.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    };
    Accumulator.prototype.writeInt = function(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buf.writeInt8(value, this.writeOffset);
          break;
        case 2:
          if (isBigEndian) {
            this.buf.writeInt16BE(value, this.writeOffset);
          } else {
            this.buf.writeInt16LE(value, this.writeOffset);
          }
          break;
        case 4:
          if (isBigEndian) {
            this.buf.writeInt32BE(value, this.writeOffset);
          } else {
            this.buf.writeInt32LE(value, this.writeOffset);
          }
          break;
        default:
          throw new Error("unsupported integer size " + size);
      }
      this.writeOffset += size;
    };
    Accumulator.prototype.writeDouble = function(value) {
      this.reserve(8);
      if (isBigEndian) {
        this.buf.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buf.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    };
    var BSER_ARRAY = 0;
    var BSER_OBJECT = 1;
    var BSER_STRING = 2;
    var BSER_INT8 = 3;
    var BSER_INT16 = 4;
    var BSER_INT32 = 5;
    var BSER_INT64 = 6;
    var BSER_REAL = 7;
    var BSER_TRUE = 8;
    var BSER_FALSE = 9;
    var BSER_NULL = 10;
    var BSER_TEMPLATE = 11;
    var BSER_SKIP = 12;
    var ST_NEED_PDU = 0;
    var ST_FILL_PDU = 1;
    var MAX_INT8 = 127;
    var MAX_INT16 = 32767;
    var MAX_INT32 = 2147483647;
    function BunserBuf() {
      EE.call(this);
      this.buf = new Accumulator();
      this.state = ST_NEED_PDU;
    }
    util.inherits(BunserBuf, EE);
    exports2.BunserBuf = BunserBuf;
    BunserBuf.prototype.append = function(buf, synchronous) {
      if (synchronous) {
        this.buf.append(buf);
        return this.process(synchronous);
      }
      try {
        this.buf.append(buf);
      } catch (err) {
        this.emit("error", err);
        return;
      }
      this.processLater();
    };
    BunserBuf.prototype.processLater = function() {
      var self = this;
      process.nextTick(function() {
        try {
          self.process(false);
        } catch (err) {
          self.emit("error", err);
        }
      });
    };
    BunserBuf.prototype.process = function(synchronous) {
      if (this.state == ST_NEED_PDU) {
        if (this.buf.readAvail() < 2) {
          return;
        }
        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodeInt(true);
        if (this.pduLen === false) {
          this.buf.readAdvance(-2);
          return;
        }
        this.buf.reserve(this.pduLen);
        this.state = ST_FILL_PDU;
      }
      if (this.state == ST_FILL_PDU) {
        if (this.buf.readAvail() < this.pduLen) {
          return;
        }
        var val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.emit("value", val);
        this.state = ST_NEED_PDU;
      }
      if (!synchronous && this.buf.readAvail() > 0) {
        this.processLater();
      }
    };
    BunserBuf.prototype.raise = function(reason) {
      throw new Error(reason + ", in Buffer of length " + this.buf.buf.length + " (" + this.buf.readAvail() + " readable) at offset " + this.buf.readOffset + " buffer: " + JSON.stringify(this.buf.buf.slice(
        this.buf.readOffset,
        this.buf.readOffset + 32
      ).toJSON()));
    };
    BunserBuf.prototype.expectCode = function(expected) {
      var code = this.buf.readInt(1);
      if (code != expected) {
        this.raise("expected bser opcode " + expected + " but got " + code);
      }
    };
    BunserBuf.prototype.decodeAny = function() {
      var code = this.buf.peekInt(1);
      switch (code) {
        case BSER_INT8:
        case BSER_INT16:
        case BSER_INT32:
        case BSER_INT64:
          return this.decodeInt();
        case BSER_REAL:
          this.buf.readAdvance(1);
          return this.buf.readDouble();
        case BSER_TRUE:
          this.buf.readAdvance(1);
          return true;
        case BSER_FALSE:
          this.buf.readAdvance(1);
          return false;
        case BSER_NULL:
          this.buf.readAdvance(1);
          return null;
        case BSER_STRING:
          return this.decodeString();
        case BSER_ARRAY:
          return this.decodeArray();
        case BSER_OBJECT:
          return this.decodeObject();
        case BSER_TEMPLATE:
          return this.decodeTemplate();
        default:
          this.raise("unhandled bser opcode " + code);
      }
    };
    BunserBuf.prototype.decodeArray = function() {
      this.expectCode(BSER_ARRAY);
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    };
    BunserBuf.prototype.decodeObject = function() {
      this.expectCode(BSER_OBJECT);
      var nitems = this.decodeInt();
      var res = {};
      for (var i = 0; i < nitems; ++i) {
        var key = this.decodeString();
        var val = this.decodeAny();
        res[key] = val;
      }
      return res;
    };
    BunserBuf.prototype.decodeTemplate = function() {
      this.expectCode(BSER_TEMPLATE);
      var keys = this.decodeArray();
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        var obj = {};
        for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
          if (this.buf.peekInt(1) == BSER_SKIP) {
            this.buf.readAdvance(1);
            continue;
          }
          var val = this.decodeAny();
          obj[keys[keyidx]] = val;
        }
        arr.push(obj);
      }
      return arr;
    };
    BunserBuf.prototype.decodeString = function() {
      this.expectCode(BSER_STRING);
      var len = this.decodeInt();
      return this.buf.readString(len);
    };
    BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
      if (relaxSizeAsserts && this.buf.readAvail() < 1) {
        return false;
      } else {
        this.buf.assertReadableSize(1);
      }
      var code = this.buf.peekInt(1);
      var size = 0;
      switch (code) {
        case BSER_INT8:
          size = 1;
          break;
        case BSER_INT16:
          size = 2;
          break;
        case BSER_INT32:
          size = 4;
          break;
        case BSER_INT64:
          size = 8;
          break;
        default:
          this.raise("invalid bser int encoding " + code);
      }
      if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {
        return false;
      }
      this.buf.readAdvance(1);
      return this.buf.readInt(size);
    };
    function loadFromBuffer(input) {
      var buf = new BunserBuf();
      var result = buf.append(input, true);
      if (buf.buf.readAvail()) {
        throw Error(
          "excess data found after input buffer, use BunserBuf instead"
        );
      }
      if (typeof result === "undefined") {
        throw Error(
          "no bser found in string and no error raised!?"
        );
      }
      return result;
    }
    exports2.loadFromBuffer = loadFromBuffer;
    function byteswap64(buf) {
      var swap = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        swap[i] = buf[buf.length - 1 - i];
      }
      return swap;
    }
    function dump_int64(buf, val) {
      var be = val.toBuffer();
      if (isBigEndian) {
        buf.writeByte(BSER_INT64);
        buf.append(be);
        return;
      }
      var le = byteswap64(be);
      buf.writeByte(BSER_INT64);
      buf.append(le);
    }
    function dump_int(buf, val) {
      var abs = Math.abs(val);
      if (abs <= MAX_INT8) {
        buf.writeByte(BSER_INT8);
        buf.writeInt(val, 1);
      } else if (abs <= MAX_INT16) {
        buf.writeByte(BSER_INT16);
        buf.writeInt(val, 2);
      } else if (abs <= MAX_INT32) {
        buf.writeByte(BSER_INT32);
        buf.writeInt(val, 4);
      } else {
        dump_int64(buf, new Int64(val));
      }
    }
    function dump_any(buf, val) {
      switch (typeof val) {
        case "number":
          if (isFinite(val) && Math.floor(val) === val) {
            dump_int(buf, val);
          } else {
            buf.writeByte(BSER_REAL);
            buf.writeDouble(val);
          }
          return;
        case "string":
          buf.writeByte(BSER_STRING);
          dump_int(buf, Buffer.byteLength(val));
          buf.append(val);
          return;
        case "boolean":
          buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
          return;
        case "object":
          if (val === null) {
            buf.writeByte(BSER_NULL);
            return;
          }
          if (val instanceof Int64) {
            dump_int64(buf, val);
            return;
          }
          if (Array.isArray(val)) {
            buf.writeByte(BSER_ARRAY);
            dump_int(buf, val.length);
            for (var i = 0; i < val.length; ++i) {
              dump_any(buf, val[i]);
            }
            return;
          }
          buf.writeByte(BSER_OBJECT);
          var keys = Object.keys(val);
          var num_keys = keys.length;
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              num_keys--;
            }
          }
          dump_int(buf, num_keys);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              continue;
            }
            dump_any(buf, key);
            try {
              dump_any(buf, v);
            } catch (e) {
              throw new Error(
                e.message + " (while serializing object property with name `" + key + "')"
              );
            }
          }
          return;
        default:
          throw new Error("cannot serialize type " + typeof val + " to BSER");
      }
    }
    function dumpToBuffer(val) {
      var buf = new Accumulator();
      buf.writeByte(0);
      buf.writeByte(1);
      buf.writeByte(BSER_INT32);
      buf.writeInt(0, 4);
      dump_any(buf, val);
      var off = buf.writeOffset;
      var len = off - 7;
      buf.writeOffset = 3;
      buf.writeInt(len, 4);
      buf.writeOffset = off;
      return buf.buf.slice(0, off);
    }
    exports2.dumpToBuffer = dumpToBuffer;
  }
});

// node_modules/fb-watchman/index.js
var require_fb_watchman = __commonJS({
  "node_modules/fb-watchman/index.js"(exports2, module2) {
    "use strict";
    var net2 = require("net");
    var EE = require("events").EventEmitter;
    var util = require("util");
    var childProcess = require("child_process");
    var bser = require_bser();
    var unilateralTags = ["subscription", "log"];
    function Client(options2) {
      var self = this;
      EE.call(this);
      this.watchmanBinaryPath = "watchman";
      if (options2 && options2.watchmanBinaryPath) {
        this.watchmanBinaryPath = options2.watchmanBinaryPath.trim();
      }
      ;
      this.commands = [];
    }
    util.inherits(Client, EE);
    module2.exports.Client = Client;
    Client.prototype.sendNextCommand = function() {
      if (this.currentCommand) {
        return;
      }
      this.currentCommand = this.commands.shift();
      if (!this.currentCommand) {
        return;
      }
      this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
    };
    Client.prototype.cancelCommands = function(why) {
      var error = new Error(why);
      var cmds = this.commands;
      this.commands = [];
      if (this.currentCommand) {
        cmds.unshift(this.currentCommand);
        this.currentCommand = null;
      }
      cmds.forEach(function(cmd) {
        cmd.cb(error);
      });
    };
    Client.prototype.connect = function() {
      var self = this;
      function makeSock(sockname) {
        self.bunser = new bser.BunserBuf();
        self.bunser.on("value", function(obj) {
          var unilateral = false;
          for (var i = 0; i < unilateralTags.length; i++) {
            var tag = unilateralTags[i];
            if (tag in obj) {
              unilateral = tag;
            }
          }
          if (unilateral) {
            self.emit(unilateral, obj);
          } else if (self.currentCommand) {
            var cmd = self.currentCommand;
            self.currentCommand = null;
            if ("error" in obj) {
              var error = new Error(obj.error);
              error.watchmanResponse = obj;
              cmd.cb(error);
            } else {
              cmd.cb(null, obj);
            }
          }
          self.sendNextCommand();
        });
        self.bunser.on("error", function(err) {
          self.emit("error", err);
        });
        self.socket = net2.createConnection(sockname);
        self.socket.on("connect", function() {
          self.connecting = false;
          self.emit("connect");
          self.sendNextCommand();
        });
        self.socket.on("error", function(err) {
          self.connecting = false;
          self.emit("error", err);
        });
        self.socket.on("data", function(buf) {
          if (self.bunser) {
            self.bunser.append(buf);
          }
        });
        self.socket.on("end", function() {
          self.socket = null;
          self.bunser = null;
          self.cancelCommands("The watchman connection was closed");
          self.emit("end");
        });
      }
      if (process.env.WATCHMAN_SOCK) {
        makeSock(process.env.WATCHMAN_SOCK);
        return;
      }
      var args = ["--no-pretty", "get-sockname"];
      var proc = null;
      var spawnFailed = false;
      function spawnError(error) {
        if (spawnFailed) {
          return;
        }
        spawnFailed = true;
        if (error.code === "EACCES" || error.errno === "EACCES") {
          error.message = "The Watchman CLI is installed but cannot be spawned because of a permission problem";
        } else if (error.code === "ENOENT" || error.errno === "ENOENT") {
          error.message = "Watchman was not found in PATH.  See https://facebook.github.io/watchman/docs/install.html for installation instructions";
        }
        console.error("Watchman: ", error.message);
        self.emit("error", error);
      }
      try {
        proc = childProcess.spawn(this.watchmanBinaryPath, args, {
          stdio: ["ignore", "pipe", "pipe"],
          windowsHide: true
        });
      } catch (error) {
        spawnError(error);
        return;
      }
      var stdout = [];
      var stderr = [];
      proc.stdout.on("data", function(data) {
        stdout.push(data);
      });
      proc.stderr.on("data", function(data) {
        data = data.toString("utf8");
        stderr.push(data);
        console.error(data);
      });
      proc.on("error", function(error) {
        spawnError(error);
      });
      proc.on("close", function(code, signal) {
        if (code !== 0) {
          spawnError(new Error(
            self.watchmanBinaryPath + " " + args.join(" ") + " returned with exit code=" + code + ", signal=" + signal + ", stderr= " + stderr.join("")
          ));
          return;
        }
        try {
          var obj = JSON.parse(stdout.join(""));
          if ("error" in obj) {
            var error = new Error(obj.error);
            error.watchmanResponse = obj;
            self.emit("error", error);
            return;
          }
          makeSock(obj.sockname);
        } catch (e) {
          self.emit("error", e);
        }
      });
    };
    Client.prototype.command = function(args, done) {
      done = done || function() {
      };
      this.commands.push({ cmd: args, cb: done });
      if (!this.socket) {
        if (!this.connecting) {
          this.connecting = true;
          this.connect();
          return;
        }
        return;
      }
      this.sendNextCommand();
    };
    var cap_versions = {
      "cmd-watch-del-all": "3.1.1",
      "cmd-watch-project": "3.1",
      "relative_root": "3.3",
      "term-dirname": "3.1",
      "term-idirname": "3.1",
      "wildmatch": "3.7"
    };
    function vers_compare(a, b) {
      a = a.split(".");
      b = b.split(".");
      for (var i = 0; i < 3; i++) {
        var d = parseInt(a[i] || "0") - parseInt(b[i] || "0");
        if (d != 0) {
          return d;
        }
      }
      return 0;
    }
    function have_cap(vers, name2) {
      if (name2 in cap_versions) {
        return vers_compare(vers, cap_versions[name2]) >= 0;
      }
      return false;
    }
    Client.prototype._synthesizeCapabilityCheck = function(resp, optional, required) {
      resp.capabilities = {};
      var version2 = resp.version;
      optional.forEach(function(name2) {
        resp.capabilities[name2] = have_cap(version2, name2);
      });
      required.forEach(function(name2) {
        var have = have_cap(version2, name2);
        resp.capabilities[name2] = have;
        if (!have) {
          resp.error = "client required capability `" + name2 + "` is not supported by this server";
        }
      });
      return resp;
    };
    Client.prototype.capabilityCheck = function(caps, done) {
      var optional = caps.optional || [];
      var required = caps.required || [];
      var self = this;
      this.command(["version", {
        optional,
        required
      }], function(error, resp) {
        if (error) {
          done(error);
          return;
        }
        if (!("capabilities" in resp)) {
          resp = self._synthesizeCapabilityCheck(resp, optional, required);
          if (resp.error) {
            error = new Error(resp.error);
            error.watchmanResponse = resp;
            done(error);
            return;
          }
        }
        done(null, resp);
      });
    };
    Client.prototype.end = function() {
      this.cancelCommands("The client was ended");
      if (this.socket) {
        this.socket.end();
        this.socket = null;
      }
      this.bunser = null;
    };
  }
});

// src/core/watchman.ts
function isValidWatchRoot(root) {
  if (root == "/" || root == "/tmp" || root == "/private/tmp")
    return false;
  if (isParentFolder(root, os.homedir(), true))
    return false;
  if (path.parse(root).base == root)
    return false;
  if (root.startsWith("/tmp/") || root.startsWith("/private/tmp/"))
    return false;
  if (isParentFolder(os.tmpdir(), root, true))
    return false;
  return true;
}
var logger13, requiredCapabilities, Watchman;
var init_watchman = __esm({
  "src/core/watchman.ts"() {
    "use strict";
    init_esm_node();
    init_logger();
    init_fs();
    init_node();
    logger13 = createLogger("core-watchman");
    requiredCapabilities = ["relative_root", "cmd-watch-project", "wildmatch", "field-new"];
    Watchman = class {
      constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        const watchman = require_fb_watchman();
        this.client = new watchman.Client({
          watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
      }
      checkCapability() {
        let { client } = this;
        return new Promise((resolve, reject) => {
          client.capabilityCheck({
            optional: [],
            required: requiredCapabilities
          }, (error, resp) => {
            if (error)
              return resolve(false);
            let { capabilities } = resp;
            for (let key of Object.keys(capabilities)) {
              if (!capabilities[key])
                return resolve(false);
            }
            resolve(true);
          });
        });
      }
      async watchProject(root) {
        let resp = await this.command(["watch-project", root]);
        let { watch, warning, relative_path } = resp;
        if (!watch)
          return false;
        if (warning)
          logger13.warn(warning);
        this.watch = watch;
        this.relative_path = relative_path;
        logger13.info(`watchman watching project: ${root}`);
        this.appendOutput(`watchman watching project: ${root}`);
        return true;
      }
      command(args) {
        return new Promise((resolve, reject) => {
          this.client.command(args, (error, resp) => {
            if (error)
              return reject(error);
            resolve(resp);
          });
        });
      }
      async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch)
          throw new Error("watchman not watching");
        let { clock } = await this.command(["clock", watch]);
        let uid = v1_default();
        let sub = {
          expression: ["allof", ["match", "**/*", "wholename"]],
          fields: ["name", "size", "new", "exists", "type", "mtime_ms", "ctime_ms"],
          since: clock
        };
        let root = watch;
        if (relative_path) {
          sub.relative_root = relative_path;
          root = path.join(watch, relative_path);
        }
        if (!this.client)
          return;
        let { subscribe } = await this.command(["subscribe", watch, uid, sub]);
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on("subscription", (resp) => {
          if (!resp || resp.subscription != uid)
            return;
          let { files } = resp;
          if (!files)
            return;
          files = files.filter((f) => f.type == "f" && minimatch(f.name, globPattern, { dot: true }));
          if (!files.length)
            return;
          let ev = Object.assign({}, resp);
          if (this.relative_path)
            ev.root = path.resolve(resp.root, this.relative_path);
          this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
          cb(ev);
        });
        return {
          dispose: () => {
            void this.unsubscribe(subscribe);
          },
          subscribe
        };
      }
      unsubscribe(subscription) {
        if (this._disposed)
          return Promise.resolve();
        let { watch } = this;
        if (!watch)
          return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(["unsubscribe", watch, subscription]).catch((e) => {
          var _a2;
          if ((_a2 = e.message) == null ? void 0 : _a2.includes("The client was ended"))
            logger13.error(e);
        });
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this.client) {
          this.client.end();
          this.client = void 0;
        }
      }
      appendOutput(message, type = "Info") {
        if (this.channel) {
          this.channel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
        }
      }
      static async createClient(binaryPath, root, channel) {
        if (!isValidWatchRoot(root))
          throw new Error(`Watch for ${root} is ignored`);
        let watchman;
        try {
          watchman = new Watchman(binaryPath, channel);
          let valid = await watchman.checkCapability();
          if (!valid)
            throw new Error("required capabilities do not exist.");
          let watching = await watchman.watchProject(root);
          if (!watching)
            throw new Error("unable to watch");
          return watchman;
        } catch (e) {
          if (watchman)
            watchman.dispose();
          throw e;
        }
      }
    };
  }
});

// src/core/fileSystemWatcher.ts
var logger14, _FileSystemWatcherManager, FileSystemWatcherManager, FileSystemWatcher;
var init_fileSystemWatcher = __esm({
  "src/core/fileSystemWatcher.ts"() {
    "use strict";
    init_esm();
    init_logger();
    init_util();
    init_array();
    init_fs();
    init_node();
    init_protocol();
    init_watchman();
    logger14 = createLogger("fileSystemWatcher");
    _FileSystemWatcherManager = class {
      constructor(workspaceFolder, watchmanPath) {
        this.workspaceFolder = workspaceFolder;
        this.watchmanPath = watchmanPath;
        this.clientsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.creating = /* @__PURE__ */ new Set();
        this._onDidCreateClient = new import_node3.Emitter();
        this.disabled = false;
        this.onDidCreateClient = this._onDidCreateClient.event;
      }
      attach(channel) {
        this.channel = channel;
        let createClient = (folder) => {
          let root = URI.parse(folder.uri).fsPath;
          void this.createClient(root);
        };
        this.workspaceFolder.workspaceFolders.forEach((folder) => {
          createClient(folder);
        });
        this.workspaceFolder.onDidChangeWorkspaceFolders((e) => {
          e.added.forEach((folder) => {
            createClient(folder);
          });
          e.removed.forEach((folder) => {
            let root = URI.parse(folder.uri).fsPath;
            let client = this.clientsMap.get(root);
            if (client) {
              this.clientsMap.delete(root);
              client.dispose();
            }
          });
        }, null, this.disposables);
      }
      waitClient(root) {
        if (this.clientsMap.has(root))
          return Promise.resolve();
        return new Promise((resolve) => {
          let disposable = this.onDidCreateClient((r) => {
            if (r == root) {
              disposable.dispose();
              resolve();
            }
          });
        });
      }
      async createClient(root) {
        if (this.watchmanPath == null || this.has(root) || this.disabled)
          return;
        try {
          let watchmanPath = await this.getWatchmanPath();
          this.creating.add(root);
          let client = await Watchman.createClient(watchmanPath, root, this.channel);
          this.creating.delete(root);
          this.clientsMap.set(root, client);
          for (let watcher of _FileSystemWatcherManager.watchers) {
            watcher.listen(root, client);
          }
          this._onDidCreateClient.fire(root);
        } catch (e) {
          this.creating.delete(root);
          if (this.channel)
            this.channel.appendLine(`Error on create watchman client: ${e}`);
        }
      }
      async getWatchmanPath() {
        let watchmanPath = this.watchmanPath;
        if (!process.env.WATCHMAN_SOCK) {
          watchmanPath = await which(this.watchmanPath, { all: false });
        }
        return watchmanPath;
      }
      has(root) {
        let curr = Array.from(this.clientsMap.keys());
        curr.push(...this.creating);
        return curr.some((r) => sameFile(r, root));
      }
      createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        let fileWatcher = new FileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        let base = typeof globPattern === "string" ? void 0 : globPattern.baseUri.fsPath;
        for (let [root, client] of this.clientsMap.entries()) {
          if (base && isParentFolder(root, base, true)) {
            base = void 0;
          }
          fileWatcher.listen(root, client);
        }
        if (base)
          void this.createClient(base);
        _FileSystemWatcherManager.watchers.add(fileWatcher);
        return fileWatcher;
      }
      dispose() {
        this._onDidCreateClient.dispose();
        for (let client of this.clientsMap.values()) {
          if (client)
            client.dispose();
        }
        this.clientsMap.clear();
        _FileSystemWatcherManager.watchers.clear();
        disposeAll(this.disposables);
      }
    };
    FileSystemWatcherManager = _FileSystemWatcherManager;
    FileSystemWatcherManager.watchers = /* @__PURE__ */ new Set();
    FileSystemWatcher = class {
      constructor(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new import_node3.Emitter();
        this._onDidChange = new import_node3.Emitter();
        this._onDidDelete = new import_node3.Emitter();
        this._onDidRename = new import_node3.Emitter();
        this.disposables = [];
        this._disposed = false;
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
        this._onDidListen = new import_node3.Emitter();
        this.onDidListen = this._onDidListen.event;
      }
      listen(root, client) {
        let {
          globPattern,
          ignoreCreateEvents,
          ignoreChangeEvents,
          ignoreDeleteEvents
        } = this;
        let pattern;
        let basePath;
        if (typeof globPattern === "string") {
          pattern = globPattern;
        } else {
          pattern = globPattern.pattern;
          basePath = globPattern.baseUri.fsPath;
          if (!isParentFolder(root, basePath, true))
            return;
        }
        const onChange = (change) => {
          let { root: root2, files } = change;
          if (basePath && !sameFile(root2, basePath)) {
            files = files.filter((f) => {
              if (f.type != "f")
                return false;
              let fullpath = path.join(root2, f.name);
              if (!isParentFolder(basePath, fullpath))
                return false;
              return minimatch(path.relative(basePath, fullpath), pattern, { dot: true });
            });
          } else {
            files = files.filter((f) => f.type == "f" && minimatch(f.name, pattern, { dot: true }));
          }
          for (let file of files) {
            let uri = URI.file(path.join(root2, file.name));
            if (!file.exists) {
              if (!ignoreDeleteEvents)
                this._onDidDelete.fire(uri);
            } else {
              if (file.new === true) {
                if (!ignoreCreateEvents)
                  this._onDidCreate.fire(uri);
              } else {
                if (!ignoreChangeEvents)
                  this._onDidChange.fire(uri);
              }
            }
          }
          if (files.length == 2 && files[0].exists !== files[1].exists) {
            let oldFile = files.find((o) => o.exists !== true);
            let newFile = files.find((o) => o.exists === true);
            if (oldFile.size == newFile.size) {
              this._onDidRename.fire({
                oldUri: URI.file(path.join(root2, oldFile.name)),
                newUri: URI.file(path.join(root2, newFile.name))
              });
            }
          }
          if (files.length > 2 && files.length % 2 == 0) {
            let [oldFiles, newFiles] = splitArray(files, (o) => o.exists === false);
            if (oldFiles.length == newFiles.length) {
              for (let oldFile of oldFiles) {
                let newFile = newFiles.find((o) => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                if (newFile) {
                  this._onDidRename.fire({
                    oldUri: URI.file(path.join(root2, oldFile.name)),
                    newUri: URI.file(path.join(root2, newFile.name))
                  });
                }
              }
            }
          }
        };
        client.subscribe(pattern, onChange).then((disposable) => {
          if (!disposable)
            return;
          this._onDidListen.fire();
          this.subscribe = disposable.subscribe;
          if (this._disposed)
            return disposable.dispose();
          this.disposables.push(disposable);
        }, (e) => {
          if (e instanceof Error && e.message.includes("client was ended"))
            return;
          logger14.error(`Error on subscribe ${pattern}`, e);
        });
      }
      dispose() {
        this._disposed = true;
        FileSystemWatcherManager.watchers.delete(this);
        this._onDidRename.dispose();
        this._onDidCreate.dispose();
        this._onDidChange.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/keymaps.ts
function getKeymapModifier(mode) {
  if (mode == "n" || mode == "o" || mode == "x" || mode == "v")
    return "<C-U>";
  if (mode == "i")
    return "<C-o>";
  if (mode == "s")
    return "<Esc>";
  return "";
}
function getBufnr(buffer) {
  return typeof buffer === "number" ? buffer : events_default.bufnr;
}
var logger15, Keymaps;
var init_keymaps = __esm({
  "src/core/keymaps.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_protocol();
    init_string();
    logger15 = createLogger("core-keymaps");
    Keymaps = class {
      constructor() {
        this.keymaps = /* @__PURE__ */ new Map();
      }
      attach(nvim) {
        this.nvim = nvim;
      }
      async doKeymap(key, defaultReturn) {
        let keymap = this.keymaps.get(key) ?? this.keymaps.get("coc-" + key);
        if (!keymap) {
          logger15.error(`keymap for ${key} not found`);
          return defaultReturn;
        }
        let [fn, repeat2] = keymap;
        let res = await Promise.resolve(fn());
        if (repeat2)
          await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
        return res ?? defaultReturn;
      }
      registerKeymap(modes, name2, fn, opts = {}) {
        if (!name2)
          throw new Error(`Invalid key ${name2} of registerKeymap`);
        let key = `coc-${name2}`;
        if (this.keymaps.has(key))
          throw new Error(`${name2} already exists.`);
        let lhs = `<Plug>(${key})`;
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? "request" : "notify";
        let cancel = opts.cancel ? 1 : 0;
        for (let mode of modes) {
          if (mode == "i") {
            nvim.setKeymap(mode, lhs, `coc#_insert_key('${method}', '${key}', ${cancel})`, {
              expr: true,
              noremap: true,
              silent: opts.silent
            });
          } else {
            nvim.setKeymap(mode, lhs, `:${getKeymapModifier(mode)}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, {
              noremap: true,
              silent: opts.silent
            });
          }
        }
        return import_node3.Disposable.create(() => {
          this.keymaps.delete(key);
          for (let m of modes) {
            nvim.deleteKeymap(m, lhs);
          }
        });
      }
      registerExprKeymap(mode, lhs, fn, buffer = false) {
        let bufnr = getBufnr(buffer);
        let id = `${mode}-${toBase64(lhs)}${buffer ? `-${bufnr}` : ""}`;
        let { nvim } = this;
        let rhs = mode == "i" ? `coc#_insert_key('request', '${id}')` : `coc#rpc#request('doKeymap', ['${id}'])`;
        let opts = { noremap: true, silent: true, expr: true, nowait: true };
        if (buffer) {
          nvim.createBuffer(bufnr).setKeymap(mode, lhs, rhs, opts);
        } else {
          nvim.setKeymap(mode, lhs, rhs, opts);
        }
        this.keymaps.set(id, [fn, false]);
        return import_node3.Disposable.create(() => {
          this.keymaps.delete(id);
          if (buffer) {
            nvim.createBuffer(bufnr).deleteKeymap(mode, lhs);
          } else {
            nvim.deleteKeymap(mode, lhs);
          }
        });
      }
      registerLocalKeymap(bufnr, mode, lhs, fn, notify) {
        let { nvim } = this;
        let buffer = nvim.createBuffer(bufnr);
        let id = `local-${bufnr}-${mode}-${toBase64(lhs)}`;
        this.keymaps.set(id, [fn, false]);
        let method = notify ? "notify" : "request";
        let modify2 = getKeymapModifier(mode);
        buffer.setKeymap(mode, lhs, `:${modify2}call coc#rpc#${method}('doKeymap', ['${id}'])<CR>`, {
          silent: true,
          nowait: true,
          noremap: true
        });
        return import_node3.Disposable.create(() => {
          this.keymaps.delete(id);
          buffer.deleteKeymap(mode, lhs);
        });
      }
    };
  }
});

// src/core/watchers.ts
var logger16, Watchers;
var init_watchers = __esm({
  "src/core/watchers.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_util();
    init_protocol();
    init_string();
    logger16 = createLogger("watchers");
    Watchers = class {
      constructor() {
        this.optionCallbacks = /* @__PURE__ */ new Map();
        this.globalCallbacks = /* @__PURE__ */ new Map();
        this.disposables = [];
        this._onDidRuntimePathChange = new import_node3.Emitter();
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        events_default.on("OptionSet", async (changed, oldValue, newValue) => {
          let cbs = Array.from(this.optionCallbacks.get(changed) ?? []);
          await Promise.allSettled(cbs.map((cb) => {
            return (async () => {
              try {
                await Promise.resolve(cb(oldValue, newValue));
              } catch (e) {
                this.nvim.errWriteLine(`Error on OptionSet '${changed}': ${toErrorText(e)}`);
                logger16.error(`Error on OptionSet callback:`, e);
              }
            })();
          }));
        }, null, this.disposables);
        events_default.on("GlobalChange", async (changed, oldValue, newValue) => {
          let cbs = Array.from(this.globalCallbacks.get(changed) ?? []);
          await Promise.allSettled(cbs.map((cb) => {
            return (async () => {
              try {
                await Promise.resolve(cb(oldValue, newValue));
              } catch (e) {
                this.nvim.errWriteLine(`Error on GlobalChange '${changed}': ${toErrorText(e)}`);
                logger16.error(`Error on GlobalChange callback:`, e);
              }
            })();
          }));
        }, null, this.disposables);
      }
      get options() {
        return Array.from(this.optionCallbacks.keys());
      }
      attach(nvim, env) {
        this.nvim = nvim;
        this.env = env;
        this.watchOption("runtimepath", (oldValue, newValue) => {
          let oldList = oldValue.split(",");
          let newList = newValue.split(",");
          let paths = newList.filter((x) => !oldList.includes(x));
          if (paths.length > 0) {
            this._onDidRuntimePathChange.fire(paths);
          }
          this.env.runtimepath = newValue;
        }, this.disposables);
      }
      watchOption(key, callback, disposables) {
        let cbs = this.optionCallbacks.get(key);
        if (!cbs) {
          cbs = /* @__PURE__ */ new Set();
          this.optionCallbacks.set(key, cbs);
        }
        cbs.add(callback);
        let cmd = `autocmd! coc_dynamic_option OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`;
        this.nvim.command(cmd, true);
        let disposable = import_node3.Disposable.create(() => {
          let cbs2 = this.optionCallbacks.get(key);
          cbs2.delete(callback);
          if (cbs2.size === 0)
            this.nvim.command(`autocmd! coc_dynamic_option OptionSet ${key}`, true);
        });
        if (disposables)
          disposables.push(disposable);
        return disposable;
      }
      watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        let cbs = this.globalCallbacks.get(key);
        if (!cbs) {
          cbs = /* @__PURE__ */ new Set();
          this.globalCallbacks.set(key, cbs);
        }
        cbs.add(callback);
        nvim.call("coc#_watch", key, true);
        let disposable = import_node3.Disposable.create(() => {
          let cbs2 = this.globalCallbacks.get(key);
          cbs2.delete(callback);
          if (cbs2.size === 0)
            nvim.call("coc#_unwatch", key, true);
        });
        if (disposables)
          disposables.push(disposable);
        return disposable;
      }
      dispose() {
        disposeAll(this.disposables);
        this._onDidRuntimePathChange.dispose();
      }
    };
  }
});

// src/core/workspaceFolder.ts
function toWorkspaceFolder(fsPath2) {
  if (!fsPath2 || !path.isAbsolute(fsPath2))
    return void 0;
  return {
    name: path.basename(fsPath2),
    uri: URI.file(fsPath2).toString()
  };
}
var PatternType, logger17, PatternTypes, checkPatternTimeout, extensionRegistry3, WorkspaceFolderController;
var init_workspaceFolder = __esm({
  "src/core/workspaceFolder.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_logger();
    init_util();
    init_array();
    init_errors();
    init_extensionRegistry();
    init_fs();
    init_node();
    init_object();
    init_protocol();
    init_registry();
    PatternType = /* @__PURE__ */ ((PatternType2) => {
      PatternType2[PatternType2["Buffer"] = 0] = "Buffer";
      PatternType2[PatternType2["LanguageServer"] = 1] = "LanguageServer";
      PatternType2[PatternType2["Global"] = 2] = "Global";
      return PatternType2;
    })(PatternType || {});
    logger17 = createLogger("core-workspaceFolder");
    PatternTypes = [0 /* Buffer */, 1 /* LanguageServer */, 2 /* Global */];
    checkPatternTimeout = getConditionValue(5e3, 50);
    extensionRegistry3 = Registry.as(Extensions.ExtensionContribution);
    WorkspaceFolderController = class {
      constructor(configurations) {
        this.configurations = configurations;
        this._onDidChangeWorkspaceFolders = new import_node3.Emitter();
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this.rootPatterns = /* @__PURE__ */ new Map();
        this._workspaceFolders = [];
        this._tokenSources = /* @__PURE__ */ new Set();
        events_default.on("VimLeavePre", this.cancelAll, this);
        this.updateConfiguration(true);
        this.configurations.onDidChange((e) => {
          if (e.affectsConfiguration("workspace") || e.affectsConfiguration("coc.preferences")) {
            this.updateConfiguration(false);
          }
        });
      }
      updateConfiguration(init) {
        const allConfig = this.configurations.initialConfiguration;
        let config = allConfig.get("workspace");
        let oldConfig = allConfig.get("coc.preferences.rootPatterns");
        this.config = {
          rootPatterns: isFalsyOrEmpty(oldConfig) ? toArray(config.rootPatterns) : oldConfig,
          ignoredFiletypes: toArray(config.ignoredFiletypes),
          bottomUpFiletypes: toArray(config.bottomUpFiletypes),
          ignoredFolders: toArray(config.ignoredFolders),
          workspaceFolderCheckCwd: !!config.workspaceFolderCheckCwd,
          workspaceFolderFallbackCwd: !!config.workspaceFolderFallbackCwd
        };
        if (init) {
          const lspConfig = allConfig.get("languageserver", {});
          this.addServerRootPatterns(lspConfig);
        }
      }
      addServerRootPatterns(lspConfig) {
        for (let key of Object.keys(toObject(lspConfig))) {
          let config = lspConfig[key];
          let { filetypes, rootPatterns } = config;
          if (Array.isArray(filetypes) && !isFalsyOrEmpty(rootPatterns)) {
            filetypes.filter((s) => typeof s === "string").forEach((filetype) => {
              this.addRootPattern(filetype, rootPatterns);
            });
          }
        }
      }
      cancelAll() {
        for (let tokenSource of this._tokenSources) {
          tokenSource.cancel();
        }
      }
      setWorkspaceFolders(folders) {
        if (!folders || !Array.isArray(folders))
          return;
        let arr = folders.map((f) => toWorkspaceFolder(f));
        this._workspaceFolders = arr.filter((o) => o != null);
      }
      getWorkspaceFolder(uri) {
        if (uri.scheme !== "file")
          return void 0;
        let folders = Array.from(this._workspaceFolders).map((o) => URI.parse(o.uri).fsPath);
        folders.sort((a, b) => b.length - a.length);
        let fsPath2 = uri.fsPath;
        let folder = folders.find((f) => isParentFolder(f, fsPath2, true));
        return toWorkspaceFolder(folder);
      }
      getRelativePath(pathOrUri, includeWorkspace) {
        let resource;
        let p = "";
        if (typeof pathOrUri === "string") {
          resource = URI.file(pathOrUri);
          p = pathOrUri;
        } else if (typeof pathOrUri !== "undefined") {
          resource = pathOrUri;
          p = pathOrUri.fsPath;
        }
        if (!resource)
          return p;
        const folder = this.getWorkspaceFolder(resource);
        if (!folder)
          return p;
        if (typeof includeWorkspace === "undefined" && this._workspaceFolders) {
          includeWorkspace = this._workspaceFolders.length > 1;
        }
        let result = path.relative(URI.parse(folder.uri).fsPath, resource.fsPath);
        result = result == "" ? resource.fsPath : result;
        if (includeWorkspace && folder.name) {
          result = `${folder.name}/${result}`;
        }
        return result;
      }
      get workspaceFolders() {
        return this._workspaceFolders;
      }
      addRootPattern(filetype, rootPatterns) {
        let patterns = this.rootPatterns.get(filetype) ?? [];
        for (let p of rootPatterns) {
          if (!patterns.includes(p)) {
            patterns.push(p);
          }
        }
        this.rootPatterns.set(filetype, patterns);
      }
      resolveRoot(document2, cwd2, fireEvent, expand2) {
        if (document2.buftype !== "" || document2.schema !== "file")
          return null;
        let u = URI.parse(document2.uri);
        let curr = this.getWorkspaceFolder(u);
        if (curr)
          return URI.parse(curr.uri).fsPath;
        let dir = path.dirname(u.fsPath);
        let { ignoredFiletypes, ignoredFolders, workspaceFolderCheckCwd, workspaceFolderFallbackCwd, bottomUpFiletypes } = this.config;
        if (ignoredFiletypes == null ? void 0 : ignoredFiletypes.includes(document2.filetype))
          return null;
        ignoredFolders = Array.isArray(ignoredFolders) ? ignoredFolders.filter((s) => s && s.length > 0).map((s) => expand2(s)) : [];
        let res = null;
        for (let patternType of PatternTypes) {
          let patterns = this.getRootPatterns(document2, patternType);
          if (patterns && patterns.length) {
            let isBottomUp = bottomUpFiletypes.includes("*") || bottomUpFiletypes.includes(document2.filetype);
            let root = resolveRoot(dir, patterns, cwd2, isBottomUp, workspaceFolderCheckCwd, ignoredFolders);
            if (root) {
              res = root;
              break;
            }
          }
        }
        if (workspaceFolderFallbackCwd && !res && !ignoredFolders.includes(cwd2) && isParentFolder(cwd2, dir, true)) {
          res = cwd2;
        }
        if (res)
          this.addWorkspaceFolder(res, fireEvent);
        return res;
      }
      addWorkspaceFolder(folder, fireEvent) {
        let workspaceFolder = toWorkspaceFolder(folder);
        if (!workspaceFolder)
          return void 0;
        if (this._workspaceFolders.findIndex((o) => o.uri == workspaceFolder.uri) == -1) {
          this._workspaceFolders.push(workspaceFolder);
          if (fireEvent) {
            this._onDidChangeWorkspaceFolders.fire({
              added: [workspaceFolder],
              removed: []
            });
          }
        }
        return workspaceFolder;
      }
      renameWorkspaceFolder(oldPath, newPath) {
        let added = toWorkspaceFolder(newPath);
        if (!added)
          return;
        let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == oldPath);
        if (idx == -1)
          return;
        let removed = this.workspaceFolders[idx];
        this._workspaceFolders.splice(idx, 1, added);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: [added]
        });
      }
      removeWorkspaceFolder(fsPath2) {
        let removed = toWorkspaceFolder(fsPath2);
        if (!removed)
          return;
        let idx = this._workspaceFolders.findIndex((f) => f.uri == removed.uri);
        if (idx == -1)
          return;
        this._workspaceFolders.splice(idx, 1);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: []
        });
      }
      getRootPatterns(document2, patternType) {
        if (patternType == 0 /* Buffer */)
          return document2.getVar("root_patterns", []) || [];
        if (patternType == 1 /* LanguageServer */)
          return this.getServerRootPatterns(document2.languageId);
        return this.config.rootPatterns;
      }
      reset() {
        this.rootPatterns.clear();
        this._workspaceFolders = [];
      }
      getServerRootPatterns(filetype) {
        let patterns = extensionRegistry3.getRootPatternsByFiletype(filetype);
        patterns = patterns.concat(toArray(this.rootPatterns.get(filetype)));
        return distinct(patterns);
      }
      checkFolder(dir, patterns, token) {
        return checkFolder(dir, patterns, token);
      }
      async checkPatterns(folders, patterns) {
        if (isFalsyOrEmpty(folders))
          return false;
        let dirs = folders.map((f) => URI.parse(f.uri).fsPath);
        let find = false;
        let tokenSource = new import_node3.CancellationTokenSource();
        this._tokenSources.add(tokenSource);
        let token = tokenSource.token;
        let timer = setTimeout(() => {
          tokenSource.cancel();
        }, checkPatternTimeout);
        let results = await Promise.allSettled(dirs.map((dir) => {
          return this.checkFolder(dir, patterns, token).then((checked) => {
            this._tokenSources.delete(tokenSource);
            if (checked) {
              find = true;
              clearTimeout(timer);
              tokenSource.cancel();
            }
          });
        }));
        clearTimeout(timer);
        results.forEach((res) => {
          if (res.status === "rejected" && !isCancellationError(res.reason)) {
            logger17.error(`checkPatterns error:`, patterns, res.reason);
          }
        });
        return find;
      }
    };
  }
});

// src/model/bufferSync.ts
var BufferSync;
var init_bufferSync = __esm({
  "src/model/bufferSync.ts"() {
    "use strict";
    init_events();
    init_util();
    BufferSync = class {
      constructor(_create, documents) {
        this._create = _create;
        this.disposables = [];
        this.itemsMap = /* @__PURE__ */ new Map();
        let { disposables } = this;
        for (let doc of documents.attached()) {
          this.create(doc);
        }
        documents.onDidOpenTextDocument((e) => {
          this.create(documents.getDocument(e.bufnr));
        }, null, disposables);
        documents.onDidChangeDocument((e) => {
          this.onChange(e);
        }, null, disposables);
        documents.onDidCloseDocument((e) => {
          this.delete(e.bufnr);
        }, null, disposables);
        events_default.on("LinesChanged", (bufnr) => {
          let o = this.itemsMap.get(bufnr);
          if (o && typeof o.item.onTextChange == "function") {
            o.item.onTextChange();
          }
        }, null, disposables);
      }
      get items() {
        return Array.from(this.itemsMap.values()).map((x) => x.item);
      }
      getItem(bufnr) {
        var _a2;
        if (typeof bufnr === "number") {
          return (_a2 = this.itemsMap.get(bufnr)) == null ? void 0 : _a2.item;
        }
        let o = Array.from(this.itemsMap.values()).find((v) => {
          return v.uri == bufnr;
        });
        return o ? o.item : void 0;
      }
      create(doc) {
        let o = this.itemsMap.get(doc.bufnr);
        if (o)
          o.item.dispose();
        let item = this._create(doc);
        if (item)
          this.itemsMap.set(doc.bufnr, { uri: doc.uri, item });
      }
      onChange(e) {
        let o = this.itemsMap.get(e.bufnr);
        if (o && typeof o.item.onChange == "function") {
          o.item.onChange(e);
        }
      }
      delete(bufnr) {
        let o = this.itemsMap.get(bufnr);
        if (o) {
          o.item.dispose();
          this.itemsMap.delete(bufnr);
        }
      }
      reset() {
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
      dispose() {
        disposeAll(this.disposables);
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this._create = void 0;
        this.itemsMap.clear();
      }
    };
  }
});

// src/model/db.ts
var DB;
var init_db = __esm({
  "src/model/db.ts"() {
    "use strict";
    init_node();
    init_object();
    DB = class {
      constructor(filepath) {
        this.filepath = filepath;
      }
      fetch(key) {
        let obj = this.load();
        if (!key)
          return obj;
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] === "undefined") {
            return void 0;
          }
          obj = obj[part];
        }
        return obj;
      }
      exists(key) {
        let obj = this.load();
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] === "undefined") {
            return false;
          }
          obj = obj[part];
        }
        return true;
      }
      delete(key) {
        let obj = this.load();
        let origin = obj;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          if (typeof obj[parts[i]] === "undefined") {
            break;
          }
          if (i == len - 1) {
            delete obj[parts[i]];
            fs.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), "utf8");
            break;
          }
          obj = obj[parts[i]];
        }
      }
      push(key, data) {
        let origin = toObject(this.load());
        let obj = origin;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          let key2 = parts[i];
          if (i == len - 1) {
            obj[key2] = data;
            let dir = path.dirname(this.filepath);
            fs.mkdirSync(dir, { recursive: true });
            fs.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
            break;
          }
          if (typeof obj[key2] == "undefined") {
            obj[key2] = {};
            obj = obj[key2];
          } else {
            obj = obj[key2];
          }
        }
      }
      load() {
        let dir = path.dirname(this.filepath);
        let exists = fs.existsSync(dir);
        if (!exists) {
          fs.mkdirSync(dir, { recursive: true });
          fs.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
        try {
          let content = fs.readFileSync(this.filepath, "utf8");
          return JSON.parse(content.trim());
        } catch (e) {
          fs.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
      }
      clear() {
        let exists = fs.existsSync(this.filepath);
        if (!exists)
          return;
        fs.writeFileSync(this.filepath, "{}", "utf8");
      }
      destroy() {
        if (fs.existsSync(this.filepath)) {
          fs.unlinkSync(this.filepath);
        }
      }
    };
  }
});

// src/model/status.ts
var frames, StatusLine;
var init_status = __esm({
  "src/model/status.ts"() {
    "use strict";
    init_esm_node();
    frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    StatusLine = class {
      constructor() {
        this.items = /* @__PURE__ */ new Map();
        this.shownIds = /* @__PURE__ */ new Set();
        this._text = "";
        this.interval = setInterval(() => {
          this.setStatusText();
        }, 100).unref();
      }
      dispose() {
        this.items.clear();
        this.shownIds.clear();
        clearInterval(this.interval);
      }
      reset() {
        this.items.clear();
        this.shownIds.clear();
      }
      createStatusBarItem(priority, isProgress = false) {
        let uid = v1_default();
        let item = {
          text: "",
          priority,
          isProgress,
          show: () => {
            this.shownIds.add(uid);
            this.setStatusText();
          },
          hide: () => {
            this.shownIds.delete(uid);
            this.setStatusText();
          },
          dispose: () => {
            this.shownIds.delete(uid);
            this.items.delete(uid);
            this.setStatusText();
          }
        };
        this.items.set(uid, item);
        return item;
      }
      getText() {
        if (this.shownIds.size == 0)
          return "";
        let d = new Date();
        let idx = Math.floor(d.getMilliseconds() / 100);
        let text = "";
        let items = [];
        for (let [id, item] of this.items) {
          if (this.shownIds.has(id)) {
            items.push(item);
          }
        }
        items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
          if (!item.isProgress) {
            text = `${text} ${item.text}`;
          } else {
            text = `${text} ${frames[idx]} ${item.text}`;
          }
        }
        return text;
      }
      setStatusText() {
        let text = this.getText();
        let { nvim } = this;
        if (text != this._text && nvim) {
          this._text = text;
          nvim.pauseNotification();
          this.nvim.setVar("coc_status", text, true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          nvim.resumeNotification(false, true);
        }
      }
    };
  }
});

// src/model/task.ts
var Task;
var init_task = __esm({
  "src/model/task.ts"() {
    "use strict";
    init_events();
    init_util();
    init_protocol();
    Task = class {
      constructor(nvim, id) {
        this.nvim = nvim;
        this.id = id;
        this.disposables = [];
        this._onExit = new import_node3.Emitter();
        this._onStderr = new import_node3.Emitter();
        this._onStdout = new import_node3.Emitter();
        this.onExit = this._onExit.event;
        this.onStdout = this._onStdout.event;
        this.onStderr = this._onStderr.event;
        events_default.on("TaskExit", (id2, code) => {
          if (id2 == this.id) {
            this._onExit.fire(code);
          }
        }, null, this.disposables);
        events_default.on("TaskStderr", (id2, lines) => {
          if (id2 == this.id) {
            this._onStderr.fire(lines);
          }
        }, null, this.disposables);
        events_default.on("TaskStdout", (id2, lines) => {
          if (id2 == this.id) {
            this._onStdout.fire(lines);
          }
        }, null, this.disposables);
      }
      async start(opts) {
        let { nvim } = this;
        return await nvim.call("coc#task#start", [this.id, opts]);
      }
      async stop() {
        let { nvim } = this;
        await nvim.call("coc#task#stop", [this.id]);
      }
      get running() {
        let { nvim } = this;
        return nvim.call("coc#task#running", [this.id]);
      }
      dispose() {
        let { nvim } = this;
        nvim.call("coc#task#stop", [this.id], true);
        this._onStdout.dispose();
        this._onStderr.dispose();
        this._onExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/workspace.ts
var logger18, methods, Workspace, workspace_default;
var init_workspace = __esm({
  "src/workspace.ts"() {
    "use strict";
    init_esm();
    init_configuration2();
    init_shape();
    init_autocmds();
    init_channels();
    init_contentProvider();
    init_documents();
    init_editors();
    init_files();
    init_fileSystemWatcher();
    init_funcs();
    init_keymaps();
    init_ui();
    init_watchers();
    init_workspaceFolder();
    init_events();
    init_logger();
    init_bufferSync();
    init_db();
    init_fuzzyMatch();
    init_mru();
    init_status();
    init_strwidth();
    init_task();
    init_constants();
    init_extensionRegistry();
    init_node();
    init_object();
    init_processes();
    logger18 = createLogger("workspace");
    methods = [
      "showMessage",
      "runTerminalCommand",
      "openTerminal",
      "showQuickpick",
      "menuPick",
      "openLocalConfig",
      "showPrompt",
      "createStatusBarItem",
      "createOutputChannel",
      "showOutputChannel",
      "requestInput",
      "echoLines",
      "getCursorPosition",
      "moveTo",
      "getOffset",
      "getSelectedRange",
      "selectRange",
      "createTerminal"
    ];
    Workspace = class {
      constructor() {
        this.statusLine = new StatusLine();
        void initFuzzyWasm().then((api) => {
          this.fuzzyExports = api;
        });
        void StrWidth.create().then((strWdith) => {
          this.strWdith = strWdith;
        });
        events_default.on("VimResized", (columns, lines) => {
          Object.assign(toObject(this.env), { columns, lines });
        });
        Object.defineProperty(this.statusLine, "nvim", {
          get: () => this.nvim
        });
        let configurations = this.configurations = new Configurations(userConfigFile, new ConfigurationProxy(this));
        this.workspaceFolderControl = new WorkspaceFolderController(this.configurations);
        let documents = this.documentsManager = new Documents(this.configurations, this.workspaceFolderControl);
        this.contentProvider = new ContentProvider(documents);
        this.watchers = new Watchers();
        this.autocmds = new Autocmds();
        this.keymaps = new Keymaps();
        this.files = new Files(documents, this.configurations, this.workspaceFolderControl, this.keymaps);
        this.editors = new Editors(documents);
        this.onDidRuntimePathChange = this.watchers.onDidRuntimePathChange;
        this.onDidChangeWorkspaceFolders = this.workspaceFolderControl.onDidChangeWorkspaceFolders;
        this.onDidChangeConfiguration = this.configurations.onDidChange;
        this.onDidOpenTextDocument = documents.onDidOpenTextDocument;
        this.onDidChangeTextDocument = documents.onDidChangeDocument;
        this.onDidCloseTextDocument = documents.onDidCloseDocument;
        this.onDidSaveTextDocument = documents.onDidSaveTextDocument;
        this.onWillSaveTextDocument = documents.onWillSaveTextDocument;
        this.onDidCreateFiles = this.files.onDidCreateFiles;
        this.onDidRenameFiles = this.files.onDidRenameFiles;
        this.onDidDeleteFiles = this.files.onDidDeleteFiles;
        this.onWillCreateFiles = this.files.onWillCreateFiles;
        this.onWillRenameFiles = this.files.onWillRenameFiles;
        this.onWillDeleteFiles = this.files.onWillDeleteFiles;
        const preferences = configurations.initialConfiguration.get("coc.preferences");
        const watchmanPath = preferences.watchmanPath ?? watchmanCommand;
        this.fileSystemWatchers = new FileSystemWatcherManager(this.workspaceFolderControl, watchmanPath);
      }
      get initialConfiguration() {
        return this.configurations.initialConfiguration;
      }
      async init(window2) {
        let { nvim } = this;
        for (let method of methods) {
          Object.defineProperty(this, method, {
            get: () => {
              return (...args) => {
                let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
                logger18.warn(`workspace.${method} is deprecated, please use window.${method} instead.`, stack);
                return window2[method].apply(window2, args);
              };
            }
          });
        }
        for (let name2 of ["onDidOpenTerminal", "onDidCloseTerminal"]) {
          Object.defineProperty(this, name2, {
            get: () => {
              let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
              logger18.warn(`workspace.${name2} is deprecated, please use window.${name2} instead.`, stack);
              return window2[name2];
            }
          });
        }
        let env = this._env = await nvim.call("coc#util#vim_info");
        window2.init(env);
        this.checkVersion(APIVERSION);
        this.configurations.updateMemoryConfig(this._env.config);
        this.workspaceFolderControl.setWorkspaceFolders(this._env.workspaceFolders);
        this.workspaceFolderControl.onDidChangeWorkspaceFolders(() => {
          nvim.setVar("WorkspaceFolders", this.folderPaths, true);
        });
        this.files.attach(nvim, env, window2);
        this.contentProvider.attach(nvim);
        this.keymaps.attach(nvim);
        this.autocmds.attach(nvim, env);
        this.watchers.attach(nvim, env);
        await this.documentsManager.attach(this.nvim, this._env);
        await this.editors.attach(nvim);
        let channel = channels_default.create("watchman", nvim);
        this.fileSystemWatchers.attach(channel);
        if (this.strWdith)
          this.strWdith.setAmbw(!env.ambiguousIsNarrow);
      }
      checkVersion(version2) {
        if (this._env.apiversion != version2) {
          this.nvim.echoError(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);
        }
      }
      getDisplayWidth(text, cache = false) {
        return this.strWdith.getWidth(text, cache);
      }
      get version() {
        return VERSION;
      }
      get cwd() {
        return this.documentsManager.cwd;
      }
      get env() {
        return this._env;
      }
      get root() {
        return this.documentsManager.root || this.cwd;
      }
      get rootPath() {
        return this.root;
      }
      get bufnr() {
        return this.documentsManager.bufnr;
      }
      get insertMode() {
        return events_default.insertMode;
      }
      get floatSupported() {
        return true;
      }
      get uri() {
        return this.documentsManager.uri;
      }
      get workspaceFolder() {
        return this.workspaceFolders[0];
      }
      get textDocuments() {
        return this.documentsManager.textDocuments;
      }
      get documents() {
        return this.documentsManager.documents;
      }
      get document() {
        return this.documentsManager.document;
      }
      get workspaceFolders() {
        return this.workspaceFolderControl.workspaceFolders;
      }
      checkPatterns(patterns, folders) {
        return this.workspaceFolderControl.checkPatterns(folders ?? this.workspaceFolderControl.workspaceFolders, patterns);
      }
      get folderPaths() {
        return this.workspaceFolders.map((f) => URI.parse(f.uri).fsPath);
      }
      get channelNames() {
        return channels_default.names;
      }
      get pluginRoot() {
        return pluginRoot;
      }
      get isVim() {
        return this._env.isVim;
      }
      get isNvim() {
        return !this._env.isVim;
      }
      get completeOpt() {
        return "";
      }
      get filetypes() {
        return this.documentsManager.filetypes;
      }
      get languageIds() {
        return this.documentsManager.languageIds;
      }
      createNameSpace(name2) {
        return createNameSpace(name2);
      }
      has(feature) {
        return has(this.env, feature);
      }
      registerAutocmd(autocmd) {
        if (autocmd.request && autocmd.event !== "BufWritePre") {
          let name2 = parseExtensionName(Error().stack);
          logger18.warn(`Extension "${name2}" registered synchronized autocmd "${autocmd.event}", which could be slow.`);
        }
        return this.autocmds.registerAutocmd(autocmd);
      }
      watchOption(key, callback, disposables) {
        return this.watchers.watchOption(key, callback, disposables);
      }
      watchGlobal(key, callback, disposables) {
        let cb = callback ?? function() {
        };
        return this.watchers.watchGlobal(key, cb, disposables);
      }
      match(selector, document2) {
        return score(selector, document2.uri, document2.languageId);
      }
      createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        return this.fileSystemWatchers.createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete);
      }
      createFuzzyMatch() {
        return new FuzzyMatch(this.fuzzyExports);
      }
      getWatchmanPath() {
        return getWatchmanPath(this.configurations);
      }
      getConfiguration(section2, scope) {
        return this.configurations.getConfiguration(section2, scope);
      }
      resolveJSONSchema(uri) {
        return this.configurations.getJSONSchema(uri);
      }
      getDocument(uri) {
        return this.documentsManager.getDocument(uri);
      }
      hasDocument(uri, version2) {
        let doc = this.documentsManager.getDocument(uri);
        return doc != null && (version2 != null ? doc.version == version2 : true);
      }
      getUri(bufnr, defaultValue2 = "") {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc ? doc.uri : defaultValue2;
      }
      isAttached(bufnr) {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc != null && doc.attached;
      }
      getAttachedDocument(uri) {
        let doc = this.getDocument(uri);
        if (!doc)
          throw new Error(`Buffer ${uri} not created.`);
        if (!doc.attached)
          throw new Error(`Buffer ${uri} not attached, ${doc.notAttachReason}`);
        return doc;
      }
      getQuickfixItem(loc, text, type = "", module2) {
        return this.documentsManager.getQuickfixItem(loc, text, type, module2);
      }
      createMru(name2) {
        return new Mru(name2);
      }
      async getQuickfixList(locations) {
        return this.documentsManager.getQuickfixList(locations);
      }
      async showLocations(locations) {
        await this.documentsManager.showLocations(locations);
      }
      getLine(uri, line) {
        return this.documentsManager.getLine(uri, line);
      }
      getWorkspaceFolder(uri) {
        return this.workspaceFolderControl.getWorkspaceFolder(URI.parse(uri));
      }
      readFile(uri) {
        return this.documentsManager.readFile(uri);
      }
      async getCurrentState() {
        let document2 = await this.document;
        let position = await getCursorPosition(this.nvim);
        return {
          document: document2.textDocument,
          position
        };
      }
      async getFormatOptions(uri) {
        return this.documentsManager.getFormatOptions(uri);
      }
      resolveModule(name2) {
        return resolveModule(name2);
      }
      async runCommand(cmd, cwd2, timeout2) {
        return runCommand(cmd, { cwd: cwd2 ?? this.cwd }, timeout2);
      }
      expand(filepath) {
        return this.documentsManager.expand(filepath);
      }
      async callAsync(method, args) {
        return await callAsync(this.nvim, method, args);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        return this.contentProvider.registerTextDocumentContentProvider(scheme, provider);
      }
      registerKeymap(modes, key, fn, opts = {}) {
        return this.keymaps.registerKeymap(modes, key, fn, opts);
      }
      registerExprKeymap(mode, key, fn, buffer = false) {
        return this.keymaps.registerExprKeymap(mode, key, fn, buffer);
      }
      registerLocalKeymap(bufnr, mode, key, fn, notify = false) {
        if (typeof arguments[0] === "string") {
          bufnr = this.bufnr;
          mode = arguments[0];
          key = arguments[1];
          fn = arguments[2];
          notify = arguments[3] ?? false;
        }
        return this.keymaps.registerLocalKeymap(bufnr, mode, key, fn, notify);
      }
      createTask(id) {
        return new Task(this.nvim, id);
      }
      createDatabase(name2) {
        return new DB(path.join(dataHome, name2 + ".json"));
      }
      registerBufferSync(create) {
        return new BufferSync(create, this.documentsManager);
      }
      async attach() {
        await this.documentsManager.attach(this.nvim, this._env);
      }
      jumpTo(uri, position, openCommand) {
        return this.files.jumpTo(uri, position, openCommand);
      }
      findUp(filename) {
        return findUp2(this.nvim, this.cwd, filename);
      }
      applyEdit(edit2) {
        return this.files.applyEdit(edit2);
      }
      createFile(filepath, opts = {}) {
        return this.files.createFile(filepath, opts);
      }
      loadFile(uri, cmd) {
        return this.files.loadResource(uri, cmd);
      }
      async loadFiles(uris) {
        return this.files.loadResources(uris);
      }
      async renameFile(oldPath, newPath, opts = {}) {
        await this.files.renameFile(oldPath, newPath, opts);
      }
      async deleteFile(filepath, opts = {}) {
        await this.files.deleteFile(filepath, opts);
      }
      async openResource(uri) {
        await this.files.openResource(uri);
      }
      async computeWordRanges(uri, range, token) {
        let doc = this.getDocument(uri);
        if (!doc)
          return null;
        return await doc.chars.computeWordRanges(doc.textDocument.lines, range, token);
      }
      openTextDocument(uri) {
        return this.files.openTextDocument(uri);
      }
      getRelativePath(pathOrUri, includeWorkspace) {
        return this.workspaceFolderControl.getRelativePath(pathOrUri, includeWorkspace);
      }
      async findFiles(include, exclude, maxResults, token) {
        return this.files.findFiles(include, exclude, maxResults, token);
      }
      detach() {
        this.documentsManager.detach();
      }
      reset() {
        this.statusLine.reset();
        this.configurations.reset();
        this.workspaceFolderControl.reset();
        this.documentsManager.reset();
      }
      dispose() {
        this.autocmds.dispose();
        this.statusLine.dispose();
        this.watchers.dispose();
        this.contentProvider.dispose();
        this.documentsManager.dispose();
        this.configurations.dispose();
      }
    };
    workspace_default = new Workspace();
  }
});

// src/tree/filter.ts
var sessionKey, HistoryInput, Filter;
var init_filter2 = __esm({
  "src/tree/filter.ts"() {
    "use strict";
    init_events();
    init_protocol();
    init_util();
    sessionKey = "filter";
    HistoryInput = class {
      constructor() {
        this.history = [];
      }
      next(input) {
        let idx = this.history.indexOf(input);
        return this.history[idx + 1] ?? this.history[0];
      }
      previous(input) {
        let idx = this.history.indexOf(input);
        return this.history[idx - 1] ?? this.history[this.history.length - 1];
      }
      add(input) {
        let idx = this.history.indexOf(input);
        if (idx !== -1) {
          this.history.splice(idx, 1);
        }
        this.history.unshift(input);
      }
      toJSON() {
        return `[${this.history.join(",")}]`;
      }
    };
    Filter = class {
      constructor(nvim, keys) {
        this.nvim = nvim;
        this._activated = false;
        this.history = new HistoryInput();
        this.disposables = [];
        this._onDidUpdate = new import_node3.Emitter();
        this._onDidExit = new import_node3.Emitter();
        this._onDidKeyPress = new import_node3.Emitter();
        this.onDidKeyPress = this._onDidKeyPress.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.onDidExit = this._onDidExit.event;
        this.text = "";
        events_default.on("InputChar", (session, character) => {
          if (session !== sessionKey || !this._activated)
            return;
          if (!keys.includes(character)) {
            if (character.length == 1) {
              this.text = this.text + character;
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<bs>" || character == "<C-h>") {
              this.text = this.text.slice(0, -1);
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-u>") {
              this.text = "";
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-n>") {
              let text = this.history.next(this.text);
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
              return;
            }
            if (character == "<C-p>") {
              let text = this.history.previous(this.text);
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
            }
            if (character == "<esc>" || character == "<C-o>") {
              this.deactivate();
              return;
            }
          }
          this._onDidKeyPress.fire(character);
        }, null, this.disposables);
      }
      active() {
        this._activated = true;
        this.text = "";
        this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
      }
      deactivate(node) {
        if (!this._activated)
          return;
        this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
        this._activated = false;
        let { text } = this;
        this.text = "";
        this._onDidExit.fire(node);
        this.history.add(text);
      }
      get activated() {
        return this._activated;
      }
      dispose() {
        this.deactivate();
        this._onDidKeyPress.dispose();
        this._onDidUpdate.dispose();
        this._onDidExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/TreeItem.ts
function getItemLabel(item) {
  return TreeItemLabel.is(item.label) ? item.label.label : item.label;
}
var TreeItemLabel, TreeItemCollapsibleState, TreeItem;
var init_TreeItem = __esm({
  "src/tree/TreeItem.ts"() {
    "use strict";
    init_esm();
    init_node();
    ((TreeItemLabel3) => {
      function is(obj) {
        return typeof obj.label == "string";
      }
      TreeItemLabel3.is = is;
    })(TreeItemLabel || (TreeItemLabel = {}));
    TreeItemCollapsibleState = /* @__PURE__ */ ((TreeItemCollapsibleState2) => {
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["None"] = 0] = "None";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Collapsed"] = 1] = "Collapsed";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Expanded"] = 2] = "Expanded";
      return TreeItemCollapsibleState2;
    })(TreeItemCollapsibleState || {});
    TreeItem = class {
      constructor(label, collapsibleState = 0 /* None */) {
        this.collapsibleState = collapsibleState;
        if (URI.isUri(label)) {
          this.resourceUri = label;
          this.label = path.basename(label.path);
          this.id = label.toString();
        } else {
          this.label = label;
        }
      }
    };
  }
});

// src/tree/TreeView.ts
var TreeView_exports = {};
__export(TreeView_exports, {
  default: () => BasicTreeView
});
var logger19, retryTimeout, maxRetry, highlightNamespace, signOffset, globalId, BasicTreeView;
var init_TreeView = __esm({
  "src/tree/TreeView.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_logger();
    init_fuzzyMatch();
    init_util();
    init_array();
    init_filter();
    init_mutex();
    init_object();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_filter2();
    init_TreeItem();
    logger19 = createLogger("BasicTreeView");
    retryTimeout = getConditionValue(500, 10);
    maxRetry = getConditionValue(5, 1);
    highlightNamespace = "tree";
    signOffset = 3e3;
    globalId = 1;
    BasicTreeView = class {
      constructor(viewId, opts) {
        this.viewId = viewId;
        this.opts = opts;
        this._selection = [];
        this._keymapDefs = [];
        this._onDispose = new import_node3.Emitter();
        this._onDidRefrash = new import_node3.Emitter();
        this._onDidExpandElement = new import_node3.Emitter();
        this._onDidCollapseElement = new import_node3.Emitter();
        this._onDidChangeSelection = new import_node3.Emitter();
        this._onDidChangeVisibility = new import_node3.Emitter();
        this._onDidFilterStateChange = new import_node3.Emitter();
        this._onDidCursorMoved = new import_node3.Emitter();
        this.onDidRefrash = this._onDidRefrash.event;
        this.onDispose = this._onDispose.event;
        this.onDidExpandElement = this._onDidExpandElement.event;
        this.onDidCollapseElement = this._onDidCollapseElement.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.onDidFilterStateChange = this._onDidFilterStateChange.event;
        this.onDidCursorMoved = this._onDidCursorMoved.event;
        this.retryTimers = 0;
        this.renderedItems = [];
        this.nodesMap = /* @__PURE__ */ new Map();
        this.mutex = new Mutex();
        this.disposables = [];
        this.lineState = { titleCount: 0, messageCount: 0 };
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        if (opts.enableFilter) {
          this.filter = new Filter(this.nvim, [this.keys.selectNext, this.keys.selectPrevious, this.keys.invoke]);
        }
        let id = globalId;
        globalId = globalId + 1;
        this.bufname = `CocTree${id}`;
        this.tooltipFactory = window_default.createFloatFactory({ modes: ["n"] });
        this.provider = opts.treeDataProvider;
        this.leafIndent = opts.disableLeafIndent !== true;
        this.winfixwidth = opts.winfixwidth !== false;
        this.autoWidth = opts.autoWidth === true;
        let message;
        Object.defineProperty(this, "message", {
          set: (msg) => {
            message = msg ? msg.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return message;
          }
        });
        let title = viewId.replace(/\r?\n/g, " ");
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            title = newTitle ? newTitle.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return title;
          }
        });
        let description;
        Object.defineProperty(this, "description", {
          set: (desc) => {
            description = desc ? desc.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return description;
          }
        });
        let filterText;
        Object.defineProperty(this, "filterText", {
          set: (text) => {
            let { titleCount, messageCount } = this.lineState;
            let start = titleCount + messageCount;
            if (text != null) {
              let highlights = [{
                lnum: start,
                colStart: byteLength(text),
                colEnd: byteLength(text) + 1,
                hlGroup: "Cursor"
              }];
              this.renderedItems = [];
              this.updateUI([text + " "], highlights, start, -1, true);
              void this.doFilter(text);
            } else if (filterText != null) {
              this.updateUI([], [], start, start + 1);
            }
            filterText = text;
          },
          get: () => {
            return filterText;
          }
        });
        if (this.provider.onDidChangeTreeData) {
          this.provider.onDidChangeTreeData(this.onDataChange, this, this.disposables);
        }
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          let isVisible = this.winid != null;
          this.winid = void 0;
          this.bufnr = void 0;
          if (isVisible)
            this._onDidChangeVisibility.fire({ visible: false });
          this.dispose();
        }, null, this.disposables);
        events_default.on("WinClosed", (winid) => {
          if (this.winid === winid) {
            this.winid = void 0;
            this._onDidChangeVisibility.fire({ visible: false });
          }
        }, null, this.disposables);
        events_default.on("BufWinLeave", (bufnr, winid) => {
          if (bufnr == this.bufnr && winid == this.winid) {
            this.winid = void 0;
            this._onDidChangeVisibility.fire({ visible: false });
          }
        }, null, this.disposables);
        window_default.onDidTabClose((id2) => {
          if (this._targetTabId === id2) {
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr, cursor) => {
          if (bufnr != this.bufnr)
            return;
          await this.onHover(cursor[0]);
        }, null, this.disposables);
        events_default.on(["CursorMoved", "BufEnter"], () => {
          this.cancelResolve();
        }, null, this.disposables);
        events_default.on("CursorMoved", (bufnr, cursor) => {
          if (bufnr == this.bufnr) {
            let element = this.getElementByLnum(cursor[0] - 1);
            this._onDidCursorMoved.fire(element);
          }
        }, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          if (winid != this.windowId || !this.filtering)
            return;
          let buf = this.nvim.createBuffer(this.bufnr);
          let line = this.startLnum - 1;
          let len = toText(this.filterText).length;
          let range = Range.create(line, len, line, len + 1);
          buf.highlightRanges(highlightNamespace, "Cursor", [range]);
          this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
          this.redraw();
        }, null, this.disposables);
        events_default.on("WinLeave", (winid) => {
          if (winid != this.windowId || !this.filtering)
            return;
          let buf = this.nvim.createBuffer(this.bufnr);
          this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
          buf.clearNamespace(highlightNamespace, this.startLnum - 1, this.startLnum);
        }, null, this.disposables);
        this.disposables.push(this._onDidChangeVisibility, this._onDidCursorMoved, this._onDidChangeSelection, this._onDidCollapseElement, this._onDidExpandElement);
        if (this.filter) {
          this.filter.onDidExit((node) => {
            this.nodesMap.clear();
            this.filterText = void 0;
            this.itemsToFilter = void 0;
            if (node && typeof this.provider.getParent === "function") {
              this.renderedItems = [];
              void this.reveal(node, { focus: true });
            } else {
              this.clearSelection();
              void this.render();
            }
            this._onDidFilterStateChange.fire(false);
          });
          this.filter.onDidUpdate((text) => {
            this.filterText = text;
          });
          this.filter.onDidKeyPress(async (character) => {
            var _a2, _b;
            let items = toArray(this.renderedItems);
            let curr = this.selection[0];
            if (character == "<up>" || character == this.keys.selectPrevious) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == 0 ? items.length - 1 : idx - 1;
              let node = (_a2 = items[index]) == null ? void 0 : _a2.node;
              if (node)
                this.selectItem(node, true);
            }
            if (character == "<down>" || character == this.keys.selectNext) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == items.length - 1 ? 0 : idx + 1;
              let node = (_b = items[index]) == null ? void 0 : _b.node;
              if (node)
                this.selectItem(node, true);
            }
            if (character == "<cr>" || character == this.keys.invoke) {
              if (!curr)
                return;
              await this.invokeCommand(curr);
              this.filter.deactivate(curr);
            }
          });
        }
      }
      get windowId() {
        return this.winid;
      }
      get targetTabId() {
        return this._targetTabId;
      }
      get targetWinId() {
        return this._targetWinId;
      }
      get targetBufnr() {
        return this._targetBufnr;
      }
      get startLnum() {
        let filterCount = this.filterText == null ? 0 : 1;
        return this.lineState.messageCount + this.lineState.titleCount + filterCount;
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get filtering() {
        return this.filter != null && this.filter.activated;
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("tree")) {
          let config = workspace_default.getConfiguration("tree", null);
          this.config = {
            openedIcon: config.get("openedIcon", " "),
            closedIcon: config.get("closedIcon", " ")
          };
          this.keys = {
            close: config.get("key.close"),
            invoke: config.get("key.invoke"),
            toggle: config.get("key.toggle"),
            actions: config.get("key.actions"),
            collapseAll: config.get("key.collapseAll"),
            toggleSelection: config.get("key.toggleSelection"),
            activeFilter: config.get("key.activeFilter"),
            selectNext: config.get("key.selectNext"),
            selectPrevious: config.get("key.selectPrevious")
          };
          if (e && this.visible) {
            void this.render();
          }
        }
      }
      async doFilter(text) {
        let items = [];
        let index = 0;
        let release = await this.mutex.acquire();
        try {
          if (!this.itemsToFilter) {
            let itemsToFilter = [];
            const addNodes = async (nodes2) => {
              for (let n of nodes2) {
                itemsToFilter.push(n);
                let arr = await Promise.resolve(this.provider.getChildren(n));
                if (!isFalsyOrEmpty(arr))
                  await addNodes(arr);
              }
            };
            let nodes = await Promise.resolve(this.provider.getChildren());
            await addNodes(nodes);
            this.itemsToFilter = itemsToFilter;
          }
          let lowInput = text.toLowerCase();
          let emptyInput = text.length === 0;
          for (let n of this.itemsToFilter) {
            let item = await this.getTreeItem(n);
            let label = getItemLabel(item);
            let score3 = 0;
            if (!emptyInput) {
              let res = fuzzyScoreGracefulAggressive(text, lowInput, 0, label, label.toLowerCase(), 0, { boostFullMatch: true, firstMatchCanBeWeak: true });
              if (!res)
                continue;
              score3 = res[0];
              item.label = { label, highlights: toSpans(label, res) };
            } else {
              item.label = { label, highlights: [] };
            }
            item.collapsibleState = 0 /* None */;
            let { line, highlights: highlights2 } = this.getRenderedLine(item, index, 0);
            items.push({
              level: 0,
              node: n,
              line,
              index,
              score: score3,
              highlights: highlights2
            });
            index += 1;
          }
          items.sort((a, b) => {
            if (a.score != b.score)
              return b.score - a.score;
            return a.index - b.index;
          });
          let lnum = this.startLnum;
          let highlights = [];
          let renderedItems = this.renderedItems = items.map((o, idx) => {
            highlights.push(...o.highlights.map((h) => {
              h.lnum = lnum + idx;
              return h;
            }));
            delete o.index;
            delete o.score;
            delete o.highlights;
            return o;
          });
          this.updateUI(renderedItems.map((o) => o.line), highlights, lnum, -1, true);
          if (renderedItems.length) {
            this.selectItem(renderedItems[0].node, true);
          } else {
            this.clearSelection();
          }
          this.redraw();
          release();
        } catch (e) {
          release();
          logger19.error(`Error on tree filter:`, e);
        }
      }
      async onHover(lnum) {
        let element = this.getElementByLnum(lnum - 1);
        if (!element || !this.nodesMap.has(element))
          return;
        let obj = this.nodesMap.get(element);
        let item = obj.item;
        if (!item.tooltip && !obj.resolved)
          item = await this.resolveItem(element, item);
        if (!item.tooltip)
          return;
        let isMarkdown2 = MarkupContent.is(item.tooltip) && item.tooltip.kind == MarkupKind.Markdown;
        let doc = {
          filetype: isMarkdown2 ? "markdown" : "txt",
          content: MarkupContent.is(item.tooltip) ? item.tooltip.value : item.tooltip
        };
        await this.tooltipFactory.show([doc]);
      }
      async onClick(element) {
        let { nvim } = this;
        let [line, col] = await nvim.eval(`[getline('.'),col('.')]`);
        let pre = byteSlice(line, 0, col - 1);
        let character = line[pre.length];
        let { openedIcon, closedIcon } = this.config;
        if (/^\s*$/.test(pre) && [openedIcon, closedIcon].includes(character)) {
          await this.toggleExpand(element);
        } else {
          await this.invokeCommand(element);
        }
      }
      async invokeCommand(element) {
        let obj = this.nodesMap.get(element);
        if (!obj)
          return;
        this.selectItem(element);
        let item = obj.item;
        if (!item.command)
          item = await this.resolveItem(element, item);
        if (!item || !item.command)
          throw new Error(`Failed to resolve command from TreeItem.`);
        await commands_default.execute(item.command);
      }
      async invokeActions(element) {
        if (!element)
          return;
        this.selectItem(element);
        if (typeof this.provider.resolveActions !== "function") {
          await window_default.showWarningMessage("No actions");
          return;
        }
        let obj = this.nodesMap.get(element);
        let actions = await Promise.resolve(this.provider.resolveActions(obj.item, element));
        if (!actions || actions.length == 0) {
          await window_default.showWarningMessage("No actions available");
          return;
        }
        let keys = actions.map((o) => o.title);
        let res = await window_default.showMenuPicker(keys, "Choose action");
        if (res == -1)
          return;
        await Promise.resolve(actions[res].handler(element));
      }
      async onDataChange(node) {
        if (this.filtering) {
          this.itemsToFilter = void 0;
          await this.doFilter(toText(this.filterText));
          return;
        }
        this.clearSelection();
        if (!node) {
          await this.render();
          return;
        }
        let release = await this.mutex.acquire();
        try {
          let items = this.renderedItems;
          let idx = items.findIndex((o) => o.node === node);
          if (idx != -1 && this.bufnr) {
            let obj = items[idx];
            let level2 = obj.level;
            let removeCount = 0;
            for (let i = idx; i < items.length; i++) {
              let o = items[i];
              if (i == idx || o && o.level > level2) {
                removeCount += 1;
              }
            }
            let appendItems = [];
            let highlights = [];
            let start = idx + this.startLnum;
            await this.appendTreeNode(node, level2, start, appendItems, highlights);
            items.splice(idx, removeCount, ...appendItems);
            this.updateUI(appendItems.map((o) => o.line), highlights, start, start + removeCount);
          }
          release();
        } catch (e) {
          let errMsg = `Error on tree refresh: ${e}`;
          logger19.error(errMsg, e);
          this.nvim.errWriteLine("[coc.nvim] " + errMsg);
          release();
        }
      }
      async resolveItem(element, item) {
        if (typeof this.provider.resolveTreeItem === "function") {
          let tokenSource = this.resolveTokenSource = new import_node3.CancellationTokenSource();
          let token = tokenSource.token;
          item = await Promise.resolve(this.provider.resolveTreeItem(item, element, token));
          tokenSource.dispose();
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested)
            return void 0;
        }
        this.nodesMap.set(element, { item, resolved: true });
        return item;
      }
      get visible() {
        if (!this.bufnr)
          return false;
        return this.winid != null;
      }
      get valid() {
        return typeof this.bufnr === "number";
      }
      get selection() {
        return this._selection.slice();
      }
      async checkLines() {
        if (!this.bufnr)
          return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let curr = await buf.lines;
        let { titleCount, messageCount } = this.lineState;
        curr = curr.slice(titleCount + messageCount);
        let lines = this.renderedItems.map((o) => o.line);
        return equals(curr, lines);
      }
      async toggleExpand(element) {
        let o = this.nodesMap.get(element);
        if (!o)
          return;
        let treeItem = o.item;
        let lnum = this.getItemLnum(element);
        let nodeIdx = lnum - this.startLnum;
        let obj = this.renderedItems[nodeIdx];
        if (!obj || treeItem.collapsibleState == 0 /* None */) {
          if (typeof this.provider.getParent === "function") {
            let node = await Promise.resolve(this.provider.getParent(element));
            if (node) {
              await this.toggleExpand(node);
              this.focusItem(node);
            }
          }
          return;
        }
        let removeCount = 0;
        if (treeItem.collapsibleState == 2 /* Expanded */) {
          let level2 = obj.level;
          for (let i = nodeIdx + 1; i < this.renderedItems.length; i++) {
            let o2 = this.renderedItems[i];
            if (!o2 || o2.level <= level2)
              break;
            removeCount += 1;
          }
          treeItem.collapsibleState = 1 /* Collapsed */;
        } else if (treeItem.collapsibleState == 1 /* Collapsed */) {
          treeItem.collapsibleState = 2 /* Expanded */;
        }
        let newItems = [];
        let newHighlights = [];
        await this.appendTreeNode(obj.node, obj.level, lnum, newItems, newHighlights);
        this.renderedItems.splice(nodeIdx, removeCount + 1, ...newItems);
        this.updateUI(newItems.map((o2) => o2.line), newHighlights, lnum, lnum + removeCount + 1);
        this.refreshSigns();
        if (treeItem.collapsibleState == 1 /* Collapsed */) {
          this._onDidCollapseElement.fire({ element });
        } else {
          this._onDidExpandElement.fire({ element });
        }
      }
      toggleSelection(element) {
        if (!element)
          return;
        let idx = this._selection.findIndex((o) => o === element);
        if (idx !== -1) {
          this.unselectItem(idx);
        } else {
          this.selectItem(element);
        }
      }
      clearSelection() {
        if (!this.bufnr)
          return;
        this._selection = [];
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree" });
        this._onDidChangeSelection.fire({ selection: [] });
      }
      selectItem(item, forceSingle, noRedraw) {
        let { nvim } = this;
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr)
          return;
        let buf = nvim.createBuffer(this.bufnr);
        let exists = this._selection.includes(item);
        if (!this.opts.canSelectMany || forceSingle) {
          this._selection = [item];
        } else if (!exists) {
          this._selection.push(item);
        }
        nvim.pauseNotification();
        if (!this.opts.canSelectMany || forceSingle) {
          buf.unplaceSign({ group: "CocTree" });
        }
        nvim.call("coc#compat#execute", [this.winid, `normal! ${row + 1}G`], true);
        buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        if (!noRedraw)
          this.redraw();
        nvim.resumeNotification(false, true);
        if (!exists)
          this._onDidChangeSelection.fire({ selection: this._selection });
      }
      unselectItem(idx) {
        let item = this._selection[idx];
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr)
          return;
        this._selection.splice(idx, 1);
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree", id: signOffset + row });
        this._onDidChangeSelection.fire({ selection: this._selection });
      }
      focusItem(element) {
        if (!this.winid)
          return;
        let lnum = this.getItemLnum(element);
        if (lnum == null)
          return;
        this.nvim.call("coc#compat#execute", [this.winid, `exe ${lnum + 1}`], true);
      }
      getElementByLnum(lnum) {
        let item = this.renderedItems[lnum - this.startLnum];
        return item ? item.node : void 0;
      }
      getItemLnum(item) {
        let idx = this.renderedItems.findIndex((o) => o.node === item);
        if (idx == -1)
          return void 0;
        return this.startLnum + idx;
      }
      async getTreeItem(element) {
        let exists;
        let resolved = false;
        let obj = this.nodesMap.get(element);
        if (obj != null) {
          exists = obj.item;
          resolved = obj.resolved;
        }
        let item = await Promise.resolve(this.provider.getTreeItem(element));
        if (exists && exists.collapsibleState != 0 /* None */ && item.collapsibleState != 0 /* None */) {
          item.collapsibleState = exists.collapsibleState;
        }
        this.nodesMap.set(element, { item, resolved });
        return item;
      }
      getRenderedLine(treeItem, lnum, level2) {
        let { openedIcon, closedIcon } = this.config;
        const highlights = [];
        const { label, deprecated, description } = treeItem;
        let prefix = "  ".repeat(level2);
        const addHighlight = (text, hlGroup) => {
          let colStart = byteLength(prefix);
          highlights.push({
            lnum,
            hlGroup,
            colStart,
            colEnd: colStart + byteLength(text)
          });
        };
        switch (treeItem.collapsibleState) {
          case 2 /* Expanded */: {
            addHighlight(openedIcon, "CocTreeOpenClose");
            prefix += openedIcon + " ";
            break;
          }
          case 1 /* Collapsed */: {
            addHighlight(closedIcon, "CocTreeOpenClose");
            prefix += closedIcon + " ";
            break;
          }
          default:
            prefix += this.leafIndent ? "  " : "";
        }
        if (treeItem.icon) {
          let { text, hlGroup } = treeItem.icon;
          addHighlight(text, hlGroup);
          prefix += text + " ";
        }
        if (TreeItemLabel.is(label) && Array.isArray(label.highlights)) {
          let colStart = byteLength(prefix);
          for (let o of label.highlights) {
            highlights.push({
              lnum,
              hlGroup: "CocSearch",
              colStart: colStart + o[0],
              colEnd: colStart + o[1]
            });
          }
        }
        let labelText = getItemLabel(treeItem);
        if (deprecated) {
          addHighlight(labelText, "CocDeprecatedHighlight");
        }
        prefix += labelText;
        if (description && description.indexOf("\n") == -1) {
          prefix += " ";
          addHighlight(description, "CocTreeDescription");
          prefix += description;
        }
        return { line: prefix, highlights };
      }
      async appendTreeNode(element, level2, lnum, items, highlights) {
        let takes = 1;
        let treeItem = await this.getTreeItem(element);
        let res = this.getRenderedLine(treeItem, lnum, level2);
        highlights.push(...res.highlights);
        items.push({ level: level2, line: res.line, node: element });
        if (treeItem.collapsibleState == 2 /* Expanded */) {
          let l = level2 + 1;
          let children = await Promise.resolve(this.provider.getChildren(element));
          for (let el of toArray(children)) {
            let n = await this.appendTreeNode(el, l, lnum + takes, items, highlights);
            takes = takes + n;
          }
        }
        return takes;
      }
      updateUI(lines, highlights, start = 0, end = -1, noRedraw = false) {
        if (!this.bufnr)
          return;
        let { nvim, winid } = this;
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        buf.setOption("modifiable", true, true);
        void buf.setLines(lines, { start, end, strictIndexing: false }, true);
        if (this.autoWidth)
          this.nvim.call("coc#window#adjust_width", [winid], true);
        if (highlights.length) {
          let highlightEnd = end == -1 ? -1 : start + lines.length;
          nvim.call("coc#highlight#update_highlights", [this.bufnr, highlightNamespace, highlights, start, highlightEnd], true);
        }
        buf.setOption("modifiable", false, true);
        if (!noRedraw)
          this.redraw();
        nvim.resumeNotification(false, true);
      }
      async reveal(element, options2 = {}) {
        if (this.filtering)
          return;
        let isShown = this.getItemLnum(element) != null;
        let { select, focus, expand: expand2 } = options2;
        let curr = element;
        if (typeof this.provider.getParent !== "function") {
          throw new Error("missing getParent function from provider for reveal.");
        }
        if (!isShown) {
          while (curr) {
            let parentNode = await Promise.resolve(this.provider.getParent(curr));
            if (parentNode) {
              let item = await this.getTreeItem(parentNode);
              item.collapsibleState = 2 /* Expanded */;
              curr = parentNode;
            } else {
              break;
            }
          }
        }
        if (expand2) {
          let item = await this.getTreeItem(element);
          if (item.collapsibleState != 0 /* None */) {
            item.collapsibleState = 2 /* Expanded */;
            if (typeof expand2 === "boolean")
              expand2 = 1;
            if (expand2 > 1) {
              let curr2 = Math.min(expand2, 2);
              let nodes = await Promise.resolve(this.provider.getChildren(element));
              while (!isFalsyOrEmpty(nodes)) {
                let arr = [];
                for (let n of nodes) {
                  let item2 = await this.getTreeItem(n);
                  if (item2.collapsibleState == 0 /* None */)
                    continue;
                  item2.collapsibleState = 2 /* Expanded */;
                  if (curr2 > 1) {
                    let res = await Promise.resolve(this.provider.getChildren(n));
                    arr.push(...res);
                  }
                }
                nodes = arr;
                curr2 = curr2 - 1;
              }
            }
          }
        }
        if (!isShown || expand2) {
          await this.render();
        }
        if (select !== false)
          this.selectItem(element);
        if (focus)
          this.focusItem(element);
      }
      updateHeadLines(initialize = false) {
        let { titleCount, messageCount } = this.lineState;
        let end = initialize ? -1 : titleCount + messageCount;
        let lines = [];
        let highlights = [];
        if (this.message) {
          highlights.push({ hlGroup: "MoreMsg", colStart: 0, colEnd: byteLength(this.message), lnum: 0 });
          lines.push(this.message);
          lines.push("");
        }
        if (this.title) {
          highlights.push({ hlGroup: "CocTreeTitle", colStart: 0, colEnd: byteLength(this.title), lnum: lines.length });
          if (this.description) {
            let colStart = byteLength(this.title) + 1;
            highlights.push({ hlGroup: "Comment", colStart, colEnd: colStart + byteLength(this.description), lnum: lines.length });
          }
          lines.push(this.title + (this.description ? " " + this.description : ""));
        }
        this.lineState.messageCount = this.message ? 2 : 0;
        this.lineState.titleCount = this.title ? 1 : 0;
        this.updateUI(lines, highlights, 0, end);
        if (!initialize) {
          this.refreshSigns();
        }
      }
      refreshSigns() {
        let { selection, nvim, bufnr } = this;
        if (!selection.length || !bufnr)
          return;
        let buf = nvim.createBuffer(bufnr);
        nvim.pauseNotification();
        buf.unplaceSign({ group: "CocTree" });
        for (let n of selection) {
          let row = this.getItemLnum(n);
          if (row == null)
            continue;
          buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        }
        nvim.resumeNotification(false, true);
      }
      async render() {
        if (!this.bufnr)
          return;
        let release = await this.mutex.acquire();
        try {
          let lines = [];
          let highlights = [];
          let { startLnum } = this;
          let nodes = await Promise.resolve(this.provider.getChildren());
          let level2 = 0;
          let lnum = startLnum;
          let renderedItems = [];
          if (isFalsyOrEmpty(nodes)) {
            this.message = "No results";
          } else {
            if (this.message == "No results")
              this.message = "";
            for (let node of nodes) {
              let n = await this.appendTreeNode(node, level2, lnum, renderedItems, highlights);
              lnum += n;
            }
          }
          lines.push(...renderedItems.map((o) => o.line));
          this.renderedItems = renderedItems;
          let delta = this.startLnum - startLnum;
          highlights.forEach((o) => o.lnum = o.lnum + delta);
          this.updateUI(lines, highlights, this.startLnum, -1);
          this._onDidRefrash.fire();
          this.retryTimers = 0;
          release();
        } catch (e) {
          this.renderedItems = [];
          this.nodesMap.clear();
          this.lineState = { titleCount: 0, messageCount: 1 };
          release();
          let errMsg = `${e}`.replace(/\r?\n/g, " ");
          this.updateUI([errMsg], [{ hlGroup: "WarningMsg", colStart: 0, colEnd: byteLength(errMsg), lnum: 0 }]);
          if (this.retryTimers == maxRetry)
            return;
          this.timer = setTimeout(() => {
            this.retryTimers = this.retryTimers + 1;
            void this.render();
          }, retryTimeout);
        }
      }
      async show(splitCommand = "belowright 30vs", waitRender = true) {
        let { nvim } = this;
        let [targetBufnr, windowId] = await nvim.eval(`[bufnr("%"),win_getid()]`);
        this._targetBufnr = targetBufnr;
        this._targetWinId = windowId;
        let opts = {
          command: splitCommand,
          bufname: this.bufname,
          viewId: this.viewId.replace(/"/g, '\\"'),
          bufnr: defaultValue(this.bufnr, -1),
          winid: defaultValue(this.winid, -1),
          bufhidden: defaultValue(this.opts.bufhidden, "wipe"),
          canSelectMany: this.opts.canSelectMany === true,
          winfixwidth: this.winfixwidth === true
        };
        let [bufnr, winid, tabId] = await nvim.call("coc#ui#create_tree", [opts]);
        this.bufnr = bufnr;
        this.winid = winid;
        this._targetTabId = tabId;
        if (winid != opts.winid)
          this._onDidChangeVisibility.fire({ visible: true });
        if (bufnr == opts.bufnr)
          return true;
        this.registerKeymaps();
        this.updateHeadLines(true);
        let promise = this.render();
        if (waitRender)
          await promise;
        return true;
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        if (!this.bufnr) {
          this._keymapDefs.push({ mode, key, fn, notify });
        } else {
          this.addLocalKeymap(mode, key, fn, notify);
        }
      }
      addLocalKeymap(mode, key, fn, notify = true) {
        if (!key)
          return;
        workspace_default.registerLocalKeymap(this.bufnr, mode, key, async () => {
          let lnum = await this.nvim.call("line", ["."]);
          let element = this.getElementByLnum(lnum - 1);
          await Promise.resolve(fn(element));
        }, notify);
      }
      registerKeymaps() {
        let { toggleSelection, actions, close, invoke, toggle, collapseAll, activeFilter } = this.keys;
        let { nvim, _keymapDefs } = this;
        this.disposables.push(workspace_default.registerLocalKeymap(this.bufnr, "n", "<C-o>", () => {
          nvim.call("win_gotoid", [this._targetWinId], true);
        }, true));
        this.addLocalKeymap("n", "<LeftRelease>", async (element) => {
          if (element)
            await this.onClick(element);
        });
        this.filter && this.addLocalKeymap("n", activeFilter, async () => {
          this.nvim.command(`exe ${this.startLnum}`, true);
          this.filter.active();
          this.filterText = "";
          this._onDidFilterStateChange.fire(true);
        });
        this.addLocalKeymap("n", toggleSelection, (element) => this.toggleSelection(element));
        this.addLocalKeymap("n", invoke, (element) => this.invokeCommand(element));
        this.addLocalKeymap("n", actions, (element) => this.invokeActions(element));
        this.addLocalKeymap("n", toggle, (element) => this.toggleExpand(element));
        this.addLocalKeymap("n", collapseAll, () => this.collapseAll());
        this.addLocalKeymap("n", close, () => this.hide());
        while (_keymapDefs.length) {
          const def = _keymapDefs.pop();
          this.addLocalKeymap(def.mode, def.key, def.fn, def.notify);
        }
      }
      hide() {
        this.nvim.call("coc#window#close", [this.winid], true);
        this.redraw();
        this.winid = void 0;
        this._onDidChangeVisibility.fire({ visible: false });
      }
      redraw() {
        var _a2;
        if (workspace_default.isVim || ((_a2 = this.filter) == null ? void 0 : _a2.activated)) {
          this.nvim.command("redraw", true);
        }
      }
      async collapseAll() {
        for (let obj of this.nodesMap.values()) {
          let item = obj.item;
          if (item.collapsibleState == 2 /* Expanded */) {
            item.collapsibleState = 1 /* Collapsed */;
          }
        }
        await this.render();
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = void 0;
        }
      }
      dispose() {
        var _a2;
        if (!this.provider)
          return;
        if (this.timer)
          clearTimeout(this.timer);
        this.cancelResolve();
        let { bufnr } = this;
        if (this.winid)
          this._onDidChangeVisibility.fire({ visible: false });
        if (bufnr)
          this.nvim.command(`silent! bwipeout! ${bufnr}`, true);
        this._keymapDefs = [];
        this.winid = void 0;
        this.bufnr = void 0;
        (_a2 = this.filter) == null ? void 0 : _a2.dispose();
        this._selection = [];
        this.itemsToFilter = [];
        this.tooltipFactory.dispose();
        this.renderedItems = [];
        this.nodesMap.clear();
        this.provider = void 0;
        this._onDispose.fire();
        this._onDispose.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/window.ts
var Window, window_default;
var init_window = __esm({
  "src/window.ts"() {
    "use strict";
    init_channels();
    init_dialogs();
    init_highlights();
    init_notifications();
    init_terminals();
    init_ui();
    init_object();
    init_protocol();
    Window = class {
      constructor() {
        this.highlights = new Highlights();
        this.terminalManager = new Terminals();
        this.dialogs = new Dialogs();
        this.notifications = new Notifications(this.dialogs);
        Object.defineProperty(this.highlights, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(this.dialogs, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(this.dialogs, "configuration", {
          get: () => this.workspace.initialConfiguration
        });
        Object.defineProperty(this.notifications, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(this.notifications, "configuration", {
          get: () => this.workspace.initialConfiguration
        });
        Object.defineProperty(this.notifications, "statusLine", {
          get: () => this.workspace.statusLine
        });
      }
      init(env) {
        this.highlights.checkMarkers = this.workspace.has("nvim-0.5.1") || env.isVim;
      }
      get activeTextEditor() {
        return this.workspace.editors.activeTextEditor;
      }
      get visibleTextEditors() {
        return this.workspace.editors.visibleTextEditors;
      }
      get onDidTabClose() {
        return this.workspace.editors.onDidTabClose;
      }
      get onDidChangeActiveTextEditor() {
        return this.workspace.editors.onDidChangeActiveTextEditor;
      }
      get onDidChangeVisibleTextEditors() {
        return this.workspace.editors.onDidChangeVisibleTextEditors;
      }
      get terminals() {
        return this.terminalManager.terminals;
      }
      get onDidOpenTerminal() {
        return this.terminalManager.onDidOpenTerminal;
      }
      get onDidCloseTerminal() {
        return this.terminalManager.onDidCloseTerminal;
      }
      async createTerminal(opts) {
        return await this.terminalManager.createTerminal(this.nvim, opts);
      }
      async runTerminalCommand(cmd, cwd2, keepfocus = false) {
        return await this.terminalManager.runTerminalCommand(this.nvim, cmd, cwd2 ?? this.workspace.cwd, keepfocus);
      }
      async openTerminal(cmd, opts) {
        return await this.terminalManager.openTerminal(this.nvim, cmd, opts);
      }
      showMessage(msg, messageType = "more") {
        this.notifications.echoMessages(msg, messageType);
      }
      createOutputChannel(name2) {
        return channels_default.create(name2, this.nvim);
      }
      showOutputChannel(name2, preserveFocus) {
        let command = this.configuration.get("workspace.openOutputCommand", "vs");
        channels_default.show(name2, command, preserveFocus);
      }
      async echoLines(lines, truncate = false) {
        await echoLines(this.nvim, this.workspace.env, lines, truncate);
      }
      getCursorPosition() {
        return getCursorPosition(this.nvim);
      }
      async moveTo(position) {
        await moveTo(this.nvim, position, this.workspace.env.isVim);
      }
      getSelectedRange(mode) {
        return getSelection(this.nvim, mode);
      }
      async selectRange(range) {
        await selectRange(this.nvim, range, this.nvim.isVim);
      }
      getOffset() {
        return getOffset(this.nvim);
      }
      getCursorScreenPosition() {
        return getCursorScreenPosition(this.nvim);
      }
      createTreeView(viewId, options2) {
        const BasicTreeView2 = (init_TreeView(), __toCommonJS(TreeView_exports)).default;
        return new BasicTreeView2(viewId, options2);
      }
      createStatusBarItem(priority = 0, option = {}) {
        return this.workspace.statusLine.createStatusBarItem(priority, option.progress);
      }
      async diffHighlights(bufnr, ns, items, region, token) {
        return this.highlights.diffHighlights(bufnr, ns, items, region, token);
      }
      createFloatFactory(conf) {
        let configuration2 = this.workspace.initialConfiguration;
        let defaults3 = toObject(configuration2.get("floatFactory.floatConfig"));
        let markdownPreference = this.workspace.configurations.markdownPreference;
        return createFloatFactory(this.workspace.nvim, Object.assign({ ...markdownPreference, maxWidth: 80 }, conf), defaults3);
      }
      async showQuickpick(items, placeholder = "Choose by number") {
        return await this.showMenuPicker(items, { title: placeholder, position: "center" });
      }
      async showQuickPick(itemsOrItemsPromise, options2, token = import_node3.CancellationToken.None) {
        return await this.dialogs.showQuickPick(itemsOrItemsPromise, options2, token);
      }
      async createQuickPick(config = {}) {
        return await this.dialogs.createQuickPick(config);
      }
      async showMenuPicker(items, option, token) {
        return await this.dialogs.showMenuPicker(items, option, token);
      }
      async showPrompt(title) {
        return await this.dialogs.showPrompt(title);
      }
      async showDialog(config) {
        return await this.dialogs.showDialog(config);
      }
      async requestInput(title, value, option) {
        return await this.dialogs.requestInput(title, this.workspace.env, value, option);
      }
      async createInputBox(title, value, option) {
        return await this.dialogs.createInputBox(title, value, option);
      }
      async showPickerDialog(items, title, token) {
        return await this.dialogs.showPickerDialog(items, title, token);
      }
      async showInformationMessage(message, ...items) {
        let stack = Error().stack;
        return await this.notifications._showMessage("Info", message, items, stack);
      }
      async showWarningMessage(message, ...items) {
        let stack = Error().stack;
        return await this.notifications._showMessage("Warning", message, items, stack);
      }
      async showErrorMessage(message, ...items) {
        let stack = Error().stack;
        return await this.notifications._showMessage("Error", message, items, stack);
      }
      async showNotification(config) {
        let stack = Error().stack;
        await this.notifications.showNotification(config, stack);
      }
      async withProgress(options2, task) {
        return this.notifications.withProgress(options2, task);
      }
      async applyDiffHighlights(bufnr, ns, priority, diff, notify = false) {
        return this.highlights.applyDiffHighlights(bufnr, ns, priority, diff, notify);
      }
      get configuration() {
        return this.workspace.initialConfiguration;
      }
      dispose() {
        this.terminalManager.dispose();
      }
    };
    window_default = new Window();
  }
});

// src/completion/types.ts
var SourceType;
var init_types2 = __esm({
  "src/completion/types.ts"() {
    "use strict";
    SourceType = /* @__PURE__ */ ((SourceType2) => {
      SourceType2[SourceType2["Native"] = 0] = "Native";
      SourceType2[SourceType2["Remote"] = 1] = "Remote";
      SourceType2[SourceType2["Service"] = 2] = "Service";
      return SourceType2;
    })(SourceType || {});
  }
});

// src/snippets/eval.ts
async function evalCode(nvim, kind, code, curr) {
  if (kind == "vim") {
    let res2 = await nvim.eval(code);
    return res2.toString();
  }
  if (kind == "shell") {
    let res2 = await (0, import_util.promisify)(import_child_process.exec)(code);
    return res2.stdout.replace(/\s*$/, "");
  }
  let lines = [`snip._reset("${escapeString(curr)}")`];
  lines.push(...code.split(/\r?\n/).map((line) => line.replace(/\t/g, "    ")));
  await executePythonCode(nvim, lines);
  let res = await nvim.call(`pyxeval`, "str(snip.rv)");
  return toText(res);
}
function prepareMatchCode(snip) {
  let { range, regex: regex2, line } = snip;
  let pyCodes = [];
  if (regex2 && range != null) {
    let trigger = line.slice(range.start.character, range.end.character);
    pyCodes.push(`pattern = re.compile("${escapeString(regex2)}")`);
    pyCodes.push(`match = pattern.search("${escapeString(trigger)}")`);
  } else {
    pyCodes.push(`match = None`);
  }
  return pyCodes.join("\n");
}
function preparePythonCodes(snip) {
  let { range, context, line } = snip;
  let pyCodes = [
    "import re, os, vim, string, random",
    `path = vim.eval('expand("%:p")') or ""`,
    `fn = os.path.basename(path)`
  ];
  if (context) {
    pyCodes.push(`snip = ContextSnippet()`);
    pyCodes.push(`context = ${context}`);
  } else {
    pyCodes.push(`context = True`);
  }
  let start = `(${range.start.line},${Buffer.byteLength(line.slice(0, range.start.character))})`;
  let end = `(${range.start.line},${Buffer.byteLength(line.slice(0, range.end.character))})`;
  let indent = line.match(/^\s*/)[0];
  pyCodes.push(`snip = SnippetUtil("${escapeString(indent)}", ${start}, ${end}, context)`);
  return pyCodes;
}
async function executePythonCode(nvim, codes) {
  try {
    await nvim.command(`pyx ${addPythonTryCatch(codes.join("\n"))}`);
  } catch (e) {
    let err = new Error(e.message);
    err.stack = `Error on execute python code:
${codes.join("\n")}
` + e.stack;
    throw err;
  }
}
function getVariablesCode(values) {
  let keys = Object.keys(values);
  if (keys.length == 0)
    return `t = ()`;
  let maxIndex = Math.max.apply(null, keys.map((v) => Number(v)));
  let vals = new Array(maxIndex).fill('""');
  for (let [idx, val] of Object.entries(values)) {
    vals[idx] = `"${escapeString(val)}"`;
  }
  return `t = (${vals.join(",")},)`;
}
function addPythonTryCatch(code, force = false) {
  if (!isVim && force === false)
    return code;
  let lines = [
    "import traceback, vim",
    `vim.vars['errmsg'] = ''`,
    "try:"
  ];
  lines.push(...code.split("\n").map((line) => "    " + line));
  lines.push("except Exception as e:");
  lines.push(`    vim.vars['errmsg'] = traceback.format_exc()`);
  return lines.join("\n");
}
function escapeString(input) {
  return input.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\t/g, "\\t").replace(/\n/g, "\\n");
}
function convertRegex(str) {
  if (str.indexOf("\\z") !== -1) {
    throw new Error("pattern \\z not supported");
  }
  if (str.indexOf("(?s)") !== -1) {
    throw new Error("pattern (?s) not supported");
  }
  if (str.indexOf("(?x)") !== -1) {
    throw new Error("pattern (?x) not supported");
  }
  if (str.indexOf("\n") !== -1) {
    throw new Error("pattern \\n not supported");
  }
  if (conditionRe.test(str)) {
    throw new Error("pattern (?id/name)yes-pattern|no-pattern not supported");
  }
  return str.replace(regex, (match, p1) => {
    if (match.startsWith("(?#"))
      return "";
    if (match.startsWith("(?P<"))
      return "(?" + match.slice(3);
    if (match.startsWith("(?P="))
      return `\\k<${p1}>`;
    return "^";
  });
}
var import_child_process, stringStartRe, conditionRe, commentRe, namedCaptureRe, namedReferenceRe, regex;
var init_eval = __esm({
  "src/snippets/eval.ts"() {
    "use strict";
    import_child_process = require("child_process");
    init_constants();
    init_node();
    init_string();
    stringStartRe = /\\A/;
    conditionRe = /\(\?\(\w+\).+\|/;
    commentRe = /\(\?#.*?\)/;
    namedCaptureRe = /\(\?P<\w+>.*?\)/;
    namedReferenceRe = /\(\?P=(\w+)\)/;
    regex = new RegExp(`${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}`, "g");
  }
});

// src/snippets/parser.ts
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
function transformEscapes(input, backslashIndexes = []) {
  let res = "";
  let len = input.length;
  let i = 0;
  let toUpper = false;
  let toLower2 = false;
  while (i < len) {
    let ch = input[i];
    if (ch.charCodeAt(0) === 92 /* Backslash */ && !backslashIndexes.includes(i)) {
      let next = input[i + 1];
      if (escapedCharacters.includes(next)) {
        i++;
        continue;
      }
      if (next == "u" || next == "l") {
        let follow = input[i + 2];
        if (follow)
          res = res + (next == "u" ? follow.toUpperCase() : follow.toLowerCase());
        i = i + 3;
        continue;
      }
      if (next == "U" || next == "L") {
        if (next == "U") {
          toUpper = true;
        } else {
          toLower2 = true;
        }
        i = i + 2;
        continue;
      }
      if (next == "E") {
        toUpper = false;
        toLower2 = false;
        i = i + 2;
        continue;
      }
      if (next == "n") {
        res += "\n";
        i = i + 2;
        continue;
      }
      if (next == "t") {
        res += "	";
        i = i + 2;
        continue;
      }
    }
    if (toUpper) {
      ch = ch.toUpperCase();
    } else if (toLower2) {
      ch = ch.toLowerCase();
    }
    res += ch;
    i++;
  }
  return res;
}
var logger20, ULTISNIP_VARIABLES, knownRegexOptions, _Scanner, Scanner, Marker, Text, CodeBlock, TransformableMarker, Placeholder, Choice, Transform, ConditionString, FormatString, Variable, TextmateSnippet, SnippetParser, escapedCharacters;
var init_parser3 = __esm({
  "src/snippets/parser.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_array();
    init_charCode();
    init_node();
    init_string();
    init_eval();
    logger20 = createLogger("snippets-parser");
    ULTISNIP_VARIABLES = ["VISUAL", "YANK", "UUID"];
    knownRegexOptions = ["d", "g", "i", "m", "s", "u", "y"];
    _Scanner = class {
      static isDigitCharacter(ch) {
        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
      }
      static isVariableCharacter(ch) {
        return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;
      }
      constructor() {
        this.text("");
      }
      text(value) {
        this.value = value;
        this.pos = 0;
      }
      tokenText(token) {
        return this.value.substr(token.pos, token.len);
      }
      next() {
        if (this.pos >= this.value.length) {
          return { type: 14 /* EOF */, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        type = _Scanner._table[ch];
        if (typeof type === "number") {
          this.pos += 1;
          return { type, pos, len: 1 };
        }
        if (_Scanner.isDigitCharacter(ch)) {
          type = 8 /* Int */;
          do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
          } while (_Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        if (_Scanner.isVariableCharacter(ch)) {
          type = 9 /* VariableName */;
          do {
            ch = this.value.charCodeAt(pos + ++len);
          } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        type = 10 /* Format */;
        do {
          len += 1;
          ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
        this.pos += len;
        return { type, pos, len };
      }
    };
    Scanner = _Scanner;
    Scanner._table = {
      [36 /* DollarSign */]: 0 /* Dollar */,
      [58 /* Colon */]: 1 /* Colon */,
      [44 /* Comma */]: 2 /* Comma */,
      [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
      [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
      [92 /* Backslash */]: 5 /* Backslash */,
      [47 /* Slash */]: 6 /* Forwardslash */,
      [124 /* Pipe */]: 7 /* Pipe */,
      [43 /* Plus */]: 11 /* Plus */,
      [45 /* Dash */]: 12 /* Dash */,
      [63 /* QuestionMark */]: 13 /* QuestionMark */,
      [40 /* OpenParen */]: 15 /* OpenParen */,
      [41 /* CloseParen */]: 16 /* CloseParen */,
      [96 /* BackTick */]: 17 /* BackTick */,
      [33 /* ExclamationMark */]: 18 /* ExclamationMark */
    };
    Marker = class {
      constructor() {
        this._children = [];
      }
      appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
          this._children[this._children.length - 1].value += child.value;
        } else {
          child.parent = this;
          this._children.push(child);
        }
        return this;
      }
      setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
      }
      replaceChildren(children) {
        for (const child of children) {
          child.parent = this;
        }
        this._children = children;
      }
      get children() {
        return this._children;
      }
      get snippet() {
        let candidate = this;
        while (true) {
          if (!candidate) {
            return void 0;
          }
          if (candidate instanceof TextmateSnippet) {
            return candidate;
          }
          candidate = candidate.parent;
        }
      }
      toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), "");
      }
      len() {
        return 0;
      }
    };
    Text = class extends Marker {
      constructor(value) {
        super();
        this.value = value;
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      toString() {
        return this.value;
      }
      toTextmateString() {
        return Text.escape(this.value);
      }
      len() {
        return this.value.length;
      }
      clone() {
        return new Text(this.value);
      }
    };
    CodeBlock = class extends Marker {
      constructor(code, kind, value) {
        super();
        this.code = code;
        this.kind = kind;
        this._value = "";
        this._related = [];
        if (kind === "python") {
          let { _related } = this;
          let arr;
          let re = /\bt\[(\d+)\]/g;
          while (true) {
            arr = re.exec(code);
            if (arr == null)
              break;
            let n = parseInt(arr[1], 10);
            if (!_related.includes(n))
              _related.push(n);
          }
        }
        if (typeof value === "string")
          this._value = value;
      }
      get related() {
        return this._related;
      }
      update(map) {
        if (this.kind !== "python")
          return;
        let related = /* @__PURE__ */ new Set();
        this.code = this.code.replace(/\bt\[(\d+)\]/g, (_, p1) => {
          let idx = Number(p1);
          let id = map.has(idx) ? map.get(idx) : idx;
          related.add(id);
          return `t[${id}]`;
        });
        this._related = Array.from(related);
      }
      get index() {
        if (this.parent instanceof Placeholder) {
          return this.parent.index;
        }
        return void 0;
      }
      async resolve(nvim) {
        if (!this.code.length)
          return;
        let res = await evalCode(nvim, this.kind, this.code, defaultValue(this._value, ""));
        if (res != null)
          this._value = res;
      }
      len() {
        return this._value.length;
      }
      toString() {
        return this._value;
      }
      get value() {
        return this._value;
      }
      toTextmateString() {
        let t = "";
        if (this.kind == "python") {
          t = "!p ";
        } else if (this.kind == "shell") {
          t = "";
        } else if (this.kind == "vim") {
          t = "!v ";
        }
        return "`" + t + this.code + "`";
      }
      clone() {
        return new CodeBlock(this.code, this.kind, this.value);
      }
    };
    TransformableMarker = class extends Marker {
    };
    Placeholder = class extends TransformableMarker {
      constructor(index) {
        super();
        this.index = index;
        this.primary = false;
      }
      get isFinalTabstop() {
        return this.index === 0;
      }
      get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
          return `$${this.index}`;
        } else if (this.children.length === 0 || this.children.length == 1 && this.children[0].toTextmateString() == "") {
          return `\${${this.index}${transformString}}`;
        } else if (this.choice) {
          return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        } else {
          return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        let ret = new Placeholder(this.index);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    Choice = class extends Marker {
      constructor() {
        super(...arguments);
        this.options = [];
      }
      appendChild(marker) {
        if (marker instanceof Text) {
          marker.parent = this;
          this.options.push(marker);
        }
        return this;
      }
      toString() {
        return this.options[0].value;
      }
      toTextmateString() {
        return this.options.map((option) => option.value.replace(/\||,/g, "\\$&")).join(",");
      }
      len() {
        return this.options[0].len();
      }
      clone() {
        let ret = new Choice();
        for (let opt of this.options) {
          ret.appendChild(opt);
        }
        return ret;
      }
    };
    Transform = class extends Marker {
      constructor() {
        super(...arguments);
        this.ascii = false;
        this.ultisnip = false;
      }
      resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
          didMatch = true;
          return this._replace(args.slice(0, -2));
        });
        if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
          ret = this._replace([]);
        }
        return ret;
      }
      _replace(groups) {
        let ret = "";
        let backslashIndexes = [];
        for (const marker of this._children) {
          if (marker instanceof FormatString) {
            let val = marker.resolve(groups[marker.index] || "");
            if (this.ultisnip && val.indexOf("\\") !== -1) {
              let s = ret.length;
              backslashIndexes.push(...getCharIndexes(val, "\\").map((i) => i + s));
            }
            ret += val;
          } else if (marker instanceof ConditionString) {
            ret += marker.resolve(groups[marker.index]);
          } else {
            ret += marker.toString();
          }
        }
        if (this.ascii)
          ret = unidecode(ret);
        return this.ultisnip ? transformEscapes(ret, backslashIndexes) : ret;
      }
      toString() {
        return "";
      }
      toTextmateString() {
        let format3 = this.children.map((c) => c.toTextmateString()).join("");
        if (this.ultisnip) {
          format3 = format3.replace(/\\\\(\w)/g, (match, ch) => {
            if (["u", "l", "U", "L", "E", "n", "t"].includes(ch)) {
              return "\\" + ch;
            }
            return match;
          });
        }
        return `/${this.regexp.source}/${format3}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
      }
      clone() {
        let ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    ConditionString = class extends Marker {
      constructor(index, ifValue, elseValue) {
        super();
        this.index = index;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (value)
          return this.ifValue;
        return this.elseValue;
      }
      toTextmateString() {
        return "(?" + this.index + ":" + this.ifValue + (this.elseValue ? ":" + this.elseValue : "") + ")";
      }
      clone() {
        return new ConditionString(this.index, this.ifValue, this.elseValue);
      }
    };
    FormatString = class extends Marker {
      constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (this.shorthandName === "upcase") {
          return !value ? "" : value.toLocaleUpperCase();
        } else if (this.shorthandName === "downcase") {
          return !value ? "" : value.toLocaleLowerCase();
        } else if (this.shorthandName === "capitalize") {
          return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
        } else if (this.shorthandName === "pascalcase") {
          return !value ? "" : this._toPascalCase(value);
        } else if (Boolean(value) && typeof this.ifValue === "string") {
          return this.ifValue;
        } else if (!value && typeof this.elseValue === "string") {
          return this.elseValue;
        } else {
          return value || "";
        }
      }
      _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase()).join("");
      }
      toTextmateString() {
        let value = "${";
        value += this.index;
        if (this.shorthandName) {
          value += `:/${this.shorthandName}`;
        } else if (this.ifValue && this.elseValue) {
          value += `:?${this.ifValue}:${this.elseValue}`;
        } else if (this.ifValue) {
          value += `:+${this.ifValue}`;
        } else if (this.elseValue) {
          value += `:-${this.elseValue}`;
        }
        value += "}";
        return value;
      }
      clone() {
        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
      }
    };
    Variable = class extends TransformableMarker {
      constructor(name2, resolved = false) {
        super();
        this.name = name2;
        this._resolved = resolved;
      }
      get resolved() {
        return this._resolved;
      }
      async resolve(resolver2) {
        let value = await resolver2.resolve(this);
        this._resolved = true;
        if (value && value.includes("\n")) {
          let indent = "";
          this.snippet.walk((m) => {
            if (m == this) {
              return false;
            }
            if (m instanceof Text) {
              let lines2 = m.toString().split(/\r?\n/);
              indent = lines2[lines2.length - 1].match(/^\s*/)[0];
            }
            return true;
          });
          let lines = value.split("\n");
          let indents = lines.filter((s) => s.length > 0).map((s) => s.match(/^\s*/)[0]);
          let minIndent = indents.reduce((p, c) => p < c.length ? p : c.length, 0);
          let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(" ".repeat(minIndent)) ? s : indent + s.slice(minIndent));
          value = newLines.join("\n");
        }
        if (this.transform) {
          value = this.transform.resolve(toText(value));
        }
        if (value != null) {
          this._children = [new Text(value.toString())];
          return true;
        }
        return false;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
          return `\${${this.name}${transformString}}`;
        } else {
          return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        const ret = new Variable(this.name, this.resolved);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    TextmateSnippet = class extends Marker {
      constructor(ultisnip) {
        super();
        this.ultisnip = ultisnip === true;
      }
      get hasPython() {
        if (!this.ultisnip)
          return false;
        return this.pyBlocks.length > 0;
      }
      get hasCodeBlock() {
        if (!this.ultisnip)
          return false;
        let { pyBlocks, otherBlocks } = this;
        return pyBlocks.length > 0 || otherBlocks.length > 0;
      }
      get values() {
        if (this._values)
          return this._values;
        let values = {};
        let maxIndexNumber = 0;
        this.placeholders.forEach((c) => {
          maxIndexNumber = Math.max(c.index, maxIndexNumber);
          if (c.transform != null)
            return;
          if (c.primary || values[c.index] === void 0)
            values[c.index] = c.toString();
        });
        for (let i = 0; i <= maxIndexNumber; i++) {
          if (values[i] === void 0)
            values[i] = "";
        }
        this._values = values;
        return values;
      }
      get orderedPyIndexBlocks() {
        let res = [];
        let filtered = this.pyBlocks.filter((o) => typeof o.index === "number");
        if (filtered.length === 0)
          return res;
        let allIndexes = filtered.map((o) => o.index);
        let usedIndexes = [];
        const checkBlock = (b) => {
          let { related } = b;
          if (related.length == 0 || related.every((idx) => !allIndexes.includes(idx) || usedIndexes.includes(idx))) {
            usedIndexes.push(b.index);
            res.push(b);
            return true;
          }
          return false;
        };
        while (filtered.length > 0) {
          let c = false;
          for (let b of filtered) {
            if (checkBlock(b)) {
              c = true;
            }
          }
          if (!c) {
            break;
          }
          filtered = filtered.filter((o) => !usedIndexes.includes(o.index));
        }
        return res;
      }
      async evalCodeBlocks(nvim, prepareCodes) {
        let { pyBlocks, otherBlocks } = this;
        await Promise.all(otherBlocks.map((block2) => {
          let pre = block2.value;
          return block2.resolve(nvim).then(() => {
            if (block2.parent instanceof Placeholder && pre !== block2.value) {
              this.onPlaceholderUpdate(block2.parent);
            }
          });
        }));
        if (pyBlocks.length) {
          const variableCode = getVariablesCode(this.values);
          await executePythonCode(nvim, [...prepareCodes, variableCode]);
          for (let block2 of pyBlocks) {
            let pre = block2.value;
            await block2.resolve(nvim);
            if (pre === block2.value)
              continue;
            if (block2.parent instanceof Placeholder) {
              this.onPlaceholderUpdate(block2.parent);
              await executePythonCode(nvim, [getVariablesCode(this.values)]);
            }
          }
          for (let block2 of this.orderedPyIndexBlocks) {
            await this.updatePyIndexBlock(nvim, block2);
          }
          let filtered = pyBlocks.filter((o) => o.index === void 0 && o.related.length > 0);
          for (let block2 of filtered) {
            await block2.resolve(nvim);
          }
        }
      }
      async updatePythonCodes(nvim, marker) {
        let index;
        if (marker instanceof Placeholder) {
          index = marker.index;
        } else {
          while (marker.parent) {
            if (marker instanceof Placeholder) {
              index = marker.index;
              break;
            }
            marker = marker.parent;
          }
          if (index === void 0)
            return;
        }
        let blocks = this.getDependentPyIndexBlocks(index);
        await executePythonCode(nvim, [getVariablesCode(this.values)]);
        for (let block2 of blocks) {
          await this.updatePyIndexBlock(nvim, block2);
        }
        let filtered = this.pyBlocks.filter((o) => o.index === void 0 && o.related.length > 0);
        for (let block2 of filtered) {
          await block2.resolve(nvim);
        }
      }
      getDependentPyIndexBlocks(index) {
        const res = [];
        const taken = [];
        let filtered = this.pyBlocks.filter((o) => typeof o.index === "number");
        const search = (idx) => {
          let blocks = filtered.filter((o) => !taken.includes(o.index) && o.related.includes(idx));
          if (blocks.length > 0) {
            res.push(...blocks);
            blocks.forEach((b) => {
              search(b.index);
            });
          }
        };
        search(index);
        return res;
      }
      async updatePyIndexBlock(nvim, block2) {
        let pre = block2.value;
        await block2.resolve(nvim);
        if (pre === block2.value)
          return;
        if (block2.parent instanceof Placeholder) {
          this.onPlaceholderUpdate(block2.parent);
        }
        await executePythonCode(nvim, [getVariablesCode(this.values)]);
      }
      get placeholderInfo() {
        if (!this._placeholders) {
          const variables = [];
          const pyBlocks = [];
          const otherBlocks = [];
          let placeholders = [];
          this.walk((candidate) => {
            if (candidate instanceof Placeholder) {
              placeholders.push(candidate);
            } else if (candidate instanceof Variable) {
              let first = candidate.name.charCodeAt(0);
              if (first < 65 || first > 90) {
                variables.push(candidate);
              }
            } else if (candidate instanceof CodeBlock) {
              if (candidate.kind === "python") {
                pyBlocks.push(candidate);
              } else {
                otherBlocks.push(candidate);
              }
            }
            return true;
          });
          this._placeholders = { placeholders, pyBlocks, otherBlocks, variables };
        }
        return this._placeholders;
      }
      get variables() {
        return this.placeholderInfo.variables;
      }
      get placeholders() {
        return this.placeholderInfo.placeholders;
      }
      get pyBlocks() {
        return this.placeholderInfo.pyBlocks;
      }
      get otherBlocks() {
        return this.placeholderInfo.otherBlocks;
      }
      get maxIndexNumber() {
        let { placeholders } = this;
        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
      }
      get first() {
        let { placeholders, variables } = this;
        let [normals, finals] = groupBy(placeholders.filter((p) => !p.transform), (v) => v.index !== 0);
        if (normals.length) {
          let minIndex = Math.min.apply(null, normals.map((o) => o.index));
          let arr = normals.filter((v) => v.index == minIndex);
          return arr.find((p) => p.primary) ?? arr[0];
        }
        if (variables.length)
          return variables[0];
        return finals.find((o) => o.primary) ?? finals[0];
      }
      insertSnippet(snippet, marker, parts, ultisnip) {
        let index = marker instanceof Placeholder ? marker.index : this.maxIndexNumber + 1;
        let [before, after] = parts;
        let matchCode = ultisnip ? prepareMatchCode(ultisnip) : void 0;
        let nested = new SnippetParser(!!ultisnip, matchCode).parse(snippet, true);
        let maxIndexAdded = nested.maxIndexNumber + 1;
        let changed = /* @__PURE__ */ new Map();
        for (let p of nested.placeholders) {
          let idx = p.index;
          if (p.isFinalTabstop) {
            p.index = maxIndexAdded + index;
          } else {
            p.index = p.index + index;
          }
          changed.set(idx, p.index);
        }
        if (ultisnip) {
          nested.pyBlocks.forEach((b) => {
            b.update(changed);
          });
        }
        let map = /* @__PURE__ */ new Map();
        this.walk((m) => {
          if (m instanceof Placeholder && m.index > index) {
            let idx = m.index;
            m.index = m.index + maxIndexAdded;
            map.set(idx, m.index);
          }
          return true;
        });
        if (this.hasPython) {
          this.walk((m) => {
            if (m instanceof CodeBlock) {
              m.update(map);
            }
            return true;
          });
        }
        const select = nested.first;
        let children = nested.children.slice();
        if (before)
          children.unshift(new Text(before));
        if (after)
          children.push(new Text(after));
        this.replace(marker, children);
        return select;
      }
      async update(nvim, marker, value) {
        this.resetMarker(marker, value);
        if (this.hasPython) {
          await this.updatePythonCodes(nvim, marker);
        }
      }
      deleteText(offset, length) {
        let pos = 0;
        let marker;
        let end = offset + length;
        let start = 0;
        this.walk((candidate) => {
          let len = candidate.len();
          if (candidate instanceof Text && offset >= pos && pos + len >= end) {
            marker = candidate;
            start = offset - pos;
            return false;
          }
          pos += len;
          return true;
        });
        if (!marker)
          return false;
        let parent = marker.parent;
        let text = marker.value;
        let value = text.slice(0, start) + text.slice(start + length);
        let children = parent.children.slice();
        let idx = children.indexOf(marker);
        children.splice(idx, 1, new Text(value));
        parent.replaceChildren(children);
        return true;
      }
      resetMarker(marker, val) {
        let markers;
        if (marker instanceof Placeholder) {
          markers = this.placeholders.filter((o) => o.index == marker.index);
        } else {
          markers = this.variables.filter((o) => o.name == marker.name);
        }
        for (let p of markers) {
          let newText = p.transform ? p.transform.resolve(val) : val;
          p.setOnlyChild(new Text(newText || ""));
        }
        this.synchronizeParents(markers);
        this.reset();
      }
      onPlaceholderUpdate(marker) {
        let val = marker.toString();
        let markers;
        if (marker instanceof Placeholder) {
          this.values[marker.index] = val;
          markers = this.placeholders.filter((o) => o.index == marker.index);
        } else {
          markers = this.variables.filter((o) => o.name == marker.name);
        }
        for (let p of markers) {
          if (p === marker)
            continue;
          let newText = p.transform ? p.transform.resolve(val) : val;
          p.setOnlyChild(new Text(toText(newText)));
        }
        this.synchronizeParents(markers);
      }
      synchronizeParents(markers) {
        let arr = [];
        markers.forEach((m) => {
          let p = m.parent;
          if (p instanceof Placeholder && !arr.includes(p)) {
            arr.push(p);
          }
        });
        arr.forEach((p) => {
          this.onPlaceholderUpdate(p);
        });
      }
      offset(marker) {
        let pos = 0;
        let found = false;
        this.walk((candidate) => {
          if (candidate === marker) {
            found = true;
            return false;
          }
          pos += candidate.len();
          return true;
        });
        if (!found) {
          return -1;
        }
        return pos;
      }
      fullLen(marker) {
        let ret = 0;
        walk([marker], (marker2) => {
          ret += marker2.len();
          return true;
        });
        return ret;
      }
      getTextBefore(marker, parent) {
        let res = "";
        const calc = (m) => {
          let p = m.parent;
          if (!p)
            return;
          let s = "";
          for (let b of p.children) {
            if (b === m)
              break;
            s = s + b.toString();
          }
          res = s + res;
          if (p == parent)
            return;
          calc(p);
        };
        calc(marker);
        return res;
      }
      enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
          if (parent instanceof Placeholder) {
            ret.push(parent);
          }
          parent = parent.parent;
        }
        return ret;
      }
      async resolveVariables(resolver2) {
        let items = [];
        this.walk((candidate) => {
          if (candidate instanceof Variable && !candidate.resolved) {
            items.push(candidate);
          }
          return true;
        });
        if (items.length) {
          await Promise.all(items.map((o) => o.resolve(resolver2)));
          this.synchronizeParents(items);
        }
      }
      appendChild(child) {
        this.reset();
        return super.appendChild(child);
      }
      replace(marker, children) {
        marker.replaceChildren(children);
        if (marker instanceof Placeholder || marker instanceof Variable) {
          this.onPlaceholderUpdate(marker);
        }
        this.reset();
      }
      reset() {
        this._placeholders = void 0;
        this._values = void 0;
      }
      toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
      }
      clone() {
        let ret = new TextmateSnippet(this.ultisnip);
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
      walk(visitor) {
        walk(this.children, visitor);
      }
    };
    SnippetParser = class {
      constructor(ultisnip, matchCode) {
        this.ultisnip = ultisnip;
        this.matchCode = matchCode;
        this._scanner = new Scanner();
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      static isPlainText(value) {
        let s = new SnippetParser().parse(value.replace(/\$0$/, ""), false);
        return s.children.length == 1 && s.children[0] instanceof Text;
      }
      text(value) {
        return this.parse(value, false).toString();
      }
      parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet(this.ultisnip);
        while (this._parse(snippet)) {
        }
        const defaultValues = /* @__PURE__ */ new Map();
        const incompletePlaceholders = [];
        let complexPlaceholders = [];
        let hasFinal = false;
        snippet.walk((marker) => {
          if (marker instanceof Placeholder) {
            if (marker.index == 0)
              hasFinal = true;
            if (marker.children.some((o) => o instanceof Placeholder)) {
              complexPlaceholders.push(marker);
            } else if (!defaultValues.has(marker.index) && marker.children.length > 0) {
              marker.primary = true;
              defaultValues.set(marker.index, marker.toString());
            } else {
              incompletePlaceholders.push(marker);
            }
          }
          return true;
        });
        const complexIndexes = complexPlaceholders.map((p) => p.index);
        for (const placeholder of incompletePlaceholders) {
          if (defaultValues.has(placeholder.index)) {
            let val = defaultValues.get(placeholder.index);
            let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
            placeholder.setOnlyChild(text);
          } else if (!complexIndexes.includes(placeholder.index)) {
            if (placeholder.transform) {
              let text = new Text(placeholder.transform.resolve(""));
              placeholder.setOnlyChild(text);
            } else {
              placeholder.primary = true;
              defaultValues.set(placeholder.index, "");
            }
          }
        }
        const resolveComplex = () => {
          let resolved = /* @__PURE__ */ new Set();
          for (let p of complexPlaceholders) {
            if (p.children.every((o) => !(o instanceof Placeholder) || defaultValues.has(o.index))) {
              let val = p.toString();
              defaultValues.set(p.index, val);
              for (let placeholder of incompletePlaceholders.filter((o) => o.index == p.index)) {
                let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
                placeholder.setOnlyChild(text);
              }
              resolved.add(p.index);
            }
          }
          complexPlaceholders = complexPlaceholders.filter((p) => !resolved.has(p.index));
          if (complexPlaceholders.length == 0 || !resolved.size)
            return;
          resolveComplex();
        };
        resolveComplex();
        if (!hasFinal && insertFinalTabstop) {
          snippet.appendChild(new Placeholder(0));
        }
        return snippet;
      }
      _accept(type, value) {
        if (type === void 0 || this._token.type === type) {
          let ret = !value ? true : this._scanner.tokenText(this._token);
          this._token = this._scanner.next();
          return ret;
        }
        return false;
      }
      _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
      }
      _until(type, checkBackSlash = false) {
        if (this._token.type === 14 /* EOF */) {
          return false;
        }
        let start = this._token;
        let pre;
        while (this._token.type !== type || checkBackSlash && pre && pre.type === 5 /* Backslash */) {
          if (checkBackSlash)
            pre = this._token;
          this._token = this._scanner.next();
          if (this._token.type === 14 /* EOF */) {
            return false;
          }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
      }
      _parse(marker) {
        return this._parseEscaped(marker) || this._parseCodeBlock(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
      }
      _parseEscaped(marker) {
        let value;
        if (value = this._accept(5 /* Backslash */, true)) {
          value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || this.ultisnip && this._accept(3 /* CurlyOpen */, true) || this.ultisnip && this._accept(17 /* BackTick */, true) || value;
          marker.appendChild(new Text(value));
          return true;
        }
        return false;
      }
      _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
        if (!match) {
          return this._backTo(token);
        }
        if (/^\d+$/.test(value)) {
          parent.appendChild(new Placeholder(Number(value)));
        } else {
          if (this.ultisnip && !ULTISNIP_VARIABLES.includes(value)) {
            parent.appendChild(new Text("$" + value));
          } else {
            parent.appendChild(new Variable(value));
          }
        }
        return true;
      }
      _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));
        if (!match) {
          return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1 /* Colon */)) {
          while (true) {
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(placeholder);
              return true;
            }
            if (this._parse(placeholder)) {
              continue;
            }
            parent.appendChild(new Text("${" + index + ":"));
            placeholder.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
          const choice = new Choice();
          while (true) {
            if (this._parseChoiceElement(choice)) {
              if (this._accept(2 /* Comma */)) {
                continue;
              }
              if (this._accept(7 /* Pipe */)) {
                placeholder.appendChild(choice);
                if (this._accept(4 /* CurlyClose */)) {
                  parent.appendChild(placeholder);
                  return true;
                }
              }
            }
            this._backTo(token);
            return false;
          }
        } else if (this._accept(6 /* Forwardslash */)) {
          if (this._parseTransform(placeholder)) {
            parent.appendChild(placeholder);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(placeholder);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        while (true) {
          if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
            break;
          }
          let value;
          if (value = this._accept(5 /* Backslash */, true)) {
            value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;
          } else {
            value = this._accept(void 0, true);
          }
          if (!value) {
            this._backTo(token);
            return false;
          }
          values.push(value);
        }
        if (values.length === 0) {
          this._backTo(token);
          return false;
        }
        parent.appendChild(new Text(values.join("")));
        return true;
      }
      _parseComplexVariable(parent) {
        let name2;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name2 = this._accept(9 /* VariableName */, true));
        if (!match) {
          return this._backTo(token);
        }
        if (this.ultisnip && !ULTISNIP_VARIABLES.includes(name2)) {
          return this._backTo(token);
        }
        const variable = new Variable(name2);
        if (this._accept(1 /* Colon */)) {
          while (true) {
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(variable);
              return true;
            }
            if (this._parse(variable)) {
              continue;
            }
            parent.appendChild(new Text("${" + name2 + ":"));
            variable.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (this._accept(6 /* Forwardslash */)) {
          if (this._parseTransform(variable)) {
            parent.appendChild(variable);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(variable);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseTransform(parent) {
        let transform = new Transform();
        transform.ultisnip = this.ultisnip === true;
        let regexValue = "";
        let regexOptions = "";
        while (true) {
          if (this._accept(6 /* Forwardslash */)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5 /* Backslash */, true)) {
            escaped = this._accept(6 /* Forwardslash */, true) || escaped;
            regexValue += escaped;
            continue;
          }
          if (this._token.type !== 14 /* EOF */) {
            regexValue += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(6 /* Forwardslash */)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5 /* Backslash */, true)) {
            escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;
            transform.appendChild(new Text(escaped));
            continue;
          }
          if (this._parseFormatString(transform) || this._parseConditionString(transform) || this._parseAnything(transform)) {
            continue;
          }
          return false;
        }
        let ascii = false;
        while (true) {
          if (this._accept(4 /* CurlyClose */)) {
            break;
          }
          if (this._token.type !== 14 /* EOF */) {
            let c = this._accept(void 0, true);
            if (c == "a") {
              ascii = true;
            } else {
              if (!knownRegexOptions.includes(c)) {
                logger20.error(`Unknown regex option: ${c}`);
              }
              regexOptions += c;
            }
            continue;
          }
          return false;
        }
        try {
          if (ascii)
            transform.ascii = true;
          if (this.ultisnip)
            regexValue = convertRegex(regexValue);
          transform.regexp = new RegExp(regexValue, regexOptions);
        } catch (e) {
          return false;
        }
        parent.transform = transform;
        return true;
      }
      _parseConditionString(parent) {
        if (!this.ultisnip)
          return false;
        const token = this._token;
        if (!this._accept(15 /* OpenParen */)) {
          return false;
        }
        if (!this._accept(13 /* QuestionMark */)) {
          this._backTo(token);
          return false;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
          this._backTo(token);
          return false;
        }
        if (!this._accept(1 /* Colon */)) {
          this._backTo(token);
          return false;
        }
        let text = this._until(16 /* CloseParen */, true);
        if (text) {
          let i = 0;
          while (i < text.length) {
            let t = text[i];
            if (t == ":" && text[i - 1] != "\\") {
              break;
            }
            i++;
          }
          let ifValue = text.slice(0, i);
          let elseValue = text.slice(i + 1);
          parent.appendChild(new ConditionString(Number(index), ifValue, elseValue));
          return true;
        }
        this._backTo(token);
        return false;
      }
      _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0 /* Dollar */)) {
          return false;
        }
        let complex = false;
        if (this._accept(3 /* CurlyOpen */)) {
          complex = true;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
          this._backTo(token);
          return false;
        } else if (!complex) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (!this._accept(1 /* Colon */)) {
          this._backTo(token);
          return false;
        }
        if (this.ultisnip) {
          this._backTo(token);
          return false;
        }
        if (this._accept(6 /* Forwardslash */)) {
          let shorthand = this._accept(9 /* VariableName */, true);
          if (!shorthand || !this._accept(4 /* CurlyClose */)) {
            this._backTo(token);
            return false;
          } else {
            parent.appendChild(new FormatString(Number(index), shorthand));
            return true;
          }
        } else if (this._accept(11 /* Plus */)) {
          let ifValue = this._until(4 /* CurlyClose */);
          if (ifValue) {
            parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
            return true;
          }
        } else if (this._accept(12 /* Dash */)) {
          let elseValue = this._until(4 /* CurlyClose */);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        } else if (this._accept(13 /* QuestionMark */)) {
          let ifValue = this._until(1 /* Colon */);
          if (ifValue) {
            let elseValue = this._until(4 /* CurlyClose */);
            if (elseValue) {
              parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
              return true;
            }
          }
        } else {
          let elseValue = this._until(4 /* CurlyClose */);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseCodeBlock(parent) {
        if (!this.ultisnip)
          return false;
        const token = this._token;
        if (!this._accept(17 /* BackTick */)) {
          return false;
        }
        let text = this._until(17 /* BackTick */, true);
        if (text) {
          if (!text.startsWith("!")) {
            let marker = new CodeBlock(text.trim(), "shell");
            parent.appendChild(marker);
            return true;
          }
          if (text.startsWith("!v")) {
            let marker = new CodeBlock(text.slice(2).trim(), "vim");
            parent.appendChild(marker);
            return true;
          }
          if (text.startsWith("!p")) {
            let code = text.slice(2);
            let pre = this.matchCode ? this.matchCode + "\n" : "";
            if (code.indexOf("\n") == -1) {
              let marker = new CodeBlock(pre + code.trim(), "python");
              parent.appendChild(marker);
            } else {
              let codes = code.split(/\r?\n/);
              codes = codes.filter((s) => !/^\s*$/.test(s));
              if (!codes.length)
                return true;
              let ind = codes[0].match(/^\s*/)[0];
              if (ind.length && codes.every((s) => s.startsWith(ind))) {
                codes = codes.map((s) => s.slice(ind.length));
              }
              if (ind == " " && codes[0].startsWith(ind))
                codes[0] = codes[0].slice(1);
              let marker = new CodeBlock(pre + codes.join("\n"), "python");
              parent.appendChild(marker);
            }
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseAnything(marker) {
        if (this._token.type !== 14 /* EOF */) {
          let text = this._scanner.tokenText(this._token);
          marker.appendChild(new Text(text));
          this._accept(void 0);
          return true;
        }
        return false;
      }
    };
    escapedCharacters = [":", "(", ")", "{", "}"];
  }
});

// src/util/map.ts
var _a, LinkedMap, LRUCache;
var init_map = __esm({
  "src/util/map.ts"() {
    "use strict";
    LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a2;
        return (_a2 = this._head) == null ? void 0 : _a2.value;
      }
      get last() {
        var _a2;
        return (_a2 = this._tail) == null ? void 0 : _a2.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = 0 /* None */) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== 0 /* None */) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = 0 /* None */) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== 0 /* None */) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case 0 /* None */:
              this.addItemLast(item);
              break;
            case 1 /* AsOld */:
              this.addItemFirst(item);
              break;
            case 2 /* AsNew */:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */) {
          return;
        }
        if (touch === 1 /* AsOld */) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = 2 /* AsNew */) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, 0 /* None */);
      }
      set(key, value) {
        super.set(key, value, 2 /* AsNew */);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
  }
});

// src/completion/util.ts
function useAscii(input) {
  return input.length > 0 && input.charCodeAt(0) < ASCII_END;
}
function getKindText(kind, kindMap, defaultKindText) {
  return number(kind) ? kindMap.get(kind) ?? defaultKindText : kind;
}
function getKindHighlight(kind) {
  return number(kind) ? highlightsMap[kind] ?? DEFAULT_HL_GROUP : DEFAULT_HL_GROUP;
}
function getPriority(source, defaultValue2) {
  if (number(source.priority)) {
    return source.priority;
  }
  return defaultValue2;
}
function getDetail(item, filetype) {
  const { detail, labelDetails, label } = item;
  if (!isEmpty(labelDetails)) {
    let content = (labelDetails.detail ?? "") + (labelDetails.description ? ` ${labelDetails.description}` : "");
    return { filetype: "txt", content };
  }
  if (detail && detail !== label) {
    let isText = /^[\w-\s.,\t\n]+$/.test(detail);
    return { filetype: isText ? "txt" : filetype, content: detail };
  }
  return void 0;
}
function toCompleteDoneItem(selected, item) {
  if (!item || !selected)
    return {};
  return Object.assign({
    word: selected.word,
    source: selected.source.name,
    user_data: `${selected.source.name}:0`
  }, item);
}
function getDocumentaions(completeItem, filetype, detailRendered = false) {
  let docs = [];
  if (isCompletionItem(completeItem)) {
    let { documentation } = completeItem;
    if (!detailRendered) {
      let doc = getDetail(completeItem, filetype);
      if (doc)
        docs.push(doc);
    }
    if (documentation) {
      if (typeof documentation == "string") {
        docs.push({ filetype: "txt", content: documentation });
      } else if (documentation.value) {
        docs.push({
          filetype: documentation.kind == "markdown" ? "markdown" : "txt",
          content: documentation.value
        });
      }
    }
  } else {
    if (completeItem.documentation) {
      docs = completeItem.documentation;
    } else if (completeItem.info) {
      docs.push({ content: completeItem.info, filetype: "txt" });
    }
  }
  return docs;
}
function getResumeInput(option, pretext) {
  const { line, position } = option;
  const cursor = position.character;
  const pl = pretext.length;
  if (pl < cursor)
    return null;
  for (let i = 0; i < pl; i++) {
    if (i < cursor) {
      if (pretext.charCodeAt(i) !== line.charCodeAt(i)) {
        return null;
      }
    } else if (pretext.charCodeAt(i) === 32 /* Space */) {
      return null;
    }
  }
  return byteSlice(pretext, option.col);
}
function checkIgnoreRegexps(ignoreRegexps, input) {
  if (!ignoreRegexps || ignoreRegexps.length == 0 || input.length == 0)
    return false;
  return ignoreRegexps.some((regexp) => {
    try {
      return new RegExp(regexp).test(input);
    } catch (e) {
      return false;
    }
  });
}
function createKindMap(labels) {
  return /* @__PURE__ */ new Map([
    [CompletionItemKind.Text, labels["text"] ?? "v"],
    [CompletionItemKind.Method, labels["method"] ?? "f"],
    [CompletionItemKind.Function, labels["function"] ?? "f"],
    [CompletionItemKind.Constructor, typeof labels["constructor"] == "function" ? "f" : labels["constructor"] ?? ""],
    [CompletionItemKind.Field, labels["field"] ?? "m"],
    [CompletionItemKind.Variable, labels["variable"] ?? "v"],
    [CompletionItemKind.Class, labels["class"] ?? "C"],
    [CompletionItemKind.Interface, labels["interface"] ?? "I"],
    [CompletionItemKind.Module, labels["module"] ?? "M"],
    [CompletionItemKind.Property, labels["property"] ?? "m"],
    [CompletionItemKind.Unit, labels["unit"] ?? "U"],
    [CompletionItemKind.Value, labels["value"] ?? "v"],
    [CompletionItemKind.Enum, labels["enum"] ?? "E"],
    [CompletionItemKind.Keyword, labels["keyword"] ?? "k"],
    [CompletionItemKind.Snippet, labels["snippet"] ?? "S"],
    [CompletionItemKind.Color, labels["color"] ?? "v"],
    [CompletionItemKind.File, labels["file"] ?? "F"],
    [CompletionItemKind.Reference, labels["reference"] ?? "r"],
    [CompletionItemKind.Folder, labels["folder"] ?? "F"],
    [CompletionItemKind.EnumMember, labels["enumMember"] ?? "m"],
    [CompletionItemKind.Constant, labels["constant"] ?? "v"],
    [CompletionItemKind.Struct, labels["struct"] ?? "S"],
    [CompletionItemKind.Event, labels["event"] ?? "E"],
    [CompletionItemKind.Operator, labels["operator"] ?? "O"],
    [CompletionItemKind.TypeParameter, labels["typeParameter"] ?? "T"]
  ]);
}
function shouldStop(bufnr, pretext, info, option) {
  let { pre } = info;
  if (pre.length === 0 || pre[pre.length - 1] === " " || pre.length < pretext.length)
    return true;
  if (option.bufnr != bufnr)
    return true;
  let text = byteSlice(option.line, 0, option.colnr - 1);
  if (option.linenr != info.lnum || !pre.startsWith(text))
    return true;
  return false;
}
function getInput(chars, pre, asciiCharactersOnly) {
  let len = 0;
  let prev;
  for (let i = pre.length - 1; i >= 0; i--) {
    let code = pre.charCodeAt(i);
    let word = isWordCode(chars, code, asciiCharactersOnly);
    if (!word || prev !== void 0 && !sameScope(prev, code)) {
      break;
    }
    len += 1;
    prev = code;
  }
  return len == 0 ? "" : pre.slice(-len);
}
function isWordCode(chars, code, asciiCharactersOnly) {
  if (!chars.isKeywordCode(code))
    return false;
  if (isLowSurrogate(code))
    return false;
  if (asciiCharactersOnly && code >= 255)
    return false;
  return true;
}
function highlightOffert(pre, item) {
  let { filterText, abbr } = item;
  let idx = abbr.indexOf(filterText);
  if (idx == -1)
    return -1;
  let n = idx == 0 ? 0 : byteIndex(abbr, idx);
  return pre + n;
}
function emptLabelDetails(labelDetails) {
  if (!labelDetails)
    return true;
  return !labelDetails.detail && !labelDetails.description;
}
function isSnippetItem(item, itemDefaults) {
  let insertTextFormat = item.insertTextFormat ?? itemDefaults.insertTextFormat;
  return insertTextFormat === InsertTextFormat.Snippet;
}
function hasAction(item, itemDefaults) {
  return isSnippetItem(item, itemDefaults) || !isFalsyOrEmpty(item.additionalTextEdits);
}
function toValidWord(snippet, excludes) {
  for (let i = 0; i < snippet.length; i++) {
    let code = snippet.charCodeAt(i);
    if (excludes.includes(code)) {
      return snippet.slice(0, i);
    }
  }
  return snippet;
}
function snippetToWord(text, kind) {
  if (kind === CompletionItemKind.Function || kind === CompletionItemKind.Method || kind === CompletionItemKind.Class) {
    text = text.replace(/\(.+/, "");
  }
  if (!text.includes(DollarSign))
    return text;
  return toValidWord(new SnippetParser().text(text), INVALID_WORD_CHARS);
}
function getWord(item, itemDefaults) {
  let { label, data, kind } = item;
  if (data && string(data.word))
    return data.word;
  let textToInsert = item.textEdit ? item.textEdit.newText : item.insertText;
  if (!string(textToInsert))
    return label;
  return isSnippetItem(item, itemDefaults) ? snippetToWord(textToInsert, kind) : toValidWord(textToInsert, INVALID_WORD_CHARS);
}
function getReplaceRange(item, itemDefaults, character, insertMode) {
  let editRange;
  if (item.textEdit) {
    editRange = InsertReplaceEdit.is(item.textEdit) ? item.textEdit : item.textEdit.range;
  } else if (itemDefaults.editRange) {
    editRange = itemDefaults.editRange;
  }
  let range;
  if (editRange) {
    if (Range.is(editRange)) {
      range = editRange;
    } else {
      range = insertMode == "insert" /* Insert */ ? editRange.insert : editRange.replace;
    }
  }
  if (range && number(character) && range.start.character > character)
    range.start.character = character;
  return range;
}
function toItemKey(item) {
  let label = item.filterText;
  let source = item.source.name;
  let kind = item.kind ?? "";
  return `${label}|${source}|${kind}`;
}
var INVALID_WORD_CHARS, DollarSign, QuestionMark, MAX_CODE_POINT, MAX_MRU_ITEMS, DEFAULT_HL_GROUP, highlightsMap, Converter, MruLoader;
var init_util3 = __esm({
  "src/completion/util.ts"() {
    "use strict";
    init_main();
    init_chars();
    init_parser3();
    init_array();
    init_charCode();
    init_constants();
    init_is();
    init_map();
    init_node();
    init_object();
    init_string();
    init_types2();
    INVALID_WORD_CHARS = [10 /* LineFeed */, 13 /* CarriageReturn */];
    DollarSign = "$";
    QuestionMark = "?";
    MAX_CODE_POINT = 1114111;
    MAX_MRU_ITEMS = 100;
    DEFAULT_HL_GROUP = "CocSymbolDefault";
    highlightsMap = {
      [CompletionItemKind.Text]: "CocSymbolText",
      [CompletionItemKind.Method]: "CocSymbolMethod",
      [CompletionItemKind.Function]: "CocSymbolFunction",
      [CompletionItemKind.Constructor]: "CocSymbolConstructor",
      [CompletionItemKind.Field]: "CocSymbolField",
      [CompletionItemKind.Variable]: "CocSymbolVariable",
      [CompletionItemKind.Class]: "CocSymbolClass",
      [CompletionItemKind.Interface]: "CocSymbolInterface",
      [CompletionItemKind.Module]: "CocSymbolModule",
      [CompletionItemKind.Property]: "CocSymbolProperty",
      [CompletionItemKind.Unit]: "CocSymbolUnit",
      [CompletionItemKind.Value]: "CocSymbolValue",
      [CompletionItemKind.Enum]: "CocSymbolEnum",
      [CompletionItemKind.Keyword]: "CocSymbolKeyword",
      [CompletionItemKind.Snippet]: "CocSymbolSnippet",
      [CompletionItemKind.Color]: "CocSymbolColor",
      [CompletionItemKind.File]: "CocSymbolFile",
      [CompletionItemKind.Reference]: "CocSymbolReference",
      [CompletionItemKind.Folder]: "CocSymbolFolder",
      [CompletionItemKind.EnumMember]: "CocSymbolEnumMember",
      [CompletionItemKind.Constant]: "CocSymbolConstant",
      [CompletionItemKind.Struct]: "CocSymbolStruct",
      [CompletionItemKind.Event]: "CocSymbolEvent",
      [CompletionItemKind.Operator]: "CocSymbolOperator",
      [CompletionItemKind.TypeParameter]: "CocSymbolTypeParameter"
    };
    Converter = class {
      constructor(inputStart, option, opt) {
        this.inputStart = inputStart;
        this.option = option;
        this.opt = opt;
        this.previousCache = /* @__PURE__ */ new Map();
        this.postCache = /* @__PURE__ */ new Map();
        this.minCharacter = Number.MAX_SAFE_INTEGER;
        this.character = opt.position.character;
        this.inputLen = opt.position.character - inputStart;
      }
      getPrevious(character) {
        if (this.previousCache.has(character))
          return this.previousCache.get(character);
        let prev = this.opt.line.slice(character, this.inputStart);
        this.previousCache.set(character, prev);
        return prev;
      }
      getAfter(character) {
        if (this.postCache.has(character))
          return this.postCache.get(character);
        let text = this.opt.line.slice(this.character, character);
        this.postCache.set(character, text);
        return text;
      }
      fixFollow(word, isSnippet, endCharacter) {
        if (isSnippet || endCharacter <= this.character)
          return word;
        let toReplace = this.getAfter(endCharacter);
        if (word.length - this.inputLen > toReplace.length && word.endsWith(toReplace)) {
          return word.slice(0, -toReplace.length);
        }
        return word;
      }
      getDelta(filterText, character) {
        if (character < this.inputStart) {
          let prev = this.getPrevious(character);
          if (filterText.startsWith(prev))
            return prev.length;
        }
        return 0;
      }
      convertToDurationItem(item) {
        if (isCompletionItem(item)) {
          return this.convertLspCompleteItem(item);
        } else if (string(item.word)) {
          return this.convertVimCompleteItem(item);
        }
        return void 0;
      }
      convertVimCompleteItem(item) {
        const { option } = this;
        const { range, asciiMatch } = option;
        const word = toText(item.word);
        const character = range.start.character;
        this.minCharacter = Math.min(this.minCharacter, character);
        let filterText = item.filterText ?? word;
        filterText = asciiMatch ? unidecode(filterText) : filterText, character;
        const delta = this.getDelta(filterText, character);
        return {
          word: this.fixFollow(word, item.isSnippet, range.end.character),
          abbr: item.abbr ?? word,
          filterText,
          delta,
          character,
          dup: item.dup === 1,
          menu: item.menu,
          kind: item.kind,
          isSnippet: !!item.isSnippet,
          insertText: item.insertText,
          preselect: item.preselect,
          sortText: item.sortText,
          deprecated: item.deprecated,
          detail: item.detail,
          labelDetails: item.labelDetails,
          get source() {
            return option.source;
          },
          get priority() {
            return option.source.priority ?? 99;
          },
          get shortcut() {
            return toText(option.source.shortcut);
          }
        };
      }
      convertLspCompleteItem(item) {
        var _a2;
        const { option, inputStart } = this;
        const label = item.label.trim();
        const itemDefaults = toObject(option.itemDefaults);
        const word = getWord(item, itemDefaults);
        const range = getReplaceRange(item, itemDefaults, inputStart, this.option.insertMode) ?? option.range;
        const character = range.start.character;
        const data = toObject(item.data);
        const filterText = item.filterText ?? item.label;
        const delta = this.getDelta(filterText, character);
        let obj = {
          word: this.fixFollow(word, isSnippetItem(item, itemDefaults), range.end.character),
          abbr: label,
          character,
          delta,
          kind: item.kind,
          detail: item.detail,
          sortText: item.sortText,
          filterText,
          preselect: item.preselect === true,
          deprecated: item.deprecated === true || ((_a2 = item.tags) == null ? void 0 : _a2.includes(CompletionItemTag.Deprecated)),
          isSnippet: hasAction(item, itemDefaults),
          get source() {
            return option.source;
          },
          get priority() {
            return option.priority;
          },
          get shortcut() {
            return toText(option.source.shortcut);
          },
          dup: data.dup !== 0
        };
        this.minCharacter = Math.min(this.minCharacter, character);
        if (data.optional && !obj.abbr.endsWith(QuestionMark))
          obj.abbr += QuestionMark;
        if (!emptLabelDetails(item.labelDetails))
          obj.labelDetails = item.labelDetails;
        if (number(item["score"]) && !obj.sortText)
          obj.sortText = String.fromCodePoint(MAX_CODE_POINT - Math.round(item["score"]));
        return obj;
      }
    };
    MruLoader = class {
      constructor() {
        this.max = 0;
        this.items = new LRUCache(MAX_MRU_ITEMS);
        this.itemsNoPrefex = new LRUCache(MAX_MRU_ITEMS);
      }
      getScore(input, item, selection) {
        let key = toItemKey(item);
        if (input.length == 0)
          return this.itemsNoPrefex.get(key) ?? -1;
        if (selection === "recentlyUsedByPrefix" /* RecentlyUsedByPrefix */)
          key = `${input}|${key}`;
        let map = selection === "recentlyUsed" /* RecentlyUsed */ ? this.itemsNoPrefex : this.items;
        return map.get(key) ?? -1;
      }
      add(prefix, item) {
        if (!number(item.kind))
          return;
        let key = toItemKey(item);
        if (!item.filterText.startsWith(prefix)) {
          prefix = "";
        }
        let line = `${prefix}|${key}`;
        this.items.set(line, this.max);
        this.itemsNoPrefex.set(key, this.max);
        this.max += 1;
      }
      clear() {
        this.max = 0;
        this.items.clear();
        this.itemsNoPrefex.clear();
      }
    };
  }
});

// src/diagnostic/util.ts
function formatDiagnostic(format3, diagnostic) {
  let { source, code, severity, message } = diagnostic;
  let s = getSeverityName(severity)[0];
  const codeStr = code ? " " + code : "";
  return format3.replace("%source", source).replace("%code", codeStr).replace("%severity", s).replace("%message", message);
}
function getSeverityName(severity) {
  switch (severity) {
    case DiagnosticSeverity.Warning:
      return "Warning";
    case DiagnosticSeverity.Information:
      return "Information";
    case DiagnosticSeverity.Hint:
      return "Hint";
    default:
      return "Error";
  }
}
function getSeverityType(severity) {
  switch (severity) {
    case DiagnosticSeverity.Warning:
      return "W";
    case DiagnosticSeverity.Information:
      return "I";
    case DiagnosticSeverity.Hint:
      return "I";
    default:
      return "E";
  }
}
function severityLevel(level2) {
  if (level2 == null)
    return void 0;
  switch (level2) {
    case "hint":
      return DiagnosticSeverity.Hint;
    case "information":
      return DiagnosticSeverity.Information;
    case "warning":
      return DiagnosticSeverity.Warning;
    case "error":
      return DiagnosticSeverity.Error;
    default:
      return DiagnosticSeverity.Hint;
  }
}
function getNameFromSeverity(severity) {
  switch (severity) {
    case DiagnosticSeverity.Error:
      return "CocError";
    case DiagnosticSeverity.Warning:
      return "CocWarning";
    case DiagnosticSeverity.Information:
      return "CocInfo";
    case DiagnosticSeverity.Hint:
      return "CocHint";
    default:
      return "CocError";
  }
}
function getLocationListItem(bufnr, diagnostic, lines) {
  let { start, end } = diagnostic.range;
  let owner = diagnostic.source || "coc.nvim";
  let msg = diagnostic.message.split("\n")[0];
  let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
  return {
    bufnr,
    lnum: start.line + 1,
    end_lnum: end.line + 1,
    col: Array.isArray(lines) ? byteIndex(lines[start.line] ?? "", start.character) + 1 : start.character + 1,
    end_col: Array.isArray(lines) ? byteIndex(lines[end.line] ?? "", end.character) + 1 : end.character + 1,
    text: `[${owner}${diagnostic.code ? " " + diagnostic.code : ""}] ${msg} [${type}]`,
    type
  };
}
function sortDiagnostics(a, b) {
  let sa = a.severity ?? 1;
  let sb = b.severity ?? 1;
  if (sa != sb)
    return sa - sb;
  let d = comparePosition(a.range.start, b.range.start);
  if (d != 0)
    return d;
  return a.source > b.source ? 1 : -1;
}
function getHighlightGroup(diagnostic) {
  let tags = diagnostic.tags || [];
  if (tags.includes(DiagnosticTag.Deprecated)) {
    return "CocDeprecatedHighlight" /* Deprecated */;
  }
  if (tags.includes(DiagnosticTag.Unnecessary)) {
    return "CocUnusedHighlight" /* Unused */;
  }
  switch (diagnostic.severity) {
    case DiagnosticSeverity.Warning:
      return "CocWarningHighlight" /* Warning */;
    case DiagnosticSeverity.Information:
      return "CocInfoHighlight" /* Information */;
    case DiagnosticSeverity.Hint:
      return "CocHintHighlight" /* Hint */;
    default:
      return "CocErrorHighlight" /* Error */;
  }
}
function adjustDiagnostics(diagnostics, edit2) {
  let res = [];
  let { range } = edit2;
  for (let diag of diagnostics) {
    let r = diag.range;
    if (rangeOverlap(range, r))
      continue;
    if (comparePosition(r.start, range.end) > 0) {
      let s = getPosition(r.start, edit2);
      let e = getPosition(r.end, edit2);
      if (s.line >= 0 && s.character >= 0 && e.line >= 0 && e.character >= 0) {
        diag.range = Range.create(s, e);
      }
    }
    res.push(diag);
  }
  return res;
}
var init_util4 = __esm({
  "src/diagnostic/util.ts"() {
    "use strict";
    init_main();
    init_position();
    init_string();
    init_textedit();
  }
});

// src/diagnostic/buffer.ts
var signGroup, NAMESPACE, hlGroups, delay2, aleMethod, virtualTextSrcId, floatFactory, DiagnosticBuffer;
var init_buffer = __esm({
  "src/diagnostic/buffer.ts"() {
    "use strict";
    init_main();
    init_events();
    init_util();
    init_array();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    init_util4();
    signGroup = "CocDiagnostic";
    NAMESPACE = "diagnostic";
    hlGroups = ["CocErrorHighlight", "CocWarningHighlight", "CocInfoHighlight", "CocHintHighlight", "CocDeprecatedHighlight", "CocUnusedHighlight"];
    delay2 = getConditionValue(50, 10);
    aleMethod = getConditionValue("ale#other_source#ShowResults", "MockAleResults");
    DiagnosticBuffer = class {
      constructor(nvim, doc) {
        this.nvim = nvim;
        this.doc = doc;
        this.diagnosticsMap = /* @__PURE__ */ new Map();
        this._disposed = false;
        this._dirties = /* @__PURE__ */ new Set();
        this._refreshing = false;
        this._onDidRefresh = new import_node3.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.loadConfiguration();
        let timer;
        let fn = () => {
          clearTimeout(timer);
          this._refreshing = true;
          timer = setTimeout(() => {
            this._refreshing = false;
            if (!this._autoRefresh)
              return;
            void this._refresh(true);
          }, delay2);
        };
        fn.clear = () => {
          this._refreshing = false;
          clearTimeout(timer);
        };
        this.refreshHighlights = fn;
      }
      get _autoRefresh() {
        return this.config.enable && this.config.autoRefresh && this.dirty && !this.doc.hasChanged;
      }
      get config() {
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("diagnostic", this.doc);
        let changed = this._config && config.enable != this._config.enable;
        this._config = {
          enable: config.get("enable", true),
          floatConfig: config.get("floatConfig", {}),
          messageTarget: config.get("messageTarget", "float"),
          enableHighlightLineNumber: config.get("enableHighlightLineNumber", true),
          highlightLimit: config.get("highlightLimit", 1e3),
          highlightPriority: config.get("highlightPriority"),
          autoRefresh: config.get("autoRefresh", true),
          checkCurrentLine: config.get("checkCurrentLine", false),
          enableSign: workspace_default.env.sign && config.get("enableSign", true),
          locationlistUpdate: config.get("locationlistUpdate", true),
          enableMessage: config.get("enableMessage", "always"),
          virtualText: config.get("virtualText", false),
          virtualTextAlign: config.get("virtualTextAlign", "after"),
          virtualTextWinCol: config.get("virtualTextWinCol", null),
          virtualTextCurrentLineOnly: config.get("virtualTextCurrentLineOnly"),
          virtualTextPrefix: config.get("virtualTextPrefix", " "),
          virtualTextFormat: config.get("virtualTextFormat", "%message"),
          virtualTextLimitInOneLine: config.get("virtualTextLimitInOneLine", 999),
          virtualTextLineSeparator: config.get("virtualTextLineSeparator", " \\ "),
          virtualTextLines: config.get("virtualTextLines", 3),
          displayByAle: config.get("displayByAle", false),
          level: severityLevel(config.get("level", "hint")),
          locationlistLevel: severityLevel(config.get("locationlistLevel")),
          signLevel: severityLevel(config.get("signLevel")),
          virtualTextLevel: severityLevel(config.get("virtualTextLevel")),
          messageLevel: severityLevel(config.get("messageLevel")),
          signPriority: config.get("signPriority", 10),
          refreshOnInsertMode: config.get("refreshOnInsertMode", false),
          filetypeMap: config.get("filetypeMap", {}),
          showUnused: config.get("showUnused", true),
          showDeprecated: config.get("showDeprecated", true),
          format: config.get("format", "[%source%code] [%severity] %message")
        };
        if (this._config.virtualText && !virtualTextSrcId) {
          void this.nvim.createNamespace("coc-diagnostic-virtualText").then((id) => {
            virtualTextSrcId = id;
          });
        }
        if (changed) {
          if (this.config.enable) {
            void this._refresh(false);
          } else {
            this.clear();
          }
        }
      }
      async setState(enable) {
        let curr = this._config.enable;
        if (curr == enable)
          return;
        this._config.enable = enable;
        if (enable) {
          await this._refresh(false);
        } else {
          this.clear();
        }
      }
      get dirty() {
        return this._dirties.size > 0;
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      get uri() {
        return this.doc.uri;
      }
      onChange(e) {
        let changes = e.contentChanges;
        if (changes.length > 0) {
          let edit2 = TextEdit.replace(changes[0].range, changes[0].text);
          for (let [collection, diagnostics] of this.diagnosticsMap.entries()) {
            let arr = adjustDiagnostics(diagnostics, edit2);
            this.diagnosticsMap.set(collection, arr);
          }
          this._dirties = new Set(this.diagnosticsMap.keys());
        }
        if (!this.config.autoRefresh)
          return;
        this.refreshHighlights();
      }
      onTextChange() {
        this._dirties = new Set(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
      }
      get displayByAle() {
        return this._config.displayByAle;
      }
      clearHighlight(collection) {
        this.buffer.clearNamespace(NAMESPACE + collection);
      }
      clearSigns(collection) {
        this.buffer.unplaceSign({ group: signGroup + collection });
      }
      get diagnostics() {
        let res = [];
        for (let diags of this.diagnosticsMap.values()) {
          res.push(...diags);
        }
        return res;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      refreshAle(collection, diagnostics) {
        let aleItems = diagnostics.map((o) => {
          let range = o.range;
          return {
            text: o.message,
            code: o.code,
            lnum: range.start.line + 1,
            col: range.start.character + 1,
            end_lnum: range.end.line + 1,
            end_col: range.end.character,
            type: getSeverityType(o.severity)
          };
        });
        this.nvim.call(aleMethod, [this.bufnr, "coc" + collection, aleItems], true);
      }
      async update(collection, diagnostics) {
        let { diagnosticsMap } = this;
        let curr = diagnosticsMap.get(collection);
        if (!this._dirties.has(collection) && isFalsyOrEmpty(diagnostics) && isFalsyOrEmpty(curr))
          return;
        diagnosticsMap.set(collection, diagnostics);
        void this.checkFloat();
        if (!this.config.enable || diagnostics.length > 0 && this._refreshing) {
          this._dirties.add(collection);
          return;
        }
        let info = await this.getDiagnosticInfo(diagnostics.length === 0);
        if (!info || info.winid == -1) {
          this._dirties.add(collection);
          return;
        }
        let map = /* @__PURE__ */ new Map();
        map.set(collection, diagnostics);
        this.refresh(map, info);
      }
      async checkFloat() {
        if (workspace_default.bufnr != this.bufnr || !floatFactory)
          return;
        let pos = await window_default.getCursorPosition();
        let diagnostics = this.getDiagnosticsAtPosition(pos);
        if (diagnostics.length == 0) {
          floatFactory.close();
        }
      }
      async reset(diagnostics) {
        this.refreshHighlights.clear();
        let { diagnosticsMap } = this;
        for (let key of diagnosticsMap.keys()) {
          if (isFalsyOrEmpty(diagnostics[key]))
            diagnostics[key] = [];
        }
        for (let [key, value] of Object.entries(diagnostics)) {
          diagnosticsMap.set(key, value);
        }
        this._dirties = new Set(diagnosticsMap.keys());
        await this._refresh(false);
      }
      async onCursorHold(lnum, col) {
        if (this.config.enableMessage !== "always")
          return;
        let pos = this.doc.getPosition(lnum, col);
        await this.echoMessage(true, pos);
      }
      async echoMessage(truncate = false, position) {
        const config = this.config;
        if (!config.enable || config.enableMessage === "never" || config.displayByAle)
          return false;
        let useFloat = config.messageTarget == "float";
        let diagnostics = this.getDiagnosticsAtPosition(position);
        if (config.messageLevel) {
          diagnostics = diagnostics.filter((diagnostic) => {
            return diagnostic.severity && diagnostic.severity <= config.messageLevel;
          });
        }
        if (useFloat) {
          await this.showFloat(diagnostics);
        } else {
          const lines = [];
          diagnostics.forEach((diagnostic) => {
            lines.push(formatDiagnostic(config.format, diagnostic));
          });
          if (lines.length) {
            await this.nvim.command('echo ""');
            await window_default.echoLines(lines, truncate);
          }
        }
        return true;
      }
      async showVirtualTextCurrentLine(lnum) {
        let { config } = this;
        if (!config.virtualTextCurrentLineOnly || events_default.insertMode && !config.refreshOnInsertMode)
          return false;
        let enabled = await this.isEnabled();
        if (!enabled)
          return false;
        this.showVirtualText(lnum);
        return true;
      }
      async showFloat(diagnostics) {
        if (this.config.messageTarget !== "float")
          return false;
        if (!floatFactory)
          floatFactory = window_default.createFloatFactory({ modes: ["n"], autoHide: true });
        if (diagnostics.length == 0) {
          floatFactory.close();
          return false;
        }
        if (events_default.insertMode)
          return false;
        let config = this.config;
        let ft = "";
        let docs = [];
        if (Object.keys(config.filetypeMap).length > 0) {
          let filetype = this.doc.filetype;
          const defaultFiletype = config.filetypeMap["default"] || "";
          ft = config.filetypeMap[filetype] || (defaultFiletype == "bufferType" ? filetype : defaultFiletype);
        }
        diagnostics.forEach((diagnostic) => {
          var _a2;
          let filetype = "Error";
          if (ft === "") {
            switch (diagnostic.severity) {
              case DiagnosticSeverity.Hint:
                filetype = "Hint";
                break;
              case DiagnosticSeverity.Warning:
                filetype = "Warning";
                break;
              case DiagnosticSeverity.Information:
                filetype = "Info";
                break;
            }
          } else {
            filetype = ft;
          }
          docs.push({ filetype, content: formatDiagnostic(config.format, diagnostic) });
          if ((_a2 = diagnostic.codeDescription) == null ? void 0 : _a2.href) {
            docs.push({ filetype: "txt", content: diagnostic.codeDescription.href });
          }
        });
        await floatFactory.show(docs, this.config.floatConfig);
        return true;
      }
      async getDiagnosticInfo(force) {
        let { refreshOnInsertMode } = this._config;
        let { nvim, bufnr } = this;
        let checkInsert = !refreshOnInsertMode;
        if (force) {
          checkInsert = false;
        } else {
          let disabledByInsert = events_default.insertMode && !refreshOnInsertMode;
          if (disabledByInsert)
            return void 0;
        }
        return await nvim.call("coc#util#diagnostic_info", [bufnr, checkInsert]);
      }
      refresh(diagnosticsMap, info) {
        let { nvim, displayByAle } = this;
        for (let collection of diagnosticsMap.keys()) {
          this._dirties.delete(collection);
        }
        if (displayByAle) {
          nvim.pauseNotification();
          for (let [collection, diagnostics] of diagnosticsMap.entries()) {
            this.refreshAle(collection, diagnostics);
          }
          nvim.resumeNotification(true, true);
        } else {
          let emptyCollections = [];
          nvim.pauseNotification();
          for (let [collection, diagnostics] of diagnosticsMap.entries()) {
            if (diagnostics.length == 0)
              emptyCollections.push(collection);
            this.addSigns(collection, diagnostics);
            this.updateHighlights(collection, diagnostics);
          }
          this.showVirtualText(info.lnum);
          this.updateLocationList(info.winid, info.locationlist);
          this.setDiagnosticInfo();
          nvim.resumeNotification(true, true);
          emptyCollections.forEach((name2) => {
            this.diagnosticsMap.delete(name2);
          });
        }
        this._onDidRefresh.fire(this.diagnostics);
      }
      updateLocationList(winid, title) {
        if (!this._config.locationlistUpdate || winid == -1 || title !== "Diagnostics of coc")
          return;
        let items = this.toLocationListItems(this.diagnostics);
        this.nvim.call("coc#ui#setloclist", [winid, items, "r", "Diagnostics of coc"], true);
      }
      toLocationListItems(diagnostics) {
        let { locationlistLevel } = this._config;
        let items = [];
        let lines = this.doc.textDocument.lines;
        diagnostics.sort(sortDiagnostics);
        for (let diagnostic of diagnostics) {
          if (locationlistLevel && diagnostic.severity && diagnostic.severity > locationlistLevel)
            continue;
          items.push(getLocationListItem(this.bufnr, diagnostic, lines));
        }
        return items;
      }
      addSigns(collection, diagnostics) {
        let { enableSign, signLevel } = this._config;
        if (!enableSign)
          return;
        let group = signGroup + collection;
        let signs = [];
        let signsMap = /* @__PURE__ */ new Map();
        for (let diagnostic of diagnostics) {
          let { range, severity } = diagnostic;
          if (!severity || signLevel && severity > signLevel) {
            continue;
          }
          let line = range.start.line;
          let exists = signsMap.get(line) || [];
          if (exists.includes(severity)) {
            continue;
          }
          exists.push(severity);
          signsMap.set(line, exists);
          let priority = this._config.signPriority + 4 - severity;
          signs.push({ name: getNameFromSeverity(severity), lnum: line + 1, priority });
        }
        this.nvim.call("coc#ui#update_signs", [this.bufnr, group, signs], true);
      }
      setDiagnosticInfo() {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostics of this.diagnosticsMap.values()) {
          for (let diagnostic of diagnostics) {
            let lnum = diagnostic.range.start.line + 1;
            switch (diagnostic.severity) {
              case DiagnosticSeverity.Warning:
                info.warning = info.warning + 1;
                lnums[1] = lnums[1] ? Math.min(lnums[1], lnum) : lnum;
                break;
              case DiagnosticSeverity.Information:
                info.information = info.information + 1;
                lnums[2] = lnums[2] ? Math.min(lnums[2], lnum) : lnum;
                break;
              case DiagnosticSeverity.Hint:
                info.hint = info.hint + 1;
                lnums[3] = lnums[3] ? Math.min(lnums[3], lnum) : lnum;
                break;
              default:
                lnums[0] = lnums[0] ? Math.min(lnums[0], lnum) : lnum;
                info.error = info.error + 1;
            }
          }
        }
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.setVar("coc_diagnostic_info", info, true);
        this.nvim.call("coc#util#do_autocmd", ["CocDiagnosticChange"], true);
      }
      showVirtualText(lnum) {
        let { _config: config } = this;
        let { virtualText, virtualTextLevel } = config;
        if (!virtualText || lnum < 0)
          return;
        let { virtualTextPrefix, virtualTextLimitInOneLine, virtualTextCurrentLineOnly } = this._config;
        let { diagnostics, buffer } = this;
        if (virtualTextCurrentLineOnly) {
          diagnostics = diagnostics.filter((d) => {
            let { start, end } = d.range;
            return start.line <= lnum - 1 && end.line >= lnum - 1;
          });
        }
        diagnostics.sort(sortDiagnostics);
        buffer.clearNamespace(virtualTextSrcId);
        let map = /* @__PURE__ */ new Map();
        let opts = {
          text_align: config.virtualTextAlign,
          virt_text_win_col: config.virtualTextWinCol
        };
        for (let i = diagnostics.length - 1; i >= 0; i--) {
          let diagnostic = diagnostics[i];
          if (virtualTextLevel && diagnostic.severity && diagnostic.severity > virtualTextLevel) {
            continue;
          }
          let { line } = diagnostic.range.start;
          let highlight = getNameFromSeverity(diagnostic.severity) + "VirtualText";
          let msg = diagnostic.message.split(/\n/).map((l) => l.trim()).filter((l) => l.length > 0).slice(0, this._config.virtualTextLines).join(this._config.virtualTextLineSeparator);
          let arr = map.get(line) ?? [];
          arr.unshift([virtualTextPrefix + formatDiagnostic(this._config.virtualTextFormat, {
            ...diagnostic,
            message: msg
          }), highlight]);
          map.set(line, arr);
        }
        for (let [line, blocks] of map.entries()) {
          buffer.setVirtualText(virtualTextSrcId, line, blocks.slice(0, virtualTextLimitInOneLine), opts);
        }
      }
      updateHighlights(collection, diagnostics) {
        if (!diagnostics.length) {
          this.clearHighlight(collection);
        } else {
          let items = this.getHighlightItems(diagnostics);
          let priority = this._config.highlightPriority;
          this.buffer.updateHighlights(NAMESPACE + collection, items, { priority });
        }
      }
      async _refresh(dirtyOnly) {
        let info = await this.getDiagnosticInfo(!dirtyOnly);
        if (!info || info.winid == -1 || !this.config.enable)
          return;
        let { _dirties } = this;
        if (dirtyOnly) {
          let map = /* @__PURE__ */ new Map();
          for (let [key, diagnostics] of this.diagnosticsMap.entries()) {
            if (!_dirties.has(key))
              continue;
            map.set(key, diagnostics);
          }
          this.refresh(map, info);
        } else {
          this.refresh(this.diagnosticsMap, info);
        }
      }
      getHighlightItems(diagnostics) {
        let res = [];
        for (let i = 0; i < Math.min(this._config.highlightLimit, diagnostics.length); i++) {
          let diagnostic = diagnostics[i];
          let hlGroup = getHighlightGroup(diagnostic);
          this.doc.addHighlights(res, hlGroup, diagnostic.range);
        }
        res.sort((a, b) => {
          if (a.lnum != b.lnum)
            return a.lnum - b.lnum;
          if (a.colStart != b.colStart)
            return a.colStart - b.colStart;
          return hlGroups.indexOf(b.hlGroup) - hlGroups.indexOf(a.hlGroup);
        });
        return res;
      }
      clear() {
        let { nvim } = this;
        let collections = Array.from(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
        this._dirties.clear();
        if (this.displayByAle) {
          for (let collection of collections) {
            this.nvim.call(aleMethod, [this.bufnr, collection, []], true);
          }
        } else {
          nvim.pauseNotification();
          this.buffer.deleteVar("coc_diagnostic_info");
          for (let collection of collections) {
            this.clearHighlight(collection);
            this.clearSigns(collection);
          }
          if (this._config.virtualText) {
            this.buffer.clearNamespace(virtualTextSrcId);
          }
          nvim.resumeNotification(true, true);
        }
      }
      getDiagnosticsAt(pos, checkCurrentLine) {
        let diagnostics = [];
        for (let diags of this.diagnosticsMap.values()) {
          if (checkCurrentLine) {
            diagnostics.push(...diags.filter((o) => lineInRange(pos.line, o.range)));
          } else {
            diagnostics.push(...diags.filter((o) => positionInRange(pos, o.range) == 0));
          }
        }
        diagnostics.sort(sortDiagnostics);
        return diagnostics;
      }
      getDiagnosticsAtPosition(pos) {
        let { config, doc } = this;
        let res = this.getDiagnosticsAt(pos, config.checkCurrentLine);
        if (config.checkCurrentLine || res.length)
          return res;
        let total = doc.getline(pos.line).length;
        if (pos.character + 1 == total) {
          res = this.getDiagnosticsAt(Position.create(pos.line, pos.character + 1), false);
          if (res.length)
            return res;
        }
        if (pos.line === doc.lineCount - 1 && pos.character == 0) {
          pos = Position.create(pos.line + 1, 0);
          res = this.getDiagnosticsAt(pos, true);
        }
        return res;
      }
      async isEnabled() {
        if (this._disposed || !this.config.enable)
          return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let res = await buf.getVar("coc_diagnostic_disable");
        return res != 1;
      }
      dispose() {
        this.clear();
        this.diagnosticsMap.clear();
        this._onDidRefresh.dispose();
        this._disposed = true;
      }
    };
  }
});

// src/diagnostic/collection.ts
var HintTags, DiagnosticCollection;
var init_collection = __esm({
  "src/diagnostic/collection.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_array();
    init_protocol();
    init_workspace();
    HintTags = [DiagnosticTag.Deprecated, DiagnosticTag.Unnecessary];
    DiagnosticCollection = class {
      constructor(name2, onDispose) {
        this.name = name2;
        this.onDispose = onDispose;
        this.diagnosticsMap = /* @__PURE__ */ new Map();
        this._onDidDiagnosticsChange = new import_node3.Emitter();
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
      }
      set(entries, diagnostics) {
        let diagnosticsPerFile = /* @__PURE__ */ new Map();
        if (!Array.isArray(entries)) {
          let doc = workspace_default.getDocument(entries);
          let uri = doc ? doc.uri : entries;
          diagnosticsPerFile.set(uri, diagnostics || []);
        } else {
          for (let item of entries) {
            let [uri, diagnostics2] = item;
            let doc = workspace_default.getDocument(uri);
            uri = doc ? doc.uri : uri;
            if (diagnostics2 == null) {
              diagnostics2 = [];
            } else {
              diagnostics2 = (diagnosticsPerFile.get(uri) || []).concat(diagnostics2);
            }
            diagnosticsPerFile.set(uri, diagnostics2);
          }
        }
        for (let item of diagnosticsPerFile) {
          let [uri, diagnostics2] = item;
          uri = URI.parse(uri).toString();
          diagnostics2.forEach((o) => {
            o.range = o.range ?? Range.create(0, 0, 0, 0);
            o.message = o.message ?? "";
            o.source = o.source || this.name;
            if (!o.severity && Array.isArray(o.tags) && intersect(o.tags, HintTags)) {
              o.severity = DiagnosticSeverity.Hint;
            }
          });
          this.diagnosticsMap.set(uri, diagnostics2);
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      delete(uri) {
        this.diagnosticsMap.delete(uri);
        this._onDidDiagnosticsChange.fire(uri);
      }
      clear() {
        let uris = Array.from(this.diagnosticsMap.keys());
        uris = uris.filter((uri) => this.diagnosticsMap.get(uri).length > 0);
        this.diagnosticsMap.clear();
        for (let uri of uris) {
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
          let diagnostics = this.diagnosticsMap.get(uri);
          callback.call(thisArg, uri, diagnostics, this);
        }
      }
      entries() {
        return this.diagnosticsMap.entries();
      }
      get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr.slice();
      }
      has(uri) {
        return this.diagnosticsMap.has(uri);
      }
      dispose() {
        this.clear();
        if (this.onDispose)
          this.onDispose();
        this._onDidDiagnosticsChange.dispose();
      }
    };
  }
});

// src/diagnostic/manager.ts
var DiagnosticManager, manager_default;
var init_manager = __esm({
  "src/diagnostic/manager.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_events();
    init_util();
    init_array();
    init_constants();
    init_fs();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_buffer();
    init_collection();
    init_util4();
    DiagnosticManager = class {
      constructor() {
        this._onDidRefresh = new import_node3.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.enabled = true;
        this.collections = [];
        this.disposables = [];
      }
      init() {
        commands_default.register({
          id: "workspace.diagnosticRelated",
          execute: () => this.jumpRelated()
        }, false, "jump to related locations of current diagnostic.");
        this.defineSigns(workspace_default.initialConfiguration.get("diagnostic"));
        this.buffers = workspace_default.registerBufferSync((doc) => {
          let buf = new DiagnosticBuffer(this.nvim, doc);
          buf.onDidRefresh((diagnostics2) => {
            this._onDidRefresh.fire({ diagnostics: diagnostics2, uri: buf.uri, bufnr: buf.bufnr });
          });
          let diagnostics = this.getDiagnostics(buf);
          if (Object.keys(diagnostics).length > 0 && buf.config.autoRefresh) {
            void buf.reset(diagnostics);
          }
          return buf;
        });
        workspace_default.onDidChangeConfiguration((e) => {
          if (this.buffers && e.affectsConfiguration("diagnostic")) {
            for (let item of this.buffers.items) {
              item.loadConfiguration();
            }
          }
        }, null, this.disposables);
        let config = workspace_default.initialConfiguration.get("diagnostic");
        events_default.on("CursorMoved", (bufnr, cursor) => {
          if (this.messageTimer)
            clearTimeout(this.messageTimer);
          this.messageTimer = setTimeout(() => {
            let buf = this.buffers.getItem(bufnr);
            if (buf == null || buf.dirty)
              return;
            void Promise.allSettled([
              buf.onCursorHold(cursor[0], cursor[1]),
              buf.showVirtualTextCurrentLine(cursor[0])
            ]);
          }, config.messageDelay);
        }, null, this.disposables);
        events_default.on(["InsertEnter", "BufEnter"], () => {
          clearTimeout(this.messageTimer);
        }, null, this.disposables);
        events_default.on("InsertLeave", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (!buf || buf.config.refreshOnInsertMode)
            return;
          for (let buf2 of this.buffers.items) {
            buf2.refreshHighlights();
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.refreshHighlights();
        }, null, this.disposables);
        this.checkConfigurationErrors();
        workspace_default.configurations.onError((ev) => {
          const collection = this.create("config");
          collection.set(ev.uri, ev.diagnostics);
        }, null, this.disposables);
      }
      checkConfigurationErrors() {
        const errors = workspace_default.configurations.errors;
        if (!isFalsyOrEmpty(errors)) {
          const collection = this.create("config");
          for (let [uri, diagnostics] of errors.entries()) {
            let fsPath2 = URI.parse(uri).fsPath;
            void window_default.showErrorMessage(`Error detected for config file ${fsPath2}, please check diagnostics list.`);
            collection.set(uri, diagnostics);
          }
        }
      }
      defineSigns(config) {
        let { nvim } = this;
        nvim.pauseNotification();
        for (let kind of ["Error", "Warning", "Info", "Hint"]) {
          let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
          let signText = config[kind.toLowerCase() + "Sign"];
          if (signText)
            cmd += ` texthl=Coc${kind}Sign text=${signText}`;
          if (!isVim && config.enableHighlightLineNumber)
            cmd += ` numhl=Coc${kind}Sign`;
          nvim.command(cmd, true);
        }
        nvim.resumeNotification(false, true);
      }
      getItem(bufnr) {
        return this.buffers.getItem(bufnr);
      }
      async setLocationlist(bufnr) {
        let doc = workspace_default.getAttachedDocument(bufnr);
        let buf = this.buffers.getItem(doc.bufnr);
        let diagnostics = [];
        for (let diags of Object.values(this.getDiagnostics(buf))) {
          diagnostics.push(...diags);
        }
        let items = buf.toLocationListItems(diagnostics);
        await this.nvim.call("coc#ui#setloclist", [0, items, " ", "Diagnostics of coc"]);
      }
      create(name2) {
        let collection = this.getCollectionByName(name2);
        if (collection)
          return collection;
        collection = new DiagnosticCollection(name2, () => {
          let idx = this.collections.findIndex((o) => o == collection);
          if (idx !== -1)
            this.collections.splice(idx, 1);
        });
        this.collections.push(collection);
        collection.onDidDiagnosticsChange((uri) => {
          var _a2;
          let buf = (_a2 = this.buffers) == null ? void 0 : _a2.getItem(uri);
          if (buf && buf.config.autoRefresh)
            void buf.update(name2, this.getDiagnosticsByCollection(buf, collection));
        });
        return collection;
      }
      getSortedRanges(uri, minLevel, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level2 = severity ? severityLevel(severity) : 0;
        for (let collection of collections) {
          let diagnostics = collection.get(uri);
          if (level2) {
            diagnostics = diagnostics.filter((o) => o.severity == level2);
          } else {
            if (minLevel && minLevel < DiagnosticSeverity.Hint) {
              diagnostics = diagnostics.filter((o) => {
                return o.severity && o.severity > minLevel ? false : true;
              });
            }
          }
          let ranges = diagnostics.map((o) => o.range);
          res.push(...ranges);
        }
        res.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        return res;
      }
      getDiagnostics(buf) {
        let res = {};
        for (let collection of this.collections) {
          if (!collection.has(buf.uri))
            continue;
          res[collection.name] = this.getDiagnosticsByCollection(buf, collection);
        }
        return res;
      }
      getDiagnosticsByCollection(buf, collection) {
        let { level: level2, showUnused, showDeprecated } = buf.config;
        let items = collection.get(buf.uri) ?? [];
        if (items.length) {
          items = items.filter((d) => {
            var _a2, _b;
            if (level2 && d.severity && d.severity > level2) {
              return false;
            }
            if (!showUnused && ((_a2 = d.tags) == null ? void 0 : _a2.includes(DiagnosticTag.Unnecessary))) {
              return false;
            }
            if (!showDeprecated && ((_b = d.tags) == null ? void 0 : _b.includes(DiagnosticTag.Deprecated))) {
              return false;
            }
            return true;
          });
          items.sort((a, b) => {
            return comparePosition(a.range.start, b.range.start);
          });
        }
        return items;
      }
      getDiagnosticsInRange(document2, range) {
        let res = [];
        for (let collection of this.collections) {
          for (let item of collection.get(document2.uri) ?? []) {
            if (rangeIntersect(item.range, range)) {
              res.push(item);
            }
          }
        }
        return res;
      }
      async preview() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (diagnostics.length == 0) {
          this.nvim.command("pclose", true);
          return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          lines.push(`[${source}${code ? " " + code : ""}] [${s}]`);
          lines.push(...message.split(/\r?\n/));
          lines.push("");
        }
        this.nvim.call("coc#ui#preview_info", [lines, "txt"], true);
      }
      async prepareJump(severity) {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let item = this.buffers.getItem(bufnr);
        if (!item)
          return;
        let ranges = this.getSortedRanges(item.uri, item.config.level, severity);
        if (isFalsyOrEmpty(ranges))
          return;
        let curpos = await window_default.getCursorPosition();
        let wrapscan = await this.nvim.getOption("wrapscan");
        return {
          item,
          curpos,
          wrapscan: wrapscan != 0,
          ranges
        };
      }
      async jumpPrevious(severity) {
        let result = await this.prepareJump(severity);
        if (!result)
          return;
        let { curpos, item, wrapscan, ranges } = result;
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
          let end = ranges[i].end;
          if (comparePosition(end, curpos) < 0) {
            pos = ranges[i].start;
            break;
          }
        }
        if (!pos && wrapscan)
          pos = ranges[ranges.length - 1].start;
        if (pos) {
          await window_default.moveTo(pos);
          await item.echoMessage(false, pos);
        } else {
          void window_default.showWarningMessage(`No more diagnostic before cursor position`);
        }
      }
      async jumpNext(severity) {
        let result = await this.prepareJump(severity);
        if (!result)
          return;
        let { curpos, item, wrapscan, ranges } = result;
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
          let start = ranges[i].start;
          if (comparePosition(start, curpos) > 0) {
            let arr = await this.nvim.call("coc#util#valid_position", [start.line, start.character]);
            if ((arr[0] != start.line || arr[1] != start.character) && comparePosition(Position.create(arr[0], arr[1]), curpos) <= 0) {
              continue;
            }
            pos = Position.create(arr[0], arr[1]);
            break;
          }
        }
        if (!pos && wrapscan)
          pos = ranges[0].start;
        if (pos) {
          await window_default.moveTo(pos);
          await item.echoMessage(false, pos);
        } else {
          void window_default.showWarningMessage(`No more diagnostic after cursor position`);
        }
      }
      async getDiagnosticList() {
        let res = [];
        let config = workspace_default.getConfiguration("diagnostic");
        let level2 = severityLevel(config.get("level", "hint"));
        for (let collection of this.collections) {
          for (let [uri, diagnostics] of collection.entries()) {
            if (diagnostics.length == 0)
              continue;
            let u = URI.parse(uri);
            let doc = workspace_default.getDocument(uri);
            let lines = doc && doc.attached ? doc.textDocument.lines : void 0;
            if (!lines && u.scheme === "file") {
              try {
                const max = diagnostics.reduce((p, c) => {
                  return Math.max(c.range.end.line, p);
                }, 0);
                lines = await readFileLines(u.fsPath, 0, max);
              } catch (e) {
              }
            }
            for (let diagnostic of diagnostics) {
              if (diagnostic.severity && diagnostic.severity > level2)
                continue;
              let { start, end } = diagnostic.range;
              let o = {
                file: u.fsPath,
                lnum: start.line + 1,
                end_lnum: end.line + 1,
                col: Array.isArray(lines) ? byteIndex(lines[start.line] ?? "", start.character) + 1 : start.character + 1,
                end_col: Array.isArray(lines) ? byteIndex(lines[end.line] ?? "", end.character) + 1 : end.character + 1,
                code: diagnostic.code,
                source: diagnostic.source ?? collection.name,
                message: diagnostic.message,
                severity: getSeverityName(diagnostic.severity),
                level: diagnostic.severity ?? 0,
                location: Location.create(uri, diagnostic.range)
              };
              res.push(o);
            }
          }
        }
        res.sort((a, b) => {
          if (a.level !== b.level) {
            return a.level - b.level;
          }
          if (a.file !== b.file) {
            return a.file > b.file ? 1 : -1;
          } else {
            if (a.lnum != b.lnum) {
              return a.lnum - b.lnum;
            }
            return a.col - b.col;
          }
        });
        return res;
      }
      async getBufferAndPosition() {
        let [bufnr, lnum, col] = await this.nvim.eval(`[bufnr("%"),line('.'),col('.')]`);
        let item = this.buffers.getItem(bufnr);
        if (!item)
          return;
        let pos = item.doc.getPosition(lnum, col);
        return [item, pos];
      }
      async getCurrentDiagnostics() {
        let res = await this.getBufferAndPosition();
        if (!res)
          return;
        return res[0].getDiagnosticsAtPosition(res[1]);
      }
      async echoCurrentMessage() {
        let res = await this.getBufferAndPosition();
        if (!res)
          return;
        let [item, position] = res;
        await item.echoMessage(false, position);
      }
      async jumpRelated() {
        let diagnostics = await this.getCurrentDiagnostics();
        let diagnostic = diagnostics.find((o) => o.relatedInformation != null);
        let locations = diagnostic ? diagnostic.relatedInformation.map((o) => o.location) : [];
        if (locations.length == 1) {
          await workspace_default.jumpTo(locations[0].uri, locations[0].range.start);
        } else if (locations.length > 1) {
          await workspace_default.showLocations(locations);
        } else {
          void window_default.showWarningMessage("No related information found.");
        }
      }
      reset() {
        clearTimeout(this.messageTimer);
        this.buffers.reset();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
      }
      dispose() {
        clearTimeout(this.messageTimer);
        this.buffers.dispose();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
        disposeAll(this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      getCollectionByName(name2) {
        return this.collections.find((o) => o.name == name2);
      }
      getCollections(uri) {
        return this.collections.filter((c) => c.has(uri));
      }
      async toggleDiagnostic(enable) {
        this.enabled = enable == void 0 ? !this.enabled : enable != 0;
        await Promise.allSettled(this.buffers.items.map((buf) => {
          return buf.setState(this.enabled);
        }));
      }
      async toggleDiagnosticBuffer(bufnr, enable) {
        bufnr = bufnr ?? workspace_default.bufnr;
        let buf = this.buffers.getItem(bufnr);
        if (buf) {
          let isEnabled = enable == void 0 ? await buf.isEnabled() : enable == 0;
          await this.nvim.call("setbufvar", [bufnr, "coc_diagnostic_disable", isEnabled ? 1 : 0]);
          await buf.setState(!isEnabled);
        }
      }
      async refreshBuffer(uri) {
        let buf = this.buffers.getItem(uri);
        if (!buf)
          return false;
        await buf.reset(this.getDiagnostics(buf));
        return true;
      }
      async refresh(bufnr) {
        let items;
        if (!bufnr) {
          items = this.buffers.items;
        } else {
          let item = this.buffers.getItem(bufnr);
          items = item ? [item] : [];
        }
        for (let item of items) {
          await this.refreshBuffer(item.uri);
        }
      }
    };
    manager_default = new DiagnosticManager();
  }
});

// src/provider/manager.ts
function addLocation(arr, location) {
  if (Location.is(location)) {
    let { range, uri } = location;
    if (arr.find((o) => o.uri == uri && equals(o.range, range)) != null)
      return;
    arr.push(location);
  } else if (location && typeof location.targetUri === "string") {
    let { targetUri, targetSelectionRange, targetRange } = location;
    if (arr.find((o) => o.uri == targetUri && equals(o.range, targetSelectionRange)) != null)
      return;
    arr.push({
      uri: targetUri,
      range: targetSelectionRange,
      targetRange
    });
  }
}
var logger21, Manager;
var init_manager2 = __esm({
  "src/provider/manager.ts"() {
    "use strict";
    init_main();
    init_logger();
    init_object();
    init_protocol();
    init_workspace();
    logger21 = createLogger("provider-manager");
    Manager = class {
      constructor() {
        this.providers = /* @__PURE__ */ new Set();
      }
      hasProvider(document2) {
        return this.getProvider(document2) != null;
      }
      addProvider(item) {
        this.providers.add(item);
        return import_node3.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      handleResults(results, name2) {
        results.forEach((res) => {
          if (res.status === "rejected") {
            logger21.error(`Provider error on ${name2}:`, res.reason);
          }
        });
      }
      getProvider(document2) {
        let currScore = 0;
        let providerItem;
        for (let item of this.providers) {
          let { selector, priority } = item;
          let score3 = workspace_default.match(selector, document2);
          if (score3 == 0)
            continue;
          if (typeof priority == "number" && priority > 0) {
            score3 = score3 + priority;
          }
          if (score3 < currScore)
            continue;
          currScore = score3;
          providerItem = item;
        }
        return providerItem;
      }
      getProviderById(id) {
        let item = Array.from(this.providers).find((o) => o.id == id);
        return item ? item.provider : null;
      }
      getProviders(document2) {
        let items = Array.from(this.providers);
        items = items.filter((item) => workspace_default.match(item.selector, document2) > 0);
        return items.sort((a, b) => workspace_default.match(b.selector, document2) - workspace_default.match(a.selector, document2));
      }
      addLocation(locations, location) {
        if (Array.isArray(location)) {
          for (let loc of location) {
            if (Location.is(loc)) {
              addLocation(locations, loc);
            } else if (loc && typeof loc.targetUri === "string") {
              addLocation(locations, loc);
            }
          }
        } else if (Location.is(location)) {
          addLocation(locations, location);
        }
      }
    };
  }
});

// src/provider/callHierarchyManager.ts
var CallHierarchyManager;
var init_callHierarchyManager = __esm({
  "src/provider/callHierarchyManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    CallHierarchyManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async prepareCallHierarchy(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.prepareCallHierarchy(document2, position, token));
      }
      async provideCallHierarchyOutgoingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem)
          return null;
        let { provider } = providerItem;
        return await Promise.resolve(provider.provideCallHierarchyOutgoingCalls(item, token));
      }
      async provideCallHierarchyIncomingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem)
          return null;
        let { provider } = providerItem;
        return await Promise.resolve(provider.provideCallHierarchyIncomingCalls(item, token));
      }
    };
  }
});

// src/util/lodash.ts
function defaults2(obj, ...sources) {
  obj = Object(obj);
  sources.forEach((source) => {
    if (source != null) {
      source = Object(source);
      for (const key in source) {
        const value = obj[key];
        if (value === void 0 || value === objectProto[key] && !hasOwnProperty2.call(obj, key)) {
          obj[key] = source[key];
        }
      }
    }
  });
  return obj;
}
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}
var objectProto, hasOwnProperty2;
var init_lodash = __esm({
  "src/util/lodash.ts"() {
    "use strict";
    objectProto = Object.prototype;
    hasOwnProperty2 = objectProto.hasOwnProperty;
  }
});

// src/provider/codeActionManager.ts
function codeActionContains(kinds, kind) {
  return kinds.some((k) => kind === k || kind.startsWith(k + "."));
}
function checkAction(only, action) {
  if (isFalsyOrEmpty(only))
    return true;
  if (Command.is(action))
    return false;
  return codeActionContains(only, action.kind);
}
var CodeActionManager;
var init_codeActionManager = __esm({
  "src/provider/codeActionManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_array();
    init_is();
    init_lodash();
    init_manager2();
    CodeActionManager = class extends Manager {
      register(selector, provider, clientId, codeActionKinds) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          kinds: codeActionKinds,
          clientId
        });
      }
      async provideCodeActions(document2, range, context, token) {
        let providers = this.getProviders(document2);
        const only = isFalsyOrEmpty(context.only) ? void 0 : context.only;
        if (only) {
          providers = providers.filter((p) => {
            if (Array.isArray(p.kinds) && !p.kinds.some((kind) => codeActionContains(only, kind))) {
              return false;
            }
            return true;
          });
        }
        let res = [];
        const titles = [];
        let results = await Promise.allSettled(providers.map((item) => {
          let { provider, id } = item;
          let fn = async () => {
            let actions = await Promise.resolve(provider.provideCodeActions(document2, range, context, token));
            if (isFalsyOrEmpty(actions))
              return;
            for (let action of actions) {
              if (titles.includes(action.title) || !checkAction(only, action))
                continue;
              if (Command.is(action)) {
                let codeAction = {
                  title: action.title,
                  command: action,
                  providerId: id
                };
                res.push(codeAction);
              } else {
                res.push(Object.assign({ providerId: id }, action));
              }
              titles.push(action.title);
            }
          };
          return fn();
        }));
        this.handleResults(results, "provideCodeActions");
        return res;
      }
      async resolveCodeAction(codeAction, token) {
        if (codeAction.edit != null || codeAction.providerId == null)
          return codeAction;
        let provider = this.getProviderById(codeAction.providerId);
        if (!provider || !func(provider.resolveCodeAction))
          return codeAction;
        let resolved = await Promise.resolve(provider.resolveCodeAction(omit(codeAction, ["providerId"]), token));
        return resolved ?? codeAction;
      }
    };
  }
});

// src/provider/codeLensManager.ts
var CodeLensManager;
var init_codeLensManager = __esm({
  "src/provider/codeLensManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager2();
    init_is();
    CodeLensManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideCodeLenses(document2, token) {
        let providers = this.getProviders(document2);
        let codeLens = [];
        let results = await Promise.allSettled(providers.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.provideCodeLenses(document2, token)).then((res) => {
            if (Array.isArray(res)) {
              for (let item2 of res) {
                codeLens.push(Object.assign({ source: id }, item2));
              }
            }
          });
        }));
        this.handleResults(results, "provideCodeLenses");
        return codeLens;
      }
      async resolveCodeLens(codeLens, token) {
        if (isCommand(codeLens.command))
          return codeLens;
        let provider = this.getProviderById(codeLens.source);
        if (!provider || typeof provider.resolveCodeLens != "function") {
          return codeLens;
        }
        let res = await Promise.resolve(provider.resolveCodeLens(omit(codeLens, ["source"]), token));
        Object.assign(codeLens, res);
        return codeLens;
      }
    };
  }
});

// src/provider/declarationManager.ts
var DeclarationManager;
var init_declarationManager = __esm({
  "src/provider/declarationManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    DeclarationManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDeclaration(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDeclaration(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideDeclaration");
        return locations;
      }
    };
  }
});

// src/provider/definitionManager.ts
var DefinitionManager;
var init_definitionManager = __esm({
  "src/provider/definitionManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_manager2();
    DefinitionManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDefinition(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDefinition(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideDefinition");
        return locations;
      }
      async provideDefinitionLinks(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDefinition(document2, position, token)).then((location) => {
            if (Array.isArray(location)) {
              location.forEach((loc) => {
                if (LocationLink.is(loc)) {
                  locations.push(loc);
                }
              });
            }
          });
        }));
        this.handleResults(results, "provideDefinition");
        return locations;
      }
    };
  }
});

// src/provider/documentColorManager.ts
var DocumentColorManager;
var init_documentColorManager = __esm({
  "src/provider/documentColorManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_manager2();
    DocumentColorManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentColors(document2, token) {
        let items = this.getProviders(document2);
        let colors = [];
        const results = await Promise.allSettled(items.map((item) => {
          let { id } = item;
          return Promise.resolve(item.provider.provideDocumentColors(document2, token)).then((arr) => {
            let noCheck = colors.length == 0;
            if (Array.isArray(arr)) {
              for (let color of arr) {
                if (noCheck || !colors.some((o) => equals(o.range, color.range))) {
                  colors.push(Object.assign({ source: id }, color));
                }
              }
            }
          });
        }));
        this.handleResults(results, "provideDocumentColors");
        return colors;
      }
      async provideColorPresentations(colorInformation, document2, token) {
        let providers = this.getProviders(document2);
        let { range, color } = colorInformation;
        for (let item of providers) {
          let res = await Promise.resolve(item.provider.provideColorPresentations(color, { document: document2, range }, token));
          if (res)
            return res;
        }
        return null;
      }
    };
  }
});

// src/provider/documentHighlightManager.ts
var DocumentHighlightManager;
var init_documentHighlightManager = __esm({
  "src/provider/documentHighlightManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    DocumentHighlightManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentHighlights(document2, position, token) {
        let items = this.getProviders(document2);
        let res = null;
        for (const item of items) {
          try {
            res = await Promise.resolve(item.provider.provideDocumentHighlights(document2, position, token));
            if (res != null)
              break;
          } catch (e) {
            this.handleResults([{ status: "rejected", reason: e }], "provideDocumentHighlights");
          }
        }
        return res;
      }
    };
  }
});

// src/provider/documentLinkManager.ts
function rangeToString(range) {
  return `${range.start.line},${range.start.character},${range.end.line},${range.end.character}`;
}
var DocumentLinkManager;
var init_documentLinkManager = __esm({
  "src/provider/documentLinkManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager2();
    DocumentLinkManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentLinks(document2, token) {
        let items = this.getProviders(document2);
        if (items.length == 0)
          return null;
        const links2 = [];
        const seenRanges = /* @__PURE__ */ new Set();
        const results = await Promise.allSettled(items.map(async (item) => {
          let { id, provider } = item;
          const arr = await provider.provideDocumentLinks(document2, token);
          if (Array.isArray(arr)) {
            let check = links2.length > 0;
            arr.forEach((link) => {
              if (check) {
                const rangeString = rangeToString(link.range);
                if (!seenRanges.has(rangeString)) {
                  seenRanges.add(rangeString);
                  links2.push(Object.assign({ source: id }, link));
                }
              } else {
                if (items.length > 1)
                  seenRanges.add(rangeToString(link.range));
                links2.push(Object.assign({ source: id }, link));
              }
            });
          }
        }));
        this.handleResults(results, "provideDocumentLinks");
        return links2;
      }
      async resolveDocumentLink(link, token) {
        let provider = this.getProviderById(link.source);
        if (typeof provider.resolveDocumentLink === "function") {
          let resolved = await Promise.resolve(provider.resolveDocumentLink(omit(link, ["source"]), token));
          if (resolved)
            Object.assign(link, resolved);
        }
        return link;
      }
    };
  }
});

// src/provider/documentSymbolManager.ts
function asDocumentSymbolTree(infos) {
  infos = infos.slice().sort((a, b) => {
    return compareRangesUsingStarts(a.location.range, b.location.range);
  });
  const res = [];
  const parentStack = [];
  for (const info of infos) {
    const element = {
      name: toText(info.name),
      kind: info.kind,
      tags: toArray(info.tags),
      detail: "",
      range: info.location.range,
      selectionRange: info.location.range
    };
    if (info.deprecated) {
      element.tags.push(SymbolTag.Deprecated);
    }
    while (true) {
      if (parentStack.length === 0) {
        parentStack.push(element);
        res.push(element);
        break;
      }
      const parent = parentStack[parentStack.length - 1];
      if (rangeInRange(element.range, parent.range) && !equalsRange(parent.range, element.range)) {
        parent.children = toArray(parent.children);
        parent.children.push(element);
        parentStack.push(element);
        break;
      }
      parentStack.pop();
    }
  }
  return res;
}
var DocumentSymbolManager;
var init_documentSymbolManager = __esm({
  "src/provider/documentSymbolManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_array();
    init_position();
    init_string();
    init_manager2();
    DocumentSymbolManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      getMetaData(document2) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        return item.provider.meta ?? {};
      }
      async provideDocumentSymbols(document2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let symbols = [];
        let results = await Promise.allSettled([item].map((item2) => {
          return Promise.resolve(item2.provider.provideDocumentSymbols(document2, token)).then((result) => {
            if (!token.isCancellationRequested && !isFalsyOrEmpty(result)) {
              if (DocumentSymbol.is(result[0])) {
                symbols = result;
              } else {
                symbols = asDocumentSymbolTree(result);
              }
            }
          });
        }));
        this.handleResults(results, "provideDocumentSymbols");
        return symbols;
      }
    };
  }
});

// src/provider/foldingRangeManager.ts
function getParent(line, sortedRanges) {
  for (let r of sortedRanges) {
    if (line >= r.startLine) {
      if (line <= r.endLine) {
        return r;
      } else {
        continue;
      }
    } else {
      break;
    }
  }
  return void 0;
}
var FoldingRangeManager;
var init_foldingRangeManager = __esm({
  "src/provider/foldingRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    FoldingRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideFoldingRanges(document2, context, token) {
        let items = this.getProviders(document2);
        let ranges = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideFoldingRanges(document2, context, token)).then((res) => {
            if (Array.isArray(res) && res.length > 0) {
              if (ranges.length == 0) {
                ranges.push(...res);
              } else {
                for (let r of res) {
                  let sp = getParent(r.startLine, ranges);
                  if ((sp == null ? void 0 : sp.startLine) === r.startLine)
                    continue;
                  let ep = getParent(r.endLine, ranges);
                  if (sp === ep) {
                    ranges.push(r);
                  }
                }
              }
              ranges.sort((a, b) => a.startLine - b.startLine);
            }
          });
        }));
        this.handleResults(results, "provideFoldingRanges");
        return ranges;
      }
    };
  }
});

// src/provider/formatManager.ts
var FormatManager;
var init_formatManager = __esm({
  "src/provider/formatManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    FormatManager = class extends Manager {
      register(selector, provider, priority) {
        return this.addProvider({
          id: v4_default(),
          selector,
          priority,
          provider
        });
      }
      async provideDocumentFormattingEdits(document2, options2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentFormattingEdits(document2, options2, token));
      }
    };
  }
});

// src/provider/formatRangeManager.ts
var FormatRangeManager;
var init_formatRangeManager = __esm({
  "src/provider/formatRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    FormatRangeManager = class extends Manager {
      register(selector, provider, priority) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          priority
        });
      }
      async provideDocumentRangeFormattingEdits(document2, range, options2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document2, range, options2, token));
      }
    };
  }
});

// src/provider/hoverManager.ts
var HoverManager;
var init_hoverManager = __esm({
  "src/provider/hoverManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_object();
    init_manager2();
    HoverManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideHover(document2, position, token) {
        let items = this.getProviders(document2);
        let hovers = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideHover(document2, position, token)).then((hover) => {
            if (!Hover.is(hover))
              return;
            if (hovers.findIndex((o) => equals(o.contents, hover.contents)) == -1) {
              hovers.push(hover);
            }
          });
        }));
        this.handleResults(results, "provideHover");
        return hovers;
      }
    };
  }
});

// src/provider/implementationManager.ts
var ImplementationManager;
var init_implementationManager = __esm({
  "src/provider/implementationManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    ImplementationManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideImplementations(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideImplementation(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideImplementations");
        return locations;
      }
    };
  }
});

// src/provider/inlayHintManager.ts
function sameHint(one, other) {
  if (comparePosition(one.position, other.position) !== 0)
    return false;
  return getLabel(one) === getLabel(other);
}
function isInlayHint(obj) {
  if (!obj || !Position.is(obj.position) || obj.label == null)
    return false;
  if (typeof obj.label !== "string")
    return Array.isArray(obj.label) && obj.label.every((p) => typeof p.value === "string");
  return true;
}
function isValidInlayHint(hint, range) {
  if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every((part) => part.value.length === 0)) {
    logger22.warn("INVALID inlay hint, empty label", hint);
    return false;
  }
  if (!isInlayHint(hint)) {
    logger22.warn("INVALID inlay hint", hint);
    return false;
  }
  if (range && positionInRange(hint.position, range) !== 0) {
    return false;
  }
  return true;
}
function getLabel(hint) {
  if (typeof hint.label === "string")
    return hint.label;
  return hint.label.map((o) => o.value).join("");
}
var logger22, InlayHintManger;
var init_inlayHintManager = __esm({
  "src/provider/inlayHintManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_logger();
    init_position();
    init_manager2();
    logger22 = createLogger("inlayHintManger");
    InlayHintManger = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideInlayHints(document2, range, token) {
        let items = this.getProviders(document2);
        let inlayHints = [];
        await Promise.all(items.map((item) => {
          let { id, provider } = item;
          return Promise.resolve(provider.provideInlayHints(document2, range, token)).then((hints) => {
            if (!Array.isArray(hints) || token.isCancellationRequested)
              return;
            let noCheck = inlayHints.length == 0;
            for (let hint of hints) {
              if (!isValidInlayHint(hint, range))
                continue;
              if (!noCheck && inlayHints.findIndex((o) => sameHint(o, hint)) != -1)
                continue;
              inlayHints.push({ providerId: id, ...hint });
            }
          });
        }));
        return inlayHints;
      }
      async resolveInlayHint(hint, token) {
        let provider = this.getProviderById(hint.providerId);
        if (!provider || typeof provider.resolveInlayHint !== "function" || hint.resolved === true)
          return hint;
        let res = await Promise.resolve(provider.resolveInlayHint(hint, token));
        if (token.isCancellationRequested)
          return hint;
        return Object.assign(hint, res, { resolved: true });
      }
    };
  }
});

// src/provider/inlineValueManager.ts
var InlineValueManager;
var init_inlineValueManager = __esm({
  "src/provider/inlineValueManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_manager2();
    InlineValueManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideInlineValues(document2, viewPort, context, token) {
        const items = this.getProviders(document2);
        const values = [];
        const results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideInlineValues(document2, viewPort, context, token)).then((arr) => {
            if (!Array.isArray(arr))
              return;
            let noCheck = values.length === 0;
            for (let value of arr) {
              if (noCheck || values.every((o) => !equals(o, value))) {
                values.push(value);
              }
            }
          });
        }));
        this.handleResults(results, "provideInlineValues");
        return values;
      }
    };
  }
});

// src/provider/linkedEditingRangeManager.ts
var logger23, LinkedEditingRangeManager;
var init_linkedEditingRangeManager = __esm({
  "src/provider/linkedEditingRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_logger();
    init_manager2();
    logger23 = createLogger("linkedEditingManager");
    LinkedEditingRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideLinkedEditingRanges(document2, position, token) {
        let items = this.getProviders(document2);
        for (let item of items) {
          let res = await Promise.resolve(item.provider.provideLinkedEditingRanges(document2, position, token));
          if (res != null)
            return res;
        }
        return null;
      }
    };
  }
});

// src/provider/onTypeFormatManager.ts
var OnTypeFormatManager;
var init_onTypeFormatManager = __esm({
  "src/provider/onTypeFormatManager.ts"() {
    "use strict";
    init_esm_node();
    init_workspace();
    init_manager2();
    OnTypeFormatManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: triggerCharacters ?? []
        });
      }
      couldTrigger(document2, triggerCharacter) {
        for (let o of this.providers) {
          let { triggerCharacters, selector } = o;
          if (workspace_default.match(selector, document2) > 0 && triggerCharacters.includes(triggerCharacter)) {
            return o.provider;
          }
        }
        return null;
      }
      async onCharacterType(character, document2, position, token) {
        let items = this.getProviders(document2);
        let item = items.find((o) => o.triggerCharacters.includes(character));
        if (!item)
          return null;
        let formatOpts = await workspace_default.getFormatOptions(document2.uri);
        return await Promise.resolve(item.provider.provideOnTypeFormattingEdits(document2, position, character, formatOpts, token));
      }
    };
  }
});

// src/provider/referenceManager.ts
var ReferenceManager;
var init_referenceManager = __esm({
  "src/provider/referenceManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    ReferenceManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideReferences(document2, position, context, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideReferences(document2, position, context, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideReferences");
        return locations;
      }
    };
  }
});

// src/provider/renameManager.ts
var RenameManager;
var init_renameManager = __esm({
  "src/provider/renameManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    RenameManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideRenameEdits(document2, position, newName, token) {
        let items = this.getProviders(document2);
        let edit2 = null;
        for (const item of items) {
          try {
            edit2 = await Promise.resolve(item.provider.provideRenameEdits(document2, position, newName, token));
          } catch (e) {
            this.handleResults([{ status: "rejected", reason: e }], "provideRenameEdits");
          }
          if (edit2 != null)
            break;
        }
        return edit2;
      }
      async prepareRename(document2, position, token) {
        let items = this.getProviders(document2);
        items = items.filter((o) => typeof o.provider.prepareRename === "function");
        if (items.length === 0)
          return null;
        for (const item of items) {
          let res = await Promise.resolve(item.provider.prepareRename(document2, position, token));
          if (res != null)
            return res;
        }
        return false;
      }
    };
  }
});

// src/provider/selectionRangeManager.ts
var SelectionRangeManager;
var init_selectionRangeManager = __esm({
  "src/provider/selectionRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_position();
    init_manager2();
    SelectionRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideSelectionRanges(document2, positions, token) {
        let items = this.getProviders(document2);
        if (items.length === 0)
          return null;
        let selectionRangeResult = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideSelectionRanges(document2, positions, token)).then((ranges) => {
            if (Array.isArray(ranges) && ranges.length > 0) {
              selectionRangeResult.push(ranges);
            }
          });
        }));
        this.handleResults(results, "provideSelectionRanges");
        if (selectionRangeResult.length === 0)
          return null;
        let selectionRanges = selectionRangeResult[0];
        if (selectionRangeResult.length > 1) {
          for (let i = 1; i <= selectionRangeResult.length - 1; i++) {
            let start = selectionRanges[0].range;
            let end = selectionRanges[selectionRanges.length - 1].range;
            let ranges = selectionRangeResult[i];
            let len = ranges.length;
            if (rangeInRange(end, ranges[0].range) && !equals(end, ranges[0].range)) {
              selectionRanges.push(...ranges);
            } else if (rangeInRange(ranges[len - 1].range, start) && !equals(ranges[len - 1].range, start)) {
              selectionRanges.unshift(...ranges);
            }
          }
        }
        for (let i = 0; i < selectionRanges.length - 1; i++) {
          let r = selectionRanges[i];
          r.parent = selectionRanges[i + 1];
        }
        return selectionRanges;
      }
    };
  }
});

// src/provider/semanticTokensManager.ts
var SemanticTokensManager;
var init_semanticTokensManager = __esm({
  "src/provider/semanticTokensManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    SemanticTokensManager = class extends Manager {
      register(selector, provider, legend) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          legend
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item)
          return;
        return item.legend;
      }
      hasSemanticTokensEdits(document2) {
        var _a2;
        let provider = (_a2 = this.getProvider(document2)) == null ? void 0 : _a2.provider;
        if (!provider)
          return false;
        return typeof provider.provideDocumentSemanticTokensEdits === "function";
      }
      async provideDocumentSemanticTokens(document2, token) {
        var _a2;
        let provider = (_a2 = this.getProvider(document2)) == null ? void 0 : _a2.provider;
        if (!provider || typeof provider.provideDocumentSemanticTokens !== "function")
          return null;
        return await Promise.resolve(provider.provideDocumentSemanticTokens(document2, token));
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        let item = this.getProvider(document2);
        if (!item || typeof item.provider.provideDocumentSemanticTokensEdits !== "function")
          return null;
        return await Promise.resolve(item.provider.provideDocumentSemanticTokensEdits(document2, previousResultId, token));
      }
    };
  }
});

// src/provider/semanticTokensRangeManager.ts
var SemanticTokensRangeManager;
var init_semanticTokensRangeManager = __esm({
  "src/provider/semanticTokensRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    SemanticTokensRangeManager = class extends Manager {
      register(selector, provider, legend) {
        return this.addProvider({
          id: v4_default(),
          selector,
          legend,
          provider
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item)
          return;
        return item.legend;
      }
      async provideDocumentRangeSemanticTokens(document2, range, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeSemanticTokens(document2, range, token));
      }
    };
  }
});

// src/provider/signatureManager.ts
var SignatureManager;
var init_signatureManager = __esm({
  "src/provider/signatureManager.ts"() {
    "use strict";
    init_esm_node();
    init_array();
    init_manager2();
    SignatureManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        triggerCharacters = isFalsyOrEmpty(triggerCharacters) ? [] : triggerCharacters;
        let characters = triggerCharacters.reduce((p, c) => p.concat(c.length == 1 ? [c] : c.split(/\s*/g)), []);
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: characters
        });
      }
      shouldTrigger(document2, triggerCharacter) {
        let items = this.getProviders(document2);
        if (items.length === 0)
          return false;
        for (let item of items) {
          if (item.triggerCharacters.includes(triggerCharacter)) {
            return true;
          }
        }
        return false;
      }
      async provideSignatureHelp(document2, position, token, context) {
        let items = this.getProviders(document2);
        for (const item of items) {
          let res = await Promise.resolve(item.provider.provideSignatureHelp(document2, position, token, context));
          if (res && res.signatures && res.signatures.length > 0)
            return res;
        }
        return null;
      }
    };
  }
});

// src/provider/typeDefinitionManager.ts
var TypeDefinitionManager;
var init_typeDefinitionManager = __esm({
  "src/provider/typeDefinitionManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    TypeDefinitionManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideTypeDefinition(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideTypeDefinition(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideTypeDefinition");
        return locations;
      }
    };
  }
});

// src/provider/typeHierarchyManager.ts
var excludeKeys, TypeHierarchyManager;
var init_typeHierarchyManager = __esm({
  "src/provider/typeHierarchyManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager2();
    excludeKeys = ["source"];
    TypeHierarchyManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async prepareTypeHierarchy(document2, position, token) {
        const items = this.getProviders(document2);
        let hierarchyItems = [];
        let results = await Promise.allSettled(items.map((item) => {
          let { provider, id } = item;
          return (async () => {
            let arr = await Promise.resolve(provider.prepareTypeHierarchy(document2, position, token));
            if (Array.isArray(arr)) {
              let noCheck = hierarchyItems.length === 0;
              arr.forEach((item2) => {
                if (noCheck || hierarchyItems.every((o) => o.name !== item2.name)) {
                  hierarchyItems.push(Object.assign({ source: id }, item2));
                }
              });
            }
          })();
        }));
        this.handleResults(results, "prepareTypeHierarchy");
        return hierarchyItems;
      }
      async provideTypeHierarchySupertypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider)
          return [];
        return await Promise.resolve(provider.provideTypeHierarchySupertypes(omit(item, excludeKeys), token)).then((arr) => {
          if (Array.isArray(arr)) {
            return arr.map((item2) => {
              return Object.assign({ source }, item2);
            });
          }
          return [];
        });
      }
      async provideTypeHierarchySubtypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider)
          return [];
        return await Promise.resolve(provider.provideTypeHierarchySubtypes(omit(item, excludeKeys), token)).then((arr) => {
          if (Array.isArray(arr)) {
            return arr.map((item2) => {
              return Object.assign({ source }, item2);
            });
          }
          return [];
        });
      }
    };
  }
});

// src/provider/workspaceSymbolsManager.ts
var WorkspaceSymbolManager;
var init_workspaceSymbolsManager = __esm({
  "src/provider/workspaceSymbolsManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    WorkspaceSymbolManager = class extends Manager {
      register(provider) {
        return this.addProvider({
          id: v4_default(),
          selector: [{ language: "*" }],
          provider
        });
      }
      async provideWorkspaceSymbols(query, token) {
        let entries = Array.from(this.providers);
        let infos = [];
        let results = await Promise.allSettled(entries.map((o) => {
          let { id, provider } = o;
          return Promise.resolve(provider.provideWorkspaceSymbols(query, token)).then((list2) => {
            if (list2)
              infos.push(...list2.map((item) => Object.assign({ source: id }, item)));
          });
        }));
        this.handleResults(results, "provideWorkspaceSymbols");
        return infos;
      }
      async resolveWorkspaceSymbol(symbolInfo, token) {
        let provider = this.getProviderById(symbolInfo.source);
        if (!provider || typeof provider.resolveWorkspaceSymbol !== "function")
          return symbolInfo;
        return provider.resolveWorkspaceSymbol(symbolInfo, token);
      }
      hasProvider() {
        return this.providers.size > 0;
      }
    };
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty2 = true;
      const checker = new Transform2({
        transform(data, _encoding, callback) {
          isEmpty2 = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty2 && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format3];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level2) {
      if (level2 === 0) {
        return false;
      }
      return {
        level: level2,
        hasBasic: true,
        has256: level2 >= 2,
        has16m: level2 >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level2 = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level2);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL4 = url.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert2 = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self = this;
      this._onNativeResponse = function(response) {
        self._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding2, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding2)) {
        callback = encoding2;
        encoding2 = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding: encoding2 });
        this._currentRequest.write(data, encoding2, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding2, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding2 = null;
      } else if (isFunction(encoding2)) {
        callback = encoding2;
        encoding2 = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding2, function() {
          self._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value) {
      this._options.headers[name2] = value;
      this._currentRequest.setHeader(name2, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self._timeout) {
          clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
          self.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self._timeout) {
          clearTimeout(self._timeout);
          self._timeout = null;
        }
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        if (callback) {
          self.removeListener("timeout", callback);
        }
        if (!self.socket) {
          self._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol2 = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol2];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol2));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol2.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request2._redirectable = this;
      for (var event of events) {
        request2.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._options.path;
      if (this._isRedirect) {
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self._currentRequest) {
            if (error) {
              self.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol2 = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request2(input, options2, callback) {
          if (isString(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL4(input));
            } catch (err) {
              parsed = url.parse(input);
            }
            if (!isString(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL4 && input instanceof URL4) {
            input = urlToOptions(input);
          } else {
            callback = options2;
            options2 = input;
            input = { protocol: protocol2 };
          }
          if (isFunction(options2)) {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          if (!isString(options2.host) && !isString(options2.hostname)) {
            options2.hostname = "::1";
          }
          assert2.equal(options2.protocol, protocol2, "protocol mismatch");
          debug("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port);
      }
      return options2;
    }
    function removeMatchingHeaders(regex2, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex2.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request2) {
      for (var event of events) {
        request2.removeListener(event, eventHandlers[event]);
      }
      request2.on("error", noop);
      request2.abort();
    }
    function isSubdomain(subdomain, domain2) {
      assert2(isString(subdomain) && isString(domain2));
      var dot = subdomain.length - domain2.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain2);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/@tootallnate/once/dist/index.js
var require_dist = __commonJS({
  "node_modules/@tootallnate/once/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function once(emitter, name2, { signal } = {}) {
      return new Promise((resolve, reject) => {
        function cleanup() {
          signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", cleanup);
          emitter.removeListener(name2, onEvent);
          emitter.removeListener("error", onError);
        }
        function onEvent(...args) {
          cleanup();
          resolve(args);
        }
        function onError(err) {
          cleanup();
          reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", cleanup);
        emitter.on(name2, onEvent);
        emitter.on("error", onError);
      });
    }
    exports2.default = once;
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify2(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify2;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/http-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/http-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var once_1 = __importDefault(require_dist());
    var agent_base_1 = require_src2();
    var debug = (0, debug_1.default)("http-proxy-agent");
    function isHTTPS(protocol2) {
      return typeof protocol2 === "string" ? /^https:?$/i.test(protocol2) : false;
    }
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            parsed.port = "";
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield (0, once_1.default)(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent2;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent3) {
      createHttpProxyAgent3.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent2 || (createHttpProxyAgent2 = {}));
    module2.exports = createHttpProxyAgent2;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name2 of Object.keys(headers)) {
            payload += `${name2}: ${headers[name2]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol2) {
      return typeof protocol2 === "string" ? /^https:?$/i.test(protocol2) : false;
    }
    function omit2(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpsProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent3) {
      createHttpsProxyAgent3.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent2 || (createHttpsProxyAgent2 = {}));
    module2.exports = createHttpsProxyAgent2;
  }
});

// src/model/fetch.ts
function getRequestModule(url) {
  return url.protocol === "https:" ? import_follow_redirects.https : import_follow_redirects.http;
}
function getText2(data) {
  if (typeof data === "string" || Buffer.isBuffer(data))
    return data;
  return JSON.stringify(data);
}
function toURL(urlInput) {
  if (urlInput instanceof import_url2.URL)
    return urlInput;
  let url = new import_url2.URL(urlInput);
  if (!["https:", "http:"].includes(url.protocol))
    throw new Error(`Not valid protocol with ${urlInput}, should be http: or https:`);
  return url;
}
function toPort(port, protocol2) {
  if (port) {
    port = typeof port === "number" ? port : parseInt(port, 10);
    if (!isNaN(port))
      return port;
  }
  return protocol2.startsWith("https") ? 443 : 80;
}
function getDataType(data) {
  if (data === null)
    return "null";
  if (data === void 0)
    return "undefined";
  if (typeof data == "string")
    return "string";
  if (Buffer.isBuffer(data))
    return "buffer";
  if (Array.isArray(data) || objectLiteral(data))
    return "object";
  return "unknown";
}
function getSystemProxyURI(endpoint, env = process.env) {
  let noProxy = env.NO_PROXY ?? env.no_proxy;
  if (noProxy === "*") {
    return null;
  }
  if (noProxy) {
    const hostname = endpoint.hostname.replace(/^\.*/, ".").toLowerCase();
    const port = toPort(endpoint.port, endpoint.protocol).toString();
    const noProxyList = noProxy.split(",");
    for (let i = 0, len = noProxyList.length; i < len; i++) {
      let noProxyItem = noProxyList[i].trim().toLowerCase();
      if (noProxyItem.includes(":")) {
        let noProxyItemParts = noProxyItem.split(":", 2);
        let noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".");
        let noProxyPort = noProxyItemParts[1];
        if (port == noProxyPort && hostname.endsWith(noProxyHost)) {
          return null;
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, ".");
        if (hostname.endsWith(noProxyItem)) {
          return null;
        }
      }
    }
  }
  let proxyUri;
  if (endpoint.protocol === "http:") {
    proxyUri = env.HTTP_PROXY || env.http_proxy || null;
  } else {
    proxyUri = env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy || null;
  }
  return proxyUri;
}
function getAgent(endpoint, options2) {
  let proxy = options2.proxy || getSystemProxyURI(endpoint);
  if (proxy) {
    let proxyURL;
    try {
      proxyURL = new import_url2.URL(proxy);
      if (!/^https?:$/.test(proxyURL.protocol))
        return null;
    } catch (e) {
      return null;
    }
    let opts = {
      host: proxyURL.hostname,
      port: toPort(proxyURL.port, proxyURL.protocol),
      auth: proxyURL.username ? `${proxyURL.username}:${toText(proxyURL.password)}` : void 0,
      rejectUnauthorized: typeof options2.proxyStrictSSL === "boolean" ? options2.proxyStrictSSL : true
    };
    logger24.info(`Using proxy ${proxy} from ${options2.proxy ? "configuration" : "system environment"} for ${endpoint.hostname}:`);
    return endpoint.protocol === "http:" ? (0, import_http_proxy_agent.default)(opts) : (0, import_https_proxy_agent.default)(opts);
  }
  return null;
}
function resolveRequestOptions(url, options2) {
  let config = workspace_default.getConfiguration("http", null);
  let dataType = getDataType(options2.data);
  let proxyOptions = {
    proxy: config.get("proxy", ""),
    proxyStrictSSL: config.get("proxyStrictSSL", true),
    proxyAuthorization: config.get("proxyAuthorization", null),
    proxyCA: config.get("proxyCA", null)
  };
  if (options2.query && !url.search) {
    url.search = `?${(0, import_querystring.stringify)(options2.query)}`;
  }
  let agent = getAgent(url, proxyOptions);
  let opts = {
    method: options2.method ?? "GET",
    hostname: url.hostname,
    port: toPort(url.port, url.protocol),
    path: url.pathname + url.search,
    agent,
    rejectUnauthorized: proxyOptions.proxyStrictSSL,
    maxRedirects: 3,
    headers: {
      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
      "Accept-Encoding": "gzip, deflate",
      ...options2.headers ?? {}
    }
  };
  if (dataType == "object") {
    opts.headers["Content-Type"] = "application/json";
  } else if (dataType == "string") {
    opts.headers["Content-Type"] = "text/plain";
  }
  if (proxyOptions.proxyAuthorization)
    opts.headers["Proxy-Authorization"] = proxyOptions.proxyAuthorization;
  if (proxyOptions.proxyCA)
    opts.ca = fs.readFileSync(proxyOptions.proxyCA);
  if (options2.user)
    opts.auth = options2.user + ":" + toText(options2.password);
  if (url.username)
    opts.auth = url.username + ":" + toText(url.password);
  if (options2.timeout)
    opts.timeout = options2.timeout;
  if (options2.buffer)
    opts.buffer = true;
  return opts;
}
function request(url, data, opts, token) {
  let mod = getRequestModule(url);
  return new Promise((resolve, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new CancellationError());
      });
    }
    let timer;
    const req = mod.request(opts, (res) => {
      let readable = res;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers;
        let chunks = [];
        let contentType = toText(headers["content-type"]);
        readable = (0, import_decompress_response.default)(res);
        readable.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readable.on("end", () => {
          clearTimeout(timer);
          let buf = Buffer.concat(chunks);
          if (!opts.buffer && (contentType.startsWith("application/json") || contentType.startsWith("text/"))) {
            let ms = contentType.match(/charset=(\S+)/);
            let encoding2 = ms ? ms[1] : "utf8";
            let rawData = buf.toString(encoding2);
            if (!contentType.includes("application/json")) {
              resolve(rawData);
            } else {
              try {
                const parsedData = JSON.parse(rawData);
                resolve(parsedData);
              } catch (e) {
                reject(new Error(`Parse response error: ${e}`));
              }
            }
          } else {
            resolve(buf);
          }
        });
        readable.on("error", (err) => {
          reject(new Error(`Connection error to ${url}: ${err.message}`));
        });
      } else {
        reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", (e) => {
      if (opts.agent && e["code"] == "ECONNRESET") {
        timer = setTimeout(() => {
          reject(e);
        }, timeout);
      } else {
        reject(e);
      }
    });
    req.on("timeout", () => {
      req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
    });
    if (data)
      req.write(getText2(data));
    if (opts.timeout)
      req.setTimeout(opts.timeout);
    req.end();
  });
}
function fetch(urlInput, options2 = {}, token) {
  let url = toURL(urlInput);
  let opts = resolveRequestOptions(url, options2);
  return request(url, options2.data, opts, token).catch((err) => {
    logger24.error(`Fetch error for ${url}:`, opts, err);
    if (opts.agent && opts.agent.proxy) {
      let { proxy } = opts.agent;
      throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
    } else {
      throw err;
    }
  });
}
var import_decompress_response, import_follow_redirects, import_http_proxy_agent, import_https_proxy_agent, import_querystring, import_url2, logger24, timeout;
var init_fetch = __esm({
  "src/model/fetch.ts"() {
    "use strict";
    import_decompress_response = __toESM(require_decompress_response());
    import_follow_redirects = __toESM(require_follow_redirects());
    import_http_proxy_agent = __toESM(require_dist2());
    import_https_proxy_agent = __toESM(require_dist3());
    import_querystring = require("querystring");
    import_url2 = require("url");
    init_logger();
    init_errors();
    init_is();
    init_node();
    init_workspace();
    init_string();
    init_util();
    logger24 = createLogger("model-fetch");
    timeout = getConditionValue(500, 50);
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse3;
    var basename = require("path").basename;
    var Buffer3 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options2) {
      var opts = options2 || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format3(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name2 = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name2);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
        params["filename*"] = name2;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name2;
      }
      return params;
    }
    function format3(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string2 = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string2 += "; " + param + "=" + val;
        }
      }
      return string2;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer3.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse3(string2) {
      if (!string2 || typeof string2 !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string2);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string2)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string2.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/tar/node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/tar/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options2) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options2 && options2.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options2 && options2.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options2 && !!options2.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options2 && options2.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options2 && options2.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this[BUFFER].length)
            this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding2, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (!encoding2)
          encoding2 = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && !(encoding2 === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this[BUFFER] = [this[BUFFER].join("")];
          else
            this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this[BUFFER][0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding2, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (chunk)
          this.write(chunk, encoding2);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[BUFFER].length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        }
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this[PIPES].length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/constants.js
var require_constants3 = __commonJS({
  "node_modules/minizlib/constants.js"(exports2, module2) {
    var realZlibConstants = require("zlib").constants || { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minipass/index.js
var require_minipass2 = __commonJS({
  "node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options2) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options2 && options2.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options2 && options2.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options2 && !!options2.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding2, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (!encoding2)
          encoding2 = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && !(encoding2 === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding2, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (chunk)
          this.write(chunk, encoding2);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert2 = require("assert");
    var Buffer3 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants3();
    var Minipass = require_minipass2();
    var OriginalBufferConcat = Buffer3.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert2(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer3.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding2, cb) {
        if (chunk)
          this.write(chunk, encoding2);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding2, cb) {
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer3.from(chunk, encoding2);
        if (this[_sawError])
          return;
        assert2(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer3.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer3.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer3.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer3.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer3.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level2, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level2 || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert2(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level2, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level2;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports2, module2) {
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform2 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends MiniPass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
          this.mode = this.mode & 4095;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
          this[SLURP](ex);
        }
        if (gex) {
          this[SLURP](gex, true);
        }
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
          return true;
        }
        if (r >= writeLen) {
          return super.write(data);
        }
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path")) {
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
          }
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types2 = __commonJS({
  "node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      ["7", "ContiguousFile"],
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      ["A", "SolarisACL"],
      ["D", "GNUDumpDir"],
      ["I", "Inode"],
      ["K", "NextFileHasLongLinkpath"],
      ["L", "NextFileHasLongPath"],
      ["M", "ContinuationFile"],
      ["N", "OldGnuLongPath"],
      ["S", "SparseFile"],
      ["V", "TapeVolumeHeader"],
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports2, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num)) {
        throw Error("cannot encode number outside of javascript safe integer range");
      } else if (num < 0) {
        encodeNegative(num, buf);
      } else {
        encodePositive(num, buf);
      }
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped) {
          buf[i - 1] = onesComp(byte);
        } else if (byte === 0) {
          buf[i - 1] = 0;
        } else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse3 = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null) {
        throw Error("invalid base256 encoding");
      }
      if (!Number.isSafeInteger(value)) {
        throw Error("parsed number outside of javascript safe integer range");
      }
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped) {
          f = onesComp(byte);
        } else if (byte === 0) {
          f = byte;
        } else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0) {
          sum -= f * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0) {
          sum += byte * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse3
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data)) {
          this.decode(data, off || 0, ex, gex);
        } else if (data) {
          this.set(data);
        }
      }
      decode(buf, off, ex, gex) {
        if (!off) {
          off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "") {
          this[TYPE] = "0";
        }
        if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
          this[TYPE] = "5";
        }
        if (this[TYPE] === "5") {
          this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix) {
              this.path = prefix + "/" + this.path;
            }
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32) {
          this.nullBlock = true;
        }
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path")) {
            this[k] = ex[k];
          }
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off) {
          off = 0;
        }
        if (!(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path2 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path2) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0) {
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        } else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0) {
            this[i] = data[i];
          }
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type)) {
          this[TYPE] = types.code.get(type);
        } else {
          this[TYPE] = type;
        }
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize) {
        ret = [pp, prefix, false];
      } else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp, prefix, false];
          } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp.slice(0, pathSize - 1), prefix, true];
          } else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret) {
          ret = [p.slice(0, pathSize - 1), "", true];
        }
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(
      buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number2) => number2 === null ? false : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number2), false);
    var encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii");
    var octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size);
    var padOctal = (string2, size) => (string2.length === size - 1 ? string2 : new Array(size - string2.length - 1).join("0") + string2 + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string2) => string2 === null ? false : (buf.write(string2 + NULLS, off, size, "utf8"), string2.length !== Buffer.byteLength(string2) || string2.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path2 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "") {
          return null;
        }
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          path: ("PaxHeader/" + path2.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0) {
          return "";
        }
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
          digits += 1;
        }
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string2, ex, g) => new Pax(merge2(parseKV(string2), ex), g);
    var merge2 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string2) => string2.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1) {
        return set;
      }
      line = line.slice((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k) {
        return set;
      }
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports2, module2) {
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file) {
          data.file = this.file;
        }
        if (this.cwd) {
          data.cwd = this.cwd;
        }
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data));
        } else {
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
        }
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports2, module2) {
    var { isAbsolute, parse: parse3 } = require("path").win32;
    module2.exports = (path2) => {
      let r = "";
      let parsed = parse3(path2);
      while (isAbsolute(path2) || parsed.root) {
        const root = path2.charAt(0) === "/" && path2.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path2 = path2.slice(root.length);
        r += root;
        parsed = parse3(path2);
      }
      return [r, path2];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256) {
          mode |= 64;
        }
        if (mode & 32) {
          mode |= 8;
        }
        if (mode & 4) {
          mode |= 1;
        }
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs2 = require("fs");
    var path2 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path3, prefix) => {
      if (!prefix) {
        return normPath(path3);
      }
      path3 = normPath(path3).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path3;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends MiniPass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string") {
          throw new TypeError("path is required");
        }
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path2.resolve(this.cwd, p));
        if (this.path === "") {
          this.path = "./";
        }
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute)) {
          this[ONLSTAT](this.statCache.get(this.absolute));
        } else {
          this[LSTAT]();
        }
      }
      emit(ev, ...data) {
        if (ev === "error") {
          this[HAD_ERROR] = true;
        }
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs2.lstat(this.absolute, (er, stat) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile()) {
          stat.size = 0;
        }
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path3) {
        return prefixPath(path3, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.slice(-1) !== "/") {
          this.path += "/";
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs2.readlink(this.absolute, (er, linkpath) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path2.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0) {
              return this[HARDLINK](linkpath);
            }
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
          return this.end();
        }
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs2.open(this.absolute, "r", (er, fd) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR]) {
          return this[CLOSE]();
        }
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs2.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs2.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed) {
          this[AWAITDRAIN](() => this[ONDRAIN]());
        } else {
          this[ONDRAIN]();
        }
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
          }
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs2.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs2.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs2.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs2.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path3) {
        return prefixPath(path3, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path3, absolute) {
        this.path = path3 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var MiniPass = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs2 = require("fs");
    var path2 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends MiniPass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object") {
            opt.gzip = {};
          }
          if (this.portable) {
            opt.gzip.portable = true;
          }
          this.zip = new zlib.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else {
          this.on("drain", this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path3) {
        this.write(path3);
        return this;
      }
      end(path3) {
        if (path3) {
          this.write(path3);
        }
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path3) {
        if (this[ENDED]) {
          throw new Error("write after end");
        }
        if (path3 instanceof ReadEntry) {
          this[ADDTARENTRY](path3);
        } else {
          this[ADDFSENTRY](path3);
        }
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path2.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p)) {
          p.resume();
        } else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path2.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs2[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            this.emit("error", er);
          } else {
            this[ONSTAT](job, stat2);
          }
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat)) {
          job.ignore = true;
        }
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs2.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING]) {
          return;
        }
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip) {
            this.zip.end(EOF);
          } else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending) {
          return;
        }
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
          }
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute)) {
            this[ONSTAT](job, this.statCache.get(job.absolute));
          } else {
            this[STAT](job);
          }
        }
        if (!job.stat) {
          return;
        }
        if (job.ignore) {
          return;
        }
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute)) {
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          } else {
            this[READDIR](job);
          }
          if (!job.readdir) {
            return;
          }
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
          this[CURRENT].entry.resume();
        }
      }
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk)) {
              source.pause();
            }
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk)) {
              source.pause();
            }
          });
        }
      }
      pause() {
        if (this.zip) {
          this.zip.pause();
        }
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs2[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs2.readdirSync(job.absolute));
      }
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass2();
    var EE = require("events").EventEmitter;
    var fs2 = require("fs");
    var writev = fs2.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path2, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path2 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path2;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs2.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path2, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path2;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs2.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var { nextTick } = require("process");
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var CLOSESTREAM = Symbol("closeStream");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone) {
          this.on(DONE, opt.ondone);
        } else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        this.on("end", () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        if (typeof opt.onentry === "function") {
          this.on("entry", opt.onentry);
        }
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null) {
          this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin") {
              this[STATE] = "header";
            }
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid) {
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          } else if (!header.path) {
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          } else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            } else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid) {
                      this[SAW_VALID_ENTRY] = true;
                    }
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain) {
                    this[STATE] = "body";
                  } else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else {
                    this[QUEUE].push(entry);
                  }
                }
              }
            }
          }
        }
      }
      [CLOSESTREAM]() {
        nextTick(() => this.emit("close"));
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry)) {
          this.emit.apply(this, entry);
        } else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING]) {
              this.emit("drain");
            }
          } else {
            re.once("drain", (_) => this.emit("drain"));
          }
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY]) {
          this[EMITMETA](entry);
        }
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY]) {
          this.emit(ev, data, extra);
        } else {
          this[QUEUE].push([ev, data, extra]);
        }
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED]) {
          return;
        }
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i]) {
              this[UNZIP] = false;
            }
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
          this[UNZIP].write(chunk);
        } else {
          this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length) {
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        }
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED]) {
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
        }
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER]) {
              entry.write(this[BUFFER]);
            }
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING]) {
          this[BUFFERCONCAT](chunk);
        } else if (!chunk && !this[BUFFER]) {
          this[MAYBEEND]();
        } else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED]) {
          this[MAYBEEND]();
        }
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER]) {
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          } else {
            this[BUFFER] = chunk.slice(position);
          }
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP]) {
            this[UNZIP].end(chunk);
          } else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser2 = require_parse2();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path2 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      if (!opt.noResume) {
        onentryFunction(opt);
      }
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter2 = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path2.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path2.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list2(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs2.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p.end(fs2.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs2.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse3 = new Parser2(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        parse3.on("error", reject);
        parse3.on("end", resolve);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse3);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list2 = (opt) => new Parser2(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path2 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function") {
        cb = files;
      }
      if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path2.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path2.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path2 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs2.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT") {
            fd = fs2.openSync(opt.file, "w+");
          } else {
            throw er;
          }
        }
        const st = fs2.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes2 = 0; bufPos < 512; bufPos += bytes2) {
              bytes2 = fs2.readSync(
                fd,
                headBuf,
                bufPos,
                headBuf.length - bufPos,
                position + bufPos
              );
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
                throw new Error("cannot append to compressed archives");
              }
              if (!bytes2) {
                break POSITION;
              }
            }
            const h = new Header(headBuf);
            if (!h.cksumValid) {
              break;
            }
            const entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size) {
              break;
            }
            position += entryBlockSize;
            if (opt.mtimeCache) {
              opt.mtimeCache.set(h.path, h.mtime);
            }
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er) {
            fs2.close(fd, (_) => cb_(er));
          } else {
            cb_(null, pos);
          }
        };
        let position = 0;
        if (size === 0) {
          return cb2(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes2) => {
          if (er) {
            return cb2(er);
          }
          bufPos += bytes2;
          if (bufPos < 512 && bytes2) {
            return fs2.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos,
              onread
            );
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            return cb2(new Error("cannot append to compressed archives"));
          }
          if (bufPos < 512) {
            return cb2(null, position);
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            return cb2(null, position);
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size) {
            return cb2(null, position);
          }
          position += entryBlockSize + 512;
          if (position >= size) {
            return cb2(null, position);
          }
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
          bufPos = 0;
          fs2.read(fd, headBuf, 0, 512, position, onread);
        };
        fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs2.open(opt.file, flag, onopen);
          }
          if (er) {
            return reject(er);
          }
          fs2.fstat(fd, (er2, st) => {
            if (er2) {
              return fs2.close(fd, () => reject(er2));
            }
            getPos(fd, st.size, (er3, position) => {
              if (er3) {
                return reject(er3);
              }
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve);
              addFilesAsync(p, files);
            });
          });
        };
        fs2.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path2.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path2.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter2 = opt.filter;
      if (!opt.mtimeCache) {
        opt.mtimeCache = /* @__PURE__ */ new Map();
      }
      opt.filter = filter2 ? (path2, stat) => filter2(path2, stat) && !(opt.mtimeCache.get(path2) > stat.mtime) : (path2, stat) => !(opt.mtimeCache.get(path2) > stat.mtime);
    };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    var { promisify: promisify2 } = require("util");
    var fs2 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs2 };
      else if (typeof opts === "object")
        opts = { mode: 511, fs: fs2, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs2 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs2 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir;
      opts.mkdirAsync = promisify2(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs2.stat;
      opts.statAsync = promisify2(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/tar/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    var platform2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve, parse: parse3 } = require("path");
    var pathArg = (path2) => {
      if (/\0/.test(path2)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path: path2,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path2 = resolve(path2);
      if (platform2 === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse3(path2);
        if (badWinChars.test(path2.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path2,
            code: "EINVAL"
          });
        }
      }
      return path2;
    };
    module2.exports = pathArg;
  }
});

// node_modules/tar/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    var { dirname } = require("path");
    var findMade = (opts, parent, path2 = void 0) => {
      if (path2 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path2 : void 0,
        (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path2 = void 0) => {
      if (path2 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path2 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    var { dirname } = require("path");
    var mkdirpManual = (path2, opts, made) => {
      opts.recursive = false;
      const parent = dirname(path2);
      if (parent === path2) {
        return opts.mkdirAsync(path2, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path2, opts).then(() => made || path2, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path2, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path2).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path2, opts, made) => {
      const parent = dirname(path2);
      opts.recursive = false;
      if (parent === path2) {
        try {
          return opts.mkdirSync(path2, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path2, opts);
        return made || path2;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path2, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path2).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    var { dirname } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path2, opts) => {
      opts.recursive = true;
      const parent = dirname(path2);
      if (parent === path2)
        return opts.mkdirAsync(path2, opts);
      return findMade(opts, path2).then((made) => opts.mkdirAsync(path2, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path2, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path2, opts) => {
      opts.recursive = true;
      const parent = dirname(path2);
      if (parent === path2)
        return opts.mkdirSync(path2, opts);
      const made = findMadeSync(opts, path2);
      try {
        opts.mkdirSync(path2, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path2, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    var fs2 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs2.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs2.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/tar/node_modules/mkdirp/index.js"(exports2, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path2, opts) => {
      path2 = pathArg(path2);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path2, opts) : mkdirpManual(path2, opts);
    };
    var mkdirpSync = (path2, opts) => {
      path2 = pathArg(path2);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path2, opts) : mkdirpManualSync(path2, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path2, opts) => mkdirpNative(pathArg(path2), optsArg(opts));
    mkdirp.manual = (path2, opts) => mkdirpManual(pathArg(path2), optsArg(opts));
    mkdirp.nativeSync = (path2, opts) => mkdirpNativeSync(pathArg(path2), optsArg(opts));
    mkdirp.manualSync = (path2, opts) => mkdirpManualSync(pathArg(path2), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path2 = require("path");
    var LCHOWN = fs2.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path3, uid, gid) => {
      try {
        return fs2[LCHOWNSYNC](path3, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path3, uid, gid) => {
      try {
        return fs2.chownSync(path3, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path3, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs2.chown(path3, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path3, uid, gid) => {
      try {
        return lchownSync(path3, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path3, uid, gid);
      }
    } : (path3, uid, gid) => lchownSync(path3, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path3, options2, cb) => fs2.readdir(path3, options2, cb);
    var readdirSync = (path3, options2) => fs2.readdirSync(path3, options2);
    if (/^v4\./.test(nodeVersion))
      readdir = (path3, options2, cb) => fs2.readdir(path3, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs2.lstat(path2.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path2.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path2.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path2.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs2.lstatSync(path2.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path2.resolve(p, child.name), uid, gid);
      handleEISDirSync(path2.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs2 = require("fs");
    var path2 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path3) {
        super("Cannot extract through symbolic link");
        this.path = path3;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path3, code) {
        super(code + ": Cannot cd into '" + path3 + "'");
        this.path = path3;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs2.stat(dir, (er, st) => {
        if (er || !st.isDirectory()) {
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        }
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (er, created) => {
        if (er) {
          cb(er);
        } else {
          cSet(cache, dir, true);
          if (created && doChown) {
            chownr(created, uid, gid, (er2) => done(er2));
          } else if (needChmod) {
            fs2.chmod(dir, mode, cb);
          } else {
            cb();
          }
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        return checkCwd(dir, done);
      }
      if (preserve) {
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      }
      const sub = normPath(path2.relative(cwd2, dir));
      const parts = sub.split("/");
      mkdir_(cwd2, parts, mode, cache, unlink, cwd2, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd2, created, cb) => {
      if (!parts.length) {
        return cb(null, created);
      }
      const p = parts.shift();
      const part = normPath(path2.resolve(base + "/" + p));
      if (cGet(cache, part)) {
        return mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
      }
      fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd2, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd2, created, cb) => (er) => {
      if (er) {
        fs2.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory()) {
            mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
          } else if (unlink) {
            fs2.unlink(part, (er2) => {
              if (er2) {
                return cb(er2);
              }
              fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd2, created, cb));
            });
          } else if (st.isSymbolicLink()) {
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          } else {
            cb(er);
          }
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs2.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok) {
          throw new CwdError(dir, code);
        }
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown) {
          chownr.sync(created2, uid, gid);
        }
        if (needChmod) {
          fs2.chmodSync(dir, mode);
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        checkCwdSync(cwd2);
        return done();
      }
      if (preserve) {
        return done(mkdirp.sync(dir, mode));
      }
      const sub = normPath(path2.relative(cwd2, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd2; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path2.resolve(part));
        if (cGet(cache, part)) {
          continue;
        }
        try {
          fs2.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs2.unlinkSync(part);
            fs2.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink()) {
            return new SymlinkError(part, part + "/" + parts.join("/"));
          }
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports2, module2) {
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty3.call(normalizeCache, s)) {
        normalizeCache[s] = s.normalize("NFKD");
      }
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    var assert2 = require("assert");
    var normalize = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join } = require("path");
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows2 = platform2 === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path2) => {
        const dirs = path2.split("/").slice(0, -1).reduce((set, path3) => {
          if (set.length) {
            path3 = join(set[set.length - 1], path3);
          }
          set.push(path3 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res) {
          throw new Error("function does not have any path reservations");
        }
        return {
          paths: res.paths.map((path2) => queues.get(path2)),
          dirs: [...res.dirs].map((path2) => queues.get(path2))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn)) {
          return false;
        }
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn)) {
          return false;
        }
        const { paths, dirs } = reservations.get(fn);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path2) => {
          const q = queues.get(path2);
          assert2.equal(q[0], fn);
          if (q.length === 1) {
            queues.delete(path2);
          } else {
            q.shift();
            if (typeof q[0] === "function") {
              next.add(q[0]);
            } else {
              q[0].forEach((fn2) => next.add(fn2));
            }
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert2(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else {
            q[0].delete(fn);
          }
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows2 ? ["win32 parallelization disabled"] : paths.map((p) => {
          return normalize(stripSlashes(join(p))).toLowerCase();
        });
        const dirs = new Set(
          paths.map((path2) => getDirs(path2)).reduce((a, b) => a.concat(b))
        );
        reservations.set(fn, { dirs, paths });
        paths.forEach((path2) => {
          const q = queues.get(path2);
          if (!q) {
            queues.set(path2, [fn]);
          } else {
            q.push(fn);
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q) {
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          } else if (q[q.length - 1] instanceof Set) {
            q[q.length - 1].add(fn);
          } else {
            q.push(/* @__PURE__ */ new Set([fn]));
          }
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    var platform2 = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows2 = platform2 === "win32";
    var fs2 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants;
    var fMapEnabled = isWindows2 && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert2 = require("assert");
    var Parser2 = require_parse2();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path2 = require("path");
    var mkdir = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto3 = require("crypto");
    var getFlag = require_get_write_flag();
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows2 = platform2 === "win32";
    var unlinkFile = (path3, cb) => {
      if (!isWindows2) {
        return fs2.unlink(path3, cb);
      }
      const name2 = path3 + ".DELETE." + crypto3.randomBytes(16).toString("hex");
      fs2.rename(path3, name2, (er) => {
        if (er) {
          return cb(er);
        }
        fs2.unlink(name2, cb);
      });
    };
    var unlinkFileSync = (path3) => {
      if (!isWindows2) {
        return fs2.unlinkSync(path3);
      }
      const name2 = path3 + ".DELETE." + crypto3.randomBytes(16).toString("hex");
      fs2.renameSync(path3, name2);
      fs2.unlinkSync(name2);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path3) => normalize(stripSlash(normPath(path3))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path3 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path3);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
          cache.delete(path3);
        }
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys()) {
        cache.delete(key);
      }
    };
    var Unpack = class extends Parser2 {
      constructor(opt) {
        if (!opt) {
          opt = {};
        }
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
            throw new TypeError("cannot set owner without number uid and gid");
          }
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
          this.preserveOwner = process.getuid && process.getuid() === 0;
        } else {
          this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows2;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path2.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
          data.recoverable = false;
        }
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = normPath(entry.path).split("/");
          if (parts.length < this.strip) {
            return false;
          }
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip) {
              entry.linkpath = linkparts.slice(this.strip).join("/");
            } else {
              return false;
            }
          }
        }
        if (!this.preservePaths) {
          const p = normPath(entry.path);
          const parts = p.split("/");
          if (parts.includes("..") || isWindows2 && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path2.isAbsolute(entry.path)) {
          entry.absolute = normPath(path2.resolve(entry.path));
        } else {
          entry.absolute = normPath(path2.resolve(this.cwd, entry.path));
        }
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
          return false;
        }
        if (this.win32) {
          const { root: aRoot } = path2.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
          const { root: pRoot } = path2.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
          return entry.resume();
        }
        assert2.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode) {
              entry.mode = entry.mode | 448;
            }
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError") {
          this.emit("error", er);
        } else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd) {
            fs2.close(stream.fd, () => {
            });
          }
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd) {
              fs2.close(stream.fd, () => {
              });
            }
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs2.close(stream.fd, (er2) => {
              if (er2) {
                this[ONERROR](er2, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs2.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path2.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows2;
      }
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath) {
          paths.push(entry.linkpath);
        }
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink") {
          dropCache(this.dirCache);
        } else if (entry.type !== "Directory") {
          pruneCache(this.dirCache, entry.absolute);
        }
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path2.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs2.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st)) {
              return this[MAKEFS](null, entry, done);
            }
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod) {
                  return afterChmod();
                }
                return fs2.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd) {
              return this[MAKEFS](null, entry, done);
            }
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD]) {
          start();
        } else {
          checkCwd();
        }
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs2[link](linkpath, entry.absolute, (er) => {
          if (er) {
            this[ONERROR](er, entry);
          } else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2) {
            return this[ONERROR](er2, entry);
          }
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path2.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent) {
              return this[ONERROR](mkParent, entry);
            }
          }
        }
        const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs2.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs2.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError) {
            this[ONERROR](er || closeError, entry);
          }
          done();
        };
        let fd;
        try {
          fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs2.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            try {
              fs2.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs2.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs2.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs2.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs2.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs2[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path2 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter2 = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path2.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path2.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs2.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        u.on("error", reject);
        u.on("close", resolve);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse2();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types2();
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports2, module2) {
    module2.exports = Traverse;
    function Traverse(obj) {
      if (!(this instanceof Traverse))
        return new Traverse(obj);
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk2(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk2(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.deepEqual = function(obj) {
      if (arguments.length !== 1) {
        throw new Error(
          "deepEqual requires exactly one object to compare against"
        );
      }
      var equal = true;
      var node = obj;
      this.forEach(function(y) {
        var notEqual = function() {
          equal = false;
          return void 0;
        }.bind(this);
        if (!this.isRoot) {
          if (typeof node !== "object")
            return notEqual();
          node = node[this.key];
        }
        var x = node;
        this.post(function() {
          node = x;
        });
        var toS = function(o) {
          return Object.prototype.toString.call(o);
        };
        if (this.circular) {
          if (Traverse(obj).get(this.circular.path) !== x)
            notEqual();
        } else if (typeof x !== typeof y) {
          notEqual();
        } else if (x === null || y === null || x === void 0 || y === void 0) {
          if (x !== y)
            notEqual();
        } else if (x.__proto__ !== y.__proto__) {
          notEqual();
        } else if (x === y) {
        } else if (typeof x === "function") {
          if (x instanceof RegExp) {
            if (x.toString() != y.toString())
              notEqual();
          } else if (x !== y)
            notEqual();
        } else if (typeof x === "object") {
          if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
            if (toS(x) !== toS(y)) {
              notEqual();
            }
          } else if (x instanceof Date || y instanceof Date) {
            if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
              notEqual();
            }
          } else {
            var kx = Object.keys(x);
            var ky = Object.keys(y);
            if (kx.length !== ky.length)
              return notEqual();
            for (var i = 0; i < kx.length; i++) {
              var k = kx[i];
              if (!Object.hasOwnProperty.call(y, k)) {
                notEqual();
              }
            }
          }
        }
      });
      return equal;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          Object.keys(src).forEach(function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk2(root, cb, immutable) {
      var path2 = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
          node,
          node_,
          path: [].concat(path2),
          parent: parents.slice(-1)[0],
          key: path2.slice(-1)[0],
          isRoot: path2.length === 0,
          level: path2.length,
          circular: null,
          update: function(x) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
          },
          "delete": function() {
            delete state.parent.node[state.key];
          },
          remove: function() {
            if (Array.isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
          },
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          }
        };
        if (!alive)
          return state;
        if (typeof node === "object" && node !== null) {
          state.isLeaf = Object.keys(node).length == 0;
          for (var i = 0; i < parents.length; i++) {
            if (parents[i].node_ === node_) {
              state.circular = parents[i];
              break;
            }
          }
        } else {
          state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update)
          state.update(ret);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          var keys = Object.keys(state.node);
          keys.forEach(function(key, i2) {
            path2.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && Object.hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i2 == keys.length - 1;
            child.isFirst = i2 == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path2.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    Object.keys(Traverse.prototype).forEach(function(key) {
      Traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
          dst = [];
        } else if (src instanceof Date) {
          dst = new Date(src);
        } else if (src instanceof Boolean) {
          dst = new Boolean(src);
        } else if (src instanceof Number) {
          dst = new Number(src);
        } else if (src instanceof String) {
          dst = new String(src);
        } else {
          dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS({
  "node_modules/chainsaw/index.js"(exports2, module2) {
    var Traverse = require_traverse();
    var EventEmitter4 = require("events").EventEmitter;
    module2.exports = Chainsaw;
    function Chainsaw(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      saw.record();
      return saw.chain();
    }
    Chainsaw.light = function ChainsawLight(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      return saw.chain();
    };
    Chainsaw.saw = function(builder, handlers) {
      var saw = new EventEmitter4();
      saw.handlers = handlers;
      saw.actions = [];
      saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
          if (this.isRoot)
            return node;
          var ps = this.path;
          if (typeof node === "function") {
            this.update(function() {
              saw.actions.push({
                path: ps,
                args: [].slice.call(arguments)
              });
              return ch;
            });
          }
        });
        process.nextTick(function() {
          saw.emit("begin");
          saw.next();
        });
        return ch;
      };
      saw.pop = function() {
        return saw.actions.shift();
      };
      saw.next = function() {
        var action = saw.pop();
        if (!action) {
          saw.emit("end");
        } else if (!action.trap) {
          var node = saw.handlers;
          action.path.forEach(function(key) {
            node = node[key];
          });
          node.apply(saw.handlers, action.args);
        }
      };
      saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
          var autonext = cb;
          cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== void 0)
          s.handlers = r;
        if ("undefined" !== typeof saw.step) {
          s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false)
          s.on("end", saw.next);
      };
      saw.record = function() {
        upgradeChainsaw(saw);
      };
      ["trap", "down", "jump"].forEach(function(method) {
        saw[method] = function() {
          throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
        };
      });
      return saw;
    };
    function upgradeChainsaw(saw) {
      saw.step = 0;
      saw.pop = function() {
        return saw.actions[saw.step++];
      };
      saw.trap = function(name2, cb) {
        var ps = Array.isArray(name2) ? name2 : [name2];
        saw.actions.push({
          path: ps,
          step: saw.step,
          cb,
          trap: true
        });
      };
      saw.down = function(name2) {
        var ps = (Array.isArray(name2) ? name2 : [name2]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
          if (x.trap && x.step <= saw.step)
            return false;
          return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0)
          saw.step += i;
        else
          saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
          saw.step = act.step;
          act.cb();
        } else
          saw.next();
      };
      saw.jump = function(step) {
        saw.step = step;
        saw.next();
      };
    }
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS({
  "node_modules/buffers/index.js"(exports2, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers))
        return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i, howMany) {
      var buffers = this.buffers;
      var index = i >= 0 ? i : this.length - i;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
      }
      var removed = new Buffers();
      var bytes2 = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i = 0; i < start; i++) {
            buf0[i] = orig[i];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i = start + howMany; i < orig.length; i++) {
            buf1[i - howMany - start] = orig[i];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i, j) {
      var buffers = this.buffers;
      if (j === void 0)
        j = this.length;
      if (i === void 0)
        i = 0;
      if (j > this.length)
        j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i);
      var ti = 0;
      for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i) {
      if (i < 0 || i >= this.length)
        throw new Error("oob");
      var l = i, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l < bu.length) {
          return { buf: bi, offset: l };
        } else {
          l -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set(i, b) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].set(pos.offset, b);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if ("string" === typeof needle) {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i].length) {
          j = 0;
          i++;
          if (i >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding2, start, end) {
      return this.slice(start, end).toString(encoding2);
    };
  }
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS({
  "node_modules/binary/lib/vars.js"(exports2, module2) {
    module2.exports = function(store) {
      function getset(name2, value) {
        var node = vars.store;
        var keys = name2.split(".");
        keys.slice(0, -1).forEach(function(k) {
          if (node[k] === void 0)
            node[k] = {};
          node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
          return node[key];
        } else {
          return node[key] = value;
        }
      }
      var vars = {
        get: function(name2) {
          return getset(name2);
        },
        set: function(name2, value) {
          return getset(name2, value);
        },
        store: store || {}
      };
      return vars;
    };
  }
});

// node_modules/binary/index.js
var require_binary = __commonJS({
  "node_modules/binary/index.js"(exports2, module2) {
    var Chainsaw = require_chainsaw();
    var EventEmitter4 = require("events").EventEmitter;
    var Buffers = require_buffers();
    var Vars = require_vars();
    var Stream = require("stream").Stream;
    exports2 = module2.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports2.parse(bufOrEm);
      }
      var s = exports2.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports2.stream = function(input) {
      if (input)
        return exports2.apply(null, arguments);
      var pending = null;
      function getBytes(bytes2, cb, skip) {
        pending = {
          bytes: bytes2,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd)
            done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes2 = offset + pending.bytes;
          if (buffers.length >= bytes2) {
            var buf;
            if (offset == null) {
              buf = buffers.splice(0, bytes2);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers.slice(offset, bytes2);
              }
              offset = bytes2;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done)
            saw.next();
        }
        var self = words(function(bytes2, cb) {
          return function(name2) {
            getBytes(bytes2, function(buf) {
              vars.set(name2, cb(buf));
              next();
            });
          };
        });
        self.tap = function(cb) {
          saw.nest(cb, vars.store);
        };
        self.into = function(key, cb) {
          if (!vars.get(key))
            vars.set(key, {});
          var parent = vars;
          vars = Vars(parent.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars = parent;
            });
          }, vars.store);
        };
        self.flush = function() {
          vars.store = {};
          next();
        };
        self.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars.store);
            this.tap(function() {
              if (end)
                saw.next();
              else
                loop.call(this);
            }.bind(this));
          }, vars.store);
        };
        self.buffer = function(name2, bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function(buf) {
            vars.set(name2, buf);
            next();
          });
        };
        self.skip = function(bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function() {
            next();
          });
        };
        self.scan = function find(name2, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars.set(
                  name2,
                  buffers.slice(offset, offset + taken + i)
                );
                offset += taken + i + search.length;
              } else {
                vars.set(
                  name2,
                  buffers.slice(0, taken + i)
                );
                buffers.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self;
      }
      ;
      var stream = Chainsaw.light(builder);
      stream.writable = true;
      var buffers = Buffers();
      stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
      };
      var vars = Vars();
      var done = false, caughtEnd = false;
      stream.end = function() {
        caughtEnd = true;
      };
      stream.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter4.prototype).forEach(function(name2) {
        stream[name2] = EventEmitter4.prototype[name2];
      });
      return stream;
    };
    exports2.parse = function parse3(buffer) {
      var self = words(function(bytes2, cb) {
        return function(name2) {
          if (offset + bytes2 <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes2);
            offset += bytes2;
            vars.set(name2, cb(buf));
          } else {
            vars.set(name2, null);
          }
          return self;
        };
      });
      var offset = 0;
      var vars = Vars();
      self.vars = vars.store;
      self.tap = function(cb) {
        cb.call(self, vars.store);
        return self;
      };
      self.into = function(key, cb) {
        if (!vars.get(key)) {
          vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self, vars.store);
        vars = parent;
        return self;
      };
      self.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self, ender, vars.store);
        }
        return self;
      };
      self.buffer = function(name2, size) {
        if (typeof size === "string") {
          size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name2, buf);
        return self;
      };
      self.skip = function(bytes2) {
        if (typeof bytes2 === "string") {
          bytes2 = vars.get(bytes2);
        }
        offset += bytes2;
        return self;
      };
      self.scan = function(name2, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars.set(name2, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++)
            ;
          if (j === search.length)
            break;
        }
        vars.set(name2, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self;
      };
      self.peek = function(cb) {
        var was = offset;
        cb.call(self, vars.store);
        offset = was;
        return self;
      };
      self.flush = function() {
        vars.store = {};
        return self;
      };
      self.eof = function() {
        return offset >= buffer.length;
      };
      return self;
    };
    function decodeLEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, i) * bytes2[i];
      }
      return acc;
    }
    function decodeBEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, bytes2.length - i - 1) * bytes2[i];
      }
      return acc;
    }
    function decodeBEs(bytes2) {
      var val = decodeBEu(bytes2);
      if ((bytes2[0] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function decodeLEs(bytes2) {
      var val = decodeLEu(bytes2);
      if ((bytes2[bytes2.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function words(decode) {
      var self = {};
      [1, 2, 4, 8].forEach(function(bytes2) {
        var bits = bytes2 * 8;
        self["word" + bits + "le"] = self["word" + bits + "lu"] = decode(bytes2, decodeLEu);
        self["word" + bits + "ls"] = decode(bytes2, decodeLEs);
        self["word" + bits + "be"] = self["word" + bits + "bu"] = decode(bytes2, decodeBEu);
        self["word" + bits + "bs"] = decode(bytes2, decodeBEs);
      });
      self.word8 = self.word8u = self.word8be;
      self.word8s = self.word8bs;
      return self;
    }
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS({
  "node_modules/unzip-stream/lib/matcher-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util = require("util");
    function MatcherStream(patternDesc, matchFn) {
      if (!(this instanceof MatcherStream)) {
        return new MatcherStream();
      }
      Transform2.call(this);
      var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
      this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
      this.requiredLength = this.pattern.length;
      if (patternDesc.requiredExtraSize)
        this.requiredLength += patternDesc.requiredExtraSize;
      this.data = new Buffer("");
      this.bytesSoFar = 0;
      this.matchFn = matchFn;
    }
    util.inherits(MatcherStream, Transform2);
    MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
      var enoughData = this.data.length >= this.requiredLength;
      if (!enoughData) {
        return;
      }
      var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
      if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
        if (matchIndex > 0) {
          var packet = this.data.slice(0, matchIndex);
          this.push(packet);
          this.bytesSoFar += matchIndex;
          this.data = this.data.slice(matchIndex);
        }
        return;
      }
      if (matchIndex === -1) {
        var packetLen = this.data.length - this.requiredLength + 1;
        var packet = this.data.slice(0, packetLen);
        this.push(packet);
        this.bytesSoFar += packetLen;
        this.data = this.data.slice(packetLen);
        return;
      }
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.data = this.data.slice(matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
      }
      var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
      if (finished) {
        this.data = new Buffer("");
        return;
      }
      return true;
    };
    MatcherStream.prototype._transform = function(chunk, encoding2, cb) {
      this.data = Buffer.concat([this.data, chunk]);
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
      cb();
    };
    MatcherStream.prototype._flush = function(cb) {
      if (this.data.length > 0) {
        var firstIteration = true;
        while (this.checkDataChunk(!firstIteration)) {
          firstIteration = false;
        }
      }
      if (this.data.length > 0) {
        this.push(this.data);
        this.data = null;
      }
      cb();
    };
    module2.exports = MatcherStream;
  }
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS({
  "node_modules/unzip-stream/lib/entry.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var inherits = require("util").inherits;
    function Entry() {
      if (!(this instanceof Entry)) {
        return new Entry();
      }
      stream.PassThrough.call(this);
      this.path = null;
      this.type = null;
      this.isDirectory = false;
    }
    inherits(Entry, stream.PassThrough);
    Entry.prototype.autodrain = function() {
      return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = Entry;
  }
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS({
  "node_modules/unzip-stream/lib/unzip-stream.js"(exports2, module2) {
    "use strict";
    var binary = require_binary();
    var stream = require("stream");
    var util = require("util");
    var zlib = require("zlib");
    var MatcherStream = require_matcher_stream();
    var Entry = require_entry();
    var states = {
      STREAM_START: 0,
      START: 1,
      LOCAL_FILE_HEADER: 2,
      LOCAL_FILE_HEADER_SUFFIX: 3,
      FILE_DATA: 4,
      FILE_DATA_END: 5,
      DATA_DESCRIPTOR: 6,
      CENTRAL_DIRECTORY_FILE_HEADER: 7,
      CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
      CDIR64_END: 9,
      CDIR64_END_DATA_SECTOR: 10,
      CDIR64_LOCATOR: 11,
      CENTRAL_DIRECTORY_END: 12,
      CENTRAL_DIRECTORY_END_COMMENT: 13,
      TRAILING_JUNK: 14,
      ERROR: 99
    };
    var FOUR_GIGS = 4294967296;
    var SIG_LOCAL_FILE_HEADER = 67324752;
    var SIG_DATA_DESCRIPTOR = 134695760;
    var SIG_CDIR_RECORD = 33639248;
    var SIG_CDIR64_RECORD_END = 101075792;
    var SIG_CDIR64_LOCATOR_END = 117853008;
    var SIG_CDIR_RECORD_END = 101010256;
    function UnzipStream(options2) {
      if (!(this instanceof UnzipStream)) {
        return new UnzipStream(options2);
      }
      stream.Transform.call(this);
      this.options = options2 || {};
      this.data = new Buffer("");
      this.state = states.STREAM_START;
      this.skippedBytes = 0;
      this.parsedEntity = null;
      this.outStreamInfo = {};
    }
    util.inherits(UnzipStream, stream.Transform);
    UnzipStream.prototype.processDataChunk = function(chunk) {
      var requiredLength;
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          requiredLength = 4;
          break;
        case states.LOCAL_FILE_HEADER:
          requiredLength = 26;
          break;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
          break;
        case states.DATA_DESCRIPTOR:
          requiredLength = 12;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          requiredLength = 42;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
          break;
        case states.CDIR64_END:
          requiredLength = 52;
          break;
        case states.CDIR64_END_DATA_SECTOR:
          requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
          break;
        case states.CDIR64_LOCATOR:
          requiredLength = 16;
          break;
        case states.CENTRAL_DIRECTORY_END:
          requiredLength = 18;
          break;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          requiredLength = this.parsedEntity.commentLength;
          break;
        case states.FILE_DATA:
          return 0;
        case states.FILE_DATA_END:
          return 0;
        case states.TRAILING_JUNK:
          if (this.options.debug)
            console.log("found", chunk.length, "bytes of TRAILING_JUNK");
          return chunk.length;
        default:
          return chunk.length;
      }
      var chunkLength = chunk.length;
      if (chunkLength < requiredLength) {
        return 0;
      }
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          var signature = chunk.readUInt32LE(0);
          switch (signature) {
            case SIG_LOCAL_FILE_HEADER:
              this.state = states.LOCAL_FILE_HEADER;
              break;
            case SIG_CDIR_RECORD:
              this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
              break;
            case SIG_CDIR64_RECORD_END:
              this.state = states.CDIR64_END;
              break;
            case SIG_CDIR64_LOCATOR_END:
              this.state = states.CDIR64_LOCATOR;
              break;
            case SIG_CDIR_RECORD_END:
              this.state = states.CENTRAL_DIRECTORY_END;
              break;
            default:
              var isStreamStart = this.state === states.STREAM_START;
              if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
                var remaining = signature;
                var toSkip = 4;
                for (var i = 1; i < 4 && remaining !== 0; i++) {
                  remaining = remaining >>> 8;
                  if ((remaining & 255) === 80) {
                    toSkip = i;
                    break;
                  }
                }
                this.skippedBytes += toSkip;
                if (this.options.debug)
                  console.log("Skipped", this.skippedBytes, "bytes");
                return toSkip;
              }
              this.state = states.ERROR;
              var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
              if (this.options.debug) {
                var sig = chunk.readUInt32LE(0);
                var asString;
                try {
                  asString = chunk.slice(0, 4).toString();
                } catch (e) {
                }
                console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
              }
              this.emit("error", new Error(errMsg));
              return chunk.length;
          }
          this.skippedBytes = 0;
          return requiredLength;
        case states.LOCAL_FILE_HEADER:
          this.parsedEntity = this._readFile(chunk);
          this.state = states.LOCAL_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          var entry = new Entry();
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed) {
            if (extra.parsed.path && !isUtf8) {
              entry.path = extra.parsed.path;
            }
            if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
            }
            if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.compressedSize = extra.parsed.compressedSize;
            }
          }
          this.parsedEntity.extra = extra.parsed || {};
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: entry.path,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              extraFields: extra && extra.debug
            });
            console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this._prepareOutStream(this.parsedEntity, entry);
          this.emit("entry", entry);
          this.state = states.FILE_DATA;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          this.parsedEntity = this._readCentralDirectoryEntry(chunk);
          this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          var path2 = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
            path2 = extra.parsed.path;
          }
          this.parsedEntity.extra = extra.parsed;
          var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
          var unixAttrs, isSymlink;
          if (isUnix) {
            unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
            var fileType = unixAttrs >>> 12;
            isSymlink = (fileType & 10) === 10;
          }
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: path2,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
              isSymlink,
              extraFields: extra.debug
            });
            console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_END:
          this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
          if (this.options.debug) {
            console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
          }
          this.state = states.CDIR64_END_DATA_SECTOR;
          return requiredLength;
        case states.CDIR64_END_DATA_SECTOR:
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_LOCATOR:
          this.state = states.START;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END:
          this.parsedEntity = this._readEndOfCentralDirectory(chunk);
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
          }
          this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
          }
          this.state = states.TRAILING_JUNK;
          return requiredLength;
        case states.ERROR:
          return chunk.length;
        default:
          console.log("didn't handle state #", this.state, "discarding");
          return chunk.length;
      }
    };
    UnzipStream.prototype._prepareOutStream = function(vars, entry) {
      var self = this;
      var isDirectory2 = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
      entry.path = entry.path.replace(/^([/\\]*[.]+[/\\]+)*[/\\]*/, "");
      entry.type = isDirectory2 ? "Directory" : "File";
      entry.isDirectory = isDirectory2;
      var fileSizeKnown = !(vars.flags & 8);
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
      }
      var isVersionSupported = vars.versionsNeededToExtract <= 45;
      this.outStreamInfo = {
        stream: null,
        limit: fileSizeKnown ? vars.compressedSize : -1,
        written: 0
      };
      if (!fileSizeKnown) {
        var pattern = new Buffer(4);
        pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
        var zip64Mode = vars.extra.zip64Mode;
        var extraSize = zip64Mode ? 20 : 12;
        var searchPattern = {
          pattern,
          requiredExtraSize: extraSize
        };
        var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
          var vars2 = self._readDataDescriptor(matchedChunk, zip64Mode);
          var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
          if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
            var overflown = sizeSoFar - FOUR_GIGS;
            while (overflown >= 0) {
              compressedSizeMatches = vars2.compressedSize === overflown;
              if (compressedSizeMatches)
                break;
              overflown -= FOUR_GIGS;
            }
          }
          if (!compressedSizeMatches) {
            return;
          }
          self.state = states.FILE_DATA_END;
          var sliceOffset = zip64Mode ? 24 : 16;
          if (self.data.length > 0) {
            self.data = Buffer.concat([matchedChunk.slice(sliceOffset), self.data]);
          } else {
            self.data = matchedChunk.slice(sliceOffset);
          }
          return true;
        });
        this.outStreamInfo.stream = matcherStream;
      } else {
        this.outStreamInfo.stream = new stream.PassThrough();
      }
      var isEncrypted = vars.flags & 1 || vars.flags & 64;
      if (isEncrypted || !isVersionSupported) {
        var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
        entry.skip = true;
        setImmediate(() => {
          entry.emit("error", new Error(message));
        });
        this.outStreamInfo.stream.pipe(new Entry().autodrain());
        return;
      }
      var isCompressed = vars.compressionMethod > 0;
      if (isCompressed) {
        var inflater = zlib.createInflateRaw();
        inflater.on("error", function(err) {
          self.state = states.ERROR;
          self.emit("error", err);
        });
        this.outStreamInfo.stream.pipe(inflater).pipe(entry);
      } else {
        this.outStreamInfo.stream.pipe(entry);
      }
      if (this._drainAllEntries) {
        entry.autodrain();
      }
    };
    UnzipStream.prototype._readFile = function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      return vars;
    };
    UnzipStream.prototype._readExtraFields = function(data) {
      var extra = {};
      var result = { parsed: extra };
      if (this.options.debug) {
        result.debug = [];
      }
      var index = 0;
      while (index < data.length) {
        var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
        index += 4;
        var fieldType = void 0;
        switch (vars.extraId) {
          case 1:
            fieldType = "Zip64 extended information extra field";
            var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
            if (z64vars.uncompressedSize !== null) {
              extra.uncompressedSize = z64vars.uncompressedSize;
            }
            if (z64vars.compressedSize !== null) {
              extra.compressedSize = z64vars.compressedSize;
            }
            extra.zip64Mode = true;
            break;
          case 10:
            fieldType = "NTFS extra field";
            break;
          case 21589:
            fieldType = "extended timestamp";
            var timestampFields = data.readUInt8(index);
            var offset = 1;
            if (vars.extraSize >= offset + 4 && timestampFields & 1) {
              extra.mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 2) {
              extra.atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 4) {
              extra.ctime = new Date(data.readUInt32LE(index + offset) * 1e3);
            }
            break;
          case 28789:
            fieldType = "Info-ZIP Unicode Path Extra Field";
            var fieldVer = data.readUInt8(index);
            if (fieldVer === 1) {
              var offset = 1;
              var nameCrc32 = data.readUInt32LE(index + offset);
              offset += 4;
              var pathBuffer = data.slice(index + offset);
              extra.path = pathBuffer.toString();
            }
            break;
          case 13:
          case 22613:
            fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
            var offset = 0;
            if (vars.extraSize >= 8) {
              var atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              var mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              extra.atime = atime;
              extra.mtime = mtime;
              if (vars.extraSize >= 12) {
                var uid = data.readUInt16LE(index + offset);
                offset += 2;
                var gid = data.readUInt16LE(index + offset);
                offset += 2;
                extra.uid = uid;
                extra.gid = gid;
              }
            }
            break;
          case 30805:
            fieldType = "Info-ZIP UNIX (type 2)";
            var offset = 0;
            if (vars.extraSize >= 4) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
            break;
          case 30837:
            fieldType = "Info-ZIP New Unix";
            var offset = 0;
            var extraVer = data.readUInt8(index);
            offset += 1;
            if (extraVer === 1) {
              var uidSize = data.readUInt8(index + offset);
              offset += 1;
              if (uidSize <= 6) {
                extra.uid = data.readUIntLE(index + offset, uidSize);
              }
              offset += uidSize;
              var gidSize = data.readUInt8(index + offset);
              offset += 1;
              if (gidSize <= 6) {
                extra.gid = data.readUIntLE(index + offset, gidSize);
              }
            }
            break;
          case 30062:
            fieldType = "ASi Unix";
            var offset = 0;
            if (vars.extraSize >= 14) {
              var crc = data.readUInt32LE(index + offset);
              offset += 4;
              var mode = data.readUInt16LE(index + offset);
              offset += 2;
              var sizdev = data.readUInt32LE(index + offset);
              offset += 4;
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.mode = mode;
              extra.uid = uid;
              extra.gid = gid;
              if (vars.extraSize > 14) {
                var start = index + offset;
                var end = index + vars.extraSize - 14;
                var symlinkName = this._decodeString(data.slice(start, end));
                extra.symlink = symlinkName;
              }
            }
            break;
        }
        if (this.options.debug) {
          result.debug.push({
            extraId: "0x" + vars.extraId.toString(16),
            description: fieldType,
            data: data.slice(index, index + vars.extraSize).inspect()
          });
        }
        index += vars.extraSize;
      }
      return result;
    };
    UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
      if (zip64Mode) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
        return vars;
      }
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      return vars;
    };
    UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
      var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return vars;
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ";
    UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      }
      if (this.options.decodeString) {
        return this.options.decodeString(buffer);
      }
      let result = "";
      for (var i = 0; i < buffer.length; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    };
    UnzipStream.prototype._parseOrOutput = function(encoding2, cb) {
      var consume;
      while ((consume = this.processDataChunk(this.data)) > 0) {
        this.data = this.data.slice(consume);
        if (this.data.length === 0)
          break;
      }
      if (this.state === states.FILE_DATA) {
        if (this.outStreamInfo.limit >= 0) {
          var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
          var packet;
          if (remaining < this.data.length) {
            packet = this.data.slice(0, remaining);
            this.data = this.data.slice(remaining);
          } else {
            packet = this.data;
            this.data = new Buffer("");
          }
          this.outStreamInfo.written += packet.length;
          if (this.outStreamInfo.limit === this.outStreamInfo.written) {
            this.state = states.START;
            this.outStreamInfo.stream.end(packet, encoding2, cb);
          } else {
            this.outStreamInfo.stream.write(packet, encoding2, cb);
          }
        } else {
          var packet = this.data;
          this.data = new Buffer("");
          this.outStreamInfo.written += packet.length;
          var outputStream = this.outStreamInfo.stream;
          outputStream.write(packet, encoding2, () => {
            if (this.state === states.FILE_DATA_END) {
              this.state = states.START;
              return outputStream.end(cb);
            }
            cb();
          });
        }
        return;
      }
      cb();
    };
    UnzipStream.prototype.drainAll = function() {
      this._drainAllEntries = true;
    };
    UnzipStream.prototype._transform = function(chunk, encoding2, cb) {
      var self = this;
      if (self.data.length > 0) {
        self.data = Buffer.concat([self.data, chunk]);
      } else {
        self.data = chunk;
      }
      var startDataLength = self.data.length;
      var done = function() {
        if (self.data.length > 0 && self.data.length < startDataLength) {
          startDataLength = self.data.length;
          self._parseOrOutput(encoding2, done);
          return;
        }
        cb();
      };
      self._parseOrOutput(encoding2, done);
    };
    UnzipStream.prototype._flush = function(cb) {
      var self = this;
      if (self.data.length > 0) {
        self._parseOrOutput("buffer", function() {
          if (self.data.length > 0)
            return setImmediate(function() {
              self._flush(cb);
            });
          cb();
        });
        return;
      }
      if (self.state === states.FILE_DATA) {
        return cb(new Error("Stream finished in an invalid state, uncompression failed"));
      }
      setImmediate(cb);
    };
    module2.exports = UnzipStream;
  }
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS({
  "node_modules/unzip-stream/lib/parser-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util = require("util");
    var UnzipStream = require_unzip_stream();
    function ParserStream(opts) {
      if (!(this instanceof ParserStream)) {
        return new ParserStream(opts);
      }
      var transformOpts = opts || {};
      Transform2.call(this, { readableObjectMode: true });
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      var self = this;
      this.unzipStream.on("entry", function(entry) {
        self.push(entry);
      });
      this.unzipStream.on("error", function(error) {
        self.emit("error", error);
      });
    }
    util.inherits(ParserStream, Transform2);
    ParserStream.prototype._transform = function(chunk, encoding2, cb) {
      this.unzipStream.write(chunk, encoding2, cb);
    };
    ParserStream.prototype._flush = function(cb) {
      var self = this;
      this.unzipStream.end(function() {
        process.nextTick(function() {
          self.emit("close");
        });
        cb();
      });
    };
    ParserStream.prototype.on = function(eventName, fn) {
      if (eventName === "entry") {
        return Transform2.prototype.on.call(this, "data", fn);
      }
      return Transform2.prototype.on.call(this, eventName, fn);
    };
    ParserStream.prototype.drainAll = function() {
      this.unzipStream.drainAll();
      return this.pipe(new Transform2({ objectMode: true, transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = ParserStream;
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp2 = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    var path2 = require("path");
    var fs2 = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs2;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path2.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path2.dirname(p) === p)
              return cb(er);
            mkdirP(path2.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs2;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path2.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path2.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS({
  "node_modules/unzip-stream/lib/extract.js"(exports2, module2) {
    var fs2 = require("fs");
    var path2 = require("path");
    var util = require("util");
    var mkdirp = require_mkdirp2();
    var Transform2 = require("stream").Transform;
    var UnzipStream = require_unzip_stream();
    function Extract(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Transform2.call(this);
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      this.unfinishedEntries = 0;
      this.afterFlushWait = false;
      this.createdDirectories = {};
      var self = this;
      this.unzipStream.on("entry", this._processEntry.bind(this));
      this.unzipStream.on("error", function(error) {
        self.emit("error", error);
      });
    }
    util.inherits(Extract, Transform2);
    Extract.prototype._transform = function(chunk, encoding2, cb) {
      this.unzipStream.write(chunk, encoding2, cb);
    };
    Extract.prototype._flush = function(cb) {
      var self = this;
      var allDone = function() {
        process.nextTick(function() {
          self.emit("close");
        });
        cb();
      };
      this.unzipStream.end(function() {
        if (self.unfinishedEntries > 0) {
          self.afterFlushWait = true;
          return self.on("await-finished", allDone);
        }
        allDone();
      });
    };
    Extract.prototype._processEntry = function(entry) {
      var self = this;
      var destPath = path2.join(this.opts.path, entry.path);
      var directory = entry.isDirectory ? destPath : path2.dirname(destPath);
      this.unfinishedEntries++;
      var writeFileFn = function() {
        var pipedStream = fs2.createWriteStream(destPath);
        pipedStream.on("close", function() {
          self.unfinishedEntries--;
          self._notifyAwaiter();
        });
        pipedStream.on("error", function(error) {
          self.emit("error", error);
        });
        entry.pipe(pipedStream);
      };
      if (this.createdDirectories[directory] || directory === ".") {
        return writeFileFn();
      }
      mkdirp(directory, function(err) {
        if (err)
          return self.emit("error", err);
        self.createdDirectories[directory] = true;
        if (entry.isDirectory) {
          self.unfinishedEntries--;
          self._notifyAwaiter();
          return;
        }
        writeFileFn();
      });
    };
    Extract.prototype._notifyAwaiter = function() {
      if (this.afterFlushWait && this.unfinishedEntries === 0) {
        this.emit("await-finished");
        this.afterFlushWait = false;
      }
    };
    module2.exports = Extract;
  }
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS({
  "node_modules/unzip-stream/unzip.js"(exports2) {
    "use strict";
    exports2.Parse = require_parser_stream();
    exports2.Extract = require_extract2();
  }
});

// src/model/download.ts
function getEtag(headers) {
  let header = headers["etag"];
  if (typeof header !== "string")
    return void 0;
  header = header.replace(/^W\//, "");
  if (!header.startsWith('"') || !header.endsWith('"'))
    return void 0;
  return header.slice(1, -1);
}
function getExtname(dispositionHeader) {
  const contentDisposition = require_content_disposition();
  let disposition = contentDisposition.parse(dispositionHeader);
  let filename = disposition.parameters.filename;
  if (filename)
    return path.extname(filename);
  return void 0;
}
function download(urlInput, options2, token) {
  let url = toURL(urlInput);
  let { etagAlgorithm } = options2;
  let { dest, onProgress, extract } = options2;
  if (!dest || !path.isAbsolute(dest)) {
    throw new Error(`Expect absolute file path for dest option.`);
  }
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  } else {
    let stat = fs.statSync(dest);
    if (stat && !stat.isDirectory()) {
      throw new Error(`${dest} exists, but not directory!`);
    }
  }
  let mod = getRequestModule(url);
  let opts = resolveRequestOptions(url, options2);
  if (!opts.agent && options2.agent)
    opts.agent = options2.agent;
  let extname = path.extname(url.pathname);
  let finished = false;
  return new Promise((resolve, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    let timer;
    const req = mod.request(opts, (res) => {
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers;
        let dispositionHeader = headers["content-disposition"];
        let etag = getEtag(headers);
        let checkEtag = etag && typeof etagAlgorithm === "string";
        if (!extname && dispositionHeader) {
          extname = getExtname(dispositionHeader);
        }
        if (extract === true) {
          if (extname === ".zip" || headers["content-type"] == "application/zip") {
            extract = "unzip";
          } else if (extname == ".tgz") {
            extract = "untar";
          } else {
            reject(new Error(`Unable to detect extract method for ${url}`));
            return;
          }
        }
        let total = Number(headers["content-length"]);
        let hasTotal = !isNaN(total);
        let cur = 0;
        res.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
        let hash = checkEtag ? crypto.createHash(etagAlgorithm) : void 0;
        res.on("data", (chunk) => {
          cur += chunk.length;
          if (hash)
            hash.update(chunk);
          if (hasTotal) {
            let percent = (cur / total * 100).toFixed(1);
            typeof onProgress === "function" ? onProgress(percent) : logger25.info(`Download ${url} progress ${percent}%`);
          }
        });
        res.on("end", () => {
          clearTimeout(timer);
          timer = void 0;
          logger25.info("Download completed:", url);
        });
        let stream;
        if (extract === "untar") {
          const tar = require_tar();
          stream = res.pipe(tar.x({ strip: options2.strip ?? 1, C: dest }));
        } else if (extract === "unzip") {
          const unzip = require_unzip();
          stream = res.pipe(unzip.Extract({ path: dest }));
        } else {
          dest = path.join(dest, `${v1_default()}${extname}`);
          stream = res.pipe(fs.createWriteStream(dest));
        }
        stream.on("finish", () => {
          if (hash) {
            if (hash.digest("hex") !== etag) {
              reject(new Error(`Etag check failed by ${etagAlgorithm}, content not match.`));
              return;
            }
          }
          logger25.info(`Downloaded ${url} => ${dest}`);
          setTimeout(() => {
            resolve(dest);
          }, 100);
        });
        stream.on("error", reject);
      } else {
        reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", (e) => {
      if (opts.agent && e["code"] == "ECONNRESET") {
        timer = setTimeout(() => {
          finished = true;
          reject(e);
        }, timeout);
      } else {
        clearTimeout(timer);
        if (opts.agent && opts.agent.proxy) {
          reject(new Error(`Request failed using proxy ${opts.agent.proxy.host}: ${e.message}`));
          return;
        }
        finished = true;
        reject(e);
      }
    });
    req.on("timeout", () => {
      req.destroy(new Error(`request timeout after ${options2.timeout}ms`));
    });
    if (typeof options2.timeout === "number" && options2.timeout) {
      req.setTimeout(options2.timeout);
    }
    req.end();
  });
}
var logger25;
var init_download = __esm({
  "src/model/download.ts"() {
    "use strict";
    init_esm_node();
    init_logger();
    init_node();
    init_fetch();
    logger25 = createLogger("model-download");
  }
});

// src/extension/installer.ts
function registryUrl(home = os.homedir()) {
  let res;
  let filepath = path.join(home, ".npmrc");
  if (fs.existsSync(filepath)) {
    try {
      let content = fs.readFileSync(filepath, "utf8");
      let uri;
      for (let line of content.split(/\r?\n/)) {
        if (line.startsWith("#"))
          continue;
        let ms = line.match(/^(.*?)=(.*)$/);
        if (ms && ms[1] === "coc.nvim:registry") {
          uri = ms[2];
        }
      }
      if (uri)
        res = new import_url3.URL(uri);
    } catch (e) {
      logger26.debug("Error on parse .npmrc:", e);
    }
  }
  return res ?? new import_url3.URL("https://registry.npmjs.org");
}
function isNpmCommand(exePath) {
  let name2 = path.basename(exePath);
  return name2 === "npm" || name2 === "npm.CMD";
}
function isYarn(exePath) {
  let name2 = path.basename(exePath);
  return ["yarn", "yarn.CMD", "yarnpkg", "yarnpkg.CMD"].includes(name2);
}
function isPnpm(exePath) {
  let name2 = path.basename(exePath);
  return name2 === "pnpm" || name2 === "pnpm.CMD";
}
function isSymbolicLink(folder) {
  if (fs.existsSync(folder)) {
    let stat = fs.lstatSync(folder);
    if (stat.isSymbolicLink()) {
      return true;
    }
  }
  return false;
}
function getDependencies(obj) {
  return Object.keys(obj.dependencies ?? {}).filter((id) => !local_dependencies.includes(id));
}
var import_events29, import_url3, logger26, local_dependencies, Installer;
var init_installer = __esm({
  "src/extension/installer.ts"() {
    "use strict";
    import_events29 = require("events");
    import_url3 = require("url");
    init_esm_node();
    init_logger();
    init_download();
    init_fetch();
    init_fs();
    init_node();
    init_string();
    init_workspace();
    logger26 = createLogger("extension-installer");
    local_dependencies = ["coc.nvim", "esbuild", "webpack", "@types/node"];
    Installer = class extends import_events29.EventEmitter {
      constructor(root, npm, def) {
        super();
        this.root = root;
        this.npm = npm;
        this.def = def;
        if (/^https?:/.test(def)) {
          this.url = def;
        } else {
          let ms = def.match(/(.+)@([^/]+)$/);
          if (ms) {
            this.name = ms[1];
            this.version = ms[2];
          } else {
            this.name = def;
          }
        }
      }
      get info() {
        return { name: this.name, version: this.version };
      }
      async getInfo() {
        if (this.url)
          return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let buffer = await this.fetch(new import_url3.URL(this.name, registry), { timeout: 1e4, buffer: true });
        let res = JSON.parse(buffer.toString());
        if (!this.version)
          this.version = res["dist-tags"]["latest"];
        let obj = res["versions"][this.version];
        if (!obj)
          throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj["engines"] && obj["engines"]["coc"];
        if (!requiredVersion)
          throw new Error(`${this.def} is not a valid coc extension, "engines" field with coc property required.`);
        return {
          "dist.tarball": obj["dist"]["tarball"],
          "engines.coc": requiredVersion,
          version: obj["version"],
          name: res.name
        };
      }
      async getInfoFromUri() {
        let { url } = this;
        if (!url.startsWith("https://github.com")) {
          throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, "");
        let branch = "master";
        if (url.includes("@")) {
          let idx = url.indexOf("@");
          branch = url.substr(idx + 1);
          url = url.substring(0, idx);
        }
        let fileUrl = url.replace("github.com", "raw.githubusercontent.com") + `/${branch}/package.json`;
        this.log(`Get info from ${fileUrl}`);
        let content = await this.fetch(fileUrl, { timeout: 1e4 });
        let obj = typeof content == "string" ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
          "dist.tarball": `${url}/archive/${branch}.tar.gz`,
          "engines.coc": obj["engines"] ? obj["engines"]["coc"] : null,
          name: obj.name,
          version: obj.version
        };
      }
      log(msg, isProgress = false) {
        this.emit("message", msg, isProgress);
      }
      async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger26.info(`Fetched info of ${this.def}`, info);
        let { name: name2, version: version2 } = info;
        let required = toText(info["engines.coc"]).replace(/^\^/, ">=");
        if (required && !semver.satisfies(workspace_default.version, required)) {
          throw new Error(`${name2} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        let updated = await this.doInstall(info);
        return { name: name2, updated, version: version2, url: this.url, folder: path.join(this.root, info.name) };
      }
      async update(url) {
        if (url)
          this.url = url;
        let version2;
        if (this.name) {
          let folder = path.join(this.root, this.name);
          if (isSymbolicLink(folder)) {
            this.log(`Skipped update for symbol link`);
            return;
          }
          let obj = loadJson(path.join(folder, "package.json"));
          version2 = obj.version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version2 && info.version && semver.gte(version2, info.version)) {
          this.log(`Current version ${version2} is up to date.`);
          return;
        }
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !semver.satisfies(workspace_default.version, required)) {
          throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        let succeed = await this.doInstall(info);
        if (!succeed)
          return;
        let jsonFile = path.join(this.root, info.name, "package.json");
        this.log(`Updated to v${info.version}`);
        return path.dirname(jsonFile);
      }
      getInstallArguments(exePath, url) {
        let args = ["install", "--ignore-scripts", "--no-lockfile"];
        if (url && url.startsWith("https://github.com")) {
          args = ["install"];
        }
        if (isNpmCommand(exePath)) {
          args.push("--omit=dev");
          args.push("--legacy-peer-deps");
          args.push("--no-global");
        }
        if (isYarn(exePath)) {
          args.push("--production");
          args.push("--ignore-engines");
        }
        if (isPnpm(exePath)) {
          args.push("--production");
          args.push("--config.strict-peer-dependencies=false");
        }
        return args;
      }
      readLines(key, stream) {
        const rl = readline.createInterface({
          input: stream
        });
        rl.on("line", (line) => {
          this.log(`${key} ${line}`, true);
        });
      }
      installDependencies(folder, dependencies) {
        if (dependencies.length == 0)
          return Promise.resolve();
        return new Promise((resolve, reject) => {
          let args = this.getInstallArguments(this.npm, this.url);
          this.log(`Installing dependencies by: ${this.npm} ${args.join(" ")}.`);
          const child = child_process.spawn(this.npm, args, {
            cwd: folder,
            env: Object.assign(process.env, { NODE_ENV: "production" })
          });
          this.readLines("[npm stdout]", child.stdout);
          this.readLines("[npm stderr]", child.stderr);
          child.stderr.setEncoding("utf8");
          child.stdout.setEncoding("utf8");
          child.on("error", reject);
          child.on("exit", (code) => {
            if (code) {
              reject(new Error(`${this.npm} install exited with ${code}`));
              return;
            }
            resolve();
          });
        });
      }
      async doInstall(info) {
        let dest = path.join(this.root, info.name);
        if (isSymbolicLink(dest))
          return false;
        let key = info.name.replace(/\//g, "_");
        let downloadFolder = path.join(this.root, `${key}-${v4_default()}`);
        let url = info["dist.tarball"];
        this.log(`Downloading from ${url}`);
        let etagAlgorithm = url.startsWith("https://registry.npmjs.org") ? "md5" : void 0;
        try {
          await this.download(url, {
            dest: downloadFolder,
            etagAlgorithm,
            extract: "untar",
            onProgress: (p) => this.log(`Download progress ${p}%`, true)
          });
          this.log(`Extension download at ${downloadFolder}`);
          let obj = loadJson(path.join(downloadFolder, "package.json"));
          await this.installDependencies(downloadFolder, getDependencies(obj));
        } catch (e) {
          fs.rmSync(downloadFolder, { recursive: true, force: true });
          throw e;
        }
        this.log(`Download extension ${info.name}@${info.version} at ${downloadFolder}`);
        fs.mkdirSync(path.dirname(dest), { recursive: true });
        if (fs.existsSync(dest))
          fs.rmSync(dest, { force: true, recursive: true });
        fs.renameSync(downloadFolder, dest);
        this.log(`Move extension ${info.name}@${info.version} to ${dest}`);
        return true;
      }
      async download(url, options2) {
        return await download(url, options2);
      }
      async fetch(url, options2 = {}) {
        return await fetch(url, options2);
      }
    };
  }
});

// src/model/memos.ts
var Memos;
var init_memos = __esm({
  "src/model/memos.ts"() {
    "use strict";
    init_fs();
    init_node();
    init_object();
    Memos = class {
      constructor(filepath) {
        this.filepath = filepath;
        if (!fs.existsSync(filepath)) {
          fs.writeFileSync(filepath, "{}", "utf8");
        }
      }
      merge(filepath) {
        if (!fs.existsSync(filepath))
          return;
        let obj = loadJson(filepath);
        let current = loadJson(this.filepath);
        Object.assign(current, obj);
        writeJson(this.filepath, current);
        fs.unlinkSync(filepath);
      }
      fetchContent(id, key) {
        let res = loadJson(this.filepath);
        let obj = res[id];
        if (!obj)
          return void 0;
        return obj[key];
      }
      async update(id, key, value) {
        let { filepath } = this;
        let current = loadJson(filepath);
        current[id] = current[id] || {};
        if (value !== void 0) {
          current[id][key] = deepClone(value);
        } else {
          delete current[id][key];
        }
        writeJson(filepath, current);
      }
      createMemento(id) {
        return {
          get: (key, defaultValue2) => {
            let res = this.fetchContent(id, key);
            return res === void 0 ? defaultValue2 : res;
          },
          update: async (key, value) => {
            await this.update(id, key, value);
          }
        };
      }
    };
  }
});

// src/list/commandTask.ts
var import_events30, spawn, logger27, CommandTask;
var init_commandTask = __esm({
  "src/list/commandTask.ts"() {
    "use strict";
    import_events30 = require("events");
    init_logger();
    init_util();
    init_node();
    init_workspace();
    spawn = child_process.spawn;
    logger27 = createLogger("list-commandTask");
    CommandTask = class extends import_events30.EventEmitter {
      constructor(opt) {
        super();
        this.opt = opt;
        this.disposables = [];
        this.start();
      }
      start() {
        let { cmd, args, cwd: cwd2, onLine } = this.opt;
        let proc = spawn(cmd, args, { cwd: cwd2 || workspace_default.cwd, windowsHide: true });
        this.disposables.push({
          dispose: () => {
            proc.kill();
          }
        });
        proc.on("error", (e) => {
          this.emit("error", e.message);
        });
        proc.stderr.on("data", (chunk) => {
          logger27.error(`[${cmd} Error]`, chunk.toString("utf8"));
        });
        const rl = readline.createInterface(proc.stdout);
        rl.on("line", (line) => {
          let res = onLine(line);
          if (res)
            this.emit("data", res);
        });
        rl.on("close", () => {
          this.emit("end");
        });
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/list/configuration.ts
var validKeys, ListConfiguration, configuration_default;
var init_configuration3 = __esm({
  "src/list/configuration.ts"() {
    "use strict";
    init_window();
    init_workspace();
    validKeys = [
      "<esc>",
      "<space>",
      "<tab>",
      "<s-tab>",
      "<bs>",
      "<right>",
      "<left>",
      "<up>",
      "<down>",
      "<home>",
      "<end>",
      "<cr>",
      "<FocusGained>",
      "<FocusLost>",
      "<ScrollWheelUp>",
      "<ScrollWheelDown>",
      "<LeftMouse>",
      "<LeftDrag>",
      "<LeftRelease>",
      "<2-LeftMouse>",
      "<C-a>",
      "<C-b>",
      "<C-c>",
      "<C-d>",
      "<C-e>",
      "<C-f>",
      "<C-g>",
      "<C-h>",
      "<C-i>",
      "<C-j>",
      "<C-k>",
      "<C-l>",
      "<C-m>",
      "<C-n>",
      "<C-o>",
      "<C-p>",
      "<C-q>",
      "<C-r>",
      "<C-s>",
      "<C-t>",
      "<C-u>",
      "<C-v>",
      "<C-w>",
      "<C-x>",
      "<C-y>",
      "<C-z>",
      "<A-a>",
      "<A-b>",
      "<A-c>",
      "<A-d>",
      "<A-e>",
      "<A-f>",
      "<A-g>",
      "<A-h>",
      "<A-i>",
      "<A-j>",
      "<A-k>",
      "<A-l>",
      "<A-m>",
      "<A-n>",
      "<A-o>",
      "<A-p>",
      "<A-q>",
      "<A-r>",
      "<A-s>",
      "<A-t>",
      "<A-u>",
      "<A-v>",
      "<A-w>",
      "<A-x>",
      "<A-y>",
      "<A-z>"
    ];
    ListConfiguration = class {
      get debounceTime() {
        return this.get("interactiveDebounceTime", 100);
      }
      get extendedSearchMode() {
        return this.get("extendedSearchMode", true);
      }
      get smartcase() {
        return this.get("smartCase", false);
      }
      get signOffset() {
        return this.get("signOffset", 900);
      }
      get(key, defaultValue2) {
        let configuration2 = workspace_default.initialConfiguration;
        return configuration2.get("list." + key, defaultValue2);
      }
      get previousKey() {
        return this.fixKey(this.get("previousKeymap", "<C-j>"));
      }
      get nextKey() {
        return this.fixKey(this.get("nextKeymap", "<C-k>"));
      }
      fixKey(key) {
        if (validKeys.includes(key))
          return key;
        let find = validKeys.find((s) => s.toLowerCase() == key.toLowerCase());
        if (find)
          return find;
        void window_default.showErrorMessage(`Configured key "${key}" not supported.`);
        return null;
      }
    };
    configuration_default = new ListConfiguration();
  }
});

// src/list/basic.ts
function toVimFiletype(filetype) {
  switch (filetype) {
    case "latex":
      return "tex";
    default:
      return filetype;
  }
}
var BasicList;
var init_basic = __esm({
  "src/list/basic.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_util();
    init_fs();
    init_position();
    init_string();
    init_workspace();
    init_commandTask();
    init_configuration3();
    BasicList = class {
      constructor() {
        this.defaultAction = "open";
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.nvim = workspace_default.nvim;
        this.config = configuration_default;
      }
      get alignColumns() {
        return configuration_default.get("alignColumns", false);
      }
      get floatPreview() {
        return configuration_default.get("floatPreview", false);
      }
      get hlGroup() {
        return configuration_default.get("previewHighlightGroup", "Search");
      }
      get previewHeight() {
        return configuration_default.get("maxPreviewHeight", 12);
      }
      get splitRight() {
        return configuration_default.get("previewSplitRight", false);
      }
      get toplineStyle() {
        return configuration_default.get("previewToplineStyle", "offset");
      }
      get toplineOffset() {
        return configuration_default.get("previewToplineOffset", 3);
      }
      parseArguments(args) {
        if (!this.optionMap) {
          this.optionMap = /* @__PURE__ */ new Map();
          for (let opt of this.options) {
            let parts = opt.name.split(/,\s*/g).map((s) => s.replace(/\s+.*/g, ""));
            let name2 = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, "");
            for (let p of parts) {
              this.optionMap.set(p, { name: name2, hasValue: opt.hasValue });
            }
          }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
          let arg = args[i];
          let def = this.optionMap.get(arg);
          if (!def)
            continue;
          let value = true;
          if (def.hasValue) {
            value = toText(args[i + 1]);
            i = i + 1;
          }
          res[def.name] = value;
        }
        return res;
      }
      getConfig() {
        return workspace_default.getConfiguration(`list.source.${this.name}`);
      }
      addAction(name2, fn, options2) {
        this.createAction(Object.assign({
          name: name2,
          execute: fn
        }, options2 || {}));
      }
      addMultipleAction(name2, fn, options2) {
        this.createAction(Object.assign({
          name: name2,
          multiple: true,
          execute: fn
        }, options2 || {}));
      }
      createCommandTask(opt) {
        return new CommandTask(opt);
      }
      addLocationActions() {
        this.createAction({
          name: "preview",
          execute: async (item, context) => {
            let loc = await this.convertLocation(item.location);
            await this.previewLocation(loc, context);
          }
        });
        let { nvim } = this;
        this.createAction({
          name: "quickfix",
          multiple: true,
          execute: async (items) => {
            let quickfixItems = await Promise.all(items.map((item) => this.convertLocation(item.location).then((loc) => workspace_default.getQuickfixItem(loc))));
            await nvim.call("setqflist", [quickfixItems]);
            let openCommand = await nvim.getVar("coc_quickfix_open_command");
            nvim.command(typeof openCommand === "string" ? openCommand : "copen", true);
          }
        });
        for (let name2 of ["open", "tabe", "drop", "vsplit", "split"]) {
          this.createAction({
            name: name2,
            execute: async (item, context) => {
              await this.jumpTo(item.location, name2 == "open" ? null : name2, context);
            },
            tabPersist: name2 === "open"
          });
        }
      }
      async convertLocation(location) {
        if (typeof location == "string")
          return Location.create(location, Range.create(0, 0, 0, 0));
        if (Location.is(location))
          return location;
        let u = URI.parse(location.uri);
        if (u.scheme != "file")
          return Location.create(location.uri, Range.create(0, 0, 0, 0));
        return await lineToLocation(u.fsPath, location.line, location.text);
      }
      async jumpTo(location, command, context) {
        if (command == null && context && context.options.position === "tab") {
          command = "tabe";
        }
        if (typeof location == "string") {
          await workspace_default.jumpTo(location, null, command);
          return;
        }
        let { range, uri } = await this.convertLocation(location);
        let position = range.start;
        if (position.line == 0 && position.character == 0 && comparePosition(position, range.end) == 0) {
          position = null;
        }
        await workspace_default.jumpTo(uri, position, command);
      }
      createAction(action) {
        let { name: name2 } = action;
        let idx = this.actions.findIndex((o) => o.name == name2);
        if (idx !== -1)
          this.actions.splice(idx, 1);
        this.actions.push(action);
      }
      async previewLocation(location, context) {
        let { uri, range } = location;
        let doc = workspace_default.getDocument(location.uri);
        let u = URI.parse(uri);
        let lines = await workspace_default.documentsManager.getLines(uri);
        let config = {
          bufnr: doc ? doc.bufnr : void 0,
          winid: context.window.id,
          range: emptyRange(range) ? null : range,
          lnum: range.start.line + 1,
          name: u.scheme == "file" ? u.fsPath : uri,
          filetype: toVimFiletype(doc ? doc.languageId : workspace_default.documentsManager.getLanguageId(u.fsPath)),
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          scheme: u.scheme,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset,
          targetRange: location.targetRange
        };
        await this.openPreview(lines, config);
      }
      async preview(options2, context) {
        let { bufname, filetype, range, lines, lnum } = options2;
        let config = {
          winid: context.window.id,
          lnum: range ? range.start.line + 1 : lnum || 1,
          filetype,
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset
        };
        if (bufname)
          config.name = bufname;
        if (range)
          config.range = range;
        await this.openPreview(lines, config);
      }
      async openPreview(lines, config) {
        let { nvim } = this;
        if (this.floatPreview && config.position !== "tab") {
          await nvim.call("coc#list#float_preview", [lines, config]);
        } else {
          await nvim.call("coc#list#preview", [lines, config]);
        }
        nvim.command("redraw", true);
      }
      doHighlight() {
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/fuzzy.ts
function getCharCodes(str) {
  let len = str.length;
  let res = new Uint16Array(len);
  for (let i = 0, l = len; i < l; i++) {
    res[i] = str.charCodeAt(i);
  }
  return res;
}
function caseMatch(input, code, ignorecase = false) {
  if (input === code)
    return true;
  if (code < ASCII_END) {
    if (input >= 97 && input <= 122 && code + 32 === input)
      return true;
    if (ignorecase) {
      if (input <= 90 && input + 32 === code)
        return true;
      if (toLower(input) === code)
        return true;
    }
  } else {
    let lower = toLower(code);
    if (lower === input || ignorecase && toLower(input) === lower)
      return true;
  }
  return false;
}
function toLower(code) {
  return String.fromCharCode(code).toLowerCase().charCodeAt(0);
}
function fuzzyMatch(needle, text, ignorecase = false) {
  let totalCount = needle.length;
  let tl = text.length;
  if (totalCount > tl)
    return false;
  let i = 0;
  let curr = needle[0];
  for (let j = 0; j < tl; j++) {
    let code = text.charCodeAt(j);
    if (caseMatch(curr, code, ignorecase)) {
      i = i + 1;
      curr = needle[i];
      if (i === totalCount)
        return true;
      continue;
    }
    if (tl - j - 1 < totalCount - i) {
      break;
    }
  }
  return false;
}
var init_fuzzy = __esm({
  "src/util/fuzzy.ts"() {
    "use strict";
    init_constants();
  }
});

// src/list/db.ts
var logger28, DB_PATH, DataBase, db_default;
var init_db2 = __esm({
  "src/list/db.ts"() {
    "use strict";
    init_node();
    init_logger();
    init_string();
    init_constants();
    logger28 = createLogger("list-db");
    DB_PATH = path.join(dataHome, "list_history.dat");
    DataBase = class {
      constructor() {
        this.folders = [];
        this.names = [];
        this.items = [];
        this._changed = false;
        try {
          this.load();
        } catch (e) {
          logger28.error(`Error on load db`, e);
        }
      }
      get currItems() {
        return this.items;
      }
      getHistory(name2, folder) {
        let nameIndex = this.names.indexOf(name2);
        let folderIndex = this.folders.indexOf(folder);
        if (nameIndex == -1 || folderIndex == -1)
          return [];
        return this.items.reduce((p, c) => {
          if (c[1] == nameIndex && c[2] == folderIndex) {
            p.push(c[0]);
          }
          return p;
        }, []);
      }
      addItem(name2, text, folder) {
        let { folders, names } = this;
        if (byteLength(text) > 255) {
          text = byteSlice(text, 0, 255);
        }
        if (!folders.includes(folder)) {
          folders.push(folder);
        }
        if (!names.includes(name2)) {
          names.push(name2);
        }
        let nameIndex = names.indexOf(name2);
        let folderIndex = folders.indexOf(folder);
        let idx = this.items.findIndex((o) => o[0] == text && o[1] == nameIndex && o[2] == folderIndex);
        if (idx != -1)
          this.items.splice(idx, 1);
        this.items.push([text, nameIndex, folderIndex]);
        this._changed = true;
      }
      save() {
        let { folders, items, names } = this;
        if (!this._changed)
          return;
        let bufs = folders.reduce((p, folder) => {
          p.push(Buffer.from(folder, "utf8"), Buffer.alloc(1));
          return p;
        }, []);
        let folderBuf = Buffer.concat(bufs);
        bufs = names.reduce((p, name2) => {
          p.push(Buffer.from(name2, "utf8"), Buffer.alloc(1));
          return p;
        }, []);
        let nameBuf = Buffer.concat(bufs);
        let buf = Buffer.allocUnsafe(9);
        buf.writeUInt8(2, 0);
        buf.writeUInt32BE(folderBuf.byteLength, 1);
        buf.writeUInt32BE(nameBuf.byteLength, 5);
        bufs = items.reduce((p, item) => {
          let b = Buffer.from(item[0], "utf8");
          p.push(Buffer.from([b.byteLength]), b, Buffer.from([item[1], item[2]]));
          return p;
        }, []);
        let resultBuf = Buffer.concat([buf, folderBuf, nameBuf, ...bufs]);
        fs.writeFileSync(DB_PATH, resultBuf);
        this._changed = false;
      }
      load() {
        if (!fs.existsSync(DB_PATH))
          return;
        let buffer = fs.readFileSync(DB_PATH);
        let folder_length = buffer.readUInt32BE(1);
        let name_length = buffer.readUInt32BE(5);
        let folderBuf = buffer.slice(9, 9 + folder_length);
        let start = 0;
        let folders = [];
        let names = [];
        for (let i = 0; i < folderBuf.byteLength; i++) {
          if (folderBuf[i] === 0) {
            let text = folderBuf.slice(start, i).toString("utf8");
            folders.push(text);
            start = i + 1;
          }
        }
        let offset = 9 + folder_length;
        let nameBuf = buffer.slice(offset, offset + name_length);
        start = 0;
        for (let i = 0; i < nameBuf.byteLength; i++) {
          if (nameBuf[i] === 0) {
            let text = nameBuf.slice(start, i).toString("utf8");
            names.push(text);
            start = i + 1;
          }
        }
        let itemsBuf = buffer.slice(offset + name_length);
        start = 0;
        let total = itemsBuf.byteLength;
        while (start < total) {
          let len = itemsBuf.readUInt8(start);
          let end = start + 1 + len;
          let text = itemsBuf.slice(start + 1, end).toString("utf8");
          this.items.push([text, itemsBuf.readUInt8(end), itemsBuf.readUInt8(end + 1)]);
          start = end + 2;
        }
        this.names = names;
        this.folders = folders;
      }
    };
    db_default = new DataBase();
  }
});

// src/list/history.ts
var logger29, InputHistory;
var init_history = __esm({
  "src/list/history.ts"() {
    "use strict";
    init_node();
    init_logger();
    init_array();
    init_fuzzy();
    init_db2();
    init_string();
    logger29 = createLogger("list-history");
    InputHistory = class {
      constructor(prompt, name2, db, cwd2) {
        this.prompt = prompt;
        this.name = name2;
        this.db = db;
        this.cwd = cwd2;
        this._index = -1;
        this._filtered = [];
      }
      get loaded() {
        return this.db.getHistory(this.name, this.cwd);
      }
      get filtered() {
        return this._filtered;
      }
      get index() {
        return this._index;
      }
      static migrate(folder) {
        try {
          let files = fs.readdirSync(folder);
          files = files.filter((f) => f.startsWith("list-") && f.endsWith("-history.json") && fs.statSync(path.join(folder, f)).isFile());
          if (files.length === 0)
            return;
          let db = new DataBase();
          for (let file of files) {
            let name2 = file.match(/^list-(.*)-history.json$/)[1];
            let content = fs.readFileSync(path.join(folder, file), "utf8");
            let obj = JSON.parse(content);
            for (let [key, texts] of Object.entries(obj)) {
              let folder2 = Buffer.from(key, "base64").toString("utf8");
              if (Array.isArray(texts)) {
                texts.forEach((text) => {
                  db.addItem(name2, text, folder2);
                });
              }
            }
          }
          files.forEach((f) => {
            fs.unlinkSync(path.join(folder, f));
          });
          db.save();
        } catch (e) {
          logger29.error(`Error on migrate history:`, e);
        }
      }
      get curr() {
        return this._index == -1 || this._filtered == null ? null : this._filtered[this._index];
      }
      filter() {
        let { input } = this.prompt;
        if (input === this.curr)
          return;
        this.historyInput = "";
        if (input.length > 0) {
          let codes = getCharCodes(input);
          this._filtered = this.loaded.filter((s) => fuzzyMatch(codes, s));
        } else {
          this._filtered = this.loaded;
        }
        this._index = -1;
      }
      add() {
        let { db, prompt, cwd: cwd2 } = this;
        let { input } = prompt;
        if (!input || input.length < 2 || input == this.historyInput)
          return;
        db.addItem(this.name, input, cwd2);
      }
      previous() {
        let { _filtered, _index } = this;
        if (isFalsyOrEmpty(_filtered))
          return;
        if (_index <= 0) {
          this._index = _filtered.length - 1;
        } else {
          this._index = _index - 1;
        }
        this.historyInput = this.prompt.input = toText(_filtered[this._index]);
      }
      next() {
        let { _filtered, _index } = this;
        if (isFalsyOrEmpty(_filtered))
          return;
        if (_index == _filtered.length - 1) {
          this._index = 0;
        } else {
          this._index = _index + 1;
        }
        this.historyInput = this.prompt.input = toText(_filtered[this._index]);
      }
    };
  }
});

// src/list/mappings.ts
var Mappings;
var init_mappings = __esm({
  "src/list/mappings.ts"() {
    "use strict";
    init_window();
    init_configuration3();
    Mappings = class {
      constructor(manager, nvim) {
        this.manager = manager;
        this.nvim = nvim;
        this.insertMappings = /* @__PURE__ */ new Map();
        this.normalMappings = /* @__PURE__ */ new Map();
        this.userInsertMappings = /* @__PURE__ */ new Map();
        this.userNormalMappings = /* @__PURE__ */ new Map();
        this.actions = /* @__PURE__ */ new Map();
        let { prompt } = manager;
        this.addAction("do:switch", async () => {
          await manager.switchMatcher();
        });
        this.addAction("do:selectall", async () => {
          var _a2;
          await ((_a2 = manager.session) == null ? void 0 : _a2.ui.selectAll());
        });
        this.addAction("do:help", async () => {
          var _a2;
          await ((_a2 = manager.session) == null ? void 0 : _a2.showHelp());
        });
        this.addAction("do:refresh", async () => {
          var _a2;
          await ((_a2 = manager.session) == null ? void 0 : _a2.reloadItems());
        });
        this.addAction("do:exit", async () => {
          await manager.cancel();
        });
        this.addAction("do:stop", () => {
          manager.stop();
        });
        this.addAction("do:cancel", async () => {
          await manager.cancel(false);
        });
        this.addAction("do:toggle", async () => {
          var _a2;
          await ((_a2 = manager.session) == null ? void 0 : _a2.ui.toggleSelection());
        });
        this.addAction("do:jumpback", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.jumpBack();
        });
        this.addAction("do:previous", async () => {
          await this.navigate(true);
        });
        this.addAction("do:next", async () => {
          await this.navigate(false);
        });
        this.addAction("do:defaultaction", async () => {
          await manager.doAction();
        });
        this.addAction("do:chooseaction", async () => {
          await manager.chooseAction();
        });
        this.addAction("do:togglemode", () => {
          manager.toggleMode();
        });
        this.addAction("do:previewtoggle", async () => {
          await manager.togglePreview();
        });
        this.addAction("do:previewup", () => {
          this.scrollPreview("up");
        });
        this.addAction("do:previewdown", () => {
          this.scrollPreview("down");
        });
        this.addAction("do:command", async () => {
          await manager.cancel(false);
          await nvim.eval('feedkeys(":")');
        });
        this.addAction("prompt:previous", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.history.previous();
        });
        this.addAction("prompt:next", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.history.next();
        });
        this.addAction("prompt:start", () => {
          prompt.moveToStart();
        });
        this.addAction("prompt:end", () => {
          prompt.moveToEnd();
        });
        this.addAction("prompt:left", () => {
          prompt.moveLeft();
        });
        this.addAction("prompt:right", () => {
          prompt.moveRight();
        });
        this.addAction("prompt:deleteforward", () => {
          prompt.onBackspace();
        });
        this.addAction("prompt:deletebackward", () => {
          prompt.removeNext();
        });
        this.addAction("prompt:removetail", () => {
          prompt.removeTail();
        });
        this.addAction("prompt:removeahead", () => {
          prompt.removeAhead();
        });
        this.addAction("prompt:removeword", () => {
          prompt.removeWord();
        });
        this.addAction("prompt:insertregister", () => {
          prompt.insertRegister();
        });
        this.addAction("prompt:paste", async () => {
          await prompt.paste();
        });
        this.addAction("eval", async (expr) => {
          await prompt.eval(expr);
        });
        this.addAction("command", async (expr) => {
          await manager.command(expr);
        });
        this.addAction("action", async (expr) => {
          await manager.doAction(expr);
        });
        this.addAction("feedkeys", async (expr) => {
          await manager.feedkeys(expr);
        });
        this.addAction("feedkeys!", async (expr) => {
          await manager.feedkeys(expr, false);
        });
        this.addAction("normal", async (expr) => {
          await manager.normal(expr, false);
        });
        this.addAction("normal!", async (expr) => {
          await manager.normal(expr, true);
        });
        this.addAction("call", async (expr) => {
          await manager.call(expr);
        });
        this.addAction("expr", async (expr) => {
          let name2 = await manager.call(expr);
          if (name2)
            await manager.doAction(name2);
        });
        this.addKeyMapping("insert", "<C-s>", "do:switch");
        this.addKeyMapping("insert", "<C-n>", "prompt:next");
        this.addKeyMapping("insert", "<C-p>", "prompt:previous");
        this.addKeyMapping("insert", "<C-v>", "prompt:paste");
        this.addKeyMapping("insert", ["<C-m>", "<cr>"], "do:defaultaction");
        this.addKeyMapping("insert", ["<tab>", "<C-i>", "	"], "do:chooseaction");
        this.addKeyMapping("insert", "<C-o>", "do:togglemode");
        this.addKeyMapping("insert", "<C-c>", "do:stop");
        this.addKeyMapping("insert", "<C-l>", "do:refresh");
        this.addKeyMapping("insert", "<left>", "prompt:left");
        this.addKeyMapping("insert", "<right>", "prompt:right");
        this.addKeyMapping("insert", ["<end>", "<C-e>"], "prompt:end");
        this.addKeyMapping("insert", ["<home>", "<C-a>"], "prompt:start");
        this.addKeyMapping("insert", ["<C-h>", "<bs>", "<backspace>"], "prompt:deleteforward");
        this.addKeyMapping("insert", "<C-w>", "prompt:removeword");
        this.addKeyMapping("insert", "<C-u>", "prompt:removeahead");
        this.addKeyMapping("insert", "<C-r>", "prompt:insertregister");
        this.addKeyMapping("normal", "t", "action:tabe");
        this.addKeyMapping("normal", "s", "action:split");
        this.addKeyMapping("normal", "d", "action:drop");
        this.addKeyMapping("normal", ["<cr>", "<C-m>", "\r"], "do:defaultaction");
        this.addKeyMapping("normal", "<C-a>", "do:selectall");
        this.addKeyMapping("normal", " ", "do:toggle");
        this.addKeyMapping("normal", "p", "do:previewtoggle");
        this.addKeyMapping("normal", ["<tab>", "	", "<C-i>"], "do:chooseaction");
        this.addKeyMapping("normal", "<C-c>", "do:stop");
        this.addKeyMapping("normal", "<C-l>", "do:refresh");
        this.addKeyMapping("normal", "<C-o>", "do:jumpback");
        this.addKeyMapping("normal", "<C-e>", "do:previewdown");
        this.addKeyMapping("normal", "<C-y>", "do:previewup");
        this.addKeyMapping("normal", ["i", "I", "o", "O", "a", "A"], "do:togglemode");
        this.addKeyMapping("normal", "?", "do:help");
        this.addKeyMapping("normal", ":", "do:command");
        this.createMappings();
      }
      createMappings() {
        let insertMappings = configuration_default.get("insertMappings", {});
        this.userInsertMappings = this.fixUserMappings(insertMappings, "list.insertMappings");
        let normalMappings = configuration_default.get("normalMappings", {});
        this.userNormalMappings = this.fixUserMappings(normalMappings, "list.normalMappings");
      }
      hasUserMapping(mode, key) {
        let map = mode == "insert" ? this.userInsertMappings : this.userNormalMappings;
        return map.has(key);
      }
      isValidAction(action) {
        if (this.actions.has(action))
          return true;
        let [key, expr] = action.split(":", 2);
        if (!expr || !this.actions.has(key))
          return false;
        return true;
      }
      fixUserMappings(mappings, entry) {
        let res = /* @__PURE__ */ new Map();
        for (let [key, value] of Object.entries(mappings)) {
          if (!this.isValidAction(value)) {
            void window_default.showWarningMessage(`Invalid configuration - unable to support action "${value}" in "${entry}"`);
            continue;
          }
          if (key.length == 1) {
            res.set(key, value);
          } else if (key.startsWith("<") && key.endsWith(">")) {
            if (key.toLowerCase() == "<space>") {
              res.set(" ", value);
            } else if (key.toLowerCase() == "<backspace>") {
              res.set("<bs>", value);
            } else if (validKeys.includes(key)) {
              res.set(key, value);
            } else {
              let find = false;
              for (let i = 0; i < validKeys.length; i++) {
                if (validKeys[i].toLowerCase() == key.toLowerCase()) {
                  find = true;
                  res.set(validKeys[i], value);
                  break;
                }
              }
              if (!find)
                void window_default.showWarningMessage(`Invalid configuration - unable to recognize "${key}" in "${entry}"`);
            }
          } else {
            void window_default.showWarningMessage(`Invalid configuration - unable to recognize key "${key}" in "${entry}"`);
          }
        }
        return res;
      }
      async navigate(up) {
        var _a2;
        let ui = (_a2 = this.manager.session) == null ? void 0 : _a2.ui;
        if (!ui)
          return false;
        await ui.moveCursor(up ? -1 : 1);
        return true;
      }
      async doInsertKeymap(key) {
        if (key === configuration_default.nextKey)
          return await this.navigate(false);
        if (key === configuration_default.previousKey)
          return await this.navigate(true);
        let expr = this.userInsertMappings.get(key);
        if (expr) {
          let fn = this.getAction(expr);
          await Promise.resolve(fn());
          return true;
        }
        if (this.insertMappings.has(key)) {
          let fn = this.insertMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      async doNormalKeymap(key) {
        let expr = this.userNormalMappings.get(key);
        if (expr) {
          let fn = this.getAction(expr);
          await Promise.resolve(fn());
          return true;
        }
        if (this.normalMappings.has(key)) {
          let fn = this.normalMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      addKeyMapping(mode, key, action) {
        let mappings = mode == "insert" ? this.insertMappings : this.normalMappings;
        let fn = this.getAction(action);
        if (Array.isArray(key)) {
          for (let k of key) {
            mappings.set(k, fn);
          }
        } else {
          mappings.set(key, fn);
        }
      }
      addAction(key, fn) {
        this.actions.set(key, fn);
      }
      getAction(action) {
        if (this.actions.has(action))
          return () => {
            return this.doAction(action);
          };
        let [key, expr] = action.split(":", 2);
        if (!expr || !this.actions.has(key))
          throw new Error(`Invalid action ${action}`);
        return () => {
          return this.doAction(key, expr);
        };
      }
      async doAction(key, expr) {
        let fn = this.actions.get(key);
        if (!fn)
          throw new Error(`Action ${key} doesn't exist`);
        await Promise.resolve(fn(expr));
      }
      scrollPreview(dir) {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.call("coc#list#scroll_preview", [dir], true);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/prompt.ts
var Prompt;
var init_prompt = __esm({
  "src/list/prompt.ts"() {
    "use strict";
    init_protocol();
    init_configuration3();
    Prompt = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.cusorIndex = 0;
        this._input = "";
        this._mode = "insert";
        this.interactive = false;
        this.requestInput = false;
        this._onDidChangeInput = new import_node3.Emitter();
        this.onDidChangeInput = this._onDidChangeInput.event;
      }
      get input() {
        return this._input;
      }
      set input(str) {
        if (this._input == str)
          return;
        this.cusorIndex = str.length;
        this._input = str;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      get mode() {
        return this._mode;
      }
      set mode(val) {
        if (val == this._mode)
          return;
        this._mode = val;
        this.drawPrompt();
      }
      set matcher(val) {
        this._matcher = val;
        this.drawPrompt();
      }
      start(opts) {
        if (opts) {
          this.interactive = opts.interactive;
          this.cusorIndex = opts.input.length;
          this._input = opts.input;
          this._mode = opts.mode;
          this._matcher = opts.interactive ? "" : opts.matcher;
        }
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        this.drawPrompt();
      }
      cancel() {
        let { nvim } = this;
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      reset() {
        this._input = "";
        this.cusorIndex = 0;
      }
      drawPrompt() {
        let indicator = configuration_default.get("indicator", ">");
        let { cusorIndex, interactive, input, _matcher } = this;
        let cmds = ['echo ""'];
        if (this.mode == "insert") {
          if (interactive) {
            cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
          } else if (_matcher) {
            cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
          }
          cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
          if (cusorIndex == input.length) {
            cmds.push(`echon '${input.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon ' ' | echohl None`);
          } else {
            let pre = input.slice(0, cusorIndex);
            if (pre)
              cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, "''")}' | echohl None`);
            let post = input.slice(cusorIndex + 1);
            cmds.push(`echon '${post.replace(/'/g, "''")}'`);
          }
        } else {
          cmds.push(`echohl MoreMsg | echo "" | echohl None`);
        }
        cmds.push("redraw");
        let cmd = cmds.join("|");
        this.nvim.command(cmd, true);
      }
      moveLeft() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = this.cusorIndex - 1;
        this.drawPrompt();
      }
      moveRight() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this.cusorIndex + 1;
        this.drawPrompt();
      }
      moveToEnd() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this._input.length;
        this.drawPrompt();
      }
      moveToStart() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = 0;
        this.drawPrompt();
      }
      onBackspace() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this.cusorIndex = cusorIndex - 1;
        this._input = `${pre.slice(0, pre.length - 1)}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeNext() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex + 1);
        this._input = `${pre}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeWord() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        let remain = pre.replace(/[\w$]+([^\w$]+)?$/, "");
        this.cusorIndex = cusorIndex - (pre.length - remain.length);
        this._input = `${remain}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeTail() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length)
          return;
        let pre = input.slice(0, cusorIndex);
        this._input = pre;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeAhead() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let post = input.slice(cusorIndex);
        this.cusorIndex = 0;
        this._input = post;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      async acceptCharacter(ch) {
        if (this.requestInput) {
          this.requestInput = false;
          if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
            let text = await this.nvim.call("getreg", ch);
            text = text.replace(/\n/g, " ");
            this.addText(text);
          }
        } else {
          this.addText(ch);
        }
      }
      insertRegister() {
        this.requestInput = true;
      }
      async paste() {
        let text = await this.nvim.eval("@*");
        text = text.replace(/\n/g, "");
        if (!text)
          return;
        this.addText(text);
      }
      async eval(expression) {
        let text = await this.nvim.call("eval", [expression]);
        text = text.replace(/\n/g, "");
        this.addText(text);
      }
      addText(text) {
        let { cusorIndex, input } = this;
        this.cusorIndex = cusorIndex + text.length;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this._input = `${pre}${text}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
    };
  }
});

// src/util/sequence.ts
var Sequence;
var init_sequence = __esm({
  "src/util/sequence.ts"() {
    "use strict";
    Sequence = class {
      constructor() {
        this._busy = false;
        this._fns = [];
        this._resolves = [];
      }
      run(fn) {
        if (!this._busy) {
          this._busy = true;
          fn().finally(() => {
            this.next();
          });
        } else {
          this._fns.push(fn);
        }
      }
      waitFinish() {
        if (!this._busy)
          return Promise.resolve();
        return new Promise((resolve) => {
          this._resolves.push(resolve);
        });
      }
      next() {
        let fn = this._fns.shift();
        if (!fn) {
          this.finish();
        } else {
          fn().finally(() => {
            this.next();
          });
        }
      }
      finish() {
        this._busy = false;
        let fn;
        while ((fn = this._resolves.pop()) != null) {
          fn();
        }
      }
      cancel() {
        this._fns = [];
        this.finish();
      }
    };
  }
});

// src/list/ui.ts
var debounceTime3, ListUI;
var init_ui2 = __esm({
  "src/list/ui.ts"() {
    "use strict";
    init_events();
    init_util();
    init_array();
    init_node();
    init_protocol();
    init_sequence();
    init_string();
    init_workspace();
    init_configuration3();
    debounceTime3 = getConditionValue(100, 20);
    ListUI = class {
      constructor(nvim, name2, listOptions) {
        this.nvim = nvim;
        this.name = name2;
        this.listOptions = listOptions;
        this.newTab = false;
        this.reversed = false;
        this.currIndex = 0;
        this.items = [];
        this.disposables = [];
        this.selected = /* @__PURE__ */ new Set();
        this.sequence = new Sequence();
        this._onDidChangeLine = new import_node3.Emitter();
        this._onDidOpen = new import_node3.Emitter();
        this._onDidClose = new import_node3.Emitter();
        this._onDidLineChange = new import_node3.Emitter();
        this._onDoubleClick = new import_node3.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.newTab = listOptions.position == "tab";
        this.reversed = listOptions.reverse === true;
        events_default.on("BufWinLeave", async (bufnr) => {
          if (bufnr != this.bufnr || this.window == null)
            return;
          this.window = null;
          this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_default.on("CursorMoved", async (bufnr, cursor) => {
          if (bufnr != this.bufnr)
            return;
          let idx = this.lnumToIndex(cursor[0]);
          this.onLineChange(idx);
        }, null, this.disposables);
        let debounced = debounce(async (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
          if (end < 300 || winid != this.winid)
            return;
          let h = end - start + 1;
          let s = this.lnumToIndex(start);
          let e = this.lnumToIndex(start + h * 2);
          nvim.pauseNotification();
          this.doHighlight(s, e);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }, debounceTime3);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        events_default.on("CursorMoved", debounced, null, this.disposables);
      }
      onDidChangeItems(ev) {
        if (!ev.append)
          this.clearSelection();
        this.sequence.run(async () => {
          let { items, reload, append, finished, sorted } = ev;
          if (this.shouldSort && !sorted) {
            items = append ? this.items.concat(items) : items;
            reload = append == true;
            append = false;
            items.sort((a, b) => {
              if (a.score != b.score)
                return b.score - a.score;
              if (a.sortText > b.sortText)
                return 1;
              return -1;
            });
          }
          if (append) {
            await this.appendItems(items);
          } else {
            await this.drawItems(items, finished, reload);
          }
        });
      }
      lnumToIndex(lnum) {
        let { reversed, length } = this;
        if (!reversed)
          return lnum - 1;
        return Math.max(0, length - lnum);
      }
      indexToLnum(index) {
        let { reversed, length } = this;
        if (!reversed)
          return Math.min(index + 1, length);
        return Math.max(Math.min(length, length - index), 1);
      }
      get bufnr() {
        var _a2;
        return (_a2 = this.buffer) == null ? void 0 : _a2.id;
      }
      get winid() {
        var _a2;
        return (_a2 = this.window) == null ? void 0 : _a2.id;
      }
      get limitLines() {
        return configuration_default.get("limitLines", Infinity);
      }
      onLineChange(index) {
        if (this.currIndex == index)
          return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
      }
      get index() {
        return this.currIndex;
      }
      getItem(index) {
        return this.items[index];
      }
      get item() {
        let { window: window2 } = this;
        if (!window2)
          return Promise.resolve(null);
        return window2.cursor.then((cursor) => {
          this.currIndex = this.lnumToIndex(cursor[0]);
          return this.items[this.currIndex];
        });
      }
      async echoMessage(item) {
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${toText(item.label)}`;
        this.nvim.callTimer("coc#ui#echo_lines", [[msg]], true);
      }
      updateItem(item, index) {
        if (!this.buffer || index >= this.length)
          return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.buffer.setOption("modifiable", true, true);
        nvim.call("setbufline", [this.bufnr, lnum, item.label], true);
        this.doHighlight(index, index + 1);
        this.buffer.setOption("modifiable", false, true);
        nvim.resumeNotification(true, true);
      }
      async getItems() {
        if (this.length == 0 || !this.window)
          return [];
        let mode = await this.nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let res = [];
          for (let i = start; i <= end; i++) {
            let idx = this.lnumToIndex(i);
            let item2 = this.items[idx];
            if (item2)
              res.push(item2);
          }
          return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length)
          return selectedItems;
        let item = await this.item;
        return toArray(item);
      }
      async onMouse(event) {
        let { nvim, window: window2 } = this;
        if (!window2)
          return;
        let [winid, lnum, col] = await nvim.eval(`[v:mouse_winid,v:mouse_lnum,v:mouse_col]`);
        if (event == "mouseDown") {
          this.mouseDown = { winid, lnum, col, current: winid == window2.id };
          return;
        }
        let current = winid == window2.id;
        if (current && event == "doubleClick") {
          this.setCursor(lnum);
          this._onDoubleClick.fire();
        }
        if (current && event == "mouseDrag") {
          if (!this.mouseDown)
            return;
          await this.selectLines(this.mouseDown.lnum, lnum);
        } else if (current && event == "mouseUp") {
          if (!this.mouseDown)
            return;
          if (this.mouseDown.lnum == lnum) {
            this.setCursor(lnum);
            nvim.command("redraw", true);
          } else {
            await this.selectLines(this.mouseDown.lnum, lnum);
          }
        } else if (!current && event == "mouseUp") {
          nvim.pauseNotification();
          nvim.call("win_gotoid", winid, true);
          nvim.call("cursor", [lnum, col], true);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        let { items, selected, nvim } = this;
        await this.drawItems(items, true, true);
        if (!selected.size || !this.buffer)
          return;
        nvim.pauseNotification();
        for (let lnum of selected) {
          this.buffer.placeSign({ lnum, id: configuration_default.signOffset + lnum, name: "CocSelected", group: "coc-list" });
        }
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async toggleSelection() {
        let { nvim, reversed } = this;
        await nvim.call("win_gotoid", [this.winid]);
        let lnum = await nvim.call("line", ".");
        let mode = await nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let reverse = start > end;
          if (reverse)
            [start, end] = [end, start];
          for (let i = start; i <= end; i++) {
            this.toggleLine(i);
          }
          this.setCursor(end);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
          return;
        }
        nvim.pauseNotification();
        this.toggleLine(lnum);
        this.setCursor(reversed ? lnum - 1 : lnum + 1);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      toggleLine(lnum) {
        let { selected, buffer } = this;
        let exists = selected.has(lnum);
        const signOffset2 = configuration_default.signOffset;
        if (!exists) {
          selected.add(lnum);
          buffer.placeSign({ lnum, id: signOffset2 + lnum, name: "CocSelected", group: "coc-list" });
        } else {
          selected.delete(lnum);
          buffer.unplaceSign({ id: signOffset2 + lnum, group: "coc-list" });
        }
      }
      async selectLines(start, end) {
        let { nvim, buffer, length } = this;
        const signOffset2 = configuration_default.signOffset;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse)
          [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
          if (i > length)
            break;
          selected.add(i);
          buffer.placeSign({ lnum: i, id: signOffset2 + i, name: "CocSelected", group: "coc-list" });
        }
        this.setCursor(end);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async selectAll() {
        let { length } = this;
        if (length > 0)
          await this.selectLines(1, length);
      }
      clearSelection() {
        let { selected, buffer } = this;
        if (buffer && selected.size > 0) {
          buffer.unplaceSign({ group: "coc-list" });
          this.selected.clear();
        }
      }
      get ready() {
        if (this.window)
          return Promise.resolve();
        return new Promise((resolve) => {
          let disposable = this.onDidLineChange(() => {
            disposable.dispose();
            resolve();
          });
        });
      }
      getHeight(len, finished) {
        let { listOptions } = this;
        if (typeof listOptions.height === "number")
          return listOptions.height;
        let height = configuration_default.get("height", 10);
        if (finished && !listOptions.interactive && listOptions.input.length == 0) {
          height = Math.min(len, height);
        }
        return Math.max(1, height);
      }
      async drawItems(items, finished, reload = false) {
        const { nvim, name: name2, listOptions } = this;
        this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
        if (!this.window) {
          let height = this.getHeight(items.length, finished);
          let { position, numberSelect } = listOptions;
          let [bufnr, winid, tabnr] = await nvim.call("coc#list#create", [position, height, name2, numberSelect]);
          this.tabnr = tabnr;
          this.height = height;
          this.buffer = nvim.createBuffer(bufnr);
          let win = this.window = nvim.createWindow(winid);
          let statusSegments = configuration_default.get("statusLineSegments");
          if (statusSegments)
            win.setOption("statusline", statusSegments.join(" "), true);
          this._onDidOpen.fire(this.bufnr);
        }
        const lines = [];
        let selectIndex = 0;
        this.items.forEach((item, idx) => {
          lines.push(item.label);
          if (!reload && selectIndex == 0 && item.preselect)
            selectIndex = idx;
        });
        let newIndex = reload ? this.currIndex : selectIndex;
        this.setLines(lines, 0, newIndex);
        this._onDidLineChange.fire();
      }
      async appendItems(items) {
        if (!this.window || items.length === 0)
          return;
        let curr = this.items.length;
        let remain = this.limitLines - curr;
        if (remain > 0) {
          let append = remain < items.length ? items.slice(0, remain) : items;
          this.items = this.items.concat(append);
          this.setLines(append.map((item) => item.label), append.length, this.currIndex);
        }
      }
      get shouldSort() {
        let { matcher, interactive } = this.listOptions;
        if (interactive || matcher !== "fuzzy")
          return false;
        return true;
      }
      setLines(lines, append, index) {
        let { nvim, buffer, window: window2, reversed, newTab } = this;
        if (!buffer || !window2)
          return;
        nvim.pauseNotification();
        if (!append) {
          nvim.call("coc#compat#clear_matches", [window2.id], true);
          if (!lines.length) {
            lines = ["No results, press ? on normal mode to get help."];
            nvim.call("coc#compat#matchaddpos", ["Comment", [[1]], 99, window2.id], true);
          }
        }
        buffer.setOption("modifiable", true, true);
        if (reversed) {
          let replacement = lines.reverse();
          if (append) {
            nvim.call("coc#compat#prepend_lines", [buffer.id, replacement], true);
          } else {
            buffer.setLines(replacement, { start: 0, end: -1, strictIndexing: false }, true);
          }
        } else {
          buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        }
        buffer.setOption("modifiable", false, true);
        if (reversed && !newTab) {
          let maxHeight = configuration_default.get("height", 10);
          nvim.call("coc#window#set_height", [window2.id, Math.max(Math.min(maxHeight, this.length), 1)], true);
        }
        if (index > this.items.length - 1)
          index = 0;
        if (index == 0) {
          if (append == 0) {
            this.doHighlight(0, 299);
          } else {
            let s = this.length - append - 1;
            if (s < 300)
              this.doHighlight(s, Math.min(299, this.length - 1));
          }
        } else {
          let height = newTab ? workspace_default.env.lines : this.height;
          this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
          this.currIndex = index;
          let lnum = this.indexToLnum(index);
          window2.setCursor([lnum, 0], true);
          nvim.call("coc#list#select", [buffer.id, lnum], true);
        }
        if (reversed)
          nvim.command("normal! zb", true);
        nvim.command("redraws", true);
        nvim.resumeNotification(true, true);
      }
      restoreWindow() {
        if (this.newTab)
          return;
        let { winid, height } = this;
        if (winid && height) {
          this.nvim.call("coc#window#set_height", [winid, height], true);
        }
      }
      get length() {
        return this.items.length;
      }
      get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
          let idx = this.lnumToIndex(i);
          if (items[i - 1])
            res.push(items[idx]);
        }
        return res;
      }
      doHighlight(start, end) {
        let { items, reversed, length, buffer } = this;
        const highlightItems = [];
        const iterate = (i) => {
          let lnum = this.indexToLnum(i) - 1;
          let { ansiHighlights } = items[i];
          if (ansiHighlights) {
            for (let hi of ansiHighlights) {
              let { span, hlGroup } = hi;
              highlightItems.push({ hlGroup, lnum, colStart: span[0], colEnd: span[1] });
            }
          }
        };
        if (reversed) {
          for (let i = Math.min(end, length - 1); i >= start; i--) {
            iterate(i);
          }
        } else {
          for (let i = start; i <= Math.min(end, length - 1); i++) {
            iterate(i);
          }
        }
        start = this.indexToLnum(start) - 1;
        end = this.indexToLnum(end) - 1;
        if (start > end) {
          [start, end] = [end, start];
        }
        if (!buffer || highlightItems.length == 0)
          return;
        buffer.updateHighlights("list", highlightItems, { start, end: end + 1, priority: 99 });
      }
      setCursor(lnum, col = 0, index) {
        var _a2;
        let { items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max)
          return;
        index = index == null ? this.lnumToIndex(lnum) : index;
        this.onLineChange(index);
        (_a2 = this.window) == null ? void 0 : _a2.setCursor([lnum, col], true);
        this.nvim.call("coc#list#select", [this.bufnr, lnum], true);
      }
      async setIndex(index) {
        if (index < 0 || index >= this.items.length)
          return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.setCursor(lnum, 0, index);
        nvim.command("redraw", true);
        await nvim.resumeNotification(false);
      }
      async moveCursor(delta) {
        let { index, reversed } = this;
        await this.setIndex(reversed ? index - delta : index + delta);
      }
      async getSelectedRange() {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call("getpos", "'<");
        let [, end] = await nvim.call("getpos", "'>");
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        return [start, end];
      }
      cancel() {
        this.sequence.cancel();
      }
      reset() {
        this.cancel();
        if (this.window) {
          this.window = null;
          this.buffer = null;
          this.tabnr = void 0;
        }
      }
      dispose() {
        disposeAll(this.disposables);
        this.nvim.call("coc#window#close", [defaultValue(this.winid, -1)], true);
        this.reset();
        this.items = [];
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
      }
    };
  }
});

// src/util/async.ts
async function filter(items, isValid, onFilter, token) {
  if (items.length === 0)
    return;
  const timer = new Timer();
  const len = items.length;
  function convertBatch(start) {
    const result = [];
    timer.start();
    for (let i = start; i < len; i++) {
      let item = items[i];
      let res = isValid(item);
      if (res)
        typeof res === "boolean" ? result.push(item) : result.push(Object.assign({}, item, res));
      if (timer.shouldYield()) {
        let done = i === len - 1;
        onFilter(result, done);
        return done ? -1 : i + 1;
      }
    }
    onFilter(result, true);
    return -1;
  }
  let index = convertBatch(0);
  while (index !== -1) {
    if (token != null && token.isCancellationRequested) {
      break;
    }
    index = await new Promise((resolve) => {
      setImmediate(() => {
        resolve(convertBatch(index));
      });
    });
  }
}
var defaultYieldTimeout, Timer;
var init_async = __esm({
  "src/util/async.ts"() {
    "use strict";
    defaultYieldTimeout = 15;
    Timer = class {
      constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
      }
      start() {
        this.startTime = Date.now();
      }
      shouldYield() {
        if (++this.counter >= this.counterInterval) {
          const timeTaken = Date.now() - this.startTime;
          const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
          this.total += this.counter;
          this.counter = 0;
          if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
            this.counterInterval = 1;
            this.total = 0;
            return true;
          } else {
            switch (timeTaken) {
              case 0:
              case 1:
                this.counterInterval = this.total * 2;
                break;
            }
          }
        }
        return false;
      }
    };
  }
});

// src/list/worker.ts
function getFilterLabel(item) {
  return item.filterText != null ? patchLine(item.filterText, item.label) : item.label;
}
function toInputs(input, extendedSearchMode) {
  return extendedSearchMode ? parseInput(input) : [input];
}
function convertItemLabel(item) {
  let { label, converted } = item;
  if (converted)
    return item;
  if (label.includes("\n")) {
    label = item.label = label.replace(/\r?\n.*/gm, "");
  }
  if (label.includes(controlCode)) {
    let { line, highlights } = parseAnsiHighlights(label);
    item.label = line;
    if (!Array.isArray(item.ansiHighlights))
      item.ansiHighlights = highlights;
  }
  item.converted = true;
  return item;
}
function indexOf(label, input, smartcase, ignorecase) {
  if (smartcase)
    return smartcaseIndex(input, label);
  return ignorecase ? label.toLowerCase().indexOf(input.toLowerCase()) : label.indexOf(input);
}
function parseInput(input) {
  let res = [];
  let startIdx = 0;
  let currIdx = 0;
  let prev = "";
  for (; currIdx < input.length; currIdx++) {
    let ch = input[currIdx];
    if (WHITE_SPACE_CHARS.includes(ch.charCodeAt(0))) {
      if (prev && prev != "\\" && startIdx != currIdx) {
        res.push(input.slice(startIdx, currIdx));
        startIdx = currIdx + 1;
      }
    } else {
    }
    prev = ch;
  }
  if (startIdx != input.length) {
    res.push(input.slice(startIdx, input.length));
  }
  return res.map((s) => s.replace(/\\\s/g, " ").trim()).filter((s) => s.length > 0);
}
var logger30, controlCode, WHITE_SPACE_CHARS, SERCH_HL_GROUP, Worker;
var init_worker = __esm({
  "src/list/worker.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_ansiparse();
    init_array();
    init_async();
    init_diff();
    init_fuzzy();
    init_mutex();
    init_protocol();
    init_string();
    init_workspace();
    init_configuration3();
    logger30 = createLogger("list-worker");
    controlCode = "\x1B";
    WHITE_SPACE_CHARS = [32, 9];
    SERCH_HL_GROUP = "CocListSearch";
    Worker = class {
      constructor(list2, prompt, listOptions) {
        this.list = list2;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this._loading = false;
        this._finished = false;
        this.mutex = new Mutex();
        this.totalItems = [];
        this._onDidChangeItems = new import_node3.Emitter();
        this._onDidChangeLoading = new import_node3.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        this.onDidChangeLoading = this._onDidChangeLoading.event;
        this.fuzzyMatch = workspace_default.createFuzzyMatch();
      }
      set loading(loading) {
        if (this._loading == loading)
          return;
        this._loading = loading;
        this._onDidChangeLoading.fire(loading);
      }
      get isLoading() {
        return this._loading;
      }
      async loadItems(context, reload = false) {
        this.cancelFilter();
        this.filteredCount = 0;
        this._finished = false;
        let { list: list2, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        this.tokenSource = new import_node3.CancellationTokenSource();
        let token = this.tokenSource.token;
        let items = await list2.loadItems(context, token);
        if (token.isCancellationRequested)
          return;
        items = items ?? [];
        if (Array.isArray(items)) {
          this.tokenSource = null;
          this.totalItems = items;
          this.loading = false;
          this._finished = true;
          let filtered;
          if (!interactive) {
            this.filterTokenSource = new import_node3.CancellationTokenSource();
            await this.mutex.use(async () => {
              await this.filterItems(items, { reload }, token);
            });
          } else {
            filtered = this.convertToHighlightItems(items);
            this._onDidChangeItems.fire({
              sorted: true,
              items: filtered,
              reload,
              finished: true
            });
          }
        } else {
          let task = items;
          let totalItems = this.totalItems = [];
          let taken = 0;
          let currInput = context.input;
          this.filterTokenSource = new import_node3.CancellationTokenSource();
          let _onData = async (finished) => {
            await this.mutex.use(async () => {
              let inputChanged = this.input != currInput;
              if (inputChanged) {
                currInput = this.input;
                taken = defaultValue(this.filteredCount, 0);
              }
              if (taken >= totalItems.length)
                return;
              let append = taken > 0;
              let remain = totalItems.slice(taken);
              taken = totalItems.length;
              if (!interactive) {
                let tokenSource = this.filterTokenSource;
                await this.filterItems(remain, { append, reload }, tokenSource.token);
              } else {
                let items2 = this.convertToHighlightItems(remain);
                this._onDidChangeItems.fire({ items: items2, append, reload, sorted: true, finished });
              }
            });
          };
          let interval2 = setInterval(async () => {
            await _onData();
          }, 50);
          task.on("data", (item) => {
            totalItems.push(item);
          });
          let onEnd = async () => {
            if (task == null)
              return;
            clearInterval(interval2);
            this.tokenSource = null;
            task = null;
            this.loading = false;
            this._finished = true;
            disposable.dispose();
            if (token.isCancellationRequested)
              return;
            if (totalItems.length == 0) {
              this._onDidChangeItems.fire({ items: [], append: false, sorted: true, reload, finished: true });
              return;
            }
            await _onData(true);
          };
          let disposable = token.onCancellationRequested(() => {
            this.mutex.reset();
            task == null ? void 0 : task.dispose();
            void onEnd();
          });
          task.on("error", async (error) => {
            if (task == null)
              return;
            task = null;
            this.tokenSource = null;
            this.loading = false;
            disposable.dispose();
            clearInterval(interval2);
            workspace_default.nvim.call("coc#prompt#stop_prompt", ["list"], true);
            workspace_default.nvim.echoError(`Task error: ${error.toString()}`);
            logger30.error("Task error:", error);
          });
          task.on("end", onEnd);
        }
      }
      async drawItems() {
        let { totalItems } = this;
        if (totalItems.length === 0)
          return;
        this.cancelFilter();
        let tokenSource = this.filterTokenSource = new import_node3.CancellationTokenSource();
        let token = tokenSource.token;
        await this.mutex.use(async () => {
          if (token.isCancellationRequested)
            return;
          let { totalItems: totalItems2 } = this;
          this.filteredCount = totalItems2.length;
          await this.filterItems(totalItems2, {}, tokenSource.token);
        });
      }
      cancelFilter() {
        if (this.filterTokenSource) {
          this.filterTokenSource.cancel();
          this.filterTokenSource = null;
        }
      }
      stop() {
        this.cancelFilter();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
        this.loading = false;
      }
      get length() {
        return this.totalItems.length;
      }
      get input() {
        return this.prompt.input;
      }
      convertToHighlightItems(items) {
        let input = toText(this.input);
        if (input.length > 0)
          this.fuzzyMatch.setPattern(input);
        let res = items.map((item) => {
          convertItemLabel(item);
          let search = input.length > 0 && item.filterText !== "";
          if (search) {
            let filterLabel = getFilterLabel(item);
            let results = this.fuzzyMatch.matchHighlights(filterLabel, SERCH_HL_GROUP);
            item.ansiHighlights = Array.isArray(item.ansiHighlights) ? item.ansiHighlights.filter((o) => o.hlGroup !== SERCH_HL_GROUP) : [];
            if (results)
              item.ansiHighlights.push(...results.highlights);
          }
          return item;
        });
        this.fuzzyMatch.free();
        return res;
      }
      async filterItemsByInclude(input, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        const smartcase = configuration_default.smartcase;
        let inputs = toInputs(input, configuration_default.extendedSearchMode);
        if (ignorecase)
          inputs = inputs.map((s) => s.toLowerCase());
        await filter(items, (item) => {
          convertItemLabel(item);
          let spans = [];
          let filterLabel = getFilterLabel(item);
          let byteIndex2 = bytes(filterLabel);
          let curr = 0;
          item.ansiHighlights = toArray(item.ansiHighlights).filter((o) => o.hlGroup !== SERCH_HL_GROUP);
          for (let input2 of inputs) {
            let label = filterLabel.slice(curr);
            let idx = indexOf(label, input2, smartcase, ignorecase);
            if (idx === -1)
              break;
            let end = idx + curr + input2.length;
            spans.push([byteIndex2(idx + curr), byteIndex2(end)]);
            curr = end;
          }
          if (spans.length !== inputs.length)
            return false;
          item.ansiHighlights.push(...spans.map((s) => {
            return { span: s, hlGroup: SERCH_HL_GROUP };
          }));
          return true;
        }, onFilter, token);
      }
      async filterItemsByRegex(input, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        let flags = ignorecase ? "iu" : "u";
        let inputs = toInputs(input, configuration_default.extendedSearchMode);
        let regexes = inputs.reduce((p, c) => {
          try {
            p.push(new RegExp(c, flags));
          } catch (e) {
          }
          return p;
        }, []);
        await filter(items, (item) => {
          convertItemLabel(item);
          item.ansiHighlights = toArray(item.ansiHighlights).filter((o) => o.hlGroup !== SERCH_HL_GROUP);
          let spans = [];
          let filterLabel = getFilterLabel(item);
          let byteIndex2 = bytes(filterLabel);
          let curr = 0;
          for (let regex2 of regexes) {
            let ms = filterLabel.slice(curr).match(regex2);
            if (ms == null)
              break;
            let end = ms.index + curr + ms[0].length;
            spans.push([byteIndex2(ms.index + curr), byteIndex2(end)]);
            curr = end;
          }
          if (spans.length !== inputs.length)
            return false;
          item.ansiHighlights.push(...spans.map((s) => {
            return { span: s, hlGroup: SERCH_HL_GROUP };
          }));
          return true;
        }, onFilter, token);
      }
      async filterItemsByFuzzyMatch(input, items, token, onFilter) {
        let { extendedSearchMode, smartcase } = configuration_default;
        let { sort } = this.listOptions;
        let idx = 0;
        this.fuzzyMatch.setPattern(input, !extendedSearchMode);
        let codes = getCharCodes(input);
        if (extendedSearchMode)
          codes = codes.filter((c) => !WHITE_SPACE_CHARS.includes(c));
        await filter(items, (item) => {
          convertItemLabel(item);
          let filterLabel = getFilterLabel(item);
          let match = this.fuzzyMatch.matchHighlights(filterLabel, SERCH_HL_GROUP);
          if (!match || smartcase && !fuzzyMatch(codes, filterLabel))
            return false;
          let ansiHighlights = Array.isArray(item.ansiHighlights) ? item.ansiHighlights.filter((o) => o.hlGroup != SERCH_HL_GROUP) : [];
          ansiHighlights.push(...match.highlights);
          return {
            sortText: typeof item.sortText === "string" ? item.sortText : String.fromCharCode(idx),
            score: match.score,
            ansiHighlights
          };
        }, (items2, done) => {
          onFilter(items2, done, sort);
        }, token);
      }
      async filterItems(arr, opts, token) {
        let { input } = this;
        if (input.length === 0) {
          let items = arr.map((item) => {
            return convertItemLabel(item);
          });
          this._onDidChangeItems.fire({ items, sorted: true, finished: this._finished, ...opts });
          return;
        }
        let called = false;
        let itemsToSort = [];
        const onFilter = (items, done, sort) => {
          let finished = done && this._finished;
          if (token.isCancellationRequested || !finished && items.length == 0)
            return;
          if (sort) {
            itemsToSort.push(...items);
            if (done)
              this._onDidChangeItems.fire({ items: itemsToSort, append: false, sorted: false, reload: opts.reload, finished });
          } else {
            let append = opts.append === true || called;
            called = true;
            this._onDidChangeItems.fire({ items, append, sorted: true, reload: opts.reload, finished });
          }
        };
        switch (this.listOptions.matcher) {
          case "strict":
            await this.filterItemsByInclude(input, arr, token, onFilter);
            break;
          case "regex":
            await this.filterItemsByRegex(input, arr, token, onFilter);
            break;
          default:
            await this.filterItemsByFuzzyMatch(input, arr, token, onFilter);
        }
      }
      dispose() {
        this.stop();
      }
    };
  }
});

// src/list/session.ts
var frames2, debounceTime4, ListSession;
var init_session = __esm({
  "src/list/session.ts"() {
    "use strict";
    init_highligher();
    init_util();
    init_node();
    init_protocol();
    init_window();
    init_workspace();
    init_configuration3();
    init_db2();
    init_history();
    init_ui2();
    init_worker();
    frames2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    debounceTime4 = getConditionValue(50, 1);
    ListSession = class {
      constructor(nvim, prompt, list2, listOptions, listArgs) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list2;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.loadingFrame = "";
        this.hidden = false;
        this.disposables = [];
        this.args = [];
        this.ui = new ListUI(nvim, list2.name, listOptions);
        this.history = new InputHistory(prompt, list2.name, db_default, workspace_default.cwd);
        this.worker = new Worker(list2, prompt, listOptions);
        let debouncedChangeLine = debounce(async () => {
          let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
          if (previewing && currwin == this.winid) {
            let idx = this.ui.lnumToIndex(lnum);
            await this.doPreview(idx);
          }
        }, debounceTime4);
        this.disposables.push({
          dispose: () => {
            debouncedChangeLine.clear();
          }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = debounce(async () => {
          this.updateStatus();
          let { autoPreview } = this.listOptions;
          if (!autoPreview) {
            let [previewing, mode] = await nvim.eval("[coc#list#has_preview(),mode()]");
            if (mode != "n" || !previewing)
              return;
          }
          await this.doAction("preview");
        }, 50);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidOpen(async () => {
          if (typeof this.list.doHighlight == "function") {
            this.list.doHighlight();
          }
          if (this.listOptions.first) {
            await this.doAction();
          }
        }, null, this.disposables);
        this.ui.onDidClose(this.hide, this, this.disposables);
        this.ui.onDidDoubleClick(this.doAction, this, this.disposables);
        this.worker.onDidChangeItems((ev) => {
          if (this.hidden)
            return;
          this.ui.onDidChangeItems(ev);
        }, null, this.disposables);
        let start = 0;
        let timer;
        let interval2;
        this.disposables.push(import_node3.Disposable.create(() => {
          clearTimeout(timer);
          clearInterval(interval2);
        }));
        this.worker.onDidChangeLoading((loading) => {
          if (this.hidden)
            return;
          if (timer)
            clearTimeout(timer);
          if (loading) {
            start = Date.now();
            if (interval2)
              clearInterval(interval2);
            interval2 = setInterval(() => {
              let idx = Math.floor((Date.now() - start) % 1e3 / 100);
              this.loadingFrame = frames2[idx];
              this.updateStatus();
            }, 100);
          } else {
            timer = setTimeout(() => {
              this.loadingFrame = "";
              if (interval2)
                clearInterval(interval2);
              interval2 = null;
              this.updateStatus();
            }, Math.max(0, 200 - (Date.now() - start)));
          }
        }, null, this.disposables);
      }
      async start(args) {
        this.args = args;
        this.cwd = workspace_default.cwd;
        this.hidden = false;
        let { listArgs } = this;
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.listArgs = listArgs;
        this.history.filter();
        this.targetWinid = res[0];
        this.targetBufnr = res[1];
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
      }
      async reloadItems() {
        if (!this.ui.winid)
          return;
        await this.worker.loadItems(this.context, true);
      }
      async call(fname) {
        await this.nvim.call("coc#prompt#stop_prompt", ["list"]);
        let targets = await this.ui.getItems();
        let context = {
          name: this.name,
          args: this.listArgs,
          input: this.prompt.input,
          winid: this.targetWinid,
          bufnr: this.targetBufnr,
          targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
      }
      async chooseAction() {
        let { nvim, defaultAction } = this;
        let { actions } = this.list;
        let names = actions.map((o) => o.name);
        let idx = names.indexOf(defaultAction.name);
        if (idx != -1) {
          names.splice(idx, 1);
          names.unshift(defaultAction.name);
        }
        let shortcuts = /* @__PURE__ */ new Set();
        let choices = [];
        let invalids = [];
        let menuAction = workspace_default.env.dialog && configuration_default.get("menuAction", false);
        for (let name2 of names) {
          let i = 0;
          for (let ch of name2) {
            if (!shortcuts.has(ch)) {
              shortcuts.add(ch);
              choices.push(`${name2.slice(0, i)}&${name2.slice(i)}`);
              break;
            }
            i++;
          }
          if (i == name2.length) {
            invalids.push(name2);
          }
        }
        if (invalids.length && !menuAction) {
          names = names.filter((s) => !invalids.includes(s));
        }
        let n;
        if (menuAction) {
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          n = await window_default.showMenuPicker(names, { title: "Choose action", shortcuts: true });
          n = n + 1;
          this.prompt.start();
        } else {
          await nvim.call("coc#prompt#stop_prompt", ["list"]);
          n = await nvim.call("confirm", ["Choose action:", choices.join("\n")]);
          await wait(10);
          this.prompt.start();
        }
        if (n)
          await this.doAction(names[n - 1]);
      }
      async doAction(name2) {
        let { list: list2 } = this;
        let action;
        if (name2 != null) {
          action = list2.actions.find((o) => o.name == name2);
          if (!action) {
            void window_default.showErrorMessage(`Action ${name2} not found`);
            return;
          }
        } else {
          action = this.defaultAction;
        }
        let items;
        if (name2 == "preview") {
          let item = await this.ui.item;
          items = item ? [item] : [];
        } else {
          items = await this.ui.getItems();
        }
        if (items.length)
          await this.doItemAction(items, action);
      }
      async doPreview(index) {
        let item = this.ui.getItem(index);
        let action = this.list.actions.find((o) => o.name == "preview");
        if (!item || !action)
          return;
        await this.doItemAction([item], action);
      }
      async first() {
        await this.doDefaultAction(0);
      }
      async last() {
        await this.doDefaultAction(this.ui.length - 1);
      }
      async previous() {
        await this.doDefaultAction(this.ui.index - 1);
      }
      async next() {
        await this.doDefaultAction(this.ui.index + 1);
      }
      async doDefaultAction(index) {
        let { ui } = this;
        let item = ui.getItem(index);
        if (!item)
          return;
        await this.ui.setIndex(index);
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
      }
      get name() {
        return this.list.name;
      }
      get winid() {
        return this.ui.winid;
      }
      get length() {
        return this.ui.length;
      }
      get defaultAction() {
        let { defaultAction, actions, name: name2 } = this.list;
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        let action;
        if (config.defaultAction)
          action = actions.find((o) => o.name == config.defaultAction);
        if (!action)
          action = actions.find((o) => o.name == defaultAction);
        if (!action)
          action = actions[0];
        if (!action)
          throw new Error(`default action "${defaultAction}" not found`);
        return action;
      }
      async hide(notify = false, isVim2 = workspace_default.isVim) {
        if (this.hidden)
          return;
        let { nvim, timer, targetWinid, context } = this;
        let { winid } = this.ui;
        if (timer)
          clearTimeout(timer);
        this.worker.stop();
        this.history.add();
        this.ui.reset();
        db_default.save();
        this.hidden = true;
        nvim.pauseNotification();
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
        if (winid)
          nvim.call("coc#list#close", [winid, context.options.position, targetWinid, this.savedHeight], true);
        if (notify)
          return nvim.resumeNotification(true, true);
        await nvim.resumeNotification(false);
        if (isVim2) {
          await wait(10);
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          nvim.redrawVim();
        }
      }
      toggleMode() {
        let mode = this.prompt.mode == "normal" ? "insert" : "normal";
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
      }
      stop() {
        this.worker.stop();
      }
      async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(index);
        if (!item || item.resolved)
          return;
        let { list: list2 } = this;
        if (typeof list2.resolveItem === "function") {
          let label = item.label;
          let resolved = await Promise.resolve(list2.resolveItem(item));
          if (resolved && index == this.ui.index) {
            Object.assign(item, resolved, { resolved: true });
            if (label == resolved.label)
              return;
            this.ui.updateItem(item, index);
          }
        }
      }
      async showHelp() {
        await this.hide();
        let { list: list2, nvim } = this;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command("setl nobuflisted noswapfile buftype=nofile bufhidden=wipe", true);
        await nvim.resumeNotification();
        let hasOptions = list2.options && list2.options.length;
        let buf = await nvim.buffer;
        let highligher = new Highlighter();
        highligher.addLine("NAME", "Label");
        highligher.addLine(`  ${list2.name} - ${list2.description || ""}
`);
        highligher.addLine("SYNOPSIS", "Label");
        highligher.addLine(`  :CocList [LIST OPTIONS] ${list2.name}${hasOptions ? " [ARGUMENTS]" : ""}
`);
        if (list2.detail) {
          highligher.addLine("DESCRIPTION", "Label");
          let lines = list2.detail.split("\n").map((s) => "  " + s);
          highligher.addLine(lines.join("\n") + "\n");
        }
        if (hasOptions) {
          highligher.addLine("ARGUMENTS", "Label");
          highligher.addLine("");
          for (let opt of list2.options) {
            highligher.addLine(opt.name, "Special");
            highligher.addLine(`  ${opt.description}`);
            highligher.addLine("");
          }
          highligher.addLine("");
        }
        let config = workspace_default.getConfiguration(`list.source.${list2.name}`);
        if (Object.keys(config).length) {
          highligher.addLine("CONFIGURATIONS", "Label");
          highligher.addLine("");
          for (let key of Object.keys(config)) {
            let val = config[key];
            let name2 = `list.source.${list2.name}.${key}`;
            let description = defaultValue(workspace_default.configurations.getDescription(name2), key);
            highligher.addLine(`  "${name2}"`, "MoreMsg");
            highligher.addText(` - ${description} current value: `);
            highligher.addText(JSON.stringify(val), "Special");
          }
          highligher.addLine("");
        }
        highligher.addLine("ACTIONS", "Label");
        highligher.addLine(`  ${list2.actions.map((o) => o.name).join(", ")}`);
        highligher.addLine("");
        highligher.addLine(`see ':h coc-list-options' for available list options.`, "Comment");
        nvim.pauseNotification();
        highligher.render(buf, 0, -1);
        nvim.command("setl nomod", true);
        nvim.command("setl nomodifiable", true);
        nvim.command("normal! gg", true);
        nvim.command("nnoremap <buffer> q :bd!<CR>", true);
        await nvim.resumeNotification();
      }
      async switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive)
          return;
        const list2 = ["fuzzy", "strict", "regex"];
        let idx = list2.indexOf(matcher) + 1;
        if (idx >= list2.length)
          idx = 0;
        this.listOptions.matcher = list2[idx];
        this.prompt.matcher = list2[idx];
        await this.worker.drawItems();
      }
      updateStatus() {
        let { ui, list: list2, nvim } = this;
        if (!ui.bufnr)
          return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
          mode: this.prompt.mode.toUpperCase(),
          args: this.args.join(" "),
          name: list2.name,
          cwd: this.cwd,
          loading: this.loadingFrame,
          total: this.worker.length
        };
        buf.setVar("list_status", status, true);
        nvim.command("redraws", true);
      }
      get context() {
        let { winid } = this.ui;
        return {
          options: this.listOptions,
          args: this.listArgs,
          input: this.prompt.input,
          cwd: workspace_default.cwd,
          window: this.window,
          buffer: this.buffer,
          listWindow: winid ? this.nvim.createWindow(winid) : void 0
        };
      }
      get window() {
        return this.targetWinid ? this.nvim.createWindow(this.targetWinid) : void 0;
      }
      get buffer() {
        return this.targetBufnr ? this.nvim.createBuffer(this.targetBufnr) : void 0;
      }
      onMouseEvent(key) {
        switch (key) {
          case "<LeftMouse>":
            return this.ui.onMouse("mouseDown");
          case "<LeftDrag>":
            return this.ui.onMouse("mouseDrag");
          case "<LeftRelease>":
            return this.ui.onMouse("mouseUp");
          case "<2-LeftMouse>":
            return this.ui.onMouse("doubleClick");
        }
      }
      async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect)
          return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
          let n = Number(ch);
          if (n == 0)
            n = 10;
          if (this.ui.length >= n) {
            this.nvim.pauseNotification();
            this.ui.setCursor(n);
            await this.nvim.resumeNotification();
            await this.doAction();
            return true;
          }
        }
        return false;
      }
      jumpBack() {
        let { targetWinid, nvim } = this;
        if (targetWinid) {
          nvim.pauseNotification();
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          this.nvim.call("win_gotoid", [targetWinid], true);
          nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        if (this.winid)
          await this.hide();
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.hidden = false;
        this.targetWinid = res[0];
        this.targetBufnr = res[1];
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
          await this.doAction("preview");
        }
      }
      async doItemAction(items, action) {
        let { noQuit, position } = this.listOptions;
        let { nvim } = this;
        let persistAction = action.persist === true || action.name == "preview";
        if (position === "tab" && action.tabPersist)
          persistAction = true;
        let persist = this.winid && (persistAction || noQuit);
        if (persist) {
          if (!persistAction) {
            nvim.pauseNotification();
            nvim.call("coc#prompt#stop_prompt", ["list"], true);
            nvim.call("win_gotoid", [this.context.window.id], true);
            await nvim.resumeNotification();
          }
        } else {
          await this.hide();
        }
        if (action.multiple) {
          await Promise.resolve(action.execute(items, this.context));
        } else if (action.parallel) {
          await Promise.all(items.map((item) => Promise.resolve(action.execute(item, this.context))));
        } else {
          for (let item of items) {
            await Promise.resolve(action.execute(item, this.context));
          }
        }
        if (persist)
          this.ui.restoreWindow();
        if (action.reload && persist) {
          await this.reloadItems();
        } else if (persist) {
          this.nvim.command("redraw", true);
        }
      }
      onInputChange() {
        if (this.timer)
          clearTimeout(this.timer);
        this.ui.cancel();
        this.history.filter();
        this.listOptions.input = this.prompt.input;
        if (this.listOptions.interactive) {
          this.worker.stop();
          this.timer = setTimeout(async () => {
            await this.worker.loadItems(this.context);
          }, configuration_default.debounceTime);
        } else {
          void this.worker.drawItems();
        }
      }
      dispose() {
        void this.hide(true);
        disposeAll(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
      }
    };
  }
});

// src/list/formatting.ts
function fixWidth(str, width) {
  if (str.length > width) {
    return str.slice(0, width - 1) + ".";
  }
  return str + " ".repeat(width - str.length);
}
function formatUri(uri, cwd2) {
  if (!uri.startsWith("file:"))
    return uri;
  let filepath = URI.parse(uri).fsPath;
  return isParentFolder(cwd2, filepath) ? path.relative(cwd2, filepath) : filepath;
}
function formatListItems(align, list2) {
  if (list2.length === 0) {
    return [];
  }
  let processedList = [];
  if (align) {
    const maxWidths = Array(Math.min(...list2.map((item) => item.label.length))).fill(0);
    for (let item of list2) {
      for (let i = 0; i < maxWidths.length; i++) {
        maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
      }
    }
    processedList = list2.map((item) => ({
      ...item,
      label: item.label.map((element, idx) => element.padEnd(maxWidths[idx])).join("	")
    }));
  } else {
    processedList = list2.map((item) => ({ ...item, label: item.label.join("	") }));
  }
  return processedList;
}
function formatPath(format3, pathToFormat) {
  if (format3 === "hidden") {
    return "";
  } else if (format3 === "full") {
    return pathToFormat;
  } else if (format3 === "short") {
    const segments = pathToFormat.split(path.sep);
    if (segments.length < 2) {
      return pathToFormat;
    }
    const shortenedInit = segments.slice(0, segments.length - 2).filter((seg) => seg.length > 0).map((seg) => seg[0]);
    return [...shortenedInit, segments[segments.length - 1]].join(path.sep);
  } else {
    const segments = pathToFormat.split(path.sep);
    return toText(segments[segments.length - 1]);
  }
}
var init_formatting = __esm({
  "src/list/formatting.ts"() {
    "use strict";
    init_node();
    init_esm();
    init_fs();
    init_string();
  }
});

// src/list/source/commands.ts
function score2(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var extensionRegistry4, CommandsList;
var init_commands2 = __esm({
  "src/list/source/commands.ts"() {
    "use strict";
    init_commands();
    init_extensionRegistry();
    init_registry();
    init_workspace();
    init_basic();
    init_formatting();
    init_string();
    extensionRegistry4 = Registry.as(Extensions.ExtensionContribution);
    CommandsList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "run";
        this.description = "registered commands of coc.nvim";
        this.name = "commands";
        this.mru = workspace_default.createMru("commands");
        this.addAction("run", async (item) => {
          await commands_default.fireCommand(item.data.cmd);
        });
        this.addAction("append", async (item) => {
          let { cmd } = item.data;
          await workspace_default.nvim.feedKeys(`:CocCommand ${cmd} `, "n", false);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        let ids = /* @__PURE__ */ new Set();
        for (const obj of extensionRegistry4.onCommands.concat(commands_default.commandList)) {
          let { id, title } = obj;
          if (ids.has(id))
            continue;
          ids.add(id);
          items.push({
            label: [id, toText(title)],
            filterText: id,
            data: { cmd: id, score: score2(mruList, id) }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine", true);
        nvim.command("highlight default link CocCommandsTitle Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/location.ts
function createItem(filename, loc) {
  let uri = loc.uri ?? URI.file(loc.filename).toString();
  let label = "";
  const ansiHighlights = [];
  let start = 0;
  if (filename.length > 0) {
    label = filename + " ";
    ansiHighlights.push({ span: [start, start + byteLength(filename)], hlGroup: "Directory" });
  }
  start = byteLength(label);
  let lnum = loc.lnum ?? loc.range.start.line + 1;
  let col = loc.col ?? byteLength(loc.text.slice(0, loc.range.start.character)) + 1;
  let position = `|${loc.type ? loc.type + " " : ""}${lnum} Col ${col}|`;
  label += position;
  ansiHighlights.push({ span: [start, start + byteLength(position)], hlGroup: "LineNr" });
  if (loc.type) {
    let hl = loc.type.toLowerCase() === "error" ? "Error" : "WarningMsg";
    ansiHighlights.push({ span: [start + 1, start + byteLength(loc.type)], hlGroup: hl });
  }
  if (loc.range && loc.range.start.line == loc.range.end.line) {
    let len = byteLength(label) + 1;
    let start2 = len + byteLength(loc.text.slice(0, loc.range.start.character));
    let end = len + byteLength(loc.text.slice(0, loc.range.end.character));
    ansiHighlights.push({ span: [start2, end], hlGroup: "Search" });
  }
  label += " " + loc.text;
  let filterText = `${filename}${loc.text.trim()}`;
  let location;
  if (loc.range) {
    location = Location.create(uri, loc.range);
  } else {
    let start2 = Position.create(loc.lnum - 1, loc.col - 1);
    let end = Position.create((loc.end_lnum ?? loc.lnum) - 1, (loc.end_col ?? loc.col) - 1);
    location = Location.create(uri, Range.create(start2, end));
  }
  location.targetRange = loc.targetRange ? loc.targetRange : Range.create(lnum - 1, 0, lnum - 1, 99);
  return {
    label,
    location,
    filterText,
    ansiHighlights
  };
}
var LocationList;
var init_location = __esm({
  "src/list/source/location.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_array();
    init_fs();
    init_node();
    init_string();
    init_basic();
    LocationList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "open";
        this.description = "show locations saved by g:coc_jump_locations variable";
        this.name = "location";
        this.createAction({
          name: "refactor",
          multiple: true,
          execute: async (items) => {
            let locations = items.map((o) => o.location);
            await commands_default.executeCommand("editor.action.showRefactor", locations);
          }
        });
        this.addLocationActions();
      }
      async loadItems(context, _token) {
        let locs = await this.nvim.getVar("coc_jump_locations");
        locs = toArray(locs);
        let bufnr = context.buffer.id;
        let ignoreFilepath = locs.every((o) => o.bufnr == bufnr);
        let items = locs.map((loc) => {
          let filename = ignoreFilepath ? "" : loc.filename;
          if (filename.length > 0 && path.isAbsolute(filename)) {
            filename = isParentFolder(context.cwd, filename) ? path.relative(context.cwd, filename) : filename;
          }
          return createItem(filename, loc);
        });
        return items;
      }
    };
  }
});

// src/list/source/diagnostics.ts
function convertToLabel(item, cwd2, includeCode, pathFormat = "full") {
  const file = isParentFolder(cwd2, item.file) ? path.relative(cwd2, item.file) : item.file;
  const formattedPath = formatPath(pathFormat, file);
  const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
  const source = includeCode ? `[${item.source} ${defaultValue(item.code, "")}]` : item.source;
  return [...formattedPosition, source, item.severity, item.message];
}
var DiagnosticsList;
var init_diagnostics = __esm({
  "src/list/source/diagnostics.ts"() {
    "use strict";
    init_manager();
    init_util();
    init_fs();
    init_node();
    init_formatting();
    init_location();
    DiagnosticsList = class extends LocationList {
      constructor(manager) {
        super();
        this.defaultAction = "open";
        this.description = "diagnostics of current workspace";
        this.name = "diagnostics";
        manager_default.onDidRefresh(async () => {
          let session = manager.getSession("diagnostics");
          if (session)
            await session.reloadItems();
        }, null, this.disposables);
      }
      async loadItems(context) {
        let list2 = await manager_default.getDiagnosticList();
        let { cwd: cwd2 } = context;
        const config = this.getConfig();
        const includeCode = config.get("includeCode", true);
        const pathFormat = config.get("pathFormat", "full");
        const unformatted = list2.map((item) => {
          return {
            label: convertToLabel(item, cwd2, includeCode, pathFormat),
            location: item.location
          };
        });
        return formatListItems(this.alignColumns, unformatted);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("highlight default link CocDiagnosticsFile Comment", true);
        nvim.command("highlight default link CocDiagnosticsError CocErrorSign", true);
        nvim.command("highlight default link CocDiagnosticsWarning CocWarningSign", true);
        nvim.command("highlight default link CocDiagnosticsInfo CocInfoSign", true);
        nvim.command("highlight default link CocDiagnosticsHint CocHintSign", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/extensions.ts
function sortExtensionItem(a, b) {
  if (a.data.priority != b.data.priority) {
    return b.data.priority - a.data.priority;
  }
  return b.data.id > a.data.id ? 1 : -1;
}
function getExtensionPrefix(state) {
  let prefix = "+";
  if (state == "disabled") {
    prefix = "-";
  } else if (state == "activated") {
    prefix = "*";
  } else if (state == "unknown") {
    prefix = "?";
  }
  return prefix;
}
function getExtensionPriority(stat) {
  switch (stat) {
    case "unknown":
      return 2;
    case "activated":
      return 1;
    case "disabled":
      return -1;
    default:
      return 0;
  }
}
var delay3, ExtensionList;
var init_extensions = __esm({
  "src/list/source/extensions.ts"() {
    "use strict";
    init_esm();
    init_extension();
    init_util();
    init_node();
    init_workspace();
    init_basic();
    init_formatting();
    delay3 = getConditionValue(50, 0);
    ExtensionList = class extends BasicList {
      constructor(manager) {
        super();
        this.manager = manager;
        this.defaultAction = "toggle";
        this.description = "manage coc extensions";
        this.name = "extensions";
        this.addAction("toggle", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            return;
          if (state == "activated") {
            await this.manager.deactivate(id);
          } else {
            await this.manager.activate(id);
          }
          await wait(delay3);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("configuration", async (item) => {
          let { root } = item.data;
          let jsonFile = path.join(root, "package.json");
          if (fs.existsSync(jsonFile)) {
            let lines = fs.readFileSync(jsonFile, "utf8").split(/\r?\n/);
            let idx = lines.findIndex((s) => s.includes('"contributes"'));
            await workspace_default.jumpTo(URI.file(jsonFile), { line: idx == -1 ? 0 : idx, character: 0 });
          }
        });
        this.addAction("open", async (item) => {
          let { root } = item.data;
          workspace_default.nvim.call("coc#ui#open_url", [root], true);
        });
        this.addAction("disable", async (item) => {
          let { id, state } = item.data;
          if (state !== "disabled")
            await this.manager.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("enable", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            await this.manager.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("lock", async (item) => {
          let { id } = item.data;
          this.manager.states.setLocked(id, true);
        }, { persist: true, reload: true });
        this.addAction("help", async (item) => {
          let { root } = item.data;
          let files = fs.readdirSync(root, { encoding: "utf8" });
          let file = files.find((f) => /^readme/i.test(f));
          if (file)
            await workspace_default.jumpTo(URI.file(file));
        });
        this.addAction("reload", async (item) => {
          let { id } = item.data;
          await this.manager.reloadExtension(id);
        }, { persist: true, reload: true });
        this.addMultipleAction("uninstall", async (items) => {
          let ids = [];
          for (let item of items) {
            if (item.data.isLocal)
              continue;
            ids.push(item.data.id);
          }
          await this.manager.uninstallExtensions(ids);
        });
      }
      async loadItems() {
        let items = [];
        let list2 = await extension_default.getExtensionStates();
        for (let stat of list2) {
          let prefix = getExtensionPrefix(stat.state);
          let root = fs.realpathSync(stat.root);
          let locked = stat.isLocked;
          items.push({
            label: [`${prefix} ${stat.id}${locked ? " \uE0A2" : ""}`, ...stat.isLocal ? ["[RTP]"] : [], stat.version, root.replace(os.homedir(), "~")],
            filterText: stat.id,
            data: {
              id: stat.id,
              root,
              state: stat.state,
              isLocal: stat.isLocal,
              priority: getExtensionPriority(stat.state)
            }
          });
        }
        items.sort(sortExtensionItem);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine", true);
        nvim.command("highlight default link CocExtensionsActivited Special", true);
        nvim.command("highlight default link CocExtensionsLoaded Normal", true);
        nvim.command("highlight default link CocExtensionsDisabled Comment", true);
        nvim.command("highlight default link CocExtensionsName String", true);
        nvim.command("highlight default link CocExtensionsLocal MoreMsg", true);
        nvim.command("highlight default link CocExtensionsRoot Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/folders.ts
var FoldList;
var init_folders = __esm({
  "src/list/source/folders.ts"() {
    "use strict";
    init_esm();
    init_fs();
    init_window();
    init_workspace();
    init_basic();
    FoldList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "edit";
        this.description = "list of current workspace folders";
        this.name = "folders";
        this.addAction("edit", async (item) => {
          let newPath = await this.nvim.call("input", ["Folder: ", item.label, "dir"]);
          if (!isDirectory(newPath)) {
            void window_default.showWarningMessage(`invalid path: ${newPath}`);
            return;
          }
          workspace_default.workspaceFolderControl.renameWorkspaceFolder(item.label, newPath);
        });
        this.addAction("delete", async (item) => {
          workspace_default.workspaceFolderControl.removeWorkspaceFolder(item.label);
        }, { reload: true, persist: true });
        this.addAction("newfile", async (item, context) => {
          let file = await window_default.requestInput("File name", item.label + "/");
          if (!file)
            return;
          await workspace_default.createFile(file, { overwrite: false, ignoreIfExists: true });
          await this.jumpTo(URI.file(file).toString(), null, context);
        });
      }
      async loadItems() {
        return workspace_default.folderPaths.map((p) => ({ label: p }));
      }
    };
  }
});

// src/list/source/links.ts
var LinksList;
var init_links = __esm({
  "src/list/source/links.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_workspace();
    init_basic();
    init_formatting();
    LinksList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "open";
        this.description = "links of current buffer";
        this.name = "links";
        this.addAction("open", async (item) => {
          let { target } = item.data;
          await workspace_default.openResource(target);
        });
        this.addAction("jump", async (item) => {
          let { location } = item.data;
          await workspace_default.jumpTo(location.uri, location.range.start);
        });
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let doc = workspace_default.getAttachedDocument(buf.id);
        let items = [];
        let links2 = await languages_default.getDocumentLinks(doc.textDocument, token);
        if (links2 == null)
          throw new Error("Links provider not found.");
        let res = [];
        for (let link of links2) {
          link = link.target ? link : await languages_default.resolveDocumentLink(link, token);
          if (link.target) {
            items.push({
              label: formatUri(link.target, workspace_default.cwd),
              data: {
                target: link.target,
                location: Location.create(doc.uri, link.range)
              }
            });
          }
          res.push(link);
        }
        return items;
      }
    };
  }
});

// src/list/source/lists.ts
function mruScore(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var ListsList;
var init_lists = __esm({
  "src/list/source/lists.ts"() {
    "use strict";
    init_mru();
    init_string();
    init_basic();
    init_formatting();
    ListsList = class extends BasicList {
      constructor(listMap) {
        super();
        this.listMap = listMap;
        this.name = "lists";
        this.defaultAction = "open";
        this.description = "registered lists of coc.nvim";
        this.mru = new Mru("lists");
        this.addAction("open", async (item) => {
          let { name: name2 } = item.data;
          await this.mru.add(name2);
          setTimeout(() => {
            this.nvim.command(`CocList ${name2}`, true);
          }, 50);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        for (let list2 of this.listMap.values()) {
          if (list2.name == "lists")
            continue;
          items.push({
            label: [list2.name, toText(list2.description)],
            data: {
              name: list2.name,
              interactive: list2.interactive,
              score: mruScore(mruList, list2.name)
            }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine", true);
        nvim.command("highlight default link CocListsDesc Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/util/convert.ts
function getSymbolKind(kind) {
  switch (kind) {
    case SymbolKind.File:
      return "File";
    case SymbolKind.Module:
      return "Module";
    case SymbolKind.Namespace:
      return "Namespace";
    case SymbolKind.Package:
      return "Package";
    case SymbolKind.Class:
      return "Class";
    case SymbolKind.Method:
      return "Method";
    case SymbolKind.Property:
      return "Property";
    case SymbolKind.Field:
      return "Field";
    case SymbolKind.Constructor:
      return "Constructor";
    case SymbolKind.Enum:
      return "Enum";
    case SymbolKind.Interface:
      return "Interface";
    case SymbolKind.Function:
      return "Function";
    case SymbolKind.Variable:
      return "Variable";
    case SymbolKind.Constant:
      return "Constant";
    case SymbolKind.String:
      return "String";
    case SymbolKind.Number:
      return "Number";
    case SymbolKind.Boolean:
      return "Boolean";
    case SymbolKind.Array:
      return "Array";
    case SymbolKind.Object:
      return "Object";
    case SymbolKind.Key:
      return "Key";
    case SymbolKind.Null:
      return "Null";
    case SymbolKind.EnumMember:
      return "EnumMember";
    case SymbolKind.Struct:
      return "Struct";
    case SymbolKind.Event:
      return "Event";
    case SymbolKind.Operator:
      return "Operator";
    case SymbolKind.TypeParameter:
      return "TypeParameter";
    default:
      return "Unknown";
  }
}
var init_convert = __esm({
  "src/util/convert.ts"() {
    "use strict";
    init_main();
  }
});

// src/list/source/outline.ts
function symbolsToListItems(symbols, uri, filterKind) {
  let items = [];
  const addSymbols = (symbols2, level2 = 0) => {
    symbols2.sort((a, b) => {
      return compareRangesUsingStarts(a.selectionRange, b.selectionRange);
    });
    for (let s of symbols2) {
      let kind = getSymbolKind(s.kind);
      let location = Location.create(uri, s.selectionRange);
      items.push({
        label: [`${"| ".repeat(level2)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
        filterText: getFilterText(s, filterKind),
        location,
        data: { kind }
      });
      if (!isFalsyOrEmpty(s.children)) {
        addSymbols(s.children, level2 + 1);
      }
    }
  };
  addSymbols(symbols);
  if (filterKind) {
    items = items.filter((o) => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
  }
  return items;
}
function getFilterText(s, kind) {
  if (typeof kind === "string" && kind.length > 0)
    return s.name;
  return `${s.name}${getSymbolKind(s.kind)}`;
}
async function loadCtagsSymbols(document2, nvim) {
  if (!which.sync("ctags", { nothrow: true })) {
    return [];
  }
  let uri = URI.parse(document2.uri);
  let extname = path.extname(uri.fsPath);
  let content = "";
  let tempname = await nvim.call("tempname");
  let filepath = `${tempname}.${extname}`;
  let escaped = await nvim.call("fnameescape", filepath);
  await writeFile(escaped, document2.getDocumentContent());
  try {
    content = await runCommand(`ctags -f - --excmd=number --language-force=${document2.filetype} ${escaped}`);
  } catch (e) {
  }
  if (!content.trim().length) {
    content = await runCommand(`ctags -f - --excmd=number ${escaped}`);
  }
  content = content.trim();
  if (!content)
    return [];
  return contentToItems(content, document2);
}
function contentToItems(content, document2) {
  let lines = content.split(/\r?\n/);
  let items = [];
  for (let line of lines) {
    let parts = line.split("	");
    if (parts.length < 4)
      continue;
    let lnum = Number(parts[2].replace(/;"$/, ""));
    let text = document2.getline(lnum - 1);
    let idx = text.indexOf(parts[0]);
    let start = idx == -1 ? 0 : idx;
    let range = Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
    items.push({
      label: `${parts[0]} [${parts[3]}] ${lnum}`,
      filterText: parts[0],
      location: Location.create(document2.uri, range),
      data: { line: lnum }
    });
  }
  items.sort((a, b) => a.data.line - b.data.line);
  return items;
}
var Outline;
var init_outline = __esm({
  "src/list/source/outline.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_array();
    init_convert();
    init_fs();
    init_node();
    init_position();
    init_processes();
    init_workspace();
    init_formatting();
    init_location();
    Outline = class extends LocationList {
      constructor() {
        super(...arguments);
        this.description = "symbols of current document";
        this.name = "outline";
        this.options = [{
          name: "-k, -kind KIND",
          hasValue: true,
          description: "filter symbol by kind"
        }];
      }
      async loadItems(context, token) {
        let document2 = workspace_default.getAttachedDocument(context.buffer.id);
        let config = this.getConfig();
        let ctagsFiletypes = config.get("ctagsFiletypes", []);
        let symbols;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toString().toLowerCase() : null;
        if (!ctagsFiletypes.includes(document2.filetype)) {
          symbols = await languages_default.getDocumentSymbol(document2.textDocument, token);
        }
        if (token.isCancellationRequested)
          return [];
        if (!symbols)
          return await loadCtagsSymbols(document2, this.nvim);
        if (isFalsyOrEmpty(symbols))
          return [];
        let items = symbolsToListItems(symbols, document2.uri, filterKind);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName", true);
        nvim.command("syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine", true);
        nvim.command("highlight default link CocOutlineName Normal", true);
        nvim.command("highlight default link CocOutlineIndentLine Comment", true);
        nvim.command("highlight default link CocOutlineKind Typedef", true);
        nvim.command("highlight default link CocOutlineLine Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/language-client/utils/uuid.ts
function generateUuid() {
  return v4_default();
}
var init_uuid = __esm({
  "src/language-client/utils/uuid.ts"() {
    "use strict";
    init_esm_node();
  }
});

// src/language-client/features.ts
function ensure(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var LSPCancellationError, BaseFeature, StaticFeature, DynamicFeature, DynamicDocumentFeature, TextDocumentEventFeature, TextDocumentLanguageFeature;
var init_features = __esm({
  "src/language-client/features.ts"() {
    "use strict";
    init_protocol();
    init_is();
    init_workspace();
    init_uuid();
    init_errors();
    LSPCancellationError = class extends CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    };
    BaseFeature = class {
      constructor(client) {
        this._client = client;
      }
      sendRequest(type, params, token, defaultValue2) {
        return this._client.sendRequest(type, params, token).then((res) => {
          return token.isCancellationRequested || res == null ? defaultValue2 ?? null : res;
        }, (error) => {
          return this._client.handleFailedRequest(type, token, error, defaultValue2 ?? null);
        });
      }
    };
    ((StaticFeature4) => {
      function is(value) {
        return value !== void 0 && value !== null && func(value.fillClientCapabilities) && func(value.initialize) && func(value.dispose) && (value.fillInitializeParams === void 0 || func(value.fillInitializeParams)) && value.registrationType === void 0;
      }
      StaticFeature4.is = is;
    })(StaticFeature || (StaticFeature = {}));
    ((DynamicFeature8) => {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && func(candidate.fillClientCapabilities) && func(candidate.initialize) && func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || func(candidate.fillInitializeParams)) && func(candidate.register) && func(candidate.unregister) && candidate.registrationType !== void 0;
      }
      DynamicFeature8.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    DynamicDocumentFeature = class extends BaseFeature {
      constructor(client) {
        super(client);
      }
      getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
          count++;
          for (const document2 of workspace_default.textDocuments) {
            if (workspace_default.match(selector, document2) > 0) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
        }
        const registrations = count > 0;
        return { kind: "document", id: this.registrationType.method, registrations, matches: false };
      }
    };
    TextDocumentEventFeature = class extends DynamicDocumentFeature {
      constructor(client, event, type, middleware, createParams, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._selectorFilter = selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new import_node3.Emitter();
      }
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (workspace_default.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      async callback(data) {
        if (!this.matches(data))
          return;
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params).catch();
          this.notificationSent(data2, this._type, params);
        };
        const middleware = this._client.middleware[this._middleware];
        return Promise.resolve(middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data));
      }
      matches(data) {
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
      }
      unregister(id) {
        this._selectors.delete(id);
      }
      dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this.getDocumentSelectors()) {
          if (workspace_default.match(selector, document2) > 0) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
      constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
          const selector = registration.data.registerOptions.documentSelector;
          if (selector === null) {
            continue;
          }
          yield selector;
        }
      }
      get registrationType() {
        return this._registrationType;
      }
      get registrationLength() {
        return this._registrations.size;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability)
          return [void 0, void 0];
        if (boolean(capability) && capability === true) {
          return [generateUuid(), { documentSelector }];
        }
        if (import_node3.TextDocumentRegistrationOptions.is(capability)) {
          const id = import_node3.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          const selector = capability.documentSelector ?? documentSelector;
          return [id, Object.assign({}, { documentSelector: selector }, capability)];
        }
        if (import_node3.WorkDoneProgressOptions.is(capability)) {
          const id = import_node3.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          return [id, Object.assign({}, { documentSelector }, capability)];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && workspace_default.match(selector, textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
  }
});

// src/model/relativePattern.ts
var RelativePattern2;
var init_relativePattern = __esm({
  "src/model/relativePattern.ts"() {
    "use strict";
    init_esm();
    init_errors();
    RelativePattern2 = class {
      constructor(base, pattern) {
        if (typeof base !== "string") {
          if (!base || !URI.isUri(base) && typeof base.uri !== "string") {
            throw illegalArgument("base");
          }
        }
        if (typeof pattern !== "string") {
          throw illegalArgument("pattern");
        }
        if (typeof base === "string") {
          this.baseUri = URI.file(base);
        } else if (URI.isUri(base)) {
          this.baseUri = base;
        } else {
          this.baseUri = URI.parse(base.uri);
        }
        this.pattern = pattern;
      }
      toJSON() {
        return {
          pattern: this.pattern,
          baseUri: this.baseUri.toJSON()
        };
      }
    };
  }
});

// src/language-client/utils/converter.ts
function convertToTextDocumentItem(document2) {
  return {
    uri: document2.uri,
    languageId: document2.languageId,
    version: document2.version,
    text: document2.getText()
  };
}
function asOpenTextDocumentParams(textDocument) {
  return {
    textDocument: convertToTextDocumentItem(textDocument)
  };
}
function asRelativePattern(rp) {
  let { baseUri, pattern } = rp;
  if (typeof baseUri === "string") {
    return new RelativePattern2(URI.parse(baseUri), pattern);
  }
  return new RelativePattern2(baseUri, pattern);
}
function asCloseTextDocumentParams(document2) {
  return {
    textDocument: {
      uri: document2.uri
    }
  };
}
function asFullChangeTextDocumentParams(document2) {
  let result = {
    textDocument: {
      uri: document2.uri,
      version: document2.version
    },
    contentChanges: [{ text: document2.getText() }]
  };
  return result;
}
function asChangeTextDocumentParams(event) {
  let { textDocument, contentChanges } = event;
  let result = {
    textDocument: {
      uri: textDocument.uri,
      version: textDocument.version
    },
    contentChanges: contentChanges.slice()
  };
  return result;
}
function asWillSaveTextDocumentParams(event) {
  return {
    textDocument: asVersionedTextDocumentIdentifier(event.document),
    reason: event.reason
  };
}
function asVersionedTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri,
    version: textDocument.version
  };
}
function asSaveTextDocumentParams(document2, includeText) {
  let result = {
    textDocument: asVersionedTextDocumentIdentifier(document2)
  };
  if (includeText) {
    result.text = document2.getText();
  }
  return result;
}
function asUri(resource) {
  return resource.toString();
}
function asCompletionParams(textDocument, position, context) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: omit(context, ["option"])
  };
}
function asTextDocumentPositionParams(textDocument, position) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position
  };
}
function asSignatureHelpParams(textDocument, position, context) {
  return {
    textDocument: asTextDocumentIdentifier(textDocument),
    position,
    context
  };
}
function asTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri
  };
}
function asReferenceParams(textDocument, position, options2) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: { includeDeclaration: options2.includeDeclaration }
  };
}
function asDocumentSymbolParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
function asCodeLensParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
var init_converter = __esm({
  "src/language-client/utils/converter.ts"() {
    "use strict";
    init_esm();
    init_relativePattern();
    init_lodash();
  }
});

// src/language-client/callHierarchy.ts
var CallHierarchyFeature;
var init_callHierarchy = __esm({
  "src/language-client/callHierarchy.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    CallHierarchyFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          prepareCallHierarchy: (document2, position, token) => {
            const client = this._client;
            const prepareCallHierarchy = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_node3.CallHierarchyPrepareRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
          },
          provideCallHierarchyIncomingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyIncomingCalls = (item2, token2) => {
              return this.sendRequest(import_node3.CallHierarchyIncomingCallsRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
          },
          provideCallHierarchyOutgoingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyOutgoingCalls = (item2, token2) => {
              return this.sendRequest(import_node3.CallHierarchyOutgoingCallsRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
          }
        };
        return [languages_default.registerCallHierarchyProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/codeAction.ts
var CodeActionFeature;
var init_codeAction = __esm({
  "src/language-client/codeAction.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    CodeActionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.CodeActionRequest.type);
        this.disposables = [];
      }
      fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.honorsChangeAnnotations = false;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              CodeActionKind.Empty,
              CodeActionKind.QuickFix,
              CodeActionKind.Refactor,
              CodeActionKind.RefactorExtract,
              CodeActionKind.RefactorInline,
              CodeActionKind.RefactorRewrite,
              CodeActionKind.Source,
              CodeActionKind.SourceOrganizeImports
            ]
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const registerCommand = (id) => {
          const client = this._client;
          const executeCommand = (command, args) => {
            const params = {
              command,
              arguments: args
            };
            return client.sendRequest(import_node3.ExecuteCommandRequest.type, params);
          };
          const middleware = client.middleware;
          this.disposables.push(commands_default.registerCommand(id, (...args) => {
            return middleware.executeCommand ? middleware.executeCommand(id, args, executeCommand) : executeCommand(id, args);
          }, null, true));
        };
        const provider = {
          provideCodeActions: (document2, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = (document3, range2, context2, token2) => {
              const params = {
                textDocument: {
                  uri: document3.uri
                },
                range: range2,
                context: context2
              };
              return this.sendRequest(import_node3.CodeActionRequest.type, params, token2).then(
                (values) => {
                  if (!values)
                    return void 0;
                  values.forEach((val) => {
                    var _a2;
                    let cmd = Command.is(val) ? val.command : (_a2 = val.command) == null ? void 0 : _a2.command;
                    if (cmd && !commands_default.has(cmd))
                      registerCommand(cmd);
                  });
                  return values;
                }
              );
            };
            const middleware = client.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
          },
          resolveCodeAction: options2.resolveProvider ? (item, token) => {
            const middleware = this._client.middleware;
            const resolveCodeAction = (item2, token2) => {
              return this.sendRequest(import_node3.CodeActionResolveRequest.type, item2, token2, item2);
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [languages_default.registerCodeActionProvider(options2.documentSelector, provider, this._client.id, options2.codeActionKinds), provider];
      }
      dispose() {
        this.disposables.forEach((o) => {
          o.dispose();
        });
        this.disposables = [];
        super.dispose();
      }
    };
  }
});

// src/language-client/codeLens.ts
var CodeLensFeature;
var init_codeLens = __esm({
  "src/language-client/codeLens.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    CodeLensFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_node3.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options2)
          return;
        this.register({ id: generateUuid(), registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const emitter = new import_node3.Emitter();
        const provider = {
          onDidChangeCodeLenses: emitter.event,
          provideCodeLenses: (document2, token) => {
            const client = this._client;
            const provideCodeLenses = (document3, token2) => {
              return this.sendRequest(
                import_node3.CodeLensRequest.type,
                asCodeLensParams(document3),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
          },
          resolveCodeLens: options2.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return this.sendRequest(
                import_node3.CodeLensResolveRequest.type,
                codeLens2,
                token2,
                codeLens2
              );
            };
            const middleware = client.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [languages_default.registerCodeLensProvider(options2.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: emitter }];
      }
    };
  }
});

// src/language-client/colorProvider.ts
var ColorProviderFeature;
var init_colorProvider = __esm({
  "src/language-client/colorProvider.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    ColorProviderFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options2] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: { uri: context2.document.uri },
                range: context2.range
              };
              return this.sendRequest(import_node3.ColorPresentationRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document2, token) => {
            const client = this._client;
            const provideDocumentColors = (document3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return this.sendRequest(import_node3.DocumentColorRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
          }
        };
        return [languages_default.registerDocumentColorProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/completion.ts
var SupportedCompletionItemKinds, CompletionItemFeature;
var init_completion = __esm({
  "src/language-client/completion.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    SupportedCompletionItemKinds = [
      CompletionItemKind.Text,
      CompletionItemKind.Method,
      CompletionItemKind.Function,
      CompletionItemKind.Constructor,
      CompletionItemKind.Field,
      CompletionItemKind.Variable,
      CompletionItemKind.Class,
      CompletionItemKind.Interface,
      CompletionItemKind.Module,
      CompletionItemKind.Property,
      CompletionItemKind.Unit,
      CompletionItemKind.Value,
      CompletionItemKind.Enum,
      CompletionItemKind.Keyword,
      CompletionItemKind.Snippet,
      CompletionItemKind.Color,
      CompletionItemKind.File,
      CompletionItemKind.Reference,
      CompletionItemKind.Folder,
      CompletionItemKind.EnumMember,
      CompletionItemKind.Constant,
      CompletionItemKind.Struct,
      CompletionItemKind.Event,
      CompletionItemKind.Operator,
      CompletionItemKind.TypeParameter
    ];
    CompletionItemFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.CompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = ensure(ensure(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport,
          commitCharactersSupport: true,
          documentationFormat: this._client.supportedMarkupKind,
          deprecatedSupport: true,
          preselectSupport: true,
          insertReplaceSupport: true,
          tagSupport: { valueSet: [CompletionItemTag.Deprecated] },
          resolveSupport: { properties: ["documentation", "detail", "additionalTextEdits"] },
          labelDetailsSupport: true,
          insertTextModeSupport: { valueSet: [InsertTextMode.asIs, InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.insertTextMode = InsertTextMode.adjustIndentation;
        completion.completionList = {
          itemDefaults: [
            "commitCharacters",
            "editRange",
            "insertTextFormat",
            "insertTextMode"
          ]
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options2)
          return;
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2, id) {
        let triggerCharacters = options2.triggerCharacters || [];
        let allCommitCharacters = options2.allCommitCharacters || [];
        const provider = {
          provideCompletionItems: (document2, position, token, context) => {
            const middleware = this._client.middleware;
            const provideCompletionItems = (document3, position2, context2, token2) => {
              return this.sendRequest(
                import_node3.CompletionRequest.type,
                asCompletionParams(document3, position2, context2),
                token2,
                []
              );
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
          },
          resolveCompletionItem: options2.resolveProvider ? (item, token) => {
            const middleware = this._client.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return this.sendRequest(
                import_node3.CompletionResolveRequest.type,
                item2,
                token2,
                item2
              );
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        let name2 = this._client.id + (this.registrationLength == 0 ? "" : "-" + id);
        const disposable = languages_default.registerCompletionItemProvider(
          name2,
          "LS",
          options2.documentSelector,
          provider,
          triggerCharacters,
          options2.priority,
          allCommitCharacters
        );
        return [disposable, provider];
      }
    };
  }
});

// src/language-client/configuration.ts
var PullConfigurationFeature, SyncConfigurationFeature;
var init_configuration4 = __esm({
  "src/language-client/configuration.ts"() {
    "use strict";
    init_util2();
    init_is();
    init_protocol();
    init_workspace();
    init_features();
    init_uuid();
    PullConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
      }
      get method() {
        return import_node3.ConfigurationRequest.method;
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "workspace").configuration = true;
      }
      getState() {
        return { kind: "static" };
      }
      initialize() {
        let client = this._client;
        let { configuredSection } = client;
        client.onRequest(import_node3.ConfigurationRequest.type, (params, token) => {
          let configuration2 = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let section2 = configuredSection ? configuredSection + (item.section ? `.${item.section}` : "") : item.section;
              result.push(this.getConfiguration(item.scopeUri, section2));
            }
            return result;
          };
          let middleware = client.middleware.workspace;
          return (middleware == null ? void 0 : middleware.configuration) ? middleware.configuration(params, token, configuration2) : configuration2(params, token);
        });
      }
      getConfiguration(resource, section2) {
        let result = null;
        if (section2) {
          let index = section2.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(workspace_default.getConfiguration(void 0, resource).get(section2));
          } else {
            let config = workspace_default.getConfiguration(section2.substr(0, index), resource);
            result = toJSONObject(config.get(section2.substr(index + 1)));
          }
        } else {
          let config = workspace_default.getConfiguration(section2, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        return result ?? null;
      }
      dispose() {
      }
    };
    SyncConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return import_node3.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        var _a2;
        let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
        if (section2 !== void 0) {
          let id = this.configuredUID = generateUuid();
          this.register({
            id,
            registerOptions: {
              section: section2
            }
          });
        }
      }
      register(data) {
        if (this._client.configuredSection && data.id !== this.configuredUID)
          return;
        let { section: section2 } = data.registerOptions;
        let disposable = workspace_default.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(section2, event);
        });
        this._listeners.set(data.id, disposable);
        if (section2 !== void 0) {
          this.onDidChangeConfiguration(section2, void 0);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection, event) {
        var _a2;
        let { configuredSection } = this._client;
        let sections;
        if (string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections != null && event != null) {
          let keys = sections.map((s) => s.startsWith("languageserver.") ? "languageserver" : s);
          let affected = keys.some((section2) => event.affectsConfiguration(section2));
          if (!affected)
            return;
        }
        let didChangeConfiguration = (sections2) => {
          if (sections2 == null) {
            return this._client.sendNotification(import_node3.DidChangeConfigurationNotification.type, { settings: null });
          }
          let workspaceFolder = this._client.clientOptions.workspaceFolder;
          let settings = configuredSection ? SyncConfigurationFeature.getConfiguredSettings(configuredSection, workspaceFolder) : SyncConfigurationFeature.extractSettingsInformation(sections2, workspaceFolder);
          return this._client.sendNotification(import_node3.DidChangeConfigurationNotification.type, { settings });
        };
        let middleware = (_a2 = this._client.middleware.workspace) == null ? void 0 : _a2.didChangeConfiguration;
        let promise = middleware ? Promise.resolve(middleware(sections, didChangeConfiguration)) : didChangeConfiguration(sections);
        promise.catch((error) => {
          this._client.error(`Sending notification ${import_node3.DidChangeConfigurationNotification.type.method} failed`, error);
        });
      }
      static getConfiguredSettings(key, workspaceFolder) {
        let len = ".settings".length;
        let config = workspace_default.getConfiguration(key.slice(0, -len), workspaceFolder);
        return mergeConfigProperties(config.get("settings", {}));
      }
      static extractSettingsInformation(keys, workspaceFolder) {
        function ensurePath(config, path2) {
          let current = config;
          for (let i = 0; i < path2.length - 1; i++) {
            let obj = current[path2[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path2[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config;
          if (index >= 0) {
            config = workspace_default.getConfiguration(key.substr(0, index), workspaceFolder).get(key.substr(index + 1));
          } else {
            config = workspace_default.getConfiguration(key, workspaceFolder);
          }
          let path2 = keys[i].split(".");
          ensurePath(result, path2)[path2[path2.length - 1]] = config;
        }
        return result;
      }
    };
  }
});

// src/language-client/declaration.ts
var DeclarationFeature;
var init_declaration = __esm({
  "src/language-client/declaration.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    DeclarationFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let declarationSupport = ensure(ensure(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDeclaration: (document2, position, token) => {
            const client = this._client;
            const provideDeclaration = (document3, position2, token2) => this.sendRequest(import_node3.DeclarationRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
          }
        };
        return [languages_default.registerDeclarationProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/definition.ts
var DefinitionFeature;
var init_definition = __esm({
  "src/language-client/definition.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    DefinitionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDefinition: (document2, position, token) => {
            const client = this._client;
            const provideDefinition = (document3, position2, token2) => {
              return this.sendRequest(
                import_node3.DefinitionRequest.type,
                asTextDocumentPositionParams(document3, position2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
          }
        };
        return [languages_default.registerDefinitionProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/diagnostic.ts
var pullDebounce, DocumentPullStateTracker, DiagnosticRequestor, BackgroundScheduler, DiagnosticFeatureProviderImpl, DiagnosticFeature;
var init_diagnostic = __esm({
  "src/language-client/diagnostic.ts"() {
    "use strict";
    init_node();
    init_esm_node();
    init_esm();
    init_languages();
    init_errors();
    init_map();
    init_protocol();
    init_window();
    init_workspace();
    init_features();
    init_util();
    pullDebounce = getConditionValue(3e3, 10);
    DocumentPullStateTracker = class {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document2, arg1) {
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version2] = document2 instanceof URI ? [document2.toString(), document2, arg1] : [document2.uri.toString(), URI.parse(document2.uri), document2.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version2, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document2, arg1, arg2) {
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version2, resultId] = document2 instanceof URI ? [document2.toString(), document2, arg1, arg2] : [document2.uri, URI.parse(document2.uri), document2.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version2, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version2;
          state.resultId = resultId;
        }
      }
      unTrack(kind, document2) {
        const key = document2 instanceof URI ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
      }
      tracks(kind, document2) {
        const key = document2 instanceof URI ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      trackingDocuments() {
        return Array.from(this.documentPullStates.keys());
      }
      getResultId(kind, document2) {
        var _a2;
        const key = document2 instanceof URI ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        return (_a2 = states.get(key)) == null ? void 0 : _a2.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    };
    DiagnosticRequestor = class extends BaseFeature {
      constructor(client, options2) {
        var _a2;
        super(client);
        this.client = client;
        this.options = options2;
        this.enableWorkspace = options2.workspaceDiagnostics && ((_a2 = this.client.clientOptions.diagnosticPullOptions) == null ? void 0 : _a2.workspace) !== false;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new import_node3.Emitter();
        this.provider = this.createProvider();
        this.diagnostics = languages_default.createDiagnosticCollection(options2.identifier ? options2.identifier : client.id);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, textDocument) {
        return this.documentStates.tracks(kind, textDocument);
      }
      trackingDocuments() {
        return this.documentStates.trackingDocuments();
      }
      forget(kind, document2) {
        this.documentStates.unTrack(kind, document2);
      }
      pull(document2, cb) {
        this.pullAsync(document2).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${document2.uri}`, error);
        });
      }
      async pullAsync(document2) {
        if (this.isDisposed)
          return;
        const uri = document2.uri;
        const version2 = document2.version;
        const currentRequestState = this.openRequests.get(uri);
        const documentState = this.documentStates.track(1 /* document */, document2);
        if (currentRequestState === void 0) {
          const tokenSource = new import_node3.CancellationTokenSource();
          this.openRequests.set(uri, { state: "open" /* active */, document: document2, version: version2, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(document2, documentState.resultId, tokenSource.token) ?? { kind: import_node3.DocumentDiagnosticReportKind.Full, items: [] };
          } catch (error) {
            if (error instanceof LSPCancellationError && error.data && import_node3.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: "drop" /* outDated */, document: document2 };
            }
            if (afterState === void 0 && error instanceof CancellationError) {
              afterState = { state: "reschedule" /* reschedule */, document: document2 };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(uri);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${uri}`);
            this.diagnostics.delete(uri);
            return;
          }
          this.openRequests.delete(uri);
          const visible = window_default.visibleTextEditors.some((editor) => editor.document.uri === uri);
          if (!visible) {
            this.documentStates.unTrack(1 /* document */, document2);
            return;
          }
          if (afterState.state === "drop" /* outDated */)
            return;
          if (report !== void 0) {
            if (report.kind === import_node3.DocumentDiagnosticReportKind.Full) {
              this.diagnostics.set(uri, report.items);
            }
            documentState.pulledVersion = version2;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === "reschedule" /* reschedule */) {
            this.pull(document2);
          }
        } else {
          if (currentRequestState.state === "open" /* active */) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: currentRequestState.document });
          } else if (currentRequestState.state === "drop" /* outDated */) {
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: currentRequestState.document });
          }
        }
      }
      forgetDocument(document2) {
        const uri = document2.uri;
        const request2 = this.openRequests.get(uri);
        if (this.enableWorkspace) {
          if (request2 !== void 0) {
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: document2 });
          } else {
            this.pull(document2, () => {
              this.forget(1 /* document */, document2);
            });
          }
        } else {
          if (request2 !== void 0) {
            if (request2.state === "open" /* active */) {
              request2.tokenSource.cancel();
            }
            this.openRequests.delete(uri);
          }
          this.diagnostics.delete(uri.toString());
          this.forget(1 /* document */, document2);
        }
      }
      pullWorkspace() {
        if (!this.enableWorkspace)
          return;
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, import_node3.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, pullDebounce);
        }, (error) => {
          if (!(error instanceof LSPCancellationError) && !import_node3.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, import_node3.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, pullDebounce);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new import_node3.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds();
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === import_node3.DocumentDiagnosticReportKind.Full) {
              if (!this.documentStates.tracks(1 /* document */, URI.parse(item.uri))) {
                this.diagnostics.set(item.uri.toString(), item.items);
              }
            }
            this.documentStates.update(2 /* workspace */, URI.parse(item.uri), item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const provider = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (document2, previousResultId, token) => {
            const middleware = this.client.middleware;
            const provideDiagnostics = (document3, previousResultId2, token2) => {
              const uri = document3 instanceof URI ? document3.toString() : document3.uri;
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri },
                previousResultId: previousResultId2
              };
              return this.sendRequest(import_node3.DocumentDiagnosticRequest.type, params, token2, { kind: import_node3.DocumentDiagnosticReportKind.Full, items: [] }).then(async (result) => {
                if (result === void 0 || result === null || this.isDisposed) {
                  return { kind: import_node3.DocumentDiagnosticReportKind.Full, items: [] };
                }
                if (middleware.handleDiagnostics && result.kind == import_node3.DocumentDiagnosticReportKind.Full) {
                  middleware.handleDiagnostics(uri, result.items, (_, diagnostics) => {
                    result.items = diagnostics;
                  });
                }
                return result;
              });
            };
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document2, previousResultId, token, provideDiagnostics) : provideDiagnostics(document2, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          provider.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const provideWorkspaceDiagnostics = (resultIds2, token2) => {
              const partialResultToken = v4_default();
              const disposable = this.client.onProgress(import_node3.WorkspaceDiagnosticRequest.partialResult, partialResultToken, (partialResult) => {
                if (partialResult == void 0) {
                  resultReporter(null);
                  return;
                }
                resultReporter(partialResult);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: resultIds2,
                partialResultToken
              };
              return this.sendRequest(import_node3.WorkspaceDiagnosticRequest.type, params, token2, { items: [] }).then(async (result) => {
                resultReporter(result);
                return { items: [] };
              }).finally(() => {
                disposable.dispose();
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideWorkspaceDiagnostics) : provideWorkspaceDiagnostics(resultIds, token, resultReporter);
          };
        }
        return provider;
      }
      dispose() {
        var _a2, _b;
        this.isDisposed = true;
        (_a2 = this.workspaceCancellation) == null ? void 0 : _a2.cancel();
        (_b = this.workspaceTimeout) == null ? void 0 : _b.dispose();
        for (const request2 of this.openRequests.values()) {
          if (request2.state === "open" /* active */) {
            request2.tokenSource.cancel();
          }
        }
        this.openRequests.clear();
      }
    };
    BackgroundScheduler = class {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new LinkedMap();
      }
      add(document2) {
        const key = document2.uri;
        if (this.documents.has(key))
          return;
        this.documents.set(key, document2, 2 /* AsNew */);
        this.trigger();
      }
      remove(document2) {
        var _a2;
        const key = document2.uri;
        if (this.documents.has(key)) {
          this.documents.delete(key);
          this.diagnosticRequestor.pull(document2);
        }
        if (this.documents.size === 0) {
          this.stop();
        } else if (document2.uri === ((_a2 = this.endDocument) == null ? void 0 : _a2.uri)) {
          this.endDocument = this.documents.last;
        }
      }
      trigger() {
        if (this.intervalHandle !== void 0) {
          this.endDocument = this.documents.last;
          return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, import_node3.RAL)().timer.setInterval(() => {
          const document2 = this.documents.first;
          if (document2 !== void 0) {
            const key = document2.uri;
            this.diagnosticRequestor.pull(document2);
            this.documents.set(key, document2, 2 /* AsNew */);
            if (document2 === this.endDocument) {
              this.stop();
            }
          }
        }, 200);
      }
      dispose() {
        this.stop();
        this.documents.clear();
      }
      stop() {
        var _a2;
        (_a2 = this.intervalHandle) == null ? void 0 : _a2.dispose();
        this.intervalHandle = void 0;
        this.endDocument = void 0;
      }
    };
    DiagnosticFeatureProviderImpl = class {
      constructor(client, options2) {
        var _a2;
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions;
        const documentSelector = options2.documentSelector;
        const disposables = [];
        const ignored = diagnosticPullOptions.ignored ?? [];
        const matches = (document2) => {
          if (workspace_default.match(documentSelector, document2) <= 0)
            return false;
          const visible = window_default.visibleTextEditors.some((editor) => editor.document.uri === document2.uri);
          if (!visible)
            return false;
          if (ignored.length > 0 && ignored.some((p) => minimatch(URI.parse(document2.uri).fsPath, p, { dot: true })))
            return false;
          return true;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, options2);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document2) => {
          var _a3;
          if (!matches(document2) || !options2.interFileDependencies || ((_a3 = this.activeTextDocument) == null ? void 0 : _a3.uri) === document2.uri)
            return;
          this.backgroundScheduler.add(document2);
        };
        this.activeTextDocument = (_a2 = window_default.activeTextEditor) == null ? void 0 : _a2.document.textDocument;
        window_default.onDidChangeActiveTextEditor((editor) => {
          const oldActive = this.activeTextDocument;
          let textDocument = this.activeTextDocument = editor == null ? void 0 : editor.document.textDocument;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (textDocument != null)
            this.backgroundScheduler.remove(textDocument);
        }, null, disposables);
        const openFeature = client.getFeature(import_node3.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.original;
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        const shouldPull = (textDocument, mode) => {
          if (diagnosticPullOptions.filter && diagnosticPullOptions.filter(textDocument, mode))
            return false;
          if (!this.diagnosticRequestor.knows(1 /* document */, textDocument))
            return false;
          return true;
        };
        if (diagnosticPullOptions.onChange === true) {
          const changeFeature = client.getFeature(import_node3.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = workspace_default.getDocument(event.original.bufnr).textDocument;
            if (event.original.contentChanges.length == 0)
              return;
            if (shouldPull(textDocument, "onType" /* onType */)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave === true) {
          const saveFeature = client.getFeature(import_node3.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (shouldPull(textDocument, "onSave" /* onSave */)) {
              this.diagnosticRequestor.pull(event.original, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        const closeFeature = client.getFeature(import_node3.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          this.cleanUpDocument(event.original);
        }));
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of workspace_default.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        window_default.onDidChangeVisibleTextEditors((editors) => {
          const handled = /* @__PURE__ */ new Set();
          const tracking = this.diagnosticRequestor.trackingDocuments();
          editors.forEach((editor) => {
            let { uri, textDocument } = editor.document;
            if (handled.has(uri))
              return;
            handled.add(uri);
            if (matches(textDocument) && !tracking.includes(uri)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          });
          tracking.forEach((uri) => {
            if (handled.has(uri))
              return;
            let doc = workspace_default.getDocument(uri);
            if (doc && doc.attached)
              this.cleanUpDocument(doc.textDocument);
          });
        }, null, disposables);
        if (options2.workspaceDiagnostics === true && options2.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = import_node3.Disposable.create(() => [...disposables, this.backgroundScheduler, this.diagnosticRequestor].forEach((d) => d.dispose()));
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      knows(kind, textDocument) {
        return this.diagnosticRequestor.knows(kind, textDocument);
      }
      cleanUpDocument(document2) {
        if (this.diagnosticRequestor.knows(1 /* document */, document2)) {
          this.diagnosticRequestor.forgetDocument(document2);
          this.backgroundScheduler.remove(document2);
        }
      }
    };
    DiagnosticFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = true;
        ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        let [id, options2] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options2)
          return;
        client.onRequest(import_node3.DiagnosticRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = new DiagnosticFeatureProviderImpl(this._client, options2);
        return [provider.disposable, provider];
      }
    };
  }
});

// src/language-client/documentHighlight.ts
var DocumentHighlightFeature;
var init_documentHighlight = __esm({
  "src/language-client/documentHighlight.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    DocumentHighlightFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "documentHighlight"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentHighlights: (document2, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document3, position2, token2) => {
              return this.sendRequest(
                import_node3.DocumentHighlightRequest.type,
                asTextDocumentPositionParams(document3, position2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
          }
        };
        return [languages_default.registerDocumentHighlightProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/documentLink.ts
var DocumentLinkFeature;
var init_documentLink = __esm({
  "src/language-client/documentLink.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    DocumentLinkFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentLinks: (document2, token) => {
            const client = this._client;
            const provideDocumentLinks = (document3, token2) => {
              return this.sendRequest(
                import_node3.DocumentLinkRequest.type,
                { textDocument: { uri: document3.uri } },
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
          },
          resolveDocumentLink: options2.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return this.sendRequest(import_node3.DocumentLinkResolveRequest.type, link2, token2, link2);
            };
            const middleware = client.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [languages_default.registerDocumentLinkProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/documentSymbol.ts
var SupportedSymbolKinds, SupportedSymbolTags, DocumentSymbolFeature;
var init_documentSymbol = __esm({
  "src/language-client/documentSymbol.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    SupportedSymbolKinds = [
      SymbolKind.File,
      SymbolKind.Module,
      SymbolKind.Namespace,
      SymbolKind.Package,
      SymbolKind.Class,
      SymbolKind.Method,
      SymbolKind.Property,
      SymbolKind.Field,
      SymbolKind.Constructor,
      SymbolKind.Enum,
      SymbolKind.Interface,
      SymbolKind.Function,
      SymbolKind.Variable,
      SymbolKind.Constant,
      SymbolKind.String,
      SymbolKind.Number,
      SymbolKind.Boolean,
      SymbolKind.Array,
      SymbolKind.Object,
      SymbolKind.Key,
      SymbolKind.Null,
      SymbolKind.EnumMember,
      SymbolKind.Struct,
      SymbolKind.Event,
      SymbolKind.Operator,
      SymbolKind.TypeParameter
    ];
    SupportedSymbolTags = [
      SymbolTag.Deprecated
    ];
    DocumentSymbolFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          meta: options2.label ? { label: options2.label } : void 0,
          provideDocumentSymbols: (document2, token) => {
            const client = this._client;
            const _provideDocumentSymbols = (document3, token2) => {
              return this.sendRequest(
                import_node3.DocumentSymbolRequest.type,
                asDocumentSymbolParams(document3),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        return [languages_default.registerDocumentSymbolProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/executeCommand.ts
var ExecuteCommandFeature;
var init_executeCommand = __esm({
  "src/language-client/executeCommand.ts"() {
    "use strict";
    init_protocol();
    init_features();
    init_commands();
    init_uuid();
    ExecuteCommandFeature = class extends BaseFeature {
      constructor(client) {
        super(client);
        this._commands = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
      }
      get registrationType() {
        return import_node3.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
          const params = {
            command,
            arguments: args
          };
          return this.sendRequest(import_node3.ExecuteCommandRequest.type, params, import_node3.CancellationToken.None);
        };
        if (data.registerOptions.commands) {
          let disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(commands_default.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }, null, true));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
  }
});

// src/language-client/fileOperations.ts
function access(target, key) {
  return target[key];
}
function assign(target, key, value) {
  target[key] = value;
}
function asCreateDeleteFilesParams(e) {
  return {
    files: e.files.map((f) => ({ uri: f.toString() }))
  };
}
function asRenameFilesParams(e) {
  return {
    files: e.files.map((f) => ({ oldUri: f.oldUri.toString(), newUri: f.newUri.toString() }))
  };
}
var FileOperationFeature, NotificationFileOperationFeature, DidCreateFilesFeature, DidRenameFilesFeature, DidDeleteFilesFeature, RequestFileOperationFeature, WillCreateFilesFeature, WillRenameFilesFeature, WillDeleteFilesFeature;
var init_fileOperations = __esm({
  "src/language-client/fileOperations.ts"() {
    "use strict";
    init_node();
    init_fs();
    init_protocol();
    init_workspace();
    init_features();
    init_uuid();
    FileOperationFeature = class extends BaseFeature {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        super(client);
        this._filters = /* @__PURE__ */ new Map();
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
      }
      getState() {
        return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        var _a2;
        const options2 = (_a2 = capabilities.workspace) == null ? void 0 : _a2.fileOperations;
        const capability = options2 !== void 0 ? access(options2, this._serverCapability) : void 0;
        if ((capability == null ? void 0 : capability.filters) !== void 0) {
          try {
            this.register({
              id: generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(
              `Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`
            );
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter2) => {
          const matcher = new minimatch.Minimatch(
            filter2.pattern.glob,
            FileOperationFeature.asMinimatchOptions(filter2.pattern.options)
          );
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter2.pattern.glob}!`);
          }
          return { scheme: filter2.scheme, matcher, kind: filter2.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id) {
        this._filters.delete(id);
      }
      dispose() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(
          event.files.map(async (item) => {
            const uri = prop(item);
            const path2 = uri.fsPath.replace(/\\/g, "/");
            for (const filters of this._filters.values()) {
              for (const filter2 of filters) {
                if (filter2.scheme !== void 0 && filter2.scheme !== uri.scheme) {
                  continue;
                }
                if (filter2.matcher.match(path2)) {
                  if (filter2.kind === void 0) {
                    return true;
                  }
                  const fileType = await getFileType(uri.fsPath);
                  if (fileType === void 0) {
                    this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                    return true;
                  }
                  if (fileType === 1 /* File */ && filter2.kind === import_node3.FileOperationPatternKind.file || fileType === 2 /* Directory */ && filter2.kind === import_node3.FileOperationPatternKind.folder) {
                    return true;
                  }
                } else if (filter2.kind === import_node3.FileOperationPatternKind.folder) {
                  const fileType = await getFileType(uri.fsPath);
                  if (fileType === 2 /* Directory */ && filter2.matcher.match(`${path2}/`)) {
                    return true;
                  }
                }
              }
            }
            return false;
          })
        );
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
      }
      static asMinimatchOptions(options2) {
        if (options2 === void 0) {
          return void 0;
        }
        if (options2.ignoreCase === true) {
          return { nocase: true };
        }
        return void 0;
      }
    };
    NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            if (!this._client.isRunning())
              return;
            return this._client.sendNotification(
              this._notificationType,
              this._createParams(event)
            );
          };
          let promise = this.doSend(filteredEvent, next);
          if (promise) {
            await promise.catch((e) => {
              this._client.error(`Sending notification ${this.registrationType.method} failed`, e);
            });
          }
        }
      }
    };
    DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidCreateFiles,
          import_node3.DidCreateFilesNotification.type,
          "didCreate",
          "didCreate",
          (i) => i,
          (e) => asCreateDeleteFilesParams(e)
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.didCreateFiles) ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    DidRenameFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidRenameFiles,
          import_node3.DidRenameFilesNotification.type,
          "didRename",
          "didRename",
          (i) => i.oldUri,
          (e) => asRenameFilesParams(e)
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.didRenameFiles) ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    DidDeleteFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidDeleteFiles,
          import_node3.DidDeleteFilesNotification.type,
          "didDelete",
          "didDelete",
          (i) => i,
          (e) => asCreateDeleteFilesParams(e)
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.didDeleteFiles) ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this.sendRequest(this._requestType, this._createParams(event), import_node3.CancellationToken.None);
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillCreateFiles,
          import_node3.WillCreateFilesRequest.type,
          "willCreate",
          "willCreate",
          (i) => i,
          (e) => asCreateDeleteFilesParams(e)
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.willCreateFiles) ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillRenameFiles,
          import_node3.WillRenameFilesRequest.type,
          "willRename",
          "willRename",
          (i) => i.oldUri,
          (e) => asRenameFilesParams(e)
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.willRenameFiles) ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillDeleteFiles,
          import_node3.WillDeleteFilesRequest.type,
          "willDelete",
          "willDelete",
          (i) => i,
          (e) => asCreateDeleteFilesParams(e)
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.willDeleteFiles) ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
  }
});

// src/language-client/fileSystemWatcher.ts
var debounceTime5, FileSystemWatcherFeature;
var init_fileSystemWatcher2 = __esm({
  "src/language-client/fileSystemWatcher.ts"() {
    "use strict";
    init_util();
    init_is();
    init_node();
    init_protocol();
    init_workspace();
    init_features();
    init_converter();
    init_uuid();
    debounceTime5 = getConditionValue(200, 20);
    FileSystemWatcherFeature = class {
      constructor(_client) {
        this._client = _client;
        this._watchers = /* @__PURE__ */ new Map();
        this._fileEventsMap = /* @__PURE__ */ new Map();
        this.debouncedFileNotify = debounce(() => {
          void this._notifyFileEvent();
        }, debounceTime5);
      }
      async _notifyFileEvent() {
        let map = this._fileEventsMap;
        if (map.size == 0)
          return;
        await this._client.forceDocumentSync();
        this._client.sendNotification(import_node3.DidChangeWatchedFilesNotification.type, { changes: Array.from(map.values()) }).catch((error) => {
          this._client.error(`Notify file events failed.`, error);
        });
        map.clear();
      }
      notifyFileEvent(event) {
        let self = this;
        function didChangeWatchedFile(event2) {
          self._fileEventsMap.set(event2.uri, event2);
          self.debouncedFileNotify();
        }
        const workSpaceMiddleware = this._client.middleware.workspace;
        if (workSpaceMiddleware == null ? void 0 : workSpaceMiddleware.didChangeWatchedFile) {
          void workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile);
        } else {
          didChangeWatchedFile(event);
        }
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
      }
      get registrationType() {
        return import_node3.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
      }
      initialize(_capabilities, _documentSelector) {
        var _a2;
        let fileEvents = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.fileEvents;
        if (!fileEvents)
          return;
        let watchers = Array.isArray(fileEvents) ? fileEvents : [fileEvents];
        let disposables = [];
        for (let fileSystemWatcher of watchers) {
          disposables.push(fileSystemWatcher);
          this.hookListeners(
            fileSystemWatcher,
            !fileSystemWatcher.ignoreCreateEvents,
            !fileSystemWatcher.ignoreChangeEvents,
            !fileSystemWatcher.ignoreDeleteEvents,
            disposables
          );
        }
        this._watchers.set(generateUuid(), disposables);
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          let globPattern;
          if (string(watcher.globPattern)) {
            globPattern = watcher.globPattern;
          } else if (import_node3.RelativePattern.is(watcher.globPattern)) {
            globPattern = asRelativePattern(watcher.globPattern);
          } else {
            continue;
          }
          let watchCreate = true;
          let watchChange = true;
          let watchDelete = true;
          if (watcher.kind != null) {
            watchCreate = (watcher.kind & import_node3.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & import_node3.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & import_node3.WatchKind.Delete) !== 0;
          }
          let fileSystemWatcher = workspace_default.createFileSystemWatcher(
            globPattern,
            !watchCreate,
            !watchChange,
            !watchDelete
          );
          this.hookListeners(
            fileSystemWatcher,
            watchCreate,
            watchChange,
            watchDelete,
            disposables
          );
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate(
            (resource) => this.notifyFileEvent({
              uri: asUri(resource),
              type: import_node3.FileChangeType.Created
            }),
            null,
            listeners
          );
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange(
            (resource) => this.notifyFileEvent({
              uri: asUri(resource),
              type: import_node3.FileChangeType.Changed
            }),
            null,
            listeners
          );
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete(
            (resource) => this.notifyFileEvent({
              uri: asUri(resource),
              type: import_node3.FileChangeType.Deleted
            }),
            null,
            listeners
          );
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
          this._watchers.delete(id);
        }
      }
      dispose() {
        this._fileEventsMap.clear();
        this.debouncedFileNotify.clear();
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
  }
});

// src/language-client/foldingRange.ts
var FoldingRangeFeature;
var init_foldingRange = __esm({
  "src/language-client/foldingRange.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    FoldingRangeFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [import_node3.FoldingRangeKind.Comment, import_node3.FoldingRangeKind.Imports, import_node3.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideFoldingRanges: (document2, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document3, _, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return this.sendRequest(import_node3.FoldingRangeRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
          }
        };
        return [languages_default.registerFoldingRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/formatting.ts
var DocumentFormattingFeature, DocumentRangeFormattingFeature, DocumentOnTypeFormattingFeature;
var init_formatting2 = __esm({
  "src/language-client/formatting.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    DocumentFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "formatting"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentFormattingEdits: (document2, options3, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document3, options4, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                options: options4
              };
              return this.sendRequest(import_node3.DocumentFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options3, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options3, token);
          }
        };
        return [
          languages_default.registerDocumentFormatProvider(options2.documentSelector, provider, this._client.clientOptions.formatterPriority),
          provider
        ];
      }
    };
    DocumentRangeFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "rangeFormatting"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentRangeFormattingEdits: (document2, range, options3, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document3, range2, options4, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                range: range2,
                options: options4
              };
              return this.sendRequest(import_node3.DocumentRangeFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options3, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options3, token);
          }
        };
        return [languages_default.registerDocumentRangeFormatProvider(options2.documentSelector, provider), provider];
      }
    };
    DocumentOnTypeFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideOnTypeFormattingEdits: (document2, position, ch, options3, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document3, position2, ch2, options4, token2) => {
              const params = {
                textDocument: asVersionedTextDocumentIdentifier(document3),
                position: position2,
                ch: ch2,
                options: options4
              };
              return this.sendRequest(import_node3.DocumentOnTypeFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options3, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options3, token);
          }
        };
        const moreTriggerCharacter = options2.moreTriggerCharacter || [];
        const characters = [options2.firstTriggerCharacter, ...moreTriggerCharacter];
        return [languages_default.registerOnTypeFormattingEditProvider(options2.documentSelector, provider, characters), provider];
      }
    };
  }
});

// src/language-client/hover.ts
var HoverFeature;
var init_hover = __esm({
  "src/language-client/hover.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    HoverFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = ensure(
          ensure(capabilities, "textDocument"),
          "hover"
        );
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = this._client.supportedMarkupKind;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideHover: (document2, position, token) => {
            const client = this._client;
            const provideHover = (document3, position2, token2) => {
              return this.sendRequest(
                import_node3.HoverRequest.type,
                asTextDocumentPositionParams(document3, position2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
          }
        };
        return [languages_default.registerHoverProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/implementation.ts
var ImplementationFeature;
var init_implementation = __esm({
  "src/language-client/implementation.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    ImplementationFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const implementationSupport = ensure(ensure(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideImplementation: (document2, position, token) => {
            const client = this._client;
            const provideImplementation = (document3, position2, token2) => this.sendRequest(import_node3.ImplementationRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
          }
        };
        return [languages_default.registerImplementationProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/inlayHint.ts
var InlayHintsFeature;
var init_inlayHint = __esm({
  "src/language-client/inlayHint.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    InlayHintsFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.InlayHintRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const inlayHint = ensure(ensure(capabilities, "textDocument"), "inlayHint");
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
          properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
        };
        ensure(ensure(capabilities, "workspace"), "inlayHint").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(import_node3.InlayHintRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlayHints.fire();
          }
        });
        const [id, options2] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const eventEmitter = new import_node3.Emitter();
        const provider = {
          onDidChangeInlayHints: eventEmitter.event,
          provideInlayHints: (document2, range, token) => {
            const client = this._client;
            const provideInlayHints = (document3, range2, token2) => {
              const requestParams = {
                textDocument: asTextDocumentIdentifier(document3),
                range: range2
              };
              return this.sendRequest(import_node3.InlayHintRequest.type, requestParams, token2, null);
            };
            const middleware = client.middleware;
            return middleware.provideInlayHints ? middleware.provideInlayHints(document2, range, token, provideInlayHints) : provideInlayHints(document2, range, token);
          }
        };
        provider.resolveInlayHint = options2.resolveProvider === true ? (hint, token) => {
          const client = this._client;
          const resolveInlayHint = (item, token2) => {
            return this.sendRequest(import_node3.InlayHintResolveRequest.type, item, token2);
          };
          const middleware = client.middleware;
          return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
        } : void 0;
        const selector = options2.documentSelector;
        return [languages_default.registerInlayHintsProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
      }
    };
  }
});

// src/language-client/inlineValue.ts
var InlineValueFeature;
var init_inlineValue = __esm({
  "src/language-client/inlineValue.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    InlineValueFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.InlineValueRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "inlineValue").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(import_node3.InlineValueRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlineValues.fire();
          }
        });
        const [id, options2] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const eventEmitter = new import_node3.Emitter();
        const provider = {
          onDidChangeInlineValues: eventEmitter.event,
          provideInlineValues: (document2, viewPort, context, token) => {
            const client = this._client;
            const provideInlineValues = (document3, range, context2, token2) => {
              const requestParams = {
                textDocument: asTextDocumentIdentifier(document3),
                range,
                context: context2
              };
              return this.sendRequest(import_node3.InlineValueRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideInlineValues ? middleware.provideInlineValues(document2, viewPort, context, token, provideInlineValues) : provideInlineValues(document2, viewPort, context, token);
          }
        };
        const selector = options2.documentSelector;
        return [languages_default.registerInlineValuesProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
      }
    };
  }
});

// src/language-client/linkedEditingRange.ts
var LinkedEditingFeature;
var init_linkedEditingRange = __esm({
  "src/language-client/linkedEditingRange.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    LinkedEditingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure(ensure(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options2] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideLinkedEditingRanges: (document2, position, token) => {
            const client = this._client;
            const provideLinkedEditing = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_node3.LinkedEditingRangeRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
          }
        };
        return [languages_default.registerLinkedEditingRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/progressPart.ts
function validPercent(n) {
  if (typeof n !== "number")
    return false;
  return n >= 0 && n <= 100;
}
var ProgressPart;
var init_progressPart = __esm({
  "src/language-client/progressPart.ts"() {
    "use strict";
    init_util();
    init_protocol();
    init_window();
    ProgressPart = class {
      constructor(client, token, done) {
        this.client = client;
        this.token = token;
        this.disposables = [];
        this._cancelled = false;
        this._percent = 0;
        this._started = false;
        this.disposables.push(client.onProgress(import_node3.WorkDoneProgress.type, this.token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done(value.message);
              done && done(this);
              break;
          }
        }));
      }
      begin(params) {
        if (this._started || this._cancelled)
          return false;
        this._started = true;
        void window_default.withProgress({
          source: `language-client-${this.client.id}`,
          cancellable: params.cancellable,
          title: params.title
        }, (progress, token) => {
          this.progress = progress;
          this.report(params);
          if (this._cancelled)
            return Promise.resolve();
          this.disposables.push(token.onCancellationRequested(() => {
            this.client.sendNotification(import_node3.WorkDoneProgressCancelNotification.type, { token: this.token });
            this.cancel();
          }));
          return new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        });
        return true;
      }
      report(params) {
        if (!this.progress)
          return;
        let msg = {};
        if (params.message)
          msg.message = params.message;
        if (validPercent(params.percentage)) {
          msg.increment = params.percentage - this._percent;
          this._percent = params.percentage;
        }
        if (Object.keys(msg).length > 0) {
          this.progress.report(msg);
        }
      }
      cancel() {
        if (this._cancelled)
          return;
        this.cleanUp();
        if (this._reject !== void 0) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done(message) {
        if (this.progress) {
          let msg = {};
          if (message)
            msg.message = message;
          if (typeof this._percent === "number" && this._percent > 0)
            msg.increment = 100 - this._percent;
          this.progress.report(msg);
        }
        this.cleanUp();
        if (this._resolve) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      cleanUp() {
        this._cancelled = true;
        this.progress = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/language-client/progress.ts
var ProgressFeature;
var init_progress2 = __esm({
  "src/language-client/progress.ts"() {
    "use strict";
    init_protocol();
    init_features();
    init_progressPart();
    ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = /* @__PURE__ */ new Set();
      }
      get method() {
        return import_node3.WorkDoneProgressCreateRequest.method;
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "window").workDoneProgress = true;
      }
      getState() {
        return { kind: "window", id: import_node3.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
      }
      initialize() {
        let client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(import_node3.WorkDoneProgressCreateRequest.type, createHandler);
      }
      dispose() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
  }
});

// src/language-client/reference.ts
var ReferencesFeature;
var init_reference = __esm({
  "src/language-client/reference.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    ReferencesFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "references"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideReferences: (document2, position, options3, token) => {
            const client = this._client;
            const _providerReferences = (document3, position2, options4, token2) => {
              return this.sendRequest(
                import_node3.ReferencesRequest.type,
                asReferenceParams(document3, position2, options4),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document2, position, options3, token, _providerReferences) : _providerReferences(document2, position, options3, token);
          }
        };
        return [languages_default.registerReferencesProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/rename.ts
var RenameFeature;
var init_rename = __esm({
  "src/language-client/rename.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_is();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    RenameFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.honorsChangeAnnotations = true;
        rename.prepareSupportDefaultBehavior = import_node3.PrepareSupportDefaultBehavior.Identifier;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options2) {
          return;
        }
        if (boolean(capabilities.renameProvider)) {
          options2.prepareProvider = false;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideRenameEdits: (document2, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document3, position2, newName2, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                position: position2,
                newName: newName2
              };
              return this.sendRequest(import_node3.RenameRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
          },
          prepareRename: options2.prepareProvider ? (document2, position, token) => {
            const client = this._client;
            const prepareRename = (document3, position2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                position: position2
              };
              return this.sendRequest(import_node3.PrepareRenameRequest.type, params, token2).then((result) => {
                if (!result)
                  return null;
                if (Range.is(result)) {
                  return result;
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && Range.is(result.range)) {
                  return {
                    range: result.range,
                    placeholder: result.placeholder
                  };
                }
              });
            };
            const middleware = client.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
          } : void 0
        };
        return [languages_default.registerRenameProvider(options2.documentSelector, provider), provider];
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && boolean(candidate.defaultBehavior);
      }
    };
  }
});

// src/language-client/selectionRange.ts
var SelectionRangeFeature;
var init_selectionRange = __esm({
  "src/language-client/selectionRange.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    SelectionRangeFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options2] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideSelectionRanges: (document2, positions, token) => {
            const client = this._client;
            const provideSelectionRanges = (document3, positions2, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri },
                positions: positions2
              };
              return this.sendRequest(import_node3.SelectionRangeRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions, token, provideSelectionRanges) : provideSelectionRanges(document2, positions, token);
          }
        };
        return [languages_default.registerSelectionRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/semanticTokens.ts
var SemanticTokensFeature;
var init_semanticTokens = __esm({
  "src/language-client/semanticTokens.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_is();
    init_protocol();
    init_features();
    init_converter();
    SemanticTokensFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          SemanticTokenTypes.namespace,
          SemanticTokenTypes.type,
          SemanticTokenTypes.class,
          SemanticTokenTypes.enum,
          SemanticTokenTypes.interface,
          SemanticTokenTypes.struct,
          SemanticTokenTypes.typeParameter,
          SemanticTokenTypes.parameter,
          SemanticTokenTypes.variable,
          SemanticTokenTypes.property,
          SemanticTokenTypes.enumMember,
          SemanticTokenTypes.event,
          SemanticTokenTypes.function,
          SemanticTokenTypes.method,
          SemanticTokenTypes.macro,
          SemanticTokenTypes.keyword,
          SemanticTokenTypes.modifier,
          SemanticTokenTypes.comment,
          SemanticTokenTypes.string,
          SemanticTokenTypes.number,
          SemanticTokenTypes.regexp,
          SemanticTokenTypes.decorator,
          SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
          SemanticTokenModifiers.declaration,
          SemanticTokenModifiers.definition,
          SemanticTokenModifiers.readonly,
          SemanticTokenModifiers.static,
          SemanticTokenModifiers.deprecated,
          SemanticTokenModifiers.abstract,
          SemanticTokenModifiers.async,
          SemanticTokenModifiers.modification,
          SemanticTokenModifiers.documentation,
          SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [import_node3.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        ensure(ensure(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_node3.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options2] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const fullProvider = boolean(options2.full) ? options2.full : options2.full !== void 0;
        const hasEditProvider = options2.full !== void 0 && typeof options2.full !== "boolean" && options2.full.delta === true;
        const eventEmitter = new import_node3.Emitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document2, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentSemanticTokens = (document3, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3)
              };
              return this.sendRequest(import_node3.SemanticTokensRequest.type, params, token2);
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                previousResultId: previousResultId2
              };
              return this.sendRequest(import_node3.SemanticTokensDeltaRequest.type, params, token2);
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options2.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document2, range, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                range: range2
              };
              return this.sendRequest(import_node3.SemanticTokensRangeRequest.type, params, token2);
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
          }
        } : void 0;
        const disposables = [];
        if (documentProvider !== void 0) {
          disposables.push(languages_default.registerDocumentSemanticTokensProvider(options2.documentSelector, documentProvider, options2.legend));
        }
        if (rangeProvider !== void 0) {
          disposables.push(languages_default.registerDocumentRangeSemanticTokensProvider(options2.documentSelector, rangeProvider, options2.legend));
        }
        return [import_node3.Disposable.create(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
  }
});

// src/language-client/signatureHelp.ts
var SignatureHelpFeature;
var init_signatureHelp = __esm({
  "src/language-client/signatureHelp.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    init_uuid();
    SignatureHelpFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.contextSupport = true;
        config.signatureInformation = {
          documentationFormat: this._client.supportedMarkupKind,
          activeParameterSupport: true,
          parameterInformation: {
            labelOffsetSupport: true
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options2)
          return;
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideSignatureHelp: (document2, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document3, position2, context2, token2) => {
              return this.sendRequest(
                import_node3.SignatureHelpRequest.type,
                asSignatureHelpParams(document3, position2, context2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
          }
        };
        const disposable = languages_default.registerSignatureHelpProvider(options2.documentSelector, provider, options2.triggerCharacters);
        return [disposable, provider];
      }
    };
  }
});

// src/language-client/textSynchronization.ts
var DidOpenTextDocumentFeature, DidCloseTextDocumentFeature, DidChangeTextDocumentFeature, WillSaveFeature, WillSaveWaitUntilFeature, DidSaveTextDocumentFeature;
var init_textSynchronization = __esm({
  "src/language-client/textSynchronization.ts"() {
    "use strict";
    init_protocol();
    init_workspace();
    init_features();
    init_converter();
    init_uuid();
    DidOpenTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client, _syncedDocuments) {
        super(
          client,
          workspace_default.onDidOpenTextDocument,
          import_node3.DidOpenTextDocumentNotification.type,
          "didOpen",
          (textDocument) => asOpenTextDocumentParams(textDocument),
          TextDocumentEventFeature.textDocumentFilter
        );
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_node3.DidOpenTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector)
          return;
        workspace_default.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri;
          if (this._syncedDocuments.has(uri))
            return;
          void this.callback(textDocument);
        });
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    DidCloseTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client, _syncedDocuments) {
        super(
          client,
          workspace_default.onDidCloseTextDocument,
          import_node3.DidCloseTextDocumentNotification.type,
          "didClose",
          (textDocument) => asCloseTextDocumentParams(textDocument),
          TextDocumentEventFeature.textDocumentFilter
        );
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_node3.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "synchronization"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id) {
        let selector = this._selectors.get(id);
        if (!selector)
          return;
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (workspace_default.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.middleware;
            let didClose = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            let promise = middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument);
            if (promise) {
              promise.catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
            }
          }
        });
      }
    };
    DidChangeTextDocumentFeature = class extends DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._changeData = /* @__PURE__ */ new Map();
        this._onNotificationSent = new import_node3.Emitter();
      }
      *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
          yield data.documentSelector;
        }
      }
      get registrationType() {
        return import_node3.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== import_node3.TextDocumentSyncKind.None) {
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign(
              {},
              { documentSelector },
              { syncKind: textDocumentSyncOptions.change }
            )
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector)
          return;
        if (!this._listener) {
          this._listener = workspace_default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        let doc = workspace_default.getDocument(event.textDocument.uri);
        let { textDocument } = doc;
        const promises = [];
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, textDocument) > 0) {
            let middleware = this._client.middleware;
            let promise;
            let didChange;
            if (changeData.syncKind === import_node3.TextDocumentSyncKind.Incremental) {
              didChange = async (event2) => {
                const params = asChangeTextDocumentParams(event2);
                await this._client.sendNotification(import_node3.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, import_node3.DidChangeTextDocumentNotification.type, params);
              };
            } else if (changeData.syncKind === import_node3.TextDocumentSyncKind.Full) {
              didChange = async (event2) => {
                const params = asFullChangeTextDocumentParams(textDocument);
                await this._client.sendNotification(import_node3.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, import_node3.DidChangeTextDocumentNotification.type, params);
              };
            } else {
              didChange = () => Promise.resolve(void 0);
            }
            promise = middleware.didChange ? middleware.didChange(event, didChange) : didChange(event);
            if (promise)
              promises.push(promise);
          }
        }
        return Promise.all(promises).then(void 0, (error) => {
          this._client.error(`Sending document notification ${import_node3.DidChangeTextDocumentNotification.type.method} failed`, error);
          throw error;
        });
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
      }
      unregister(id) {
        this._changeData.delete(id);
      }
      dispose() {
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, document2) > 0) {
            return {
              send: (event) => {
                return this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
    };
    WillSaveFeature = class extends TextDocumentEventFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillSaveTextDocument,
          import_node3.WillSaveTextDocumentNotification.type,
          "willSave",
          (willSaveEvent) => asWillSaveTextDocumentParams(willSaveEvent),
          (selectors, willSaveEvent) => TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document)
        );
      }
      get registrationType() {
        return import_node3.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    WillSaveWaitUntilFeature = class extends DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._selectors = /* @__PURE__ */ new Map();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      get registrationType() {
        return import_node3.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && documentSelector.length > 0 && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (TextDocumentEventFeature.textDocumentFilter(
          this._selectors.values(),
          event.document
        )) {
          let middleware = this._client.middleware;
          let willSaveWaitUntil = (event2) => {
            return this.sendRequest(
              import_node3.WillSaveTextDocumentWaitUntilRequest.type,
              asWillSaveTextDocumentParams(event2),
              import_node3.CancellationToken.None
            );
          };
          event.waitUntil(
            middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event)
          );
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    DidSaveTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidSaveTextDocument,
          import_node3.DidSaveTextDocumentNotification.type,
          "didSave",
          (textDocument) => asSaveTextDocumentParams(textDocument, this._includeText),
          TextDocumentEventFeature.textDocumentFilter
        );
        this._includeText = false;
      }
      get registrationType() {
        return import_node3.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
    };
  }
});

// src/language-client/typeDefinition.ts
var TypeDefinitionFeature;
var init_typeDefinition = __esm({
  "src/language-client/typeDefinition.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    TypeDefinitionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const typeDefinitionSupport = ensure(ensure(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideTypeDefinition: (document2, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document3, position2, token2) => this.sendRequest(import_node3.TypeDefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
          }
        };
        return [languages_default.registerTypeDefinitionProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/typeHierarchy.ts
var TypeHierarchyFeature;
var init_typeHierarchy = __esm({
  "src/language-client/typeHierarchy.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_converter();
    TypeHierarchyFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node3.TypeHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "typeHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const client = this._client;
        const selector = options2.documentSelector;
        const provider = {
          prepareTypeHierarchy: (document2, position, token) => {
            const prepareTypeHierarchy = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_node3.TypeHierarchyPrepareRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document2, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document2, position, token);
          },
          provideTypeHierarchySupertypes: (item, token) => {
            const provideTypeHierarchySupertypes = (item2, token2) => {
              return this.sendRequest(import_node3.TypeHierarchySupertypesRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
          },
          provideTypeHierarchySubtypes: (item, token) => {
            const provideTypeHierarchySubtypes = (item2, token2) => {
              return this.sendRequest(import_node3.TypeHierarchySubtypesRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
          }
        };
        return [languages_default.registerTypeHierarchyProvider(selector, provider), provider];
      }
    };
  }
});

// src/language-client/utils/index.ts
function getLocale() {
  const lang = process.env.LANG;
  if (!lang)
    return "en";
  return lang.split(".")[0];
}
function toMethod(type) {
  return string(type) ? type : type.method;
}
function currentTimeStamp() {
  return getTimestamp(new Date());
}
function getTraceMessage(data) {
  if (data.isLSPMessage && data.type) {
    return `[LSP   - ${currentTimeStamp()}] `;
  }
  return `[Trace - ${currentTimeStamp()}] `;
}
function data2String(data, color = false) {
  if (data instanceof import_node3.ResponseError) {
    const responseError = data;
    return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
  }
  if (data instanceof Error) {
    if (string(data.stack)) {
      return data.stack;
    }
    return data.message;
  }
  if (string(data)) {
    return data;
  }
  return (0, import_util.inspect)(data, false, null, color);
}
function parseTraceData(data) {
  if (typeof data !== "string")
    return data2String(data);
  let prefixes = ["Params: ", "Result: "];
  for (let prefix of prefixes) {
    if (data.startsWith(prefix)) {
      try {
        let obj = JSON.parse(data.slice(prefix.length));
        return prefix + data2String(obj, true);
      } catch (_e) {
        return data;
      }
    }
  }
  return data;
}
var init_utils = __esm({
  "src/language-client/utils/index.ts"() {
    "use strict";
    init_logger();
    init_is();
    init_node();
    init_protocol();
  }
});

// src/language-client/utils/errorHandler.ts
var CloseAction, ErrorAction, DefaultErrorHandler;
var init_errorHandler = __esm({
  "src/language-client/utils/errorHandler.ts"() {
    "use strict";
    CloseAction = /* @__PURE__ */ ((CloseAction2) => {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
      return CloseAction2;
    })(CloseAction || {});
    ErrorAction = /* @__PURE__ */ ((ErrorAction2) => {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
      return ErrorAction2;
    })(ErrorAction || {});
    DefaultErrorHandler = class {
      constructor(name2, maxRestartCount) {
        this.name = name2;
        this.maxRestartCount = maxRestartCount;
        this.milliseconds = 3 * 60 * 1e3;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return 1 /* Continue */;
        }
        return 2 /* Shutdown */;
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < this.maxRestartCount) {
          return 2 /* Restart */;
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= this.milliseconds) {
            console.error(`The "${this.name}" server crashed ${this.maxRestartCount} times in the last 3 minutes. The server will not be restarted.`);
            return 1 /* DoNotRestart */;
          } else {
            this.restarts.shift();
            return 2 /* Restart */;
          }
        }
      }
    };
  }
});

// src/language-client/utils/logger.ts
var logger31, ConsoleLogger, NullLogger;
var init_logger2 = __esm({
  "src/language-client/utils/logger.ts"() {
    "use strict";
    init_logger();
    logger31 = createLogger("language-client");
    ConsoleLogger = class {
      error(message) {
        logger31.error(message);
      }
      warn(message) {
        logger31.warn(message);
      }
      info(message) {
        logger31.info(message);
      }
      log(message) {
        logger31.log(message);
      }
    };
    NullLogger = class {
      error(_message) {
      }
      warn(_message) {
      }
      info(_message) {
      }
      log(_message) {
      }
    };
  }
});

// src/language-client/workspaceFolders.ts
function access2(target, key) {
  if (target === void 0) {
    return void 0;
  }
  return target[key];
}
function arrayDiff(left, right) {
  return left.filter((element) => !right.includes(element));
}
var WorkspaceFoldersFeature;
var init_workspaceFolders = __esm({
  "src/language-client/workspaceFolders.ts"() {
    "use strict";
    init_esm();
    init_fs();
    init_protocol();
    init_workspace();
    init_uuid();
    WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return import_node3.DidChangeWorkspaceFoldersNotification.type;
      }
      getValidWorkspaceFolders() {
        let { workspaceFolders } = workspace_default;
        if (!workspaceFolders || workspaceFolders.length == 0)
          return void 0;
        let ignoredRootPaths = this._client.clientOptions.ignoredRootPaths ?? [];
        let arr = workspaceFolders.filter((o) => {
          let fsPath2 = URI.parse(o.uri).fsPath;
          return ignoredRootPaths.every((p) => !sameFile(p, fsPath2));
        });
        return arr.length ? arr : void 0;
      }
      fillInitializeParams(params) {
        const folders = this.getValidWorkspaceFolders();
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          this._client.warn(`No valid workspaceFolder exists`);
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        let client = this._client;
        client.onRequest(import_node3.WorkspaceFoldersRequest.type, (token) => {
          let workspaceFolders = () => {
            let folders = this.getValidWorkspaceFolders();
            if (folders === void 0) {
              return null;
            }
            let result = folders.map((folder) => this.asProtocol(folder));
            return result;
          };
          const middleware = client.middleware.workspace;
          return (middleware == null ? void 0 : middleware.workspaceFolders) ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access2(access2(access2(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value) {
          id = generateUuid();
        }
        if (id) {
          this.register({
            id,
            registerOptions: void 0
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        return this._client.sendNotification(import_node3.DidChangeWorkspaceFoldersNotification.type, params);
      }
      sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            promise = this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          promise = this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise) {
          promise.catch((error) => {
            this._client.error(`Sending notification ${import_node3.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        }
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = workspace_default.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (e) => {
            return this.doSendEvent(e.added, e.removed);
          };
          let middleware = client.middleware.workspace;
          const promise = (middleware == null ? void 0 : middleware.didChangeWorkspaceFolders) ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
          if (promise) {
            promise.catch((error) => {
              this._client.error(`Sending notification ${import_node3.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          }
        });
        this._listeners.set(id, disposable);
        let workspaceFolders = this.getValidWorkspaceFolders();
        this.sendInitialEvent(workspaceFolders);
      }
      unregister(id) {
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder == null)
          return null;
        return { uri: workspaceFolder.uri, name: workspaceFolder.name };
      }
    };
  }
});

// src/language-client/workspaceSymbol.ts
var WorkspaceFeature, WorkspaceSymbolFeature;
var init_workspaceSymbol = __esm({
  "src/language-client/workspaceSymbol.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_documentSymbol();
    init_features();
    init_uuid();
    WorkspaceFeature = class extends BaseFeature {
      constructor(_client, _registrationType) {
        super(_client);
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      getState() {
        const registrations = this._registrations.size > 0;
        return { kind: "workspace", id: this._registrationType.method, registrations };
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        const registration = this._registrations.get(id);
        if (registration)
          registration.disposable.dispose();
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, import_node3.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ["location.range"] };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return this.sendRequest(import_node3.WorkspaceSymbolRequest.type, { query: query2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          },
          resolveWorkspaceSymbol: options2.resolveProvider === true ? (item, token) => {
            const client = this._client;
            const resolveWorkspaceSymbol = (item2, token2) => {
              return this.sendRequest(import_node3.WorkspaceSymbolResolveRequest.type, item2, token2);
            };
            const middleware = client.middleware;
            return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
          } : void 0
        };
        return [languages_default.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
  }
});

// src/language-client/client.ts
function createConnection(input, output, errorHandler, closeHandler, options2) {
  let logger57 = new ConsoleLogger();
  let connection = (0, import_node3.createProtocolConnection)(input, output, logger57, options2);
  connection.onError((data) => {
    errorHandler(data[0], data[1], data[2]);
  });
  connection.onClose(closeHandler);
  let result = {
    id: "",
    hasPendingResponse: () => connection.hasPendingResponse(),
    listen: () => connection.listen(),
    sendRequest: (type, ...params) => {
      return connection.sendRequest(toMethod(type), ...params);
    },
    onRequest: (type, handler) => connection.onRequest(toMethod(type), handler),
    sendNotification: (type, params) => {
      return connection.sendNotification(toMethod(type), params);
    },
    onNotification: (type, handler) => connection.onNotification(toMethod(type), handler),
    onProgress: connection.onProgress,
    sendProgress: connection.sendProgress,
    trace: (value, tracer, sendNotificationOrTraceOptions) => {
      return connection.trace(value, tracer, sendNotificationOrTraceOptions);
    },
    initialize: (params) => {
      return connection.sendRequest(import_node3.InitializeRequest.type, params);
    },
    shutdown: () => {
      return connection.sendRequest(import_node3.ShutdownRequest.type, void 0);
    },
    exit: () => {
      return connection.sendNotification(import_node3.ExitNotification.type);
    },
    end: () => connection.end(),
    dispose: () => connection.dispose()
  };
  return result;
}
var logger32, redOpen, redClose, RevealOutputChannelOn, State, ClientState, MessageTransports, _BaseLanguageClient, BaseLanguageClient, ProposedFeatures;
var init_client = __esm({
  "src/language-client/client.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_logger();
    init_util();
    init_array();
    init_errors();
    init_fs();
    init_is();
    init_node();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_callHierarchy();
    init_codeAction();
    init_codeLens();
    init_colorProvider();
    init_completion();
    init_configuration4();
    init_declaration();
    init_definition();
    init_diagnostic();
    init_documentHighlight();
    init_documentLink();
    init_documentSymbol();
    init_executeCommand();
    init_features();
    init_fileOperations();
    init_fileSystemWatcher2();
    init_foldingRange();
    init_formatting2();
    init_hover();
    init_implementation();
    init_inlayHint();
    init_inlineValue();
    init_linkedEditingRange();
    init_progress2();
    init_progressPart();
    init_reference();
    init_rename();
    init_selectionRange();
    init_semanticTokens();
    init_signatureHelp();
    init_textSynchronization();
    init_typeDefinition();
    init_typeHierarchy();
    init_utils();
    init_converter();
    init_errorHandler();
    init_logger2();
    init_uuid();
    init_workspaceFolders();
    init_workspaceSymbol();
    logger32 = createLogger("language-client-client");
    redOpen = "\x1B[31m";
    redClose = "\x1B[39m";
    RevealOutputChannelOn = /* @__PURE__ */ ((RevealOutputChannelOn2) => {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
      return RevealOutputChannelOn2;
    })(RevealOutputChannelOn || {});
    State = /* @__PURE__ */ ((State2) => {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Running"] = 2] = "Running";
      State2[State2["Starting"] = 3] = "Starting";
      return State2;
    })(State || {});
    ClientState = /* @__PURE__ */ ((ClientState2) => {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
      return ClientState2;
    })(ClientState || {});
    ((MessageTransports2) => {
      function is(value) {
        let candidate = value;
        return candidate && import_node3.MessageReader.is(value.reader) && import_node3.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (MessageTransports = {}));
    _BaseLanguageClient = class {
      constructor(id, name2, clientOptions) {
        this._consoleDebug = false;
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this._id = id;
        this._name = name2;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
        } else {
          this._outputChannel = void 0;
        }
        this._clientOptions = this.resolveClientOptions(clientOptions);
        this.$state = 0 /* Initial */;
        this._connection = void 0;
        this._initializeResult = void 0;
        this._listeners = [];
        this._diagnostics = void 0;
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
        this._notificationDisposables = /* @__PURE__ */ new Map();
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._pendingRequestHandlers = /* @__PURE__ */ new Map();
        this._requestDisposables = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._pendingProgressHandlers = /* @__PURE__ */ new Map();
        this._progressDisposables = /* @__PURE__ */ new Map();
        this._ignoredRegistrations = /* @__PURE__ */ new Set();
        this._onStop = void 0;
        this._stateChangeEmitter = new import_node3.Emitter();
        this._trace = import_node3.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      switchConsole() {
        this._consoleDebug = !this._consoleDebug;
        if (!this._consoleDebug) {
          this.enableVerboseTrace();
        }
      }
      resolveClientOptions(clientOptions) {
        var _a2;
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown != null) {
          markdown.isTrusted = clientOptions.markdown.isTrusted === true;
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        let disableSnippetCompletion = clientOptions.disableSnippetCompletion;
        let disableMarkdown = clientOptions.disableMarkdown;
        if (disableMarkdown === void 0) {
          disableMarkdown = workspace_default.initialConfiguration.get("coc.preferences.enableMarkdown") === false;
        }
        const pullConfig = workspace_default.getConfiguration("pullDiagnostic", clientOptions.workspaceFolder);
        let pullOption = clientOptions.diagnosticPullOptions ?? {};
        if (pullOption.onChange === void 0)
          pullOption.onChange = pullConfig.get("onChange");
        if (pullOption.onSave === void 0)
          pullOption.onSave = pullConfig.get("onSave");
        if (pullOption.workspace === void 0)
          pullOption.workspace = pullConfig.get("workspace");
        pullOption.ignored = pullConfig.get("ignored", []).concat(pullOption.ignored ?? []);
        let disabledFeatures = clientOptions.disabledFeatures ?? [];
        for (let key of ["disableCompletion", "disableWorkspaceFolders", "disableDiagnostics"]) {
          if (typeof clientOptions[key] === "boolean") {
            let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
            logger32.warn(`${key} in the client options is deprecated. use disabledFeatures instead.`, stack);
            if (clientOptions[key] === true) {
              let s = key.slice(7);
              disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
            }
          }
        }
        let separateDiagnostics = clientOptions.separateDiagnostics;
        if (clientOptions.separateDiagnostics === void 0) {
          separateDiagnostics = workspace_default.getConfiguration("diagnostic", clientOptions.workspaceFolder).get("separateRelatedInformationAsDiagnostics");
        }
        return {
          disabledFeatures,
          disableMarkdown,
          disableSnippetCompletion,
          separateDiagnostics,
          diagnosticPullOptions: pullOption,
          rootPatterns: clientOptions.rootPatterns ?? [],
          requireRootPattern: clientOptions.requireRootPattern,
          disableDynamicRegister: clientOptions.disableDynamicRegister,
          formatterPriority: clientOptions.formatterPriority ?? 0,
          ignoredRootPaths: clientOptions.ignoredRootPaths ?? [],
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._id,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? 4 /* Never */,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: clientOptions.progressOnInitialization === true,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler((_a2 = clientOptions.connectionOptions) == null ? void 0 : _a2.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown
        };
      }
      get supportedMarkupKind() {
        if (!this.clientOptions.disableMarkdown)
          return [MarkupKind.Markdown, MarkupKind.PlainText];
        return [MarkupKind.PlainText];
      }
      get state() {
        return this.getPublicState();
      }
      get $state() {
        return this._state;
      }
      set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      get middleware() {
        return this._clientOptions.middleware;
      }
      getPublicState() {
        if (this.$state === 3 /* Running */) {
          return 2 /* Running */;
        } else if (this.$state === 1 /* Starting */) {
          return 3 /* Starting */;
        } else {
          return 1 /* Stopped */;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        this.checkState();
        try {
          const connection = await this.$start();
          return await connection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${toMethod(type)} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        const method = toMethod(type);
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._requestDisposables.set(method, connection.onRequest(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingRequestHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingRequestHandlers.delete(method);
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._requestHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendNotification(type, params) {
        if (this.$state === 2 /* StartFailed */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */) {
          return;
        }
        try {
          const connection = await this.$start();
          return await connection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${toMethod(type)} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        const method = toMethod(type);
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._notificationDisposables.set(method, connection.onNotification(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingNotificationHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingNotificationHandlers.delete(method);
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._notificationHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
        const realHandler = import_node3.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
        if (connection !== void 0) {
          this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
          disposable = {
            dispose: () => {
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        } else {
          this._pendingProgressHandlers.set(token, { type, handler });
          disposable = {
            dispose: () => {
              this._pendingProgressHandlers.delete(token);
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._progressHandlers.delete(token);
            disposable.dispose();
          }
        };
      }
      async sendProgress(type, token, value) {
        this.checkState();
        try {
          const connection = await this.$start();
          await connection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      get configuredSection() {
        var _a2;
        let section2 = (_a2 = this._clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
        return typeof section2 === "string" && section2.startsWith("languageserver.") ? section2 : void 0;
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          let { outputChannelName } = this._clientOptions;
          this._outputChannel = window_default.createOutputChannel(defaultValue(outputChannelName, this._name));
        }
        return this._outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler(maxRestartCount) {
        return new DefaultErrorHandler(this._id, maxRestartCount ?? 4);
      }
      set trace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== void 0) {
          void connection.trace(this._trace, this._tracer, {
            sendNotification: false,
            traceFormat: this._traceFormat
          });
        }
      }
      logObjectTrace(data) {
        this.outputChannel.append(getTraceMessage(data));
        this.traceData(data);
      }
      traceData(data, error = false) {
        this.outputChannel.appendLine(data2String(data));
        if (this._consoleDebug)
          error ? console.error(redOpen + data2String(data) + redClose) : console.log(parseTraceData(data));
      }
      consoleMessage(prefix, message, error = false) {
        if (this._consoleDebug) {
          let msg = prefix + " " + message;
          error ? console.error(redOpen + msg + redClose) : console.log(msg);
        }
      }
      info(message, data, showNotification = true) {
        let prefix = `[Info  - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null)
          this.traceData(data);
        if (showNotification && this._clientOptions.revealOutputChannelOn <= 1 /* Info */) {
          this.showNotificationMessage(import_node3.MessageType.Info, message);
        }
      }
      warn(message, data, showNotification = true) {
        let prefix = `[Warn  - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null)
          this.traceData(data);
        if (showNotification && this._clientOptions.revealOutputChannelOn <= 2 /* Warn */) {
          this.showNotificationMessage(import_node3.MessageType.Warning, message);
        }
      }
      error(message, data, showNotification = true) {
        let prefix = `[Error - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message, true);
        if (data != null)
          this.traceData(data, true);
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= 3 /* Error */) {
          this.showNotificationMessage(import_node3.MessageType.Error, message);
        }
      }
      logTrace(message, data) {
        let prefix = `[Trace - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null)
          this.traceData(data);
      }
      showNotificationMessage(type, message) {
        const messageFunc = type === import_node3.MessageType.Error ? window_default.showErrorMessage.bind(window_default) : type === import_node3.MessageType.Warning ? window_default.showWarningMessage.bind(window_default) : window_default.showInformationMessage.bind(window_default);
        void messageFunc(message);
      }
      needsStart() {
        return this.$state === 0 /* Initial */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */;
      }
      needsStop() {
        return this.$state === 1 /* Starting */ || this.$state === 3 /* Running */;
      }
      activeConnection() {
        return this.$state === 3 /* Running */ && this._connection !== void 0 ? this._connection : void 0;
      }
      get hasPendingResponse() {
        var _a2;
        return (_a2 = this._connection) == null ? void 0 : _a2.hasPendingResponse();
      }
      onReady() {
        if (this._onStart)
          return this._onStart;
        return new Promise((resolve) => {
          let disposable = this.onDidChangeState((e) => {
            if (e.newState === 2 /* Running */) {
              disposable.dispose();
              resolve();
            }
          });
        });
      }
      get started() {
        return this.$state != 0 /* Initial */;
      }
      isRunning() {
        return this.$state === 3 /* Running */;
      }
      async _start() {
        if (this._disposed === "disposing" || this._disposed === "disposed") {
          throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === 4 /* Stopping */) {
          throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        if (this._onStart !== void 0) {
          return this._onStart;
        }
        this._rootPath = this.resolveRootPath();
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        if (this._diagnostics === void 0) {
          let opts = this._clientOptions;
          let name2 = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
          if (!opts.disabledFeatures.includes("diagnostics")) {
            this._diagnostics = languages_default.createDiagnosticCollection(name2);
          }
        }
        for (const [method, handler] of this._notificationHandlers) {
          if (!this._pendingNotificationHandlers.has(method)) {
            this._pendingNotificationHandlers.set(method, handler);
          }
        }
        for (const [method, handler] of this._requestHandlers) {
          if (!this._pendingRequestHandlers.has(method)) {
            this._pendingRequestHandlers.set(method, handler);
          }
        }
        for (const [token, data] of this._progressHandlers) {
          if (!this._pendingProgressHandlers.has(token)) {
            this._pendingProgressHandlers.set(token, data);
          }
        }
        this.$state = 1 /* Starting */;
        try {
          const connection = await this.createConnection();
          this.handleConnectionEvents(connection);
          connection.listen();
          await this.initialize(connection);
          resolve();
        } catch (error) {
          this.$state = 2 /* StartFailed */;
          this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
          reject(error);
        }
        return this._onStart;
      }
      start() {
        let p = this._start();
        p.dispose = () => {
          if (this.needsStop()) {
            void this.stop();
          }
        };
        return p;
      }
      async $start() {
        if (this.$state === 2 /* StartFailed */) {
          throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this._start();
        const connection = this.activeConnection();
        if (connection === void 0) {
          throw new Error(`Starting server failed`);
        }
        return connection;
      }
      handleConnectionEvents(connection) {
        connection.onNotification(import_node3.LogMessageNotification.type, (message) => {
          switch (message.type) {
            case import_node3.MessageType.Error:
              this.error(message.message);
              break;
            case import_node3.MessageType.Warning:
              this.warn(message.message);
              break;
            case import_node3.MessageType.Info:
              this.info(message.message);
              break;
            default:
              this.outputChannel.appendLine(message.message);
          }
        });
        connection.onNotification(import_node3.ShowMessageNotification.type, (message) => {
          switch (message.type) {
            case import_node3.MessageType.Error:
              void window_default.showErrorMessage(message.message);
              break;
            case import_node3.MessageType.Warning:
              void window_default.showWarningMessage(message.message);
              break;
            case import_node3.MessageType.Info:
              void window_default.showInformationMessage(message.message);
              break;
            default:
              void window_default.showInformationMessage(message.message);
          }
        });
        connection.onRequest(import_node3.ShowMessageRequest.type, (params) => {
          let messageFunc;
          switch (params.type) {
            case import_node3.MessageType.Error:
              messageFunc = window_default.showErrorMessage.bind(window_default);
              break;
            case import_node3.MessageType.Warning:
              messageFunc = window_default.showWarningMessage.bind(window_default);
              break;
            case import_node3.MessageType.Info:
              messageFunc = window_default.showInformationMessage.bind(window_default);
              break;
            default:
              messageFunc = window_default.showInformationMessage.bind(window_default);
          }
          let actions = toArray(params.actions);
          return messageFunc(params.message, ...actions).then((res) => {
            return res == null ? null : res;
          });
        });
        connection.onRequest(import_node3.ShowDocumentRequest.type, async (params) => {
          var _a2;
          const showDocument = async (params2) => {
            try {
              if (params2.external === true || /^https?:\/\//.test(params2.uri)) {
                await workspace_default.openResource(params2.uri);
                return { success: true };
              } else {
                let { selection, takeFocus } = params2;
                if (takeFocus === false) {
                  await workspace_default.loadFile(params2.uri);
                } else {
                  await workspace_default.jumpTo(params2.uri, selection == null ? void 0 : selection.start);
                  if (selection && comparePosition(selection.start, selection.end) != 0) {
                    await window_default.selectRange(selection);
                  }
                }
                return { success: true };
              }
            } catch (error) {
              return { success: false };
            }
          };
          const middleware = (_a2 = this._clientOptions.middleware.window) == null ? void 0 : _a2.showDocument;
          if (middleware !== void 0) {
            return middleware(params, showDocument);
          } else {
            return showDocument(params);
          }
        });
      }
      createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        return [promise, resolve, reject];
      }
      resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
          return URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths, rootPatterns, requireRootPattern } = this._clientOptions;
        let resolved;
        if (!isFalsyOrEmpty(rootPatterns)) {
          resolved = workspace_default.documentsManager.resolveRoot(rootPatterns, requireRootPattern);
        }
        let rootPath = resolved || workspace_default.rootPath;
        if (sameFile(rootPath, os.homedir()) || ignoredRootPaths.some((p) => sameFile(rootPath, p))) {
          this.warn(`Ignored rootPath ${rootPath} of client "${this._id}"`);
          return null;
        }
        return rootPath;
      }
      initialize(connection) {
        let { initializationOptions, workspaceFolder, progressOnInitialization } = this._clientOptions;
        this.refreshTrace(connection, false);
        let rootPath = this._rootPath;
        let initParams = {
          processId: process.pid,
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? asUri(URI.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: func(initializationOptions) ? initializationOptions() : initializationOptions,
          trace: import_node3.Trace.toString(this._trace),
          workspaceFolders: workspaceFolder ? [workspaceFolder] : null,
          locale: getLocale(),
          clientInfo: {
            name: "coc.nvim",
            version: workspace_default.version
          }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
          const token = generateUuid();
          initParams.workDoneToken = token;
          connection.id = this._id;
          const part = new ProgressPart(connection, token);
          part.begin({ title: `Initializing ${this.id}`, kind: "begin" });
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.done();
            return Promise.reject(error);
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      async doInitialize(connection, initParams) {
        try {
          const result = await connection.initialize(initParams);
          if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== import_node3.PositionEncodingKind.UTF16) {
            await connection.shutdown();
            await connection.exit();
            connection.end();
            connection.dispose();
            throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
          }
          this._initializeResult = result;
          this.$state = 3 /* Running */;
          let textDocumentSyncOptions;
          if (number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === import_node3.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: import_node3.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onNotification(import_node3.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
          connection.onRequest(import_node3.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(import_node3.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(import_node3.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          for (const [method, handler] of this._pendingNotificationHandlers) {
            this._notificationDisposables.set(method, connection.onNotification(method, handler));
          }
          this._pendingNotificationHandlers.clear();
          for (const [method, handler] of this._pendingRequestHandlers) {
            this._requestDisposables.set(method, connection.onRequest(method, handler));
          }
          this._pendingRequestHandlers.clear();
          for (const [token, data] of this._pendingProgressHandlers) {
            this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
          }
          this._pendingProgressHandlers.clear();
          await connection.sendNotification(import_node3.InitializedNotification.type, {});
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          return result;
        } catch (error) {
          let cb = (retry) => {
            if (retry) {
              this.initialize(connection).catch(() => {
              });
            } else {
              this.stop().catch(() => {
              });
            }
          };
          if (this._clientOptions.initializationFailedHandler) {
            cb(this._clientOptions.initializationFailedHandler(error));
          } else if (error instanceof import_node3.ResponseError && error.data && error.data.retry) {
            if (this._connection) {
              let connection2 = this._connection;
              connection2.end();
              this._connection.dispose();
              this._connection = null;
            }
            void window_default.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              cb(item && item.id === "retry");
            });
          } else {
            void window_default.showErrorMessage(toText(error.message));
            this.error("Server initialization failed.", error);
            logger32.error(`Server ${this.id} initialization failed.`, error);
            cb(false);
          }
          throw error;
        }
      }
      stop(timeout2 = 2e3) {
        return this.shutdown("stop", timeout2);
      }
      async shutdown(mode, timeout2) {
        if (this.$state === 5 /* Stopped */ || this.$state === 0 /* Initial */) {
          return;
        }
        if (this.$state === 4 /* Stopping */) {
          return this._onStop;
        }
        const connection = this.activeConnection();
        if (connection === void 0 || this.$state !== 3 /* Running */ && this.$state !== 1 /* Starting */) {
          throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = void 0;
        this.$state = 4 /* Stopping */;
        this.cleanUp(mode);
        let tm;
        const tp = new Promise((c) => {
          tm = setTimeout(c, timeout2);
        });
        const shutdown = (async (connection2) => {
          await connection2.shutdown();
          await connection2.exit();
          return connection2;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
          if (tm)
            clearTimeout(tm);
          if (connection2 !== void 0) {
            connection2.end();
            connection2.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error);
          throw error;
        }).finally(() => {
          this.$state = 5 /* Stopped */;
          mode === "stop" && this.cleanUpChannel();
          this._onStart = void 0;
          this._onStop = void 0;
          this._connection = void 0;
          this._ignoredRegistrations.clear();
        });
      }
      dispose(timeout2 = 2e3) {
        if (this._disposed)
          return;
        try {
          this._disposed = "disposing";
          if (!this.needsStop())
            return;
          return this.stop(timeout2);
        } finally {
          this._disposed = "disposed";
        }
      }
      cleanUp(mode) {
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = [];
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (let feature of this._features.values()) {
          if (typeof feature.dispose === "function") {
            feature.dispose();
          }
        }
        if (mode === "stop" && this._diagnostics) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      async forceDocumentSync() {
        let textDocuments = Array.from(this._syncedDocuments.values());
        await Promise.all(textDocuments.map((textDocument) => {
          let doc = workspace_default.getDocument(textDocument.uri);
          return doc ? doc.synchronize() : null;
        }));
      }
      handleDiagnostics(params) {
        let { uri, diagnostics, version: version2 } = params;
        if (number(version2) && !workspace_default.hasDocument(uri, version2))
          return;
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
          middleware(
            uri,
            diagnostics,
            (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2)
          );
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      async createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        const transports = await this.createMessageTransports(defaultValue(this._clientOptions.stdioEncoding, "utf8"));
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
      }
      handleConnectionClosed() {
        if (this.$state === 5 /* Stopped */) {
          logger32.debug(`client ${this._id} normal closed`);
          return;
        }
        try {
          if (this._connection) {
            this._connection.dispose();
          }
        } catch (error) {
        }
        let action = 1 /* DoNotRestart */;
        if (this.$state !== 4 /* Stopping */ && this._clientOptions.errorHandler) {
          try {
            action = this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connection = void 0;
        if (action === 1 /* DoNotRestart */) {
          this.error("Connection to server got closed. Server will not be restarted.", void 0, "force");
          this.cleanUp("stop");
          if (this.$state === 1 /* Starting */) {
            this.$state = 2 /* StartFailed */;
          } else {
            this.$state = 5 /* Stopped */;
          }
          this._onStop = Promise.resolve();
          this._onStart = void 0;
        } else if (action === 2 /* Restart */) {
          this.info("Connection to server got closed. Server will restart.");
          this.cleanUp("restart");
          this.$state = 0 /* Initial */;
          this._onStop = Promise.resolve();
          this._onStart = void 0;
          this.start().catch(this.error.bind(this, `Restarting server failed`));
        }
      }
      checkState() {
        if (this.$state === 2 /* StartFailed */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */) {
          throw new import_node3.ResponseError(import_node3.ErrorCodes.ConnectionInactive, `Client is not running`);
        }
      }
      handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === 2 /* Shutdown */) {
          this.error(`Client ${this._name}: connection to server is erroring. Shutting down server.`, void 0, "force");
          this.stop().catch(this.error.bind(this, `Stopping server failed`));
        }
      }
      hookConfigurationChanged(connection) {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._id)) {
            this.refreshTrace(connection, true);
          }
        }, null, this._listeners);
      }
      refreshTrace(connection, sendNotification) {
        let config = workspace_default.getConfiguration(this._id, this.clientOptions.workspaceFolder);
        let trace = import_node3.Trace.Off;
        let traceFormat = import_node3.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = import_node3.Trace.fromString(traceConfig);
          } else {
            trace = import_node3.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = import_node3.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        if (sendNotification && this._trace == trace && this._traceFormat == traceFormat) {
          return;
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        }).catch(this.error.bind(this, `Updating trace failed with error`));
      }
      enableVerboseTrace() {
        this._trace = import_node3.Trace.Verbose;
        this._traceFormat = import_node3.TraceFormat.Text;
        this._connection.trace(this._trace, this._tracer, {
          sendNotification: true,
          traceFormat: this._traceFormat
        }).catch(this.error.bind(this, `Updating trace failed with error`));
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature, "");
        }
      }
      registerFeature(feature, name2) {
        let { disabledFeatures } = this._clientOptions;
        if (disabledFeatures.length > 0 && disabledFeatures.includes(name2))
          return;
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getStaticFeature(method) {
        return this._features.find((o) => StaticFeature.is(o) && o.method == method);
      }
      getFeature(request2) {
        return this._dynamicFeatures.get(request2);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new SyncConfigurationFeature(this), "configuration");
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments), "document");
        this.registerFeature(new DidChangeTextDocumentFeature(this), "document");
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments), "document");
        this.registerFeature(new WillSaveFeature(this), "willSave");
        this.registerFeature(new WillSaveWaitUntilFeature(this), "willSaveWaitUntil");
        this.registerFeature(new DidSaveTextDocumentFeature(this), "didSave");
        this.registerFeature(new FileSystemWatcherFeature(this), "fileSystemWatcher");
        this.registerFeature(new CompletionItemFeature(this), "completion");
        this.registerFeature(new HoverFeature(this), "hover");
        this.registerFeature(new SignatureHelpFeature(this), "signatureHelp");
        this.registerFeature(new ReferencesFeature(this), "references");
        this.registerFeature(new DefinitionFeature(this), "definition");
        this.registerFeature(new DocumentHighlightFeature(this), "documentHighlight");
        this.registerFeature(new DocumentSymbolFeature(this), "documentSymbol");
        this.registerFeature(new CodeActionFeature(this), "codeAction");
        this.registerFeature(new CodeLensFeature(this), "codeLens");
        this.registerFeature(new DocumentFormattingFeature(this), "documentFormatting");
        this.registerFeature(new DocumentRangeFormattingFeature(this), "documentRangeFormatting");
        this.registerFeature(new DocumentOnTypeFormattingFeature(this), "documentOnTypeFormatting");
        this.registerFeature(new RenameFeature(this), "rename");
        this.registerFeature(new DocumentLinkFeature(this), "documentLink");
        this.registerFeature(new ExecuteCommandFeature(this), "executeCommand");
        this.registerFeature(new PullConfigurationFeature(this), "pullConfiguration");
        this.registerFeature(new TypeDefinitionFeature(this), "typeDefinition");
        this.registerFeature(new ImplementationFeature(this), "implementation");
        this.registerFeature(new DeclarationFeature(this), "declaration");
        this.registerFeature(new ColorProviderFeature(this), "colorProvider");
        this.registerFeature(new FoldingRangeFeature(this), "foldingRange");
        this.registerFeature(new SelectionRangeFeature(this), "selectionRange");
        this.registerFeature(new CallHierarchyFeature(this), "callHierarchy");
        this.registerFeature(new ProgressFeature(this), "progress");
        this.registerFeature(new LinkedEditingFeature(this), "linkedEditing");
        this.registerFeature(new DidCreateFilesFeature(this), "fileEvents");
        this.registerFeature(new DidRenameFilesFeature(this), "fileEvents");
        this.registerFeature(new DidDeleteFilesFeature(this), "fileEvents");
        this.registerFeature(new WillCreateFilesFeature(this), "fileEvents");
        this.registerFeature(new WillRenameFilesFeature(this), "fileEvents");
        this.registerFeature(new WillDeleteFilesFeature(this), "fileEvents");
        this.registerFeature(new SemanticTokensFeature(this), "semanticTokens");
        this.registerFeature(new InlayHintsFeature(this), "inlayHint");
        this.registerFeature(new InlineValueFeature(this), "inlineValue");
        this.registerFeature(new DiagnosticFeature(this), "pullDiagnostic");
        this.registerFeature(new TypeHierarchyFeature(this), "typeHierarchy");
        this.registerFeature(new WorkspaceSymbolFeature(this), "workspaceSymbol");
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new WorkspaceFoldersFeature(this), "workspaceFolders");
        }
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        ensure(result, "workspace").applyEdit = true;
        const workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [import_node3.ResourceOperationKind.Create, import_node3.ResourceOperationKind.Rename, import_node3.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = import_node3.FailureHandlingKind.Undo;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: false
        };
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = true;
        diagnostics.tagSupport = { valueSet: [DiagnosticTag.Unnecessary, DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, "window");
        const showMessage = ensure(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = ensure(result, "general");
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = { parser: "marked", version: "4.0.10" };
        generalCapabilities.positionEncodings = ["utf-16"];
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(_BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          if (func(feature.preInitialize)) {
            feature.preInitialize(this._capabilities, documentSelector);
          }
        }
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        if (this.clientOptions.disableDynamicRegister)
          return;
        if (!this.isRunning()) {
          for (const registration of params.registrations) {
            this._ignoredRegistrations.add(registration.id);
          }
          return;
        }
        for (const registration of params.registrations) {
          const feature = this._dynamicFeatures.get(registration.method);
          if (!feature) {
            this.error(`No feature implementation for ${registration.method} found. Registration failed.`);
            return;
          }
          const options2 = registration.registerOptions ?? {};
          options2.documentSelector = options2.documentSelector ?? this._clientOptions.documentSelector;
          const data = {
            id: registration.id,
            registerOptions: options2
          };
          feature.register(data);
        }
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve) => {
          for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id))
              continue;
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (feature)
              feature.unregister(unregistration.id);
          }
          resolve();
        });
      }
      setDiagnostics(uri, diagnostics) {
        var _a2;
        if (!this._diagnostics)
          return;
        const separate = this.clientOptions.separateDiagnostics;
        if (separate && diagnostics.length > 0) {
          const entries = /* @__PURE__ */ new Map();
          entries.set(uri, diagnostics);
          for (const diagnostic of diagnostics) {
            if ((_a2 = diagnostic.relatedInformation) == null ? void 0 : _a2.length) {
              let message = `${diagnostic.message}

Related diagnostics:
`;
              for (const info of diagnostic.relatedInformation) {
                const basename = path.basename(URI.parse(info.location.uri).fsPath);
                const ln = info.location.range.start.line;
                message = `${message}
${basename}(line ${ln + 1}): ${info.message}`;
                const diags = entries.get(info.location.uri) || [];
                diags.push(Diagnostic.create(info.location.range, info.message, DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
                entries.set(info.location.uri, diags);
              }
              diagnostic.message = message;
            }
            this._diagnostics.set(Array.from(entries));
          }
        } else {
          this._diagnostics.set(uri, diagnostics);
        }
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = /* @__PURE__ */ new Map();
        workspace_default.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return workspace_default.applyEdit(params.edit).then((value) => {
          return { applied: value };
        });
      }
      handleFailedRequest(type, token, error, defaultValue2) {
        if (token && token.isCancellationRequested)
          return defaultValue2;
        if (error instanceof import_node3.ResponseError) {
          if (error.code === import_node3.ErrorCodes.PendingResponseRejected || error.code === import_node3.ErrorCodes.ConnectionInactive) {
            return defaultValue2;
          }
          if (error.code === import_node3.LSPErrorCodes.RequestCancelled || error.code === import_node3.LSPErrorCodes.ServerCancelled) {
            if (error.data != null) {
              throw new LSPCancellationError(error.data);
            } else {
              throw new CancellationError();
            }
          } else if (error.code === import_node3.LSPErrorCodes.ContentModified) {
            if (_BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
              throw new CancellationError();
            } else {
              return defaultValue2;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
      }
      logFailedRequest() {
      }
    };
    BaseLanguageClient = _BaseLanguageClient;
    BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
      import_node3.InlayHintRequest.method,
      import_node3.SemanticTokensRequest.method,
      import_node3.SemanticTokensRangeRequest.method,
      import_node3.SemanticTokensDeltaRequest.method
    ]);
    ProposedFeatures = {
      createAll: (_client) => {
        let result = [];
        return result;
      }
    };
  }
});

// src/language-client/index.ts
function getRuntimePath(runtime, serverWorkingDirectory) {
  if (path.isAbsolute(runtime)) {
    return runtime;
  }
  const mainRootPath = mainGetRootPath();
  if (mainRootPath !== void 0) {
    const result = path.join(mainRootPath, runtime);
    if (fs.existsSync(result)) {
      return result;
    }
  }
  if (serverWorkingDirectory !== void 0) {
    const result = path.join(serverWorkingDirectory, runtime);
    if (fs.existsSync(result)) {
      return result;
    }
  }
  return runtime;
}
function mainGetRootPath() {
  let folders = workspace_default.workspaceFolders;
  if (!folders || folders.length === 0) {
    return void 0;
  }
  let folder = folders[0];
  return folder.uri;
}
function getServerWorkingDir(options2) {
  let cwd2 = options2 && options2.cwd;
  if (cwd2 && !path.isAbsolute(cwd2))
    cwd2 = path.join(workspace_default.cwd, cwd2);
  if (!cwd2)
    cwd2 = workspace_default.cwd;
  return new Promise((s) => {
    fs.lstat(cwd2, (err, stats) => {
      s(!err && stats.isDirectory() ? cwd2 : void 0);
    });
  });
}
function startedInDebugMode(args) {
  if (args) {
    return args.some((arg) => {
      return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
    });
  }
  return false;
}
var logger33, debugStartWith, debugEquals, STOP_TIMEOUT, Executable, TransportKind, Transport, NodeModule, StreamInfo, ChildProcessInfo, LanguageClient, SettingMonitor;
var init_language_client = __esm({
  "src/language-client/index.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_is();
    init_node();
    init_processes();
    init_protocol();
    init_workspace();
    init_client();
    init_client();
    logger33 = createLogger("language-client-index");
    debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
    debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
    STOP_TIMEOUT = getConditionValue(2e3, 100);
    ((Executable3) => {
      function is(value) {
        return string(value.command);
      }
      Executable3.is = is;
    })(Executable || (Executable = {}));
    TransportKind = /* @__PURE__ */ ((TransportKind2) => {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
      return TransportKind2;
    })(TransportKind || {});
    ((Transport3) => {
      function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === 3 /* socket */ && number(candidate.port);
      }
      Transport3.isSocket = isSocket;
    })(Transport || (Transport = {}));
    ((NodeModule2) => {
      function is(value) {
        return string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    ((StreamInfo2) => {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    ((ChildProcessInfo2) => {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    LanguageClient = class extends BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name2;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (string(arg2)) {
          id = arg1;
          name2 = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name2 = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        super(id, name2, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = !!forceDebug;
        this._isInDebugMode = !!forceDebug;
      }
      stop(timeout2 = STOP_TIMEOUT) {
        return super.stop(timeout2).then(() => {
          if (this._serverProcess) {
            let toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        }, (err) => {
          if (err.message.includes("timed out")) {
            this._serverProcess.kill("SIGKILL");
            this._serverProcess = void 0;
            return;
          }
          throw err;
        });
      }
      get serviceState() {
        return this._state;
      }
      checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === void 0)
          return;
        setTimeout(() => {
          try {
            process.kill(childProcess.pid, 0);
            terminate(childProcess);
          } catch (error) {
          }
        }, STOP_TIMEOUT);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        super.handleConnectionClosed();
      }
      get isInDebugMode() {
        return this._isInDebugMode;
      }
      async restart() {
        await this.stop();
        if (this.isInDebugMode) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          await this._start();
        } else {
          await this._start();
        }
      }
      createMessageTransports(encoding2) {
        function getEnvironment(env, fork) {
          if (!env && !fork) {
            return void 0;
          }
          let result = /* @__PURE__ */ Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (env) {
            Object.keys(env).forEach((key) => result[key] = env[key]);
          }
          return result;
        }
        function assertStdio(process2) {
          if (process2.stdin === null || process2.stdout === null || process2.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        let server = this._serverOptions;
        const logMessage = this.logMessage.bind(this);
        if (func(server)) {
          return server().then((result) => {
            if (MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return {
                reader: new import_node3.StreamMessageReader(result.reader),
                writer: new import_node3.StreamMessageWriter(result.writer)
              };
            } else {
              let cp;
              if (ChildProcessInfo.is(result)) {
                cp = result.process;
                this._isDetached = result.detached;
              } else {
                cp = result;
                this._isDetached = false;
              }
              cp.stderr.on("data", logMessage);
              return {
                reader: new import_node3.StreamMessageReader(cp.stdout),
                writer: new import_node3.StreamMessageWriter(cp.stdin)
              };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (typeof v8debug === "object" || this._forceDebug || startedInDebugMode(process.execArgv)) {
            json = runDebug.debug;
          } else {
            json = runDebug.run;
          }
        } else {
          json = server;
        }
        return getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || 0 /* stdio */;
            let pipeName;
            let runtime = node.runtime ? getRuntimePath(node.runtime, serverWorkingDir) : void 0;
            return new Promise((resolve, _reject) => {
              let args = node.args && node.args.slice() || [];
              if (transport === 1 /* ipc */) {
                args.push("--node-ipc");
              } else if (transport === 0 /* stdio */) {
                args.push("--stdio");
              } else if (transport === 2 /* pipe */) {
                pipeName = (0, import_node3.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid}`);
              let options2 = node.options || /* @__PURE__ */ Object.create(null);
              options2.env = getEnvironment(options2.env, true);
              options2.execArgv = options2.execArgv || [];
              options2.cwd = serverWorkingDir;
              options2.silent = true;
              if (runtime)
                options2.execPath = runtime;
              if (transport === 1 /* ipc */ || transport === 0 /* stdio */) {
                let sp = child_process.fork(node.module, args || [], options2);
                assertStdio(sp);
                this._serverProcess = sp;
                logger33.info(`Language server "${this.id}" started with ${sp.pid}`);
                sp.stderr.on("data", logMessage);
                if (transport === 1 /* ipc */) {
                  sp.stdout.on("data", logMessage);
                  resolve({ reader: new import_node3.IPCMessageReader(this._serverProcess), writer: new import_node3.IPCMessageWriter(this._serverProcess) });
                } else {
                  resolve({ reader: new import_node3.StreamMessageReader(sp.stdout), writer: new import_node3.StreamMessageWriter(sp.stdin) });
                }
              } else if (transport === 2 /* pipe */) {
                return (0, import_node3.createClientPipeTransport)(pipeName).then((transport2) => {
                  let sp = child_process.fork(node.module, args || [], options2);
                  assertStdio(sp);
                  logger33.info(`Language server "${this.id}" started with ${sp.pid}`);
                  this._serverProcess = sp;
                  sp.stderr.on("data", logMessage);
                  sp.stdout.on("data", logMessage);
                  void transport2.onConnected().then((protocol2) => {
                    resolve({ reader: protocol2[0], writer: protocol2[1] });
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, import_node3.createClientSocketTransport)(transport.port).then((transport2) => {
                  let sp = child_process.fork(node.module, args || [], options2);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  logger33.info(`Language server "${this.id}" started with ${sp.pid}`);
                  sp.stderr.on("data", logMessage);
                  sp.stdout.on("data", logMessage);
                  void transport2.onConnected().then((protocol2) => {
                    resolve({ reader: protocol2[0], writer: protocol2[1] });
                  });
                });
              }
            });
          } else if (Executable.is(json) && json.command) {
            let command = json;
            let args = command.args || [];
            let options2 = Object.assign({}, command.options);
            options2.env = options2.env ? Object.assign({}, process.env, options2.env) : process.env;
            options2.cwd = options2.cwd || serverWorkingDir;
            let cmd = workspace_default.expand(json.command);
            let serverProcess = child_process.spawn(cmd, args, options2);
            serverProcess.on("error", (e) => {
              this.error(e.message, e);
            });
            if (!serverProcess || !serverProcess.pid) {
              return Promise.reject(new Error(`Launching server "${this.id}" using command ${command.command} failed.`));
            }
            logger33.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
            serverProcess.on("exit", (code) => {
              if (code != 0)
                this.error(`${command.command} exited with code: ${code}`);
            });
            serverProcess.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding2)));
            this._serverProcess = serverProcess;
            this._isDetached = !!options2.detached;
            return Promise.resolve({ reader: new import_node3.StreamMessageReader(serverProcess.stdout), writer: new import_node3.StreamMessageWriter(serverProcess.stdin) });
          }
          return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
        });
      }
      logMessage(data) {
        let encoding2 = this.clientOptions.stdioEncoding;
        this.outputChannel.append(string(data) ? data : data.toString(encoding2));
      }
    };
    SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._setting)) {
            this.onDidChangeConfiguration();
          }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
          dispose: () => {
            disposeAll(this._listeners);
            void this._client.dispose();
          }
        };
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? workspace_default.getConfiguration(primary).get(rest, true) : workspace_default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start().catch((error) => this._client.error("Start failed after configuration change", error, "force"));
        } else if (!enabled && this._client.needsStop()) {
          this._client.stop().catch((error) => this._client.error("Stop failed after configuration change", error, "force"));
        }
      }
    };
  }
});

// src/services.ts
function documentSelectorToLanguageIds(documentSelector) {
  let res = documentSelector.map((filter2) => {
    if (typeof filter2 == "string") {
      return filter2;
    }
    return filter2.language;
  });
  res = res.filter((s) => typeof s == "string");
  return Array.from(new Set(res));
}
function getLanguageServerOptions(id, name2, config, folder) {
  let { command, module: module2, port, args, filetypes } = config;
  args = args || [];
  if (!filetypes) {
    void window_default.showErrorMessage(`Wrong configuration of LS "${name2}", filetypes not found`);
    return null;
  }
  if (!command && !module2 && !port) {
    void window_default.showErrorMessage(`Wrong configuration of LS "${name2}", no command or module specified.`);
    return null;
  }
  let serverOptions;
  if (module2) {
    module2 = workspace_default.expand(module2);
    if (!fs.existsSync(module2)) {
      void window_default.showErrorMessage(`Module file "${module2}" not found for LS "${name2}"`);
      return null;
    }
    serverOptions = {
      module: module2,
      runtime: config.runtime ?? process.execPath,
      args,
      transport: getTransportKind(config),
      options: getForkOptions(config)
    };
  } else if (command) {
    serverOptions = {
      command,
      args,
      options: getSpawnOptions(config)
    };
  } else {
    serverOptions = () => new Promise((resolve, reject) => {
      let client = new net.Socket();
      let host = config.host ?? "127.0.0.1";
      logger34.info(`languageserver "${id}" connecting to ${host}:${port}`);
      client.connect(port, host, () => {
        resolve({
          reader: client,
          writer: client
        });
      });
      client.on("error", (e) => {
        reject(new Error(`Connection error for ${id}: ${e.message}`));
      });
    });
  }
  let disabledFeatures = Array.from(config.disabledFeatures || []);
  for (let key of ["disableWorkspaceFolders", "disableCompletion", "disableDiagnostics"]) {
    if (config[key] === true) {
      logger34.warn(`Language server config "${key}" is deprecated, use "disabledFeatures" instead.`);
      let s = key.slice(7);
      disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
    }
  }
  let disableSnippetCompletion = !!config.disableSnippetCompletion;
  let ignoredRootPaths = config.ignoredRootPaths ?? [];
  let clientOptions = {
    workspaceFolder: folder == null ? void 0 : { name: path.basename(folder.fsPath), uri: folder.toString() },
    rootPatterns: config.rootPatterns,
    requireRootPattern: config.requireRootPattern,
    ignoredRootPaths: ignoredRootPaths.map((s) => workspace_default.expand(s)),
    disableSnippetCompletion,
    disableDynamicRegister: !!config.disableDynamicRegister,
    disabledFeatures,
    formatterPriority: config.formatterPriority,
    documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
    revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
    synchronize: {
      configurationSection: `${id}.settings`
    },
    diagnosticCollectionName: name2,
    outputChannelName: id,
    stdioEncoding: config.stdioEncoding,
    progressOnInitialization: config.progressOnInitialization === true,
    initializationOptions: config.initializationOptions ?? {}
  };
  return [clientOptions, serverOptions];
}
function isValidServerConfig(key, config) {
  let errors = [];
  let fields = ["module", "command", "transport"];
  for (let field of fields) {
    let val = config[field];
    if (val && typeof val !== "string") {
      errors.push(`"${field}" field of languageserver ${key} should be string`);
    }
  }
  if (config.transportPort != null && typeof config.transportPort !== "number") {
    errors.push(`"transportPort" field of languageserver ${key} should be number`);
  }
  if (!Array.isArray(config.filetypes) || !config.filetypes.every((s) => typeof s === "string")) {
    errors.push(`"filetypes" field of languageserver ${key} should be array of string`);
  }
  if (config.additionalSchemes && (!Array.isArray(config.additionalSchemes) || config.additionalSchemes.some((s) => typeof s !== "string"))) {
    errors.push(`"additionalSchemes" field of languageserver ${key} should be array of string`);
  }
  if (errors.length) {
    logger34.error(`Invalid language server configuration for ${key}`, errors.join("\n"));
    return false;
  }
  return true;
}
function getRevealOutputChannelOn(revealOn) {
  switch (revealOn) {
    case "info":
      return 1 /* Info */;
    case "warn":
      return 2 /* Warn */;
    case "error":
      return 3 /* Error */;
    case "never":
      return 4 /* Never */;
    default:
      return 4 /* Never */;
  }
}
function getDocumentSelector(filetypes, additionalSchemes) {
  let documentSelector = [];
  let schemes = ["file", "untitled"].concat(additionalSchemes || []);
  if (!filetypes)
    return schemes.map((s) => ({ scheme: s }));
  filetypes.forEach((filetype) => {
    documentSelector.push(...schemes.map((scheme) => ({ language: filetype, scheme })));
  });
  return documentSelector;
}
function getTransportKind(config) {
  let { transport, transportPort } = config;
  if (!transport || transport == "ipc")
    return 1 /* ipc */;
  if (transport == "stdio")
    return 0 /* stdio */;
  if (transport == "pipe")
    return 2 /* pipe */;
  return { kind: 3 /* socket */, port: transportPort };
}
function getForkOptions(config) {
  return {
    cwd: config.cwd,
    execArgv: config.execArgv ?? [],
    env: config.env ?? void 0
  };
}
function getSpawnOptions(config) {
  return {
    cwd: config.cwd,
    detached: !!config.detached,
    shell: !!config.shell,
    env: config.env ?? void 0
  };
}
function convertState(state) {
  switch (state) {
    case 2 /* Running */:
      return 3 /* Running */;
    case 3 /* Starting */:
      return 1 /* Starting */;
    case 1 /* Stopped */:
      return 5 /* Stopped */;
    default:
      return void 0;
  }
}
function stateString(state) {
  switch (state) {
    case 2 /* Running */:
      return "running";
    case 3 /* Starting */:
      return "starting";
    case 1 /* Stopped */:
      return "stopped";
    default:
      return "unknown";
  }
}
function getStateName(state) {
  switch (state) {
    case 0 /* Initial */:
      return "init";
    case 3 /* Running */:
      return "running";
    case 1 /* Starting */:
      return "starting";
    case 2 /* StartFailed */:
      return "startFailed";
    case 4 /* Stopping */:
      return "stopping";
    case 5 /* Stopped */:
      return "stopped";
    default:
      return "unknown";
  }
}
var logger34, ServiceStat, ServiceManager, services_default;
var init_services = __esm({
  "src/services.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_language_client();
    init_logger();
    init_util();
    init_node();
    init_object();
    init_protocol();
    init_window();
    init_workspace();
    logger34 = createLogger("services");
    ServiceStat = /* @__PURE__ */ ((ServiceStat2) => {
      ServiceStat2[ServiceStat2["Initial"] = 0] = "Initial";
      ServiceStat2[ServiceStat2["Starting"] = 1] = "Starting";
      ServiceStat2[ServiceStat2["StartFailed"] = 2] = "StartFailed";
      ServiceStat2[ServiceStat2["Running"] = 3] = "Running";
      ServiceStat2[ServiceStat2["Stopping"] = 4] = "Stopping";
      ServiceStat2[ServiceStat2["Stopped"] = 5] = "Stopped";
      return ServiceStat2;
    })(ServiceStat || {});
    ServiceManager = class {
      constructor() {
        this.registered = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.pendingNotifications = /* @__PURE__ */ new Map();
        this.registLanguageClient = this.registerLanguageClient.bind(this);
        this.regist = this.register.bind(this);
      }
      init() {
        workspace_default.onDidOpenTextDocument((document2) => {
          void this.start(document2);
        }, null, this.disposables);
        const iterate = (folders) => {
          for (let folder of folders) {
            this.registerClientsFromFolder(folder);
          }
        };
        workspace_default.onDidChangeWorkspaceFolders((e) => {
          iterate(e.added);
        }, null, this.disposables);
        let lspConfig = workspace_default.initialConfiguration.get("languageserver", {});
        this.registerClientsByConfig(lspConfig);
        iterate(workspace_default.workspaceFolders);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("languageserver")) {
            let lspConfig2 = workspace_default.getConfiguration("languageserver", null);
            this.registerClientsByConfig(lspConfig2);
          }
        }, null, this.disposables);
      }
      registerClientsFromFolder(workspaceFolder) {
        let uri = URI.parse(workspaceFolder.uri);
        let lspConfig = workspace_default.getConfiguration(void 0, uri);
        let config = lspConfig.inspect("languageserver").workspaceFolderValue;
        this.registerClientsByConfig(config, uri);
      }
      register(service) {
        let { id } = service;
        if (this.registered.get(id))
          return;
        this.registered.set(id, service);
        this.tryStartService(service);
        service.onServiceReady(() => {
          logger34.info(`service ${id} started`);
        }, null, this.disposables);
        return import_node3.Disposable.create(() => {
          if (!this.registered.has(id))
            return;
          service.dispose();
          this.registered.delete(id);
        });
      }
      tryStartService(service) {
        if (!events_default.ready) {
          let disposable = events_default.on("ready", () => {
            disposable.dispose();
            if (this.shouldStart(service)) {
              void service.start();
            }
          });
        } else if (this.shouldStart(service)) {
          void service.start();
        }
      }
      getService(id) {
        let service = this.registered.get(id);
        if (!service)
          service = this.registered.get(`languageserver.${id}`);
        return service;
      }
      shouldStart(service) {
        if (service.state != 0 /* Initial */)
          return false;
        let selector = service.selector;
        for (let doc of workspace_default.documents) {
          if (workspace_default.match(selector, doc.textDocument)) {
            return true;
          }
        }
        return false;
      }
      async start(document2) {
        let services = [];
        for (let service of this.registered.values()) {
          if (service.state == 0 /* Initial */ && workspace_default.match(service.selector, document2) > 0) {
            services.push(service);
          }
        }
        await Promise.allSettled(services.map((service) => {
          return service.start();
        }));
      }
      stop(id) {
        let service = this.registered.get(id);
        if (service)
          return Promise.resolve(service.stop());
      }
      async toggle(id) {
        let service = this.registered.get(id);
        if (!service)
          throw new Error(`Service ${id} not found`);
        let { state } = service;
        if (state == 3 /* Running */) {
          await Promise.resolve(service.stop());
        } else if (state == 0 /* Initial */ || state == 2 /* StartFailed */) {
          await service.start();
        } else if (state == 5 /* Stopped */) {
          await service.restart();
        }
      }
      getServiceStats() {
        let res = [];
        for (let [id, service] of this.registered) {
          res.push({
            id,
            languageIds: documentSelectorToLanguageIds(service.selector),
            state: getStateName(service.state)
          });
        }
        return res;
      }
      registerClientsByConfig(lspConfig, folder) {
        for (let key of Object.keys(toObject(lspConfig))) {
          let config = lspConfig[key];
          if (!isValidServerConfig(key, config)) {
            continue;
          }
          this.registerLanguageClient(key, config, folder);
        }
      }
      async getLanguageClient(id) {
        let service = this.getService(id);
        if (!service)
          await wait(100);
        service = this.getService(id);
        if (!service || !service.client) {
          throw new Error(`Language server ${id} not found`);
        }
        return service.client;
      }
      async sendNotification(id, method, params) {
        let client = await this.getLanguageClient(id);
        await Promise.resolve(client.sendNotification(method, params));
      }
      async sendRequest(id, method, params, token) {
        let client = await this.getLanguageClient(id);
        token = token ?? import_node3.CancellationToken.None;
        return await Promise.resolve(client.sendRequest(method, params, token));
      }
      registerNotification(id, method) {
        let service = this.getService(id);
        if (service && service.client) {
          service.client.onNotification(method, async (result) => {
            this.sendNotificationVim(id, method, result);
          });
        }
        let arr = this.pendingNotifications.get(id) ?? [];
        arr.push({ id, method });
        this.pendingNotifications.set(id, arr);
      }
      getRegisteredNotifications(id) {
        id = id.startsWith("languageserver") ? id.slice("languageserver.".length) : id;
        return this.pendingNotifications.get(id) ?? [];
      }
      sendNotificationVim(id, method, result) {
        workspace_default.nvim.call("coc#do_notify", [id, method, result], true);
      }
      registerLanguageClient(name2, config, folder) {
        let id = typeof name2 === "string" ? `languageserver.${name2}` : name2.id;
        let disposables = [];
        let onDidServiceReady = new import_node3.Emitter();
        let client = typeof name2 === "string" ? null : name2;
        if (this.registered.has(id))
          return import_node3.Disposable.create(() => {
          });
        if (client && typeof client.dispose === "function")
          disposables.push(client);
        let created = false;
        let service = {
          id,
          client,
          name: typeof name2 === "string" ? name2 : name2.name,
          selector: typeof name2 === "string" ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name2.clientOptions.documentSelector,
          state: client && client.state === 2 /* Running */ ? 3 /* Running */ : 0 /* Initial */,
          onServiceReady: onDidServiceReady.event,
          start: async () => {
            if (!created) {
              if (typeof name2 == "string" && !client) {
                let config2 = workspace_default.getConfiguration(void 0, folder).get(`languageserver.${name2}`, {});
                let opts = getLanguageServerOptions(id, name2, config2, folder);
                if (!opts || config2.enable === false)
                  return;
                client = new LanguageClient(id, name2, opts[1], opts[0]);
                service.selector = opts[0].documentSelector;
                service.client = client;
                disposables.push(client);
              }
              created = true;
              for (let item of this.getRegisteredNotifications(id)) {
                service.client.onNotification(item.method, async (result) => {
                  this.sendNotificationVim(item.id, item.method, result);
                });
              }
              client.onDidChangeState((changeEvent) => {
                let { oldState, newState } = changeEvent;
                service.state = convertState(newState);
                let oldStr = stateString(oldState);
                let newStr = stateString(newState);
                logger34.info(`LanguageClient ${client.name} state change: ${oldStr} => ${newStr}`);
              }, null, disposables);
            }
            try {
              if (!client.needsStart()) {
                service.state = convertState(client.state);
              } else {
                service.state = 1 /* Starting */;
                logger34.debug(`starting service: ${id}`);
                await client.start();
                onDidServiceReady.fire(void 0);
              }
            } catch (e) {
              void window_default.showErrorMessage(`Server ${id} failed to start: ${e}`);
              logger34.error(`Server ${id} failed to start:`, e);
              service.state = 2 /* StartFailed */;
            }
          },
          dispose: async () => {
            onDidServiceReady.dispose();
            disposeAll(disposables);
          },
          stop: async () => {
            if (!client || !client.needsStop())
              return;
            await Promise.resolve(client.stop());
          },
          restart: async () => {
            if (client) {
              service.state = 1 /* Starting */;
              await client.restart();
            } else {
              await service.start();
            }
          }
        };
        return this.register(service);
      }
      dispose() {
        disposeAll(this.disposables);
        for (let service of this.registered.values()) {
          service.dispose();
        }
        this.registered.clear();
      }
    };
    services_default = new ServiceManager();
  }
});

// src/list/source/services.ts
var ServicesList;
var init_services2 = __esm({
  "src/list/source/services.ts"() {
    "use strict";
    init_services();
    init_util();
    init_basic();
    init_formatting();
    ServicesList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "toggle";
        this.description = "registered services of coc.nvim";
        this.name = "services";
        this.addAction("toggle", async (item) => {
          let { id } = item.data;
          await services_default.toggle(id);
          await wait(50);
        }, { persist: true, reload: true });
      }
      async loadItems(_context) {
        let stats = services_default.getServiceStats();
        return formatListItems(this.alignColumns, stats.map((stat) => {
          let prefix = stat.state == "running" ? "*" : " ";
          return {
            label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(", ")],
            data: { id: stat.id }
          };
        }));
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine", true);
        nvim.command("highlight default link CocServicesPrefix Special", true);
        nvim.command("highlight default link CocServicesName Type", true);
        nvim.command("highlight default link CocServicesStat Statement", true);
        nvim.command("highlight default link CocServicesLanguages Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/sources.ts
var SourcesList;
var init_sources = __esm({
  "src/list/source/sources.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_sources2();
    init_basic();
    init_formatting();
    SourcesList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "toggle";
        this.description = "registered completion sources";
        this.name = "sources";
        this.addAction("toggle", async (item) => {
          let { name: name2 } = item.data;
          sources_default.toggleSource(name2);
        }, { persist: true, reload: true });
        this.addAction("refresh", async (item) => {
          let { name: name2 } = item.data;
          await sources_default.refresh(name2);
        }, { persist: true, reload: true });
        this.addAction("open", async (item, context) => {
          let { location } = item;
          if (location)
            await this.jumpTo(location, null, context);
        });
      }
      async loadItems() {
        let stats = sources_default.sourceStats();
        return stats.map((stat) => {
          let prefix = stat.disabled ? " " : "*";
          let location;
          if (stat.filepath) {
            location = Location.create(URI.file(stat.filepath).toString(), Range.create(0, 0, 0, 0));
          }
          return {
            label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth("[" + stat.shortcut + "]", 10)} ${fixWidth(stat.triggerCharacters.join(""), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(",")}`,
            location,
            data: { name: stat.name }
          };
        });
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesPriority /\\v%46v.*%52v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine", true);
        nvim.command("highlight default link CocSourcesPrefix Special", true);
        nvim.command("highlight default link CocSourcesName Type", true);
        nvim.command("highlight default link CocSourcesPriority Number", true);
        nvim.command("highlight default link CocSourcesFileTypes Comment", true);
        nvim.command("highlight default link CocSourcesType Statement", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/symbols.ts
function toTargetLocation(location) {
  let loc = Location.create(location.uri, Range.create(location.range.start, location.range.start));
  loc.targetRange = location.range;
  return loc;
}
function sortSymbolItems(a, b) {
  if (a.data.score != b.data.score) {
    return b.data.score - a.data.score;
  }
  if (a.data.kind != b.data.kind) {
    return a.data.kind - b.data.kind;
  }
  return a.data.file.length - b.data.file.length;
}
var Symbols;
var init_symbols = __esm({
  "src/list/source/symbols.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_array();
    init_convert();
    init_node();
    init_protocol();
    init_string();
    init_workspace();
    init_formatting();
    init_location();
    Symbols = class extends LocationList {
      constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = "search workspace symbols";
        this.detail = "Symbols list is provided by server, it works on interactive mode only.";
        this.fuzzyMatch = workspace_default.createFuzzyMatch();
        this.name = "symbols";
        this.options = [{
          name: "-k, -kind KIND",
          description: "Filter symbols by kind.",
          hasValue: true
        }];
      }
      async loadItems(context, token) {
        let { input } = context;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toString().toLowerCase() : "";
        if (!languages_default.hasProvider("workspaceSymbols" /* WorkspaceSymbols */, { uri: "file:///1", languageId: "" })) {
          throw new Error("No workspace symbols provider registered");
        }
        let symbols = await languages_default.getWorkspaceSymbols(input, token);
        if (token.isCancellationRequested)
          return [];
        let config = this.getConfig();
        let excludes = config.get("excludes", []);
        let items = [];
        this.fuzzyMatch.setPattern(input, true);
        for (let s of symbols) {
          let kind = getSymbolKind(s.kind);
          if (filterKind && kind.toLowerCase() != filterKind) {
            continue;
          }
          let file = formatUri(s.location.uri, workspace_default.cwd);
          if (excludes.some((p) => minimatch(file, p))) {
            continue;
          }
          let item = this.createListItem(input, s, kind, file);
          items.push(item);
        }
        this.fuzzyMatch.free();
        items.sort(sortSymbolItems);
        return items;
      }
      async resolveItem(item) {
        let symbolItem = item.data.original;
        if (!symbolItem)
          return null;
        let tokenSource = new import_node3.CancellationTokenSource();
        let resolved = await languages_default.resolveWorkspaceSymbol(symbolItem, tokenSource.token);
        if (!resolved)
          return null;
        symbolItem.location = resolved.location;
        item.location = toTargetLocation(resolved.location);
        return item;
      }
      createListItem(input, item, kind, file) {
        let { name: name2 } = item;
        let label = "";
        let ansiHighlights = [];
        let parts = [name2, `[${kind}]`, file];
        let highlights = ["Normal", "Typedef", "Comment"];
        for (let index = 0; index < parts.length; index++) {
          const text = parts[index];
          let start = byteLength(label);
          label += text;
          let end = byteLength(label);
          if (index != parts.length - 1) {
            label += " ";
          }
          ansiHighlights.push({ span: [start, end], hlGroup: highlights[index] });
          if (index === 0 && toArray(item.tags).includes(SymbolTag.Deprecated)) {
            ansiHighlights.push({ span: [start, end], hlGroup: "CocDeprecatedHighlight" });
          }
        }
        let score3 = 0;
        if (input.length > 0) {
          let result = this.fuzzyMatch.matchHighlights(name2, "CocListSearch");
          if (result) {
            score3 = result.score;
            ansiHighlights.push(...result.highlights);
          }
        }
        return {
          label,
          filterText: "",
          ansiHighlights,
          location: toTargetLocation(item.location),
          data: {
            original: item,
            input,
            kind: item.kind,
            file,
            score: score3
          }
        };
      }
    };
  }
});

// src/list/manager.ts
function createConfigurationNode(name2, interactive, id) {
  let properties = {};
  properties[`list.source.${name2}.defaultAction`] = {
    type: "string",
    default: null,
    description: `Default action of "${name2}" list.`
  };
  properties[`list.source.${name2}.defaultOptions`] = {
    type: "array",
    default: interactive ? ["--interactive"] : [],
    description: `Default list options of "${name2}" list, only used when both list option and argument are empty.`,
    uniqueItems: true,
    items: {
      type: "string",
      enum: [
        "--top",
        "--normal",
        "--no-sort",
        "--input",
        "--height",
        "--tab",
        "--strict",
        "--regex",
        "--ignore-case",
        "--number-select",
        "--reverse",
        "--interactive",
        "--auto-preview",
        "--first",
        "--no-quit"
      ]
    }
  };
  properties[`list.source.${name2}.defaultArgs`] = {
    type: "array",
    default: [],
    description: `Default argument list of "${name2}" list, only used when list argument is empty.`,
    uniqueItems: true,
    items: { type: "string" }
  };
  let node = {
    scope: 1 /* APPLICATION */,
    properties
  };
  if (id)
    node.extensionInfo = { id };
  return node;
}
var logger35, mouseKeys, winleaveDalay, ListManager, manager_default2;
var init_manager3 = __esm({
  "src/list/manager.ts"() {
    "use strict";
    init_registry2();
    init_types();
    init_events();
    init_extension();
    init_logger();
    init_util();
    init_constants();
    init_extensionRegistry();
    init_node();
    init_protocol();
    init_registry();
    init_string();
    init_window();
    init_workspace();
    init_configuration3();
    init_history();
    init_mappings();
    init_prompt();
    init_session();
    init_commands2();
    init_diagnostics();
    init_extensions();
    init_folders();
    init_links();
    init_lists();
    init_location();
    init_outline();
    init_services2();
    init_sources();
    init_symbols();
    logger35 = createLogger("list-manager");
    mouseKeys = ["<LeftMouse>", "<LeftDrag>", "<LeftRelease>", "<2-LeftMouse>"];
    winleaveDalay = isVim ? 50 : 0;
    ListManager = class {
      constructor() {
        this.plugTs = 0;
        this.sessionsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.listMap = /* @__PURE__ */ new Map();
        InputHistory.migrate(dataHome);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      init(nvim) {
        this.prompt = new Prompt(nvim);
        this.mappings = new Mappings(this, nvim);
        let signText = configuration_default.get("selectedSignText", "*");
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_default.on("InputChar", this.onInputChar, this, this.disposables);
        events_default.on("FocusGained", async () => {
          let session = await this.getCurrentSession();
          if (session)
            this.prompt.drawPrompt();
        }, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session)
            this.prompt.start(session.listOptions);
        }, null, this.disposables);
        let timer;
        events_default.on("WinLeave", (winid) => {
          clearTimeout(timer);
          let session = this.getSessionByWinid(winid);
          if (session) {
            timer = setTimeout(() => {
              this.prompt.cancel();
            }, winleaveDalay);
          }
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.source !== 0 /* Default */ && e.affectsConfiguration("list")) {
            this.mappings.createMappings();
          }
        }, null, this.disposables);
        this.prompt.onDidChangeInput(() => {
          var _a2;
          (_a2 = this.session) == null ? void 0 : _a2.onInputChange();
        });
      }
      registerLists() {
        this.registerList(new LinksList(), true);
        this.registerList(new LocationList(), true);
        this.registerList(new Symbols(), true);
        this.registerList(new Outline(), true);
        this.registerList(new CommandsList(), true);
        this.registerList(new ExtensionList(extension_default.manager), true);
        this.registerList(new DiagnosticsList(this), true);
        this.registerList(new SourcesList(), true);
        this.registerList(new ServicesList(), true);
        this.registerList(new ListsList(this.listMap), true);
        this.registerList(new FoldList(), true);
      }
      async start(args) {
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { name: name2 } = res.list;
        let curr = this.sessionsMap.get(name2);
        if (curr)
          curr.dispose();
        this.prompt.start(res.options);
        let session = new ListSession(this.nvim, this.prompt, res.list, res.options, res.listArgs);
        this.sessionsMap.set(name2, session);
        this.lastSession = session;
        try {
          await session.start(args);
        } catch (e) {
          this.nvim.command(`echo ""`, true);
          this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
          void window_default.showErrorMessage(`Error on "CocList ${name2}": ${toErrorText(e)}`);
          this.nvim.redrawVim();
          logger35.error("Error on list start:", e);
        }
      }
      getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == winid) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async getCurrentSession() {
        let { id } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == id) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async resume(name2) {
        var _a2;
        if (!name2) {
          await ((_a2 = this.session) == null ? void 0 : _a2.resume());
        } else {
          let session = this.sessionsMap.get(name2);
          if (!session) {
            void window_default.showWarningMessage(`Can't find exists ${name2} list`);
            return;
          }
          await session.resume();
        }
      }
      async doAction(name2) {
        let lastSession = this.lastSession;
        if (!lastSession)
          return;
        await lastSession.doAction(name2);
      }
      async first(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.first();
      }
      async last(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.last();
      }
      async previous(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.previous();
      }
      async next(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.next();
      }
      getSession(name2) {
        if (!name2)
          return this.session;
        return this.sessionsMap.get(name2);
      }
      async cancel(close = true) {
        this.prompt.cancel();
        if (!close)
          return;
        if (this.session)
          await this.session.hide();
      }
      reset() {
        this.prompt.cancel();
        this.lastSession = void 0;
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      async switchMatcher() {
        var _a2;
        await ((_a2 = this.session) == null ? void 0 : _a2.switchMatcher());
      }
      async togglePreview() {
        let { nvim } = this;
        let winid = await nvim.call("coc#list#get_preview", [0]);
        if (winid != -1) {
          await nvim.call("coc#list#close_preview", []);
          await nvim.command("redraw");
        } else {
          await this.doAction("preview");
        }
      }
      async chooseAction() {
        let { lastSession } = this;
        if (lastSession)
          await lastSession.chooseAction();
      }
      parseArgs(args) {
        let options2 = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let reverse = false;
        let name2;
        let input = "";
        let matcher = "fuzzy";
        let position = "bottom";
        let listArgs = [];
        let listOptions = [];
        let height;
        for (let arg of args) {
          if (!name2 && arg.startsWith("-")) {
            listOptions.push(arg);
          } else if (!name2) {
            if (!/^\w+$/.test(arg)) {
              void window_default.showErrorMessage(`Invalid list option: "${arg}"`);
              return null;
            }
            name2 = arg;
          } else {
            listArgs.push(arg);
          }
        }
        name2 = name2 || "lists";
        let config = workspace_default.initialConfiguration.get(`list.source.${name2}`);
        if (!listOptions.length && !listArgs.length)
          listOptions = defaultValue(config == null ? void 0 : config.defaultOptions, []);
        if (!listArgs.length)
          listArgs = defaultValue(config == null ? void 0 : config.defaultArgs, []);
        for (let opt of listOptions) {
          if (opt.startsWith("--input=")) {
            input = opt.slice(8);
          } else if (opt.startsWith("--height=")) {
            height = toInteger(opt.slice(9));
          } else if (opt == "--number-select" || opt == "-N") {
            numberSelect = true;
          } else if (opt == "--auto-preview" || opt == "-A") {
            autoPreview = true;
          } else if (opt == "--regex" || opt == "-R") {
            matcher = "regex";
          } else if (opt == "--strict" || opt == "-S") {
            matcher = "strict";
          } else if (opt == "--interactive" || opt == "-I") {
            interactive = true;
          } else if (opt == "--top") {
            position = "top";
          } else if (opt == "--tab") {
            position = "tab";
          } else if (opt == "--ignore-case" || opt == "--normal" || opt == "--no-sort") {
            options2.push(opt.slice(2));
          } else if (opt == "--first") {
            first = true;
          } else if (opt == "--reverse") {
            reverse = true;
          } else if (opt == "--no-quit") {
            noQuit = true;
          } else {
            void window_default.showErrorMessage(`Invalid option "${opt}" of list`);
            return null;
          }
        }
        let list2 = this.listMap.get(name2);
        if (!list2) {
          void window_default.showErrorMessage(`List ${name2} not found`);
          return null;
        }
        if (interactive && !list2.interactive) {
          void window_default.showErrorMessage(`Interactive mode of "${name2}" list not supported`);
          return null;
        }
        return {
          list: list2,
          listArgs,
          options: {
            numberSelect,
            autoPreview,
            height,
            reverse,
            noQuit,
            first,
            input,
            interactive,
            matcher,
            position,
            ignorecase: options2.includes("ignore-case") ? true : false,
            mode: !options2.includes("normal") ? "insert" : "normal",
            sort: !options2.includes("no-sort") ? true : false
          }
        };
      }
      async onInputChar(session, ch, charmod) {
        if (!ch || session != "list")
          return;
        let { mode } = this.prompt;
        let now = Date.now();
        if (ch == "<plug>" || this.plugTs && now - this.plugTs < 20) {
          this.plugTs = now;
          return;
        }
        if (ch == "<esc>") {
          await this.cancel();
          return;
        }
        if (mode == "insert") {
          await this.onInsertInput(ch, charmod);
        } else {
          await this.onNormalInput(ch, charmod);
        }
      }
      async onInsertInput(ch, charmod) {
        let { session } = this;
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        if (!session)
          return;
        let n = await session.doNumberSelect(ch);
        if (n)
          return;
        let done = await this.mappings.doInsertKeymap(ch);
        if (done || charmod)
          return;
        if (ch.startsWith("<") && ch.endsWith(">")) {
          await this.feedkeys(ch, false);
          return;
        }
        for (let s of ch) {
          let code = s.codePointAt(0);
          if (code == 65533)
            return;
          if (code < 32 || code >= 127 && code <= 159)
            return;
          await this.prompt.acceptCharacter(s);
        }
      }
      async onNormalInput(ch, _charmod) {
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let used = await this.mappings.doNormalKeymap(ch);
        if (!used)
          await this.feedkeys(ch);
      }
      onMouseEvent(key) {
        var _a2;
        return (_a2 = this.session) == null ? void 0 : _a2.onMouseEvent(key);
      }
      async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith("<") && key.endsWith(">") ? `\\${key}` : key;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.call("eval", [`feedkeys("${key}", "${remap ? "i" : "in"}")`]);
        this.triggerCursorMoved();
        this.prompt.start();
      }
      async command(command) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(command);
        this.triggerCursorMoved();
        this.prompt.start();
      }
      async normal(command, bang) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(`normal${bang ? "!" : ""} ${command}`);
        this.triggerCursorMoved();
        this.prompt.start();
      }
      triggerCursorMoved() {
        if (this.nvim.isVim)
          this.nvim.command("doautocmd <nomodeline> CursorMoved", true);
      }
      async call(fname) {
        if (this.session)
          return await this.session.call(fname);
      }
      get session() {
        return this.lastSession;
      }
      registerList(list2, internal = false) {
        let { name: name2, interactive } = list2;
        let id;
        if (!internal)
          id = getConditionValue(parseExtensionName(Error().stack), void 0);
        let removed = this.deregisterList(name2);
        this.listMap.set(name2, list2);
        const configNode = createConfigurationNode(name2, interactive, id);
        if (!removed)
          workspace_default.configurations.updateConfigurations([configNode]);
        return import_node3.Disposable.create(() => {
          this.deregisterList(name2);
          const configurationRegistry3 = Registry.as(Extensions3.Configuration);
          configurationRegistry3.deregisterConfigurations([configNode]);
        });
      }
      deregisterList(name2) {
        let exists = this.listMap.get(name2);
        if (exists) {
          if (typeof exists.dispose == "function") {
            exists.dispose();
          }
          this.listMap.delete(name2);
          return true;
        }
        return false;
      }
      get names() {
        return Array.from(this.listMap.keys());
      }
      get descriptions() {
        let d = {};
        for (let name2 of this.listMap.keys()) {
          let list2 = this.listMap.get(name2);
          d[name2] = list2.description;
        }
        return d;
      }
      async loadItems(name2) {
        let args = [name2];
        let res = this.parseArgs(args);
        if (!res || !name2)
          return;
        let { list: list2, options: options2, listArgs } = res;
        let source = new import_node3.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list2.loadItems({
          options: options2,
          args: listArgs,
          input: "",
          cwd: workspace_default.cwd,
          window: this.nvim.createWindow(arr[0]),
          buffer: this.nvim.createBuffer(arr[1]),
          listWindow: null
        }, token);
        if (!items || Array.isArray(items)) {
          return items;
        }
        let task = items;
        let newItems = await new Promise((resolve, reject) => {
          let items2 = [];
          task.on("data", (item) => {
            item.label = stripAnsi(item.label);
            items2.push(item);
          });
          task.on("end", () => {
            resolve(items2);
          });
          task.on("error", (msg) => {
            reject(msg);
          });
        });
        return newItems;
      }
      toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.toggleMode();
      }
      get isActivated() {
        var _a2;
        return ((_a2 = this.session) == null ? void 0 : _a2.winid) != null;
      }
      stop() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.stop();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.lastSession = void 0;
        disposeAll(this.disposables);
      }
    };
    manager_default2 = new ListManager();
  }
});

// src/snippets/snippet.ts
function reduceTextEdit(edit2, oldText) {
  let { range, newText } = edit2;
  let ol = oldText.length;
  let nl = newText.length;
  if (ol === 0 || nl === 0)
    return edit2;
  let { start, end } = range;
  let bo = 0;
  for (let i = 1; i <= Math.min(nl, ol); i++) {
    if (newText[i - 1] === oldText[i - 1]) {
      bo = i;
    } else {
      break;
    }
  }
  let eo = 0;
  let t = Math.min(nl - bo, ol - bo);
  if (t > 0) {
    for (let i = 1; i <= t; i++) {
      if (newText[nl - i] === oldText[ol - i]) {
        eo = i;
      } else {
        break;
      }
    }
  }
  let text = eo == 0 ? newText.slice(bo) : newText.slice(bo, -eo);
  if (bo > 0)
    start = getEnd(start, newText.slice(0, bo));
  if (eo > 0)
    end = getEnd(range.start, oldText.slice(0, -eo));
  return TextEdit.replace(Range.create(start, end), text);
}
function checkCursor(start, cursor, newText) {
  let r = Range.create(start, getEnd(start, newText));
  return positionInRange(cursor, r) == 0;
}
function checkContentBefore(position, oldTextDocument, textDocument) {
  let lines = textDocument.lines;
  if (lines.length < position.line)
    return false;
  let checked = true;
  for (let i = position.line; i >= 0; i--) {
    let newLine = textDocument.lines[i] ?? "";
    if (i === position.line) {
      let before = oldTextDocument.lines[i].slice(0, position.character);
      if (!newLine.startsWith(before)) {
        checked = false;
        break;
      }
    } else if (newLine !== oldTextDocument.lines[i]) {
      checked = false;
      break;
    }
  }
  return checked;
}
function getEndPosition(position, oldTextDocument, textDocument) {
  let total = oldTextDocument.lines.length;
  if (textDocument.lines.length < total - position.line)
    return void 0;
  let end;
  let cl = textDocument.lines.length - total;
  for (let i = position.line; i < total; i++) {
    let newLine = textDocument.lines[i + cl];
    if (i == position.line) {
      let text = oldTextDocument.lines[i].slice(position.character);
      if (text.length && !newLine.endsWith(text))
        break;
      end = Position.create(i + cl, newLine.length - text.length);
    } else if (newLine !== oldTextDocument.lines[i]) {
      end = void 0;
      break;
    }
  }
  return end;
}
function getParts(text, range, r) {
  let before = [];
  let after = [];
  let lines = text.split("\n");
  let d = r.start.line - range.start.line;
  for (let i = 0; i <= d; i++) {
    let s = defaultValue(lines[i], "");
    if (i == d) {
      before.push(i == 0 ? s.substring(0, r.start.character - range.start.character) : s.substring(0, r.start.character));
    } else {
      before.push(s);
    }
  }
  d = range.end.line - r.end.line;
  for (let i = 0; i <= d; i++) {
    let s = lines[r.end.line - range.start.line + i] ?? "";
    if (i == 0) {
      if (d == 0) {
        after.push(range.end.character == r.end.character ? "" : s.slice(r.end.character - range.end.character));
      } else {
        after.push(s.substring(r.end.character));
      }
    } else {
      after.push(s);
    }
  }
  return [before.join("\n"), after.join("\n")];
}
function normalizeSnippetString(snippet, indent, opts) {
  let lines = snippet.split(/\r?\n/);
  let ind = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
  let tabSize = defaultValue(opts.tabSize, 2);
  lines = lines.map((line, idx) => {
    let space = line.match(/^\s*/)[0];
    let pre = space;
    let isTab = space.startsWith("	");
    if (isTab && opts.insertSpaces) {
      pre = ind.repeat(space.length);
    } else if (!isTab && !opts.insertSpaces) {
      pre = ind.repeat(space.length / tabSize);
    }
    return (idx == 0 || line.length == 0 ? "" : indent) + pre + line.slice(space.length);
  });
  return lines.join("\n");
}
function shouldFormat(snippet) {
  if (/^\s/.test(snippet))
    return true;
  if (snippet.indexOf("\n") !== -1)
    return true;
  return false;
}
function comparePlaceholder(a, b) {
  if (a.primary !== b.primary)
    return a.primary ? -1 : 1;
  if (a.index == 0 || b.index == 0)
    return a.index == 0 ? 1 : -1;
  return a.index - b.index;
}
var CocSnippet;
var init_snippet = __esm({
  "src/snippets/snippet.ts"() {
    "use strict";
    init_main3();
    init_main();
    init_util();
    init_position();
    init_textedit();
    init_eval();
    init_parser3();
    CocSnippet = class {
      constructor(snippetString, position, nvim, resolver2) {
        this.snippetString = snippetString;
        this.position = position;
        this.nvim = nvim;
        this.resolver = resolver2;
      }
      async init(ultisnip, isResolve = false) {
        const matchCode = ultisnip ? prepareMatchCode(ultisnip) : void 0;
        const parser2 = new SnippetParser(!!ultisnip, matchCode);
        const snippet = parser2.parse(this.snippetString, true);
        this.tmSnippet = snippet;
        await this.resolve(ultisnip);
        this.synchronize();
        if (!isResolve) {
          this.nvim.call("coc#compat#del_var", ["coc_selected_text"], true);
          this.nvim.call("coc#compat#del_var", ["coc_last_placeholder"], true);
        }
      }
      async resolve(ultisnip) {
        let { snippet } = this.tmSnippet;
        let { resolver: resolver2, nvim } = this;
        if (resolver2) {
          await snippet.resolveVariables(resolver2);
        }
        if (ultisnip && ultisnip.noPython !== true) {
          let pyCodes = [];
          if (snippet.hasPython)
            pyCodes = preparePythonCodes(ultisnip);
          await snippet.evalCodeBlocks(nvim, pyCodes);
        }
      }
      getRanges(placeholder) {
        let marker = placeholder.marker;
        if (placeholder.value.length == 0)
          return [];
        let placeholders = this._placeholders.filter((o) => o.index == placeholder.index);
        let ranges = placeholders.map((o) => o.range);
        let parents = this.tmSnippet.enclosingPlaceholders(marker);
        let markers;
        let p = marker.parent;
        if (marker instanceof Placeholder) {
          let index = marker.index;
          markers = this.tmSnippet.placeholders.filter((o) => o.index == index && o.parent == p);
        } else {
          let name2 = marker.name;
          markers = this.tmSnippet.variables.filter((o) => o.name == name2 && o.parent == p);
        }
        parents.forEach((p2) => {
          let arr = this._placeholders.filter((o) => o.index == p2.index && o.marker !== p2);
          if (!arr.length)
            return;
          for (let m of markers) {
            let before = this.tmSnippet.getTextBefore(m, p2);
            arr.forEach((item) => {
              if (item.transform) {
                ranges.push(item.range);
              } else {
                let s = item.range.start;
                ranges.push(Range.create(getEnd(s, before), getEnd(s, before + m.toString())));
              }
            });
          }
        });
        return ranges.filter((r) => !emptyRange(r));
      }
      getSortedPlaceholders(curr) {
        let res = curr ? [curr] : [];
        let arr = this._placeholders.filter((o) => o !== curr && !o.transform);
        arr.sort(comparePlaceholder);
        res.push(...arr);
        return res;
      }
      get hasPython() {
        return this.tmSnippet.pyBlocks.length > 0;
      }
      resetStartPosition(pos) {
        this.position = pos;
        this.synchronize();
      }
      get start() {
        return Object.assign({}, this.position);
      }
      get range() {
        return Range.create(this.position, getEnd(this.position, this._text));
      }
      get text() {
        return this._text;
      }
      get finalCount() {
        return this._placeholders.filter((o) => o.index == 0).length;
      }
      get placeholders() {
        return this._placeholders.map((o) => o.marker);
      }
      get firstPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
          if (p.index == 0 || p.transform)
            continue;
          if (index == 0 || p.index < index) {
            index = p.index;
          }
        }
        return this.getPlaceholder(index);
      }
      getPlaceholderByMarker(marker) {
        return this._placeholders.find((o) => o.marker === marker);
      }
      getPlaceholder(index) {
        let filtered = this._placeholders.filter((o) => o.index == index && !o.transform);
        let find = filtered.find((o) => o.primary);
        return defaultValue(find, filtered[0]);
      }
      getPrevPlaceholder(index) {
        if (index <= 1)
          return void 0;
        let placeholders = this._placeholders.filter((o) => o.index < index && o.index != 0 && !o.transform);
        let find;
        while (index > 1) {
          index = index - 1;
          let arr = placeholders.filter((o) => o.index == index);
          if (arr.length) {
            find = defaultValue(arr.find((o) => o.primary), arr[0]);
            break;
          }
        }
        return find;
      }
      getNextPlaceholder(index) {
        let placeholders = this._placeholders.filter((o) => !o.transform);
        let find;
        let indexes = placeholders.map((o) => o.index);
        let max = Math.max.apply(null, indexes);
        for (let i = index + 1; i <= max + 1; i++) {
          let idx = i == max + 1 ? 0 : i;
          let arr = placeholders.filter((o) => o.index == idx);
          if (arr.length) {
            find = arr.find((o) => o.primary) || arr[0];
            break;
          }
        }
        return find;
      }
      getPlaceholderByRange(range) {
        return this._placeholders.find((o) => rangeInRange(range, o.range));
      }
      async insertSnippet(placeholder, snippet, parts, ultisnip) {
        if (ultisnip) {
          let { start, end } = placeholder.range;
          this.nvim.setVar("coc_last_placeholder", {
            current_text: placeholder.value,
            start: { line: start.line, col: start.character, character: start.character },
            end: { line: end.line, col: end.character, character: end.character }
          }, true);
        }
        let select = this.tmSnippet.insertSnippet(snippet, placeholder.marker, parts, ultisnip);
        await this.resolve(ultisnip);
        this.synchronize();
        return select;
      }
      getNewText(placeholder, inserted) {
        let { before, after } = placeholder;
        if (!inserted.startsWith(before))
          return void 0;
        if (inserted.length < before.length + after.length)
          return void 0;
        if (!inserted.endsWith(after))
          return void 0;
        if (!after.length)
          return inserted.slice(before.length);
        return inserted.slice(before.length, -after.length);
      }
      async updatePlaceholder(placeholder, cursor, newText, token) {
        let start = this.position;
        let { marker, before } = placeholder;
        let cloned = this.tmSnippet.clone();
        token.onCancellationRequested(() => {
          this.tmSnippet = cloned;
          this.synchronize();
        });
        let r = Range.create(start, getEnd(start, before));
        await this.tmSnippet.update(this.nvim, marker, newText);
        if (token.isCancellationRequested)
          return void 0;
        this.synchronize();
        let after = this.getTextBefore(marker, before);
        return { text: this._text, delta: getChangedPosition(cursor, TextEdit.replace(r, after)) };
      }
      getTextBefore(marker, defaultValue2) {
        let placeholder = this._placeholders.find((o) => o.marker == marker);
        if (placeholder)
          return placeholder.before;
        return defaultValue2;
      }
      removeText(offset, length) {
        let succeed = this.tmSnippet.deleteText(offset, length);
        if (succeed)
          this.synchronize();
        return succeed;
      }
      synchronize() {
        const snippet = this.tmSnippet;
        const { line, character } = this.position;
        const document2 = TextDocument2.create("untitled:/1", "snippet", 0, snippet.toString());
        let { placeholders, variables, maxIndexNumber } = snippet;
        const variableIndexMap = /* @__PURE__ */ new Map();
        let variableIndex = maxIndexNumber + 1;
        this._placeholders = [...placeholders, ...variables].map((p) => {
          const offset = snippet.offset(p);
          const position = document2.positionAt(offset);
          const start = {
            line: line + position.line,
            character: position.line == 0 ? character + position.character : position.character
          };
          let index;
          if (p instanceof Variable) {
            let key = p.name;
            if (variableIndexMap.has(key)) {
              index = variableIndexMap.get(key);
            } else {
              variableIndexMap.set(key, variableIndex);
              index = variableIndex;
              variableIndex = variableIndex + 1;
            }
          } else {
            index = p.index;
          }
          const value = p.toString();
          const end = getEnd(position, value);
          let res = {
            index,
            value,
            marker: p,
            transform: !!p.transform,
            range: Range.create(start, getEnd(start, value)),
            before: document2.getText(Range.create(Position.create(0, 0), position)),
            after: document2.getText(Range.create(end, Position.create(document2.lineCount, 0))),
            primary: p instanceof Placeholder && p.primary === true
          };
          return res;
        });
        this._text = this.tmSnippet.toString();
      }
    };
  }
});

// src/snippets/variableResolve.ts
function padZero(n) {
  return n < 10 ? "0" + n : n.toString();
}
function parseComments(comments) {
  let start;
  let end;
  let single;
  let parts = comments.split(",");
  for (let s of parts) {
    if (start && end && single)
      break;
    if (!s.includes(":"))
      continue;
    let [flag, str] = s.split(":");
    if (flag.includes("s")) {
      start = str;
    } else if (flag.includes("e")) {
      end = str;
    } else if (!single && flag == "") {
      single = str;
    }
  }
  return { start, end, single };
}
function parseCommentstring(commentstring) {
  if (commentstring.endsWith("%s"))
    return commentstring.slice(0, -2).trim();
  return void 0;
}
var SnippetVariableResolver;
var init_variableResolve = __esm({
  "src/snippets/variableResolve.ts"() {
    "use strict";
    init_esm_node();
    init_esm();
    init_node();
    init_object();
    SnippetVariableResolver = class {
      constructor(nvim, workspaceFolder) {
        this.nvim = nvim;
        this.workspaceFolder = workspaceFolder;
        this._variableToValue = {};
        const currentDate = new Date();
        const fullyear = currentDate.getFullYear().toString();
        Object.assign(this._variableToValue, {
          CURRENT_YEAR: fullyear,
          CURRENT_YEAR_SHORT: fullyear.slice(-2),
          CURRENT_MONTH: padZero(currentDate.getMonth() + 1),
          CURRENT_DATE: padZero(currentDate.getDate()),
          CURRENT_HOUR: padZero(currentDate.getHours()),
          CURRENT_MINUTE: padZero(currentDate.getMinutes()),
          CURRENT_SECOND: padZero(currentDate.getSeconds()),
          CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
          CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
          CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
          CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" }),
          TM_FILENAME: null,
          TM_FILENAME_BASE: null,
          TM_DIRECTORY: null,
          TM_FILEPATH: null,
          YANK: null,
          TM_LINE_INDEX: null,
          TM_LINE_NUMBER: null,
          TM_CURRENT_LINE: null,
          TM_CURRENT_WORD: null,
          TM_SELECTED_TEXT: null,
          VISUAL: null,
          CLIPBOARD: null,
          RELATIVE_FILEPATH: null,
          RANDOM: null,
          RANDOM_HEX: null,
          UUID: null,
          BLOCK_COMMENT_START: null,
          BLOCK_COMMENT_END: null,
          LINE_COMMENT: null,
          WORKSPACE_NAME: null,
          WORKSPACE_FOLDER: null
        });
      }
      async resolveValue(name2) {
        let { nvim } = this;
        if (["TM_FILENAME", "TM_FILENAME_BASE", "TM_DIRECTORY", "TM_FILEPATH"].includes(name2)) {
          let filepath = await nvim.eval('expand("%:p")');
          if (name2 === "TM_FILENAME")
            return path.basename(filepath);
          if (name2 === "TM_FILENAME_BASE")
            return path.basename(filepath, path.extname(filepath));
          if (name2 === "TM_DIRECTORY")
            return path.dirname(filepath);
          if (name2 === "TM_FILEPATH")
            return filepath;
        }
        if (name2 === "YANK") {
          return await nvim.call("getreg", ['""']);
        }
        if (name2 === "TM_LINE_INDEX") {
          let lnum = await nvim.call("line", ["."]);
          return (lnum - 1).toString();
        }
        if (name2 === "TM_LINE_NUMBER") {
          let lnum = await nvim.call("line", ["."]);
          return lnum.toString();
        }
        if (name2 === "TM_CURRENT_LINE") {
          return await nvim.call("getline", ["."]);
        }
        if (name2 === "TM_CURRENT_WORD") {
          return await nvim.eval(`expand('<cword>')`);
        }
        if (name2 === "TM_SELECTED_TEXT" || name2 == "VISUAL") {
          return await nvim.eval(`get(g:,'coc_selected_text', v:null)`);
        }
        if (name2 === "CLIPBOARD") {
          return await nvim.eval("@*");
        }
        if (name2 === "RANDOM") {
          return Math.random().toString().slice(-6);
        }
        if (name2 === "RANDOM_HEX") {
          return Math.random().toString(16).slice(-6);
        }
        if (name2 === "UUID") {
          return v4_default();
        }
        if (["RELATIVE_FILEPATH", "WORKSPACE_NAME", "WORKSPACE_FOLDER"].includes(name2)) {
          let filepath = await nvim.eval('expand("%:p")');
          let folder = this.workspaceFolder.getWorkspaceFolder(URI.file(filepath));
          if (name2 === "RELATIVE_FILEPATH")
            return this.workspaceFolder.getRelativePath(filepath);
          if (name2 === "WORKSPACE_NAME")
            return folder.name;
          if (name2 === "WORKSPACE_FOLDER")
            return URI.parse(folder.uri).fsPath;
        }
        if (name2 === "LINE_COMMENT") {
          let commentstring = await nvim.eval("&commentstring");
          let s = parseCommentstring(commentstring);
          if (s)
            return s;
          let comments = await nvim.eval("&comments");
          let { single } = parseComments(comments);
          return single;
        }
        if (["BLOCK_COMMENT_START", "BLOCK_COMMENT_END"].includes(name2)) {
          let comments = await nvim.eval("&comments");
          let { start, end } = parseComments(comments);
          if (name2 === "BLOCK_COMMENT_START")
            return start;
          if (name2 === "BLOCK_COMMENT_END")
            return end;
        }
      }
      async resolve(variable) {
        const name2 = variable.name;
        let resolved = this._variableToValue[name2];
        if (resolved != null)
          return resolved.toString();
        if (hasOwnProperty(this._variableToValue, name2)) {
          let value = await this.resolveValue(name2);
          if (!value && variable.children.length) {
            return variable.toString();
          }
          return value == null ? "" : value.toString();
        }
        if (variable.children.length)
          return variable.toString();
        return name2;
      }
    };
  }
});

// src/snippets/session.ts
var logger36, NAME_SPACE2, SnippetSession;
var init_session2 = __esm({
  "src/snippets/session.ts"() {
    "use strict";
    init_main();
    init_logger();
    init_mutex();
    init_object();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_parser3();
    init_snippet();
    init_variableResolve();
    logger36 = createLogger("snippets-session");
    NAME_SPACE2 = "snippets";
    SnippetSession = class {
      constructor(nvim, document2, config) {
        this.nvim = nvim;
        this.document = document2;
        this.config = config;
        this.mutex = new Mutex();
        this._applying = false;
        this._isActive = false;
        this._snippet = null;
        this._onCancelEvent = new import_node3.Emitter();
        this.onCancel = this._onCancelEvent.event;
        this.disposable = document2.onDocumentChange(async (e) => {
          if (this._applying || !this._isActive)
            return;
          let changes = e.contentChanges;
          await this.synchronize({ version: e.textDocument.version, change: changes[0] });
        });
      }
      async start(inserted, range, select = true, context) {
        const { document: document2 } = this;
        const placeholder = this.getReplacePlaceholder(range);
        const edits = [];
        if (placeholder) {
          let r = this.snippet.range;
          let previous = document2.textDocument.getText(r);
          let parts = getParts(placeholder.value, placeholder.range, range);
          this.current = await this.snippet.insertSnippet(placeholder, inserted, parts, context);
          let edit2 = reduceTextEdit({
            range: r,
            newText: this.snippet.text
          }, previous);
          edits.push(edit2);
        } else {
          const resolver2 = new SnippetVariableResolver(this.nvim, workspace_default.workspaceFolderControl);
          let snippet = new CocSnippet(inserted, range.start, this.nvim, resolver2);
          await snippet.init(context);
          this._snippet = snippet;
          this.current = snippet.firstPlaceholder.marker;
          edits.push(TextEdit.replace(range, snippet.text));
          if (inserted.replace(/\$0$/, "").endsWith("\n")) {
            const currentLine = document2.getline(range.start.line);
            const remain = currentLine.slice(range.end.character);
            if (remain.length) {
              let s = range.end.character;
              let l = remain.match(/^\s*/)[0].length;
              let r = Range.create(range.end.line, s, range.end.line, s + l);
              edits.push(TextEdit.replace(r, currentLine.match(/^\s*/)[0]));
            }
          }
        }
        await this.applyEdits(edits);
        this.textDocument = document2.textDocument;
        this.activate();
        if (select && this.current) {
          let placeholder2 = this.snippet.getPlaceholderByMarker(this.current);
          await this.selectPlaceholder(placeholder2, true);
        }
        return this._isActive;
      }
      async applyEdits(edits) {
        this._applying = true;
        await this.document.applyEdits(edits);
        this._applying = false;
      }
      getReplacePlaceholder(range) {
        if (!this.snippet)
          return void 0;
        let placeholder = this.findPlaceholder(range);
        if (!placeholder || placeholder.index == 0)
          return void 0;
        return placeholder;
      }
      activate() {
        if (this._isActive)
          return;
        this._isActive = true;
        this.nvim.call("coc#snippet#enable", [this.config.preferComplete ? 1 : 0], true);
      }
      deactivate() {
        this.cancel();
        if (!this._isActive)
          return;
        this.disposable.dispose();
        this._isActive = false;
        this._snippet = void 0;
        this.current = null;
        this.nvim.call("coc#snippet#disable", [], true);
        if (this.config.highlight)
          this.nvim.call("coc#highlight#clear_highlight", [this.bufnr, NAME_SPACE2, 0, -1], true);
        this._onCancelEvent.fire(void 0);
        logger36.debug(`session ${this.bufnr} cancelled`);
      }
      get isActive() {
        return this._isActive;
      }
      get bufnr() {
        return this.document.bufnr;
      }
      async nextPlaceholder() {
        await this.forceSynchronize();
        let curr = this.placeholder;
        if (!curr)
          return;
        let next = this.snippet.getNextPlaceholder(curr.index);
        if (next)
          await this.selectPlaceholder(next);
      }
      async previousPlaceholder() {
        await this.forceSynchronize();
        let curr = this.placeholder;
        if (!curr)
          return;
        let prev = this.snippet.getPrevPlaceholder(curr.index);
        if (prev)
          await this.selectPlaceholder(prev);
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        await this.forceSynchronize();
        if (!this.snippet)
          return;
        let placeholder = this.snippet.getPlaceholderByMarker(this.current);
        if (placeholder)
          await this.selectPlaceholder(placeholder, triggerAutocmd);
      }
      async selectPlaceholder(placeholder, triggerAutocmd = true) {
        let { nvim, document: document2 } = this;
        if (!document2 || !placeholder)
          return;
        let { start, end } = placeholder.range;
        const line = document2.getline(start.line);
        const col = byteIndex(line, start.character) + 1;
        let marker = this.current = placeholder.marker;
        if (marker instanceof Placeholder && marker.choice && marker.choice.options.length) {
          let sources = (await Promise.resolve().then(() => (init_sources2(), sources_exports))).default;
          sources.setWords(marker.choice.options.map((o) => o.value));
          await nvim.call("coc#snippet#show_choices", [start.line + 1, col, end, placeholder.value]);
          if (triggerAutocmd)
            nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        } else {
          let finalCount = this.snippet.finalCount;
          await this.select(placeholder, triggerAutocmd);
          this.highlights(placeholder);
          if (placeholder.index == 0) {
            if (finalCount == 1) {
              logger36.info("Jump to final placeholder, cancelling snippet session");
              this.deactivate();
            } else {
              nvim.call("coc#snippet#disable", [], true);
            }
          }
        }
      }
      highlights(placeholder, redrawVim = true) {
        if (!this.config.highlight)
          return;
        let buf = this.document.buffer;
        this.nvim.pauseNotification();
        buf.clearNamespace(NAME_SPACE2);
        let ranges = this.snippet.getRanges(placeholder);
        if (ranges.length) {
          buf.highlightRanges(NAME_SPACE2, "CocSnippetVisual", ranges);
        }
        this.nvim.resumeNotification(redrawVim, true);
      }
      async select(placeholder, triggerAutocmd) {
        let { range, value } = placeholder;
        let { nvim } = this;
        if (value.length > 0) {
          await nvim.call("coc#snippet#select", [range.start, range.end, value]);
        } else {
          await nvim.call("coc#snippet#move", [range.start]);
        }
        if (triggerAutocmd)
          nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        nvim.redrawVim();
      }
      async checkPosition() {
        if (!this.isActive)
          return;
        let position = await window_default.getCursorPosition();
        if (this.snippet && positionInRange(position, this.snippet.range) != 0) {
          logger36.info("Cursor insert out of range, cancelling snippet session");
          this.deactivate();
        }
      }
      findPlaceholder(range) {
        let { placeholder } = this;
        if (placeholder && rangeInRange(range, placeholder.range))
          return placeholder;
        return this.snippet.getPlaceholderByRange(range) || null;
      }
      get version() {
        return this.textDocument ? this.textDocument.version : -1;
      }
      async synchronize(change) {
        await this.mutex.use(() => {
          if (change && (this.document.version != change.version || change.version - this.version !== 1)) {
            change = void 0;
          }
          return this._synchronize(change ? change.change : void 0);
        });
      }
      async _synchronize(change) {
        let { document: document2, textDocument } = this;
        if (!document2.attached || !this._isActive)
          return;
        let start = Date.now();
        let d = document2.textDocument;
        if (d.version == textDocument.version || equals(textDocument.lines, d.lines))
          return;
        let { range, text } = this.snippet;
        if (change && !rangeInRange(change.range, range))
          change = void 0;
        let end = getEndPosition(range.end, textDocument, d);
        if (!end) {
          logger36.info("Content change after snippet, cancel snippet session");
          this.deactivate();
          return;
        }
        let checked = checkContentBefore(range.start, textDocument, d);
        if (!checked) {
          let content = d.getText(Range.create(Position.create(0, 0), end));
          if (content.endsWith(text)) {
            let pos = d.positionAt(content.length - text.length);
            this.snippet.resetStartPosition(pos);
            this.textDocument = d;
            logger36.info("Content change before snippet, reset snippet position");
            return;
          }
          logger36.info("Before and snippet body changed, cancel snippet session");
          this.deactivate();
          return;
        }
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        let cursor = await window_default.getCursorPosition();
        if (tokenSource.token.isCancellationRequested || document2.hasChanged)
          return;
        let placeholder;
        let newText;
        let inserted = d.getText(Range.create(range.start, end));
        let curr = this.placeholder;
        if (change) {
          for (let p of this.snippet.getSortedPlaceholders(curr)) {
            if (rangeInRange(change.range, p.range)) {
              placeholder = p;
              newText = this.snippet.getNewText(p, inserted);
              break;
            }
          }
          if (!placeholder && change.text.length == 0 && !emptyRange(change.range) && isSingleLine(change.range)) {
            let length = change.range.end.character - change.range.start.character;
            let offset = d.getText(Range.create(range.start, change.range.start)).length;
            if (this.snippet.removeText(offset, length)) {
              this.textDocument = d;
              return;
            }
          }
        } else {
          for (let p of this.snippet.getSortedPlaceholders(curr)) {
            if (comparePosition(cursor, p.range.start) < 0)
              continue;
            newText = this.snippet.getNewText(p, inserted);
            if (newText != null && checkCursor(p.range.start, cursor, newText)) {
              placeholder = p;
              break;
            }
          }
        }
        if (!placeholder && inserted.endsWith(text)) {
          let pos = getEnd(range.start, inserted.slice(0, -text.length));
          this.snippet.resetStartPosition(pos);
          this.textDocument = d;
          logger36.info("Content change before snippet, reset snippet position");
          return;
        }
        if (!placeholder) {
          logger36.info("Unable to find changed placeholder, cancel snippet session");
          this.deactivate();
          return;
        }
        let res = await this.snippet.updatePlaceholder(placeholder, cursor, newText, tokenSource.token);
        if (res == null || tokenSource.token.isCancellationRequested)
          return;
        if (document2.dirty || !equals(document2.textDocument.lines, d.lines)) {
          tokenSource.cancel();
          tokenSource.dispose();
          return;
        }
        tokenSource.dispose();
        this.current = placeholder.marker;
        if (res.text !== inserted) {
          let edit2 = reduceTextEdit({
            range: Range.create(this.snippet.start, end),
            newText: res.text
          }, inserted);
          await this.applyEdits([edit2]);
          let { delta } = res;
          if (delta.line != 0 || delta.character != 0) {
            this.nvim.call(`coc#cursor#move_to`, [cursor.line + delta.line, cursor.character + delta.character], true);
          }
          this.highlights(placeholder, false);
          this.nvim.redrawVim();
        } else {
          this.highlights(placeholder);
        }
        logger36.debug("update cost:", Date.now() - start, res.delta);
        this.textDocument = this.document.textDocument;
        if (this.config.nextOnDelete) {
          if (curr && curr.value.length > 0 && placeholder.marker.toString() === "") {
            let next = this.snippet.getNextPlaceholder(placeholder.index);
            if (next)
              await this.selectPlaceholder(next);
          }
        }
      }
      async forceSynchronize() {
        await this.document.patchChange();
        let release = await this.mutex.acquire();
        release();
        if (this.document.version !== this.version) {
          await this.synchronize();
        }
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      get placeholder() {
        if (!this.snippet || !this.current)
          return void 0;
        return this.snippet.getPlaceholderByMarker(this.current);
      }
      get snippet() {
        return this._snippet;
      }
      static async resolveSnippet(nvim, snippetString, ultisnip) {
        let position = ultisnip && Range.is(ultisnip.range) ? ultisnip.range.start : await window_default.getCursorPosition();
        let line = ultisnip && typeof ultisnip.line === "string" ? ultisnip.line : await nvim.line;
        let context;
        if (ultisnip)
          context = Object.assign({ range: Range.create(position, position), line }, ultisnip);
        const resolver2 = new SnippetVariableResolver(nvim, workspace_default.workspaceFolderControl);
        let snippet = new CocSnippet(snippetString, position, nvim, resolver2);
        await snippet.init(context, true);
        return snippet.text;
      }
    };
  }
});

// src/snippets/string.ts
var SnippetString;
var init_string2 = __esm({
  "src/snippets/string.ts"() {
    "use strict";
    SnippetString = class {
      constructor(value) {
        this._tabstop = 1;
        this.value = value || "";
      }
      static isSnippetString(thing) {
        if (thing instanceof SnippetString) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.value === "string";
      }
      static _escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      appendText(str) {
        this.value += SnippetString._escape(str);
        return this;
      }
      appendTabstop(num = this._tabstop++) {
        this.value += "$";
        this.value += num;
        return this;
      }
      appendPlaceholder(value, num = this._tabstop++) {
        if (typeof value === "function") {
          const nested = new SnippetString();
          nested._tabstop = this._tabstop;
          value(nested);
          this._tabstop = nested._tabstop;
          value = nested.value;
        } else {
          value = SnippetString._escape(value);
        }
        this.value += "${";
        this.value += num;
        this.value += ":";
        this.value += value;
        this.value += "}";
        return this;
      }
      appendChoice(values, num = this._tabstop++) {
        const value = values.map((s) => s.replace(/\$|}|\\|,/g, "\\$&")).join(",");
        this.value += "${";
        this.value += num;
        this.value += "|";
        this.value += value;
        this.value += "|}";
        return this;
      }
      appendVariable(name2, defaultValue2) {
        if (typeof defaultValue2 === "function") {
          const nested = new SnippetString();
          nested._tabstop = this._tabstop;
          defaultValue2(nested);
          this._tabstop = nested._tabstop;
          defaultValue2 = nested.value;
        } else if (typeof defaultValue2 === "string") {
          defaultValue2 = defaultValue2.replace(/\$|}/g, "\\$&");
        }
        this.value += "${";
        this.value += name2;
        if (defaultValue2) {
          this.value += ":";
          this.value += defaultValue2;
        }
        this.value += "}";
        return this;
      }
    };
  }
});

// src/snippets/manager.ts
var SnippetManager, manager_default3;
var init_manager4 = __esm({
  "src/snippets/manager.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_util();
    init_object();
    init_position();
    init_window();
    init_workspace();
    init_session2();
    init_snippet();
    init_string2();
    SnippetManager = class {
      constructor() {
        this.sessionMap = /* @__PURE__ */ new Map();
        this.disposables = [];
      }
      init() {
        events_default.on("InsertCharPre", (_, bufnr) => {
          let session = this.getSession(bufnr);
          if (session)
            session.cancel();
        }, null, this.disposables);
        events_default.on("InsertEnter", async (bufnr) => {
          let session = this.getSession(bufnr);
          if (session)
            await session.checkPosition();
        }, null, this.disposables);
        workspace_default.onDidCloseTextDocument((e) => {
          let session = this.getSession(e.bufnr);
          if (session)
            session.deactivate();
        }, null, this.disposables);
        window_default.onDidChangeActiveTextEditor((e) => {
          if (!this._statusItem)
            return;
          let session = this.getSession(e.document.bufnr);
          if (session) {
            this.statusItem.show();
          } else {
            this.statusItem.hide();
          }
        }, null, this.disposables);
        commands_default.register({
          id: "editor.action.insertSnippet",
          execute: async (edit2, ultisnip) => {
            const opts = ultisnip === true ? {} : ultisnip;
            return await this.insertSnippet(edit2.newText, true, edit2.range, InsertTextMode.adjustIndentation, opts ? opts : void 0);
          }
        }, true);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get statusItem() {
        if (this._statusItem)
          return this._statusItem;
        let statusItem = this._statusItem = window_default.createStatusBarItem(0);
        const snippetConfig = workspace_default.initialConfiguration.get("snippet");
        statusItem.text = defaultValue(snippetConfig.statusText, "");
        return this._statusItem;
      }
      getSnippetConfig(resource) {
        let config = workspace_default.getConfiguration("coc.preferences", resource);
        const snippetConfig = workspace_default.getConfiguration("snippet", resource);
        const suggest = workspace_default.getConfiguration("suggest", resource);
        return {
          highlight: config.get("snippetHighlight", snippetConfig.get("highlight", false)),
          nextOnDelete: config.get("nextPlaceholderOnDelete", snippetConfig.get("nextPlaceholderOnDelete", false)),
          preferComplete: suggest.get("preferCompleteThanJumpPlaceholder", false)
        };
      }
      async insertSnippet(snippet, select = true, range, insertTextMode, ultisnip) {
        let { bufnr } = workspace_default;
        let doc = workspace_default.getAttachedDocument(bufnr);
        if (range && !rangeInRange(range, Range.create(0, 0, doc.lineCount + 1, 0))) {
          throw new Error(`Unable to insert snippet, invalid range.`);
        }
        let context;
        if (!range) {
          let pos = await window_default.getCursorPosition();
          range = Range.create(pos, pos);
        }
        const currentLine = doc.getline(range.start.line);
        const snippetStr = SnippetString.isSnippetString(snippet) ? snippet.value : snippet;
        const inserted = await this.normalizeInsertText(doc.uri, snippetStr, currentLine, insertTextMode);
        if (ultisnip != null) {
          context = Object.assign({ range: deepClone(range), line: currentLine }, ultisnip);
          if (!emptyRange(range) && inserted.includes("`!p")) {
            this.nvim.call("coc#cursor#move_to", [range.start.line, range.start.character], true);
            await doc.applyEdits([{ range, newText: "" }]);
            range.end = Position.create(range.start.line, range.start.character);
          }
        }
        let session = this.getSession(bufnr);
        if (session) {
          await session.forceSynchronize();
          session = this.getSession(bufnr);
        } else {
          await doc.patchChange(true);
        }
        if (!session) {
          let config = this.getSnippetConfig(doc.uri);
          session = new SnippetSession(this.nvim, doc, config);
          session.onCancel(() => {
            this.sessionMap.delete(bufnr);
            this.statusItem.hide();
          });
        }
        let isActive = await session.start(inserted, range, select, context);
        if (isActive) {
          this.statusItem.show();
          this.sessionMap.set(bufnr, session);
        } else {
          this.statusItem.hide();
          this.sessionMap.delete(bufnr);
        }
        return isActive;
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session)
          return await session.selectCurrentPlaceholder(triggerAutocmd);
      }
      async nextPlaceholder() {
        let { session } = this;
        if (session) {
          await session.nextPlaceholder();
        } else {
          this.nvim.call("coc#snippet#disable", [], true);
          this.statusItem.hide();
        }
        return "";
      }
      async previousPlaceholder() {
        let { session } = this;
        if (session) {
          await session.previousPlaceholder();
        } else {
          this.nvim.call("coc#snippet#disable", [], true);
          this.statusItem.hide();
        }
        return "";
      }
      cancel() {
        let session = this.getSession(workspace_default.bufnr);
        if (session)
          return session.deactivate();
        this.nvim.call("coc#snippet#disable", [], true);
        if (this.statusItem)
          this.statusItem.hide();
      }
      get session() {
        return this.getSession(workspace_default.bufnr);
      }
      getSession(bufnr) {
        return this.sessionMap.get(bufnr);
      }
      jumpable() {
        let { session } = this;
        if (!session)
          return false;
        return session.placeholder != null && session.placeholder.index != 0;
      }
      async editsInsideSnippet(edits) {
        let session = this.getSession(workspace_default.bufnr);
        if (!session || !session.snippet)
          return false;
        await session.forceSynchronize();
        let range = session.snippet.range;
        if (edits.some((e) => rangeOverlap(e.range, range))) {
          return true;
        }
        return false;
      }
      async resolveSnippet(snippetString, ultisnip) {
        if (ultisnip) {
          let session = this.getSession(workspace_default.bufnr);
          if (session != null && session.snippet.hasPython)
            ultisnip.noPython = false;
        }
        return await SnippetSession.resolveSnippet(this.nvim, snippetString, ultisnip);
      }
      async normalizeInsertText(uri, snippetString, currentLine, insertTextMode) {
        let inserted = "";
        if (insertTextMode === InsertTextMode.asIs || !shouldFormat(snippetString)) {
          inserted = snippetString;
        } else {
          const currentIndent = currentLine.match(/^\s*/)[0];
          const formatOptions = window_default.activeTextEditor ? window_default.activeTextEditor.options : await workspace_default.getFormatOptions(uri);
          inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
        }
        return inserted;
      }
      dispose() {
        this.cancel();
        for (let d of this.disposables) {
          d.dispose();
        }
      }
    };
    manager_default3 = new SnippetManager();
  }
});

// src/model/line.ts
var LineBuilder;
var init_line = __esm({
  "src/model/line.ts"() {
    "use strict";
    init_string();
    LineBuilder = class {
      constructor(addSpace = false) {
        this.addSpace = addSpace;
        this._label = "";
        this._len = 0;
        this._highlights = [];
      }
      append(text, hlGroup, nested) {
        if (text.length == 0)
          return;
        let space = this._len > 0 && this.addSpace ? " " : "";
        let start = this._len + space.length;
        this._label = this._label + space + text;
        this._len = this._len + byteLength(text) + space.length;
        if (hlGroup) {
          this._highlights.push({
            hlGroup,
            span: [start, start + byteLength(text)]
          });
        }
        if (nested) {
          for (let item of nested) {
            let s = start + byteIndex(text, item.offset);
            let e = start + byteIndex(text, item.offset + item.length);
            this._highlights.push({
              hlGroup: item.hlGroup,
              span: [s, e]
            });
          }
        }
      }
      appendBuilder(builder) {
        let space = this._len > 0 && this.addSpace ? " " : "";
        let curr = this._len + space.length;
        this._label = this._label + space + builder.label;
        this._len = this._len + byteLength(builder.label) + space.length;
        this._highlights.push(...builder.highlights.map((item) => {
          return {
            hlGroup: item.hlGroup,
            span: item.span.map((v) => {
              return curr + v;
            })
          };
        }));
      }
      get label() {
        return this._label;
      }
      get highlights() {
        return this._highlights;
      }
    };
  }
});

// src/model/semanticTokensBuilder.ts
function isStringArray(value) {
  return Array.isArray(value) && value.every((elem) => typeof elem === "string");
}
function isStrArrayOrUndefined(arg) {
  return typeof arg === "undefined" || isStringArray(arg);
}
var SemanticTokensBuilder;
var init_semanticTokensBuilder = __esm({
  "src/model/semanticTokensBuilder.ts"() {
    "use strict";
    init_main();
    SemanticTokensBuilder = class {
      constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt = /* @__PURE__ */ new Map();
        this._tokenModifierStrToInt = /* @__PURE__ */ new Map();
        this._hasLegend = false;
        if (legend) {
          this._hasLegend = true;
          for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
            this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
          }
          for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
            this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
          }
        }
      }
      push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === "number" && typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && (typeof arg4 === "number" || typeof arg4 === "undefined")) {
          if (typeof arg4 === "undefined") {
            arg4 = 0;
          }
          return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (Range.is(arg0) && typeof arg1 === "string" && isStrArrayOrUndefined(arg2)) {
          return this._push(arg0, arg1, arg2);
        }
        throw new Error("Illegal argument");
      }
      _push(range, tokenType, tokenModifiers) {
        if (!this._hasLegend) {
          throw new Error("Legend must be provided in constructor");
        }
        if (range.start.line !== range.end.line) {
          throw new Error("`range` cannot span multiple lines");
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
          throw new Error("`tokenType` is not in the provided legend");
        }
        const line = range.start.line;
        const char = range.start.character;
        const length = range.end.character - range.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers) {
          for (const tokenModifier of tokenModifiers) {
            if (!this._tokenModifierStrToInt.has(tokenModifier)) {
              throw new Error("`tokenModifier` is not in the provided legend");
            }
            const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
            nTokenModifiers |= 1 << nTokenModifier >>> 0;
          }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
      }
      _pushEncoded(line, char, length, tokenType, tokenModifiers) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || line === this._prevLine && char < this._prevChar)) {
          this._dataIsSortedAndDeltaEncoded = false;
          const tokenCount = this._data.length / 5 | 0;
          let prevLine = 0;
          let prevChar = 0;
          for (let i = 0; i < tokenCount; i++) {
            let line2 = this._data[5 * i];
            let char2 = this._data[5 * i + 1];
            if (line2 === 0) {
              line2 = prevLine;
              char2 += prevChar;
            } else {
              line2 += prevLine;
            }
            this._data[5 * i] = line2;
            this._data[5 * i + 1] = char2;
            prevLine = line2;
            prevChar = char2;
          }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      static _sortAndDeltaEncode(data) {
        let pos = [];
        const tokenCount = data.length / 5 | 0;
        for (let i = 0; i < tokenCount; i++) {
          pos[i] = i;
        }
        pos.sort((a, b) => {
          const aLine = data[5 * a];
          const bLine = data[5 * b];
          if (aLine === bLine) {
            const aChar = data[5 * a + 1];
            const bChar = data[5 * b + 1];
            return aChar - bChar;
          }
          return aLine - bLine;
        });
        const result = new Array(data.length);
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
          const srcOffset = 5 * pos[i];
          const line = data[srcOffset + 0];
          const char = data[srcOffset + 1];
          const length = data[srcOffset + 2];
          const tokenType = data[srcOffset + 3];
          const tokenModifiers = data[srcOffset + 4];
          const pushLine = line - prevLine;
          const pushChar = pushLine === 0 ? char - prevChar : char;
          const dstOffset = 5 * i;
          result[dstOffset + 0] = pushLine;
          result[dstOffset + 1] = pushChar;
          result[dstOffset + 2] = length;
          result[dstOffset + 3] = tokenType;
          result[dstOffset + 4] = tokenModifiers;
          prevLine = line;
          prevChar = char;
        }
        return result;
      }
      build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
          return { data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId };
        }
        return { data: this._data, resultId };
      }
    };
  }
});

// src/tree/index.ts
var init_tree = __esm({
  "src/tree/index.ts"() {
    "use strict";
    init_TreeItem();
  }
});

// src/index.ts
var require_src3 = __commonJS({
  "src/index.ts"(exports2, module2) {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_manager();
    init_events();
    init_extension();
    init_languages();
    init_basic();
    init_manager3();
    init_download();
    init_fetch();
    init_floatFactory();
    init_highligher();
    init_mru();
    init_relativePattern();
    init_services();
    init_manager4();
    init_string2();
    init_sources2();
    init_ansiparse();
    init_errors();
    init_mutex();
    init_protocol();
    init_window();
    init_workspace();
    init_language_client();
    init_line();
    init_semanticTokensBuilder();
    init_tree();
    init_util();
    init_fs();
    init_processes();
    init_types();
    init_types2();
    init_workspaceFolder();
    module2.exports = {
      get nvim() {
        return workspace_default.nvim;
      },
      Uri: URI,
      LineBuilder,
      NullLogger,
      SettingMonitor,
      LanguageClient,
      CancellationTokenSource: import_node3.CancellationTokenSource,
      ProgressType: import_node3.ProgressType,
      RequestType: import_node3.RequestType,
      RequestType0: import_node3.RequestType0,
      NotificationType: import_node3.NotificationType,
      NotificationType0: import_node3.NotificationType0,
      ProtocolRequestType: import_node3.ProtocolRequestType,
      ProtocolRequestType0: import_node3.ProtocolRequestType0,
      ProtocolNotificationType: import_node3.ProtocolNotificationType,
      ProtocolNotificationType0: import_node3.ProtocolNotificationType0,
      Highligher: Highlighter,
      Mru,
      Emitter: import_node3.Emitter,
      SnippetString,
      BasicList,
      Mutex,
      TreeItem,
      SemanticTokensBuilder,
      FloatFactory: FloatFactoryImpl,
      RelativePattern: RelativePattern2,
      CancellationError,
      WorkspaceChange,
      ResponseError: import_node3.ResponseError,
      Trace: import_node3.Trace,
      DocumentUri,
      WorkspaceFolder,
      InlineValueText,
      InlineValueVariableLookup,
      InlineValueEvaluatableExpression,
      InlineValueContext,
      InlayHintKind,
      InlayHintLabelPart,
      InlayHint,
      DiagnosticRelatedInformation,
      SemanticTokens,
      SemanticTokenTypes,
      SemanticTokenModifiers,
      AnnotatedTextEdit,
      ChangeAnnotation,
      SymbolTag,
      Command,
      Color,
      CodeDescription,
      ColorInformation,
      ColorPresentation,
      TextDocumentEdit,
      TextDocumentIdentifier,
      VersionedTextDocumentIdentifier,
      TextDocumentItem,
      DocumentHighlight,
      SelectionRange,
      DocumentLink,
      CodeLens,
      FormattingOptions,
      CodeAction,
      CodeActionContext,
      DocumentSymbol,
      WorkspaceSymbol,
      CreateFile,
      RenameFile,
      WorkspaceEdit,
      InsertReplaceEdit,
      InsertTextMode,
      CompletionItem,
      CompletionList,
      Hover,
      ParameterInformation,
      SignatureInformation,
      SymbolInformation,
      MarkupContent,
      ErrorCodes: import_node3.ErrorCodes,
      CompletionItemTag,
      integer,
      uinteger,
      FoldingRangeKind,
      FoldingRange,
      ChangeAnnotationIdentifier,
      DeleteFile,
      OptionalVersionedTextDocumentIdentifier,
      CompletionItemLabelDetails,
      MarkedString,
      ProviderName,
      DocumentDiagnosticReportKind: import_node3.DocumentDiagnosticReportKind,
      UniquenessLevel: import_node3.UniquenessLevel,
      MonikerKind: import_node3.MonikerKind,
      PatternType,
      SourceType,
      ConfigurationTarget: ConfigurationUpdateTarget,
      ServiceStat,
      FileType,
      State,
      ClientState,
      CloseAction,
      ErrorAction,
      TransportKind,
      MessageTransports,
      RevealOutputChannelOn,
      MarkupKind,
      DiagnosticTag,
      DocumentHighlightKind,
      SymbolKind,
      SignatureHelpTriggerKind: import_node3.SignatureHelpTriggerKind,
      FileChangeType: import_node3.FileChangeType,
      CodeActionKind,
      Diagnostic,
      DiagnosticSeverity,
      CompletionItemKind,
      InsertTextFormat,
      Location,
      LocationLink,
      CancellationToken: import_node3.CancellationToken,
      Position,
      Range,
      TextEdit,
      Disposable: import_node3.Disposable,
      Event: import_node3.Event,
      workspace: workspace_default,
      window: window_default,
      CodeActionTriggerKind,
      CompletionTriggerKind: import_node3.CompletionTriggerKind,
      snippetManager: manager_default3,
      events: events_default,
      services: services_default,
      commands: commands_default,
      sources: sources_default,
      languages: languages_default,
      diagnosticManager: manager_default,
      extensions: extension_default,
      listManager: manager_default2,
      TreeItemCollapsibleState,
      terminate,
      fetch,
      download,
      ansiparse,
      disposeAll,
      concurrent,
      watchFile,
      wait,
      runCommand,
      isRunning,
      executable
    };
  }
});

// src/util/factory.ts
function removedGlobalStub(name2) {
  return () => {
    throw new Error(`process.${name2}() is not allowed in extension sandbox`);
  };
}
function makeRequireFunction(cocExports) {
  const req = (p) => {
    if (p === "coc.nvim") {
      return toObject(cocExports);
    }
    return this.require(p);
  };
  req.resolve = (request2) => Module._resolveFilename(request2, this);
  req.main = mainModule;
  req.extensions = Module._extensions;
  req.cache = Module._cache;
  return req;
}
function compileInSandbox(sandbox, cocExports) {
  return function(content, filename) {
    const require2 = makeRequireFunction.call(this, cocExports);
    const dirname = path.dirname(filename);
    const newContent = content.startsWith("#!") ? content.replace(/^#!.*/, "") : content;
    const wrapper = Module.wrap(newContent);
    const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
    const args = [this.exports, require2, this, filename, dirname];
    return compiledWrapper.apply(this.exports, args);
  };
}
function getProtoWithCompile(mod) {
  if (hasOwnProperty(mod.prototype, "_compile"))
    return mod.prototype;
  if (hasOwnProperty(mod.prototype.__proto__, "_compile"))
    return mod.prototype.__proto__;
  throw new Error("_compile not found");
}
function createSandbox(filename, logger57, name2, noExport = false) {
  const module2 = new Module(filename);
  module2.paths = Module._nodeModulePaths(filename);
  const sandbox = vm.createContext({
    module: module2,
    Buffer,
    URL: globalThis.URL,
    console: {
      debug: (...args) => {
        logger57.debug.apply(logger57, args);
      },
      log: (...args) => {
        logger57.info.apply(logger57, args);
      },
      error: (...args) => {
        logger57.error.apply(logger57, args);
      },
      info: (...args) => {
        logger57.info.apply(logger57, args);
      },
      warn: (...args) => {
        logger57.warn.apply(logger57, args);
      }
    }
  }, { name: name2 });
  defaults2(sandbox, global);
  sandbox.Reflect = Reflect;
  let cocExports = noExport ? void 0 : require_src3();
  sandbox.require = function sandboxRequire(p) {
    const oldCompile = ModuleProto._compile;
    ModuleProto._compile = compileInSandbox(sandbox, cocExports);
    const moduleExports = sandbox.module.require(p);
    ModuleProto._compile = oldCompile;
    return moduleExports;
  };
  sandbox.process = new process.constructor();
  for (let key of Object.keys(process)) {
    sandbox.process[key] = process[key];
  }
  REMOVED_GLOBALS.forEach((name3) => {
    sandbox.process[name3] = removedGlobalStub(name3);
  });
  sandbox.process["chdir"] = () => {
  };
  sandbox.process.umask = (mask) => {
    if (typeof mask !== "undefined") {
      throw new Error("Cannot use process.umask() to change mask (read-only)");
    }
    return process.umask();
  };
  return sandbox;
}
function getLogger(useConsole, id) {
  return useConsole ? consoleLogger : createLogger(`extension:${id}`);
}
function createExtension(id, filename, isEmpty2) {
  if (isEmpty2 || !fs.existsSync(filename))
    return {
      activate: () => {
      },
      deactivate: null
    };
  const logger57 = getLogger(!global.__isMain && true, id);
  const sandbox = createSandbox(filename, logger57, id);
  delete Module._cache[require.resolve(filename)];
  const defaultImport = sandbox.require(filename);
  const activate = defaultImport && defaultImport.activate || defaultImport;
  if (typeof activate !== "function")
    return { activate: () => {
    } };
  return typeof defaultImport === "function" ? { activate } : Object.assign({}, defaultImport);
}
var consoleLogger, Module, mainModule, REMOVED_GLOBALS, ModuleProto;
var init_factory = __esm({
  "src/util/factory.ts"() {
    "use strict";
    init_logger();
    init_node();
    init_lodash();
    init_object();
    consoleLogger = {
      category: "",
      log: console.log.bind(console),
      debug: console.debug.bind(console),
      error: console.error.bind(console),
      warn: console.warn.bind(console),
      info: console.info.bind(console),
      trace: console.log.bind(console),
      fatal: console.error.bind(console),
      mark: console.log.bind(console)
    };
    Module = require("module");
    mainModule = require.main;
    REMOVED_GLOBALS = [
      "reallyExit",
      "abort",
      "umask",
      "setuid",
      "setgid",
      "setgroups",
      "_fatalException",
      "exit",
      "kill"
    ];
    ModuleProto = getProtoWithCompile(Module);
  }
});

// src/util/timing.ts
function createTiming(name2, timeout2) {
  let start;
  let timer;
  let _label;
  return {
    start(label) {
      _label = label;
      start = Date.now();
      clearTimeout(timer);
      if (timeout2) {
        timer = setTimeout(() => {
          logger37.error(`${name2} timeout after ${timeout2}ms`);
        }, timeout2);
        timer.unref();
      }
    },
    stop() {
      clearTimeout(timer);
      logger37.trace(`${name2}${_label ? ` ${_label}` : ""} cost:`, Date.now() - start);
    }
  };
}
var logger37;
var init_timing = __esm({
  "src/util/timing.ts"() {
    "use strict";
    init_logger();
    logger37 = createLogger("timing");
  }
});

// src/extension/stat.ts
function toInterval(opt) {
  return opt === "daily" ? ONE_DAY : ONE_DAY * 7;
}
function validExtensionFolder(folder, version2) {
  let errors = [];
  let res = loadExtensionJson(folder, version2, errors);
  return res != null && errors.length == 0;
}
function getEntryFile(main) {
  if (!main)
    return "index.js";
  if (!main.endsWith(".js"))
    return main + ".js";
  return main;
}
async function loadGlobalJsonAsync(folder, version2) {
  let jsonFile = path.join(folder, "package.json");
  let content = await readFile(jsonFile, "utf8");
  let packageJSON = JSON.parse(content);
  let { engines } = packageJSON;
  let main = getEntryFile(packageJSON.main);
  if (!engines || typeof engines.coc !== "string" && typeof engines.vscode !== "string")
    throw new Error("Invalid engines field");
  let keys = Object.keys(engines);
  if (keys.includes("coc") && !semver.satisfies(version2, engines["coc"].replace(/^\^/, ">="))) {
    throw new Error(`coc.nvim version not match, required ${engines["coc"]}`);
  }
  if (!engines.vscode && !fs.existsSync(path.join(folder, main))) {
    throw new Error(`main file ${main} not found, you may need to build the project.`);
  }
  return packageJSON;
}
function loadExtensionJson(folder, version2, errors) {
  let jsonFile = path.join(folder, "package.json");
  if (!fs.existsSync(jsonFile)) {
    errors.push(`package.json not found in ${folder}`);
    return void 0;
  }
  let packageJSON = loadJson2(jsonFile);
  let { name: name2, engines } = packageJSON;
  let main = getEntryFile(packageJSON.main);
  if (!name2)
    errors.push(`can't find name in package.json`);
  if (!engines || !objectLiteral(engines)) {
    errors.push(`invalid engines in ${jsonFile}`);
  }
  if (engines && !engines.vscode && !fs.existsSync(path.join(folder, main))) {
    errors.push(`main file ${main} not found, you may need to build the project.`);
  }
  if (engines) {
    let keys = Object.keys(engines);
    if (!keys.includes("coc") && !keys.includes("vscode")) {
      errors.push(`Engines in package.json doesn't have coc or vscode`);
    }
    if (keys.includes("coc")) {
      let required = engines["coc"].replace(/^\^/, ">=");
      if (!semver.satisfies(version2, required)) {
        errors.push(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines["coc"]}`);
      }
    }
  }
  return packageJSON;
}
function getExtensionName(def) {
  if (/^https?:/.test(def))
    return def;
  if (!def.includes("@"))
    return def;
  return def.replace(/@[\d.]+$/, "");
}
function checkExtensionRoot(root) {
  try {
    if (!fs.existsSync(root)) {
      fs.mkdirSync(root, { recursive: true });
    }
    let stat = fs.statSync(root);
    if (!stat.isDirectory()) {
      logger38.info(`Trying to delete ${root}`);
      fs.unlinkSync(root);
      fs.mkdirSync(root, { recursive: true });
    }
    let jsonFile = path.join(root, "package.json");
    if (!fs.existsSync(jsonFile)) {
      fs.writeFileSync(jsonFile, '{"dependencies":{}}', "utf8");
    }
  } catch (e) {
    console.error(`Unexpected error when check data home ${root}: ${e}`);
    return false;
  }
  return true;
}
async function getJsFiles(folder) {
  if (!fs.existsSync(folder))
    return [];
  let files = await (0, import_util.promisify)(fs.readdir)(folder);
  return files.filter((f) => f.endsWith(".js"));
}
function loadJson2(filepath) {
  try {
    let text = fs.readFileSync(filepath, "utf8");
    let data = JSON.parse(text);
    return toObject(data);
  } catch (e) {
    logger38.error(`Error on parse json file ${filepath}`, e);
    return {};
  }
}
var logger38, ONE_DAY, ExtensionStat;
var init_stat = __esm({
  "src/extension/stat.ts"() {
    "use strict";
    init_logger();
    init_array();
    init_fs();
    init_is();
    init_node();
    init_object();
    logger38 = createLogger("extension-stat");
    ONE_DAY = 24 * 60 * 60 * 1e3;
    ExtensionStat = class {
      constructor(folder) {
        this.folder = folder;
        this.disabled = /* @__PURE__ */ new Set();
        this.locked = /* @__PURE__ */ new Set();
        this.extensions = /* @__PURE__ */ new Set();
        this.localExtensions = /* @__PURE__ */ new Map();
        try {
          this.migrate();
        } catch (e) {
          logger38.error(`Error on update package.json at ${folder}`, e);
        }
      }
      migrate() {
        let curr = loadJson2(this.jsonFile);
        let db = path.join(this.folder, "db.json");
        let changed = false;
        if (fs.existsSync(db)) {
          let obj = loadJson2(db);
          let def = obj.extension ?? {};
          for (let [key, o] of Object.entries(def)) {
            if (o.disabled)
              this.disabled.add(key);
            if (o.locked)
              this.locked.add(key);
          }
          curr.disabled = Array.from(this.disabled);
          curr.locked = Array.from(this.locked);
          curr.lastUpdate - obj.lastUpdate;
          fs.unlinkSync(db);
          changed = true;
        } else {
          this.disabled = new Set(curr.disabled ?? []);
          this.locked = new Set(curr.locked ?? []);
        }
        if (changed)
          writeJson(this.jsonFile, curr);
        let ids = Object.keys(curr.dependencies ?? {});
        this.extensions = new Set(ids);
      }
      *activated() {
        let { disabled } = this;
        for (let key of Object.keys(this.dependencies)) {
          if (!disabled.has(key)) {
            yield key;
          }
        }
      }
      addLocalExtension(name2, folder) {
        this.localExtensions.set(name2, folder);
      }
      getFolder(name2) {
        if (this.extensions.has(name2))
          return path.join(this.folder, "node_modules", name2);
        return this.localExtensions.get(name2);
      }
      getExtensionsStat() {
        let res = {};
        for (let id of this.extensions) {
          if (this.disabled.has(id)) {
            res[id] = 1 /* Disabled */;
          } else if (this.locked.has(id)) {
            res[id] = 2 /* Locked */;
          } else {
            res[id] = 0 /* Normal */;
          }
        }
        return res;
      }
      hasExtension(id) {
        return this.extensions.has(id);
      }
      addExtension(id, val) {
        let curr = loadJson2(this.jsonFile);
        curr.dependencies = curr.dependencies ?? {};
        curr.dependencies[id] = val;
        this.extensions.add(id);
        writeJson(this.jsonFile, curr);
      }
      removeExtension(id) {
        let curr = loadJson2(this.jsonFile);
        if (curr.disabled)
          curr.disabled = curr.disabled.filter((key) => key !== id);
        if (curr.locked)
          curr.locked = curr.locked.filter((key) => key !== id);
        curr.dependencies = curr.dependencies ?? {};
        delete curr.dependencies[id];
        this.extensions.delete(id);
        writeJson(this.jsonFile, curr);
      }
      isDisabled(id) {
        return this.disabled.has(id);
      }
      get lockedExtensions() {
        return Array.from(this.locked);
      }
      get disabledExtensions() {
        return Array.from(this.disabled);
      }
      get dependencies() {
        let curr = loadJson2(this.jsonFile);
        return curr.dependencies ?? {};
      }
      setDisable(id, disable) {
        if (disable) {
          this.disabled.add(id);
        } else {
          this.disabled.delete(id);
        }
        this.update("disabled", Array.from(this.disabled));
      }
      setLocked(id, locked) {
        if (locked) {
          this.locked.add(id);
        } else {
          this.locked.delete(id);
        }
        this.update("locked", Array.from(this.disabled));
      }
      setLastUpdate() {
        this.update("lastUpdate", Date.now());
      }
      shouldUpdate(opt) {
        if (opt === "never")
          return false;
        let interval2 = toInterval(opt);
        let curr = loadJson2(this.jsonFile);
        return curr.lastUpdate == null || Date.now() - curr.lastUpdate > interval2;
      }
      get globalIds() {
        let curr = loadJson2(this.jsonFile);
        return Object.keys(curr.dependencies ?? {});
      }
      filterGlobalExtensions(names) {
        let disabledExtensions = this.disabledExtensions;
        let dependencies = this.dependencies;
        let map = /* @__PURE__ */ new Map();
        toArray(names).forEach((def) => {
          if (!def || typeof def !== "string")
            return;
          let name2 = getExtensionName(def);
          map.set(name2, def);
        });
        let currentUrls = [];
        let exists = [];
        for (let [key, val] of Object.entries(dependencies)) {
          if (fs.existsSync(path.join(this.folder, "node_modules", key, "package.json"))) {
            exists.push(key);
            if (typeof val === "string" && /^https?:/.test(val)) {
              currentUrls.push(val);
            }
          }
        }
        for (let name2 of map.keys()) {
          if (disabledExtensions.includes(name2) || this.extensions.has(name2)) {
            map.delete(name2);
            continue;
          }
          if (/^https?:/.test(name2) && currentUrls.some((url) => url.startsWith(name2)) || exists.includes(name2)) {
            map.delete(name2);
          }
        }
        return Array.from(map.values());
      }
      update(key, value) {
        let curr = loadJson2(this.jsonFile);
        curr[key] = value;
        writeJson(this.jsonFile, curr);
      }
      get jsonFile() {
        return path.join(this.folder, "package.json");
      }
    };
  }
});

// src/extension/manager.ts
function getEvents(activationEvents) {
  let res = [];
  for (let ev of toArray(activationEvents)) {
    let [name2] = ev.split(":", 2);
    if (name2 && !res.includes(name2))
      res.push(name2);
  }
  return res;
}
function getOnCommandList(activationEvents) {
  let res = [];
  for (let ev of toArray(activationEvents)) {
    let [name2, command] = ev.split(":", 2);
    if (name2 === "onCommand" /* OnCommand */ && command)
      res.push(command);
  }
  return res;
}
function checkLanguageId(document2, activationEvents) {
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    let ev = parts[0];
    if (ev == "onLanguage" /* OnLanguage */ && (document2.languageId == parts[1] || document2.filetype == parts[1])) {
      return true;
    }
  }
  return false;
}
function checkCommand(command, activationEvents) {
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    let ev = parts[0];
    if (ev == "onCommand" /* OnCommand */ && command == parts[1]) {
      return true;
    }
  }
  return false;
}
function checkFileSystem(uri, activationEvents) {
  let scheme = URI.parse(uri).scheme;
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    let ev = parts[0];
    if (ev == "onFileSystem" /* OnFileSystem */ && scheme == parts[1]) {
      return true;
    }
  }
  return false;
}
function getActivationEvents(json) {
  return toArray(json.activationEvents).filter((key) => typeof key === "string" && key.length > 0);
}
function toWorkspaceContinsPatterns(activationEvents) {
  let patterns = [];
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    if (parts[0] == "workspaceContains" /* WorkspaceContains */ && parts[1]) {
      patterns.push(parts[1]);
    }
  }
  return patterns;
}
var logger39, extensionRegistry5, memos, configurationRegistry2, ExtensionManager;
var init_manager5 = __esm({
  "src/extension/manager.ts"() {
    "use strict";
    init_esm();
    init_registry2();
    init_types();
    init_watchman();
    init_events();
    init_logger();
    init_memos();
    init_util();
    init_array();
    init_constants();
    init_extensionRegistry();
    init_factory();
    init_fs();
    init_is();
    init_lodash();
    init_node();
    init_object();
    init_protocol();
    init_registry();
    init_timing();
    init_window();
    init_workspace();
    init_stat();
    logger39 = createLogger("extensions-manager");
    extensionRegistry5 = Registry.as(Extensions.ExtensionContribution);
    memos = new Memos(path.resolve(dataHome, "memos.json"));
    memos.merge(path.resolve(dataHome, "../memos.json"));
    configurationRegistry2 = Registry.as(Extensions3.Configuration);
    ExtensionManager = class {
      constructor(states, folder) {
        this.states = states;
        this.folder = folder;
        this.activated = false;
        this.disposables = [];
        this.configurationNodes = [];
        this.extensions = /* @__PURE__ */ new Map();
        this._onDidLoadExtension = new import_node3.Emitter();
        this._onDidActiveExtension = new import_node3.Emitter();
        this._onDidUnloadExtension = new import_node3.Emitter();
        this.singleExtensionsRoot = path.join(configHome, "coc-extensions");
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        this.modulesFolder = path.join(this.folder, "node_modules");
      }
      activateExtensions() {
        this.activated = true;
        if (process.env.COC_NO_PLUGINS == "1")
          return;
        configurationRegistry2.registerConfigurations(this.configurationNodes);
        this.attachEvents();
        let promises = [];
        for (let key of this.extensions.keys()) {
          const { extension } = this.extensions.get(key);
          const activationEvents = extension.packageJSON.activationEvents;
          if (!activationEvents || activationEvents.includes("*")) {
            promises.push(void extension.activate());
          } else {
            void this.autoActiavte(key, extension);
          }
        }
        return Promise.allSettled(promises);
      }
      async loadFileExtensions() {
        let folder = this.singleExtensionsRoot;
        let files = await getJsFiles(folder);
        await Promise.allSettled(files.map((file) => {
          return this.loadExtensionFile(path.join(folder, file));
        }));
      }
      attachEvents() {
        workspace_default.onDidRuntimePathChange(async (paths) => {
          let folders = paths.filter((p) => p && validExtensionFolder(p, workspace_default.version));
          let outputChannel = window_default.createOutputChannel("extensions");
          await Promise.allSettled(folders.map((folder) => {
            outputChannel.appendLine(`Loading extension from runtimepath: ${folder}`);
            return this.loadExtension(folder);
          }));
        }, null, this.disposables);
        workspace_default.onDidOpenTextDocument((document2) => {
          let doc = workspace_default.getDocument(document2.bufnr);
          this.tryActivateExtensions("onLanguage" /* OnLanguage */, (events) => {
            return checkLanguageId(doc, events);
          });
          this.tryActivateExtensions("onFileSystem" /* OnFileSystem */, (events) => {
            return checkFileSystem(doc.uri, events);
          });
        }, null, this.disposables);
        events_default.on("Command", async (command) => {
          let fired = false;
          this.tryActivateExtensions("onCommand" /* OnCommand */, (events) => {
            let result = checkCommand(command, events);
            if (result)
              fired = true;
            return result;
          });
          if (fired)
            await wait(50);
        }, null, this.disposables);
        workspace_default.onDidChangeWorkspaceFolders((e) => {
          if (e.added.length > 0) {
            this.tryActivateExtensions("workspaceContains" /* WorkspaceContains */, (events) => {
              let patterns = toWorkspaceContinsPatterns(events);
              return workspace_default.checkPatterns(patterns, e.added);
            });
          }
        }, null, this.disposables);
      }
      async cleanExtensions() {
        let { globalIds } = this.states;
        await remove(this.modulesFolder);
        return globalIds.filter((id) => !this.states.isDisabled(id));
      }
      tryActivateExtensions(event, check) {
        for (let item of this.extensions.values()) {
          if (item.extension.isActive)
            continue;
          let events = item.events;
          if (!events.includes(event))
            continue;
          let { extension } = item;
          let activationEvents = getActivationEvents(extension.packageJSON);
          void Promise.resolve(check(activationEvents)).then((checked) => {
            if (checked)
              void Promise.resolve(extension.activate());
          });
        }
      }
      async checkAutoActivate(packageJSON) {
        let activationEvents = getActivationEvents(packageJSON);
        if (activationEvents.length === 0 || activationEvents.includes("*")) {
          return true;
        }
        let patterns = [];
        for (let eventName of activationEvents) {
          let parts = eventName.split(":");
          let ev = parts[0];
          if (ev === "onLanguage" /* OnLanguage */) {
            if (workspace_default.languageIds.has(parts[1]) || workspace_default.filetypes.has(parts[1])) {
              return true;
            }
          } else if (ev === "workspaceContains" /* WorkspaceContains */ && parts[1]) {
            patterns.push(parts[1]);
          } else if (ev === "onFileSystem" /* OnFileSystem */) {
            for (let doc of workspace_default.documents) {
              let u = URI.parse(doc.uri);
              if (u.scheme == parts[1]) {
                return true;
              }
            }
          }
        }
        if (patterns.length > 0) {
          let res = await workspace_default.checkPatterns(patterns);
          if (res)
            return true;
        }
        return false;
      }
      has(id) {
        return this.extensions.has(id);
      }
      getExtension(id) {
        return this.extensions.get(id);
      }
      get loadedExtensions() {
        return Array.from(this.extensions.keys());
      }
      get all() {
        return Array.from(this.extensions.values()).map((o) => o.extension);
      }
      async activate(id) {
        let item = this.extensions.get(id);
        if (!item)
          throw new Error(`Extension ${id} not registered!`);
        let { extension } = item;
        if (extension.isActive)
          return true;
        await Promise.resolve(extension.activate());
        return extension.isActive === true;
      }
      async deactivate(id) {
        let item = this.extensions.get(id);
        if (!item || !item.extension.isActive)
          return;
        await Promise.resolve(item.deactivate());
      }
      async loadExtension(folder, noActive = false) {
        if (Array.isArray(folder)) {
          let results = await Promise.allSettled(folder.map((f) => {
            return this.loadExtension(f, noActive);
          }));
          results.forEach((res) => {
            if (res.status === "rejected")
              throw new Error(`Error on loadExtension ${res.reason}`);
          });
          return true;
        }
        let errors = [];
        let obj = loadExtensionJson(folder, workspace_default.version, errors);
        if (errors.length > 0)
          throw new Error(errors[0]);
        let { name: name2 } = obj;
        if (this.states.isDisabled(name2))
          return false;
        await this.unloadExtension(name2);
        let isLocal = !this.states.hasExtension(name2);
        if (isLocal)
          this.states.addLocalExtension(name2, folder);
        await this.registerExtension(folder, Object.freeze(obj), isLocal ? 1 /* Local */ : 0 /* Global */, noActive);
        return true;
      }
      async unloadExtension(id) {
        let item = this.extensions.get(id);
        if (item) {
          await this.deactivate(id);
          this.extensions.delete(id);
          this._onDidUnloadExtension.fire(id);
        }
      }
      async reloadExtension(id) {
        let item = this.extensions.get(id);
        if (!item || item.type == 3 /* Internal */) {
          throw new Error(`Extension ${id} not registered`);
        }
        if (item.type == 2 /* SingleFile */) {
          await this.loadExtensionFile(item.filepath);
        } else {
          await this.loadExtension(item.directory);
        }
      }
      async call(id, method, args) {
        let item = this.extensions.get(id);
        if (!item)
          throw new Error(`extension ${id} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
          await this.activate(id);
        }
        let { exports: exports2 } = extension;
        if (!exports2 || typeof exports2[method] !== "function") {
          throw new Error(`method ${method} not found on extension ${id}`);
        }
        return await Promise.resolve(exports2[method].apply(null, args));
      }
      registContribution(id, packageJSON, directory, filepath) {
        let { contributes, activationEvents } = packageJSON;
        let { configuration: configuration2, rootPatterns, commands } = contributes ?? {};
        let definitions;
        let props = getProperties(configuration2 ?? {});
        if (!isEmpty(props)) {
          let properties = convertProperties(props, 2 /* WINDOW */);
          if (objectLiteral(configuration2.definitions)) {
            let prefix = id.replace(/[^\w]/g, "");
            const addPrefix = (obj, key) => {
              if (key == "$ref") {
                let val = obj[key];
                if (string(val) && val.startsWith("#/definitions/")) {
                  obj[key] = val.slice(0, 14) + prefix + "." + val.slice(14);
                }
              }
            };
            deepIterate(properties, addPrefix);
            definitions = {};
            Object.entries(deepClone(configuration2.definitions)).forEach(([key, val]) => {
              if (objectLiteral(val)) {
                definitions[prefix + "." + key] = val;
                deepIterate(val, addPrefix);
              }
            });
          }
          let node = { properties, extensionInfo: { id, displayName: packageJSON.displayName } };
          this.configurationNodes.push(node);
          if (this.activated) {
            let toRemove = [];
            let idx = this.configurationNodes.findIndex((o) => o.extensionInfo.id === id);
            if (idx !== -1) {
              toRemove.push(this.configurationNodes[idx]);
              this.configurationNodes.splice(idx, 1);
            }
            workspace_default.configurations.updateConfigurations([node], toRemove);
          }
        }
        extensionRegistry5.registerExtension(id, {
          name: id,
          directory,
          filepath,
          commands,
          definitions,
          rootPatterns,
          onCommands: getOnCommandList(activationEvents)
        });
      }
      getExtensionState(id) {
        let disabled = this.states.isDisabled(id);
        if (disabled)
          return "disabled";
        let item = this.getExtension(id);
        if (!item)
          return "unknown";
        let { extension } = item;
        return extension.isActive ? "activated" : "loaded";
      }
      async autoActiavte(id, extension) {
        try {
          let checked = await this.checkAutoActivate(extension.packageJSON);
          if (checked)
            await Promise.resolve(extension.activate());
        } catch (e) {
          logger39.error(`Error on activate ${id}`, e);
        }
      }
      async loadExtensionFile(filepath, noActive = false) {
        let stat = await statAsync(filepath);
        if (!stat || !stat.isFile())
          return;
        let filename = path.basename(filepath);
        let basename = path.basename(filepath, ".js");
        let name2 = "single-" + basename;
        let root = path.dirname(filepath);
        let packageJSON = { name: name2, main: filename, engines: { coc: ">=0.0.82" } };
        let confpath = path.join(root, basename + ".json");
        let obj = loadJson(confpath);
        for (const attr of ["activationEvents", "contributes"]) {
          packageJSON[attr] = obj[attr];
        }
        await this.unloadExtension(name2);
        await this.registerExtension(root, packageJSON, 2 /* SingleFile */, noActive);
        return name2;
      }
      registerExtensions(stats) {
        for (let stat of stats) {
          try {
            let extensionType = stat.isLocal ? 1 /* Local */ : 0 /* Global */;
            void this.registerExtension(stat.root, stat.packageJSON, extensionType);
          } catch (e) {
            logger39.error(`Error on regist extension from ${stat.root}: `, e);
          }
        }
      }
      async registerExtension(root, packageJSON, extensionType, noActive = false) {
        let id = packageJSON.name;
        if (this.states.isDisabled(id))
          return;
        let isActive = false;
        let result;
        let filename = path.join(root, packageJSON.main || "index.js");
        let extensionPath = extensionType === 2 /* SingleFile */ ? filename : root;
        let exports2;
        let ext;
        let subscriptions = [];
        const timing = createTiming(`activate ${id}`, 5e3);
        let extension = {
          activate: () => {
            if (result)
              return result;
            result = new Promise(async (resolve, reject) => {
              timing.start();
              try {
                let isEmpty2 = typeof packageJSON.engines.coc === "undefined";
                ext = createExtension(id, filename, isEmpty2);
                let context = {
                  subscriptions,
                  extensionPath,
                  globalState: memos.createMemento(`${id}|global`),
                  workspaceState: memos.createMemento(`${id}|${workspace_default.rootPath}`),
                  asAbsolutePath: (relativePath) => path.join(root, relativePath),
                  storagePath: path.join(this.folder, `${id}-data`),
                  logger: createLogger(`extension:${id}`)
                };
                let res = await Promise.resolve(ext.activate(context));
                isActive = true;
                exports2 = res;
                this._onDidActiveExtension.fire(extension);
                timing.stop();
                resolve(res);
              } catch (e) {
                logger39.error(`Error on active extension ${id}:`, e);
                reject(e);
              }
            });
            return result;
          },
          id,
          packageJSON,
          extensionPath,
          get isActive() {
            return isActive;
          },
          get module() {
            return ext;
          },
          get exports() {
            if (!isActive)
              throw new Error(`Invalid access to exports, extension "${id}" not activated`);
            return exports2;
          }
        };
        Object.freeze(extension);
        this.extensions.set(id, {
          id,
          type: extensionType,
          isLocal: extensionType == 1 /* Local */,
          extension,
          directory: root,
          filepath: filename,
          events: getEvents(packageJSON.activationEvents),
          deactivate: async () => {
            if (!isActive)
              return;
            isActive = false;
            result = void 0;
            exports2 = void 0;
            disposeAll(subscriptions);
            if (ext && typeof ext.deactivate === "function") {
              try {
                await Promise.resolve(ext.deactivate());
                ext = void 0;
              } catch (e) {
                logger39.error(`Error on ${id} deactivate: `, e);
              }
            }
          }
        });
        this.registContribution(id, packageJSON, root, filename);
        this._onDidLoadExtension.fire(extension);
        if (this.activated && !noActive)
          await this.autoActiavte(id, extension);
      }
      unregistContribution(id) {
        let idx = this.configurationNodes.findIndex((o) => o.extensionInfo.id === id);
        extensionRegistry5.unregistExtension(id);
        if (idx !== -1) {
          let node = this.configurationNodes[idx];
          this.configurationNodes.splice(idx, 1);
          configurationRegistry2.deregisterConfigurations([node]);
        }
      }
      async registerInternalExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.extensions.set(id, {
          id,
          directory: __dirname,
          type: 3 /* Internal */,
          events: getEvents(packageJSON.activationEvents),
          extension,
          deactivate,
          isLocal: true
        });
        this.registContribution(id, packageJSON, __dirname);
        this._onDidLoadExtension.fire(extension);
        await this.autoActiavte(id, extension);
      }
      async uninstallExtensions(ids) {
        let [globals, filtered] = splitArray(ids, (id) => this.states.hasExtension(id));
        for (let id of globals) {
          await this.unloadExtension(id);
          this.states.removeExtension(id);
          extensionRegistry5.unregistExtension(id);
          await remove(path.join(this.modulesFolder, id));
        }
        if (filtered.length > 0) {
          void window_default.showWarningMessage(`Global extensions ${filtered.join(", ")} not found`);
        }
        if (globals.length > 0) {
          void window_default.showInformationMessage(`Removed extensions: ${globals.join(" ")}`);
        }
      }
      async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == "activated")
          await this.deactivate(id);
        if (state != "disabled") {
          this.states.setDisable(id, true);
          this.unregistContribution(id);
          await this.unloadExtension(id);
        } else {
          this.states.setDisable(id, false);
          if (id.startsWith("single-")) {
            let filepath = path.join(this.singleExtensionsRoot, `${id.replace(/^single-/, "")}.js`);
            await this.loadExtensionFile(filepath);
          } else {
            let folder = this.states.getFolder(id);
            if (folder) {
              await this.loadExtension(folder);
            } else {
              void window_default.showWarningMessage(`Extension ${id} not found`);
            }
          }
        }
      }
      async watchExtension(id) {
        let item = this.getExtension(id);
        if (!item)
          throw new Error(`extension ${id} not found`);
        if (id.startsWith("single-")) {
          void window_default.showInformationMessage(`watching ${item.filepath}`);
          this.disposables.push(watchFile(item.filepath, async () => {
            await this.loadExtensionFile(item.filepath);
            void window_default.showInformationMessage(`reloaded ${id}`);
          }, false));
        } else {
          let watchmanPath = workspace_default.getWatchmanPath();
          if (!watchmanPath)
            throw new Error("watchman not found");
          let client = await Watchman.createClient(watchmanPath, item.directory);
          this.disposables.push(client);
          void window_default.showInformationMessage(`watching ${item.directory}`);
          await client.subscribe("**/*.js", async () => {
            await this.reloadExtension(id);
            void window_default.showInformationMessage(`reloaded ${id}`);
          });
        }
      }
      async load(filepath, active) {
        let name2;
        if (isDirectory(filepath)) {
          let obj = loadJson(path.join(filepath, "package.json"));
          name2 = obj.name;
          await this.loadExtension(filepath, true);
        } else {
          name2 = await this.loadExtensionFile(filepath, true);
        }
        if (!name2)
          throw new Error(`Unable to load extension at ${filepath}`);
        let disabled = this.states.isDisabled(name2);
        if (disabled)
          throw new Error(`extension ${name2} is disabled`);
        let item = this.getExtension(name2);
        if (active)
          await item.extension.activate();
        return {
          get isActive() {
            return item.extension.isActive;
          },
          get name() {
            return name2;
          },
          get api() {
            return item.extension.exports;
          },
          get exports() {
            let module2 = item.extension.module ?? {};
            return omit(module2, ["activate"]);
          },
          unload: () => {
            return this.unloadExtension(name2);
          }
        };
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/extension/ui.ts
var interval, InstallChannel, debounceTime6, InstallBuffer;
var init_ui3 = __esm({
  "src/extension/ui.ts"() {
    "use strict";
    init_events();
    init_status();
    init_util();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    interval = getConditionValue(100, 1);
    InstallChannel = class {
      constructor(isUpdate, channel) {
        this.isUpdate = isUpdate;
        this.channel = channel;
      }
      start(names) {
        this.channel.appendLine(`${this.isUpdate ? "Updating" : "Installing"} ${names.join(", ")}`);
      }
      addMessage(name2, msg, isProgress) {
        if (!isProgress) {
          this.channel.appendLine(`${name2} - ${msg}`);
        }
      }
      startProgress(name2) {
        this.channel.appendLine(`Start ${this.isUpdate ? "update" : "install"} ${name2}`);
      }
      finishProgress(name2, succeed) {
        if (succeed) {
          this.channel.appendLine(`${name2} ${this.isUpdate ? "update" : "install"} succeed!`);
        } else {
          this.channel.appendLine(`${name2} ${this.isUpdate ? "update" : "install"} failed!`);
        }
      }
    };
    debounceTime6 = getConditionValue(500, 10);
    InstallBuffer = class {
      constructor(isUpdate) {
        this.isUpdate = isUpdate;
        this.statMap = /* @__PURE__ */ new Map();
        this.updated = /* @__PURE__ */ new Set();
        this.messagesMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.names = [];
        let floatFactory4 = window_default.createFloatFactory({ modes: ["n"] });
        this.disposables.push(floatFactory4);
        let fn = debounce(async (bufnr, cursor) => {
          if (bufnr == this.bufnr) {
            let msgs = this.getMessages(cursor[0] - 1);
            let docs = msgs.length > 0 ? [{ content: msgs.join("\n"), filetype: "txt" }] : [];
            await floatFactory4.show(docs);
          }
        }, debounceTime6);
        this.disposables.push(import_node3.Disposable.create(() => {
          fn.clear();
        }));
        events_default.on("CursorMoved", fn, this.disposables);
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr === this.bufnr) {
            this.dispose();
          }
        }, null, this.disposables);
      }
      async start(names) {
        this.statMap.clear();
        this.names = names;
        for (let name2 of names) {
          this.statMap.set(name2, 0 /* Waiting */);
        }
        await this.show();
      }
      addMessage(name2, msg) {
        let lines = this.messagesMap.get(name2) || [];
        this.messagesMap.set(name2, lines.concat(msg.trim().split(/\r?\n/)));
        if (msg.startsWith("Updated to") || msg.startsWith("Installed extension")) {
          this.updated.add(name2);
        }
      }
      startProgress(name2) {
        this.statMap.set(name2, 2 /* Progressing */);
      }
      finishProgress(name2, succeed) {
        this.statMap.set(name2, succeed ? 3 /* Success */ : 1 /* Failed */);
      }
      get remains() {
        let count = 0;
        for (let name2 of this.names) {
          let stat = this.statMap.get(name2);
          if (![3 /* Success */, 1 /* Failed */].includes(stat)) {
            count = count + 1;
          }
        }
        return count;
      }
      getLinesAndHighlights(start) {
        let lines = [];
        let highlights = [];
        for (let name2 of this.names) {
          let state = this.statMap.get(name2);
          let processText = "*";
          let hlGroup;
          let lnum = start + lines.length;
          switch (state) {
            case 2 /* Progressing */: {
              let d = new Date();
              let idx = Math.floor(d.getMilliseconds() / 100);
              processText = frames[idx];
              hlGroup = void 0;
              break;
            }
            case 1 /* Failed */:
              processText = "\u2717";
              hlGroup = "ErrorMsg";
              break;
            case 3 /* Success */:
              processText = "\u2713";
              hlGroup = this.updated.has(name2) ? "MoreMsg" : "Comment";
              break;
          }
          let msgs = this.messagesMap.get(name2) || [];
          let pre = `- ${processText} `;
          let len = byteLength(pre);
          if (hlGroup) {
            highlights.push({ hlGroup, lnum, colStart: len, colEnd: len + byteLength(name2) });
          }
          lines.push(`${pre}${name2} ${msgs.length ? msgs[msgs.length - 1] : ""}`);
        }
        return { lines, highlights };
      }
      getMessages(line) {
        let name2 = this.names[line - 2];
        return this.messagesMap.get(name2) ?? [];
      }
      get stopped() {
        return this.interval == null;
      }
      draw() {
        let { remains, bufnr } = this;
        let { nvim } = workspace_default;
        if (!bufnr)
          return;
        let buffer = nvim.createBuffer(bufnr);
        let first = remains == 0 ? `${this.isUpdate ? "Update" : "Install"} finished` : `Installing, ${remains} remaining...`;
        let { lines, highlights } = this.getLinesAndHighlights(2);
        nvim.pauseNotification();
        buffer.setLines([first, "", ...lines], { start: 0, end: -1, strictIndexing: false }, true);
        buffer.updateHighlights("coc-extensions", highlights, { priority: 99 });
        if (remains == 0 && this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
        nvim.resumeNotification(true, true);
      }
      highlight() {
        let { nvim } = workspace_default;
        nvim.call("matchadd", ["CocListFgCyan", "^\\-\\s\\zs\\*"], true);
        nvim.call("matchadd", ["CocListFgGreen", "^\\-\\s\\zs\u2713"], true);
        nvim.call("matchadd", ["CocListFgRed", "^\\-\\s\\zs\u2717"], true);
      }
      async show() {
        let isSync = events_default.requesting === true;
        let { nvim } = workspace_default;
        nvim.pauseNotification();
        nvim.command(isSync ? "enew" : "vs +enew", true);
        nvim.call("bufnr", ["%"], true);
        nvim.command("setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1", true);
        if (!isSync)
          nvim.command("nnoremap <silent><nowait><buffer> q :q<CR>", true);
        this.highlight();
        let res = await nvim.resumeNotification();
        this.bufnr = res[0][1];
        this.interval = setInterval(() => {
          this.draw();
        }, interval);
      }
      dispose() {
        this.bufnr = void 0;
        this.messagesMap.clear();
        this.statMap.clear();
        disposeAll(this.disposables);
        clearInterval(this.interval);
        this.interval = null;
      }
    };
  }
});

// src/extension/index.ts
function toUrl(val) {
  return isUrl(val) ? val.replace(/\.git(#master|#main)?$/, "") : "";
}
var logger40, EXTENSIONS_FOLDER, Extensions4, extension_default;
var init_extension = __esm({
  "src/extension/index.ts"() {
    "use strict";
    init_commands();
    init_types();
    init_logger();
    init_util();
    init_array();
    init_constants();
    init_is();
    init_node();
    init_processes();
    init_window();
    init_workspace();
    init_installer();
    init_manager5();
    init_stat();
    init_ui3();
    logger40 = createLogger("extensions-index");
    EXTENSIONS_FOLDER = path.join(dataHome, "extensions");
    Extensions4 = class {
      constructor() {
        this.modulesFolder = path.join(EXTENSIONS_FOLDER, "node_modules");
        checkExtensionRoot(EXTENSIONS_FOLDER);
        this.states = new ExtensionStat(EXTENSIONS_FOLDER);
        this.manager = new ExtensionManager(this.states, EXTENSIONS_FOLDER);
        commands_default.register({
          id: "extensions.forceUpdateAll",
          execute: async () => {
            let arr = await this.manager.cleanExtensions();
            logger40.info(`Force update extensions: ${arr}`);
            await this.installExtensions(arr);
          }
        }, false, "remove all global extensions and install them");
        this.globalPromise = this.globalExtensions();
        commands_default.register({
          id: "extensions.toggleAutoUpdate",
          execute: async () => {
            let config = workspace_default.getConfiguration("coc.preferences", null);
            let interval2 = config.get("extensionUpdateCheck", "daily");
            let target = 1 /* Global */;
            if (interval2 == "never") {
              await config.update("extensionUpdateCheck", "daily", target);
              void window_default.showInformationMessage("Extension auto update enabled.");
            } else {
              await config.update("extensionUpdateCheck", "never", target);
              void window_default.showInformationMessage("Extension auto update disabled.");
            }
          }
        }, false, "toggle auto update of extensions.");
      }
      async init(runtimepath) {
        if (process.env.COC_NO_PLUGINS == "1")
          return;
        let stats = await this.globalPromise;
        this.manager.registerExtensions(stats);
        let localStats = this.runtimeExtensionStats(runtimepath);
        this.manager.registerExtensions(localStats);
        void this.manager.loadFileExtensions();
      }
      async activateExtensions() {
        await this.manager.activateExtensions();
        if (process.env.COC_NO_PLUGINS == "1")
          return;
        let names = this.states.filterGlobalExtensions(workspace_default.env.globalExtensions);
        void this.installExtensions(names);
        let config = workspace_default.initialConfiguration.get("coc.preferences");
        let interval2 = config.extensionUpdateCheck;
        let silent = config.silentAutoupdate;
        if (this.states.shouldUpdate(interval2)) {
          this.outputChannel.appendLine("Start auto update...");
          this.updateExtensions(silent).catch((e) => {
            this.outputChannel.appendLine(`Error on updateExtensions ${e}`);
          });
        }
      }
      get onDidLoadExtension() {
        return this.manager.onDidLoadExtension;
      }
      get onDidActiveExtension() {
        return this.manager.onDidActiveExtension;
      }
      get onDidUnloadExtension() {
        return this.manager.onDidUnloadExtension;
      }
      get outputChannel() {
        return window_default.createOutputChannel("extensions");
      }
      get all() {
        return this.manager.all;
      }
      has(id) {
        return this.manager.has(id);
      }
      getExtension(id) {
        return this.manager.getExtension(id);
      }
      getExtensionById(extensionId) {
        let item = this.manager.getExtension(extensionId);
        return item ? item.extension : void 0;
      }
      get schemes() {
        return {};
      }
      addSchemeProperty(key, def) {
      }
      getExtensionState(id) {
        return this.manager.getExtensionState(id);
      }
      isActivated(id) {
        let item = this.manager.getExtension(id);
        return item != null && item.extension.isActive;
      }
      async call(id, method, args) {
        return await this.manager.call(id, method, args);
      }
      get npm() {
        let npm = workspace_default.initialConfiguration.get("npm.binPath");
        npm = workspace_default.expand(npm);
        for (let exe of [npm, "yarnpkg", "yarn", "npm"]) {
          if (executable(exe))
            return which.sync(exe);
        }
        void window_default.showErrorMessage(`Can't find npm or yarn in your $PATH`);
        return null;
      }
      createInstallerUI(isUpdate, silent) {
        return silent ? new InstallChannel(isUpdate, this.outputChannel) : new InstallBuffer(isUpdate);
      }
      creteInstaller(npm, def) {
        return new Installer(this.modulesFolder, npm, def);
      }
      async installExtensions(list2) {
        if (isFalsyOrEmpty(list2) || !this.npm)
          return;
        let { npm } = this;
        list2 = distinct(list2);
        let installBuffer = this.createInstallerUI(false, false);
        await Promise.resolve(installBuffer.start(list2));
        let fn = async (key) => {
          try {
            installBuffer.startProgress(key);
            let installer = this.creteInstaller(npm, key);
            installer.on("message", (msg, isProgress) => {
              installBuffer.addMessage(key, msg, isProgress);
            });
            let result = await installer.install();
            installBuffer.finishProgress(key, true);
            this.states.addExtension(result.name, result.url ? result.url : `>=${result.version}`);
            let ms = key.match(/@[\d.]+$/);
            if (ms != null)
              this.states.setLocked(result.name, true);
            await this.manager.loadExtension(result.folder);
          } catch (err) {
            installBuffer.addMessage(key, err.message);
            installBuffer.finishProgress(key, false);
            void window_default.showErrorMessage(`Error on install ${key}: ${err}`);
            logger40.error(`Error on install ${key}`, err);
          }
        };
        await concurrent(list2, fn);
      }
      async updateExtensions(silent = false) {
        let { npm } = this;
        if (!npm)
          return;
        let stats = this.globalExtensionStats();
        stats = stats.filter((s) => {
          if (s.isLocked || s.state === "disabled") {
            this.outputChannel.appendLine(`Skipped update for ${s.isLocked ? "locked" : "disabled"} extension "${s.id}"`);
            return false;
          }
          return true;
        });
        this.states.setLastUpdate();
        this.cleanModulesFolder();
        let installBuffer = this.createInstallerUI(true, silent);
        await Promise.resolve(installBuffer.start(stats.map((o) => o.id)));
        let fn = async (stat) => {
          let { id } = stat;
          try {
            installBuffer.startProgress(id);
            let url = stat.exotic ? stat.uri : null;
            let installer = this.creteInstaller(npm, id);
            installer.on("message", (msg, isProgress) => {
              installBuffer.addMessage(id, msg, isProgress);
            });
            let directory = await installer.update(url);
            installBuffer.finishProgress(id, true);
            if (directory)
              await this.manager.loadExtension(directory);
          } catch (err) {
            installBuffer.addMessage(id, err.message);
            installBuffer.finishProgress(id, false);
            void window_default.showErrorMessage(`Error on update ${id}: ${err}`);
            logger40.error(`Error on update ${id}`, err);
          }
        };
        await concurrent(stats, fn, silent ? 1 : 3);
      }
      async getExtensionStates() {
        let runtimepath = await workspace_default.nvim.eval('join(globpath(&runtimepath, "", 0, 1), ",")');
        let localStats = this.runtimeExtensionStats(runtimepath);
        let globalStats = this.globalExtensionStats();
        return localStats.concat(globalStats);
      }
      async globalExtensions() {
        if (process.env.COC_NO_PLUGINS == "1")
          return [];
        let res = [];
        for (let key of this.states.activated()) {
          let root = path.join(this.modulesFolder, key);
          try {
            let json = await loadGlobalJsonAsync(root, VERSION);
            res.push({ root, isLocal: false, packageJSON: json });
          } catch (err) {
            logger40.error(`Error on load package.json of ${key}`, err);
          }
        }
        return res;
      }
      globalExtensionStats() {
        let dependencies = this.states.dependencies;
        let lockedExtensions = this.states.lockedExtensions;
        let infos = [];
        Object.entries(dependencies).map(([key, val]) => {
          let root = path.join(this.modulesFolder, key);
          let errors = [];
          let obj = loadExtensionJson(root, VERSION, errors);
          if (errors.length > 0) {
            this.outputChannel.appendLine(`Error on load ${key} at ${root}: ${errors.join("\n")}`);
            return;
          }
          obj.name = key;
          infos.push({
            id: key,
            root,
            isLocal: false,
            version: obj.version,
            description: obj.description ?? "",
            isLocked: lockedExtensions.includes(key),
            exotic: /^https?:/.test(val),
            uri: toUrl(val),
            state: this.getExtensionState(key),
            packageJSON: obj
          });
        });
        logger40.debug("globalExtensionStats:", infos.length);
        return infos;
      }
      runtimeExtensionStats(runtimepath) {
        let lockedExtensions = this.states.lockedExtensions;
        let paths = runtimepath.split(",");
        let infos = [];
        let localIds = /* @__PURE__ */ new Set();
        paths.map((root) => {
          let errors = [];
          let obj = loadExtensionJson(root, workspace_default.version, errors);
          if (errors.length > 0)
            return;
          let { name: name2 } = obj;
          if (!name2 || this.states.hasExtension(name2) || localIds.has(name2))
            return;
          this.states.addLocalExtension(name2, root);
          localIds.add(name2);
          infos.push({
            id: obj.name,
            isLocal: true,
            isLocked: lockedExtensions.includes(name2),
            version: obj.version,
            description: obj.description ?? "",
            exotic: false,
            root,
            state: this.getExtensionState(obj.name),
            packageJSON: Object.freeze(obj)
          });
        });
        return infos;
      }
      cleanModulesFolder() {
        let globalIds = this.states.globalIds;
        let folders = globalIds.map((s) => s.replace(/\/.*$/, ""));
        if (!fs.existsSync(this.modulesFolder))
          return;
        let files = fs.readdirSync(this.modulesFolder);
        for (let file of files) {
          if (folders.includes(file))
            continue;
          let p = path.join(this.modulesFolder, file);
          let stat = fs.lstatSync(p);
          if (stat.isSymbolicLink()) {
            fs.unlinkSync(p);
          } else if (stat.isDirectory()) {
            fs.rmSync(p, { recursive: true, force: true });
          }
        }
      }
      dispose() {
        this.manager.dispose();
      }
    };
    extension_default = new Extensions4();
  }
});

// src/completion/keywords.ts
var KeywordsBuffer;
var init_keywords = __esm({
  "src/completion/keywords.ts"() {
    "use strict";
    init_esm();
    init_fs();
    KeywordsBuffer = class {
      constructor(doc) {
        this.doc = doc;
        this.lineWords = [];
        this._gitIgnored = false;
        this.parseWords();
        let uri = URI.parse(doc.uri);
        if (uri.scheme === "file") {
          void isGitIgnored(uri.fsPath).then((ignored) => {
            this._gitIgnored = ignored;
          });
        }
      }
      getWords() {
        let res = [];
        for (let words of this.lineWords) {
          words.forEach((word) => {
            if (!res.includes(word)) {
              res.push(word);
            }
          });
        }
        return res;
      }
      parseWords() {
        let { lineWords, doc } = this;
        let { chars } = doc;
        for (let line of this.doc.textDocument.lines) {
          let words = chars.matchLine(line, 2);
          lineWords.push(words);
        }
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      get gitIgnored() {
        return this._gitIgnored;
      }
      onChange(e) {
        if (e.contentChanges.length == 0)
          return;
        let { lineWords, doc } = this;
        let { range, text } = e.contentChanges[0];
        let { start, end } = range;
        let sl = start.line;
        let el = end.line;
        let del = el - sl;
        let newLines = doc.textDocument.lines.slice(sl, sl + text.split(/\n/).length);
        let arr = newLines.map((line) => doc.chars.matchLine(line, 2));
        lineWords.splice(sl, del + 1, ...arr);
      }
      *matchWords(line) {
        let { lineWords } = this;
        if (line >= lineWords.length)
          line = lineWords.length - 1;
        for (let i = 0; i < lineWords.length; i++) {
          let idx = i < line ? line - i - 1 : i;
          let words = lineWords[idx];
          for (let word of words) {
            yield word;
          }
        }
      }
      dispose() {
        this.lineWords = [];
      }
    };
  }
});

// src/completion/source.ts
function firstMatchFuzzy(firstCode, ascii, word) {
  let ch = word[0];
  if (ascii && !WORD_PREFIXES_CODE.includes(firstCode) && WORD_PREFIXES.includes(ch))
    ch = word[1];
  if (ascii && ch.charCodeAt(0) > ASCII_END)
    ch = unidecode(ch);
  return caseMatch(firstCode, ch.charCodeAt(0));
}
var WORD_PREFIXES, WORD_PREFIXES_CODE, MAX_DURATION, MAX_COUNT, Source;
var init_source = __esm({
  "src/completion/source.ts"() {
    "use strict";
    init_events();
    init_util();
    init_array();
    init_constants();
    init_fuzzy();
    init_node();
    init_is();
    init_string();
    init_workspace();
    init_types2();
    WORD_PREFIXES = ["_", "$", "-"];
    WORD_PREFIXES_CODE = [95, 36, 45];
    MAX_DURATION = getConditionValue(80, 20);
    MAX_COUNT = 50;
    Source = class {
      constructor(option) {
        this.noMatchWords = /* @__PURE__ */ new Set();
        this.disposables = [];
        this._disabled = false;
        this.name = option.name;
        this.filepath = option.filepath || "";
        this.sourceType = option.sourceType || 0 /* Native */;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
        this.documentSelector = option.documentSelector;
        const key = `coc.source.${option.name}`;
        this.config = defaultValue(workspace_default.initialConfiguration.get(key), {});
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(key)) {
            this.config = defaultValue(workspace_default.initialConfiguration.get(key), {});
          }
        }, null, this.disposables);
        events_default.on("CompleteDone", () => {
          this.noMatchWords.clear();
        }, null, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get priority() {
        return this.getConfig("priority", 1);
      }
      get triggerPatterns() {
        let patterns = this.getConfig("triggerPatterns", null);
        if (isFalsyOrEmpty(patterns))
          return null;
        return patterns.map((s) => string(s) ? new RegExp(s + "$") : s);
      }
      get triggerOnly() {
        let triggerOnly = this.defaults["triggerOnly"];
        if (boolean(triggerOnly))
          return triggerOnly;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length > 0;
      }
      get triggerCharacters() {
        return toArray(this.getConfig("triggerCharacters", []));
      }
      get firstMatch() {
        return this.getConfig("firstMatch", true);
      }
      get optionalFns() {
        return this.defaults["optionalFns"] || [];
      }
      get shortcut() {
        let shortcut = this.getConfig("shortcut", "");
        return shortcut ? shortcut : this.name.slice(0, 3);
      }
      get enable() {
        if (this._disabled)
          return false;
        return this.getConfig("enable", true);
      }
      get filetypes() {
        return this.getConfig("filetypes", null);
      }
      get disableSyntaxes() {
        return this.getConfig("disableSyntaxes", []);
      }
      getConfig(key, defaultValue2) {
        let val = this.config[key];
        if (func(val) || val == null)
          return defaultValue2 ?? null;
        return val;
      }
      toggle() {
        this._disabled = !this._disabled;
      }
      get menu() {
        return "";
      }
      async checkComplete(opt) {
        let { disableSyntaxes } = this;
        if (!isFalsyOrEmpty(disableSyntaxes) && opt.synname) {
          let synname = opt.synname.toLowerCase();
          if (disableSyntaxes.findIndex((s) => synname.includes(s.toLowerCase())) !== -1) {
            return false;
          }
        }
        let fn = this.defaults["shouldComplete"];
        if (func(fn))
          return !!await Promise.resolve(fn.call(this, opt));
        return true;
      }
      async refresh() {
        let fn = this.defaults["refresh"];
        if (func(fn))
          await Promise.resolve(fn.call(this));
      }
      async onCompleteDone(item, opt) {
        let fn = this.defaults["onCompleteDone"];
        if (func(fn))
          await Promise.resolve(fn.call(this, item, opt));
      }
      async doComplete(opt, token) {
        let shouldRun = await this.checkComplete(opt);
        if (!shouldRun || token.isCancellationRequested)
          return null;
        let fn = this.defaults["doComplete"];
        return await Promise.resolve(fn.call(this, opt, token));
      }
      async onCompleteResolve(item, opt, token) {
        let fn = this.defaults["onCompleteResolve"];
        if (func(fn))
          await Promise.resolve(fn.call(this, item, opt, token));
      }
      async getResults(iterables, input, exclude, items, token) {
        let { firstMatch, noMatchWords } = this;
        let start = Date.now();
        let prev = start;
        let len = input.length;
        let firstCode = input.charCodeAt(0);
        let codes = getCharCodes(input);
        let ascii = isAlphabet(firstCode);
        let i = 0;
        for (let iterable of iterables) {
          for (let w of iterable) {
            i++;
            if (i % 100 === 0) {
              let curr = Date.now();
              if (curr - prev > 15) {
                await waitImmediate();
                prev = curr;
              }
              if (token.isCancellationRequested || curr - start > MAX_DURATION)
                return true;
            }
            if (w.length <= 1 && w.charCodeAt(0) < 255 || w === exclude || items.has(w) || noMatchWords.has(w))
              continue;
            if (firstMatch && !firstMatchFuzzy(firstCode, ascii, w)) {
              noMatchWords.add(w);
              continue;
            }
            if (len > 1) {
              let matched = fuzzyMatch(codes, ascii && w[0].charCodeAt(0) > ASCII_END ? unidecode(w) : w);
              if (!matched) {
                noMatchWords.add(w);
                continue;
              }
            }
            items.add(w);
            if (items.size == MAX_COUNT)
              return true;
          }
        }
        return false;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/completion/source-language.ts
function getUltisnipOption(item) {
  var _a2, _b;
  let opts = ((_a2 = item.data) == null ? void 0 : _a2.ultisnip) === true ? {} : (_b = item.data) == null ? void 0 : _b.ultisnip;
  return opts ? opts : void 0;
}
function fixIndent(line, currline, range) {
  let oldIndent = line.match(/^\s*/)[0];
  let newIndent = currline.match(/^\s*/)[0];
  if (oldIndent === newIndent)
    return 0;
  let d = newIndent.length - oldIndent.length;
  range.start.character += d;
  range.end.character += d;
  return d;
}
var logger41, LanguageSource;
var init_source_language = __esm({
  "src/completion/source-language.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_ui();
    init_logger();
    init_manager4();
    init_util();
    init_array();
    init_errors();
    init_is();
    init_object();
    init_protocol();
    init_string();
    init_workspace();
    init_types2();
    init_util3();
    logger41 = createLogger("source-language");
    LanguageSource = class {
      constructor(name2, shortcut, provider, documentSelector, triggerCharacters, allCommitCharacters, priority) {
        this.name = name2;
        this.shortcut = shortcut;
        this.provider = provider;
        this.documentSelector = documentSelector;
        this.triggerCharacters = triggerCharacters;
        this.allCommitCharacters = allCommitCharacters;
        this.priority = priority;
        this.sourceType = 2 /* Service */;
        this._enabled = true;
        this.itemDefaults = {};
        this.resolving = /* @__PURE__ */ new WeakMap();
      }
      get enable() {
        return this._enabled;
      }
      toggle() {
        this._enabled = !this._enabled;
      }
      shouldCommit(item, character) {
        if (this.allCommitCharacters.includes(character))
          return true;
        let commitCharacters = toArray(item.commitCharacters ?? this.itemDefaults.commitCharacters);
        return commitCharacters.includes(character);
      }
      async doComplete(option, token) {
        let { triggerCharacter, bufnr, position } = option;
        let triggerKind = this.getTriggerKind(option);
        this.triggerContext = { lnum: position.line, character: position.character, line: option.line };
        let context = { triggerKind, option };
        if (triggerKind == import_node3.CompletionTriggerKind.TriggerCharacter)
          context.triggerCharacter = triggerCharacter;
        let textDocument = workspace_default.getDocument(bufnr).textDocument;
        await waitImmediate();
        let result = await Promise.resolve(this.provider.provideCompletionItems(textDocument, position, token, context));
        if (!result || token.isCancellationRequested)
          return null;
        let completeItems = Array.isArray(result) ? result : result.items;
        if (!completeItems || completeItems.length == 0)
          return null;
        let itemDefaults = this.itemDefaults = toObject(result["itemDefaults"]);
        let isIncomplete = isCompletionList(result) ? result.isIncomplete === true : false;
        return { isIncomplete, items: completeItems, itemDefaults };
      }
      onCompleteResolve(item, _opt, token) {
        let hasResolve = func(this.provider.resolveCompletionItem);
        if (!hasResolve)
          return;
        let promise = this.resolving.get(item);
        if (promise)
          return promise;
        let invalid = false;
        promise = new Promise(async (resolve, reject) => {
          let disposable = token.onCancellationRequested(() => {
            this.resolving.delete(item);
            reject(new CancellationError());
          });
          try {
            let resolved = await Promise.resolve(this.provider.resolveCompletionItem(item, token));
            disposable.dispose();
            if (!token.isCancellationRequested) {
              if (!resolved) {
                invalid = true;
                this.resolving.delete(item);
              } else {
                Object.assign(item, resolved);
              }
            }
            resolve();
          } catch (e) {
            invalid = true;
            this.resolving.delete(item);
            reject(e);
          }
        });
        if (!invalid) {
          this.resolving.set(item, promise);
        }
        return promise;
      }
      async onCompleteDone(item, opt) {
        let doc = workspace_default.getDocument(opt.bufnr);
        await doc.patchChange(true);
        let additionalEdits = !isFalsyOrEmpty(item.additionalTextEdits);
        if (additionalEdits) {
          let shouldCancel = await manager_default3.editsInsideSnippet(item.additionalTextEdits);
          if (shouldCancel)
            manager_default3.cancel();
        }
        let version2 = doc.version;
        let isSnippet = await this.applyTextEdit(doc, additionalEdits, item, opt);
        if (additionalEdits) {
          await doc.applyEdits(item.additionalTextEdits, doc.version != version2, !isSnippet);
          if (isSnippet)
            await manager_default3.selectCurrentPlaceholder();
        }
        if (item.command) {
          if (commands_default.has(item.command.command)) {
            await commands_default.execute(item.command);
          } else {
            logger41.warn(`Command "${item.command.command}" not registered to coc.nvim`);
          }
        }
      }
      async applyTextEdit(doc, additionalEdits, item, option) {
        let { linenr, col } = option;
        let { character, line } = this.triggerContext;
        let pos = await getLineAndPosition(workspace_default.nvim);
        if (pos.line != linenr - 1)
          return;
        let { textEdit, insertText, label } = item;
        let range = getReplaceRange(item, this.itemDefaults, void 0, option.insertMode);
        if (!range) {
          let end = character + (option.insertMode == "insert" /* Insert */ ? 0 : option.followWord.length);
          range = Range.create(pos.line, characterIndex(line, col), pos.line, end);
        }
        if (range.end.character < character)
          range.end.character = character;
        let newText = textEdit ? textEdit.newText : insertText ?? label;
        let indentCount = fixIndent(line, pos.text, range);
        let delta = pos.character - character - indentCount;
        if (delta !== 0)
          range.end.character += delta;
        let next = pos.text[range.end.character];
        if (next && newText.endsWith(next) && pariedCharacters.get(newText[0]) === next) {
          range.end.character += 1;
        }
        if (option.snippetsSupport !== false && isSnippetItem(item, this.itemDefaults)) {
          let opts = getUltisnipOption(item);
          let insertTextMode = item.insertTextMode ?? this.itemDefaults.insertTextMode;
          return await manager_default3.insertSnippet(newText, !additionalEdits, range, insertTextMode, opts);
        }
        await doc.applyEdits([TextEdit.replace(range, newText)], false, pos);
        return false;
      }
      getTriggerKind(opt) {
        let { triggerCharacters } = this;
        let isTrigger = triggerCharacters.includes(opt.triggerCharacter);
        let triggerKind = import_node3.CompletionTriggerKind.Invoked;
        if (opt.triggerForInComplete) {
          triggerKind = import_node3.CompletionTriggerKind.TriggerForIncompleteCompletions;
        } else if (isTrigger) {
          triggerKind = import_node3.CompletionTriggerKind.TriggerCharacter;
        }
        return triggerKind;
      }
    };
  }
});

// src/completion/source-vim.ts
var VimSource;
var init_source_vim = __esm({
  "src/completion/source-vim.ts"() {
    "use strict";
    init_main();
    init_ui();
    init_manager4();
    init_string();
    init_workspace();
    init_source();
    init_is();
    VimSource = class extends Source {
      async callOptionalFunc(fname, args) {
        let exists = this.optionalFns.includes(fname);
        if (!exists)
          return null;
        let name2 = `coc#source#${this.name}#${fname}`;
        return await this.nvim.call(name2, args);
      }
      async checkComplete(opt) {
        let shouldRun = await super.checkComplete(opt);
        if (!shouldRun)
          return false;
        if (!this.optionalFns.includes("should_complete"))
          return true;
        let res = await this.callOptionalFunc("should_complete", [opt]);
        return !!res;
      }
      async refresh() {
        await this.callOptionalFunc("refresh", []);
      }
      async insertSnippet(insertText, opt) {
        let pos = await getLineAndPosition(this.nvim);
        let { line, col } = opt;
        let oldIndent = line.match(/^\s*/)[0];
        let newIndent = pos.text.match(/^\s*/)[0];
        let range = Range.create(pos.line, characterIndex(line, col) + newIndent.length - oldIndent.length, pos.line, pos.character);
        await manager_default3.insertSnippet(insertText, true, range);
      }
      async onCompleteDone(item, opt) {
        if (this.optionalFns.includes("on_complete")) {
          await this.callOptionalFunc("on_complete", [item]);
        } else if (item.isSnippet && item.insertText) {
          await this.insertSnippet(item.insertText, opt);
        }
      }
      onEnter(bufnr) {
        if (!this.optionalFns.includes("on_enter"))
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype))
          return;
        void this.callOptionalFunc("on_enter", [{
          bufnr,
          uri: doc.uri,
          languageId: doc.filetype
        }]);
      }
      async doComplete(opt, token) {
        let shouldRun = await this.checkComplete(opt);
        if (!shouldRun)
          return null;
        let startcol = await this.callOptionalFunc("get_startcol", [opt]);
        if (token.isCancellationRequested)
          return null;
        let { col, input, line, colnr } = opt;
        if (number(startcol) && startcol >= 0 && startcol !== col) {
          input = byteSlice(line, startcol, colnr - 1);
          opt = Object.assign({}, opt, {
            col: startcol,
            changed: col - startcol,
            input
          });
        }
        let vimItems = await this.nvim.callAsync("coc#util#do_complete", [this.name, opt]);
        if (!vimItems || vimItems.length == 0 || token.isCancellationRequested)
          return null;
        let checkFirst = this.firstMatch && input.length > 0;
        let inputFirst = checkFirst ? input[0].toLowerCase() : "";
        let items = [];
        vimItems.forEach((item) => {
          let obj = string(item) ? { word: item } : item;
          if (checkFirst) {
            let ch = (obj.filterText ?? obj.word)[0];
            if (inputFirst && ch.toLowerCase() !== inputFirst)
              return;
          }
          if (this.isSnippet)
            obj.isSnippet = true;
          items.push(obj);
        });
        return { items, startcol: number(startcol) ? startcol : void 0 };
      }
    };
  }
});

// src/completion/native/around.ts
var around_exports = {};
__export(around_exports, {
  Around: () => Around,
  register: () => register
});
function register(sourceMap, keywords) {
  let source = new Around(keywords);
  sourceMap.set("around", source);
}
var Around;
var init_around = __esm({
  "src/completion/native/around.ts"() {
    "use strict";
    init_util();
    init_source();
    Around = class extends Source {
      constructor(keywords) {
        super({ name: "around", filepath: __filename });
        this.keywords = keywords;
      }
      async doComplete(opt, token) {
        let { bufnr, input, word, linenr, triggerForInComplete } = opt;
        let buf = this.keywords.getItem(bufnr);
        await waitImmediate();
        if (!triggerForInComplete)
          this.noMatchWords = /* @__PURE__ */ new Set();
        if (input.length === 0 || !buf || token.isCancellationRequested)
          return null;
        let iterable = buf.matchWords(linenr - 1);
        let items = /* @__PURE__ */ new Set();
        let isIncomplete = await this.getResults([iterable], input, word, items, token);
        return {
          isIncomplete,
          items: Array.from(items).map((s) => {
            return { word: s };
          })
        };
      }
    };
  }
});

// src/completion/native/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer2,
  register: () => register2
});
function register2(sourceMap, keywords) {
  let source = new Buffer2(keywords);
  sourceMap.set("buffer", source);
}
var Buffer2;
var init_buffer2 = __esm({
  "src/completion/native/buffer.ts"() {
    "use strict";
    init_util();
    init_source();
    Buffer2 = class extends Source {
      constructor(keywords) {
        super({ name: "buffer", filepath: __filename });
        this.keywords = keywords;
      }
      get ignoreGitignore() {
        return this.getConfig("ignoreGitignore", true);
      }
      async doComplete(opt, token) {
        let { bufnr, input, word, triggerForInComplete } = opt;
        await waitImmediate();
        if (!triggerForInComplete)
          this.noMatchWords = /* @__PURE__ */ new Set();
        if (input.length === 0 || token.isCancellationRequested)
          return null;
        let iterables = [];
        for (let buf of this.keywords.items) {
          if (buf.bufnr === bufnr || this.ignoreGitignore && buf.gitIgnored)
            continue;
          iterables.push(buf.matchWords(0));
        }
        let items = /* @__PURE__ */ new Set();
        let isIncomplete = await this.getResults(iterables, input, word, items, token);
        return {
          isIncomplete,
          items: Array.from(items).map((s) => {
            return { word: s };
          })
        };
      }
    };
  }
});

// src/completion/native/file.ts
var file_exports = {};
__export(file_exports, {
  File: () => File,
  filterFiles: () => filterFiles,
  getDirectory: () => getDirectory,
  getFileItem: () => getFileItem,
  getItemsFromRoot: () => getItemsFromRoot,
  register: () => register3,
  resolveEnvVariables: () => resolveEnvVariables
});
function resolveEnvVariables(str, env = process.env) {
  let replaced = str;
  replaced = replaced.replace(/%([^%]+)%/g, (m, n) => env[n] ?? m);
  replaced = replaced.replace(
    /\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi,
    (m, a, b) => env[a || b] ?? m
  );
  return replaced;
}
async function getFileItem(root, filename) {
  let f = path.join(root, filename);
  let stat = await statAsync(f);
  if (stat) {
    let dir = stat.isDirectory();
    let abbr = dir ? filename + "/" : filename;
    let word = filename;
    return { word, abbr, kind: dir ? CompletionItemKind.Folder : CompletionItemKind.File };
  }
  return null;
}
function filterFiles(files, ignoreHidden, ignorePatterns = []) {
  return files.filter((f) => {
    if (!f || ignoreHidden && f.startsWith("."))
      return false;
    for (let p of ignorePatterns) {
      if (minimatch(f, p, { dot: true }))
        return false;
    }
    return true;
  });
}
function getDirectory(pathstr, root) {
  let part = /[\\/]$/.test(pathstr) ? pathstr : path.dirname(pathstr);
  return path.isAbsolute(pathstr) ? part : path.join(root, part);
}
async function getItemsFromRoot(pathstr, root, ignoreHidden, ignorePatterns) {
  let res = [];
  let dir = getDirectory(pathstr, root);
  let stat = await statAsync(dir);
  if (stat && stat.isDirectory()) {
    let files = await (0, import_util.promisify)(fs.readdir)(dir);
    files = filterFiles(files, ignoreHidden, ignorePatterns);
    let items = await Promise.all(files.map((filename) => getFileItem(dir, filename)));
    res = res.concat(items);
  }
  res = res.filter((item) => item != null);
  return res;
}
function register3(sourceMap) {
  sourceMap.set("file", new File(isWindows));
}
var pathRe, File;
var init_file = __esm({
  "src/completion/native/file.ts"() {
    "use strict";
    init_main();
    init_fs();
    init_node();
    init_platform();
    init_string();
    init_workspace();
    init_source();
    pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|[a-zA-Z]:|)(\/|\\+)(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-]+(\/|\\+))*(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-])*$/;
    File = class extends Source {
      constructor(isWindows2) {
        super({
          name: "file",
          filepath: __filename
        });
        this.isWindows = isWindows2;
      }
      get triggerCharacters() {
        let characters = this.getConfig("triggerCharacters", []);
        return this.isWindows ? characters : characters.filter((s) => s != "\\");
      }
      getPathOption(opt) {
        let { line, colnr } = opt;
        let part = byteSlice(line, 0, colnr - 1);
        part = resolveEnvVariables(part);
        if (!part || part.endsWith("//"))
          return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
          const pathstr = workspace_default.expand(ms[0]);
          let input = ms[0].match(/[^/\\]*$/)[0];
          return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
      }
      shouldTrim(ext) {
        let trimSameExts = this.getConfig("trimSameExts", []);
        return trimSameExts.includes(ext);
      }
      async getRoot(pathstr, part, filepath, cwd2) {
        let root;
        let dirname = filepath ? path.dirname(filepath) : "";
        if (pathstr.startsWith(".")) {
          root = filepath ? dirname : cwd2;
        } else if (this.isWindows && /^\w+:/.test(pathstr)) {
          root = /[\\/]$/.test(pathstr) ? pathstr : path.win32.dirname(pathstr);
        } else if (!this.isWindows && pathstr.startsWith("/")) {
          root = pathstr.endsWith("/") ? pathstr : path.posix.dirname(pathstr);
        } else if (part) {
          let exists = await (0, import_util.promisify)(fs.exists)(path.join(dirname, part));
          if (exists) {
            root = dirname;
          } else {
            exists = await (0, import_util.promisify)(fs.exists)(path.join(cwd2, part));
            if (exists)
              root = cwd2;
          }
        } else {
          root = cwd2;
        }
        return root;
      }
      async doComplete(opt, token) {
        let { filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option || option.startcol < opt.col)
          return null;
        let { pathstr, part, startcol } = option;
        let startPart = opt.col == startcol ? "" : byteSlice(opt.line, opt.col, startcol);
        let ext = path.extname(path.basename(filepath));
        let cwd2 = await this.nvim.call("getcwd", []);
        let root = await this.getRoot(pathstr, part, filepath, cwd2);
        if (!root || token.isCancellationRequested)
          return null;
        let items = await getItemsFromRoot(pathstr, root, this.getConfig("ignoreHidden", true), this.getConfig("ignorePatterns", []));
        let trimExt = this.shouldTrim(ext);
        return {
          items: items.map((item) => {
            let ex = path.extname(item.word);
            item.word = trimExt && ex === ext ? item.word.replace(ext, "") : item.word;
            return {
              word: `${startPart}${item.word}`,
              abbr: `${startPart}${item.abbr}`,
              menu: this.menu
            };
          })
        };
      }
    };
  }
});

// src/completion/sources.ts
var sources_exports = {};
__export(sources_exports, {
  Sources: () => Sources,
  default: () => sources_default,
  getSourceType: () => getSourceType,
  logError: () => logError
});
function logError(err) {
  logger42.error("Error on source create", err);
}
function getSourceType(sourceType) {
  if (sourceType === 0 /* Native */)
    return "native";
  if (sourceType === 1 /* Remote */)
    return "remote";
  return "service";
}
var logger42, WordsSource, Sources, sources_default;
var init_sources2 = __esm({
  "src/completion/sources.ts"() {
    "use strict";
    init_events();
    init_extension();
    init_logger();
    init_util();
    init_array();
    init_fs();
    init_is();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_keywords();
    init_source();
    init_source_language();
    init_source_vim();
    init_types2();
    init_util3();
    logger42 = createLogger("sources");
    WordsSource = class {
      constructor() {
        this.name = "$words";
        this.shortcut = "";
        this.triggerOnly = true;
        this.words = [];
      }
      doComplete(opt) {
        return {
          items: this.words.map((s) => {
            return { word: s, filterText: opt.input };
          })
        };
      }
    };
    Sources = class {
      constructor() {
        this.sourceMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
        this.wordsSource = new WordsSource();
      }
      init() {
        this.keywords = workspace_default.registerBufferSync((doc) => {
          return new KeywordsBuffer(doc);
        });
        this.createNativeSources();
        this.createRemoteSources();
        events_default.on("BufEnter", this.onDocumentEnter, this, this.disposables);
        workspace_default.onDidRuntimePathChange((newPaths) => {
          for (let p of newPaths) {
            this.createVimSources(p).catch(logError);
          }
        }, null, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      getKeywordsBuffer(bufnr) {
        return this.keywords.getItem(bufnr);
      }
      setWords(words) {
        this.wordsSource.words = words;
      }
      createNativeSources() {
        this.sourceMap.set(this.wordsSource.name, this.wordsSource);
        void Promise.all([
          Promise.resolve().then(() => (init_around(), around_exports)).then((module2) => {
            module2.register(this.sourceMap, this.keywords);
          }),
          Promise.resolve().then(() => (init_buffer2(), buffer_exports)).then((module2) => {
            module2.register(this.sourceMap, this.keywords);
          }),
          Promise.resolve().then(() => (init_file(), file_exports)).then((module2) => {
            module2.register(this.sourceMap);
          })
        ]);
      }
      createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters) {
        let source = new LanguageSource(
          name2,
          shortcut,
          provider,
          selector,
          toArray(triggerCharacters),
          toArray(allCommitCharacters),
          priority
        );
        logger42.trace("created service source", name2);
        this.sourceMap.set(name2, source);
        return {
          dispose: () => {
            this.sourceMap.delete(name2);
          }
        };
      }
      async createVimSourceExtension(filepath) {
        let { nvim } = this;
        try {
          let name2 = path.basename(filepath, ".vim");
          await nvim.command(`source ${filepath}`);
          let fns = await nvim.call("coc#util#remote_fns", name2);
          for (let fn of ["init", "complete"]) {
            if (!fns.includes(fn)) {
              throw new Error(`function "coc#source#${name2}#${fn}" not found`);
            }
          }
          let props = await nvim.call(`coc#source#${name2}#init`, []);
          let packageJSON = {
            name: `coc-vim-source-${name2}`,
            engines: {
              coc: ">= 0.0.1"
            },
            activationEvents: props.filetypes ? props.filetypes.map((f) => `onLanguage:${f}`) : ["*"],
            contributes: {
              configuration: {
                properties: {
                  [`coc.source.${name2}.enable`]: {
                    type: "boolean",
                    default: true
                  },
                  [`coc.source.${name2}.firstMatch`]: {
                    type: "boolean",
                    default: !!props.firstMatch
                  },
                  [`coc.source.${name2}.triggerCharacters`]: {
                    type: "number",
                    default: props.triggerCharacters ?? []
                  },
                  [`coc.source.${name2}.priority`]: {
                    type: "number",
                    default: props.priority ?? 9
                  },
                  [`coc.source.${name2}.shortcut`]: {
                    type: "string",
                    default: props.shortcut ?? name2.slice(0, 3).toUpperCase(),
                    description: "Shortcut text shown in complete menu."
                  },
                  [`coc.source.${name2}.disableSyntaxes`]: {
                    type: "array",
                    default: [],
                    items: {
                      type: "string"
                    }
                  },
                  [`coc.source.${name2}.filetypes`]: {
                    type: "array",
                    default: props.filetypes || null,
                    description: "Enabled filetypes.",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          };
          let isActive = false;
          let extension = {
            id: packageJSON.name,
            packageJSON,
            exports: void 0,
            extensionPath: filepath,
            activate: () => {
              isActive = true;
              let source = new VimSource({
                name: name2,
                filepath,
                isSnippet: props.isSnippet,
                sourceType: 1 /* Remote */,
                triggerOnly: !!props.triggerOnly,
                optionalFns: fns.filter((n) => !["init", "complete"].includes(n))
              });
              this.addSource(source);
              return Promise.resolve();
            }
          };
          Object.defineProperty(extension, "isActive", {
            get: () => isActive
          });
          await extension_default.manager.registerInternalExtension(extension, () => {
            isActive = false;
            this.removeSource(name2);
          });
        } catch (e) {
          void window_default.showErrorMessage(`Error on create vim source from ${filepath}: ${e}`);
        }
      }
      createRemoteSources() {
        let paths = workspace_default.env.runtimepath.split(",");
        for (let path2 of paths) {
          this.createVimSources(path2).catch(logError);
        }
      }
      async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath) || !pluginPath)
          return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = path.join(pluginPath, "autoload/coc/source");
        let stat = await statAsync(folder);
        if (stat && stat.isDirectory()) {
          let arr = await (0, import_util.promisify)(fs.readdir)(folder);
          let files = arr.filter((s) => s.endsWith(".vim")).map((s) => path.join(folder, s));
          await Promise.allSettled(files.map((p) => this.createVimSourceExtension(p)));
        }
      }
      get names() {
        return Array.from(this.sourceMap.keys());
      }
      get sources() {
        return Array.from(this.sourceMap.values());
      }
      has(name2) {
        return this.names.findIndex((o) => o == name2) != -1;
      }
      getSource(name2) {
        return this.sourceMap.get(name2) ?? null;
      }
      shouldCommit(source, item, commitCharacter) {
        if (!item || source == null)
          return false;
        if (func(source.shouldCommit)) {
          return source.shouldCommit(item, commitCharacter);
        }
        return false;
      }
      getSources(opt) {
        let { source } = opt;
        if (source)
          return toArray(this.getSource(source));
        let uri = workspace_default.getUri(opt.bufnr);
        return this.getNormalSources(opt.filetype, uri);
      }
      getNormalSources(filetype, uri) {
        let languageIds = filetype.split(".");
        let res = this.sources.filter((source) => {
          let { filetypes, triggerOnly, documentSelector, enable } = source;
          if (!enable || triggerOnly || filetypes && !intersect(filetypes, languageIds))
            return false;
          if (documentSelector && languageIds.every((filetype2) => workspace_default.match(documentSelector, { uri, languageId: filetype2 }) == 0))
            return false;
          return true;
        });
        return res;
      }
      checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if (!isFalsyOrEmpty(triggerCharacters) && triggerCharacters.includes(character)) {
          return true;
        }
        if (!isFalsyOrEmpty(triggerPatterns) && triggerPatterns.findIndex((p) => p.test(pre)) !== -1) {
          return true;
        }
        return false;
      }
      shouldTrigger(pre, filetype, uri) {
        return this.getTriggerSources(pre, filetype, uri).length > 0;
      }
      getTriggerSources(pre, filetype, uri, disabled = []) {
        if (!pre)
          return [];
        let character = pre[pre.length - 1];
        let languageIds = filetype.split(".");
        return this.sources.filter((source) => {
          let { filetypes, enable, documentSelector, name: name2 } = source;
          if (disabled.includes(name2))
            return false;
          if (!enable || filetypes && !intersect(filetypes, languageIds))
            return false;
          if (documentSelector && languageIds.every((languageId) => workspace_default.match(documentSelector, { uri, languageId }) == 0)) {
            return false;
          }
          return this.checkTrigger(source, pre, character);
        });
      }
      addSource(source) {
        let { name: name2 } = source;
        if (this.names.includes(name2)) {
          logger42.warn(`Recreate source ${name2}`);
        }
        this.sourceMap.set(name2, source);
        return import_node3.Disposable.create(() => {
          this.removeSource(source);
        });
      }
      removeSource(source) {
        let name2 = typeof source == "string" ? source : source.name;
        let obj = typeof source === "string" ? this.sourceMap.get(source) : source;
        if (obj && typeof obj.dispose === "function")
          obj.dispose();
        this.sourceMap.delete(name2);
      }
      async refresh(name2) {
        for (let source of this.sources) {
          if (!name2 || source.name == name2) {
            if (typeof source.refresh === "function") {
              await Promise.resolve(source.refresh());
            }
          }
        }
      }
      toggleSource(name2) {
        let source = this.getSource(name2);
        if (source && typeof source.toggle === "function") {
          source.toggle();
        }
      }
      sourceStats() {
        var _a2;
        let stats = [];
        let languageSourcePriority = workspace_default.initialConfiguration.get("suggest.languageSourcePriority");
        for (let item of this.sourceMap.values()) {
          if (item.name === "$words")
            continue;
          stats.push({
            name: item.name,
            priority: getPriority(item, languageSourcePriority),
            triggerCharacters: toArray(item.triggerCharacters),
            shortcut: toText(item.shortcut),
            filetypes: toArray(item.filetypes ?? ((_a2 = item.documentSelector) == null ? void 0 : _a2.map((o) => string(o) ? o : o.language))),
            filepath: toText(item.filepath),
            type: getSourceType(item.sourceType),
            disabled: !item.enable
          });
        }
        return stats;
      }
      onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
          if (s.enable && func(s.onEnter)) {
            s.onEnter(bufnr);
          }
        }
      }
      createSource(config) {
        if (typeof config.name !== "string" || typeof config.doComplete !== "function") {
          logger42.error(`Bad config for createSource:`, config);
          throw new TypeError(`name and doComplete required for createSource`);
        }
        let source = new Source(Object.assign({ sourceType: 2 /* Service */ }, config));
        return this.addSource(source);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    sources_default = new Sources();
  }
});

// src/languages.ts
var eventDebounce, ProviderName, Languages, languages_default;
var init_languages = __esm({
  "src/languages.ts"() {
    "use strict";
    init_main();
    init_manager();
    init_callHierarchyManager();
    init_codeActionManager();
    init_codeLensManager();
    init_declarationManager();
    init_definitionManager();
    init_documentColorManager();
    init_documentHighlightManager();
    init_documentLinkManager();
    init_documentSymbolManager();
    init_foldingRangeManager();
    init_formatManager();
    init_formatRangeManager();
    init_hoverManager();
    init_implementationManager();
    init_inlayHintManager();
    init_inlineValueManager();
    init_linkedEditingRangeManager();
    init_onTypeFormatManager();
    init_referenceManager();
    init_renameManager();
    init_selectionRangeManager();
    init_semanticTokensManager();
    init_semanticTokensRangeManager();
    init_signatureManager();
    init_typeDefinitionManager();
    init_typeHierarchyManager();
    init_workspaceSymbolsManager();
    init_util();
    init_is();
    init_protocol();
    init_string();
    eventDebounce = getConditionValue(500, 10);
    ProviderName = /* @__PURE__ */ ((ProviderName3) => {
      ProviderName3["FormatOnType"] = "formatOnType";
      ProviderName3["Rename"] = "rename";
      ProviderName3["OnTypeEdit"] = "onTypeEdit";
      ProviderName3["DocumentLink"] = "documentLink";
      ProviderName3["DocumentColor"] = "documentColor";
      ProviderName3["FoldingRange"] = "foldingRange";
      ProviderName3["Format"] = "format";
      ProviderName3["CodeAction"] = "codeAction";
      ProviderName3["FormatRange"] = "formatRange";
      ProviderName3["Hover"] = "hover";
      ProviderName3["Signature"] = "signature";
      ProviderName3["WorkspaceSymbols"] = "workspaceSymbols";
      ProviderName3["DocumentSymbol"] = "documentSymbol";
      ProviderName3["DocumentHighlight"] = "documentHighlight";
      ProviderName3["Definition"] = "definition";
      ProviderName3["Declaration"] = "declaration";
      ProviderName3["TypeDefinition"] = "typeDefinition";
      ProviderName3["Reference"] = "reference";
      ProviderName3["Implementation"] = "implementation";
      ProviderName3["CodeLens"] = "codeLens";
      ProviderName3["SelectionRange"] = "selectionRange";
      ProviderName3["CallHierarchy"] = "callHierarchy";
      ProviderName3["SemanticTokens"] = "semanticTokens";
      ProviderName3["SemanticTokensRange"] = "semanticTokensRange";
      ProviderName3["LinkedEditing"] = "linkedEditing";
      ProviderName3["InlayHint"] = "inlayHint";
      ProviderName3["InlineValue"] = "inlineValue";
      ProviderName3["TypeHierarchy"] = "typeHierarchy";
      return ProviderName3;
    })(ProviderName || {});
    Languages = class {
      constructor() {
        this._onDidSemanticTokensRefresh = new import_node3.Emitter();
        this._onDidInlayHintRefresh = new import_node3.Emitter();
        this._onDidCodeLensRefresh = new import_node3.Emitter();
        this._onDidColorsRefresh = new import_node3.Emitter();
        this._onDidLinksRefresh = new import_node3.Emitter();
        this.onDidSemanticTokensRefresh = this._onDidSemanticTokensRefresh.event;
        this.onDidInlayHintRefresh = this._onDidInlayHintRefresh.event;
        this.onDidCodeLensRefresh = this._onDidCodeLensRefresh.event;
        this.onDidColorsRefresh = this._onDidColorsRefresh.event;
        this.onDidLinksRefresh = this._onDidLinksRefresh.event;
        this.onTypeFormatManager = new OnTypeFormatManager();
        this.documentLinkManager = new DocumentLinkManager();
        this.documentColorManager = new DocumentColorManager();
        this.foldingRangeManager = new FoldingRangeManager();
        this.renameManager = new RenameManager();
        this.formatManager = new FormatManager();
        this.codeActionManager = new CodeActionManager();
        this.workspaceSymbolsManager = new WorkspaceSymbolManager();
        this.formatRangeManager = new FormatRangeManager();
        this.hoverManager = new HoverManager();
        this.signatureManager = new SignatureManager();
        this.documentSymbolManager = new DocumentSymbolManager();
        this.documentHighlightManager = new DocumentHighlightManager();
        this.definitionManager = new DefinitionManager();
        this.declarationManager = new DeclarationManager();
        this.typeDefinitionManager = new TypeDefinitionManager();
        this.typeHierarchyManager = new TypeHierarchyManager();
        this.referenceManager = new ReferenceManager();
        this.implementationManager = new ImplementationManager();
        this.codeLensManager = new CodeLensManager();
        this.selectionRangeManager = new SelectionRangeManager();
        this.callHierarchyManager = new CallHierarchyManager();
        this.semanticTokensManager = new SemanticTokensManager();
        this.semanticTokensRangeManager = new SemanticTokensRangeManager();
        this.linkedEditingManager = new LinkedEditingRangeManager();
        this.inlayHintManager = new InlayHintManger();
        this.inlineValueManager = new InlineValueManager();
        this.registerReferenceProvider = this.registerReferencesProvider;
      }
      hasFormatProvider(doc) {
        if (this.formatManager.hasProvider(doc)) {
          return true;
        }
        if (this.formatRangeManager.hasProvider(doc)) {
          return true;
        }
        return false;
      }
      registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
      }
      registerCompletionItemProvider(name2, shortcut, selector, provider, triggerCharacters = [], priority, allCommitCharacters) {
        selector = string(selector) ? [{ language: selector }] : selector;
        let sources = (init_sources2(), __toCommonJS(sources_exports)).default;
        sources.removeSource(name2);
        return sources.createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters);
      }
      registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
      }
      registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
      }
      registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
      }
      registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
      }
      registerDocumentSymbolProvider(selector, provider, metadata) {
        if (metadata)
          provider.meta = metadata;
        return this.documentSymbolManager.register(selector, provider);
      }
      registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
      }
      registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
      }
      registerDocumentLinkProvider(selector, provider) {
        this._onDidLinksRefresh.fire(selector);
        let disposable = this.documentLinkManager.register(selector, provider);
        return import_node3.Disposable.create(() => {
          disposable.dispose();
          this._onDidLinksRefresh.fire(selector);
        });
      }
      registerDocumentColorProvider(selector, provider) {
        this._onDidColorsRefresh.fire(selector);
        let disposable = this.documentColorManager.register(selector, provider);
        return import_node3.Disposable.create(() => {
          disposable.dispose();
          this._onDidColorsRefresh.fire(selector);
        });
      }
      registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
      }
      registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
      }
      registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
      }
      registerTypeHierarchyProvider(selector, provider) {
        return this.typeHierarchyManager.register(selector, provider);
      }
      registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
      }
      registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
      }
      registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
      }
      registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && func(arguments[1].provideWorkspaceSymbols)) {
          provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
      }
      registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
      }
      registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
      }
      registerCallHierarchyProvider(selector, provider) {
        return this.callHierarchyManager.register(selector, provider);
      }
      registerCodeLensProvider(selector, provider) {
        return this.registerProviderWithEvent(selector, provider, "onDidChangeCodeLenses", this.codeLensManager, this._onDidCodeLensRefresh);
      }
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        return this.registerProviderWithEvent(selector, provider, "onDidChangeSemanticTokens", this.semanticTokensManager, this._onDidSemanticTokensRefresh, legend);
      }
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        let timer = setTimeout(() => {
          this._onDidSemanticTokensRefresh.fire(selector);
        }, eventDebounce);
        let disposable = this.semanticTokensRangeManager.register(selector, provider, legend);
        return import_node3.Disposable.create(() => {
          clearTimeout(timer);
          disposable.dispose();
          this._onDidSemanticTokensRefresh.fire(selector);
        });
      }
      registerInlayHintsProvider(selector, provider) {
        return this.registerProviderWithEvent(selector, provider, "onDidChangeInlayHints", this.inlayHintManager, this._onDidInlayHintRefresh);
      }
      registerInlineValuesProvider(selector, provider) {
        return this.inlineValueManager.register(selector, provider);
      }
      registerLinkedEditingRangeProvider(selector, provider) {
        return this.linkedEditingManager.register(selector, provider);
      }
      shouldTriggerSignatureHelp(document2, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document2, triggerCharacter);
      }
      async getHover(document2, position, token) {
        return await this.hoverManager.provideHover(document2, position, token);
      }
      async getSignatureHelp(document2, position, token, context) {
        return await this.signatureManager.provideSignatureHelp(document2, position, token, context);
      }
      async getDefinition(document2, position, token) {
        return await this.definitionManager.provideDefinition(document2, position, token);
      }
      async getDefinitionLinks(document2, position, token) {
        return await this.definitionManager.provideDefinitionLinks(document2, position, token);
      }
      async getDeclaration(document2, position, token) {
        return await this.declarationManager.provideDeclaration(document2, position, token);
      }
      async getTypeDefinition(document2, position, token) {
        return await this.typeDefinitionManager.provideTypeDefinition(document2, position, token);
      }
      async getImplementation(document2, position, token) {
        return await this.implementationManager.provideImplementations(document2, position, token);
      }
      async getReferences(document2, context, position, token) {
        return await this.referenceManager.provideReferences(document2, position, context, token);
      }
      async getDocumentSymbol(document2, token) {
        return await this.documentSymbolManager.provideDocumentSymbols(document2, token);
      }
      getDocumentSymbolMetadata(document2) {
        return this.documentSymbolManager.getMetaData(document2);
      }
      async getSelectionRanges(document2, positions, token) {
        return await this.selectionRangeManager.provideSelectionRanges(document2, positions, token);
      }
      async getWorkspaceSymbols(query, token) {
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(toText(query), token);
      }
      async resolveWorkspaceSymbol(symbol, token) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
      }
      async prepareRename(document2, position, token) {
        return await this.renameManager.prepareRename(document2, position, token);
      }
      async provideRenameEdits(document2, position, newName, token) {
        return await this.renameManager.provideRenameEdits(document2, position, newName, token);
      }
      async provideDocumentFormattingEdits(document2, options2, token) {
        let res = await this.formatManager.provideDocumentFormattingEdits(document2, options2, token);
        if (res == null) {
          let hasRangeFormatter = this.formatRangeManager.hasProvider(document2);
          if (!hasRangeFormatter)
            return null;
          let end = document2.positionAt(document2.getText().length);
          let range = Range.create(Position.create(0, 0), end);
          return await this.provideDocumentRangeFormattingEdits(document2, range, options2, token);
        }
        return res;
      }
      async provideDocumentRangeFormattingEdits(document2, range, options2, token) {
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document2, range, options2, token);
      }
      async getCodeActions(document2, range, context, token) {
        return await this.codeActionManager.provideCodeActions(document2, range, context, token);
      }
      async getDocumentHighLight(document2, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document2, position, token);
      }
      async getDocumentLinks(document2, token) {
        return await this.documentLinkManager.provideDocumentLinks(document2, token);
      }
      async resolveDocumentLink(link, token) {
        return await this.documentLinkManager.resolveDocumentLink(link, token);
      }
      async provideDocumentColors(document2, token) {
        return await this.documentColorManager.provideDocumentColors(document2, token);
      }
      async provideFoldingRanges(document2, context, token) {
        return await this.foldingRangeManager.provideFoldingRanges(document2, context, token);
      }
      async provideColorPresentations(color, document2, token) {
        return await this.documentColorManager.provideColorPresentations(color, document2, token);
      }
      async getCodeLens(document2, token) {
        return await this.codeLensManager.provideCodeLenses(document2, token);
      }
      async resolveCodeLens(codeLens, token) {
        return await this.codeLensManager.resolveCodeLens(codeLens, token);
      }
      async resolveCodeAction(codeAction, token) {
        return await this.codeActionManager.resolveCodeAction(codeAction, token);
      }
      async provideDocumentOnTypeEdits(character, document2, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document2, position, token);
      }
      canFormatOnType(character, document2) {
        return this.onTypeFormatManager.couldTrigger(document2, character) != null;
      }
      async prepareCallHierarchy(document2, position, token) {
        return this.callHierarchyManager.prepareCallHierarchy(document2, position, token);
      }
      async provideIncomingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyIncomingCalls(document2, item, token);
      }
      async provideOutgoingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyOutgoingCalls(document2, item, token);
      }
      getLegend(document2, range) {
        if (range)
          return this.semanticTokensRangeManager.getLegend(document2);
        return this.semanticTokensManager.getLegend(document2);
      }
      hasSemanticTokensEdits(document2) {
        return this.semanticTokensManager.hasSemanticTokensEdits(document2);
      }
      async provideDocumentSemanticTokens(document2, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokens(document2, token);
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokensEdits(document2, previousResultId, token);
      }
      async provideDocumentRangeSemanticTokens(document2, range, token) {
        return this.semanticTokensRangeManager.provideDocumentRangeSemanticTokens(document2, range, token);
      }
      async provideInlayHints(document2, range, token) {
        return this.inlayHintManager.provideInlayHints(document2, range, token);
      }
      async resolveInlayHint(hint, token) {
        return this.inlayHintManager.resolveInlayHint(hint, token);
      }
      async provideLinkedEdits(document2, position, token) {
        return this.linkedEditingManager.provideLinkedEditingRanges(document2, position, token);
      }
      async provideInlineValues(document2, viewPort, context, token) {
        return this.inlineValueManager.provideInlineValues(document2, viewPort, context, token);
      }
      async prepareTypeHierarchy(document2, position, token) {
        return this.typeHierarchyManager.prepareTypeHierarchy(document2, position, token);
      }
      async provideTypeHierarchySupertypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySupertypes(item, token);
      }
      async provideTypeHierarchySubtypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySubtypes(item, token);
      }
      createDiagnosticCollection(owner) {
        return manager_default.create(owner);
      }
      registerProviderWithEvent(selector, provider, key, manager, emitter, extra) {
        let disposables = [];
        let timer = setTimeout(() => {
          emitter.fire(selector);
        }, eventDebounce);
        disposables.push(import_node3.Disposable.create(() => {
          clearTimeout(timer);
        }));
        func(provider[key]) && disposables.push(provider[key](() => {
          clearTimeout(timer);
          emitter.fire(selector);
        }));
        disposables.push(manager.register(selector, provider, extra));
        return import_node3.Disposable.create(() => {
          disposeAll(disposables);
          emitter.fire(selector);
        });
      }
      hasProvider(id, document2) {
        switch (id) {
          case "onTypeEdit" /* OnTypeEdit */:
          case "formatOnType" /* FormatOnType */:
            return this.onTypeFormatManager.hasProvider(document2);
          case "rename" /* Rename */:
            return this.renameManager.hasProvider(document2);
          case "documentLink" /* DocumentLink */:
            return this.documentLinkManager.hasProvider(document2);
          case "documentColor" /* DocumentColor */:
            return this.documentColorManager.hasProvider(document2);
          case "foldingRange" /* FoldingRange */:
            return this.foldingRangeManager.hasProvider(document2);
          case "format" /* Format */:
            return this.formatManager.hasProvider(document2) || this.formatRangeManager.hasProvider(document2);
          case "codeAction" /* CodeAction */:
            return this.codeActionManager.hasProvider(document2);
          case "workspaceSymbols" /* WorkspaceSymbols */:
            return this.workspaceSymbolsManager.hasProvider();
          case "formatRange" /* FormatRange */:
            return this.formatRangeManager.hasProvider(document2);
          case "hover" /* Hover */:
            return this.hoverManager.hasProvider(document2);
          case "signature" /* Signature */:
            return this.signatureManager.hasProvider(document2);
          case "documentSymbol" /* DocumentSymbol */:
            return this.documentSymbolManager.hasProvider(document2);
          case "documentHighlight" /* DocumentHighlight */:
            return this.documentHighlightManager.hasProvider(document2);
          case "definition" /* Definition */:
            return this.definitionManager.hasProvider(document2);
          case "declaration" /* Declaration */:
            return this.declarationManager.hasProvider(document2);
          case "typeDefinition" /* TypeDefinition */:
            return this.typeDefinitionManager.hasProvider(document2);
          case "reference" /* Reference */:
            return this.referenceManager.hasProvider(document2);
          case "implementation" /* Implementation */:
            return this.implementationManager.hasProvider(document2);
          case "codeLens" /* CodeLens */:
            return this.codeLensManager.hasProvider(document2);
          case "selectionRange" /* SelectionRange */:
            return this.selectionRangeManager.hasProvider(document2);
          case "callHierarchy" /* CallHierarchy */:
            return this.callHierarchyManager.hasProvider(document2);
          case "semanticTokens" /* SemanticTokens */:
            return this.semanticTokensManager.hasProvider(document2);
          case "semanticTokensRange" /* SemanticTokensRange */:
            return this.semanticTokensRangeManager.hasProvider(document2);
          case "linkedEditing" /* LinkedEditing */:
            return this.linkedEditingManager.hasProvider(document2);
          case "inlayHint" /* InlayHint */:
            return this.inlayHintManager.hasProvider(document2);
          case "inlineValue" /* InlineValue */:
            return this.inlineValueManager.hasProvider(document2);
          case "typeHierarchy" /* TypeHierarchy */:
            return this.typeHierarchyManager.hasProvider(document2);
          default:
            return false;
        }
      }
    };
    languages_default = new Languages();
  }
});

// src/completion/wordDistance.ts
var _WordDistance, WordDistance;
var init_wordDistance = __esm({
  "src/completion/wordDistance.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_array();
    init_object();
    init_is();
    init_position();
    init_workspace();
    init_util();
    _WordDistance = class {
      static async create(localityBonus, opt, token) {
        let { position } = opt;
        let cursor = [opt.linenr, opt.colnr];
        if (!localityBonus)
          return _WordDistance.None;
        let doc = workspace_default.getDocument(opt.bufnr);
        const selectionRanges = await languages_default.getSelectionRanges(doc.textDocument, [position], token);
        if (!selectionRanges || token.isCancellationRequested)
          return _WordDistance.None;
        let ranges = [];
        const iterate = (r) => {
          if (r && r.range.end.line - r.range.start.line < 2e3) {
            ranges.unshift(r.range);
            iterate(r.parent);
          }
        };
        iterate(toArray(selectionRanges)[0]);
        let wordRanges = ranges.length > 0 ? await Promise.race([waitWithToken(100, token), workspace_default.computeWordRanges(opt.bufnr, ranges[0], token)]) : void 0;
        if (!objectLiteral(wordRanges))
          return _WordDistance.None;
        delete wordRanges[opt.word];
        return new class extends _WordDistance {
          distance(anchor, item) {
            if (!equals([events_default.cursor.lnum, events_default.cursor.col], cursor)) {
              return 0;
            }
            if (item.kind === CompletionItemKind.Keyword || toObject(item.source)["name"] === "snippets") {
              return 2 << 20;
            }
            const wordLines = wordRanges[item.word];
            if (isFalsyOrEmpty(wordLines)) {
              return 2 << 20;
            }
            const idx = binarySearch(wordLines, Range.create(anchor, anchor), compareRangesUsingStarts);
            const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
            let blockDistance = ranges.length;
            for (const range of ranges) {
              if (!rangeInRange(bestWordRange, range)) {
                break;
              }
              blockDistance -= 1;
            }
            return blockDistance;
          }
        }();
      }
    };
    WordDistance = _WordDistance;
    WordDistance.None = new class extends _WordDistance {
      distance() {
        return 0;
      }
    }();
  }
});

// src/completion/complete.ts
function sortItems(emptyInput, defaultSortMethod, a, b) {
  let sa = a.sortText;
  let sb = b.sortText;
  if (a.score !== b.score)
    return b.score - a.score;
  if (a.priority !== b.priority)
    return b.priority - a.priority;
  if (a.source === b.source && sa !== sb)
    return sa < sb ? -1 : 1;
  if (a.localBonus !== b.localBonus)
    return b.localBonus - a.localBonus;
  if (emptyInput)
    return b.character - a.character;
  switch (defaultSortMethod) {
    case "none" /* None */:
      return 0;
    case "alphabetical" /* Alphabetical */:
      return a.filterText.localeCompare(b.filterText);
    case "length" /* Length */:
    default:
      return a.filterText.length - b.filterText.length;
  }
}
var logger43, MAX_DISTANCE, MIN_TIMEOUT, MAX_TIMEOUT, MAX_TRIGGER_WAIT, Complete;
var init_complete = __esm({
  "src/completion/complete.ts"() {
    "use strict";
    init_main();
    init_logger();
    init_util();
    init_array();
    init_filter();
    init_is();
    init_numbers();
    init_protocol();
    init_string();
    init_workspace();
    init_types2();
    init_util3();
    init_wordDistance();
    logger43 = createLogger("completion-complete");
    MAX_DISTANCE = 2 << 20;
    MIN_TIMEOUT = 50;
    MAX_TIMEOUT = 5e3;
    MAX_TRIGGER_WAIT = 200;
    Complete = class {
      constructor(option, document2, config, sources) {
        this.option = option;
        this.document = document2;
        this.config = config;
        this.sources = sources;
        this.results = /* @__PURE__ */ new Map();
        this._input = "";
        this._completing = false;
        this.names = [];
        this.cid = 0;
        this.minCharacter = Number.MAX_SAFE_INTEGER;
        this._onDidRefresh = new import_node3.Emitter();
        this.tokenSources = /* @__PURE__ */ new Set();
        this.tokensInfo = /* @__PURE__ */ new WeakMap();
        this.itemsMap = /* @__PURE__ */ new WeakMap();
        this.onDidRefresh = this._onDidRefresh.event;
        this.inputStart = characterIndex(option.line, option.col);
        this.timeout = clamp(this.config.timeout, MIN_TIMEOUT, MAX_TIMEOUT);
        sources.sort((a, b) => (b.priority ?? 99) - (a.priority ?? 99));
        this.names = sources.map((o) => o.name);
        this.asciiMatch = config.asciiMatch && useAscii(option.input);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      fireRefresh(waitTime) {
        clearTimeout(this.timer);
        if (!waitTime) {
          this._onDidRefresh.fire();
        } else {
          this.timer = setTimeout(() => {
            this._onDidRefresh.fire();
          }, waitTime);
        }
      }
      get totalLength() {
        let len = 0;
        for (let result of this.results.values()) {
          len += result.items.length;
        }
        return len;
      }
      resolveItem(item) {
        if (!item)
          return void 0;
        return { source: item.source, item: this.itemsMap.get(item) };
      }
      get isCompleting() {
        return this._completing;
      }
      get input() {
        return this._input;
      }
      get isEmpty() {
        return this.results.size === 0;
      }
      get hasInComplete() {
        for (let result of this.results.values()) {
          if (result.isIncomplete)
            return true;
        }
        return false;
      }
      getIncompleteSources() {
        return this.sources.filter((s) => {
          let res = this.results.get(s.name);
          return res && res.isIncomplete === true;
        });
      }
      async doComplete() {
        let tokenSource = this.createTokenSource(false);
        let token = tokenSource.token;
        let res = await Promise.all([
          this.nvim.call("coc#util#synname", []),
          this.nvim.call("coc#util#suggest_variables", [this.option.bufnr]),
          this.document.patchChange()
        ]);
        if (token.isCancellationRequested)
          return;
        this.option.synname = res[0];
        let variables = res[1];
        if (variables.disable) {
          logger43.warn("suggest cancelled by b:coc_suggest_disable");
          return true;
        }
        if (!isFalsyOrEmpty(variables.disabled_sources)) {
          this.sources = this.sources.filter((s) => !variables.disabled_sources.includes(s.name));
          if (this.sources.length === 0) {
            logger43.warn("suggest cancelled by b:coc_disabled_sources");
            return true;
          }
        }
        if (!isFalsyOrEmpty(variables.blacklist) && variables.blacklist.includes(this.option.input)) {
          logger43.warn("suggest cancelled by b:coc_suggest_blacklist");
          return true;
        }
        void WordDistance.create(this.config.localityBonus, this.option, token).then((instance2) => {
          this.wordDistance = instance2;
        });
        await waitWithToken(clamp(this.config.triggerCompletionWait, 0, MAX_TRIGGER_WAIT), tokenSource.token);
        await this.completeSources(this.sources, tokenSource, this.cid);
      }
      async completeSources(sources, tokenSource, cid) {
        const token = tokenSource.token;
        if (token.isCancellationRequested)
          return;
        this._completing = true;
        const remains = /* @__PURE__ */ new Set();
        sources.forEach((s) => remains.add(s.name));
        let timer;
        let disposable;
        let tp = new Promise((resolve) => {
          disposable = token.onCancellationRequested(() => {
            clearTimeout(timer);
            resolve();
          });
          timer = setTimeout(() => {
            let names = Array.from(remains);
            disposable.dispose();
            tokenSource.cancel();
            logger43.warn(`Completion timeout after ${this.timeout}ms`, names);
            this.nvim.setVar(`coc_timeout_sources`, names, true);
            resolve();
          }, this.timeout);
        });
        const range = this.getDefaultRange();
        let promises = sources.map((s) => this.completeSource(s, range, token).then((added) => {
          remains.delete(s.name);
          if (token.isCancellationRequested || cid != 0 || this.cid > 0 && this._completing)
            return;
          if (remains.size === 0) {
            this.fireRefresh(0);
          } else if (added) {
            this.fireRefresh(16);
          }
        }));
        await Promise.race([tp, Promise.allSettled(promises)]);
        this.tokenSources.delete(tokenSource);
        disposable.dispose();
        clearTimeout(timer);
        if (cid === this.cid)
          this._completing = false;
      }
      async completeSource(source, range, token) {
        let opt = Object.assign({}, this.option);
        let { asciiMatch } = this;
        const insertMode = this.config.insertMode;
        const sourceName = source.name;
        let added = false;
        try {
          if (func(source.shouldComplete)) {
            let shouldRun = await Promise.resolve(source.shouldComplete(opt));
            if (!shouldRun || token.isCancellationRequested)
              return;
          }
          const start = Date.now();
          const map = this.itemsMap;
          await new Promise((resolve, reject) => {
            Promise.resolve(source.doComplete(opt, token)).then((result) => {
              if (token.isCancellationRequested) {
                resolve(void 0);
                return;
              }
              let len = result ? result.items.length : 0;
              logger43.debug(`Source "${sourceName}" finished with ${len} items ms cost:`, Date.now() - start);
              if (len > 0) {
                if (number(result.startcol)) {
                  let line = opt.linenr - 1;
                  range = Range.create(line, characterIndex(opt.line, result.startcol), line, range.end.character);
                }
                const priority = getPriority(source, this.config.languageSourcePriority);
                const option = { source, insertMode, priority, asciiMatch, itemDefaults: result.itemDefaults, range };
                const converter = new Converter(this.inputStart, option, opt);
                const items = result.items.reduce((items2, item) => {
                  let completeItem = converter.convertToDurationItem(item);
                  if (!completeItem) {
                    logger43.error(`Unexpected completion item from ${sourceName}:`, item);
                    return items2;
                  }
                  map.set(completeItem, item);
                  items2.push(completeItem);
                  return items2;
                }, []);
                this.minCharacter = Math.min(this.minCharacter, converter.minCharacter);
                this.results.set(sourceName, { items, isIncomplete: result.isIncomplete === true });
                added = true;
              } else {
                this.results.delete(sourceName);
              }
              resolve();
            }, (err) => {
              reject(err);
            });
          });
        } catch (err) {
          logger43.error("Complete error:", source.name, err);
        }
        return added;
      }
      async completeInComplete(resumeInput) {
        let { document: document2 } = this;
        this.cancelInComplete();
        let tokenSource = this.createTokenSource(true);
        let token = tokenSource.token;
        await document2.patchChange(true);
        let { input, colnr, linenr, followWord, position } = this.option;
        Object.assign(this.option, {
          word: resumeInput + followWord,
          input: resumeInput,
          line: document2.getline(linenr - 1),
          position: { line: position.line, character: position.character + resumeInput.length - input.length },
          colnr: colnr + (resumeInput.length - input.length),
          triggerCharacter: void 0,
          triggerForInComplete: true
        });
        this.cid++;
        const sources = this.getIncompleteSources();
        await this.completeSources(sources, tokenSource, this.cid);
        if (token.isCancellationRequested)
          return void 0;
        return this.filterItems(resumeInput);
      }
      filterItems(input) {
        let { results, names, option, inputStart } = this;
        this._input = input;
        let len = input.length;
        let { maxItemCount, defaultSortMethod, removeDuplicateItems } = this.config;
        let arr = [];
        let words = /* @__PURE__ */ new Set();
        const emptyInput = len == 0;
        const lowInput = input.toLowerCase();
        const scoreFn = !this.config.filterGraceful || this.totalLength > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
        const scoreOption = { boostFullMatch: true, firstMatchCanBeWeak: false };
        const anchor = Position.create(option.linenr - 1, inputStart);
        for (let name2 of names) {
          let result = results.get(name2);
          if (!result)
            continue;
          let items = result.items;
          for (let idx = 0; idx < items.length; idx++) {
            let item = items[idx];
            let { word, filterText, dup } = item;
            if (dup !== true && words.has(word))
              continue;
            if (removeDuplicateItems && item.isSnippet !== true && words.has(word))
              continue;
            let fuzzyResult;
            if (!emptyInput) {
              scoreOption.firstMatchCanBeWeak = item.delta === 0 && item.character !== inputStart;
              if (item.delta > 0) {
                let prev = filterText.slice(0, item.delta);
                fuzzyResult = scoreFn(prev + input, prev + lowInput, 0, filterText, filterText.toLowerCase(), 0, scoreOption);
              } else {
                fuzzyResult = scoreFn(input, lowInput, 0, filterText, filterText.toLowerCase(), 0, scoreOption);
              }
              if (fuzzyResult == null)
                continue;
              item.score = fuzzyResult[0];
              item.positions = fuzzyResult;
              if (this.wordDistance)
                item.localBonus = MAX_DISTANCE - this.wordDistance.distance(anchor, item);
            } else if (item.character < inputStart) {
              let trigger = option.line.slice(item.character, inputStart);
              scoreOption.firstMatchCanBeWeak = true;
              fuzzyResult = anyScore(trigger, trigger.toLowerCase(), 0, filterText, filterText.toLowerCase(), 0, scoreOption);
              item.score = fuzzyResult[0];
              item.positions = fuzzyResult;
            } else {
              item.score = 0;
            }
            words.add(word);
            arr.push(item);
          }
        }
        arr.sort(sortItems.bind(null, emptyInput, defaultSortMethod));
        return this.limitCompleteItems(arr.slice(0, maxItemCount));
      }
      async filterResults(input) {
        clearTimeout(this.timer);
        if (input !== this.option.input && this.hasInComplete) {
          return await this.completeInComplete(input);
        }
        return this.filterItems(input);
      }
      limitCompleteItems(items) {
        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
        if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
          return items;
        let counts = /* @__PURE__ */ new Map();
        return items.filter((item) => {
          let { priority, source } = item;
          let isLow = priority < 90;
          let curr = counts.get(source) || 0;
          if (lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit || highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit) {
            return false;
          }
          counts.set(source, curr + 1);
          return true;
        });
      }
      getDefaultRange() {
        let { insertMode } = this.config;
        let { linenr, followWord, position } = this.option;
        let line = linenr - 1;
        let end = position.character + (insertMode == "replace" /* Repalce */ ? followWord.length : 0);
        return Range.create(line, this.inputStart, line, end);
      }
      createTokenSource(isIncomplete) {
        let tokenSource = new import_node3.CancellationTokenSource();
        this.tokenSources.add(tokenSource);
        tokenSource.token.onCancellationRequested(() => {
          this.tokenSources.delete(tokenSource);
        });
        this.tokensInfo.set(tokenSource, isIncomplete);
        return tokenSource;
      }
      cancelInComplete() {
        let { tokenSources, tokensInfo } = this;
        for (let tokenSource of Array.from(tokenSources)) {
          if (tokensInfo.get(tokenSource) === true) {
            tokenSource.cancel();
          }
        }
      }
      cancel() {
        let { tokenSources, timer } = this;
        clearTimeout(timer);
        for (let tokenSource of Array.from(tokenSources)) {
          tokenSource.cancel();
        }
        tokenSources.clear();
        this._completing = false;
      }
      dispose() {
        this.cancel();
        this.results.clear();
        this._onDidRefresh.dispose();
      }
    };
  }
});

// src/completion/floating.ts
var logger44, RESOLVE_TIMEOUT, Floating;
var init_floating = __esm({
  "src/completion/floating.ts"() {
    "use strict";
    init_logger();
    init_markdown();
    init_util();
    init_errors();
    init_is();
    init_protocol();
    init_workspace();
    init_util3();
    logger44 = createLogger("completion-floating");
    RESOLVE_TIMEOUT = getConditionValue(500, 50);
    Floating = class {
      constructor(config) {
        this.config = config;
      }
      async resolveItem(source, item, opt, showDocs, detailRendered = false) {
        this.cancel();
        if (func(source.onCompleteResolve)) {
          try {
            await this.requestWithToken((token) => {
              return Promise.resolve(source.onCompleteResolve(item, opt, token));
            });
          } catch (e) {
            if (isCancellationError(e))
              return;
            logger44.error(`Error on resolve complete item from ${source.name}:`, item, e);
            return;
          }
        }
        if (showDocs) {
          this.show(getDocumentaions(item, opt.filetype, detailRendered));
        }
      }
      show(docs) {
        let config = this.config.floatConfig;
        docs = docs.filter((o) => o.content.trim().length > 0);
        if (docs.length === 0) {
          this.close();
        } else {
          const markdownPreference = workspace_default.configurations.markdownPreference;
          let { lines, codes, highlights } = parseDocuments(docs, markdownPreference);
          let opts = {
            codes,
            highlights,
            highlight: config.highlight ?? "CocFloating",
            maxWidth: config.maxWidth || 80,
            rounded: config.rounded ? 1 : 0,
            focusable: config.focusable === true ? 1 : 0
          };
          if (config.shadow)
            opts.shadow = 1;
          if (config.border)
            opts.border = [1, 1, 1, 1];
          if (config.borderhighlight)
            opts.borderhighlight = config.borderhighlight;
          if (typeof config.winblend === "number")
            opts.winblend = config.winblend;
          let { nvim } = workspace_default;
          nvim.call("coc#dialog#create_pum_float", [lines, opts], true);
          nvim.redrawVim();
        }
      }
      close() {
        workspace_default.nvim.call("coc#pum#close_detail", [], true);
        workspace_default.nvim.redrawVim();
      }
      cancel() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = void 0;
        }
      }
      requestWithToken(fn) {
        let tokenSource = this.resolveTokenSource = new import_node3.CancellationTokenSource();
        return new Promise((resolve, reject) => {
          let called = false;
          let onFinish = (err) => {
            if (called)
              return;
            called = true;
            disposable.dispose();
            clearTimeout(timer);
            if (this.resolveTokenSource === tokenSource) {
              this.resolveTokenSource = void 0;
            }
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          };
          let timer = setTimeout(() => {
            tokenSource.cancel();
          }, RESOLVE_TIMEOUT);
          let disposable = tokenSource.token.onCancellationRequested(() => {
            onFinish(new CancellationError());
          });
          fn(tokenSource.token).then(() => {
            onFinish();
          }, (e) => {
            onFinish(e);
          });
        });
      }
    };
  }
});

// src/completion/pum.ts
function positionHighlights(hls, label, positions, pre, line, max) {
  for (let span of matchSpansReverse(label, positions, 2, max)) {
    hls.push({
      hlGroup: "CocPumSearch" /* PumSearch */,
      lnum: line,
      colStart: pre + span[0],
      colEnd: pre + span[1]
    });
  }
}
function getInsertWord(word, codes, start) {
  if (codes.length === 0)
    return word;
  for (let i = start; i < word.length; i++) {
    if (codes.includes(word.charCodeAt(i))) {
      return word.slice(0, i);
    }
  }
  return word;
}
function prefixWord(word, character, line, minCharacter) {
  return minCharacter < character ? line.slice(minCharacter, character) + word : word;
}
var PopupMenu;
var init_pum = __esm({
  "src/completion/pum.ts"() {
    "use strict";
    init_fuzzyMatch();
    init_array();
    init_filter();
    init_is();
    init_numbers();
    init_string();
    init_workspace();
    init_util3();
    PopupMenu = class {
      constructor(config, mruLoader) {
        this.config = config;
        this.mruLoader = mruLoader;
        this._search = "";
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get search() {
        return this._search;
      }
      reset() {
        this._search = "";
        this._pumConfig = void 0;
      }
      get pumConfig() {
        if (this._pumConfig)
          return this._pumConfig;
        let { floatConfig, pumFloatConfig, reversePumAboveCursor } = this.config;
        if (!pumFloatConfig)
          pumFloatConfig = floatConfig;
        let obj = {};
        if (string(pumFloatConfig.highlight))
          obj.highlight = pumFloatConfig.highlight;
        if (number(pumFloatConfig.winblend))
          obj.winblend = pumFloatConfig.winblend;
        if (pumFloatConfig.shadow)
          obj.shadow = pumFloatConfig.shadow;
        if (pumFloatConfig.border) {
          obj.border = [1, 1, 1, 1];
          obj.rounded = pumFloatConfig.rounded ? 1 : 0;
          obj.borderhighlight = pumFloatConfig.borderhighlight ?? "CocFloating";
        }
        obj.reverse = reversePumAboveCursor === true;
        this._pumConfig = obj;
        return obj;
      }
      stringWidth(text, cache = false) {
        return workspace_default.getDisplayWidth(text, cache);
      }
      show(items, search, option) {
        this._search = search;
        let { noselect, enablePreselect, invalidInsertCharacters, selection, virtualText, kindMap, defaultKindText } = this.config;
        const invalidInsertCodes = invalidInsertCharacters.map((ch) => ch.charCodeAt(0));
        let selectedIndex = enablePreselect ? items.findIndex((o) => o.preselect) : -1;
        let maxMru = -1;
        let abbrWidth = 0;
        let menuWidth = 0;
        let kindWidth = 0;
        let shortcutWidth = 0;
        let checkMru = selectedIndex == -1 && !noselect && selection !== "first" /* First */;
        let labels = [];
        let baseCharacter = characterIndex(option.line, option.col);
        let minCharacter = baseCharacter;
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          if (checkMru) {
            let n = this.mruLoader.getScore(search, item, selection);
            if (n > maxMru) {
              maxMru = n;
              selectedIndex = i;
            }
          }
          if (number(item.character) && item.character < minCharacter) {
            minCharacter = item.character;
          }
          let label = this.getLabel(item);
          labels.push(label);
          abbrWidth = Math.max(this.stringWidth(label.text, true), abbrWidth);
          if (item.kind)
            kindWidth = Math.max(this.stringWidth(getKindText(item.kind, kindMap, defaultKindText), true), kindWidth);
          if (item.menu)
            menuWidth = Math.max(this.stringWidth(item.menu, true), menuWidth);
          if (item.shortcut)
            shortcutWidth = Math.max(this.stringWidth(item.shortcut, true) + 2, shortcutWidth);
        }
        if (selectedIndex !== -1 && search.length > 0) {
          let item = items[selectedIndex];
          if (!item.word.startsWith(search)) {
            selectedIndex = -1;
          }
        }
        if (!noselect) {
          selectedIndex = selectedIndex == -1 ? 0 : selectedIndex;
        } else {
          if (selectedIndex > 0) {
            let [item] = items.splice(selectedIndex, 1);
            items.unshift(item);
            let [label] = labels.splice(selectedIndex, 1);
            labels.unshift(label);
          }
          selectedIndex = -1;
        }
        let opt = {
          input: search,
          index: selectedIndex,
          bufnr: option.bufnr,
          line: option.linenr,
          col: option.col,
          startcol: byteIndex(option.line, minCharacter),
          virtualText,
          words: items.map((o) => {
            let character = o.character;
            let start = Math.max(1, option.position.character - character + 1);
            let word = getInsertWord(o.word, invalidInsertCodes, start);
            return prefixWord(word, character, option.line, minCharacter);
          })
        };
        let pumConfig = this.pumConfig;
        let lines = [];
        let highlights = [];
        let width = 0;
        let buildConfig = { border: !!pumConfig.border, menuWidth, abbrWidth, kindWidth, shortcutWidth };
        this.adjustAbbrWidth(buildConfig);
        let lowInput = search.toLowerCase();
        for (let index = 0; index < items.length; index++) {
          let [displayWidth, text] = this.buildItem(search, lowInput, items[index], labels[index], highlights, index, buildConfig);
          width = Math.max(width, displayWidth);
          lines.push(text);
        }
        let config = Object.assign({ width, highlights }, pumConfig);
        this.nvim.call("coc#pum#create", [lines, opt, config], true);
        this.nvim.redrawVim();
      }
      getLabel(item) {
        let { labelDetails, detail } = item;
        let { snippetIndicator, labelMaxLength, detailField, detailMaxLength } = this.config;
        let label = item.abbr;
        let hls = [];
        if (item.isSnippet && !label.endsWith(snippetIndicator)) {
          label = label + snippetIndicator;
        }
        if (detailField === "abbr" && detail && !labelDetails && detail.length < detailMaxLength) {
          labelDetails = { detail: " " + detail.replace(/\r?\n\s*/g, " ") };
        }
        if (labelDetails) {
          let added = (labelDetails.detail ?? "") + (labelDetails.description ? ` ${labelDetails.description}` : "");
          if (label.length + added.length <= labelMaxLength) {
            let start = byteLength(label);
            hls.push({ start, end: start + byteLength(added), hlGroup: "CocPumDetail" /* PumDetail */ });
            label = label + added;
            item.detailRendered = true;
          }
        }
        if (label.length > labelMaxLength) {
          label = label.slice(0, labelMaxLength - 1) + ".";
        }
        return { text: label, highlights: hls };
      }
      adjustAbbrWidth(config) {
        let { formatItems } = this.config;
        let pumwidth = toNumber(workspace_default.env.pumwidth, 15);
        let len = 0;
        for (const item of formatItems) {
          if (item == "abbr" /* Abbr */) {
            len += config.abbrWidth + 1;
          } else if (item == "menu" /* Menu */ && config.menuWidth) {
            len += config.menuWidth + 1;
          } else if (item == "kind" /* Kind */ && config.kindWidth) {
            len += config.kindWidth + 1;
          } else if (item == "shortcut" /* Shortcut */ && config.shortcutWidth) {
            len += config.shortcutWidth + 1;
          }
        }
        if (len < pumwidth) {
          config.abbrWidth = config.abbrWidth + pumwidth - len;
        }
      }
      buildItem(input, lowInput, item, label, hls, index, config) {
        let { labelMaxLength, formatItems, kindMap, defaultKindText } = this.config;
        let text = config.border ? "" : " ";
        let len = byteLength(text);
        let displayWidth = text.length;
        let append = (str, width) => {
          let s = this.fillWidth(str, width);
          displayWidth += width;
          len += byteLength(s);
          text += s;
        };
        for (const name2 of formatItems) {
          switch (name2) {
            case "abbr": {
              if (!isFalsyOrEmpty(item.positions)) {
                let pre = highlightOffert(len, item);
                if (pre != -1) {
                  positionHighlights(hls, item.abbr, item.positions, pre, index, labelMaxLength);
                } else {
                  let score3 = anyScore(input, lowInput, 0, item.abbr, item.abbr.toLowerCase(), 0);
                  positionHighlights(hls, item.abbr, score3, 0, index, labelMaxLength);
                }
              }
              let abbr = label.text;
              let start = len;
              append(abbr, config.abbrWidth + 1);
              label.highlights.forEach((hl) => {
                hls.push({
                  hlGroup: hl.hlGroup,
                  lnum: index,
                  colStart: start + hl.start,
                  colEnd: start + hl.end
                });
              });
              if (item.deprecated) {
                hls.push({
                  hlGroup: "CocPumDeprecated" /* PumDeprecated */,
                  lnum: index,
                  colStart: start,
                  colEnd: len - 1
                });
              }
              break;
            }
            case "menu": {
              if (config.menuWidth > 0) {
                let colStart = len;
                append(toText(item.menu), config.menuWidth + 1);
                if (item.menu) {
                  hls.push({
                    hlGroup: "CocPumMenu" /* PumMenu */,
                    lnum: index,
                    colStart,
                    colEnd: colStart + byteLength(item.menu)
                  });
                }
              }
              break;
            }
            case "kind":
              if (config.kindWidth > 0) {
                let { kind } = item;
                let kindText = getKindText(kind, kindMap, defaultKindText);
                let colStart = len;
                append(toText(kindText), config.kindWidth + 1);
                if (kindText) {
                  hls.push({
                    hlGroup: getKindHighlight(kind),
                    lnum: index,
                    colStart,
                    colEnd: colStart + byteLength(kindText)
                  });
                }
              }
              break;
            case "shortcut":
              if (config.shortcutWidth > 0) {
                let colStart = len;
                let shortcut = item.shortcut;
                append(shortcut ? `[${shortcut}]` : "", config.shortcutWidth + 1);
                if (shortcut) {
                  hls.push({
                    hlGroup: "CocPumShortcut" /* PumShortcut */,
                    lnum: index,
                    colStart,
                    colEnd: colStart + byteLength(shortcut) + 2
                  });
                }
              }
              break;
          }
        }
        return [displayWidth, text];
      }
      fillWidth(text, width) {
        let n = width - this.stringWidth(text);
        return text + " ".repeat(Math.max(n, 0));
      }
    };
  }
});

// src/completion/index.ts
var logger45, TRIGGER_TIMEOUT, CURSORMOVE_DEBOUNCE, Completion, completion_default;
var init_completion2 = __esm({
  "src/completion/index.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_events();
    init_logger();
    init_util();
    init_array();
    init_is();
    init_node();
    init_numbers();
    init_object();
    init_string();
    init_window();
    init_workspace();
    init_complete();
    init_floating();
    init_pum();
    init_sources2();
    init_types2();
    init_util3();
    logger45 = createLogger("completion");
    TRIGGER_TIMEOUT = getConditionValue(200, 20);
    CURSORMOVE_DEBOUNCE = getConditionValue(10, 0);
    Completion = class {
      constructor() {
        this.disposables = [];
        this.complete = null;
        this.activeItems = [];
      }
      get nvim() {
        return workspace_default.nvim;
      }
      init() {
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        window_default.onDidChangeActiveTextEditor((e) => {
          this.loadLocalConfig(e.document);
        }, null, this.disposables);
        this._mru = new MruLoader();
        this.pum = new PopupMenu(this.staticConfig, this._mru);
        this.floating = new Floating(this.staticConfig);
        this._debounced = debounce(this.onCursorMovedI.bind(this), CURSORMOVE_DEBOUNCE);
        events_default.on("CursorMoved", () => {
          this.stop(true);
        }, null, this.disposables);
        events_default.on("CursorMovedI", this._debounced, this, this.disposables);
        events_default.on("CursorMovedI", () => {
          clearTimeout(this.triggerTimer);
        }, null, this.disposables);
        events_default.on("CompleteStop", (kind) => {
          this.stop(false, kind);
        }, null, this.disposables);
        events_default.on("InsertEnter", this.onInsertEnter, this, this.disposables);
        events_default.on("TextChangedI", this.onTextChangedI, this, this.disposables);
        events_default.on("TextChangedP", this.onTextChangedP, this, this.disposables);
        events_default.on("MenuPopupChanged", async (ev) => {
          if (!this.option)
            return;
          this.popupEvent = ev;
          let resolved = this.complete.resolveItem(this.selectedItem);
          if (!resolved || !ev.move && this.complete.isCompleting)
            return;
          let detailRendered = this.selectedItem.detailRendered;
          let showDocs = this.config.enableFloat;
          await this.floating.resolveItem(resolved.source, resolved.item, this.option, showDocs, detailRendered);
        }, null, this.disposables);
        this.nvim.call("coc#ui#check_pum_keymappings", [this.config.autoTrigger], true);
        commands_default.registerCommand("editor.action.triggerSuggest", async (source) => {
          await this.startCompletion({ source });
        }, this, true);
      }
      get mru() {
        return this._mru;
      }
      onCursorMovedI(bufnr, cursor, hasInsert) {
        if (hasInsert || !this.option || bufnr !== this.option.bufnr)
          return;
        let { linenr, colnr, col } = this.option;
        if (linenr === cursor[0]) {
          if (cursor[1] == colnr && cursor[1] === byteLength(toText(this.pretext)) + 1) {
            return;
          }
          let line = this.document.getline(cursor[0] - 1);
          if (line.match(/^\s*/)[0] !== this.option.line.match(/^\s*/)[0]) {
            return;
          }
          let curr = characterIndex(line, cursor[1] - 1);
          let start = characterIndex(line, col);
          if (start < curr) {
            let text = line.substring(start, curr);
            if (!this.inserted && text === this.pum.search) {
              return;
            }
          }
        }
        this.stop(true);
      }
      get option() {
        if (!this.complete)
          return null;
        return this.complete.option;
      }
      get isActivated() {
        return this.complete != null;
      }
      get inserted() {
        return this.popupEvent != null && this.popupEvent.inserted;
      }
      get document() {
        if (!this.option)
          return null;
        return workspace_default.getDocument(this.option.bufnr);
      }
      get selectedItem() {
        if (!this.popupEvent)
          return void 0;
        return this.activeItems[this.popupEvent.index];
      }
      loadLocalConfig(doc) {
        let suggest = workspace_default.getConfiguration("suggest", doc);
        this.config = {
          autoTrigger: suggest.get("autoTrigger", "always"),
          insertMode: suggest.get("insertMode", "replace" /* Repalce */),
          filterGraceful: suggest.get("filterGraceful", true),
          enableFloat: suggest.get("enableFloat", true),
          languageSourcePriority: suggest.get("languageSourcePriority", 99),
          snippetsSupport: suggest.get("snippetsSupport", true),
          defaultSortMethod: suggest.get("defaultSortMethod", "length" /* Length */),
          removeDuplicateItems: suggest.get("removeDuplicateItems", false),
          acceptSuggestionOnCommitCharacter: suggest.get("acceptSuggestionOnCommitCharacter", false),
          triggerCompletionWait: suggest.get("triggerCompletionWait", 0),
          triggerAfterInsertEnter: suggest.get("triggerAfterInsertEnter", false),
          maxItemCount: suggest.get("maxCompleteItemCount", 256),
          timeout: suggest.get("timeout", 500),
          minTriggerInputLength: suggest.get("minTriggerInputLength", 1),
          localityBonus: suggest.get("localityBonus", true),
          highPrioritySourceLimit: suggest.get("highPrioritySourceLimit", null),
          lowPrioritySourceLimit: suggest.get("lowPrioritySourceLimit", null),
          ignoreRegexps: suggest.get("ignoreRegexps", []),
          asciiMatch: suggest.get("asciiMatch", true),
          asciiCharactersOnly: suggest.get("asciiCharactersOnly", false)
        };
      }
      loadConfiguration(e) {
        if (e && !e.affectsConfiguration("suggest"))
          return;
        if (e)
          this.pum.reset();
        let suggest = workspace_default.initialConfiguration.get("suggest");
        let labels = defaultValue(suggest.completionItemKindLabels, {});
        this.staticConfig = Object.assign(this.staticConfig ?? {}, {
          kindMap: createKindMap(labels),
          defaultKindText: toText(labels["default"]),
          detailField: suggest.detailField,
          detailMaxLength: toNumber(suggest.detailMaxLength, 100),
          invalidInsertCharacters: toArray(suggest.invalidInsertCharacters),
          formatItems: suggest.formatItems,
          floatConfig: toObject(suggest.floatConfig),
          pumFloatConfig: suggest.pumFloatConfig,
          labelMaxLength: suggest.labelMaxLength,
          reversePumAboveCursor: !!suggest.reversePumAboveCursor,
          snippetIndicator: toText(suggest.snippetIndicator),
          noselect: !!suggest.noselect,
          enablePreselect: !!suggest.enablePreselect,
          virtualText: !!suggest.virtualText,
          selection: suggest.selection
        });
        let doc = workspace_default.getDocument(workspace_default.bufnr);
        this.loadLocalConfig(doc);
      }
      async startCompletion(opt) {
        clearTimeout(this.triggerTimer);
        let sourceList;
        if (string(opt.source)) {
          sourceList = toArray(sources_default.getSource(opt.source));
        }
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getAttachedDocument(bufnr);
        let info = await this.nvim.call("coc#util#change_info");
        info.pre = byteSlice(info.line, 0, info.col - 1);
        const option = this.getCompleteOption(doc, info, true);
        await this._startCompletion(option, sourceList);
      }
      async _startCompletion(option, sourceList) {
        this._debounced.clear();
        let doc = workspace_default.getAttachedDocument(option.bufnr);
        option.filetype = doc.filetype;
        logger45.debug("trigger completion with", option);
        this.stop(true);
        this.pretext = byteSlice(option.line, 0, option.colnr - 1);
        sourceList = sourceList ?? sources_default.getSources(option);
        if (isFalsyOrEmpty(sourceList))
          return;
        let complete = this.complete = new Complete(
          option,
          doc,
          this.config,
          sourceList
        );
        events_default.completing = true;
        complete.onDidRefresh(async () => {
          clearTimeout(this.triggerTimer);
          if (complete.isEmpty) {
            this.stop(false);
            return;
          }
          if (this.inserted)
            return;
          await this.filterResults();
        });
        let shouldStop2 = await complete.doComplete();
        if (shouldStop2)
          this.stop(false);
      }
      async onTextChangedP(_bufnr, info) {
        if (!info.insertChar && this.complete) {
          this.complete.cancel();
        }
        this.pretext = info.pre;
      }
      async onTextChangedI(bufnr, info) {
        const doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          return;
        const { option } = this;
        if (option != null) {
          if (!info.insertChar) {
            let pre = byteSlice(option.line, 0, option.col);
            if (this.selectedItem) {
              let { word, startcol } = this.popupEvent;
              if (byteSlice(option.line, 0, startcol) + word == info.pre) {
                this.pretext = info.pre;
                return;
              }
            } else if (pre + this.pum.search == info.pre) {
              return;
            }
          }
          if (info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
            await this.triggerCompletion(doc, info);
            return;
          }
          if (shouldStop(bufnr, this.pretext, info, option)) {
            this.stop(true);
          }
        }
        if (info.pre === this.pretext)
          return;
        clearTimeout(this.triggerTimer);
        let pretext = this.pretext = info.pre;
        if (!info.insertChar) {
          if (this.complete)
            await this.filterResults();
          return;
        }
        if (this.config.acceptSuggestionOnCommitCharacter && this.selectedItem) {
          let last = pretext.slice(-1);
          let resolvedItem = this.selectedItem;
          let result = this.complete.resolveItem(resolvedItem);
          if (result && sources_default.shouldCommit(result.source, result.item, last)) {
            logger45.debug("commit by commit character.");
            let startcol = byteIndex(this.option.line, resolvedItem.character) + 1;
            this.stop(true);
            this.nvim.call("coc#pum#repalce", [startcol, resolvedItem.word + info.insertChar], true);
            return;
          }
        }
        if (!doc.chars.isKeywordChar(info.insertChar)) {
          let triggerSources = this.getTriggerSources(doc, pretext);
          if (triggerSources.length > 0) {
            await this.triggerCompletion(doc, info, triggerSources);
            return;
          }
        }
        if (!this.complete) {
          await this.triggerCompletion(doc, info);
          return;
        }
        if (this.complete.isEmpty) {
          this.triggerTimer = setTimeout(async () => {
            await this.triggerCompletion(doc, info);
          }, TRIGGER_TIMEOUT);
          return;
        }
        await this.filterResults(info);
      }
      getTriggerSources(doc, pretext) {
        let disabled = doc.getVar("disabled_sources", []);
        if (this.config.autoTrigger === "none")
          return [];
        return sources_default.getTriggerSources(pretext, doc.filetype, doc.uri, disabled);
      }
      async triggerCompletion(doc, info, sources) {
        let { minTriggerInputLength, autoTrigger } = this.config;
        let { pre } = info;
        if (autoTrigger === "none")
          return false;
        if (!sources && !this.shouldTrigger(doc, pre))
          return false;
        const option = this.getCompleteOption(doc, info);
        if (sources == null && option.input.length < minTriggerInputLength) {
          logger45.trace(`Suggest not triggered with input "${option.input}", minimal trigger input length: ${minTriggerInputLength}`);
          return false;
        }
        if (checkIgnoreRegexps(this.config.ignoreRegexps, option.input))
          return false;
        await this._startCompletion(option, sources);
        return true;
      }
      getCompleteOption(doc, info, manual = false) {
        let { pre } = info;
        let input = getInput(doc.chars, info.pre, this.config.asciiCharactersOnly);
        let followWord = doc.getStartWord(info.line.slice(info.pre.length));
        return {
          input,
          position: Position.create(info.lnum - 1, info.pre.length),
          line: info.line,
          followWord,
          filetype: doc.filetype,
          linenr: info.lnum,
          col: info.col - 1 - byteLength(input),
          colnr: info.col,
          bufnr: doc.bufnr,
          word: input + followWord,
          changedtick: info.changedtick,
          synname: "",
          filepath: doc.schema === "file" ? URI.parse(doc.uri).fsPath : "",
          triggerCharacter: manual ? void 0 : toText(pre[pre.length - 1])
        };
      }
      stop(close, kind = "" /* Normal */) {
        var _a2;
        let { complete } = this;
        if (complete == null)
          return;
        let inserted = kind === "confirm" /* Confirm */ || ((_a2 = this.popupEvent) == null ? void 0 : _a2.inserted) && kind != "cancel" /* Cancel */;
        let item = this.selectedItem;
        let character = item == null ? void 0 : item.character;
        let resolved = complete.resolveItem(item);
        let option = complete.option;
        let input = complete.input;
        let doc = workspace_default.getDocument(option.bufnr);
        let line = option.line;
        let inputStart = characterIndex(line, option.col);
        events_default.completing = false;
        this.cancel();
        doc._forceSync();
        void events_default.fire("CompleteDone", [toCompleteDoneItem(item, resolved == null ? void 0 : resolved.item)]);
        if (close)
          this.nvim.call("coc#pum#_close", [], true);
        if (resolved && inserted) {
          this._mru.add(line.slice(character, inputStart) + input, item);
        }
        if (kind == "confirm" /* Confirm */ && resolved) {
          void this.confirmCompletion(resolved.source, resolved.item, option);
        }
      }
      async confirmCompletion(source, item, option) {
        await this.floating.resolveItem(source, item, option, false);
        if (!func(source.onCompleteDone))
          return;
        let { insertMode, snippetsSupport } = this.config;
        let opt = Object.assign({ insertMode, snippetsSupport }, option);
        await Promise.resolve(source.onCompleteDone(item, opt));
      }
      async onInsertEnter(bufnr) {
        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== "always")
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          return;
        let change = await this.nvim.call("coc#util#change_info");
        change.pre = byteSlice(change.line, 0, change.col - 1);
        await this.triggerCompletion(doc, change);
      }
      shouldTrigger(doc, pre) {
        let { autoTrigger } = this.config;
        if (autoTrigger == "none")
          return false;
        if (sources_default.shouldTrigger(pre, doc.filetype, doc.uri))
          return true;
        if (autoTrigger !== "always")
          return false;
        return true;
      }
      async filterResults(info) {
        let { complete, option, pretext } = this;
        let search = getResumeInput(option, pretext);
        if (search == null) {
          this.stop(true);
          return;
        }
        let items = await complete.filterResults(search);
        if (items === void 0 || !this.option)
          return;
        let doc = workspace_default.getDocument(option.bufnr);
        if (info && info.insertChar && items.length == 0) {
          let triggerSources = this.getTriggerSources(doc, pretext);
          if (triggerSources.length > 0) {
            await this.triggerCompletion(doc, info, triggerSources);
            return;
          }
        }
        if (items.length == 0) {
          let last = search.slice(-1);
          if (!complete.isCompleting || last.length === 0 || !doc.chars.isKeywordChar(last)) {
            this.stop(true);
          }
          return;
        }
        this.activeItems = items;
        this.pum.show(items, search, this.option);
      }
      cancel() {
        if (this.complete != null) {
          this.complete.dispose();
          this.complete = null;
        }
        if (this.triggerTimer != null) {
          clearTimeout(this.triggerTimer);
          this.triggerTimer = null;
        }
        this.pretext = void 0;
        this.activeItems = [];
        this.popupEvent = void 0;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    completion_default = new Completion();
  }
});

// src/cursors/util.ts
function splitRange(doc, range) {
  let splited = [];
  for (let i = range.start.line; i <= range.end.line; i++) {
    let curr = doc.getline(i) || "";
    let sc = i == range.start.line ? range.start.character : 0;
    let ec = i == range.end.line ? range.end.character : curr.length;
    if (sc == ec)
      continue;
    splited.push(Range.create(i, sc, i, ec));
  }
  return splited;
}
function getVisualRanges(doc, range) {
  let { start, end } = getWellformedRange2(range);
  let sc = start.character < end.character ? start.character : end.character;
  let ec = start.character < end.character ? end.character : start.character;
  let ranges = [];
  for (let i = start.line; i <= end.line; i++) {
    let line = doc.getline(i);
    ranges.push(Range.create(i, sc, i, Math.min(line.length, ec)));
  }
  return ranges;
}
function isSurrondChange(change) {
  return Array.isArray(change["prepend"]) && Array.isArray(change["append"]);
}
function getDelta(change) {
  if (isSurrondChange(change)) {
    return change.append[1].length + change.prepend[1].length - change.append[0] - change.prepend[0];
  }
  return change.insert.length - change.remove;
}
function getChange(r, range, newText) {
  let text = r.text;
  if (equals(r.range, range)) {
    let idx = text.indexOf(newText);
    if (idx !== -1) {
      let prepend = [idx, ""];
      let append = [text.length - newText.length - idx, ""];
      return { prepend, append };
    }
    idx = newText.indexOf(text);
    if (idx !== -1) {
      let prepend = [0, newText.slice(0, idx)];
      let append = [0, newText.slice(-(newText.length - text.length - idx))];
      return { prepend, append };
    }
  }
  if (equals(r.range.end, range.end)) {
    let remove3 = range.end.character - range.start.character;
    return { offset: remove3, remove: remove3, insert: newText, fromEnd: true };
  }
  let remove2 = range.end.character - range.start.character;
  let offset = range.start.character - r.range.start.character;
  return { offset, remove: remove2, insert: newText };
}
function getBeforeCount(textRange, ranges, exclude) {
  let n = 0;
  for (let idx = 0; idx < ranges.length; idx++) {
    const r = ranges[idx];
    if (r.position.line < textRange.position.line || r === exclude)
      continue;
    if (r.isBefore(textRange)) {
      n++;
      continue;
    }
    break;
  }
  return n;
}
var init_util5 = __esm({
  "src/cursors/util.ts"() {
    "use strict";
    init_main();
    init_object();
    init_textedit();
  }
});

// src/cursors/textRange.ts
var TextRange;
var init_textRange = __esm({
  "src/cursors/textRange.ts"() {
    "use strict";
    init_main();
    init_position();
    init_textedit();
    init_util5();
    TextRange = class {
      constructor(line, character, text) {
        this.start = Position.create(line, character);
        this._text = text;
        this.end = getEnd(this.start, this._text);
      }
      get position() {
        return this.start;
      }
      get line() {
        return this.start.line;
      }
      get text() {
        return this._text;
      }
      get range() {
        return Range.create(this.start, this.end);
      }
      get textEdit() {
        return {
          range: this.range,
          newText: this.text
        };
      }
      applyChange(change) {
        if (isSurrondChange(change)) {
          this.applySurrondChange(change);
        } else {
          this.applyTextChange(change);
        }
      }
      applySurrondChange(change) {
        let { prepend, append } = change;
        let len = this._text.length;
        let text = this._text.substring(prepend[0], len - append[0]);
        this._text = `${prepend[1]}${text}${append[1]}`;
      }
      applyTextChange(change) {
        let { text } = this;
        let { offset, remove: remove2, fromEnd, insert } = change;
        if (fromEnd)
          offset = -offset;
        let pre = text.slice(0, fromEnd && offset == 0 ? text.length : offset);
        let after = text.slice(pre.length);
        if (remove2)
          after = after.slice(remove2);
        this._text = `${pre}${insert || ""}${after}`;
      }
      move(delta) {
        if (delta != 0) {
          let { line, character } = this.start;
          this.start = Position.create(line, character + delta);
        }
        this.end = getEnd(this.start, this._text);
      }
      adjustFromEdit(edit2) {
        let changed = getChangedPosition(this.start, edit2);
        if (changed.line || changed.character) {
          let { line, character } = this.start;
          this.start = Position.create(line + changed.line, character + changed.character);
          this.end = getEnd(this.start, this._text);
        }
        return changed.character;
      }
      isBefore(range) {
        let { position } = range;
        let { line, character } = this.start;
        return position.line == line && position.character > character;
      }
    };
  }
});

// src/cursors/session.ts
function surrondChanges(changes, len) {
  if (changes.length != 2 || changes[0].offset != 0)
    return false;
  let end = changes[1].offset + (changes[1].remove ? changes[1].remove.length : 0);
  if (end !== len)
    return false;
  return true;
}
var logger46, CursorSession;
var init_session3 = __esm({
  "src/cursors/session.ts"() {
    "use strict";
    init_main3();
    init_main();
    init_logger();
    init_util();
    init_node();
    init_position();
    init_protocol();
    init_textedit();
    init_window();
    init_workspace();
    init_textRange();
    init_util5();
    logger46 = createLogger("cursors-session");
    CursorSession = class {
      constructor(nvim, doc, config) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this._onDidCancel = new import_node3.Emitter();
        this._onDidUpdate = new import_node3.Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.disposables = [];
        this.ranges = [];
        this.activated = true;
        this.changing = false;
        let { bufnr } = doc;
        doc.buffer.setVar("coc_cursors_activated", 1, true);
        let { cancelKey, nextKey, previousKey } = this.config;
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", cancelKey, () => {
          this.cancel();
        }));
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", nextKey, async () => {
          let ranges = this.ranges.map((o) => o.range);
          let curr = await window_default.getCursorPosition();
          for (let r of ranges) {
            if (comparePosition(r.start, curr) > 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          let wrap = this.config.wrapscan;
          if (ranges.length && wrap)
            await window_default.moveTo(ranges[0].start);
        }));
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", previousKey, async () => {
          let ranges = this.ranges.map((o) => o.range);
          let curr = await window_default.getCursorPosition();
          for (let i = ranges.length - 1; i >= 0; i--) {
            let r = ranges[i];
            if (comparePosition(r.end, curr) < 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          let wrap = this.config.wrapscan;
          if (ranges.length && wrap)
            await window_default.moveTo(ranges[ranges.length - 1].start);
        }));
        this.doc.onDocumentChange(async (e) => {
          await this.onChange(e);
          if (this.activated && !this.changing) {
            this._onDidUpdate.fire();
          }
        }, this, this.disposables);
      }
      addRange(range) {
        let { ranges } = this;
        let idx = ranges.findIndex((o) => rangeIntersect(o.range, range));
        if (idx !== -1) {
          ranges.splice(idx, 1);
        } else {
          this.createRange(range);
          ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
        }
        if (this.ranges.length == 0) {
          this.cancel();
        } else {
          this.doHighlights();
        }
      }
      addRanges(ranges) {
        this.doc._forceSync();
        this.ranges = this.ranges.filter((r) => {
          return !ranges.some((range) => rangeOverlap(range, r.range));
        });
        for (let range of ranges) {
          this.createRange(range);
        }
        this.ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
        this.doHighlights();
        return true;
      }
      createRange(range) {
        let { textDocument } = this.doc;
        let { line, character } = range.start;
        let text = textDocument.getText(range);
        this.ranges.push(new TextRange(line, character, text));
      }
      async onChange(e) {
        if (!this.activated || this.changing)
          return;
        if (e.contentChanges.length === 0) {
          this.doHighlights();
          return;
        }
        let change = e.contentChanges[0];
        let { text, range } = change;
        let affected = this.ranges.filter((r) => {
          if (!rangeIntersect(range, r.range))
            return false;
          if (rangeAdjacent(range, r.range)) {
            if (text.includes("\n") || !emptyRange(range))
              return false;
          }
          return true;
        });
        if (emptyRange(range) && affected.length > 0) {
          affected = affected.slice(0, 1);
        }
        if (affected.length == 0) {
          logger46.debug("no affected ranges");
          this.ranges.forEach((r) => {
            r.adjustFromEdit({ range, newText: text });
          });
          this.doHighlights();
        } else if (affected.length == 1 && rangeInRange(range, affected[0].range)) {
          logger46.debug("affected single range");
          if (text.includes("\n")) {
            this.cancel();
            return;
          }
          await this.applySingleEdit(affected[0], { range, newText: text });
        } else if (!text.length || !this.validChange(range, text)) {
          logger46.debug("filter affected ranges.");
          let ranges = this.ranges.filter((r) => !affected.includes(r));
          if (ranges.length > 0) {
            this.ranges = ranges;
            ranges.forEach((r) => {
              r.adjustFromEdit({ range, newText: text });
            });
            this.doHighlights();
          } else {
            this.cancel();
          }
        } else {
          logger46.debug("Check undo & redo");
          let first = this.ranges[0];
          let last = this.ranges[this.ranges.length - 1];
          let originalLines = e.originalLines.slice(first.line, last.line + 1);
          let newLines = this.doc.textDocument.lines.slice(first.line, last.line + 1);
          this.applyComposedEdit(originalLines, newLines);
        }
      }
      validChange(range, text) {
        if (lineCountChange(TextEdit.replace(range, text)) != 0)
          return false;
        if (!rangeInRange(range, this.range))
          return false;
        let first = this.ranges[0];
        let last = this.ranges[this.ranges.length - 1];
        if (range.start.line != first.position.line || range.end.line != last.position.line)
          return false;
        return true;
      }
      get range() {
        let first = this.ranges[0];
        let last = this.ranges[this.ranges.length - 1];
        return Range.create(first.position, last.range.end);
      }
      doHighlights() {
        let { nvim, ranges, doc } = this;
        let buffer = doc.buffer;
        let items = [];
        ranges.forEach((r) => {
          doc.addHighlights(items, "CocCursorRange", r.range, {
            combine: false,
            start_incl: true,
            end_incl: true
          });
        });
        items.sort((a, b) => {
          if (a.lnum != b.lnum)
            return a.lnum - b.lnum;
          if (a.colStart != b.colStart)
            return a.colStart - b.colStart;
          return 0;
        });
        buffer.updateHighlights("cursors", items, { priority: 4096 });
        nvim.redrawVim();
      }
      get currentRanges() {
        return this.ranges.map((r) => r.range);
      }
      cancel() {
        if (!this.activated)
          return;
        logger46.debug("cursors cancel");
        let buffer = this.doc.buffer;
        this.activated = false;
        this.ranges = [];
        buffer.clearNamespace("cursors");
        buffer.setVar("coc_cursors_activated", 0, true);
        this._onDidUpdate.fire();
        this._onDidCancel.fire();
      }
      dispose() {
        if (!this.doc)
          return;
        this._onDidCancel.dispose();
        this._onDidUpdate.dispose();
        disposeAll(this.disposables);
        this.ranges = [];
        this.doc = null;
      }
      async applySingleEdit(textRange, edit2) {
        let { doc, ranges } = this;
        let after = ranges.filter((r) => r !== textRange && r.position.line == textRange.position.line);
        after.forEach((r) => r.adjustFromEdit(edit2));
        let change = getChange(textRange, edit2.range, edit2.newText);
        let delta = getDelta(change);
        ranges.forEach((r) => r.applyChange(change));
        let edits = ranges.filter((r) => r !== textRange).map((o) => o.textEdit);
        this.changing = true;
        await doc.applyEdits(edits, true, true);
        this.changing = false;
        if (delta != 0) {
          for (let r of ranges) {
            let n = getBeforeCount(r, this.ranges, textRange);
            r.move(n * delta);
          }
        }
        this.doHighlights();
      }
      applyComposedEdit(originalLines, newLines) {
        let diffs = fastDiff(originalLines[0], newLines[0]);
        let first = this.ranges[0];
        let s = first.position.character;
        let firstLine = first.position.line;
        let len = first.text.length;
        let diff = diffs[0];
        if (s > 0 && (diff[0] != fastDiff.EQUAL || !diff[1].startsWith(originalLines[0].slice(0, s)))) {
          this.cancel();
          return false;
        }
        let used = 0;
        let invalid = false;
        let changes = [];
        for (let i = 0; i < diffs.length; i++) {
          let [kind, text] = diffs[i];
          if (i == 0 && s > 0) {
            text = text.slice(s);
          }
          if (kind == fastDiff.EQUAL) {
            used += text.length;
            if (used > len)
              break;
          } else if (kind == fastDiff.DELETE) {
            let offset = used;
            used += text.length;
            if (used > len) {
              invalid = true;
              break;
            }
            changes.push({ offset, remove: text });
          } else {
            let prev = diffs[i - 1];
            if (prev && prev[0] == fastDiff.DELETE) {
              changes[changes.length - 1].add = text;
            } else {
              changes.push({ offset: used, add: text });
            }
          }
        }
        if (invalid || !changes.length) {
          this.cancel();
          return false;
        }
        let doc = TextDocument2.create("file:///1", "", 0, originalLines.join("\n"));
        let change;
        if (changes.length == 1) {
          change = {
            offset: changes[0].offset,
            remove: changes[0].remove ? changes[0].remove.length : 0,
            insert: changes[0].add ?? ""
          };
        } else if (surrondChanges(changes, len)) {
          change = {
            prepend: [changes[0].remove ? changes[0].remove.length : 0, changes[0].add ?? ""],
            append: [changes[1].remove ? changes[1].remove.length : 0, changes[1].add ?? ""]
          };
        } else {
          let text = first.text;
          let oldText = "";
          let newText = "";
          let offset = changes[0].offset;
          for (let c of changes) {
            if (c.offset > offset + oldText.length) {
              let s2 = text.slice(offset + oldText.length, c.offset);
              oldText += s2;
              newText += s2;
            }
            if (c.add) {
              newText += c.add;
            }
            if (c.remove) {
              oldText += c.remove;
            }
          }
          change = {
            offset,
            remove: oldText.length,
            insert: newText
          };
        }
        let edits = this.ranges.map((o) => {
          let line = o.position.line - firstLine;
          let { start, end } = o.range;
          let range = Range.create(line, start.character, line, end.character);
          o.applyChange(change);
          return TextEdit.replace(range, o.text);
        });
        let content = TextDocument2.applyEdits(doc, edits);
        if (content !== newLines.join("\n")) {
          this.cancel();
          return false;
        }
        let delta = getDelta(change);
        if (delta != 0) {
          for (let r of this.ranges) {
            let n = getBeforeCount(r, this.ranges);
            r.move(n * delta);
          }
        }
        this.doHighlights();
        return true;
      }
    };
  }
});

// src/cursors/index.ts
var Cursors;
var init_cursors = __esm({
  "src/cursors/index.ts"() {
    "use strict";
    init_main();
    init_window();
    init_workspace();
    init_commands();
    init_session3();
    init_util5();
    Cursors = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.sessionsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        workspace_default.onDidCloseTextDocument((e) => {
          let session = this.getSession(e.bufnr);
          if (!session)
            return;
          this.sessionsMap.delete(e.bufnr);
          session.dispose();
        }, null, this.disposables);
        this.disposables.push(commands_default.registerCommand("editor.action.addRanges", async (ranges) => {
          await this.addRanges(ranges);
        }, null, true));
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("cursors")) {
          let config = workspace_default.initialConfiguration;
          this.config = config.get("cursors");
        }
      }
      cancel(uri) {
        let doc = workspace_default.getDocument(uri);
        if (!doc)
          return;
        let session = this.getSession(doc.bufnr);
        if (session)
          session.cancel();
      }
      getSession(bufnr) {
        return this.sessionsMap.get(bufnr);
      }
      async isActivated() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        return this.sessionsMap.get(bufnr) != null;
      }
      async select(bufnr, kind, mode) {
        let doc = workspace_default.getAttachedDocument(bufnr);
        let { nvim } = this;
        let session = this.createSession(doc);
        let range;
        if (kind == "operator") {
          let res = await nvim.eval(`[getpos("'["),getpos("']")]`);
          if (mode == "char") {
            let start = doc.getPosition(res[0][1], res[0][2]);
            let end = doc.getPosition(res[1][1], res[1][2] + 1);
            let ranges = splitRange(doc, Range.create(start, end));
            session.addRanges(ranges);
          } else {
            let ranges = [];
            for (let i = res[0][1] - 1; i <= res[1][1] - 1; i++) {
              let line = doc.getline(i);
              ranges.push(Range.create(i, 0, i, line.length));
            }
            session.addRanges(ranges);
          }
        } else if (kind == "word") {
          let pos = await window_default.getCursorPosition();
          range = doc.getWordRangeAtPosition(pos);
          if (!range) {
            let line = doc.getline(pos.line);
            if (pos.character == line.length) {
              range = Range.create(pos.line, Math.max(0, line.length - 1), pos.line, line.length);
            } else {
              range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
            }
          }
          session.addRange(range);
          await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        } else if (kind == "position") {
          let pos = await window_default.getCursorPosition();
          let line = doc.getline(pos.line);
          if (pos.character >= line.length) {
            range = Range.create(pos.line, line.length - 1, pos.line, line.length);
          } else {
            range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
          }
          session.addRange(range);
          await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        } else if (kind == "range") {
          await nvim.call("eval", 'feedkeys("\\<esc>", "in")');
          let range2 = await window_default.getSelectedRange(mode);
          if (!range2)
            return;
          let ranges = mode == "" ? getVisualRanges(doc, range2) : splitRange(doc, range2);
          for (let r of ranges) {
            session.addRange(r);
          }
        } else {
          throw new Error(`select kind "${kind}" not supported`);
        }
      }
      createSession(doc) {
        let { bufnr } = doc;
        let session = this.getSession(bufnr);
        if (session)
          return session;
        session = new CursorSession(this.nvim, doc, this.config);
        this.sessionsMap.set(bufnr, session);
        session.onDidCancel(() => {
          session.dispose();
          this.sessionsMap.delete(bufnr);
        });
        return session;
      }
      async addRanges(ranges) {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getAttachedDocument(bufnr);
        let session = this.createSession(doc);
        return session.addRanges(ranges);
      }
      reset() {
        for (let session of this.sessionsMap.values()) {
          session.cancel();
        }
        this.sessionsMap.clear();
      }
    };
  }
});

// src/tree/LocationsDataProvider.ts
function addChildren(el, children, token) {
  if (!Array.isArray(children) || token && token.isCancellationRequested)
    return;
  children.forEach((item) => item.parent = el);
  el.children = children;
}
var _LocationsDataProvider, LocationsDataProvider;
var init_LocationsDataProvider = __esm({
  "src/tree/LocationsDataProvider.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_node();
    init_protocol();
    init_workspace();
    init_TreeItem();
    _LocationsDataProvider = class {
      constructor(meta, winid, config, commandId, rootItems, getIcon, resolveChildren) {
        this.meta = meta;
        this.winid = winid;
        this.config = config;
        this.commandId = commandId;
        this.rootItems = rootItems;
        this.getIcon = getIcon;
        this.resolveChildren = resolveChildren;
        this._onDidChangeTreeData = new import_node3.Emitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.actions = [];
        this.addAction("Open in new tab", async (element) => {
          await commands_default.executeCommand(this.commandId, winid, element, "tabe");
        });
        this.addAction("Dismiss", async (element) => {
          if (element.parent == null) {
            let els = this.rootItems.filter((o) => o !== element);
            this.reset(els);
          } else {
            let parentElement = element.parent;
            let idx = parentElement.children.findIndex((o) => o === element);
            parentElement.children.splice(idx, 1);
            this._onDidChangeTreeData.fire(parentElement);
          }
        });
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = void 0;
        }
      }
      reset(rootItems) {
        this.rootItems = rootItems;
        this._onDidChangeTreeData.fire(void 0);
      }
      addAction(title, handler) {
        this.actions.push({ title, handler });
      }
      async getChildren(element) {
        this.cancel();
        this.tokenSource = new import_node3.CancellationTokenSource();
        let { token } = this.tokenSource;
        if (!element) {
          for (let o of this.rootItems) {
            let children = await this.resolveChildren(o, this.meta, token);
            addChildren(o, children, token);
          }
          return this.rootItems;
        }
        if (element.children)
          return element.children;
        let items = await this.resolveChildren(element, this.meta, token);
        this.tokenSource = void 0;
        addChildren(element, items, token);
        return items;
      }
      getTreeItem(element) {
        var _a2;
        let item = new TreeItem(element.name, element.children ? 2 /* Expanded */ : 1 /* Collapsed */);
        if (this.config.enableTooltip) {
          item.tooltip = path.relative(workspace_default.cwd, URI.parse(element.uri).fsPath);
        }
        item.description = element.detail;
        item.deprecated = (_a2 = element.tags) == null ? void 0 : _a2.includes(SymbolTag.Deprecated);
        item.icon = this.getIcon(element.kind);
        item.command = {
          command: this.commandId,
          title: "open location",
          arguments: [this.winid, element, this.config.openCommand]
        };
        return item;
      }
      resolveActions() {
        return this.actions;
      }
      dispose() {
        this.cancel();
        let win = workspace_default.nvim.createWindow(this.winid);
        win.clearMatchGroup(_LocationsDataProvider.rangesHighlight);
      }
    };
    LocationsDataProvider = _LocationsDataProvider;
    LocationsDataProvider.rangesHighlight = "CocSelectedRange";
  }
});

// src/handler/callHierarchy.ts
function toCallHierarchyItem(item) {
  return omit(item, ["children", "parent", "ranges", "sourceUri"]);
}
function isCallHierarchyItem(item) {
  if (item && typeof item.name === "string" && item.kind && Range.is(item.range))
    return true;
  return false;
}
function getTitle(kind) {
  return `${kind.toUpperCase()} CALLS`;
}
var _CallHierarchyHandler, CallHierarchyHandler;
var init_callHierarchy2 = __esm({
  "src/handler/callHierarchy.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_LocationsDataProvider();
    init_TreeView();
    init_util();
    init_array();
    init_lodash();
    init_protocol();
    init_window();
    init_workspace();
    _CallHierarchyHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = /* @__PURE__ */ new Set();
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.disposables.push(commands_default.registerCommand(_CallHierarchyHandler.commandId, async (winid, item, openCommand) => {
          var _a2;
          let { nvim: nvim2 } = this;
          await nvim2.call("win_gotoid", [winid]);
          await workspace_default.jumpTo(item.uri, item.selectionRange.start, openCommand);
          let win = await nvim2.window;
          win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
          win.highlightRanges(_CallHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
          if (!((_a2 = item.ranges) == null ? void 0 : _a2.length))
            return;
          if (item.sourceUri) {
            let doc = workspace_default.getDocument(item.sourceUri);
            if (!doc)
              return;
            let winid2 = await nvim2.call("coc#compat#buf_win_id", [doc.bufnr]);
            if (winid2 == -1)
              return;
            if (winid2 != win.id) {
              win = nvim2.createWindow(winid2);
              win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
            }
          }
          win.highlightRanges(_CallHierarchyHandler.rangesHighlight, item.ranges, 100, true);
          this.highlightWinids.add(win.id);
        }, null, true));
        events_default.on("BufWinEnter", (_, winid) => {
          if (this.highlightWinids.has(winid)) {
            this.highlightWinids.delete(winid);
            let win = nvim.createWindow(winid);
            win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
          }
        }, null, this.disposables);
        commands_default.register({
          id: "document.showIncomingCalls",
          execute: async () => {
            await this.showCallHierarchyTree("incoming");
          }
        }, false, "show incoming calls in tree view.");
        commands_default.register({
          id: "document.showOutgoingCalls",
          execute: async () => {
            await this.showCallHierarchyTree("outgoing");
          }
        }, false, "show outgoing calls in tree view.");
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("callHierarchy")) {
          let c = workspace_default.getConfiguration("callHierarchy", null);
          this.config = {
            splitCommand: c.get("splitCommand"),
            openCommand: c.get("openCommand"),
            enableTooltip: c.get("enableTooltip")
          };
        }
      }
      createProvider(rootItems, doc, winid, kind) {
        let provider = new LocationsDataProvider(
          kind,
          winid,
          this.config,
          _CallHierarchyHandler.commandId,
          rootItems,
          (kind2) => this.handler.getIcon(kind2),
          (el, meta, token) => this.getChildren(doc, el, meta, token)
        );
        for (let kind2 of ["incoming", "outgoing"]) {
          let name2 = kind2 === "incoming" ? "Show Incoming Calls" /* Incoming */ : "Show Outgoing Calls" /* Outgoing */;
          provider.addAction(name2, (el) => {
            provider.meta = kind2;
            let rootItems2 = [toCallHierarchyItem(el)];
            provider.reset(rootItems2);
          });
        }
        return provider;
      }
      async getChildren(doc, item, kind, token) {
        let items = [];
        let callHierarchyItem = toCallHierarchyItem(item);
        if (kind == "incoming") {
          let res = await languages_default.provideIncomingCalls(doc, callHierarchyItem, token);
          if (res)
            items = res.map((o) => Object.assign(o.from, { ranges: o.fromRanges }));
        } else {
          let res = await languages_default.provideOutgoingCalls(doc, callHierarchyItem, token);
          if (res)
            items = res.map((o) => Object.assign(o.to, { ranges: o.fromRanges, sourceUri: item.uri }));
        }
        return items;
      }
      async prepare(doc, position, token) {
        this.handler.checkProvider("callHierarchy" /* CallHierarchy */, doc);
        const res = await languages_default.prepareCallHierarchy(doc, position, token);
        return isCallHierarchyItem(res) ? [res] : res;
      }
      async getCallHierarchyItems(item, kind) {
        const { doc, position } = await this.handler.getCurrentState();
        const source = new import_node3.CancellationTokenSource();
        if (!item) {
          await doc.synchronize();
          let res = await this.prepare(doc.textDocument, position, source.token);
          item = res ? res[0] : void 0;
          if (!res)
            throw new Error("Unable to getCallHierarchyItem at current position");
        }
        let method = kind == "incoming" ? "provideIncomingCalls" : "provideOutgoingCalls";
        return await languages_default[method](doc.textDocument, item, source.token);
      }
      async getIncoming(item) {
        return await this.getCallHierarchyItems(item, "incoming");
      }
      async getOutgoing(item) {
        return await this.getCallHierarchyItems(item, "outgoing");
      }
      async showCallHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        if (!languages_default.hasProvider("callHierarchy" /* CallHierarchy */, doc.textDocument)) {
          void window_default.showErrorMessage(`CallHierarchy provider not found for current document, it's not supported by your languageserver`);
          return;
        }
        const res = await languages_default.prepareCallHierarchy(doc.textDocument, position, import_node3.CancellationToken.None);
        const rootItems = isCallHierarchyItem(res) ? [res] : res;
        if (isFalsyOrEmpty(rootItems)) {
          void window_default.showWarningMessage("Unable to get CallHierarchyItem at cursor position.");
          return;
        }
        let provider = this.createProvider(rootItems, doc.textDocument, winid, kind);
        let treeView = new BasicTreeView("calls", { treeDataProvider: provider });
        treeView.title = getTitle(kind);
        provider.onDidChangeTreeData((e) => {
          if (!e)
            treeView.title = getTitle(provider.meta);
        });
        treeView.onDidChangeVisibility((e) => {
          if (!e.visible)
            provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
      }
      dispose() {
        this.highlightWinids.clear();
        disposeAll(this.disposables);
      }
    };
    CallHierarchyHandler = _CallHierarchyHandler;
    CallHierarchyHandler.commandId = "callHierarchy.reveal";
    CallHierarchyHandler.rangesHighlight = "CocSelectedRange";
  }
});

// src/handler/codeActions.ts
function shouldAutoApply(only) {
  if (!only)
    return false;
  if (typeof only === "string" || only[0] === CodeActionKind.QuickFix || only[0] === CodeActionKind.SourceFixAll)
    return true;
  return false;
}
var CodeActions;
var init_codeActions = __esm({
  "src/handler/codeActions.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_manager();
    init_languages();
    init_numbers();
    init_window();
    init_workspace();
    CodeActions = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        handler.addDisposable(commands_default.registerCommand("editor.action.organizeImport", async () => {
          let succeed = await this.organizeImport();
          if (!succeed)
            void window_default.showWarningMessage(`Organize import action not found`);
        }));
        commands_default.titles.set("editor.action.organizeImport", "Run organize import code action, show warning when not exists");
      }
      async codeActionRange(start, end, only) {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let line = doc.getline(end - 1);
        let range = Range.create(start - 1, 0, end - 1, line.length);
        let codeActions = await this.getCodeActions(doc, range, only ? [only] : null);
        codeActions = codeActions.filter((o) => !o.disabled);
        if (!codeActions || codeActions.length == 0) {
          void window_default.showWarningMessage(`No${only ? " " + only : ""} code action available`);
          return;
        }
        let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
        let action = codeActions[idx];
        if (action)
          await this.applyCodeAction(action);
      }
      async organizeImport() {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let actions = await this.getCodeActions(doc, void 0, [CodeActionKind.SourceOrganizeImports]);
        if (actions && actions.length) {
          await this.applyCodeAction(actions[0]);
          return true;
        }
        return false;
      }
      async getCodeActions(doc, range, only) {
        range = range ?? Range.create(0, 0, doc.lineCount, 0);
        let diagnostics = manager_default.getDiagnosticsInRange(doc.textDocument, range);
        let context = { diagnostics, triggerKind: CodeActionTriggerKind.Invoked };
        if (only && Array.isArray(only))
          context.only = only;
        let codeActions = await this.handler.withRequestToken("code action", (token) => {
          return languages_default.getCodeActions(doc.textDocument, range, context, token);
        });
        if (!codeActions || codeActions.length == 0)
          return [];
        codeActions.sort((a, b) => {
          if (a.disabled && !b.disabled)
            return 1;
          if (b.disabled && !a.disabled)
            return -1;
          if (a.isPreferred != b.isPreferred)
            return boolToNumber(b.isPreferred) - boolToNumber(a.isPreferred);
          return 0;
        });
        return codeActions;
      }
      get floatActions() {
        if (!workspace_default.floatSupported)
          return false;
        let config = workspace_default.getConfiguration("coc.preferences", null);
        return config.get("floatActions", true);
      }
      async doCodeAction(mode, only, noExclude = false) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode)
          range = await window_default.getSelectedRange(mode);
        await doc.synchronize();
        let codeActions = await this.getCodeActions(doc, range, Array.isArray(only) ? only : null);
        if (typeof only == "string") {
          codeActions = codeActions.filter((o) => o.title == only || o.command && o.command.title == only);
        } else if (Array.isArray(only)) {
          codeActions = codeActions.filter((o) => only.some((k) => o.kind && o.kind.startsWith(k)));
        }
        if (!this.floatActions || !noExclude)
          codeActions = codeActions.filter((o) => !o.disabled);
        if (!codeActions || codeActions.length == 0) {
          void window_default.showWarningMessage(`No${only ? " " + only : ""} code action available`);
          return;
        }
        if (codeActions.length == 1 && !codeActions[0].disabled && shouldAutoApply(only)) {
          await this.applyCodeAction(codeActions[0]);
          return;
        }
        let idx = this.floatActions ? await window_default.showMenuPicker(
          codeActions.map((o) => {
            return { text: o.title, disabled: o.disabled };
          }),
          "Choose action"
        ) : await window_default.showQuickpick(codeActions.map((o) => o.title));
        let action = codeActions[idx];
        if (action)
          await this.applyCodeAction(action);
      }
      async getCurrentCodeActions(mode, only) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode)
          range = await window_default.getSelectedRange(mode);
        let codeActions = await this.getCodeActions(doc, range, only);
        return codeActions.filter((o) => !o.disabled);
      }
      async doQuickfix() {
        let actions = await this.getCurrentCodeActions("currline", [CodeActionKind.QuickFix]);
        if (!actions || actions.length == 0) {
          void window_default.showWarningMessage(`No quickfix action available`);
          return;
        }
        await this.applyCodeAction(actions[0]);
        this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`, true);
      }
      async applyCodeAction(action) {
        if (action.disabled) {
          throw new Error(`Action "${action.title}" is disabled: ${action.disabled.reason}`);
        }
        let resolved = await this.handler.withRequestToken("resolve codeAction", (token) => {
          return languages_default.resolveCodeAction(action, token);
        });
        let { edit: edit2, command } = resolved;
        if (edit2)
          await workspace_default.applyEdit(edit2);
        if (command)
          await commands_default.execute(command);
      }
    };
  }
});

// src/handler/util.ts
function handleError(e) {
  logger47.error(`Error on handler: `, toErrorText(e));
}
var logger47;
var init_util6 = __esm({
  "src/handler/util.ts"() {
    "use strict";
    init_logger();
    init_string();
    logger47 = createLogger("handler-util");
  }
});

// src/handler/codelens/buffer.ts
function getTextAlign(position) {
  if (position == "top")
    return "above" /* Above */;
  if (position == "eol")
    return "after" /* After */;
  if (position === "right_align")
    return "right" /* Right */;
  return "above" /* Above */;
}
function getCommands(line, codeLenses) {
  if (!(codeLenses == null ? void 0 : codeLenses.length))
    return [];
  let commands = [];
  for (let codeLens of codeLenses) {
    let { range, command } = codeLens;
    if (!isCommand(command))
      continue;
    if (line == range.start.line) {
      commands.push(command);
    }
  }
  return commands;
}
var logger48, srcId, debounceTime7, CODELENS_HL, NORMAL_HL, CodeLensBuffer;
var init_buffer3 = __esm({
  "src/handler/codelens/buffer.ts"() {
    "use strict";
    init_commands();
    init_languages();
    init_logger();
    init_util();
    init_array();
    init_is();
    init_node();
    init_protocol();
    init_window();
    init_workspace();
    init_util6();
    logger48 = createLogger("codelens-buffer");
    debounceTime7 = getConditionValue(200, 20);
    CODELENS_HL = "CocCodeLens";
    NORMAL_HL = "Normal";
    CodeLensBuffer = class {
      constructor(nvim, document2) {
        this.nvim = nvim;
        this.document = document2;
        this.display = true;
        this.resolveCodeLens = debounce(() => {
          this._resolveCodeLenses().catch(handleError);
        }, debounceTime7);
        this.debounceFetch = debounce(() => {
          this.fetchCodeLenses().catch(handleError);
        }, debounceTime7);
        if (this.hasProvider)
          this.debounceFetch();
      }
      get config() {
        if (this._config)
          return this._config;
        this.loadConfiguration();
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("codeLens", this.document);
        this._config = {
          enabled: config.get("enable", false),
          position: config.get("position", "top"),
          separator: config.get("separator", ""),
          subseparator: config.get("subseparator", " ")
        };
      }
      async toggleDisplay() {
        if (this.display) {
          this.display = false;
          this.clear();
        } else {
          this.display = true;
          this.resolveCodeLens.clear();
          await this._resolveCodeLenses();
        }
      }
      get bufnr() {
        return this.document.bufnr;
      }
      onChange(e) {
        if (e.contentChanges.length === 0 && this.codeLenses != null) {
          this.resolveCodeLens.clear();
          this._resolveCodeLenses().catch(handleError);
        } else {
          this.cancel();
          this.debounceFetch();
        }
      }
      get currentCodeLens() {
        var _a2;
        return (_a2 = this.codeLenses) == null ? void 0 : _a2.codeLenses;
      }
      get hasProvider() {
        return languages_default.hasProvider("codeLens" /* CodeLens */, this.document);
      }
      async forceFetch() {
        if (!this.config.enabled || !this.hasProvider)
          return;
        await this.document.synchronize();
        this.cancel();
        await this.fetchCodeLenses();
      }
      async fetchCodeLenses() {
        var _a2;
        if (!this.hasProvider || !this.config.enabled)
          return;
        let noFetch = ((_a2 = this.codeLenses) == null ? void 0 : _a2.version) == this.document.version;
        if (!noFetch) {
          let empty = this.codeLenses == null;
          let { textDocument } = this.document;
          let version2 = textDocument.version;
          this.cancelFetch();
          let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
          let token = tokenSource.token;
          if (!srcId)
            srcId = await this.nvim.createNamespace("coc-codelens");
          let codeLenses = await languages_default.getCodeLens(textDocument, token);
          if (token.isCancellationRequested)
            return;
          codeLenses = defaultValue(codeLenses, []);
          codeLenses = codeLenses.filter((o) => o != null);
          if (isFalsyOrEmpty(codeLenses)) {
            this.clear();
            return;
          }
          this.codeLenses = { version: version2, codeLenses };
          if (empty)
            this.setVirtualText(codeLenses);
        }
        this.resolveCodeLens.clear();
        await this._resolveCodeLenses();
      }
      async _resolveCodeLenses() {
        if (!this.codeLenses || this.isChanged)
          return;
        let { codeLenses } = this.codeLenses;
        let [bufnr, start, end, total] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$'),line('$')]`);
        if (this.isChanged || bufnr != this.bufnr)
          return;
        this.cancel();
        codeLenses = codeLenses.filter((o) => {
          let lnum = o.range.start.line + 1;
          return lnum >= start && lnum <= end;
        });
        if (codeLenses.length) {
          let tokenSource = this.resolveTokenSource = new import_node3.CancellationTokenSource();
          let token = tokenSource.token;
          await Promise.all(codeLenses.map((codeLens) => {
            if (isCommand(codeLens.command))
              return Promise.resolve();
            codeLens.command = void 0;
            return languages_default.resolveCodeLens(codeLens, token);
          }));
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested || this.isChanged)
            return;
        }
        if (end == total)
          end = -1;
        this.nvim.pauseNotification();
        this.clear(start - 1, end);
        this.setVirtualText(codeLenses);
        this.nvim.resumeNotification(true, true);
      }
      get isChanged() {
        if (!this.codeLenses || this.document.dirty)
          return true;
        let { version: version2 } = this.codeLenses;
        return this.document.textDocument.version !== version2;
      }
      setVirtualText(codeLenses) {
        let { document: document2 } = this;
        if (!srcId || !document2 || !codeLenses.length || !this.display)
          return;
        let top = this.config.position === "top";
        let list2 = /* @__PURE__ */ new Map();
        for (let codeLens of codeLenses) {
          let { line } = codeLens.range.start;
          let curr = list2.get(line) ?? [];
          curr.push(codeLens);
          list2.set(line, curr);
        }
        for (let lnum of list2.keys()) {
          let codeLenses2 = list2.get(lnum);
          let commands = codeLenses2.reduce((p, c) => {
            if (c && c.command && c.command.title)
              p.push(c.command.title.replace(/\s+/g, " "));
            return p;
          }, []);
          let chunks = [];
          let len = commands.length;
          for (let i = 0; i < len; i++) {
            let title = commands[i];
            chunks.push([title, CODELENS_HL]);
            if (i != len - 1) {
              chunks.push([this.config.subseparator, CODELENS_HL]);
            }
          }
          if (chunks.length > 0 && this.config.separator) {
            chunks.unshift([`${this.config.separator} `, CODELENS_HL]);
          }
          if (top && chunks.length == 0) {
            chunks.push([" ", NORMAL_HL]);
          }
          if (chunks.length > 0) {
            document2.buffer.setVirtualText(srcId, lnum, chunks, {
              text_align: getTextAlign(this.config.position),
              indent: true
            });
          }
        }
      }
      clear(start = 0, end = -1) {
        if (!srcId)
          return;
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.clearNamespace(srcId, start, end);
      }
      async doAction(line) {
        var _a2;
        let commands = getCommands(line, (_a2 = this.codeLenses) == null ? void 0 : _a2.codeLenses);
        if (commands.length == 1) {
          await commands_default.execute(commands[0]);
        } else if (commands.length > 1) {
          let res = await window_default.showMenuPicker(commands.map((c) => c.title));
          if (res != -1)
            await commands_default.execute(commands[res]);
        }
      }
      cancelFetch() {
        this.debounceFetch.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = null;
        }
      }
      cancel() {
        this.resolveCodeLens.clear();
        this.cancelResolve();
        this.cancelFetch();
      }
      abandonResult() {
        this.codeLenses = void 0;
      }
      dispose() {
        this.cancel();
        this.codeLenses = void 0;
      }
    };
  }
});

// src/handler/codelens/index.ts
var debounceTime8, CodeLensManager2;
var init_codelens = __esm({
  "src/handler/codelens/index.ts"() {
    "use strict";
    init_node();
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_protocol();
    init_window();
    init_workspace();
    init_buffer3();
    debounceTime8 = getConditionValue(200, 0);
    CodeLensManager2 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("codeLens")) {
            for (let item of this.buffers.items) {
              item.loadConfiguration();
            }
          }
        }, this, this.disposables);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype != "")
            return void 0;
          return new CodeLensBuffer(nvim, doc);
        });
        this.disposables.push(this.buffers);
        events_default.on("CursorHold", async (bufnr) => {
          let item = this.buffers.getItem(bufnr);
          if (item && item.config.enabled && !item.currentCodeLens)
            await item.forceFetch();
        }, null, this.disposables);
        events_default.on("CursorMoved", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.resolveCodeLens();
        }, null, this.disposables);
        let debounced = debounce(async (selector) => {
          for (let item of this.buffers.items) {
            if (!workspace_default.match(selector, item.document))
              continue;
            item.abandonResult();
            await item.forceFetch();
          }
        }, debounceTime8);
        this.disposables.push(import_node3.Disposable.create(() => {
          debounced.clear();
        }));
        languages_default.onDidCodeLensRefresh(debounced, null, this.disposables);
        commands_default.register({
          id: "document.toggleCodeLens",
          execute: () => {
            return this.toggle(workspace_default.bufnr);
          }
        }, false, "toggle codeLens display of current buffer");
      }
      async toggle(bufnr) {
        let item = this.buffers.getItem(bufnr);
        try {
          workspace_default.getAttachedDocument(bufnr);
          await item.toggleDisplay();
        } catch (e) {
          void window_default.showErrorMessage(e.message);
        }
      }
      async checkProvider() {
        for (let buf of this.buffers.items) {
          await buf.forceFetch();
        }
      }
      async doAction() {
        let [bufnr, line] = await this.nvim.eval(`[bufnr("%"),line(".")-1]`);
        let buf = this.buffers.getItem(bufnr);
        if (buf)
          await buf.doAction(line);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/color.ts
function pad(str) {
  return str.length == 1 ? `0${str}` : str;
}
function toHexString(color) {
  let c = toHexColor(color);
  return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
function toHexColor(color) {
  let { red, green, blue: blue2 } = color;
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255)
  };
}
function isDark(color) {
  let rgb = [color.red, color.green, color.blue];
  let lum = [];
  for (let i = 0; i < rgb.length; i++) {
    let chan = rgb[i];
    lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
  }
  let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  return luma <= 0.5;
}
var init_color = __esm({
  "src/util/color.ts"() {
    "use strict";
  }
});

// src/handler/colors/colorBuffer.ts
function getHighlightGroup2(color) {
  return `BG${toHexString(color)}`;
}
var NAMESPACE2, debounceTime9, ColorBuffer;
var init_colorBuffer = __esm({
  "src/handler/colors/colorBuffer.ts"() {
    "use strict";
    init_languages();
    init_util();
    init_color();
    init_is();
    init_node();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    NAMESPACE2 = "color";
    debounceTime9 = getConditionValue(200, 10);
    ColorBuffer = class {
      constructor(nvim, doc, config, usedColors) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this.usedColors = usedColors;
        this._colors = [];
        this.highlight = debounce(() => {
          void this.doHighlight();
        }, debounceTime9);
        if (this.hasProvider)
          this.highlight();
      }
      get enable() {
        if (boolean(this._enable))
          return this._enable;
        this._enable = workspace_default.getConfiguration("colors", this.doc).get("enable", false);
        return this._enable;
      }
      updateDocumentConfig() {
        let enable = this.enabled;
        this._enable = workspace_default.getConfiguration("colors", this.doc).get("enable", false);
        if (enable != this.enabled) {
          if (enable) {
            this.clearHighlight();
          } else {
            void this.doHighlight();
          }
        }
      }
      toggle() {
        if (this._enable) {
          this._enable = false;
          this.clearHighlight();
        } else {
          this._enable = true;
          void this.doHighlight();
        }
      }
      get hasProvider() {
        return languages_default.hasProvider("documentColor" /* DocumentColor */, this.doc);
      }
      get enabled() {
        let { filetypes } = this.config;
        let { filetype } = this.doc;
        if (!workspace_default.env.updateHighlight || !this.hasProvider)
          return false;
        if (Array.isArray(filetypes) && (filetypes.includes("*") || filetypes.includes(filetype)))
          return true;
        return this.enable;
      }
      onChange() {
        this.cancel();
        this.highlight();
      }
      get buffer() {
        return this.doc.buffer;
      }
      get colors() {
        return this._colors;
      }
      hasColor() {
        return this._colors.length > 0;
      }
      async doHighlight() {
        if (!this.enabled)
          return;
        let { nvim, doc } = this;
        this.tokenSource = new import_node3.CancellationTokenSource();
        let { token } = this.tokenSource;
        let colors;
        colors = await languages_default.provideDocumentColors(doc.textDocument, token);
        if (token.isCancellationRequested)
          return;
        colors = colors || [];
        colors.sort((a, b) => comparePosition(a.range.start, b.range.start));
        this._colors = colors;
        let items = [];
        colors.forEach((o) => {
          let hlGroup = getHighlightGroup2(o.color);
          doc.addHighlights(items, hlGroup, o.range, { combine: false });
        });
        let diff = await window_default.diffHighlights(doc.bufnr, NAMESPACE2, items);
        if (token.isCancellationRequested || !diff)
          return;
        nvim.pauseNotification();
        this.defineColors(colors);
        nvim.resumeNotification(false, true);
        await window_default.applyDiffHighlights(doc.bufnr, NAMESPACE2, this.config.highlightPriority, diff, true);
      }
      defineColors(colors) {
        for (let color of colors) {
          let hex = toHexString(color.color);
          if (!this.usedColors.has(hex)) {
            this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color.color) ? "ffffff" : "000000"}`, true);
            this.usedColors.add(hex);
          }
        }
      }
      hasColorAtPosition(position) {
        return this.colors.some((o) => positionInRange(position, o.range) == 0);
      }
      clearHighlight() {
        this.highlight.clear();
        this._colors = [];
        this.buffer.clearNamespace("color");
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this._colors = [];
        this.highlight.clear();
        this.cancel();
      }
    };
  }
});

// src/handler/colors/index.ts
var Colors;
var init_colors = __esm({
  "src/handler/colors/index.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_color();
    init_protocol();
    init_window();
    init_workspace();
    init_colorBuffer();
    Colors = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        let usedColors = /* @__PURE__ */ new Set();
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          return new ColorBuffer(this.nvim, doc, this.config, usedColors);
        });
        events_default.on("ColorScheme", () => {
          usedColors.clear();
          for (let item of this.highlighters.items) {
            item.cancel();
            void item.doHighlight();
          }
        }, null, this.disposables);
        languages_default.onDidColorsRefresh((selector) => {
          for (let item of this.highlighters.items) {
            if (workspace_default.match(selector, item.doc)) {
              item.highlight();
            }
          }
        });
        commands_default.register({
          id: "editor.action.pickColor",
          execute: async () => {
            await this.pickColor();
          }
        }, false, "pick color from system color picker when possible.");
        commands_default.register({
          id: "editor.action.colorPresentation",
          execute: async () => {
            await this.pickPresentation();
          }
        }, false, "change color presentation.");
        commands_default.register({
          id: "document.toggleColors",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", ["%"]);
            let item = this.highlighters.getItem(bufnr);
            workspace_default.getAttachedDocument(bufnr);
            item.toggle();
          }
        }, false, "toggle colors for current buffer");
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("colors")) {
          let c = workspace_default.initialConfiguration.get("colors");
          this.config = Object.assign(this.config ?? {}, {
            filetypes: c.filetypes,
            highlightPriority: defaultValue(c.highlightPriority, 1e3)
          });
          if (e) {
            for (let item of this.highlighters.items) {
              item.updateDocumentConfig();
            }
          }
        }
      }
      async pickPresentation() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentColor" /* DocumentColor */, doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info)
          return void window_default.showWarningMessage("Color not found at current position");
        let tokenSource = new import_node3.CancellationTokenSource();
        let presentations = await languages_default.provideColorPresentations(info, doc.textDocument, tokenSource.token);
        if (!(presentations == null ? void 0 : presentations.length))
          return void window_default.showWarningMessage("No color presentations found");
        let res = await window_default.showMenuPicker(presentations.map((o) => o.label), "Choose color:");
        if (res == -1)
          return;
        let presentation = presentations[res];
        let { textEdit, additionalTextEdits, label } = presentation;
        if (!textEdit)
          textEdit = { range: info.range, newText: label };
        await doc.applyEdits([textEdit]);
        if (additionalTextEdits)
          await doc.applyEdits(additionalTextEdits);
      }
      async pickColor() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentColor" /* DocumentColor */, doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info)
          return void window_default.showWarningMessage("Color not found at current position");
        let { color } = info;
        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
        let res = await this.nvim.call("coc#color#pick_color", [colorArr]);
        if (!res)
          return;
        let hex = toHexString({
          red: res[0] / 65535,
          green: res[1] / 65535,
          blue: res[2] / 65535,
          alpha: 1
        });
        await doc.applyEdits([{
          range: info.range,
          newText: `#${hex}`
        }]);
      }
      isEnabled(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        return highlighter != null && highlighter.enabled === true;
      }
      clearHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter)
          highlighter.clearHighlight();
      }
      hasColor(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return false;
        return highlighter.hasColor();
      }
      hasColorAtPosition(bufnr, position) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return false;
        return highlighter.hasColorAtPosition(position);
      }
      highlightAll() {
        for (let buf of this.highlighters.items) {
          buf.highlight();
        }
      }
      async doHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter)
          await highlighter.doHighlight();
      }
      async getColorInformation(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return null;
        let position = await window_default.getCursorPosition();
        for (let info of highlighter.colors) {
          let { range } = info;
          let { start, end } = range;
          if (position.line == start.line && position.character >= start.character && position.character <= end.character) {
            return info;
          }
        }
        return null;
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/commands.ts
function validCommand(command) {
  return command && string(command.id) && string(command.cmd) && command.id.length > 0 && command.cmd.length > 0;
}
var Commands;
var init_commands3 = __esm({
  "src/handler/commands.ts"() {
    "use strict";
    init_commands();
    init_manager3();
    init_workspace();
    init_is();
    Commands = class {
      constructor(nvim) {
        this.nvim = nvim;
        for (let item of workspace_default.env.vimCommands) {
          this.addVimCommand(item);
        }
      }
      addVimCommand(cmd) {
        if (!validCommand(cmd))
          return;
        let id = `vim.${cmd.id}`;
        commands_default.registerCommand(id, () => {
          this.nvim.command(cmd.cmd, true);
          this.nvim.redrawVim();
        });
        if (cmd.title)
          commands_default.titles.set(id, cmd.title);
      }
      getCommandList() {
        return commands_default.commandList.map((o) => o.id);
      }
      async repeat() {
        await commands_default.repeatCommand();
      }
      async runCommand(id, ...args) {
        if (id)
          return await commands_default.fireCommand(id, ...args);
        await manager_default2.start(["commands"]);
      }
    };
  }
});

// src/handler/fold.ts
var FoldHandler;
var init_fold = __esm({
  "src/handler/fold.ts"() {
    "use strict";
    init_languages();
    FoldHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async fold(kind) {
        let { doc, winid } = await this.handler.getCurrentState();
        this.handler.checkProvider("foldingRange" /* FoldingRange */, doc.textDocument);
        await doc.synchronize();
        let win = this.nvim.createWindow(winid);
        let foldlevel = await this.nvim.eval("&foldlevel");
        let ranges = await this.handler.withRequestToken("foldingrange", (token) => {
          return languages_default.provideFoldingRanges(doc.textDocument, {}, token);
        }, true);
        if (!ranges || !ranges.length)
          return false;
        if (kind)
          ranges = ranges.filter((o) => o.kind == kind);
        ranges.sort((a, b) => b.startLine - a.startLine);
        this.nvim.pauseNotification();
        win.setOption("foldmethod", "manual", true);
        this.nvim.command("normal! zE", true);
        for (let range of ranges) {
          let { startLine, endLine } = range;
          let cmd = `${startLine + 1}, ${endLine + 1}fold`;
          this.nvim.command(cmd, true);
        }
        win.setOption("foldenable", true, true);
        win.setOption("foldlevel", foldlevel, true);
        await this.nvim.resumeNotification(true);
        return true;
      }
    };
  }
});

// src/handler/format.ts
var logger49, FormatHandler;
var init_format2 = __esm({
  "src/handler/format.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_logger();
    init_manager4();
    init_array();
    init_util();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    logger49 = createLogger("handler-format");
    FormatHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.setConfiguration();
        handler.addDisposable(workspace_default.onDidChangeConfiguration(this.setConfiguration, this));
        handler.addDisposable(window_default.onDidChangeActiveTextEditor(() => {
          this.setConfiguration();
        }));
        handler.addDisposable(workspace_default.onWillSaveTextDocument((event) => {
          if (this.shouldFormatOnSave(event.document)) {
            let willSaveWaitUntil = async () => {
              if (!languages_default.hasFormatProvider(event.document)) {
                logger49.warn(`Format provider not found for ${event.document.uri}`);
                return void 0;
              }
              let options2 = await workspace_default.getFormatOptions(event.document.uri);
              let tokenSource = new import_node3.CancellationTokenSource();
              let timer;
              const tp = new Promise((c) => {
                timer = setTimeout(() => {
                  logger49.warn(`Format on save ${event.document.uri} timeout after 0.5s`);
                  tokenSource.cancel();
                  c(void 0);
                }, 500);
              });
              const provideEdits = languages_default.provideDocumentFormattingEdits(event.document, options2, tokenSource.token);
              let textEdits = await Promise.race([tp, provideEdits]);
              clearTimeout(timer);
              return Array.isArray(textEdits) ? textEdits : void 0;
            };
            event.waitUntil(willSaveWaitUntil());
          }
        }));
        handler.addDisposable(events_default.on("Enter", async (bufnr) => {
          let res = await events_default.race(["CursorMovedI"], 100);
          if (res.args && res.args[0] === bufnr) {
            await this.handleEnter(bufnr);
          }
        }));
        handler.addDisposable(events_default.on("TextInsert", async (bufnr, _info, character) => {
          if (!events_default.pumvisible)
            await this.tryFormatOnType(character, bufnr);
        }));
        handler.addDisposable(commands_default.registerCommand("editor.action.formatDocument", async (uri) => {
          const doc = uri ? workspace_default.getDocument(uri) : (await this.handler.getCurrentState()).doc;
          await this.documentFormat(doc);
        }));
        commands_default.titles.set("editor.action.formatDocument", "Format Document");
      }
      shouldFormatOnSave(doc) {
        let { languageId, uri } = doc;
        let config = workspace_default.getConfiguration("coc.preferences", { uri, languageId });
        let filetypes = config.get("formatOnSaveFiletypes", null);
        let formatOnSave = config.get("formatOnSave", false);
        if (Array.isArray(filetypes))
          return filetypes.includes("*") || filetypes.includes(languageId);
        return formatOnSave;
      }
      setConfiguration(e) {
        var _a2;
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let doc = (_a2 = window_default.activeTextEditor) == null ? void 0 : _a2.document;
          let config = workspace_default.getConfiguration("coc.preferences", doc);
          this.preferences = {
            formatOnType: config.get("formatOnType", false),
            formatOnTypeFiletypes: config.get("formatOnTypeFiletypes", null),
            bracketEnterImprove: config.get("bracketEnterImprove", true)
          };
        }
      }
      shouldFormatOnType(filetype) {
        const filetypes = this.preferences.formatOnTypeFiletypes;
        return isFalsyOrEmpty(filetype) || filetypes.includes(filetype) || filetypes.includes("*");
      }
      async tryFormatOnType(ch, bufnr, newLine = false) {
        if (!ch || isAlphabet(ch.charCodeAt(0)) || !this.preferences.formatOnType)
          return;
        if (manager_default3.getSession(bufnr) != null)
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || !this.shouldFormatOnType(doc.filetype))
          return;
        if (!languages_default.hasProvider("formatOnType" /* FormatOnType */, doc.textDocument)) {
          logger49.warn(`Format on type provider not found for buffer: ${doc.uri}`);
          return;
        }
        if (!languages_default.canFormatOnType(ch, doc.textDocument))
          return;
        let position;
        let edits = await this.handler.withRequestToken("Format on type", async (token) => {
          position = await window_default.getCursorPosition();
          let origLine = doc.getline(position.line - 1);
          if (newLine && /^\s*$/.test(origLine))
            return;
          await doc.synchronize();
          return await languages_default.provideDocumentOnTypeEdits(ch, doc.textDocument, position, token);
        });
        if (isFalsyOrEmpty(edits))
          return;
        await doc.applyEdits(edits, false, true);
      }
      async formatCurrentBuffer() {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentFormat(doc);
      }
      async formatCurrentRange(mode) {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentRangeFormat(doc, mode);
      }
      async documentFormat(doc) {
        await doc.synchronize();
        if (!languages_default.hasFormatProvider(doc.textDocument)) {
          throw new Error(`Format provider not found for buffer: ${doc.bufnr}`);
        }
        let options2 = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken("format", (token) => {
          return languages_default.provideDocumentFormattingEdits(doc.textDocument, options2, token);
        });
        if (textEdits && textEdits.length > 0) {
          await doc.applyEdits(textEdits, false, true);
          return true;
        }
        return false;
      }
      async handleEnter(bufnr) {
        let { nvim } = this;
        let { bracketEnterImprove } = this.preferences;
        await this.tryFormatOnType("\n", bufnr);
        if (bracketEnterImprove) {
          let line = await nvim.call("line", ".") - 1;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc)
            return;
          await doc.patchChange();
          let pre = doc.getline(line - 1);
          let curr = doc.getline(line);
          let prevChar = pre[pre.length - 1];
          if (prevChar && pariedCharacters.has(prevChar)) {
            let nextChar = curr.trim()[0];
            if (nextChar && pariedCharacters.get(prevChar) == nextChar) {
              let edits = [];
              let opts = await workspace_default.getFormatOptions(doc.uri);
              let space = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
              let currIndent = curr.match(/^\s*/)[0];
              let pos = Position.create(line - 1, pre.length);
              if (doc.filetype == "vim") {
                let newText = "\n" + currIndent + space;
                edits.push({ range: Range.create(line, currIndent.length, line, currIndent.length), newText: "  \\ " });
                newText = newText + "\\ ";
                edits.push({ range: Range.create(pos, pos), newText });
                await doc.applyEdits(edits);
                await window_default.moveTo(Position.create(line, newText.length - 1));
              } else {
                await nvim.eval(`feedkeys("\\<Esc>O", 'in')`);
              }
            }
          }
        }
      }
      async documentRangeFormat(doc, mode) {
        this.handler.checkProvider("formatRange" /* FormatRange */, doc.textDocument);
        await doc.synchronize();
        let range;
        if (mode) {
          range = await window_default.getSelectedRange(mode);
          if (!range)
            return -1;
        } else {
          let [lnum, count, mode2] = await this.nvim.eval("[v:lnum,v:count,mode()]");
          if (count == 0 || mode2 == "i" || mode2 == "R")
            return -1;
          range = Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options2 = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken("Format range", (token) => {
          return languages_default.provideDocumentRangeFormattingEdits(doc.textDocument, range, options2, token);
        });
        if (!isFalsyOrEmpty(textEdits)) {
          await doc.applyEdits(textEdits, false, true);
          return 0;
        }
        return -1;
      }
    };
  }
});

// src/handler/highlights.ts
var Highlights2;
var init_highlights2 = __esm({
  "src/handler/highlights.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    Highlights2 = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlights = /* @__PURE__ */ new Map();
        events_default.on(["CursorMoved", "CursorMovedI"], () => {
          this.cancel();
          this.clearHighlights();
        }, null, this.disposables);
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        window_default.onDidChangeActiveTextEditor(() => {
          this.loadConfiguration();
        }, null, this.disposables);
        commands_default.register({
          id: "document.jumpToNextSymbol",
          execute: async () => {
            await this.jumpSymbol("next");
          }
        }, false, "Jump to next symbol highlight position.");
        commands_default.register({
          id: "document.jumpToPrevSymbol",
          execute: async () => {
            await this.jumpSymbol("previous");
          }
        }, false, "Jump to previous symbol highlight position.");
      }
      loadConfiguration(e) {
        let config = workspace_default.getConfiguration("documentHighlight", this.handler.uri);
        if (!e || e.affectsConfiguration("documentHighlight")) {
          this.config = Object.assign(this.config || {}, {
            priority: config.get("priority", -1),
            timeout: config.get("timeout", 300)
          });
        }
      }
      isEnabled(bufnr, cursors) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || cursors)
          return false;
        if (!languages_default.hasProvider("documentHighlight" /* DocumentHighlight */, doc.textDocument))
          return false;
        return true;
      }
      clearHighlights() {
        if (this.highlights.size == 0)
          return;
        for (let winid of this.highlights.keys()) {
          let win = this.nvim.createWindow(winid);
          win.clearMatchGroup("^CocHighlight");
        }
        this.highlights.clear();
      }
      async highlight() {
        let { nvim } = this;
        this.cancel();
        let [bufnr, winid, pos, cursors] = await nvim.eval(`[bufnr("%"),win_getid(),coc#cursor#position(),get(b:,'coc_cursors_activated',0)]`);
        if (!this.isEnabled(bufnr, cursors))
          return;
        let doc = workspace_default.getDocument(bufnr);
        let highlights = await this.getHighlights(doc, Position.create(pos[0], pos[1]));
        if (!highlights)
          return;
        let groups = {};
        for (let hl of highlights) {
          if (!hl.range)
            continue;
          let hlGroup = hl.kind == DocumentHighlightKind.Text ? "CocHighlightText" : hl.kind == DocumentHighlightKind.Read ? "CocHighlightRead" : "CocHighlightWrite";
          groups[hlGroup] = groups[hlGroup] || [];
          groups[hlGroup].push(hl.range);
        }
        let win = nvim.createWindow(winid);
        nvim.pauseNotification();
        win.clearMatchGroup("^CocHighlight");
        for (let hlGroup of Object.keys(groups)) {
          win.highlightRanges(hlGroup, groups[hlGroup], this.config.priority, true);
        }
        nvim.resumeNotification(true, true);
        this.highlights.set(winid, highlights);
      }
      async jumpSymbol(direction) {
        let ranges = await this.getSymbolsRanges();
        if (!ranges)
          return;
        let pos = await window_default.getCursorPosition();
        if (direction == "next") {
          for (let i = 0; i <= ranges.length - 1; i++) {
            if (comparePosition(ranges[i].start, pos) > 0) {
              await window_default.moveTo(ranges[i].start);
              return;
            }
          }
          await window_default.moveTo(ranges[0].start);
        } else {
          for (let i = ranges.length - 1; i >= 0; i--) {
            if (comparePosition(ranges[i].end, pos) < 0) {
              await window_default.moveTo(ranges[i].start);
              return;
            }
          }
          await window_default.moveTo(ranges[ranges.length - 1].start);
        }
      }
      async getSymbolsRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentHighlight" /* DocumentHighlight */, doc.textDocument);
        let highlights = await this.getHighlights(doc, position);
        if (!highlights)
          return null;
        return highlights.map((o) => o.range).sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
      }
      hasHighlights(winid) {
        return this.highlights.get(winid) != null;
      }
      async getHighlights(doc, position) {
        let line = doc.getline(position.line);
        let ch = line[position.character];
        if (!ch || !doc.isWord(ch))
          return null;
        await doc.synchronize();
        this.cancel();
        let source = this.tokenSource = new import_node3.CancellationTokenSource();
        let timer = this.timer = setTimeout(() => {
          if (source.token.isCancellationRequested)
            return;
          source.cancel();
        }, this.config.timeout);
        let highlights = await languages_default.getDocumentHighLight(doc.textDocument, position, source.token);
        clearTimeout(timer);
        if (source.token.isCancellationRequested)
          return null;
        return highlights;
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        if (this.timer)
          clearTimeout(this.timer);
        this.cancel();
        this.highlights.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/hover.ts
async function addDefinitions(hovers, definitions, filetype) {
  for (const def of definitions) {
    if (!(def == null ? void 0 : def.targetRange))
      continue;
    const { start, end } = def.targetRange;
    const endLine = end.line - start.line >= 100 ? start.line + 100 : end.character == 0 ? end.line - 1 : end.line;
    let lines = await readLines(def.targetUri, start.line, endLine);
    if (lines.length) {
      let indent = lines[0].match(/^\s*/)[0];
      if (indent)
        lines = lines.map((l) => l.startsWith(indent) ? l.substring(indent.length) : l);
      hovers.push({ content: lines.join("\n"), filetype });
    }
  }
}
function addDocument(docs, text, filetype, isPreview = false) {
  let content = text.trim();
  if (!content.length)
    return;
  if (isPreview && filetype !== "markdown") {
    content = "``` " + filetype + "\n" + content + "\n```";
  }
  docs.push({ content, filetype });
}
function isDocumentation(obj) {
  if (!obj)
    return false;
  return typeof obj.filetype === "string" && typeof obj.content === "string";
}
async function readLines(uri, start, end) {
  let doc = workspace_default.getDocument(uri);
  if (doc)
    return doc.getLines(start, end + 1);
  let fsPath2 = URI.parse(uri).fsPath;
  if (!fs.existsSync(fsPath2))
    return [];
  return await readFileLines(fsPath2, start, end);
}
var highlightDelay, HoverHandler;
var init_hover2 = __esm({
  "src/handler/hover.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_util();
    init_array();
    init_fs();
    init_is();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    highlightDelay = getConditionValue(500, 10);
    HoverHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.documentLines = [];
        this.hasProvider = false;
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.hoverFactory = window_default.createFloatFactory({
          modes: ["n"],
          autoHide: this.config.autoHide
        });
        this.disposables.push(this.hoverFactory);
        window_default.onDidChangeActiveTextEditor(() => {
          this.loadConfiguration();
        }, null, this.disposables);
      }
      registerProvider() {
        if (this.hasProvider)
          return;
        this.hasProvider = true;
        let { nvim } = this;
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async () => {
            nvim.pauseNotification();
            nvim.command("setlocal conceallevel=2 nospell nofoldenable wrap", true);
            nvim.command("setlocal bufhidden=wipe nobuflisted", true);
            nvim.command("setfiletype markdown", true);
            nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.config.previewMaxHeight)}\\<cr>" | endif`, true);
            await nvim.resumeNotification();
            return this.documentLines.join("\n");
          }
        };
        this.disposables.push(workspace_default.registerTextDocumentContentProvider("coc", provider));
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("hover")) {
          let config = workspace_default.getConfiguration("hover", this.handler.uri);
          this.config = {
            floatConfig: config.get("floatConfig", {}),
            autoHide: config.get("autoHide", true),
            target: config.get("target", "float"),
            previewMaxHeight: config.get("previewMaxHeight", 12)
          };
          if (this.config.target == "preview") {
            this.registerProvider();
          }
        }
      }
      async onHover(hoverTarget) {
        let { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == "preview")
          this.registerProvider();
        this.handler.checkProvider("hover" /* Hover */, doc.textDocument);
        await doc.synchronize();
        let hovers = await this.handler.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (hovers == null || !hovers.length)
          return false;
        let hover = hovers.find((o) => Range.is(o.range));
        if (hover == null ? void 0 : hover.range) {
          let win = this.nvim.createWindow(winid);
          win.highlightRanges("CocHoverRange", [hover.range], 99, true);
          this.timer = setTimeout(() => {
            win.clearMatchGroup("CocHoverRange");
            this.nvim.redrawVim();
          }, 500);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async definitionHover(hoverTarget) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == "preview")
          this.registerProvider();
        this.handler.checkProvider("hover" /* Hover */, doc.textDocument);
        await doc.synchronize();
        const hovers = await this.handler.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (isFalsyOrEmpty(hovers))
          return false;
        const defs = await this.handler.withRequestToken("definitionHover", (token) => {
          return languages_default.getDefinitionLinks(doc.textDocument, position, token);
        }, false);
        await addDefinitions(hovers, defs, doc.filetype);
        let hover = hovers.find((o) => Hover.is(o) && Range.is(o.range));
        if (hover) {
          let win = this.nvim.createWindow(winid);
          win.highlightRanges("CocHoverRange", [hover.range], 99, true);
          this.timer = setTimeout(() => {
            win.clearMatchGroup("CocHoverRange");
            this.nvim.redrawVim();
          }, highlightDelay);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async previewHover(hovers, target) {
        let docs = [];
        target = target ?? this.config.target;
        let isPreview = target === "preview";
        for (let hover of hovers) {
          if (isDocumentation(hover)) {
            docs.push(hover);
            continue;
          }
          let { contents } = hover;
          if (Array.isArray(contents)) {
            for (let item of contents) {
              if (typeof item === "string") {
                addDocument(docs, item, "markdown", isPreview);
              } else {
                addDocument(docs, item.value, item.language, isPreview);
              }
            }
          } else if (MarkedString.is(contents)) {
            if (typeof contents == "string") {
              addDocument(docs, contents, "markdown", isPreview);
            } else {
              addDocument(docs, contents.value, contents.language, isPreview);
            }
          } else if (MarkupContent.is(contents)) {
            addDocument(docs, contents.value, isMarkdown(contents) ? "markdown" : "txt", isPreview);
          }
        }
        if (target == "float") {
          await this.hoverFactory.show(docs, this.config.floatConfig);
          return;
        }
        let lines = docs.reduce((p, c) => {
          let arr = c.content.split(/\r?\n/);
          if (p.length > 0)
            p.push("");
          p.push(...arr);
          return p;
        }, []);
        if (target == "echo") {
          const msg = lines.join("\n").trim();
          await this.nvim.call("coc#ui#echo_hover", [msg]);
        } else {
          this.documentLines = lines;
          await this.nvim.command(`noswapfile pedit coc://document`);
        }
      }
      async getHover(loc) {
        let result = [];
        let doc;
        let position;
        if (!loc) {
          let state = await this.handler.getCurrentState();
          doc = state.doc;
          position = state.position;
        } else {
          doc = loc.bufnr ? workspace_default.getAttachedDocument(loc.bufnr) : await workspace_default.document;
          let line = doc.getline(loc.line - 1);
          let character = characterIndex(line, loc.col - 1);
          position = Position.create(loc.line - 1, character);
        }
        this.handler.checkProvider("hover" /* Hover */, doc.textDocument);
        await doc.synchronize();
        let tokenSource = new import_node3.CancellationTokenSource();
        let hovers = await languages_default.getHover(doc.textDocument, position, tokenSource.token);
        for (let h of hovers) {
          let { contents } = h;
          if (Array.isArray(contents)) {
            contents.forEach((c) => {
              result.push(typeof c === "string" ? c : c.value);
            });
          } else if (MarkupContent.is(contents)) {
            result.push(contents.value);
          } else {
            result.push(typeof contents === "string" ? contents : contents.value);
          }
        }
        result = result.filter((s) => s != null && s.length > 0);
        return result;
      }
      dispose() {
        if (this.timer)
          clearTimeout(this.timer);
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/regions.ts
var Regions;
var init_regions = __esm({
  "src/model/regions.ts"() {
    "use strict";
    Regions = class {
      constructor() {
        this.ranges = [];
      }
      get current() {
        let res = [];
        this.ranges.sort((a, b) => a[0] - b[0]);
        this.ranges.forEach((o) => {
          res.push(o[0], o[1]);
        });
        return res;
      }
      clear() {
        this.ranges = [];
      }
      add(start, end) {
        if (start > end) {
          [start, end] = [end, start];
        }
        let { ranges } = this;
        if (ranges.length == 0) {
          ranges.push([start, end]);
        } else {
          ranges.sort((a, b) => a[0] - b[0]);
          let s;
          let e;
          let removedIndexes = [];
          for (let i = 0; i < ranges.length; i++) {
            let r = ranges[i];
            if (r[1] < start || r[0] > end)
              continue;
            removedIndexes.push(i);
            if (s == null)
              s = Math.min(start, r[0]);
            e = Math.max(end, r[1]);
          }
          let newRanges = removedIndexes.length ? ranges.filter((_, i) => !removedIndexes.includes(i)) : ranges;
          this.ranges = newRanges;
          if (s != null && e != null) {
            this.ranges.push([s, e]);
          } else {
            this.ranges.push([start, end]);
          }
        }
      }
      has(start, end) {
        let idx = this.ranges.findIndex((o) => o[0] <= start && o[1] >= end);
        return idx !== -1;
      }
      static mergeSpans(ranges) {
        let res = [];
        for (let r of ranges) {
          let idx = res.findIndex((o) => !(r[1] < o[0] || r[0] > o[1]));
          if (idx == -1) {
            res.push(r);
          } else {
            let o = res[idx];
            res[idx] = [Math.min(r[0], o[0]), Math.max(r[1], o[1])];
          }
        }
        return res;
      }
    };
  }
});

// src/handler/inlayHint/buffer.ts
function getHighlightGroup3(kind) {
  switch (kind) {
    case InlayHintKind.Parameter:
      return "CocInlayHintParameter";
    case InlayHintKind.Type:
      return "CocInlayHintType";
    default:
      return "CocInlayHint";
  }
}
var srcId2, debounceInterval, requestDelay, InlayHintBuffer;
var init_buffer4 = __esm({
  "src/handler/inlayHint/buffer.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_regions();
    init_inlayHintManager();
    init_util();
    init_errors();
    init_position();
    init_protocol();
    init_string();
    init_workspace();
    debounceInterval = getConditionValue(100, 10);
    requestDelay = getConditionValue(500, 10);
    InlayHintBuffer = class {
      constructor(nvim, doc) {
        this.nvim = nvim;
        this.doc = doc;
        this.regions = new Regions();
        this.currentHints = [];
        this._onDidRefresh = new import_node3.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.render = delay(() => {
          void this.renderRange();
        }, debounceInterval);
        if (this.hasProvider)
          this.render();
      }
      get config() {
        if (this._config)
          return this._config;
        this.loadConfiguration();
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("inlayHint", this.doc);
        let changed = this._config && this._config.enable != config.enable;
        this._config = {
          enable: config.get("enable"),
          display: config.get("display", true),
          filetypes: config.get("filetypes"),
          refreshOnInsertMode: config.get("refreshOnInsertMode"),
          enableParameter: config.get("enableParameter"),
          typeSeparator: config.get("typeSeparator", ""),
          parameterSeparator: config.get("parameterSeparator", ""),
          subSeparator: config.get("subSeparator", " ")
        };
        if (changed) {
          let { enable, display } = this._config;
          if (enable) {
            this.clearCache();
            this.clearVirtualText();
          } else if (display) {
            void this.renderRange();
          }
        }
      }
      onInsertLeave() {
        if (this.config.refreshOnInsertMode)
          return;
        this.render();
      }
      onInsertEnter() {
        if (this.config.refreshOnInsertMode)
          return;
        this.cancel();
      }
      get current() {
        return this.currentHints;
      }
      get enabled() {
        if (!this.config.display || !this.configEnabled)
          return false;
        return this.hasProvider;
      }
      get hasProvider() {
        return languages_default.hasProvider("inlayHint" /* InlayHint */, this.doc);
      }
      get configEnabled() {
        let { filetypes, enable } = this.config;
        if (Array.isArray(filetypes))
          return filetypes.includes("*") || filetypes.includes(this.doc.filetype);
        return enable === true;
      }
      toggle() {
        if (!languages_default.hasProvider("inlayHint" /* InlayHint */, this.doc.textDocument))
          throw new Error("Inlay hint provider not found for current document");
        if (!this.configEnabled)
          throw new Error(`Filetype "${this.doc.filetype}" not enabled by inlayHint configuration`);
        if (this.config.display) {
          this.config.display = false;
          this.clearCache();
          this.clearVirtualText();
        } else {
          this.config.display = true;
          void this.renderRange();
        }
      }
      clearCache() {
        this.currentHints = [];
        this.regions.clear();
        this.render.clear();
      }
      onTextChange() {
        this.clearCache();
        this.cancel();
      }
      onChange() {
        this.cancel();
        this.render();
      }
      cancel() {
        this.render.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      async requestInlayHints(range, token) {
        try {
          return await languages_default.provideInlayHints(this.doc.textDocument, range, token);
        } catch (e) {
          if (!token.isCancellationRequested && e instanceof CancellationError) {
            this.render(requestDelay);
          }
        }
      }
      async renderRange() {
        this.cancel();
        if (events_default.insertMode && !this.config.refreshOnInsertMode || !this.enabled)
          return;
        this.tokenSource = new import_node3.CancellationTokenSource();
        let token = this.tokenSource.token;
        let res = await this.nvim.call("coc#window#visible_range", [this.doc.bufnr]);
        if (!Array.isArray(res) || res[1] <= 0 || token.isCancellationRequested)
          return;
        if (!srcId2)
          srcId2 = await this.nvim.createNamespace("coc-inlayHint");
        if (token.isCancellationRequested || this.regions.has(res[0], res[1]))
          return;
        let range = Range.create(res[0] - 1, 0, res[1], 0);
        let inlayHints = await this.requestInlayHints(range, token);
        if (inlayHints == null || token.isCancellationRequested)
          return;
        this.regions.add(res[0], res[1]);
        if (!this.config.enableParameter) {
          inlayHints = inlayHints.filter((o) => o.kind !== InlayHintKind.Parameter);
        }
        this.currentHints = this.currentHints.filter((o) => positionInRange(o.position, range) !== 0);
        this.currentHints.push(...inlayHints);
        this.setVirtualText(range, inlayHints, workspace_default.env.isVim);
      }
      setVirtualText(range, inlayHints, isVim2) {
        let { nvim, doc } = this;
        let buffer = doc.buffer;
        let { subSeparator, parameterSeparator, typeSeparator } = this.config;
        const chunksMap = /* @__PURE__ */ new Map();
        if (!isVim2) {
          for (const item of inlayHints) {
            let { line } = item.position;
            const chunks = chunksMap.get(line) ?? [];
            if (chunks.length > 0) {
              chunks.push([subSeparator, subSeparator === " " ? "Normal" : getHighlightGroup3(item.kind)]);
            }
            let sep = item.kind === InlayHintKind.Parameter ? parameterSeparator : typeSeparator;
            chunks.push([sep + getLabel(item), getHighlightGroup3(item.kind)]);
            chunksMap.set(line, chunks);
          }
        }
        nvim.pauseNotification();
        buffer.clearNamespace(srcId2, range.start.line, range.end.line + 1);
        if (isVim2) {
          for (const item of inlayHints) {
            const chunks = [];
            let { position } = item;
            let line = this.doc.getline(position.line);
            let col = byteIndex(line, position.character) + 1;
            if (item.paddingLeft) {
              chunks.push([" ", "Normal"]);
            }
            chunks.push([getLabel(item), getHighlightGroup3(item.kind)]);
            if (item.paddingRight) {
              chunks.push([" ", "Normal"]);
            }
            buffer.setVirtualText(srcId2, position.line, chunks, { col });
          }
        } else {
          for (let [line, chunks] of chunksMap.entries()) {
            buffer.setExtMark(srcId2, line, 0, {
              virt_text: chunks,
              virt_text_pos: "eol",
              hl_mode: "combine"
            });
          }
        }
        nvim.resumeNotification(true, true);
        this._onDidRefresh.fire();
      }
      clearVirtualText() {
        if (srcId2)
          this.doc.buffer.clearNamespace(srcId2);
      }
      dispose() {
        this.cancel();
      }
    };
  }
});

// src/handler/inlayHint/index.ts
var InlayHintHandler;
var init_inlayHint2 = __esm({
  "src/handler/inlayHint/index.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_protocol();
    init_window();
    init_workspace();
    init_buffer4();
    InlayHintHandler = class {
      constructor(nvim, handler) {
        this.disposables = [];
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (!workspace_default.env.virtualText)
            return;
          return new InlayHintBuffer(nvim, doc);
        });
        this.disposables.push(this.buffers);
        workspace_default.onDidChangeConfiguration((e) => {
          for (let item of this.buffers.items) {
            if (e.affectsConfiguration("inlayHint", item.doc)) {
              item.loadConfiguration();
            }
          }
        }, null, this.disposables);
        languages_default.onDidInlayHintRefresh(async (e) => {
          for (let item of this.buffers.items) {
            if (workspace_default.match(e, item.doc.textDocument)) {
              item.clearCache();
              if (languages_default.hasProvider("inlayHint" /* InlayHint */, item.doc.textDocument)) {
                item.render();
              } else {
                item.clearVirtualText();
              }
            }
          }
        }, null, this.disposables);
        events_default.on("InsertLeave", (bufnr) => {
          let item = this.buffers.getItem(bufnr);
          if (item)
            item.onInsertLeave();
        }, null, this.disposables);
        events_default.on("InsertEnter", (bufnr) => {
          let item = this.buffers.getItem(bufnr);
          if (item)
            item.onInsertEnter();
        }, null, this.disposables);
        events_default.on("CursorMoved", (bufnr) => {
          this.refresh(bufnr);
        }, null, this.disposables);
        events_default.on("WinScrolled", async (winid) => {
          let bufnr = await nvim.call("winbufnr", [winid]);
          if (bufnr != -1)
            this.refresh(bufnr);
        }, null, this.disposables);
        commands_default.register({
          id: "document.toggleInlayHint",
          execute: (bufnr) => {
            return this.toggle(bufnr ?? workspace_default.bufnr);
          }
        }, false, "toggle codeLens display of current buffer");
        handler.addDisposable(import_node3.Disposable.create(() => {
          disposeAll(this.disposables);
        }));
      }
      toggle(bufnr) {
        let item = this.getItem(bufnr);
        try {
          workspace_default.getAttachedDocument(bufnr);
          item.toggle();
        } catch (e) {
          void window_default.showErrorMessage(e.message);
        }
      }
      getItem(bufnr) {
        return this.buffers.getItem(bufnr);
      }
      refresh(bufnr) {
        let buf = this.buffers.getItem(bufnr);
        if (buf)
          buf.render();
      }
    };
  }
});

// src/handler/linkedEditing.ts
var debounceTime10, LinkedEditingHandler;
var init_linkedEditing = __esm({
  "src/handler/linkedEditing.ts"() {
    "use strict";
    init_main();
    init_textRange();
    init_util5();
    init_events();
    init_languages();
    init_util();
    init_node();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    debounceTime10 = getConditionValue(200, 10);
    LinkedEditingHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.changing = false;
        this.checkPosition = debounce(this._checkPosition, debounceTime10);
        handler.addDisposable(events_default.on("CursorMoved", (bufnr, cursor) => {
          this.cancel();
          this.checkPosition(bufnr, [cursor[0], cursor[1]]);
        }));
        handler.addDisposable(events_default.on("CursorMovedI", (bufnr, cursor) => {
          this.cancel();
          this.checkPosition(bufnr, [cursor[0], cursor[1]]);
        }));
        handler.addDisposable(window_default.onDidChangeActiveTextEditor(() => {
          this.cancel();
          this.cancelEdit();
        }));
        handler.addDisposable(events_default.on("InsertCharPre", (character, bufnr) => {
          if (bufnr !== this.bufnr)
            return;
          let doc = workspace_default.getDocument(bufnr);
          if (!this.wordPattern) {
            if (!doc.isWord(character) && character !== "-")
              this.cancelEdit();
          } else {
            let r = new RegExp(this.wordPattern);
            if (!r.test(character))
              this.cancelEdit();
          }
        }));
        handler.addDisposable(workspace_default.onDidChangeTextDocument(async (e) => {
          await this.onChange(e);
        }));
      }
      cancelEdit() {
        var _a2;
        (_a2 = this.window) == null ? void 0 : _a2.clearMatchGroup("^CocLinkedEditing");
        this.ranges = void 0;
        this.window = void 0;
        this.bufnr = void 0;
      }
      async onChange(e) {
        if (e.bufnr !== this.bufnr || this.changing || !this.ranges)
          return;
        if (e.contentChanges.length === 0) {
          this.doHighlights();
          return;
        }
        let change = e.contentChanges[0];
        let { text, range } = change;
        let affected = this.ranges.filter((r) => {
          if (!rangeIntersect(range, r.range))
            return false;
          if (rangeAdjacent(range, r.range)) {
            if (text.includes("\n") || !emptyRange(range))
              return false;
          }
          return true;
        });
        if (affected.length == 1 && rangeInRange(range, affected[0].range)) {
          if (text.includes("\n")) {
            this.cancelEdit();
            return;
          }
          await this.applySingleEdit(affected[0], { range, newText: text });
        } else {
          this.cancelEdit();
        }
      }
      async applySingleEdit(textRange, edit2) {
        let { bufnr, ranges } = this;
        let doc = workspace_default.getDocument(bufnr);
        let after = ranges.filter((r) => r !== textRange && r.position.line == textRange.position.line);
        after.forEach((r) => r.adjustFromEdit(edit2));
        let change = getChange(textRange, edit2.range, edit2.newText);
        let delta = getDelta(change);
        ranges.forEach((r) => r.applyChange(change));
        let edits = ranges.filter((r) => r !== textRange).map((o) => o.textEdit);
        this.changing = true;
        await doc.applyEdits(edits, true, true);
        this.changing = false;
        if (delta != 0) {
          for (let r of ranges) {
            let n = getBeforeCount(r, this.ranges, textRange);
            r.move(n * delta);
          }
        }
        this.doHighlights();
      }
      doHighlights() {
        let { window: window2, ranges, nvim } = this;
        if (window2 && ranges) {
          nvim.pauseNotification();
          window2.clearMatchGroup("^CocLinkedEditing");
          window2.highlightRanges("CocLinkedEditing", ranges.map((o) => o.range), 99, true);
          nvim.resumeNotification(true, true);
        }
      }
      _checkPosition(bufnr, cursor) {
        if (events_default.pumvisible || !workspace_default.isAttached(bufnr))
          return;
        let doc = workspace_default.getDocument(bufnr);
        let config = workspace_default.getConfiguration("coc.preferences", doc);
        let enabled = config.get("enableLinkedEditing", false);
        if (!enabled || !languages_default.hasProvider("linkedEditing" /* LinkedEditing */, doc.textDocument))
          return;
        let character = characterIndex(doc.getline(cursor[0] - 1), cursor[1] - 1);
        let position = Position.create(cursor[0] - 1, character);
        if (this.ranges) {
          if (this.ranges.some((r) => positionInRange(position, r.range) == 0)) {
            return;
          }
          this.cancelEdit();
        }
        void this.enable(doc, position);
      }
      async enable(doc, position) {
        let textDocument = doc.textDocument;
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        let token = tokenSource.token;
        let win = await this.nvim.window;
        let linkedRanges = await languages_default.provideLinkedEdits(textDocument, position, token);
        if (token.isCancellationRequested || !linkedRanges || linkedRanges.ranges.length == 0)
          return;
        let ranges = linkedRanges.ranges.map((o) => new TextRange(o.start.line, o.start.character, textDocument.getText(o)));
        this.wordPattern = linkedRanges.wordPattern;
        this.bufnr = doc.bufnr;
        this.window = win;
        this.ranges = ranges;
        this.doHighlights();
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
    };
  }
});

// src/handler/links.ts
function sameLinks(links2, other) {
  if (links2.length != other.length)
    return false;
  for (let i = 0; i < links2.length; i++) {
    if (!equals(links2[i].range, other[i].range)) {
      return false;
    }
  }
  return true;
}
var import_debounce, floatFactory2, debounceTime11, NAMESPACE3, highlightGroup, Links, LinkBuffer;
var init_links2 = __esm({
  "src/handler/links.ts"() {
    "use strict";
    import_debounce = __toESM(require_debounce());
    init_main();
    init_events();
    init_languages();
    init_util();
    init_array();
    init_object();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    debounceTime11 = getConditionValue(200, 10);
    NAMESPACE3 = "links";
    highlightGroup = "CocLink";
    Links = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        events_default.on("CursorHold", async () => {
          await this.showTooltip();
        }, null, this.disposables);
        events_default.on(["CursorMoved", "InsertEnter"], () => {
          this.cancel();
        }, null, this.disposables);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          return new LinkBuffer(doc);
        });
        this.disposables.push(this.buffers);
        languages_default.onDidLinksRefresh((selector) => {
          for (let item of this.buffers.items) {
            if (workspace_default.match(selector, item.doc)) {
              item.fetchLinks();
            }
          }
        }, null, this.disposables);
      }
      setConfiguration(e) {
        if (!e || e.affectsConfiguration("links")) {
          this.tooltip = workspace_default.initialConfiguration.get("links.tooltip", false);
          if (e) {
            for (let item of this.buffers.items) {
              item.updateDocumentConfig();
            }
          }
        }
      }
      async showTooltip() {
        if (!this.tooltip)
          return;
        let link = await this.getCurrentLink();
        if (!link || !link.target)
          return;
        let text = link.target;
        if (link.tooltip)
          text += " " + link.tooltip;
        let doc = { content: text, filetype: "txt" };
        if (!floatFactory2)
          floatFactory2 = window_default.createFloatFactory({});
        await floatFactory2.show([doc]);
      }
      async getLinks() {
        let { doc } = await this.handler.getCurrentState();
        let buf = this.buffers.getItem(doc.bufnr);
        await buf.getLinks();
        return toArray(buf.links);
      }
      async getCurrentLink() {
        let links2 = await this.getLinks();
        let pos = await window_default.getCursorPosition();
        if (links2 && links2.length) {
          for (let link2 of links2) {
            if (positionInRange(pos, link2.range) == 0) {
              if (!link2.target) {
                let tokenSource = this.tokenSource = this.tokenSource || new import_node3.CancellationTokenSource();
                link2 = await languages_default.resolveDocumentLink(link2, this.tokenSource.token);
                this.tokenSource = void 0;
                if (!link2.target || tokenSource.token.isCancellationRequested)
                  continue;
              }
              return link2;
            }
          }
        }
        let line = await this.nvim.call("getline", ["."]);
        let regex2 = /\w+?:\/\/[^)\]'" ]+/g;
        let arr;
        let link;
        while ((arr = regex2.exec(line)) !== null) {
          let start = arr.index;
          if (start <= pos.character && start + arr[0].length >= pos.character) {
            link = DocumentLink.create(Range.create(pos.line, start, pos.line, start + arr[0].length), arr[0]);
            break;
          }
        }
        return link;
      }
      async openCurrentLink() {
        let link = await this.getCurrentLink();
        if (link) {
          await this.openLink(link);
          return true;
        }
        return false;
      }
      async openLink(link) {
        if (!link.target)
          throw new Error(`Failed to resolve link target`);
        await workspace_default.openResource(link.target);
      }
      getBuffer(bufnr) {
        return this.buffers.getItem(bufnr);
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    LinkBuffer = class {
      constructor(doc) {
        this.doc = doc;
        this.links = [];
        this.fetchLinks = (0, import_debounce.default)(() => {
          void this.getLinks();
        }, debounceTime11);
        if (this.hasProvider)
          this.fetchLinks();
      }
      get config() {
        if (this._config)
          return this._config;
        this.updateDocumentConfig();
        return this._config;
      }
      get hasProvider() {
        return languages_default.hasProvider("documentLink" /* DocumentLink */, this.doc);
      }
      updateDocumentConfig() {
        let configuration2 = workspace_default.getConfiguration("links", this.doc);
        this._config = {
          enable: configuration2.get("enable", true),
          highlight: configuration2.get("highlight", false)
        };
      }
      onChange(e) {
        if (e.contentChanges.length == 0) {
          this.highlight();
        } else {
          this.cancel();
          this.fetchLinks();
        }
      }
      highlight() {
        if (!this.config.highlight || !this.links)
          return;
        let { links: links2, doc } = this;
        if (isFalsyOrEmpty(links2)) {
          this.clearHighlight();
        } else {
          let highlights = [];
          links2.forEach((link) => {
            doc.addHighlights(highlights, highlightGroup, link.range);
          });
          this.doc.buffer.updateHighlights(NAMESPACE3, highlights, { priority: 2048 });
        }
      }
      clearHighlight() {
        this.buffer.clearNamespace(NAMESPACE3);
      }
      get buffer() {
        return this.doc.buffer;
      }
      cancel() {
        this.fetchLinks.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      async getLinks() {
        if (!this.hasProvider || !this.config.enable)
          return;
        this.cancel();
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        let token = tokenSource.token;
        let links2 = await languages_default.getDocumentLinks(this.doc.textDocument, token);
        this.tokenSource = void 0;
        if (token.isCancellationRequested || sameLinks(toArray(this.links), toArray(links2)))
          return;
        this.links = toArray(links2);
        this.highlight();
      }
      dispose() {
        this.cancel();
      }
    };
  }
});

// src/handler/locations.ts
var LocationsHandler;
var init_locations = __esm({
  "src/handler/locations.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_services();
    init_object();
    init_protocol();
    init_workspace();
    LocationsHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async request(method, fn) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(method, doc.textDocument);
        await doc.synchronize();
        return await this.handler.withRequestToken(method, (token) => {
          return fn(doc.textDocument, position, token);
        }, true);
      }
      async definitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("definition" /* Definition */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node3.CancellationTokenSource();
        return languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
      }
      async declarations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("declaration" /* Declaration */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node3.CancellationTokenSource();
        return languages_default.getDeclaration(doc.textDocument, position, tokenSource.token);
      }
      async typeDefinitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("typeDefinition" /* TypeDefinition */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node3.CancellationTokenSource();
        return languages_default.getTypeDefinition(doc.textDocument, position, tokenSource.token);
      }
      async implementations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("implementation" /* Implementation */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node3.CancellationTokenSource();
        return languages_default.getImplementation(doc.textDocument, position, tokenSource.token);
      }
      async references(excludeDeclaration) {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("reference" /* Reference */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node3.CancellationTokenSource();
        return languages_default.getReferences(doc.textDocument, { includeDeclaration: !excludeDeclaration }, position, tokenSource.token);
      }
      async gotoDefinition(openCommand) {
        let definition = await this.request("definition" /* Definition */, (doc, position, token) => {
          return languages_default.getDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoDeclaration(openCommand) {
        let definition = await this.request("declaration" /* Declaration */, (doc, position, token) => {
          return languages_default.getDeclaration(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoTypeDefinition(openCommand) {
        let definition = await this.request("typeDefinition" /* TypeDefinition */, (doc, position, token) => {
          return languages_default.getTypeDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoImplementation(openCommand) {
        let definition = await this.request("implementation" /* Implementation */, (doc, position, token) => {
          return languages_default.getImplementation(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async gotoReferences(openCommand, includeDeclaration = true) {
        let definition = await this.request("reference" /* Reference */, (doc, position, token) => {
          return languages_default.getReferences(doc, { includeDeclaration }, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return definition ? definition.length > 0 : false;
      }
      async getTagList() {
        let { doc, position } = await this.handler.getCurrentState();
        let word = await this.nvim.call("expand", "<cword>");
        if (!word)
          return null;
        if (!languages_default.hasProvider("definition" /* Definition */, doc.textDocument))
          return null;
        let tokenSource = new import_node3.CancellationTokenSource();
        let definitions = await languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
        if (!definitions || !definitions.length)
          return null;
        return definitions.map((location) => {
          let parsedURI = URI.parse(location.uri);
          const filename = parsedURI.scheme == "file" ? parsedURI.fsPath : parsedURI.toString();
          return {
            name: word,
            cmd: `silent keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,
            filename
          };
        });
      }
      async findLocations(id, method, params, openCommand = false) {
        let { doc, position } = await this.handler.getCurrentState();
        params = params || {};
        Object.assign(params, {
          textDocument: { uri: doc.uri },
          position
        });
        let res = await services_default.sendRequest(id, method, params);
        let locations = this.toLocations(res);
        await this.handleLocations(locations, openCommand);
        return locations.length > 0;
      }
      toLocations(location) {
        let res = [];
        if (location && hasOwnProperty(location, "location") && hasOwnProperty(location, "children")) {
          let getLocation2 = (item) => {
            if (!item)
              return;
            if (Location.is(item.location)) {
              res.push(item.location);
            } else if (LocationLink.is(item.location)) {
              let loc = item.location;
              res.push({
                uri: loc.targetUri,
                range: loc.targetSelectionRange,
                targetRange: loc.targetRange
              });
            }
            if (item.children && item.children.length) {
              for (let loc of item.children) {
                getLocation2(loc);
              }
            }
          };
          getLocation2(location);
          return res;
        }
        if (Location.is(location)) {
          res.push(location);
        } else if (LocationLink.is(location)) {
          res.push({
            uri: location.targetUri,
            range: location.targetSelectionRange,
            targetRange: location.targetRange
          });
        } else if (Array.isArray(location)) {
          for (let loc of location) {
            if (Location.is(loc)) {
              res.push(loc);
            } else if (loc && typeof loc.targetUri === "string") {
              res.push({
                uri: loc.targetUri,
                range: loc.targetSelectionRange,
                targetRange: loc.targetRange
              });
            }
          }
        }
        return res;
      }
      async handleLocations(locations, openCommand) {
        if (!locations)
          return;
        let len = locations.length;
        if (len == 0)
          return;
        if (len == 1 && openCommand !== false) {
          let { uri, range } = locations[0];
          await workspace_default.jumpTo(uri, range.start, openCommand);
        } else {
          await workspace_default.showLocations(locations);
        }
      }
    };
  }
});

// src/handler/refactor/changes.ts
var Changes;
var init_changes = __esm({
  "src/handler/refactor/changes.ts"() {
    "use strict";
    init_object();
    Changes = class {
      constructor() {
        this.stack = [];
      }
      add(infos) {
        let map = /* @__PURE__ */ new Map();
        for (let info of infos) {
          map.set(info.lnum, info);
        }
        this.stack.push(map);
      }
      checkInsert(lnums) {
        if (!this.stack.length)
          return void 0;
        let last = this.stack[this.stack.length - 1];
        let arr = Array.from(last.keys()).sort((a, b) => a - b);
        if (!equals(arr, lnums))
          return void 0;
        this.stack.pop();
        return Array.from(last.values());
      }
    };
  }
});

// src/handler/refactor/buffer.ts
function adjustRange(range, offset) {
  let { start, end } = range;
  return Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function fixChangeParams(e) {
  let { contentChanges, bufnr, textDocument, original, originalLines } = e;
  let { range, text } = contentChanges[0];
  let changes = [{ range, text }];
  if (!original) {
    if (emptyRange(range) && range.start.character != 0) {
      let lines = text.split(/\r?\n/);
      let last = lines[lines.length - 1];
      let before = originalLines[range.start.line].slice(0, range.start.character);
      if (last.startsWith(SEPARATOR) && before == last) {
        changes[0].text = before + lines.slice(0, -1).join("\n") + "\n";
        let { start, end } = range;
        changes[0].range = Range.create(start.line, 0, end.line, 0);
      }
    }
  } else {
    let lines = original.split(/\r?\n/);
    let last = lines[lines.length - 1];
    if (last.startsWith(SEPARATOR)) {
      let before = originalLines[range.start.line].slice(0, range.start.character);
      if (before == last) {
        original = before + lines.slice(0, -1).join("\n") + "\n";
        let { start, end } = range;
        changes[0].range = Range.create(start.line, 0, end.line, 0);
      }
    }
    let prev = originalLines[range.start.line - 1];
    let nest = lines.length > 1 ? lines[lines.length - 2] : "";
    if (last == "" && nest.startsWith(SEPARATOR) && prev == nest && range.start.character == 0 && range.end.character == 0) {
      original = prev + "\n" + lines.slice(0, -2).join("\n") + "\n";
      let { start, end } = range;
      changes[0].range = Range.create(start.line - 1, 0, end.line - 1, 0);
    }
  }
  return { contentChanges: changes, bufnr, textDocument, original, originalLines };
}
var logger50, SEPARATOR, RefactorBuffer;
var init_buffer5 = __esm({
  "src/handler/refactor/buffer.ts"() {
    "use strict";
    init_main3();
    init_main();
    init_esm();
    init_logger();
    init_highligher();
    init_util();
    init_fs();
    init_lodash();
    init_mutex();
    init_node();
    init_object();
    init_position();
    init_string();
    init_textedit();
    init_window();
    init_workspace();
    init_changes();
    logger50 = createLogger("handler-refactorBuffer");
    SEPARATOR = "\u3000";
    RefactorBuffer = class {
      constructor(bufnr, srcId4, nvim, config, opts) {
        this.bufnr = bufnr;
        this.srcId = srcId4;
        this.nvim = nvim;
        this.config = config;
        this.opts = opts;
        this._disposed = false;
        this._fileItems = [];
        this.mutex = new Mutex();
        this.disposables = [];
        this.matchIds = /* @__PURE__ */ new Set();
        this.changing = false;
        this.changes = new Changes();
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", "<CR>", this.splitOpen.bind(this), true));
        if (config.showMenu) {
          this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", config.showMenu, this.showMenu.bind(this), true));
        }
        workspace_default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
      }
      async showMenu() {
        let res = await window_default.showMenuPicker(["Tab open", "Remove block"]);
        if (res == -1)
          return;
        let fileRange = await this.searchCurrentRange();
        if (!fileRange)
          return;
        if (res == 0) {
          let before = await this.nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
          let character = before.length;
          let bufname = this.getAbsolutePath(fileRange.filepath);
          this.nvim.call("coc#util#jump", ["tabe", bufname, [fileRange.line, character]], true);
        }
        if (res == 1) {
          let range = this.getDeleteRange(fileRange);
          await this.document.applyEdits([TextEdit.del(range)]);
        }
      }
      get fileItems() {
        return this._fileItems;
      }
      getFileItem(uri) {
        let filepath = URI.parse(uri).fsPath;
        return this._fileItems.find((o) => sameFile(o.filepath, filepath));
      }
      getFileRange(lnum) {
        for (let item of this._fileItems) {
          for (let r of item.ranges) {
            if (r.lnum == lnum) {
              return Object.assign(omit(r, ["highlights"]), { filepath: item.filepath });
            }
          }
        }
        throw new Error(`File range not found at lnum: ${lnum}`);
      }
      onChange(e) {
        if (this.changing)
          return;
        if (e.contentChanges.length === 0) {
          this.highlightLineNr();
          this.nvim.redrawVim();
          return;
        }
        let { nvim } = this;
        e = fixChangeParams(e);
        let change = e.contentChanges[0];
        let { original } = e;
        if (change.range.end.line > 2) {
          nvim.call("setbufvar", [e.bufnr, "&modified", 1], true);
        }
        let { range, text } = change;
        let lineChange = lineCountChange(TextEdit.replace(range, text));
        if (lineChange == 0)
          return;
        let edits = [TextEdit.replace(range, text)];
        let addRanges = [];
        if (!emptyRange(range) && !text.includes("\u3000")) {
          let sl = range.start.line;
          let lnums = [];
          let lines = original.split(/\r?\n/);
          for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.length > 1 && line.includes("\u3000")) {
              lnums.push(sl + i + 1);
            }
          }
          if (lnums.length) {
            let infos = lnums.map((lnum) => {
              return this.getFileRange(lnum);
            });
            for (let item of this._fileItems) {
              item.ranges = item.ranges.filter((o) => !lnums.includes(o.lnum));
            }
            this.changes.add(infos);
          }
        } else if (emptyRange(range) && text.includes("\u3000")) {
          let lines = text.split(/\r?\n/);
          let lnums = [];
          let sl = range.start.line;
          for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.length > 1 && line.includes("\u3000")) {
              lnums.push(sl + i + 1);
            }
          }
          if (lnums.length) {
            let res = this.changes.checkInsert(lnums);
            if (res)
              addRanges = res;
          }
        } else if (text.includes("\u3000")) {
          edits = this.diffChanges(original, text);
          edits.forEach((e2) => {
            e2.range = adjustRangePosition(e2.range, range.start);
          });
        }
        this.adjustLnums(edits);
        nvim.pauseNotification();
        this.highlightLineNr();
        nvim.resumeNotification(true, true);
        if (addRanges.length) {
          addRanges.forEach((info) => {
            let item = this._fileItems.find((o) => o.filepath == info.filepath);
            item.ranges.push(info);
          });
        }
      }
      diffChanges(original, text) {
        let edits = [];
        let diffs = fastDiff(original, text);
        let offset = 0;
        let orig = TextDocument2.create("file:///1", "", 0, original);
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          let pos = orig.positionAt(offset);
          if (diff[0] == fastDiff.EQUAL) {
            offset = offset + diff[1].length;
          } else if (diff[0] == fastDiff.DELETE) {
            let end = orig.positionAt(offset + diff[1].length);
            if (diffs[i + 1] && diffs[i + 1][0] == fastDiff.INSERT) {
              let text2 = diffs[i + 1][1];
              edits.push(TextEdit.replace(Range.create(pos, end), text2));
              i = i + 1;
            } else {
              edits.push(TextEdit.replace(Range.create(pos, end), ""));
            }
            offset = offset + diff[1].length;
          } else if (diff[0] == fastDiff.INSERT) {
            edits.push(TextEdit.insert(pos, diff[1]));
          }
        }
        return edits;
      }
      async onDocumentChange(e) {
        if (this.changing || e.contentChanges.length === 0)
          return;
        let { uri } = e.textDocument;
        let fileItem = this.getFileItem(uri);
        if (!fileItem)
          return;
        let { range, text } = e.contentChanges[0];
        let lineChange = lineCountChange(TextEdit.replace(range, text));
        let edits = [];
        let deleteIndexes = [];
        for (let i = 0; i < fileItem.ranges.length; i++) {
          let r = fileItem.ranges[i];
          if (range.start.line >= r.start + r.lines.length)
            continue;
          if (range.end.line < r.start) {
            r.start = r.start + lineChange;
            continue;
          }
          let textDocument = workspace_default.getDocument(uri).textDocument;
          let end = r.start + r.lines.length + lineChange;
          let newLines = textDocument.lines.slice(r.start, end);
          if (!newLines.length) {
            deleteIndexes.push(i);
            let replaceRange = this.getDeleteRange(r);
            edits.push(TextEdit.replace(replaceRange, ""));
          } else {
            r.lines = newLines;
            let replaceRange = this.getReplaceRange(r);
            edits.push(TextEdit.replace(replaceRange, newLines.join("\n")));
          }
        }
        if (deleteIndexes.length) {
          fileItem.ranges = fileItem.ranges.filter((_, i) => !deleteIndexes.includes(i));
        }
        this._fileItems = this._fileItems.filter((o) => o.ranges && o.ranges.length > 0);
        if (edits.length) {
          this.adjustLnums(edits);
          this.changing = true;
          await this.document.applyEdits(edits);
          this.changing = false;
        }
        this.nvim.pauseNotification();
        this.highlightLineNr();
        this.buffer.setOption("modified", false, true);
        await this.nvim.resumeNotification(true);
      }
      adjustLnums(edits) {
        for (let item of this._fileItems) {
          for (let fileRange of item.ranges) {
            let line = fileRange.lnum - 1;
            fileRange.lnum += getChangedLineCount(Position.create(line, 0), edits);
          }
        }
      }
      async getFileChanges() {
        let changes = [];
        let lines = await this.buffer.lines;
        lines.push(SEPARATOR);
        let arr = [];
        let fsPath2;
        let lnum;
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          if (line.startsWith(SEPARATOR)) {
            if (fsPath2) {
              changes.push({
                filepath: fsPath2,
                lines: arr.slice(),
                lnum
              });
              fsPath2 = void 0;
              arr = [];
            }
            if (line.length > 1) {
              let ms = line.match(/^\u3000(.*)/);
              if (ms) {
                fsPath2 = this.getAbsolutePath(ms[1].replace(/\s+$/, ""));
                lnum = i + 1;
                arr = [];
              }
            }
          } else {
            arr.push(line);
          }
        }
        return changes;
      }
      async splitOpen() {
        let { nvim } = this;
        let win = nvim.createWindow(this.opts.fromWinid);
        let valid = await win.valid;
        let before = await nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
        let character = before.length;
        let fileRange = await this.searchCurrentRange();
        if (fileRange) {
          let bufname = this.getAbsolutePath(fileRange.filepath);
          nvim.pauseNotification();
          if (valid) {
            nvim.call("win_gotoid", [this.opts.fromWinid], true);
            this.nvim.call("coc#util#jump", ["edit", bufname, [fileRange.line, character]], true);
          } else {
            this.nvim.call("coc#util#jump", ["belowright vs", bufname, [fileRange.line, character]], true);
          }
          nvim.command("normal! zz", true);
          await nvim.resumeNotification(true);
          if (!valid) {
            this.opts.fromWinid = await nvim.call("win_getid");
          }
        }
      }
      async searchCurrentRange() {
        let { nvim } = this;
        let lines = await nvim.eval('getline(1,line("."))');
        let len = lines.length;
        for (let i = 0; i < len; i++) {
          let line = lines[len - i - 1];
          let ms = line.match(/^\u3000(.+)/);
          if (ms) {
            let r = this.getFileRange(len - i);
            return Object.assign({ line: r.start + (i == 0 ? 1 : i) - 1 }, r);
          }
        }
        return void 0;
      }
      async addFileItems(items) {
        if (this._disposed)
          return;
        let { cwd: cwd2 } = this.opts;
        let { document: document2 } = this;
        const release = await this.mutex.acquire();
        try {
          await document2.synchronize();
          let count = document2.lineCount;
          let highligher = new Highlighter();
          let hlRanges = [];
          for (let item of items) {
            let ranges = [];
            for (let range of item.ranges) {
              highligher.addLine(SEPARATOR);
              highligher.addLine(SEPARATOR);
              let lnum = count + highligher.length;
              highligher.addText(`${isParentFolder(cwd2, item.filepath) ? path.relative(cwd2, item.filepath) : item.filepath}`);
              let n = String(range.start + 1).length + String(range.end).length + 4;
              if (!this.srcId)
                highligher.addText(" ".repeat(n));
              let base = 0 - highligher.length - count;
              if (range.highlights) {
                hlRanges.push(...range.highlights.map((r) => adjustRange(r, base)));
              }
              let { lines, start, end, highlights } = range;
              if (!lines) {
                lines = await this.getLines(item.filepath, start, end);
              }
              ranges.push({ lines, lnum, start, highlights });
              highligher.addLines(lines);
            }
            if (ranges.length) {
              let newItem = { filepath: item.filepath, ranges };
              let fileItem = this._fileItems.find((o) => o.filepath == item.filepath);
              if (fileItem) {
                fileItem.ranges.push(...newItem.ranges);
              } else {
                this._fileItems.push(newItem);
              }
            }
          }
          let { nvim, buffer } = this;
          this.changing = true;
          nvim.pauseNotification();
          highligher.render(buffer, count);
          this.highlightLineNr();
          buffer.setOption("modified", false, true);
          buffer.setOption("undolevels", 1e3, true);
          if (count == 2 && hlRanges.length) {
            let pos = hlRanges[0].start;
            nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
          }
          await nvim.resumeNotification(true);
          await document2.patchChange();
          this.changing = false;
          await window_default.cursors.addRanges(hlRanges);
        } catch (e) {
          this.changing = false;
          logger50.error(`Error on add file item:`, e);
        }
        release();
      }
      findRange(filepath, lnum) {
        let item = this.fileItems.find((o) => sameFile(this.getAbsolutePath(o.filepath), filepath));
        let range = item.ranges.find((o) => o.lnum == lnum);
        if (!range)
          throw new Error(`File range not found at lnum: ${lnum}`);
        return range;
      }
      async save() {
        let { nvim } = this;
        let doc = this.document;
        let { buffer } = doc;
        await doc.patchChange();
        let changes = await this.getFileChanges();
        if (!changes)
          return;
        changes.sort((a, b) => a.lnum - b.lnum);
        let fileChanges = [];
        for (let i = 0; i < changes.length; i++) {
          let change = changes[i];
          let range = this.findRange(change.filepath, change.lnum);
          if (equals(range.lines, change.lines))
            continue;
          fileChanges.push(Object.assign({ start: range.start, end: range.start + range.lines.length }, change));
          range.lines = change.lines;
        }
        if (fileChanges.length == 0) {
          await window_default.showInformationMessage("No change.");
          await buffer.setOption("modified", false);
          return false;
        }
        let changeMap = {};
        for (let change of fileChanges) {
          let uri = URI.file(change.filepath).toString();
          let edits = changeMap[uri] || [];
          edits.push({
            range: Range.create(change.start, 0, change.end, 0),
            newText: change.lines.join("\n") + "\n"
          });
          changeMap[uri] = edits;
        }
        this.changing = true;
        await workspace_default.applyEdit({ changes: changeMap });
        this.changing = false;
        for (let item of this.fileItems) {
          let uri = URI.file(this.getAbsolutePath(item.filepath)).toString();
          let edits = changeMap[uri];
          if (edits && edits.length > 0) {
            item.ranges.forEach((r) => {
              r.start += getChangedLineCount(Position.create(r.start, 0), edits);
            });
          }
        }
        nvim.pauseNotification();
        buffer.setOption("modified", false, true);
        if (this.config.saveToFile) {
          nvim.command("silent noa wa", true);
        }
        this.highlightLineNr();
        await nvim.resumeNotification();
        return true;
      }
      async getLines(fsPath2, start, end) {
        let uri = URI.file(fsPath2).toString();
        let doc = workspace_default.getDocument(uri);
        if (doc)
          return doc.getLines(start, end);
        return await readFileLines(fsPath2, start, end - 1);
      }
      getAbsolutePath(filepath) {
        if (path.isAbsolute(filepath))
          return filepath;
        return path.join(this.opts.cwd, filepath);
      }
      highlightLineNr() {
        let { fileItems, nvim, srcId: srcId4, bufnr } = this;
        let { winid, cwd: cwd2 } = this.opts;
        let info = {};
        if (srcId4) {
          nvim.call("nvim_buf_clear_namespace", [bufnr, srcId4, 0, -1], true);
          for (let item of fileItems) {
            for (let range of item.ranges) {
              let end = range.start + range.lines.length;
              let text = `${range.start + 1}:${end}`;
              info[range.lnum] = [range.start + 1, end];
              nvim.call("nvim_buf_set_virtual_text", [bufnr, srcId4, range.lnum - 1, [[text, "LineNr"]], {}], true);
            }
          }
        } else {
          if (this.matchIds.size) {
            nvim.call("coc#highlight#clear_matches", [winid, Array.from(this.matchIds)], true);
            this.matchIds.clear();
          }
          let id = 2e3;
          for (let item of fileItems) {
            let filename = `${cwd2 ? path.relative(cwd2, item.filepath) : item.filepath}`;
            let col = byteLength(filename) + 1;
            for (let range of item.ranges) {
              let end = range.start + range.lines.length;
              let text = `:${range.start + 1}:${end}`;
              for (let i = 0; i < text.length; i++) {
                let ch = text[i];
                this.matchIds.add(id);
                info[range.lnum] = [range.start + 1, end];
                nvim.call("matchaddpos", ["Conceal", [[range.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);
                id++;
              }
            }
          }
        }
        this.buffer.setVar("line_infos", info, true);
      }
      getDeleteRange(r) {
        let { document: document2 } = this;
        let start = r.lnum - 1;
        let end;
        let total = document2.lineCount;
        for (let i = start; i < total; i++) {
          if (i + 1 == total) {
            end = Position.create(total, 0);
            break;
          }
          let line = document2.getline(i);
          if (line === SEPARATOR) {
            end = Position.create(i + 1, 0);
            break;
          }
          if (i != start && line.startsWith(SEPARATOR)) {
            end = Position.create(i, 0);
            break;
          }
        }
        return Range.create(Position.create(start, 0), end);
      }
      getReplaceRange(r) {
        let { document: document2 } = this;
        let start = r.lnum;
        let end;
        let total = document2.lineCount;
        for (let i = start; i < total; i++) {
          let line = document2.getline(i);
          if (i + 1 == total) {
            end = Position.create(i, line.length);
            break;
          }
          let next = document2.getline(i + 1);
          if (next.startsWith("\u3000")) {
            end = Position.create(i, line.length);
            break;
          }
        }
        return Range.create(Position.create(start, 0), end);
      }
      get valid() {
        return this.buffer.valid;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get document() {
        return workspace_default.getDocument(this.bufnr);
      }
      dispose() {
        this._disposed = true;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/refactor/search.ts
function getPathFromArgs(args) {
  if (args.length < 2)
    return void 0;
  let len = args.length;
  if (args[len - 1].startsWith("-"))
    return void 0;
  if (args[len - 2].startsWith("-"))
    return void 0;
  return args[len - 1];
}
var import_child_process2, import_events50, logger51, defaultArgs, controlCode2, Task2, Search;
var init_search = __esm({
  "src/handler/refactor/search.ts"() {
    "use strict";
    import_child_process2 = require("child_process");
    import_events50 = require("events");
    init_main();
    init_logger();
    init_highligher();
    init_ansiparse();
    init_mutex();
    init_node();
    init_window();
    logger51 = createLogger("handler-search");
    defaultArgs = ["--color", "ansi", "--colors", "path:fg:black", "--colors", "line:fg:green", "--colors", "match:fg:red", "--no-messages", "--heading", "-n"];
    controlCode2 = "\x1B";
    Task2 = class extends import_events50.EventEmitter {
      start(cmd, args, cwd2) {
        this.process = (0, import_child_process2.spawn)(cmd, args, { cwd: cwd2 });
        this.process.on("error", (e) => {
          this.emit("error", e.message);
        });
        const rl = readline.createInterface(this.process.stdout);
        let start;
        let fileItem;
        let lines = [];
        let highlights = [];
        let create = true;
        rl.on("line", (content) => {
          if (content.includes(controlCode2)) {
            let items = ansiparse(content);
            if (items.length == 0)
              return;
            if (items[0].foreground == "black") {
              fileItem = { filepath: path.join(cwd2, items[0].text), ranges: [] };
              return;
            }
            let normalLine = items[0].foreground == "green";
            if (normalLine) {
              let lnum = parseInt(items[0].text, 10) - 1;
              let padlen2 = items[0].text.length + 1;
              if (create) {
                start = lnum;
                create = false;
              }
              let line = "";
              for (let item of items) {
                if (item.foreground == "red") {
                  let l = lnum - start;
                  let c = line.length - padlen2;
                  highlights.push(Range.create(l, c, l, c + item.text.length));
                }
                line += item.text;
              }
              let currline = line.slice(padlen2);
              lines.push(currline);
            }
          } else {
            let fileEnd = content.trim().length == 0;
            if (fileItem && (fileEnd || content.trim() == "--")) {
              fileItem.ranges.push({ lines, highlights, start });
            }
            if (fileEnd) {
              this.emit("item", fileItem);
              fileItem = null;
            }
            lines = [];
            highlights = [];
            create = true;
          }
        });
        rl.on("close", () => {
          if (fileItem) {
            if (lines.length) {
              fileItem.ranges.push({ lines, highlights, start });
            }
            this.emit("item", fileItem);
          }
          lines = highlights = fileItem = null;
          this.emit("end");
        });
      }
      dispose() {
        if (this.process) {
          this.process.kill();
        }
      }
    };
    Search = class {
      constructor(nvim, cmd = "rg") {
        this.nvim = nvim;
        this.cmd = cmd;
      }
      run(args, cwd2, refactorBuf) {
        let { nvim, cmd } = this;
        let { afterContext, beforeContext } = refactorBuf.config;
        let argList = ["-A", afterContext.toString(), "-B", beforeContext.toString()].concat(defaultArgs, args);
        let p = getPathFromArgs(args);
        if (p)
          argList.pop();
        argList.push("--", p ? path.isAbsolute(p) ? p : `./${p.replace(/^\.\//, "")}` : "./");
        this.task = new Task2();
        this.task.start(cmd, argList, cwd2);
        let mutex = new Mutex();
        let files = 0;
        let matches = 0;
        let start = Date.now();
        let fileItems = [];
        const addFileItems = async () => {
          if (fileItems.length == 0)
            return;
          let items = fileItems.slice();
          fileItems = [];
          const release = await mutex.acquire();
          try {
            await refactorBuf.addFileItems(items);
          } catch (e) {
            logger51.error(e);
          }
          release();
        };
        return new Promise((resolve, reject) => {
          let interval2 = setInterval(addFileItems, 300);
          this.task.on("item", async (fileItem) => {
            files++;
            matches = matches + fileItem.ranges.reduce((p2, r) => p2 + r.highlights.length, 0);
            fileItems.push(fileItem);
          });
          this.task.on("error", (message) => {
            clearInterval(interval2);
            void window_default.showErrorMessage(`Error on command "${cmd}": ${message}`);
            this.task = null;
            reject(new Error(message));
          });
          this.task.on("end", async () => {
            clearInterval(interval2);
            try {
              await addFileItems();
              const release = await mutex.acquire();
              release();
              this.task.removeAllListeners();
              this.task = null;
              let buf = refactorBuf.buffer;
              if (buf) {
                nvim.pauseNotification();
                if (files == 0) {
                  buf.setLines(["No match found"], { start: 1, end: 2, strictIndexing: false }, true);
                  buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: "Error" });
                  buf.setOption("modified", false, true);
                } else {
                  let highligher = new Highlighter();
                  highligher.addText("Files", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${files} `, "Number");
                  highligher.addText("Matches", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${matches} `, "Number");
                  highligher.addText("Duration", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${Date.now() - start}ms`, "Number");
                  highligher.render(buf, 1, 2);
                }
                buf.setOption("modified", false, true);
                nvim.resumeNotification(false, true);
              }
            } catch (e) {
              reject(e);
              return;
            }
            resolve();
          });
        });
      }
      abort() {
        var _a2;
        (_a2 = this.task) == null ? void 0 : _a2.dispose();
      }
    };
  }
});

// src/handler/refactor/index.ts
function adjustRange2(range, offset) {
  let { start, end } = range;
  return Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
var name, refactorId, srcId3, Refactor;
var init_refactor = __esm({
  "src/handler/refactor/index.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_languages();
    init_util();
    init_fs();
    init_protocol();
    init_textedit();
    init_workspace();
    init_buffer5();
    init_search();
    name = "__coc_refactor__";
    refactorId = 0;
    Refactor = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.buffers = /* @__PURE__ */ new Map();
        this.disposables = [];
        this._onCreate = new import_node3.Emitter();
        this.onCreate = this._onCreate.event;
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        events_default.on("BufUnload", (bufnr) => {
          let buf = this.buffers.get(bufnr);
          if (buf) {
            buf.dispose();
            this.buffers.delete(bufnr);
          }
        }, null, this.disposables);
        workspace_default.onDidChangeTextDocument((e) => {
          let buf = this.buffers.get(e.bufnr);
          if (buf)
            buf.onChange(e);
        }, null, this.disposables);
      }
      has(bufnr) {
        return this.buffers.has(bufnr);
      }
      setConfiguration(e) {
        if (e && !e.affectsConfiguration("refactor"))
          return;
        let config = workspace_default.getConfiguration("refactor", null);
        this.config = Object.assign(this.config || {}, {
          afterContext: config.get("afterContext", 3),
          beforeContext: config.get("beforeContext", 3),
          openCommand: config.get("openCommand", "edit"),
          saveToFile: config.get("saveToFile", true),
          showMenu: config.get("showMenu", "<Tab>")
        });
      }
      async doRefactor() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_default.hasProvider("rename" /* Rename */, doc.textDocument)) {
          throw new Error(`Rename provider not found for current buffer`);
        }
        await doc.synchronize();
        let edit2 = await this.handler.withRequestToken("refactor", async (token) => {
          let res = await languages_default.prepareRename(doc.textDocument, position, token);
          if (token.isCancellationRequested)
            return null;
          if (res === false)
            throw new Error(`Provider returns null on prepare, unable to rename at current position`);
          let edit3 = await languages_default.provideRenameEdits(doc.textDocument, position, "NewName", token);
          if (token.isCancellationRequested)
            return null;
          if (!edit3)
            throw new Error("Provider returns null for rename edits.");
          return edit3;
        });
        if (edit2) {
          await this.fromWorkspaceEdit(edit2, doc.filetype);
        }
      }
      async search(args) {
        let buf = await this.createRefactorBuffer();
        let cwd2 = await this.nvim.call("getcwd", []);
        let search = new Search(this.nvim);
        await search.run(args, cwd2, buf);
      }
      async save(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (buf)
          return await buf.save();
      }
      getBuffer(bufnr) {
        return this.buffers.get(bufnr);
      }
      async createRefactorBuffer(filetype, conceal = false) {
        let { nvim } = this;
        let [fromWinid, cwd2] = await nvim.eval("[win_getid(),getcwd()]");
        let { openCommand } = this.config;
        if (!nvim.isVim && !srcId3)
          srcId3 = await this.nvim.createNamespace("coc-refactor");
        nvim.pauseNotification();
        nvim.command(`${openCommand} ${name}${refactorId++}`, true);
        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
        nvim.call("setline", [1, ["Save current buffer to make changes", SEPARATOR]], true);
        nvim.call("matchadd", ["Comment", "\\%1l"], true);
        nvim.call("matchadd", ["Conceal", "^\\%u3000"], true);
        nvim.call("matchadd", ["Label", "^\\%u3000\\zs\\S\\+"], true);
        nvim.command("setl nomod", true);
        if (filetype)
          nvim.command(`runtime! syntax/${filetype}.vim`, true);
        nvim.call("coc#util#do_autocmd", ["CocRefactorOpen"], true);
        await nvim.resumeNotification();
        let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
        let opts = { fromWinid, winid: win, cwd: cwd2 };
        await workspace_default.document;
        let buf = new RefactorBuffer(bufnr, conceal ? void 0 : srcId3, this.nvim, this.config, opts);
        this.buffers.set(bufnr, buf);
        return buf;
      }
      async fromLines(lines) {
        let buf = await this.createRefactorBuffer();
        await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });
        return buf;
      }
      async fromLocations(locations, filetype) {
        if (!locations || locations.length == 0)
          return void 0;
        let changes = {};
        let edit2 = { changes };
        for (let location of locations) {
          let edits = changes[location.uri] || [];
          edits.push({ range: location.range, newText: "" });
          changes[location.uri] = edits;
        }
        return await this.fromWorkspaceEdit(edit2, filetype);
      }
      async fromWorkspaceEdit(edit2, filetype) {
        if (!edit2 || emptyWorkspaceEdit(edit2))
          return void 0;
        let items = [];
        let { beforeContext, afterContext } = this.config;
        let { changes, documentChanges } = edit2;
        if (!changes) {
          changes = {};
          for (let change of documentChanges || []) {
            if (TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              changes[textDocument.uri] = edits;
            }
          }
        }
        for (let key of Object.keys(changes)) {
          let max = await this.getLineCount(key);
          let edits = changes[key];
          let ranges = [];
          let start = null;
          let end = null;
          let highlights = [];
          edits.sort((a, b) => a.range.start.line - b.range.start.line);
          for (let edit3 of edits) {
            let { line } = edit3.range.start;
            let s = Math.max(0, line - beforeContext);
            if (start != null && s < end) {
              end = Math.min(max, line + afterContext + 1);
              highlights.push(adjustRange2(edit3.range, start));
            } else {
              if (start != null)
                ranges.push({ start, end, highlights });
              start = s;
              end = Math.min(max, line + afterContext + 1);
              highlights = [adjustRange2(edit3.range, start)];
            }
          }
          if (start != null)
            ranges.push({ start, end, highlights });
          items.push({
            ranges,
            filepath: URI.parse(key).fsPath
          });
        }
        let buf = await this.createRefactorBuffer(filetype);
        await buf.addFileItems(items);
        return buf;
      }
      async getLineCount(uri) {
        let doc = workspace_default.getDocument(uri);
        if (doc)
          return doc.lineCount;
        return await getFileLineCount(URI.parse(uri).fsPath);
      }
      reset() {
        for (let buf of this.buffers.values()) {
          buf.dispose();
        }
        this.buffers.clear();
      }
      dispose() {
        this._onCreate.dispose();
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/rename.ts
var Rename;
var init_rename2 = __esm({
  "src/handler/rename.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    Rename = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async getWordEdit() {
        let { doc, position } = await this.handler.getCurrentState();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || emptyRange(range))
          return null;
        let curname = doc.textDocument.getText(range);
        if (languages_default.hasProvider("rename" /* Rename */, doc.textDocument)) {
          await doc.synchronize();
          let requestTokenSource = new import_node3.CancellationTokenSource();
          let res = await languages_default.prepareRename(doc.textDocument, position, requestTokenSource.token);
          if (res !== false) {
            let newName = curname.startsWith("a") ? "b" : "a";
            let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, requestTokenSource.token);
            if (edit2)
              return edit2;
          }
        }
        void window_default.showInformationMessage("Rename provider not found, extract word ranges from current buffer");
        let ranges = doc.getSymbolRanges(curname);
        return {
          changes: {
            [doc.uri]: ranges.map((r) => ({ range: r, newText: curname }))
          }
        };
      }
      async rename(newName) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("rename" /* Rename */, doc.textDocument);
        await doc.synchronize();
        let token = new import_node3.CancellationTokenSource().token;
        let res = await languages_default.prepareRename(doc.textDocument, position, token);
        if (res === false) {
          void window_default.showWarningMessage("Invalid position for rename");
          return false;
        }
        let curname;
        if (!newName) {
          if (Range.is(res)) {
            curname = doc.textDocument.getText(res);
            await window_default.moveTo(res.start);
          } else if (res && typeof res.placeholder === "string") {
            curname = res.placeholder;
          } else {
            curname = await this.nvim.eval('expand("<cword>")');
          }
          const config = workspace_default.getConfiguration("coc.preferences", null);
          newName = await window_default.requestInput("New name", config.get("renameFillCurrent", true) ? curname : void 0);
        }
        if (newName === "")
          void window_default.showWarningMessage("Empty word, rename canceled");
        if (!newName)
          return false;
        let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, token);
        if (token.isCancellationRequested || !edit2)
          return false;
        await workspace_default.applyEdit(edit2);
        this.nvim.redrawVim();
        return true;
      }
    };
  }
});

// src/handler/selectionRange.ts
var SelectionRangeHandler;
var init_selectionRange2 = __esm({
  "src/handler/selectionRange.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_object();
    init_position();
    init_window();
    SelectionRangeHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.selectionRange = null;
      }
      async getSelectionRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("selectionRange" /* SelectionRange */, doc.textDocument);
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, [position], token);
        });
        return selectionRanges;
      }
      async selectRange(visualmode, forward) {
        let { nvim } = this;
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("selectionRange" /* SelectionRange */, doc.textDocument);
        let positions = [];
        if (!forward && (!this.selectionRange || !visualmode))
          return;
        if (visualmode) {
          let range = await window_default.getSelectedRange(visualmode);
          positions.push(range.start, range.end);
        } else {
          let position = await window_default.getCursorPosition();
          positions.push(position);
        }
        if (!forward) {
          let curr = Range.create(positions[0], positions[1]);
          let { selectionRange: selectionRange2 } = this;
          while (selectionRange2 && selectionRange2.parent) {
            if (equals(selectionRange2.parent.range, curr)) {
              break;
            }
            selectionRange2 = selectionRange2.parent;
          }
          if (selectionRange2 && selectionRange2.parent) {
            await window_default.selectRange(selectionRange2.range);
          }
          return;
        }
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, positions, token);
        });
        if (!selectionRanges || selectionRanges.length == 0)
          return;
        let mode = await nvim.eval("mode()");
        if (mode != "n")
          await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
        let selectionRange;
        if (selectionRanges.length == 1) {
          selectionRange = selectionRanges[0];
        } else {
          let end = positions[1] ?? positions[0];
          let r = Range.create(positions[0], end);
          selectionRange = selectionRanges[0];
          while (selectionRange) {
            if (equals(r, selectionRange.range)) {
              selectionRange = selectionRange.parent;
              continue;
            }
            if (positionInRange(positions[0], selectionRange.range) == 0 && positionInRange(end, selectionRange.range) == 0) {
              break;
            }
            selectionRange = selectionRange.parent;
          }
        }
        if (!selectionRange)
          return;
        this.selectionRange = selectionRanges[0];
        await window_default.selectRange(selectionRange.range);
      }
    };
  }
});

// src/handler/semanticTokens/buffer.ts
function toHighlightPart(token) {
  if (!token)
    return "";
  if (highlightGroupMap.has(token))
    return highlightGroupMap.get(token);
  let chars = [];
  for (let i = 0; i < token.length; i++) {
    let ch = token[i];
    ch = isHighlightGroupCharCode(ch.charCodeAt(0)) ? ch : "_";
    chars.push(i == 0 ? ch.toUpperCase() : ch);
  }
  let part = chars.join("");
  highlightGroupMap.set(token, part);
  return part;
}
var logger52, yieldEveryMilliseconds, HLGROUP_PREFIX, NAMESPACE4, debounceInterval2, requestDelay2, highlightGroupMap, SemanticTokensBuffer;
var init_buffer6 = __esm({
  "src/handler/semanticTokens/buffer.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_logger();
    init_regions();
    init_util();
    init_array();
    init_errors();
    init_util();
    init_numbers();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    logger52 = createLogger("semanticTokens-buffer");
    yieldEveryMilliseconds = getConditionValue(15, 5);
    HLGROUP_PREFIX = "CocSem";
    NAMESPACE4 = "semanticTokens";
    debounceInterval2 = getConditionValue(100, 20);
    requestDelay2 = getConditionValue(500, 20);
    highlightGroupMap = /* @__PURE__ */ new Map();
    SemanticTokensBuffer = class {
      constructor(nvim, doc, staticConfig) {
        this.nvim = nvim;
        this.doc = doc;
        this.staticConfig = staticConfig;
        this._dirty = false;
        this.regions = new Regions();
        this._onDidRefresh = new import_node3.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.highlight = delay(() => {
          void this.doHighlight();
        }, debounceInterval2);
        if (this.hasProvider)
          this.highlight();
      }
      get config() {
        if (this._config)
          return this._config;
        this.loadConfiguration();
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("semanticTokens", this.doc);
        let changed = this._config != null && this._config.enable != config.enable;
        this._config = {
          enable: config.get("enable"),
          highlightPriority: config.get("highlightPriority"),
          incrementTypes: config.get("incrementTypes"),
          combinedModifiers: config.get("combinedModifiers")
        };
        if (changed) {
          if (this._config.enable) {
            this.highlight();
          } else {
            this.clearHighlight();
          }
        }
      }
      get configEnabled() {
        let { enable } = this.config;
        let { filetypes } = this.staticConfig;
        if (Array.isArray(filetypes))
          return filetypes.includes("*") || filetypes.includes(this.doc.filetype);
        return enable;
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      onChange() {
        this.highlight();
      }
      onTextChange() {
        this.cancel();
      }
      async forceHighlight() {
        this.clearHighlight();
        this.cancel();
        await this.doHighlight(true);
      }
      async onShown() {
        if (this.shouldRangeHighlight)
          return;
        const { doc } = this;
        if (doc.dirty || doc.version === this._version)
          return;
        await this.doHighlight(false, true);
      }
      get hasProvider() {
        return languages_default.hasProvider("semanticTokens" /* SemanticTokens */, this.doc) || languages_default.hasProvider("semanticTokensRange" /* SemanticTokensRange */, this.doc);
      }
      get hasLegend() {
        let { textDocument } = this.doc;
        return languages_default.getLegend(textDocument) != null || languages_default.getLegend(textDocument, true) != null;
      }
      get rangeProviderOnly() {
        return !languages_default.hasProvider("semanticTokens" /* SemanticTokens */, this.doc) && languages_default.hasProvider("semanticTokensRange" /* SemanticTokensRange */, this.doc);
      }
      get shouldRangeHighlight() {
        let { textDocument } = this.doc;
        return languages_default.hasProvider("semanticTokensRange" /* SemanticTokensRange */, textDocument) && this.previousResults == null;
      }
      get lineCount() {
        return this.doc.lineCount;
      }
      get highlights() {
        if (!this._highlights)
          return void 0;
        return this._highlights[1];
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get enabled() {
        if (!this.configEnabled || !workspace_default.env.updateHighlight || !this.hasLegend)
          return false;
        return this.hasProvider;
      }
      checkState() {
        if (!workspace_default.env.updateHighlight)
          throw new Error(`Can't perform highlight update, highlight update requires vim >= 8.1.1719 or neovim >= 0.5.0`);
        if (!this.configEnabled)
          throw new Error(`Semantic tokens highlight not enabled for current filetype: ${this.doc.filetype}`);
        if (this.staticConfig.highlightGroups.length === 0)
          throw new Error(`Unable to find highlight groups starts with CocSem`);
        if (!this.hasProvider || !this.hasLegend)
          throw new Error(`SemanticTokens provider not found for ${this.doc.uri}`);
      }
      async getTokenRanges(tokens, legend, token) {
        let currentLine = 0;
        let currentCharacter = 0;
        let highlights = [];
        let toBytes;
        let textDocument = this.doc.textDocument;
        let tickStart = Date.now();
        for (let i = 0; i < tokens.length; i += 5) {
          if (i == 0 || Date.now() - tickStart > yieldEveryMilliseconds) {
            await waitImmediate();
            if (token.isCancellationRequested)
              break;
            tickStart = Date.now();
          }
          const deltaLine = tokens[i];
          const deltaCharacter = tokens[i + 1];
          const length = tokens[i + 2];
          const tokenType = legend.tokenTypes[tokens[i + 3]];
          const tokenModifiers = legend.tokenModifiers.filter((_, m) => tokens[i + 4] & 1 << m);
          const lnum = currentLine + deltaLine;
          if (deltaLine != 0 || !toBytes) {
            toBytes = bytes(toText(textDocument.lines[lnum]));
          }
          const sc = deltaLine === 0 ? currentCharacter + deltaCharacter : deltaCharacter;
          const ec = sc + length;
          currentLine = lnum;
          currentCharacter = sc;
          this.addHighlightItems(highlights, [lnum, toBytes(sc), toBytes(ec)], tokenType, tokenModifiers);
        }
        if (token.isCancellationRequested)
          return null;
        return highlights;
      }
      addHighlightItems(highlights, range, tokenType, tokenModifiers) {
        let { combinedModifiers } = this.config;
        let { highlightGroups } = this.staticConfig;
        let highlightGroup2;
        let combine = false;
        for (let item of tokenModifiers) {
          let hlGroup = HLGROUP_PREFIX + toHighlightPart(item) + toHighlightPart(tokenType);
          if (highlightGroups.includes(hlGroup)) {
            combine = combinedModifiers.includes(item);
            highlightGroup2 = hlGroup;
            break;
          }
        }
        if (!highlightGroup2) {
          for (let modifier of tokenModifiers) {
            let hlGroup = HLGROUP_PREFIX + toHighlightPart(modifier);
            if (highlightGroups.includes(hlGroup)) {
              highlightGroup2 = hlGroup;
              combine = combinedModifiers.includes(modifier);
              break;
            }
          }
        }
        if (!highlightGroup2) {
          let hlGroup = HLGROUP_PREFIX + toHighlightPart(tokenType);
          if (highlightGroups.includes(hlGroup)) {
            highlightGroup2 = hlGroup;
          }
        }
        highlights.push({
          range,
          tokenType,
          combine,
          hlGroup: highlightGroup2,
          tokenModifiers
        });
      }
      toHighlightItems(highlights, startLine, endLine) {
        let { incrementTypes } = this.config;
        let filter2 = typeof startLine === "number" && typeof endLine === "number";
        let res = [];
        for (let hi of highlights) {
          if (!hi.hlGroup)
            continue;
          let lnum = hi.range[0];
          if (filter2 && (lnum < startLine || lnum >= endLine))
            continue;
          let item = {
            lnum,
            hlGroup: hi.hlGroup,
            colStart: hi.range[1],
            colEnd: hi.range[2],
            combine: hi.combine
          };
          if (incrementTypes.includes(hi.tokenType)) {
            item.end_incl = true;
            item.start_incl = true;
          }
          res.push(item);
        }
        return res;
      }
      async doHighlight(forceFull = false, onShown = false) {
        var _a2;
        this.cancel();
        if (!this.enabled || !onShown && !workspace_default.editors.isVisible(this.bufnr))
          return;
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        let token = tokenSource.token;
        if (this.shouldRangeHighlight) {
          let rangeTokenSource = this.rangeTokenSource = new import_node3.CancellationTokenSource();
          let rangeToken = rangeTokenSource.token;
          await this.doRangeHighlight(rangeToken);
          if (!rangeToken.isCancellationRequested)
            this.rangeTokenSource = void 0;
          if (rangeToken.isCancellationRequested && this.rangeProviderOnly)
            return;
        }
        if (token.isCancellationRequested)
          return;
        const { doc } = this;
        const version2 = doc.version;
        let tokenRanges;
        if (version2 === ((_a2 = this.previousResults) == null ? void 0 : _a2.version)) {
          if (this._highlights && this._highlights[0] == version2) {
            tokenRanges = this._highlights[1];
          } else {
            const tokens = this.previousResults.tokens;
            const legend = languages_default.getLegend(doc.textDocument);
            tokenRanges = await this.getTokenRanges(tokens, legend, token);
          }
        } else {
          tokenRanges = await this.sendRequest(() => {
            return this.requestAllHighlights(token, forceFull);
          }, token);
        }
        if (token.isCancellationRequested || !tokenRanges)
          return;
        this._highlights = [version2, tokenRanges];
        if (!this._dirty || tokenRanges.length < 200) {
          let items = this.toHighlightItems(tokenRanges);
          let diff = await window_default.diffHighlights(this.bufnr, NAMESPACE4, items, void 0, token);
          if (token.isCancellationRequested || !diff)
            return;
          this._dirty = true;
          this._version = version2;
          const priority = this.config.highlightPriority;
          await window_default.applyDiffHighlights(this.bufnr, NAMESPACE4, priority, diff);
        } else {
          this.regions.clear();
          await this.highlightRegions(token);
        }
        if (!token.isCancellationRequested)
          this.tokenSource = void 0;
        this._onDidRefresh.fire();
      }
      async sendRequest(fn, token) {
        try {
          return await fn();
        } catch (e) {
          if (!token.isCancellationRequested) {
            if (e instanceof CancellationError) {
              this.highlight(requestDelay2);
            } else {
              logger52.error("Error on request semanticTokens: ", e);
            }
          }
          return void 0;
        }
      }
      async doRangeHighlight(token) {
        let { version: version2 } = this.doc;
        let res = await this.sendRequest(() => {
          return this.requestRangeHighlights(token);
        }, token);
        if (res == null || token.isCancellationRequested)
          return;
        const { highlights, start, end } = res;
        if (this.rangeProviderOnly || !this.previousResults) {
          if (!this._highlights || version2 !== this._highlights[0]) {
            this._highlights = [version2, []];
          }
          let tokenRanges = this._highlights[1];
          let usedLines = tokenRanges.reduce((p, c) => p.add(c.range[0]), /* @__PURE__ */ new Set());
          highlights.forEach((hi) => {
            if (!usedLines.has(hi.range[0])) {
              tokenRanges.push(hi);
            }
          });
        }
        const items = this.toHighlightItems(highlights);
        let diff = await window_default.diffHighlights(this.bufnr, NAMESPACE4, items, [start, end], token);
        if (diff) {
          const priority = this.config.highlightPriority;
          await window_default.applyDiffHighlights(this.bufnr, NAMESPACE4, priority, diff, true);
          this._dirty = true;
        }
      }
      async highlightRegions(token, skipCheck = false) {
        let { regions, highlights, config, lineCount, bufnr } = this;
        if (!highlights)
          return;
        let spans = await this.nvim.call("coc#window#visible_ranges", [bufnr]);
        if (token.isCancellationRequested || spans.length === 0)
          return;
        let height = workspace_default.env.lines;
        spans.forEach((o) => {
          let s = o[0];
          o[0] = Math.max(0, Math.floor(s - height * 1.5));
          o[1] = Math.min(lineCount, Math.ceil(o[1] + height * 1.5), s + height * 2);
        });
        for (let [start, end] of Regions.mergeSpans(spans)) {
          if (!skipCheck && regions.has(start, end))
            continue;
          let items = this.toHighlightItems(highlights, start, end);
          let diff = await window_default.diffHighlights(bufnr, NAMESPACE4, items, [start, end], token);
          if (token.isCancellationRequested)
            break;
          regions.add(start, end);
          let priority = config.highlightPriority;
          if (diff)
            void window_default.applyDiffHighlights(bufnr, NAMESPACE4, priority, diff, true);
        }
      }
      async onCursorMoved() {
        this.cancel(true);
        if (!this.enabled || this.doc.dirty)
          return;
        let rangeTokenSource = this.rangeTokenSource = new import_node3.CancellationTokenSource();
        let token = rangeTokenSource.token;
        await wait(debounceInterval2);
        if (token.isCancellationRequested)
          return;
        if (this.shouldRangeHighlight) {
          await this.doRangeHighlight(token);
        } else {
          await this.highlightRegions(token);
        }
        if (!token.isCancellationRequested)
          this.rangeTokenSource = void 0;
      }
      async requestRangeHighlights(token) {
        let { nvim, doc } = this;
        let region = await nvim.call("coc#window#visible_range", [this.bufnr]);
        if (!region || token.isCancellationRequested)
          return null;
        let endLine = Math.min(region[0] + workspace_default.env.lines * 2, region[1] + workspace_default.env.lines, doc.lineCount);
        let range = Range.create(region[0] - 1, 0, endLine, 0);
        let res = await languages_default.provideDocumentRangeSemanticTokens(doc.textDocument, range, token);
        if (!res || !SemanticTokens.is(res) || token.isCancellationRequested)
          return null;
        let legend = languages_default.getLegend(doc.textDocument, true);
        let highlights = await this.getTokenRanges(res.data, legend, token);
        if (!highlights)
          return null;
        return { highlights, start: region[0] - 1, end: region[1] };
      }
      async requestAllHighlights(token, forceFull) {
        const textDocument = this.doc.textDocument;
        const legend = languages_default.getLegend(textDocument);
        const hasEditProvider = languages_default.hasSemanticTokensEdits(textDocument);
        const previousResult = forceFull ? null : this.previousResults;
        const version2 = textDocument.version;
        let result;
        if (hasEditProvider && (previousResult == null ? void 0 : previousResult.resultId)) {
          result = await languages_default.provideDocumentSemanticTokensEdits(textDocument, previousResult.resultId, token);
        } else {
          result = await languages_default.provideDocumentSemanticTokens(textDocument, token);
        }
        if (token.isCancellationRequested || result == null)
          return;
        let tokens = [];
        if (SemanticTokens.is(result)) {
          tokens = result.data;
        } else if (previousResult && Array.isArray(result.edits)) {
          tokens = previousResult.tokens;
          result.edits.forEach((e) => {
            tokens.splice(e.start, toNumber(e.deleteCount), ...toArray(e.data));
          });
        }
        this.previousResults = { resultId: result.resultId, tokens, version: version2 };
        return await this.getTokenRanges(tokens, legend, token);
      }
      clearHighlight() {
        this.previousResults = void 0;
        this._highlights = void 0;
        this.regions.clear();
        this.buffer.clearNamespace(NAMESPACE4);
      }
      abandonResult() {
        this.previousResults = void 0;
      }
      cancel(rangeOnly = false) {
        if (this.rangeTokenSource) {
          this.rangeTokenSource.cancel();
          this.rangeTokenSource = null;
        }
        if (rangeOnly)
          return;
        this.regions.clear();
        this.highlight.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.cancel();
        this.clearHighlight();
        this._onDidRefresh.dispose();
      }
    };
  }
});

// src/handler/semanticTokens/index.ts
function getFiletypes() {
  return workspace_default.initialConfiguration.get("semanticTokens.filetypes", null);
}
var headGroup, floatFactory3, SemanticTokens5;
var init_semanticTokens2 = __esm({
  "src/handler/semanticTokens/index.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_highligher();
    init_util();
    init_array();
    init_string();
    init_window();
    init_workspace();
    init_buffer6();
    headGroup = "Statement";
    SemanticTokens5 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.staticConfig = {
          filetypes: getFiletypes(),
          highlightGroups: []
        };
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("semanticTokens")) {
            this.staticConfig.filetypes = getFiletypes();
            for (let item of this.highlighters.items) {
              item.loadConfiguration();
            }
          }
        }, this, this.disposables);
        commands_default.register({
          id: "semanticTokens.checkCurrent",
          execute: async () => {
            await this.showHighlightInfo();
          }
        }, false, "show semantic tokens highlight information of current buffer");
        commands_default.register({
          id: "semanticTokens.refreshCurrent",
          execute: () => {
            return this.highlightCurrent();
          }
        }, false, "refresh semantic tokens highlight of current buffer.");
        commands_default.register({
          id: "semanticTokens.inspect",
          execute: () => {
            return this.inspectSemanticToken();
          }
        }, false, "Inspect semantic token information at cursor position.");
        commands_default.register({
          id: "semanticTokens.clearCurrent",
          execute: async () => {
            let buf = await nvim.buffer;
            buf.clearNamespace(NAMESPACE4, 0, -1);
          }
        }, false, "clear semantic tokens highlight of current buffer");
        commands_default.register({
          id: "semanticTokens.clearAll",
          execute: async () => {
            let bufs = await nvim.buffers;
            for (let buf of bufs) {
              buf.clearNamespace(NAMESPACE4, 0, -1);
            }
          }
        }, false, "clear semantic tokens highlight of all buffers");
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          return new SemanticTokensBuffer(this.nvim, doc, this.staticConfig);
        });
        languages_default.onDidSemanticTokensRefresh(async (selector) => {
          if (isFalsyOrEmpty(this.staticConfig.highlightGroups))
            await this.fetchHighlightGroups();
          let visibleBufs = window_default.visibleTextEditors.map((o) => o.document.bufnr);
          for (let item of this.highlighters.items) {
            if (!workspace_default.match(selector, item.doc))
              continue;
            if (!item.hasProvider) {
              item.clearHighlight();
            } else {
              item.abandonResult();
              if (visibleBufs.includes(item.bufnr)) {
                item.highlight();
              }
            }
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", async (bufnr) => {
          let item = this.highlighters.getItem(bufnr);
          if (item)
            await item.onShown();
        }, null, this.disposables);
        events_default.on("CursorMoved", async (bufnr) => {
          let item = this.highlighters.getItem(bufnr);
          if (item)
            await item.onCursorMoved();
        }, null, this.disposables);
      }
      async inspectSemanticToken() {
        let item = await this.getCurrentItem();
        if (!item || !item.enabled) {
          if (!item) {
            let doc = await workspace_default.document;
            void window_default.showErrorMessage(`Document not attached, ${doc.notAttachReason}`);
          } else {
            try {
              item.checkState();
            } catch (e) {
              void window_default.showErrorMessage(e.message);
            }
          }
          this.closeFloat();
          return;
        }
        let [_, line, col] = await this.nvim.call("getcurpos", []);
        let highlights = toArray(item.highlights);
        let highlight = highlights.find((o) => {
          let column = col - 1;
          return o.range[0] === line - 1 && column >= o.range[1] && column < o.range[2];
        });
        if (highlight) {
          let modifiers = toArray(highlight.tokenModifiers);
          let highlights2 = [];
          if (highlight.hlGroup) {
            let s = "Highlight group: ".length;
            highlights2.push({
              lnum: 2,
              colStart: s,
              colEnd: s + highlight.hlGroup.length,
              hlGroup: highlight.hlGroup
            });
          }
          let docs = [{
            filetype: "txt",
            content: `Type: ${highlight.tokenType}
Modifiers: ${modifiers.join(", ")}
Highlight group: ${toText(highlight.hlGroup)}`,
            highlights: highlights2
          }];
          if (!floatFactory3) {
            floatFactory3 = window_default.createFloatFactory({
              title: "Semantic token info",
              highlight: "Normal",
              borderhighlight: "MoreMsg",
              border: [1, 1, 1, 1]
            });
          }
          await floatFactory3.show(docs, { winblend: 0 });
        } else {
          this.closeFloat();
        }
      }
      closeFloat() {
        floatFactory3 == null ? void 0 : floatFactory3.close();
      }
      async fetchHighlightGroups() {
        let highlightGroups = await this.nvim.call("coc#util#semantic_hlgroups");
        this.staticConfig.highlightGroups = highlightGroups;
      }
      async getCurrentItem() {
        let buf = await this.nvim.buffer;
        return this.getItem(buf.id);
      }
      getItem(bufnr) {
        return this.highlighters.getItem(bufnr);
      }
      async highlightCurrent() {
        let item = await this.getCurrentItem();
        if (!item || !item.enabled)
          throw new Error(`Unable to perform semantic highlights for current buffer.`);
        await this.fetchHighlightGroups();
        await item.forceHighlight();
      }
      async showHighlightInfo() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        workspace_default.getAttachedDocument(bufnr);
        let { nvim } = this;
        let item = this.highlighters.getItem(bufnr);
        let hl = new Highlighter();
        nvim.pauseNotification();
        nvim.command(`vs +setl\\ buftype=nofile __coc_semantic_highlights_${bufnr}__`, true);
        nvim.command(`setl bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1`, true);
        nvim.call("bufnr", ["%"], true);
        let res = await nvim.resumeNotification();
        hl.addLine("Semantic highlights info", headGroup);
        hl.addLine("");
        try {
          item.checkState();
          let highlights = item.highlights ?? [];
          hl.addLine("The number of semantic tokens: ");
          hl.addText(String(highlights.length), "Number");
          hl.addLine("");
          hl.addLine("Semantic highlight groups used by current buffer", headGroup);
          hl.addLine("");
          const groups = distinct(highlights.filter((o) => o.hlGroup != null).map(({ hlGroup }) => hlGroup));
          for (const hlGroup of groups) {
            hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text: hlGroup, hlGroup }]);
          }
          hl.addLine("");
          hl.addLine("Tokens types that current Language Server supported:", headGroup);
          hl.addLine("");
          let doc = workspace_default.getDocument(item.bufnr);
          let legend = languages_default.getLegend(doc.textDocument) ?? languages_default.getLegend(doc.textDocument, true);
          if (legend.tokenTypes.length) {
            for (const t of [...new Set(legend.tokenTypes)]) {
              let text = HLGROUP_PREFIX + upperFirst(t);
              hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text, hlGroup: text }]);
            }
            hl.addLine("");
          } else {
            hl.addLine("No token types supported", "Comment");
            hl.addLine("");
          }
          hl.addLine("Tokens modifiers that current Language Server supported:", headGroup);
          hl.addLine("");
          if (legend.tokenModifiers.length) {
            for (const t of [...new Set(legend.tokenModifiers)]) {
              let text = HLGROUP_PREFIX + upperFirst(t);
              hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text, hlGroup: text }]);
            }
            hl.addLine("");
          } else {
            hl.addLine("No token modifiers exist", "Comment");
            hl.addLine("");
          }
        } catch (e) {
          hl.addLine(toErrorText(e));
        }
        nvim.pauseNotification();
        hl.render(nvim.createBuffer(res[0][2]));
        nvim.resumeNotification(true, true);
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/signature.ts
var debounceTime12, Signature;
var init_signature = __esm({
  "src/handler/signature.ts"() {
    "use strict";
    init_events();
    init_languages();
    init_util();
    init_is();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    debounceTime12 = getConditionValue(100, 10);
    Signature = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        this.signatureFactory = window_default.createFloatFactory(Object.assign({
          preferTop: this.config.preferAbove,
          autoHide: false,
          modes: ["i", "ic", "s"]
        }, this.config.floatConfig));
        this.disposables.push(this.signatureFactory);
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("CursorMovedI", debounce(this.checkCurosr.bind(this), debounceTime12), null, this.disposables);
        events_default.on(["InsertLeave", "BufEnter"], () => {
          var _a2;
          (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
        }, null, this.disposables);
        events_default.on("TextChangedI", () => {
          if (this.config.hideOnChange) {
            this.signatureFactory.close();
          }
        }, null, this.disposables);
        events_default.on("TextInsert", async (bufnr, info, character) => {
          if (!this.config.enableTrigger)
            return;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc || !doc.attached || !languages_default.shouldTriggerSignatureHelp(doc.textDocument, character))
            return;
          await this._triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);
        }, null, this.disposables);
        window_default.onDidChangeActiveTextEditor(() => {
          this.loadConfiguration();
        }, null, this.disposables);
      }
      checkCurosr(bufnr, cursor) {
        let pos = this.lastPosition;
        let floatFactory4 = this.signatureFactory;
        if (!pos || bufnr !== pos.bufnr || floatFactory4.window == null)
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || cursor[0] != pos.lnum || cursor[1] < pos.col) {
          floatFactory4.close();
          return;
        }
        let line = doc.getline(pos.lnum - 1);
        let text = byteSlice(line, pos.col - 1, cursor[1] - 1);
        if (text.endsWith(")"))
          return floatFactory4.close();
      }
      loadConfiguration(e) {
        var _a2;
        if (!e || e.affectsConfiguration("signature")) {
          let doc = (_a2 = window_default.activeTextEditor) == null ? void 0 : _a2.document;
          let config = workspace_default.getConfiguration("signature", doc);
          this.config = {
            target: config.get("target", "float"),
            floatConfig: config.get("floatConfig", {}),
            enableTrigger: config.get("enable", true),
            wait: Math.max(config.get("triggerSignatureWait", 500), 200),
            preferAbove: config.get("preferShownAbove", true),
            hideOnChange: config.get("hideOnTextChange", false)
          };
        }
      }
      async triggerSignatureHelp() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_default.hasProvider("signature" /* Signature */, doc.textDocument))
          return false;
        return await this._triggerSignatureHelp(doc, position, true, 0);
      }
      async _triggerSignatureHelp(doc, position, invoke = true, offset = 0) {
        var _a2;
        (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        let token = tokenSource.token;
        token.onCancellationRequested(() => {
          tokenSource.dispose();
          this.tokenSource = void 0;
        });
        let { target } = this.config;
        let timer = this.timer = setTimeout(() => {
          tokenSource.cancel();
        }, this.config.wait);
        await doc.patchChange(true);
        let signatureHelp = await languages_default.getSignatureHelp(doc.textDocument, position, token, {
          isRetrigger: this.signatureFactory.checkRetrigger(doc.bufnr),
          triggerKind: invoke ? import_node3.SignatureHelpTriggerKind.Invoked : import_node3.SignatureHelpTriggerKind.TriggerCharacter
        });
        clearTimeout(timer);
        if (token.isCancellationRequested)
          return false;
        if (!signatureHelp || signatureHelp.signatures.length == 0) {
          this.signatureFactory.close();
          return false;
        }
        let { activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
          let [active] = signatures.splice(activeSignature, 1);
          if (active)
            signatures.unshift(active);
        }
        if (target == "echo") {
          this.echoSignature(signatureHelp);
        } else {
          await this.showSignatureHelp(doc, position, signatureHelp, offset);
        }
        return true;
      }
      async showSignatureHelp(doc, position, signatureHelp, offset) {
        let { signatures, activeParameter } = signatureHelp;
        activeParameter = typeof activeParameter === "number" ? activeParameter : void 0;
        let paramDoc = null;
        let startOffset = offset;
        let docs = signatures.reduce((p, c, idx) => {
          var _a2, _b;
          let activeIndexes = null;
          let activeIndex = c.activeParameter ?? activeParameter;
          if (activeIndex === void 0 && ((_a2 = c.parameters) == null ? void 0 : _a2.length) > 0) {
            activeIndex = 0;
          }
          let nameIndex = c.label.indexOf("(");
          if (idx == 0 && typeof activeIndex === "number") {
            let active = (_b = c.parameters) == null ? void 0 : _b[activeIndex];
            if (active) {
              let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
              paramDoc = active.documentation;
              if (typeof active.label === "string") {
                let str = after.slice(0);
                let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                let index = ms ? ms.index : str.indexOf(active.label);
                if (index != -1) {
                  activeIndexes = [
                    index + nameIndex,
                    index + active.label.length + nameIndex
                  ];
                }
              } else {
                activeIndexes = active.label;
              }
            }
          }
          if (activeIndexes == null) {
            activeIndexes = [nameIndex + 1, nameIndex + 1];
          }
          if (offset == startOffset) {
            offset = offset + activeIndexes[0] + 1;
          }
          p.push({
            content: c.label,
            filetype: doc.filetype,
            active: activeIndexes
          });
          if (paramDoc) {
            let content2 = typeof paramDoc === "string" ? paramDoc : paramDoc.value;
            if (content2.trim().length) {
              p.push({
                content: content2,
                filetype: isMarkdown(c.documentation) ? "markdown" : "txt"
              });
            }
          }
          if (idx == 0 && c.documentation) {
            let { documentation } = c;
            let content2 = typeof documentation === "string" ? documentation : documentation.value;
            if (content2.trim().length) {
              p.push({
                content: content2,
                filetype: isMarkdown(c.documentation) ? "markdown" : "txt"
              });
            }
          }
          return p;
        }, []);
        let content = doc.getline(position.line, false).slice(0, position.character);
        this.lastPosition = { bufnr: doc.bufnr, lnum: position.line + 1, col: byteLength(content) + 1 };
        await this.signatureFactory.show(docs, { offsetX: offset });
      }
      echoSignature(signatureHelp) {
        var _a2;
        let { signatures, activeParameter } = signatureHelp;
        let columns = workspace_default.env.columns;
        signatures = signatures.slice(0, workspace_default.env.cmdheight);
        let signatureList = [];
        for (let signature of signatures) {
          let parts = [];
          let { label } = signature;
          label = label.replace(/\n/g, " ");
          if (label.length >= columns - 16) {
            label = label.slice(0, columns - 16) + "...";
          }
          let nameIndex = label.indexOf("(");
          if (nameIndex == -1) {
            parts = [{ text: label, type: "Normal" }];
          } else {
            parts.push({
              text: label.slice(0, nameIndex),
              type: "Label"
            });
            let after = label.slice(nameIndex);
            if (signatureList.length == 0 && activeParameter != null) {
              let active = (_a2 = signature.parameters) == null ? void 0 : _a2[activeParameter];
              if (active) {
                let start;
                let end;
                if (typeof active.label === "string") {
                  let str = after.slice(0);
                  let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                  let idx = ms ? ms.index : str.indexOf(active.label);
                  if (idx == -1) {
                    parts.push({ text: after, type: "Normal" });
                  } else {
                    start = idx;
                    end = idx + active.label.length;
                  }
                } else {
                  [start, end] = active.label;
                  start = start - nameIndex;
                  end = end - nameIndex;
                }
                if (start != null && end != null) {
                  parts.push({ text: after.slice(0, start), type: "Normal" });
                  parts.push({ text: after.slice(start, end), type: "MoreMsg" });
                  parts.push({ text: after.slice(end), type: "Normal" });
                }
              }
            } else {
              parts.push({
                text: after,
                type: "Normal"
              });
            }
          }
          signatureList.push(parts);
        }
        this.nvim.callTimer("coc#ui#echo_signatures", [signatureList], true);
      }
      dispose() {
        disposeAll(this.disposables);
        if (this.timer) {
          clearTimeout(this.timer);
        }
      }
    };
  }
});

// src/handler/symbols/buffer.ts
var logger53, DEBEBOUNCE_INTERVAL, SymbolsBuffer;
var init_buffer7 = __esm({
  "src/handler/symbols/buffer.ts"() {
    "use strict";
    init_languages();
    init_logger();
    init_util();
    init_node();
    init_protocol();
    init_util6();
    logger53 = createLogger("symbols-buffer");
    DEBEBOUNCE_INTERVAL = getConditionValue(500, 10);
    SymbolsBuffer = class {
      constructor(doc, autoUpdateBufnrs) {
        this.doc = doc;
        this.autoUpdateBufnrs = autoUpdateBufnrs;
        this.disposables = [];
        this._onDidUpdate = new import_node3.Emitter();
        this.onDidUpdate = this._onDidUpdate.event;
        this.fetchSymbols = debounce(() => {
          this._fetchSymbols().catch(handleError);
        }, DEBEBOUNCE_INTERVAL);
      }
      async getSymbols() {
        var _a2;
        let { doc } = this;
        await doc.patchChange();
        this.autoUpdateBufnrs.add(doc.bufnr);
        if (doc.version == this.version && ((_a2 = this.symbols) == null ? void 0 : _a2.length))
          return this.symbols;
        this.cancel();
        await this._fetchSymbols();
        return this.symbols;
      }
      onChange(e) {
        if (e.contentChanges.length === 0)
          return;
        this.cancel();
        if (this.autoUpdateBufnrs.has(this.doc.bufnr)) {
          this.fetchSymbols();
        }
      }
      async _fetchSymbols() {
        let { textDocument } = this.doc;
        let { version: version2 } = textDocument;
        let tokenSource = this.tokenSource = new import_node3.CancellationTokenSource();
        let { token } = tokenSource;
        let symbols = await languages_default.getDocumentSymbol(textDocument, token);
        this.tokenSource = void 0;
        if (symbols == null || token.isCancellationRequested)
          return;
        this.version = version2;
        this.symbols = symbols;
        this._onDidUpdate.fire(symbols);
      }
      cancel() {
        this.fetchSymbols.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.cancel();
        this.symbols = void 0;
        this._onDidUpdate.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/BasicDataProvider.ts
function isIcon(obj) {
  if (!obj)
    return false;
  return typeof obj.text === "string" && typeof obj.hlGroup === "string";
}
function sameTreeNode(one, two) {
  if (one.label === two.label && one.deprecated === two.deprecated && one.key === two.key) {
    return true;
  }
  return false;
}
function sameTreeNodes(one, two) {
  if (one.length !== two.length)
    return false;
  return one.every((v, idx) => sameTreeNode(v, two[idx]));
}
var BasicDataProvider;
var init_BasicDataProvider = __esm({
  "src/tree/BasicDataProvider.ts"() {
    "use strict";
    init_esm_node();
    init_protocol();
    init_commands();
    init_util();
    init_TreeItem();
    init_array();
    BasicDataProvider = class {
      constructor(opts) {
        this.opts = opts;
        this.disposables = [];
        this._onDidChangeTreeData = new import_node3.Emitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.invokeCommand = `_invoke_${v4_default()}`;
        this.disposables.push(commands_default.registerCommand(this.invokeCommand, async (node) => {
          await opts.handleClick(node);
        }, null, true));
        if (typeof opts.resolveActions === "function") {
          this.resolveActions = opts.resolveActions.bind(this);
        }
      }
      iterate(node, parentNode, level2, fn) {
        let res = fn(node, parentNode, level2);
        if (res === false)
          return false;
        if (Array.isArray(node.children)) {
          for (let element of node.children) {
            let res2 = this.iterate(element, node, level2 + 1, fn);
            if (res2 === false)
              return false;
          }
        }
        return res;
      }
      updateNodes(old, data, parentNode, fireEvent = true) {
        let sameNodes = sameTreeNodes(old, data);
        const applyNode = (previous, curr, fireEvent2) => {
          var _a2, _b, _c, _d;
          let changed = false;
          for (let key of Object.keys(curr)) {
            if (["children", "key"].includes(key))
              continue;
            previous[key] = curr[key];
          }
          if (((_a2 = previous.children) == null ? void 0 : _a2.length) && !((_b = curr.children) == null ? void 0 : _b.length)) {
            delete previous.children;
            changed = true;
          }
          if (!((_c = previous.children) == null ? void 0 : _c.length) && ((_d = curr.children) == null ? void 0 : _d.length)) {
            previous.children = curr.children;
            changed = true;
          }
          if (changed) {
            if (fireEvent2)
              this._onDidChangeTreeData.fire(previous);
            return;
          }
          if (toArray(previous.children).length > 0 && toArray(curr.children).length > 0) {
            this.updateNodes(previous.children, curr.children, previous, fireEvent2);
          }
        };
        if (sameNodes) {
          for (let i = 0; i < old.length; i++) {
            applyNode(old[i], data[i], fireEvent);
          }
        } else {
          let oldNodes = old.splice(0, old.length);
          let used = /* @__PURE__ */ new Set();
          for (let i = 0; i < data.length; i++) {
            let curr = data[i];
            let findIndex;
            if (curr.key) {
              findIndex = oldNodes.findIndex((o, i2) => !used.has(i2) && o.key == curr.key);
            } else {
              findIndex = oldNodes.findIndex((o, i2) => !used.has(i2) && o.label == curr.label);
            }
            if (findIndex === -1) {
              old[i] = curr;
            } else {
              used.add(findIndex);
              let previous = oldNodes[findIndex];
              applyNode(previous, curr, false);
              old[i] = previous;
            }
          }
          if (fireEvent) {
            this._onDidChangeTreeData.fire(parentNode);
          }
        }
      }
      update(data, reset) {
        if (!this.data)
          return;
        if (reset) {
          this.data = toArray(data);
          this._onDidChangeTreeData.fire(void 0);
        } else {
          this.updateNodes(this.data, toArray(data), void 0);
        }
        return this.data;
      }
      getTreeItem(node) {
        var _a2;
        let label = node.label;
        let { expandLevel } = this.opts;
        let item;
        if (!((_a2 = node.children) == null ? void 0 : _a2.length)) {
          item = new TreeItem(label);
        } else {
          if (expandLevel && expandLevel > 0) {
            let level2 = this.getLevel(node);
            let state = level2 && level2 <= expandLevel ? 2 /* Expanded */ : 1 /* Collapsed */;
            item = new TreeItem(label, state);
          } else {
            item = new TreeItem(label, 1 /* Collapsed */);
          }
        }
        item.description = node.description;
        if (node.deprecated)
          item.deprecated = true;
        if (node.tooltip)
          item.tooltip = node.tooltip;
        if (isIcon(node.icon)) {
          item.icon = node.icon;
        } else if (typeof this.opts.resolveIcon === "function") {
          let res = this.opts.resolveIcon(node);
          if (res)
            item.icon = res;
        }
        return item;
      }
      async getChildren(element) {
        if (element)
          return element.children ?? [];
        if (this.data)
          return this.data;
        let data = await Promise.resolve(this.opts.provideData());
        if (!Array.isArray(data))
          throw new Error(`Unable to fetch data`);
        this.data = data;
        return data;
      }
      getParent(element) {
        if (!this.data)
          return void 0;
        let find;
        for (let item of this.data) {
          let res = this.iterate(item, null, 0, (node, parentNode) => {
            if (node === element) {
              find = parentNode;
              return false;
            }
          });
          if (res === false)
            break;
        }
        return find;
      }
      getLevel(element) {
        if (!this.data)
          return 0;
        let level2 = 0;
        for (let item of toArray(this.data)) {
          let res = this.iterate(item, null, 1, (node, _parentNode, l) => {
            if (node === element) {
              level2 = l;
              return false;
            }
          });
          if (res === false)
            break;
        }
        return level2;
      }
      async resolveTreeItem(item, element, token) {
        if (typeof this.opts.resolveItem === "function") {
          let res = await Promise.resolve(this.opts.resolveItem(item, element, token));
          if (res)
            Object.assign(item, res);
        }
        if (!item.command) {
          item.command = {
            title: `invoke ${element.label}`,
            command: this.invokeCommand,
            arguments: [element]
          };
        }
        return item;
      }
      dispose() {
        this.data = [];
        this._onDidChangeTreeData.dispose();
        if (typeof this.opts.onDispose === "function") {
          this.opts.onDispose();
        }
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/symbols/outline.ts
function getNodeByPosition(position, nodes) {
  let curr;
  let checkNodes = (nodes2) => {
    for (let node of nodes2) {
      if (positionInRange(position, node.range) == 0) {
        curr = node;
        if (Array.isArray(node.children)) {
          checkNodes(node.children);
        }
        break;
      }
    }
  };
  checkNodes(nodes);
  return curr;
}
var hoverTimeout, SymbolsOutline;
var init_outline2 = __esm({
  "src/handler/symbols/outline.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_BasicDataProvider();
    init_TreeView();
    init_util();
    init_position();
    init_window();
    init_workspace();
    hoverTimeout = getConditionValue(300, 10);
    SymbolsOutline = class {
      constructor(nvim, buffers, handler) {
        this.nvim = nvim;
        this.buffers = buffers;
        this.handler = handler;
        this.treeViewList = [];
        this.providersMap = /* @__PURE__ */ new Map();
        this.sortByMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        workspace_default.onDidCloseTextDocument(async (e) => {
          let { bufnr } = e;
          let provider = this.providersMap.get(bufnr);
          if (!provider)
            return;
          let loaded = await nvim.call("bufloaded", [bufnr]);
          if (loaded)
            return;
          this.providersMap.delete(bufnr);
          provider.dispose();
        }, null, this.disposables);
        window_default.onDidChangeActiveTextEditor(async (editor) => {
          if (!this.config.checkBufferSwitch)
            return;
          let view = this.treeViewList.find((v) => v.visible && v.targetTabId == editor.tabpageid);
          if (view) {
            await this.showOutline(editor.document.bufnr, editor.tabpageid);
            await nvim.command(`noa call win_gotoid(${editor.winid})`);
          }
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr, cursor) => {
          if (!this.config.followCursor)
            return;
          let provider = this.providersMap.get(bufnr);
          if (!provider)
            return;
          let tabpage = await nvim.tabpage;
          let view = this.treeViewList.find((o) => o.visible && o.targetBufnr == bufnr && o.targetTabId == tabpage.id);
          if (!view)
            return;
          await this.revealPosition(bufnr, view, Position.create(cursor[0] - 1, cursor[1] - 1));
        }, null, this.disposables);
      }
      async revealPosition(bufnr, treeView, position) {
        let provider = this.providersMap.get(bufnr);
        let nodes = await Promise.resolve(provider.getChildren());
        let curr = getNodeByPosition(position, nodes);
        if (curr)
          await treeView.reveal(curr);
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("outline")) {
          let c = workspace_default.getConfiguration("outline", null);
          this.config = {
            splitCommand: c.get("splitCommand"),
            switchSortKey: c.get("switchSortKey"),
            togglePreviewKey: c.get("togglePreviewKey"),
            followCursor: c.get("followCursor"),
            keepWindow: c.get("keepWindow"),
            expandLevel: c.get("expandLevel"),
            autoWidth: c.get("autoWidth"),
            checkBufferSwitch: c.get("checkBufferSwitch"),
            detailAsDescription: c.get("detailAsDescription"),
            sortBy: c.get("sortBy"),
            showLineNumber: c.get("showLineNumber"),
            codeActionKinds: c.get("codeActionKinds"),
            autoPreview: c.get("autoPreview"),
            previewMaxWidth: c.get("previewMaxWidth"),
            previewBorder: c.get("previewBorder"),
            previewBorderRounded: c.get("previewBorderRounded"),
            previewHighlightGroup: c.get("previewHighlightGroup"),
            previewBorderHighlightGroup: c.get("previewBorderHighlightGroup"),
            previewWinblend: c.get("previewWinblend")
          };
        }
      }
      convertSymbolToNode(documentSymbol, sortFn) {
        var _a2;
        let descs = [];
        let { detailAsDescription, showLineNumber } = this.config;
        if (detailAsDescription && documentSymbol.detail)
          descs.push(documentSymbol.detail);
        if (showLineNumber)
          descs.push(`${documentSymbol.selectionRange.start.line + 1}`);
        return {
          label: documentSymbol.name,
          tooltip: detailAsDescription ? void 0 : documentSymbol.detail,
          description: descs.join(" "),
          icon: this.handler.getIcon(documentSymbol.kind),
          deprecated: (_a2 = documentSymbol.tags) == null ? void 0 : _a2.includes(SymbolTag.Deprecated),
          kind: documentSymbol.kind,
          range: documentSymbol.range,
          selectRange: documentSymbol.selectionRange,
          children: Array.isArray(documentSymbol.children) ? documentSymbol.children.map((o) => {
            return this.convertSymbolToNode(o, sortFn);
          }).sort(sortFn) : void 0
        };
      }
      setMessage(bufnr, msg) {
        this.treeViewList.forEach((v) => {
          if (v.valid && v.targetBufnr == bufnr) {
            v.message = msg;
          }
        });
      }
      convertSymbols(bufnr, symbols) {
        let sortBy = this.getSortBy(bufnr);
        let sortFn = (a, b) => {
          if (sortBy === "name") {
            return a.label < b.label ? -1 : 1;
          }
          if (sortBy === "category") {
            if (a.kind == b.kind)
              return a.label < b.label ? -1 : 1;
            return a.kind - b.kind;
          }
          return comparePosition(a.selectRange.start, b.selectRange.start);
        };
        return symbols.map((s) => this.convertSymbolToNode(s, sortFn)).sort(sortFn);
      }
      onSymbolsUpdate(bufnr, symbols) {
        let provider = this.providersMap.get(bufnr);
        if (provider)
          provider.update(this.convertSymbols(bufnr, symbols));
      }
      createProvider(bufnr) {
        let { nvim } = this;
        let provider = new BasicDataProvider({
          expandLevel: this.config.expandLevel,
          provideData: async () => {
            let buf = this.buffers.getItem(bufnr);
            if (!buf)
              throw new Error("Document not attached");
            let doc = workspace_default.getDocument(bufnr);
            if (!languages_default.hasProvider("documentSymbol" /* DocumentSymbol */, doc.textDocument)) {
              throw new Error("Document symbol provider not found");
            }
            let meta = languages_default.getDocumentSymbolMetadata(doc.textDocument);
            if (meta && meta.label) {
              let views = this.treeViewList.filter((v) => v.valid && v.targetBufnr == bufnr);
              views.forEach((view) => view.description = meta.label);
            }
            this.setMessage(bufnr, "Loading document symbols");
            let arr = await buf.getSymbols();
            if (!arr || arr.length == 0) {
              throw new Error("Empty symbols returned from language server. ");
            }
            this.setMessage(bufnr, void 0);
            return this.convertSymbols(bufnr, arr);
          },
          handleClick: async (item) => {
            let winnr = await nvim.call("bufwinnr", [bufnr]);
            if (winnr == -1)
              return;
            nvim.pauseNotification();
            nvim.command(`${winnr}wincmd w`, true);
            let pos = item.selectRange.start;
            nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
            nvim.command(`normal! zz`, true);
            let buf = nvim.createBuffer(bufnr);
            buf.highlightRanges("outline-hover", "CocHoverRange", [item.selectRange]);
            nvim.command("redraw", true);
            await nvim.resumeNotification();
            setTimeout(() => {
              buf.clearNamespace("outline-hover");
              nvim.command("redraw", true);
            }, hoverTimeout);
          },
          resolveActions: async (_, element) => {
            let winnr = await nvim.call("bufwinnr", [bufnr]);
            if (winnr == -1)
              return;
            let doc = workspace_default.getDocument(bufnr);
            let actions = await this.handler.getCodeActions(doc, element.range, this.config.codeActionKinds);
            let arr = actions.map((o) => {
              return {
                title: o.title,
                handler: async () => {
                  let position = element.range.start;
                  await nvim.command(`${winnr}wincmd w`);
                  await this.nvim.call("coc#cursor#move_to", [position.line, position.character]);
                  await this.handler.applyCodeAction(o);
                }
              };
            });
            return [...arr, {
              title: "Visual Select",
              handler: async (item) => {
                await nvim.command(`${winnr}wincmd w`);
                await window_default.selectRange(item.range);
              }
            }];
          },
          onDispose: () => {
            for (let view of this.treeViewList.slice()) {
              if (view.provider === provider) {
                view.dispose();
              }
            }
          }
        });
        return provider;
      }
      getSortBy(bufnr) {
        return this.sortByMap.get(bufnr) ?? this.config.sortBy;
      }
      async showOutline(bufnr, tabId) {
        if (!this.providersMap.has(bufnr)) {
          this.providersMap.set(bufnr, this.createProvider(bufnr));
        }
        let treeView = this.treeViewList.find((v) => v.valid && v.targetBufnr == bufnr && v.targetTabId == tabId);
        if (!treeView) {
          let { switchSortKey, togglePreviewKey } = this.config;
          let autoPreview = this.config.autoPreview;
          let previewBufnr;
          treeView = new BasicTreeView("OUTLINE", {
            autoWidth: this.config.autoWidth,
            bufhidden: "hide",
            enableFilter: true,
            treeDataProvider: this.providersMap.get(bufnr)
          });
          let sortBy = this.getSortBy(bufnr);
          let prev;
          treeView.description = `${sortBy[0].toUpperCase()}${sortBy.slice(1)}`;
          this.treeViewList.push(treeView);
          let disposable = events_default.on("BufEnter", (bufnr2) => {
            if (previewBufnr && bufnr2 !== previewBufnr) {
              prev = void 0;
              this.closePreview();
            }
          });
          treeView.onDispose(() => {
            let idx = this.treeViewList.findIndex((v) => v === treeView);
            if (idx !== -1)
              this.treeViewList.splice(idx, 1);
            disposable.dispose();
            this.closePreview();
          });
          treeView.onDidCursorMoved(async (node) => {
            if (autoPreview && prev !== node) {
              prev = node;
              previewBufnr = await this.doPreview(bufnr, node);
            }
          });
          treeView.registerLocalKeymap("n", switchSortKey, async () => {
            let arr = ["category", "name", "position"];
            let curr = this.getSortBy(bufnr);
            let items = arr.map((s) => {
              return { text: s, disabled: s === curr };
            });
            let res = await window_default.showMenuPicker(items, { title: "Choose sort method" });
            if (res < 0)
              return;
            let sortBy2 = arr[res];
            this.sortByMap.set(bufnr, sortBy2);
            let views = this.treeViewList.filter((o) => o.targetBufnr == bufnr);
            views.forEach((view) => {
              view.description = `${sortBy2[0].toUpperCase()}${sortBy2.slice(1)}`;
            });
            let item = this.buffers.getItem(bufnr);
            this.onSymbolsUpdate(bufnr, item.symbols);
          }, true);
          treeView.registerLocalKeymap("n", togglePreviewKey, async (node) => {
            autoPreview = !autoPreview;
            if (!autoPreview) {
              prev = void 0;
              this.closePreview();
            } else {
              previewBufnr = await this.doPreview(bufnr, node);
            }
          }, true);
        }
        await treeView.show(this.config.splitCommand, false);
        return treeView;
      }
      async doPreview(bufnr, node) {
        if (!node) {
          this.closePreview();
          return;
        }
        let config = {
          bufnr,
          range: node.range,
          border: this.config.previewBorder,
          rounded: this.config.previewBorderRounded,
          maxWidth: this.config.previewMaxWidth,
          highlight: this.config.previewHighlightGroup,
          borderhighlight: this.config.previewBorderHighlightGroup,
          winblend: this.config.previewWinblend
        };
        return await this.nvim.call("coc#ui#outline_preview", [config]);
      }
      closePreview() {
        this.nvim.call("coc#ui#outline_close_preview", [], true);
      }
      async show(keep) {
        let [bufnr, winid] = await this.nvim.eval('[bufnr("%"),win_getid()]');
        let tabpage = await this.nvim.tabpage;
        let doc = workspace_default.getDocument(bufnr);
        if (doc && !doc.attached) {
          void window_default.showErrorMessage(`Unable to show outline, ${doc.notAttachReason}`);
          return;
        }
        let position = await window_default.getCursorPosition();
        let treeView = await this.showOutline(bufnr, tabpage.id);
        if (keep == 1 || keep === void 0 && this.config.keepWindow) {
          await this.nvim.command(`noa call win_gotoid(${winid})`);
        } else if (this.config.followCursor) {
          let disposable = treeView.onDidRefrash(async () => {
            disposable.dispose();
            let curr = await this.nvim.eval('bufnr("%")');
            if (curr == bufnr && treeView.visible) {
              await this.revealPosition(bufnr, treeView, position);
            }
          });
        }
      }
      has(bufnr) {
        return this.providersMap.has(bufnr);
      }
      async hide() {
        let winid = await this.nvim.call("coc#window#find", ["cocViewId", "OUTLINE"]);
        if (winid == -1)
          return;
        await this.nvim.call("coc#window#close", [winid]);
      }
      dispose() {
        for (let view of this.treeViewList) {
          view.dispose();
        }
        this.treeViewList = [];
        for (let provider of this.providersMap.values()) {
          provider.dispose();
        }
        this.providersMap.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/symbols/util.ts
function convertSymbols(symbols) {
  let res = [];
  let arr = symbols.slice();
  arr.sort(sortDocumentSymbols);
  arr.forEach((s) => addDocumentSymbol(res, s, 0));
  return res;
}
function sortDocumentSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  return comparePosition(ra.start, rb.start);
}
function addDocumentSymbol(res, sym, level2) {
  let { name: name2, selectionRange, detail, kind, children, range, tags } = sym;
  let { start } = selectionRange || range;
  let obj = {
    col: start.character + 1,
    lnum: start.line + 1,
    text: name2,
    level: level2,
    kind: getSymbolKind(kind),
    range,
    selectionRange
  };
  if (detail)
    obj.detail = detail;
  if (tags && tags.includes(SymbolTag.Deprecated))
    obj.deprecated = true;
  res.push(obj);
  if (children && children.length) {
    children.sort(sortDocumentSymbols);
    for (let sym2 of children) {
      addDocumentSymbol(res, sym2, level2 + 1);
    }
  }
}
var init_util7 = __esm({
  "src/handler/symbols/util.ts"() {
    "use strict";
    init_main();
    init_convert();
    init_position();
  }
});

// src/handler/symbols/index.ts
var Symbols2;
var init_symbols2 = __esm({
  "src/handler/symbols/index.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_util();
    init_object();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_buffer7();
    init_outline2();
    init_util7();
    Symbols2 = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.autoUpdateBufnrs = /* @__PURE__ */ new Set();
        this.buffers = workspace_default.registerBufferSync((doc) => {
          let { bufnr } = doc;
          let buf = new SymbolsBuffer(doc, this.autoUpdateBufnrs);
          buf.onDidUpdate((symbols) => {
            if (!this.outline)
              return;
            this.outline.onSymbolsUpdate(bufnr, symbols);
          });
          return buf;
        });
        this.outline = new SymbolsOutline(nvim, this.buffers, handler);
        events_default.on("CursorHold", async (bufnr, cursor) => {
          if (!this.buffers.getItem(bufnr) || !this.autoUpdate(bufnr))
            return;
          let doc = workspace_default.getDocument(bufnr);
          let character = characterIndex(doc.getline(cursor[0] - 1), cursor[1] - 1);
          let pos = Position.create(cursor[0] - 1, character);
          let func2 = await this.getFunctionSymbol(bufnr, pos);
          let buffer = nvim.createBuffer(bufnr);
          buffer.setVar("coc_current_function", func2 ?? "", true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
        }, null, this.disposables);
        events_default.on("InsertEnter", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.cancel();
        }, null, this.disposables);
      }
      autoUpdate(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        let config = workspace_default.getConfiguration("coc.preferences", doc);
        return config.get("currentFunctionSymbolAutoUpdate", false);
      }
      get labels() {
        return workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
      }
      async getWorkspaceSymbols(input) {
        this.handler.checkProvider("workspaceSymbols" /* WorkspaceSymbols */, null);
        let tokenSource = new import_node3.CancellationTokenSource();
        return await languages_default.getWorkspaceSymbols(input, tokenSource.token);
      }
      async resolveWorkspaceSymbol(symbolInfo) {
        var _a2;
        if ((_a2 = symbolInfo.location) == null ? void 0 : _a2.uri)
          return symbolInfo;
        let tokenSource = new import_node3.CancellationTokenSource();
        return await languages_default.resolveWorkspaceSymbol(symbolInfo, tokenSource.token);
      }
      async getDocumentSymbols(bufnr) {
        if (!bufnr) {
          bufnr = await this.nvim.call("bufnr", ["%"]);
          let doc = workspace_default.getDocument(bufnr);
          if (!doc || !doc.attached)
            return void 0;
        }
        let buf = this.buffers.getItem(bufnr);
        if (!buf)
          return;
        let res = await buf.getSymbols();
        return res ? convertSymbols(res) : void 0;
      }
      async getFunctionSymbol(bufnr, position) {
        let symbols = await this.getDocumentSymbols(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        if (!symbols || symbols.length === 0) {
          buffer.setVar("coc_current_function", "", true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          return "";
        }
        symbols = symbols.filter((s) => [
          "Class",
          "Method",
          "Function",
          "Struct"
        ].includes(s.kind));
        let functionName = "";
        let labels = this.labels;
        for (let sym of symbols.reverse()) {
          if (sym.range && positionInRange(position, sym.range) == 0 && !sym.text.endsWith(") callback")) {
            functionName = sym.text;
            let label = labels[sym.kind.toLowerCase()];
            if (label)
              functionName = `${label} ${functionName}`;
            break;
          }
        }
        return functionName;
      }
      async getCurrentFunctionSymbol() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || !languages_default.hasProvider("documentSymbol" /* DocumentSymbol */, doc.textDocument))
          return;
        let position = await window_default.getCursorPosition();
        return await this.getFunctionSymbol(bufnr, position);
      }
      async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentSymbol" /* DocumentSymbol */, doc.textDocument);
        let range;
        if (visualmode) {
          range = await window_default.getSelectedRange(visualmode);
        } else {
          let pos = await window_default.getCursorPosition();
          range = Range.create(pos, pos);
        }
        let symbols = await this.getDocumentSymbols(doc.bufnr);
        if (!symbols || symbols.length === 0) {
          void window_default.showWarningMessage("No symbols found");
          return;
        }
        symbols = symbols.filter((s) => supportedSymbols.includes(s.kind));
        let selectRange2;
        for (let sym of symbols.reverse()) {
          if (sym.range && !equals(sym.range, range) && rangeInRange(range, sym.range)) {
            selectRange2 = sym.range;
            break;
          }
        }
        if (inner && selectRange2) {
          let { start, end } = selectRange2;
          let line = doc.getline(start.line + 1);
          let endLine = doc.getline(end.line - 1);
          selectRange2 = Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
        }
        if (selectRange2) {
          await window_default.selectRange(selectRange2);
        } else if (["v", "V", ""].includes(visualmode)) {
          await this.nvim.command("normal! gv");
        }
      }
      async showOutline(keep) {
        await this.outline.show(keep);
      }
      async hideOutline() {
        await this.outline.hide();
      }
      hasOutline(bufnr) {
        return this.outline.has(bufnr);
      }
      dispose() {
        this.outline.dispose();
        this.buffers.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/typeHierarchy.ts
function toTypeHierarchyItem(item) {
  return omit(item, ["children", "parent"]);
}
function getTitle2(kind) {
  return kind === "supertypes" ? "Super types" : "Sub types";
}
var _TypeHierarchyHandler, TypeHierarchyHandler;
var init_typeHierarchy2 = __esm({
  "src/handler/typeHierarchy.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_LocationsDataProvider();
    init_TreeView();
    init_util();
    init_array();
    init_lodash();
    init_window();
    init_workspace();
    _TypeHierarchyHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = /* @__PURE__ */ new Set();
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("BufWinEnter", (_, winid) => {
          if (this.highlightWinids.has(winid)) {
            this.highlightWinids.delete(winid);
            let win = nvim.createWindow(winid);
            win.clearMatchGroup(_TypeHierarchyHandler.rangesHighlight);
          }
        }, null, this.disposables);
        this.disposables.push(commands_default.registerCommand(_TypeHierarchyHandler.commandId, async (winid, item, openCommand) => {
          let { nvim: nvim2 } = this;
          await nvim2.call("win_gotoid", [winid]);
          await workspace_default.jumpTo(item.uri, item.range.start, openCommand);
          let win = await nvim2.window;
          win.clearMatchGroup(_TypeHierarchyHandler.rangesHighlight);
          win.highlightRanges(_TypeHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
          this.highlightWinids.add(win.id);
        }, null, true));
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("typeHierarchy")) {
          let c = workspace_default.getConfiguration("typeHierarchy", null);
          this.config = {
            splitCommand: c.get("splitCommand"),
            openCommand: c.get("openCommand"),
            enableTooltip: c.get("enableTooltip")
          };
        }
      }
      createProvider(rootItems, winid, kind) {
        let provider = new LocationsDataProvider(
          kind,
          winid,
          this.config,
          _TypeHierarchyHandler.commandId,
          rootItems,
          (kind2) => this.handler.getIcon(kind2),
          (el, meta, token) => this.getChildren(el, meta, token)
        );
        provider.addAction(`Show Super Types`, (el) => {
          provider.meta = "supertypes";
          let rootItems2 = [omit(el, ["children", "parent"])];
          provider.reset(rootItems2);
        });
        provider.addAction(`Show Sub Types`, (el) => {
          provider.meta = "subtypes";
          let rootItems2 = [omit(el, ["children", "parent"])];
          provider.reset(rootItems2);
        });
        return provider;
      }
      async getChildren(item, kind, token) {
        let res = [];
        let typeHierarchyItem = toTypeHierarchyItem(item);
        if (kind == "supertypes") {
          res = await languages_default.provideTypeHierarchySupertypes(typeHierarchyItem, token);
        } else {
          res = await languages_default.provideTypeHierarchySubtypes(typeHierarchyItem, token);
        }
        return res;
      }
      async prepare(doc, position) {
        this.handler.checkProvider("typeHierarchy" /* TypeHierarchy */, doc);
        return await this.handler.withRequestToken("typeHierarchy", async (token) => {
          return await languages_default.prepareTypeHierarchy(doc, position, token);
        }, false);
      }
      async showTypeHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        const rootItems = await this.prepare(doc.textDocument, position);
        if (isFalsyOrEmpty(rootItems)) {
          void window_default.showWarningMessage("Unable to get TypeHierarchyItems at cursor position.");
          return;
        }
        let provider = this.createProvider(rootItems, winid, kind);
        let treeView = new BasicTreeView("types", { treeDataProvider: provider });
        treeView.title = getTitle2(kind);
        provider.onDidChangeTreeData((e) => {
          if (!e)
            treeView.title = getTitle2(provider.meta);
        });
        treeView.onDidChangeVisibility((e) => {
          if (!e.visible)
            provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
      }
      dispose() {
        this.highlightWinids.clear();
        disposeAll(this.disposables);
      }
    };
    TypeHierarchyHandler = _TypeHierarchyHandler;
    TypeHierarchyHandler.rangesHighlight = "CocSelectedRange";
    TypeHierarchyHandler.commandId = "typeHierarchy.reveal";
  }
});

// src/handler/workspace.ts
var import_v8, WorkspaceHandler;
var init_workspace2 = __esm({
  "src/handler/workspace.ts"() {
    "use strict";
    init_esm_node();
    import_v8 = require("v8");
    init_esm();
    init_commands();
    init_workspaceFolder();
    init_extension();
    init_languages();
    init_logger();
    init_highligher();
    init_manager4();
    init_util();
    init_constants();
    init_errors();
    init_fs();
    init_is();
    init_node();
    init_string();
    init_window();
    init_workspace();
    WorkspaceHandler = class {
      constructor(nvim) {
        this.nvim = nvim;
        Object.defineProperty(window_default, "openLocalConfig", {
          get: () => this.openLocalConfig.bind(this)
        });
        commands_default.register({
          id: "workspace.openLocation",
          execute: async (winid, loc, openCommand) => {
            if (winid)
              await nvim.call("win_gotoid", [winid]);
            await workspace_default.jumpTo(loc.uri, loc.range.start, openCommand);
          }
        }, true);
        commands_default.register({
          id: "workspace.undo",
          execute: async () => {
            await workspace_default.files.undoWorkspaceEdit();
          }
        }, false, "Undo previous this.workspace edit");
        commands_default.register({
          id: "workspace.redo",
          execute: async () => {
            await workspace_default.files.redoWorkspaceEdit();
          }
        }, false, "Redo previous this.workspace edit");
        commands_default.register({
          id: "workspace.inspectEdit",
          execute: async () => {
            await workspace_default.files.inspectEdit();
          }
        }, false, "Inspect previous this.workspace edit in new tab");
        commands_default.register({
          id: "workspace.renameCurrentFile",
          execute: async () => {
            await this.renameCurrent();
          }
        }, false, "change current filename to a new name and reload it.");
        commands_default.register({
          id: "document.checkBuffer",
          execute: async () => {
            await this.bufferCheck();
          }
        }, false, "Check providers for current buffer.");
        commands_default.register({
          id: "document.echoFiletype",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getAttachedDocument(bufnr);
            await window_default.echoLines([doc.filetype]);
          }
        }, false, "echo the mapped filetype of the current buffer");
        commands_default.register({
          id: "workspace.workspaceFolders",
          execute: async () => {
            let folders = workspace_default.workspaceFolders;
            let lines = folders.map((folder) => URI.parse(folder.uri).fsPath);
            await window_default.echoLines(lines);
          }
        }, false, "show opened workspaceFolders.");
        commands_default.register({
          id: "workspace.writeHeapSnapshot",
          execute: async () => {
            let filepath = path.join(os.homedir(), `${v4_default()}-${process.pid}.heapsnapshot`);
            (0, import_v8.writeHeapSnapshot)(filepath);
            void window_default.showInformationMessage(`Create heapdump at: ${filepath}`);
            return filepath;
          }
        }, false, "Generates a snapshot of the current V8 heap and writes it to a JSON file.");
        commands_default.register({
          id: "workspace.showOutput",
          execute: async (name2) => {
            if (!name2)
              name2 = await window_default.showQuickPick(workspace_default.channelNames, { title: "Choose output name" });
            window_default.showOutputChannel(toText(name2));
          }
        }, false, "open output buffer to show output from languageservers or extensions.");
        commands_default.register({
          id: "workspace.clearWatchman",
          execute: async () => {
            let res = await window_default.runTerminalCommand("watchman watch-del-all");
            if (res.success)
              void window_default.showInformationMessage("Cleared watchman watching directories.");
            return res.success;
          }
        }, false, "run watch-del-all for watchman to free up memory.");
      }
      async openLog() {
        let file = getLoggerFile();
        await workspace_default.jumpTo(URI.file(file).toString());
      }
      async openLocalConfig() {
        let fsPath2 = await this.nvim.call("expand", ["%:p"]);
        let filetype = await this.nvim.eval("&filetype");
        if (!fsPath2 || !path.isAbsolute(fsPath2)) {
          void window_default.showWarningMessage(`Current buffer doesn't have valid file path.`);
          return;
        }
        let folder = workspace_default.getWorkspaceFolder(URI.file(fsPath2).toString());
        if (!folder) {
          let c = workspace_default.initialConfiguration.get("workspace");
          let patterns = defaultValue(c.rootPatterns, []);
          let ignored = defaultValue(c.ignoredFiletypes, []);
          let msg;
          if (ignored.includes(filetype))
            msg = `Filetype '${filetype}' is ignored for workspace folder resolve.`;
          if (!msg)
            msg = `Can't resolve workspace folder for file '${fsPath2}, consider create one of ${patterns.join(", ")} in your project root.'.`;
          void window_default.showWarningMessage(msg);
          return;
        }
        let root = URI.parse(folder.uri).fsPath;
        let dir = path.join(root, ".vim");
        if (!fs.existsSync(dir)) {
          let res = await window_default.showPrompt(`Would you like to create folder'${root}/.vim'?`);
          if (!res)
            return;
          fs.mkdirSync(dir);
        }
        await workspace_default.jumpTo(URI.file(path.join(dir, CONFIG_FILE_NAME)));
      }
      async renameCurrent() {
        let { nvim } = this;
        let oldPath = await nvim.call("expand", ["%:p"]);
        let newPath = await nvim.callAsync("coc#util#with_callback", ["input", ["New path: ", oldPath, "file"]]);
        newPath = newPath ? newPath.trim() : null;
        if (newPath === oldPath || !newPath)
          return;
        if (oldPath.toLowerCase() != newPath.toLowerCase() && fs.existsSync(newPath)) {
          let overwrite = await window_default.showPrompt(`${newPath} exists, overwrite?`);
          if (!overwrite)
            return;
        }
        await workspace_default.renameFile(oldPath, newPath, { overwrite: true });
      }
      addWorkspaceFolder(folder) {
        if (!string(folder))
          throw TypeError(`folder should be string`);
        folder = workspace_default.expand(folder);
        if (!isDirectory(folder))
          throw directoryNotExists(folder);
        workspace_default.workspaceFolderControl.addWorkspaceFolder(folder, true);
      }
      async bufferCheck() {
        let doc = await workspace_default.document;
        if (!doc.attached) {
          await window_default.showDialog({
            title: "Buffer check result",
            content: `Document not attached, ${doc.notAttachReason}`,
            highlight: "WarningMsg"
          });
          return;
        }
        let hi = new Highlighter();
        hi.addLine("Provider state", "Title");
        hi.addLine("");
        for (let name2 of Object.values(ProviderName)) {
          if (name2 === "onTypeEdit" /* OnTypeEdit */)
            continue;
          let exists = languages_default.hasProvider(name2, doc.textDocument);
          hi.addTexts([
            { text: "-", hlGroup: "Comment" },
            { text: " " },
            exists ? { text: "\u2713", hlGroup: "CocListFgGreen" } : { text: "\u2717", hlGroup: "CocListFgRed" },
            { text: " " },
            { text: name2, hlGroup: exists ? "Normal" : "CocFadeOut" }
          ]);
        }
        await window_default.showDialog({
          title: "Buffer check result",
          content: hi.content,
          highlights: hi.highlights
        });
      }
      async doAutocmd(id, args) {
        await workspace_default.autocmds.doAutocmd(id, args);
      }
      async getConfiguration(key) {
        let document2 = await workspace_default.document;
        return workspace_default.getConfiguration(key, document2 ? document2.uri : void 0);
      }
      getRootPatterns(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return null;
        return {
          buffer: workspace_default.workspaceFolderControl.getRootPatterns(doc, 0 /* Buffer */),
          server: workspace_default.workspaceFolderControl.getRootPatterns(doc, 1 /* LanguageServer */) || [],
          global: workspace_default.workspaceFolderControl.getRootPatterns(doc, 2 /* Global */)
        };
      }
      async ensureDocument() {
        let doc = await workspace_default.document;
        return doc && doc.attached;
      }
      async doKeymap(key, defaultReturn = "") {
        return await workspace_default.keymaps.doKeymap(key, defaultReturn);
      }
      async snippetCheck(checkExpand, checkJump) {
        if (checkJump) {
          let jumpable = manager_default3.jumpable();
          if (jumpable)
            return true;
        }
        if (checkExpand) {
          let expandable = await Promise.resolve(extension_default.manager.call("coc-snippets", "expandable", []));
          if (expandable)
            return true;
        }
        return false;
      }
      async showInfo() {
        let lines = [];
        let version2 = workspace_default.version + (true ? "-28e0edd 2022-12-31 20:57:39 +0800" : "");
        lines.push("## versions");
        lines.push("");
        let out = await this.nvim.call("execute", ["version"]);
        let first = out.trim().split(/\r?\n/, 2)[0].replace(/\(.*\)/, "").trim();
        lines.push("vim version: " + first + `${workspace_default.isVim ? " " + workspace_default.env.version : ""}`);
        lines.push("node version: " + process.version);
        lines.push("coc.nvim version: " + version2);
        lines.push("coc.nvim directory: " + path.dirname(__dirname));
        lines.push("term: " + (process.env.TERM_PROGRAM || process.env.TERM));
        lines.push("platform: " + process.platform);
        lines.push("");
        lines.push("## Log of coc.nvim");
        lines.push("");
        let file = getLoggerFile();
        const stripAnsi3 = require_strip_ansi();
        if (fs.existsSync(file)) {
          let content = fs.readFileSync(file, { encoding: "utf8" });
          lines.push(...content.split(/\r?\n/).map((line) => stripAnsi3(line)));
        }
        await this.nvim.command("vnew +setl\\ buftype=nofile\\ bufhidden=wipe\\ nobuflisted");
        let buf = await this.nvim.buffer;
        await buf.setLines(lines, { start: 0, end: -1, strictIndexing: false });
      }
    };
  }
});

// src/handler/index.ts
var logger54, Handler;
var init_handler = __esm({
  "src/handler/index.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_logger();
    init_util();
    init_convert();
    init_object();
    init_protocol();
    init_textedit();
    init_window();
    init_workspace();
    init_callHierarchy2();
    init_codeActions();
    init_codelens();
    init_colors();
    init_commands3();
    init_fold();
    init_format2();
    init_highlights2();
    init_hover2();
    init_inlayHint2();
    init_linkedEditing();
    init_links2();
    init_locations();
    init_refactor();
    init_rename2();
    init_selectionRange2();
    init_semanticTokens2();
    init_signature();
    init_symbols2();
    init_typeHierarchy2();
    init_workspace2();
    logger54 = createLogger("Handler");
    Handler = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "InsertSnippet", "InsertLeave"], () => {
          if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
            this.requestTokenSource = null;
          }
        }, null, this.disposables);
        this.fold = new FoldHandler(nvim, this);
        this.links = new Links(nvim, this);
        this.codeLens = new CodeLensManager2(nvim);
        this.colors = new Colors(nvim, this);
        this.format = new FormatHandler(nvim, this);
        this.symbols = new Symbols2(nvim, this);
        this.refactor = new Refactor(nvim, this);
        this.hover = new HoverHandler(nvim, this);
        this.locations = new LocationsHandler(nvim, this);
        this.signature = new Signature(nvim, this);
        this.rename = new Rename(nvim, this);
        this.workspace = new WorkspaceHandler(nvim);
        this.codeActions = new CodeActions(nvim, this);
        this.commands = new Commands(nvim);
        this.callHierarchy = new CallHierarchyHandler(nvim, this);
        this.typeHierarchy = new TypeHierarchyHandler(nvim, this);
        this.documentHighlighter = new Highlights2(nvim, this);
        this.semanticHighlighter = new SemanticTokens5(nvim);
        this.selectionRange = new SelectionRangeHandler(nvim, this);
        this.linkedEditingHandler = new LinkedEditingHandler(nvim, this);
        this.inlayHintHandler = new InlayHintHandler(nvim, this);
        this.disposables.push({
          dispose: () => {
            this.callHierarchy.dispose();
            this.typeHierarchy.dispose();
            this.codeLens.dispose();
            this.links.dispose();
            this.refactor.dispose();
            this.signature.dispose();
            this.symbols.dispose();
            this.hover.dispose();
            this.colors.dispose();
            this.documentHighlighter.dispose();
            this.semanticHighlighter.dispose();
          }
        });
        this.registerCommands();
      }
      registerCommands() {
        commands_default.register({
          id: "document.renameCurrentWord",
          execute: async () => {
            let doc = await workspace_default.document;
            let edit2 = await this.rename.getWordEdit();
            let ranges = getRangesFromEdit(doc.uri, toObject(edit2));
            if (!ranges)
              return window_default.showWarningMessage("Invalid position");
            await commands_default.executeCommand("editor.action.addRanges", ranges);
          }
        }, false, "rename word under cursor in current buffer by multiple cursors.");
        commands_default.register({
          id: ["workbench.action.reloadWindow", "editor.action.restart"],
          execute: () => {
            this.nvim.command("CocRestart", true);
          }
        }, true);
        this.register("vscode.open", (url) => {
          this.nvim.call("coc#ui#open_url", url.toString(), true);
        });
        this.register("editor.action.doCodeAction", async (action) => {
          await this.codeActions.applyCodeAction(action);
        });
        this.register("editor.action.triggerParameterHints", async () => {
          await this.signature.triggerSignatureHelp();
        });
        this.register("editor.action.showReferences", async (uri, position, references) => {
          await workspace_default.jumpTo(uri, position);
          await workspace_default.showLocations(references);
        });
        this.register("editor.action.rename", async (uri, position, newName) => {
          await workspace_default.jumpTo(uri, position);
          await this.rename.rename(newName);
        });
        this.register("editor.action.format", async () => {
          await this.format.formatCurrentBuffer();
        });
        this.register("editor.action.showRefactor", async (locations) => {
          let locs = locations.filter((o) => Location.is(o));
          return await this.refactor.fromLocations(locs);
        });
      }
      register(key, handler) {
        this.disposables.push(commands_default.registerCommand(key, handler, null, true));
      }
      get requestStatusItem() {
        if (this._requestStatusItem)
          return this._requestStatusItem;
        this._requestStatusItem = window_default.createStatusBarItem(0, { progress: true });
        return this._requestStatusItem;
      }
      get labels() {
        let configuration2 = workspace_default.initialConfiguration;
        return configuration2.get("suggest.completionItemKindLabels", {});
      }
      get uri() {
        var _a2;
        return (_a2 = window_default.activeTextEditor) == null ? void 0 : _a2.document.uri;
      }
      async getCurrentState() {
        let { nvim } = this;
        let [bufnr, [line, character], winid, mode] = await nvim.eval("[bufnr('%'),coc#cursor#position(),win_getid(),mode()]");
        let doc = workspace_default.getAttachedDocument(bufnr);
        return {
          doc,
          mode,
          position: Position.create(line, character),
          winid
        };
      }
      addDisposable(disposable) {
        this.disposables.push(disposable);
      }
      checkProvider(id, document2) {
        if (!languages_default.hasProvider(id, document2)) {
          throw new Error(`${id} provider not found for current buffer, your language server doesn't support it.`);
        }
      }
      async withRequestToken(name2, fn, checkEmpty) {
        if (this.requestTokenSource) {
          this.requestTokenSource.cancel();
          this.requestTokenSource.dispose();
        }
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
        }
        let statusItem = this.requestStatusItem;
        this.requestTokenSource = new import_node3.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        token.onCancellationRequested(() => {
          statusItem.text = `${name2} request canceled`;
          statusItem.isProgress = false;
          this.requestTimer = setTimeout(() => {
            statusItem.hide();
          }, 500);
        });
        statusItem.isProgress = true;
        statusItem.text = `requesting ${name2}`;
        statusItem.show();
        let res;
        try {
          res = await Promise.resolve(fn(token));
        } catch (e) {
          logger54.error(`Error on request ${name2}`, e);
          this.nvim.errWriteLine(`Error on ${name2}: ${e}`);
        }
        if (this.requestTokenSource) {
          this.requestTokenSource.dispose();
          this.requestTokenSource = void 0;
        }
        if (token.isCancellationRequested)
          return null;
        statusItem.hide();
        if (checkEmpty && (!res || Array.isArray(res) && res.length == 0)) {
          void window_default.showWarningMessage(`${name2} not found`);
          return null;
        }
        return res;
      }
      getIcon(kind) {
        let { labels } = this;
        let kindText = getSymbolKind(kind);
        let defaultIcon = typeof labels["default"] === "string" ? labels["default"] : kindText[0].toLowerCase();
        let text = kindText == "Unknown" ? "" : labels[kindText[0].toLowerCase() + kindText.slice(1)];
        if (!text || typeof text !== "string")
          text = defaultIcon;
        return {
          text,
          hlGroup: kindText == "Unknown" ? "CocSymbolDefault" : `CocSymbol${kindText}`
        };
      }
      async getCodeActions(doc, range, only) {
        let codeActions = await this.codeActions.getCodeActions(doc, range, only);
        return codeActions.filter((o) => !o.disabled);
      }
      async applyCodeAction(action) {
        await this.codeActions.applyCodeAction(action);
      }
      async hasProvider(id) {
        let bufnr = await this.nvim.call("bufnr", "%");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return false;
        return languages_default.hasProvider(id, doc.textDocument);
      }
      dispose() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
        }
        disposeAll(this.disposables);
      }
    };
  }
});

// src/plugin.ts
var logger55, Plugin;
var init_plugin = __esm({
  "src/plugin.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_completion2();
    init_sources2();
    init_channels();
    init_cursors();
    init_manager();
    init_events();
    init_extension();
    init_handler();
    init_manager3();
    init_logger();
    init_services();
    init_manager4();
    init_util();
    init_window();
    init_workspace();
    logger55 = createLogger("plugin");
    Plugin = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.ready = false;
        this.initialized = false;
        this.actions = /* @__PURE__ */ new Map();
        this.disposables = [];
        Object.defineProperty(window_default, "workspace", {
          get: () => workspace_default
        });
        Object.defineProperty(workspace_default, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(window_default, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(window_default, "cursors", {
          get: () => this.cursors
        });
        Object.defineProperty(commands_default, "nvim", {
          get: () => this.nvim
        });
        this.cursors = new Cursors(nvim);
        manager_default2.init(nvim);
        this.addAction("checkJsonExtension", () => {
          if (extension_default.has("coc-json"))
            return;
          void window_default.showInformationMessage(`Run :CocInstall coc-json for json intellisense`);
        });
        this.addAction("rootPatterns", (bufnr) => this.handler.workspace.getRootPatterns(bufnr));
        this.addAction("ensureDocument", () => this.handler.workspace.ensureDocument());
        this.addAction("addWorkspaceFolder", (folder) => this.handler.workspace.addWorkspaceFolder(folder));
        this.addAction("getConfig", (key) => this.handler.workspace.getConfiguration(key));
        this.addAction("doAutocmd", (id, ...args) => this.handler.workspace.doAutocmd(id, args));
        this.addAction("openLog", () => this.handler.workspace.openLog());
        this.addAction("attach", () => workspace_default.attach());
        this.addAction("detach", () => workspace_default.detach());
        this.addAction("doKeymap", (key, defaultReturn) => this.handler.workspace.doKeymap(key, defaultReturn));
        this.addAction("registerExtensions", (...folders) => extension_default.manager.loadExtension(folders), "registExtensions");
        this.addAction("snippetCheck", (checkExpand, checkJump) => this.handler.workspace.snippetCheck(checkExpand, checkJump));
        this.addAction("snippetInsert", (range, newText, mode, ultisnip) => manager_default3.insertSnippet(newText, true, range, mode, ultisnip));
        this.addAction("snippetNext", () => manager_default3.nextPlaceholder());
        this.addAction("snippetPrev", () => manager_default3.previousPlaceholder());
        this.addAction("snippetCancel", () => manager_default3.cancel());
        this.addAction("openLocalConfig", () => this.handler.workspace.openLocalConfig());
        this.addAction("bufferCheck", () => this.handler.workspace.bufferCheck());
        this.addAction("showInfo", () => this.handler.workspace.showInfo());
        this.addAction("hasProvider", (id) => this.handler.hasProvider(id));
        this.addAction("cursorsSelect", (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
        this.addAction("fillDiagnostics", (bufnr) => manager_default.setLocationlist(bufnr));
        this.addAction("commandList", () => this.handler.commands.getCommandList());
        this.addAction("selectSymbolRange", (inner, visualmode, supportedSymbols) => this.handler.symbols.selectSymbolRange(inner, visualmode, supportedSymbols));
        this.addAction("openList", (...args) => manager_default2.start(args));
        this.addAction("listNames", () => manager_default2.names);
        this.addAction("listDescriptions", () => manager_default2.descriptions);
        this.addAction("listLoadItems", (name2) => manager_default2.loadItems(name2));
        this.addAction("listResume", (name2) => manager_default2.resume(name2));
        this.addAction("listCancel", () => manager_default2.cancel(true));
        this.addAction("listPrev", (name2) => manager_default2.previous(name2));
        this.addAction("listNext", (name2) => manager_default2.next(name2));
        this.addAction("listFirst", (name2) => manager_default2.first(name2));
        this.addAction("listLast", (name2) => manager_default2.last(name2));
        this.addAction("sendRequest", (id, method, params) => services_default.sendRequest(id, method, params));
        this.addAction("sendNotification", (id, method, params) => services_default.sendNotification(id, method, params));
        this.addAction("registerNotification", (id, method) => services_default.registerNotification(id, method), "registNotification");
        this.addAction("updateConfig", (section2, val) => workspace_default.configurations.updateMemoryConfig({ [section2]: val }));
        this.addAction("links", () => this.handler.links.getLinks());
        this.addAction("openLink", () => this.handler.links.openCurrentLink());
        this.addAction("pickColor", () => this.handler.colors.pickColor());
        this.addAction("colorPresentation", () => this.handler.colors.pickPresentation());
        this.addAction("highlight", () => this.handler.documentHighlighter.highlight());
        this.addAction("fold", (kind) => this.handler.fold.fold(kind));
        this.addAction("startCompletion", (option) => completion_default.startCompletion(option));
        this.addAction("sourceStat", () => sources_default.sourceStats());
        this.addAction("refreshSource", (name2) => sources_default.refresh(name2));
        this.addAction("toggleSource", (name2) => sources_default.toggleSource(name2));
        this.addAction("diagnosticRefresh", (bufnr) => manager_default.refresh(bufnr));
        this.addAction("diagnosticInfo", () => manager_default.echoCurrentMessage());
        this.addAction("diagnosticToggle", (enable) => manager_default.toggleDiagnostic(enable));
        this.addAction("diagnosticToggleBuffer", (bufnr, enable) => manager_default.toggleDiagnosticBuffer(bufnr, enable));
        this.addAction("diagnosticNext", (severity) => manager_default.jumpNext(severity));
        this.addAction("diagnosticPrevious", (severity) => manager_default.jumpPrevious(severity));
        this.addAction("diagnosticPreview", () => manager_default.preview());
        this.addAction("diagnosticList", () => manager_default.getDiagnosticList());
        this.addAction("findLocations", (id, method, params, openCommand) => this.handler.locations.findLocations(id, method, params, openCommand));
        this.addAction("getTagList", () => this.handler.locations.getTagList());
        this.addAction("definitions", () => this.handler.locations.definitions());
        this.addAction("declarations", () => this.handler.locations.declarations());
        this.addAction("implementations", () => this.handler.locations.implementations());
        this.addAction("typeDefinitions", () => this.handler.locations.typeDefinitions());
        this.addAction("references", (excludeDeclaration) => this.handler.locations.references(excludeDeclaration));
        this.addAction("jumpUsed", (openCommand) => this.handler.locations.gotoReferences(openCommand, false));
        this.addAction("jumpDefinition", (openCommand) => this.handler.locations.gotoDefinition(openCommand));
        this.addAction("jumpReferences", (openCommand) => this.handler.locations.gotoReferences(openCommand));
        this.addAction("jumpTypeDefinition", (openCommand) => this.handler.locations.gotoTypeDefinition(openCommand));
        this.addAction("jumpDeclaration", (openCommand) => this.handler.locations.gotoDeclaration(openCommand));
        this.addAction("jumpImplementation", (openCommand) => this.handler.locations.gotoImplementation(openCommand));
        this.addAction("doHover", (hoverTarget) => this.handler.hover.onHover(hoverTarget));
        this.addAction("definitionHover", (hoverTarget) => this.handler.hover.definitionHover(hoverTarget));
        this.addAction("getHover", (loc) => this.handler.hover.getHover(loc));
        this.addAction("showSignatureHelp", () => this.handler.signature.triggerSignatureHelp());
        this.addAction("documentSymbols", (bufnr) => this.handler.symbols.getDocumentSymbols(bufnr));
        this.addAction("symbolRanges", () => this.handler.documentHighlighter.getSymbolsRanges());
        this.addAction("selectionRanges", () => this.handler.selectionRange.getSelectionRanges());
        this.addAction("rangeSelect", (visualmode, forward) => this.handler.selectionRange.selectRange(visualmode, forward));
        this.addAction("rename", (newName) => this.handler.rename.rename(newName));
        this.addAction("getWorkspaceSymbols", (input) => this.handler.symbols.getWorkspaceSymbols(input));
        this.addAction("resolveWorkspaceSymbol", (symbolInfo) => this.handler.symbols.resolveWorkspaceSymbol(symbolInfo));
        this.addAction("formatSelected", (mode) => this.handler.format.formatCurrentRange(mode));
        this.addAction("format", () => this.handler.format.formatCurrentBuffer());
        this.addAction("commands", () => commands_default.commandList);
        this.addAction("services", () => services_default.getServiceStats());
        this.addAction("toggleService", (name2) => services_default.toggle(name2));
        this.addAction("codeAction", (mode, only, noExclude) => this.handler.codeActions.doCodeAction(mode, only, noExclude));
        this.addAction("organizeImport", () => this.handler.codeActions.organizeImport());
        this.addAction("fixAll", () => this.handler.codeActions.doCodeAction(null, [CodeActionKind.SourceFixAll]));
        this.addAction("doCodeAction", (codeAction) => this.handler.codeActions.applyCodeAction(codeAction));
        this.addAction("codeActions", (mode, only) => this.handler.codeActions.getCurrentCodeActions(mode, only));
        this.addAction("quickfixes", (mode) => this.handler.codeActions.getCurrentCodeActions(mode, [CodeActionKind.QuickFix]));
        this.addAction("codeLensAction", () => this.handler.codeLens.doAction());
        this.addAction("doQuickfix", () => this.handler.codeActions.doQuickfix());
        this.addAction("search", (...args) => this.handler.refactor.search(args));
        this.addAction("saveRefactor", (bufnr) => this.handler.refactor.save(bufnr));
        this.addAction("refactor", () => this.handler.refactor.doRefactor());
        this.addAction("runCommand", (...args) => this.handler.commands.runCommand(...args));
        this.addAction("repeatCommand", () => this.handler.commands.repeat());
        this.addAction("installExtensions", (...list2) => extension_default.installExtensions(list2));
        this.addAction("updateExtensions", (silent) => extension_default.updateExtensions(silent));
        this.addAction("extensionStats", () => extension_default.getExtensionStates());
        this.addAction("loadedExtensions", () => extension_default.manager.loadedExtensions);
        this.addAction("watchExtension", (id) => extension_default.manager.watchExtension(id));
        this.addAction("activeExtension", (name2) => extension_default.manager.activate(name2));
        this.addAction("deactivateExtension", (name2) => extension_default.manager.deactivate(name2));
        this.addAction("reloadExtension", (name2) => extension_default.manager.reloadExtension(name2));
        this.addAction("toggleExtension", (name2) => extension_default.manager.toggleExtension(name2));
        this.addAction("uninstallExtension", (...args) => extension_default.manager.uninstallExtensions(args));
        this.addAction("getCurrentFunctionSymbol", () => this.handler.symbols.getCurrentFunctionSymbol());
        this.addAction("showOutline", (keep) => this.handler.symbols.showOutline(keep));
        this.addAction("hideOutline", () => this.handler.symbols.hideOutline());
        this.addAction("getWordEdit", () => this.handler.rename.getWordEdit());
        this.addAction("addCommand", (cmd) => this.handler.commands.addVimCommand(cmd));
        this.addAction("addRanges", (ranges) => this.cursors.addRanges(ranges));
        this.addAction("currentWorkspacePath", () => workspace_default.rootPath);
        this.addAction("selectCurrentPlaceholder", (triggerAutocmd) => manager_default3.selectCurrentPlaceholder(!!triggerAutocmd));
        this.addAction("codeActionRange", (start, end, only) => this.handler.codeActions.codeActionRange(start, end, only));
        this.addAction("incomingCalls", (item) => this.handler.callHierarchy.getIncoming(item));
        this.addAction("outgoingCalls", (item) => this.handler.callHierarchy.getOutgoing(item));
        this.addAction("showIncomingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("incoming"));
        this.addAction("showOutgoingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("outgoing"));
        this.addAction("showSuperTypes", () => this.handler.typeHierarchy.showTypeHierarchyTree("supertypes"));
        this.addAction("showSubTypes", () => this.handler.typeHierarchy.showTypeHierarchyTree("subtypes"));
        this.addAction("inspectSemanticToken", () => this.handler.semanticHighlighter.inspectSemanticToken());
        this.addAction("semanticHighlight", () => this.handler.semanticHighlighter.highlightCurrent());
        this.addAction("showSemanticHighlightInfo", () => this.handler.semanticHighlighter.showHighlightInfo());
      }
      get workspace() {
        return workspace_default;
      }
      get completion() {
        return completion_default;
      }
      addAction(key, fn, alias) {
        if (this.actions.has(key)) {
          throw new Error(`Action ${key} already exists`);
        }
        this.actions.set(key, fn);
        if (alias)
          this.actions.set(alias, fn);
      }
      async init(rtp) {
        if (this.initialized)
          return;
        this.initialized = true;
        let { nvim } = this;
        await extension_default.init(rtp);
        await workspace_default.init(window_default);
        workspace_default.registerTextDocumentContentProvider("output", channels_default.getProvider(nvim));
        nvim.setVar("coc_workspace_initialized", true, true);
        manager_default3.init();
        services_default.init();
        sources_default.init();
        completion_default.init();
        manager_default.init();
        this.handler = new Handler(nvim);
        this.disposables.push(this.handler);
        manager_default2.registerLists();
        await extension_default.activateExtensions();
        workspace_default.configurations.flushConfigurations();
        nvim.pauseNotification();
        nvim.setVar("coc_service_initialized", 1, true);
        nvim.call("coc#util#do_autocmd", ["CocNvimInit"], true);
        nvim.resumeNotification(false, true);
        logger55.info(`coc.nvim initialized with node: ${process.version} after`, Date.now() - getConditionValue(global.__starttime, Date.now()));
        this.ready = true;
        await events_default.fire("ready", []);
      }
      get isReady() {
        return this.ready;
      }
      hasAction(method) {
        return this.actions.has(method);
      }
      async cocAction(method, ...args) {
        let fn = this.actions.get(method);
        if (!fn)
          throw new Error(`Action "${method}" not exist`);
        return await Promise.resolve(fn.apply(null, args));
      }
      getHandler() {
        return this.handler;
      }
      dispose() {
        disposeAll(this.disposables);
        extension_default.dispose();
        manager_default2.dispose();
        workspace_default.dispose();
        channels_default.dispose();
        window_default.dispose();
        sources_default.dispose();
        services_default.dispose();
        manager_default3.dispose();
        commands_default.dispose();
        completion_default.dispose();
        manager_default.dispose();
      }
    };
  }
});

// src/attach.ts
var attach_exports = {};
__export(attach_exports, {
  default: () => attach_default,
  pathReplace: () => pathReplace
});
function pathReplace(patterns) {
  if (objectLiteral(patterns)) {
    const old_uri = URI.file;
    URI.file = (path2) => {
      path2 = path2.replace(/\\/g, "/");
      Object.keys(patterns).forEach((k) => path2 = path2.replace(new RegExp("^" + k), patterns[k]));
      return old_uri(path2);
    };
  }
}
var import_neovim, logger56, ACTIONS_NO_WAIT, semVer, pendingNotifications, attach_default;
var init_attach = __esm({
  "src/attach.ts"() {
    "use strict";
    import_neovim = __toESM(require_lib());
    init_esm();
    init_events();
    init_logger();
    init_plugin();
    init_constants();
    init_is();
    init_node();
    init_string();
    init_timing();
    logger56 = createLogger("attach");
    ACTIONS_NO_WAIT = ["installExtensions", "updateExtensions"];
    semVer = semver.parse(VERSION);
    pendingNotifications = [];
    attach_default = (opts, requestApi = false) => {
      const nvim = (0, import_neovim.attach)(opts, createLogger("node-client"), requestApi);
      nvim.setVar("coc_process_pid", process.pid, true);
      nvim.setClientInfo("coc", { major: semVer.major, minor: semVer.minor, patch: semVer.patch }, "remote", {}, {});
      const plugin = new Plugin(nvim);
      let disposable = events_default.on("ready", () => {
        disposable.dispose();
        for (let [method, args] of pendingNotifications) {
          plugin.cocAction(method, ...args).catch((e) => {
            console.error(`Error on notification "${method}": ${e}`);
            logger56.error(`Error on notification ${method}`, e);
          });
        }
        pendingNotifications = [];
      });
      nvim.on("notification", async (method, args) => {
        switch (method) {
          case "VimEnter": {
            pathReplace(args[0]);
            await plugin.init(args[1]);
            break;
          }
          case "Log": {
            logger56.debug("Vim log", ...args);
            break;
          }
          case "TaskExit":
          case "TaskStderr":
          case "TaskStdout":
          case "GlobalChange":
          case "PromptInsert":
          case "InputChar":
          case "MenuInput":
          case "OptionSet":
          case "PromptKeyPress":
          case "FloatBtnClick":
          case "CompleteStop":
          case "PumInsert":
            logger56.trace("Event: ", method, ...args);
            await events_default.fire(method, args);
            break;
          case "CocAutocmd":
            logger56.trace("Notification autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            break;
          case "redraw":
            break;
          default: {
            try {
              logger56.info("receive notification:", method, args);
              if (!plugin.isReady) {
                pendingNotifications.push([method, args]);
                return;
              }
              await plugin.cocAction(method, ...args);
            } catch (e) {
              console.error(`Error on notification "${method}": ${toErrorText(e)}`);
              logger56.error(`Error on notification ${method}`, e);
            }
          }
        }
      });
      let timing = createTiming("Request", 3e3);
      nvim.on("request", async (method, args, resp) => {
        timing.start(method);
        try {
          events_default.requesting = true;
          if (method == "CocAutocmd") {
            logger56.trace("Request autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            resp.send(void 0);
          } else {
            if (!plugin.isReady && !ACTIONS_NO_WAIT.includes(method)) {
              logger56.warn(`Plugin not ready on request "${method}"`, args);
              resp.send("Plugin not ready", true);
            } else {
              logger56.info("Request action:", method, args);
              let res = await plugin.cocAction(method, ...args);
              resp.send(res);
            }
          }
          events_default.requesting = false;
        } catch (e) {
          events_default.requesting = false;
          resp.send(toErrorText(e), true);
          logger56.error(`Request error:`, method, args, e);
        }
        timing.stop();
      });
      return plugin;
    };
  }
});

// entry-ns:index.js
if (global.__isMain) {
  Object.defineProperty(console, "log", {
    value() {
      if (logger57)
        logger57.info(...arguments);
    }
  });
  const { createLogger: createLogger2 } = (init_logger(), __toCommonJS(logger_exports));
  const logger57 = createLogger2("server");
  process.on("uncaughtException", function(err) {
    let msg = "Uncaught exception: " + err.message;
    console.error(msg);
    logger57.error("uncaughtException", err.stack);
  });
  process.on("unhandledRejection", function(reason, p) {
    if (reason instanceof Error) {
      if (typeof reason.code === "number") {
        let msg = "Unhandled response error " + reason.code + " from language server: " + reason.message;
        if (reason.data != null) {
          console.error(msg, reason.data);
        } else {
          console.error(msg);
        }
      } else {
        console.error("UnhandledRejection: " + reason.message + "\n" + reason.stack);
      }
    } else {
      console.error("UnhandledRejection: " + reason);
    }
    logger57.error("unhandledRejection ", p, reason);
  });
  const attach2 = (init_attach(), __toCommonJS(attach_exports)).default;
  attach2({ reader: process.stdin, writer: process.stdout });
} else {
  const exports2 = require_src3();
  const logger57 = (init_logger(), __toCommonJS(logger_exports)).logger;
  const attach2 = (init_attach(), __toCommonJS(attach_exports)).default;
  module.exports = { attach: attach2, exports: exports2, logger: logger57, loadExtension: (filepath, active) => {
    return exports2.extensions.manager.load(filepath, active);
  } };
}
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
