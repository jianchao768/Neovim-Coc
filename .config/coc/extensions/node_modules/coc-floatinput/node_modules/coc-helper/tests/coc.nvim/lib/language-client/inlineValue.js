'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineValueFeature = void 0;
const tslib_1 = require("tslib");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
class InlineValueFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.InlineValueRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlineValue').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlineValue').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(protocol_1.InlineValueRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlineValues.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const eventEmitter = new protocol_1.Emitter();
        const provider = {
            onDidChangeInlineValues: eventEmitter.event,
            provideInlineValues: (document, viewPort, context, token) => {
                const client = this._client;
                const provideInlineValues = (document, range, context, token) => {
                    const requestParams = {
                        textDocument: cv.asTextDocumentIdentifier(document),
                        range,
                        context
                    };
                    return this.sendRequest(protocol_1.InlineValueRequest.type, requestParams, token);
                };
                const middleware = client.middleware;
                return middleware.provideInlineValues
                    ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues)
                    : provideInlineValues(document, viewPort, context, token);
            }
        };
        const selector = options.documentSelector;
        return [languages_1.default.registerInlineValuesProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
    }
}
exports.InlineValueFeature = InlineValueFeature;
//# sourceMappingURL=inlineValue.js.map