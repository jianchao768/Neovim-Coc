"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let disposables = [];
let rename;
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    rename = helper_1.default.plugin.getHandler().rename;
});
function getWordRangeAtPosition(doc, position) {
    let lines = doc.getText().split(/\r?\n/);
    let line = lines[position.line];
    if (line.length == 0 || position.character >= line.length)
        return null;
    if (!/\w/.test(line[position.character]))
        return null;
    let start = position.character;
    let end = position.character + 1;
    if (!/\w/.test(line[start])) {
        return vscode_languageserver_protocol_1.Range.create(position, { line: position.line, character: position.character + 1 });
    }
    while (start >= 0) {
        let ch = line[start - 1];
        if (!ch || !/\w/.test(ch))
            break;
        start = start - 1;
    }
    while (end <= line.length) {
        let ch = line[end];
        if (!ch || !/\w/.test(ch))
            break;
        end = end + 1;
    }
    return vscode_languageserver_protocol_1.Range.create(position.line, start, position.line, end);
}
function getSymbolRanges(textDocument, word) {
    let res = [];
    let str = '';
    let content = textDocument.getText();
    for (let i = 0, l = content.length; i < l; i++) {
        let ch = content[i];
        if ('-' == ch && str.length == 0) {
            continue;
        }
        let isKeyword = /\w/.test(ch);
        if (isKeyword) {
            str = str + ch;
        }
        if (str.length > 0 && !isKeyword && str == word) {
            res.push(vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
        }
        if (!isKeyword) {
            str = '';
        }
    }
    return res;
}
beforeEach(() => {
    disposables.push(languages_1.default.registerRenameProvider([{ language: 'javascript' }], {
        provideRenameEdits: (doc, position, newName) => {
            let range = getWordRangeAtPosition(doc, position);
            if (range) {
                let word = doc.getText(range);
                if (word) {
                    let ranges = getSymbolRanges(doc, word);
                    return {
                        changes: {
                            [doc.uri]: ranges.map(o => vscode_languageserver_protocol_1.TextEdit.replace(o, newName))
                        }
                    };
                }
            }
            return undefined;
        },
        prepareRename: (doc, position) => {
            let range = getWordRangeAtPosition(doc, position);
            return range ? { range, placeholder: doc.getText(range) } : null;
        }
    }));
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
    disposables = [];
});
describe('rename handler', () => {
    describe('getWordEdit', () => {
        it('should not throw when provider not found', async () => {
            await helper_1.default.edit();
            let res = await helper_1.default.doAction('getWordEdit');
            expect(res).toBe(null);
        });
        it('should use document symbols when prepare failed', async () => {
            let doc = await helper_1.default.createDocument('t.js');
            await nvim.setLine('你');
            await doc.synchronize();
            let res = await rename.getWordEdit();
            expect(res != null).toBe(true);
        });
        it('should return workspace edit', async () => {
            let doc = await helper_1.default.createDocument('t.js');
            await nvim.setLine('foo foo');
            await doc.synchronize();
            let res = await rename.getWordEdit();
            expect(res).toBeDefined();
            expect(res.changes[doc.uri].length).toBe(2);
        });
        it('should extract words from buffer', async () => {
            let doc = await helper_1.default.createDocument('t');
            await nvim.setLine('你 你 你');
            await doc.synchronize();
            let res = await rename.getWordEdit();
            expect(res).toBeDefined();
            expect(res.changes[doc.uri].length).toBe(3);
        });
    });
    describe('rename', () => {
        it('should throw when provider not found', async () => {
            await helper_1.default.edit();
            await expect(async () => {
                await helper_1.default.doAction('rename', 'foo');
            }).rejects.toThrow(Error);
        });
        it('should return false for invalid position', async () => {
            await helper_1.default.createDocument('t.js');
            let res = await rename.rename('foo');
            expect(res).toBe(false);
        });
        it('should use newName from placeholder', async () => {
            let doc = await helper_1.default.createDocument('t.js');
            await nvim.setLine('foo foo foo');
            let p = commands_1.default.executeCommand('editor.action.rename', doc.uri, vscode_languageserver_protocol_1.Position.create(0, 0));
            await helper_1.default.waitFloat();
            await nvim.input('<C-u>');
            await helper_1.default.wait(10);
            await nvim.input('bar');
            await nvim.input('<cr>');
            await p;
            let line = await nvim.line;
            expect(line).toBe('bar bar bar');
        });
        it('should renameCurrentWord by cursors', async () => {
            await commands_1.default.executeCommand('document.renameCurrentWord');
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('Invalid position');
            let doc = await helper_1.default.createDocument('t.js');
            await nvim.setLine('foo foo foo');
            await commands_1.default.executeCommand('document.renameCurrentWord');
            let ns = await nvim.createNamespace('coc-cursors');
            let markers = await doc.buffer.getExtMarks(ns, 0, -1);
            expect(markers.length).toBe(3);
        });
        it('should return false for empty name', async () => {
            await helper_1.default.createDocument('t.js');
            await nvim.setLine('foo foo foo');
            let p = rename.rename();
            await helper_1.default.waitFloat();
            await nvim.input('<C-u>');
            await helper_1.default.wait(10);
            await nvim.input('<cr>');
            let res = await p;
            expect(res).toBe(false);
        });
        it('should not throw when provideRenameEdits throws', async () => {
            disposables.push(languages_1.default.registerRenameProvider([{ language: '*' }], {
                provideRenameEdits: () => {
                    throw new Error('error');
                },
            }));
            let doc = await workspace_1.default.document;
            let res = await languages_1.default.provideRenameEdits(doc.textDocument, vscode_languageserver_protocol_1.Position.create(0, 0), 'newName', vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBeNull();
        });
        it('should use newName from range', async () => {
            disposables.push(languages_1.default.registerRenameProvider([{ language: '*' }], {
                provideRenameEdits: (doc, position, newName) => {
                    let range = getWordRangeAtPosition(doc, position);
                    if (range) {
                        let word = doc.getText(range);
                        if (word) {
                            let ranges = getSymbolRanges(doc, word);
                            return {
                                changes: {
                                    [doc.uri]: ranges.map(o => vscode_languageserver_protocol_1.TextEdit.replace(o, newName))
                                }
                            };
                        }
                    }
                    return undefined;
                },
                prepareRename: (doc, position) => {
                    let range = getWordRangeAtPosition(doc, position);
                    return range ? range : null;
                }
            }));
            await helper_1.default.createDocument();
            await nvim.setLine('foo foo foo');
            let p = rename.rename();
            await helper_1.default.waitFloat();
            await nvim.input('<C-u>');
            await helper_1.default.wait(10);
            await nvim.input('bar');
            await nvim.input('<cr>');
            let res = await p;
            expect(res).toBe(true);
            await helper_1.default.waitFor('getline', ['.'], 'bar bar bar');
        });
        it('should use newName from cword', async () => {
            disposables.push(languages_1.default.registerRenameProvider([{ language: '*' }], {
                provideRenameEdits: (doc, position, newName) => {
                    let range = getWordRangeAtPosition(doc, position);
                    if (range) {
                        let word = doc.getText(range);
                        if (word) {
                            let ranges = getSymbolRanges(doc, word);
                            return {
                                changes: {
                                    [doc.uri]: ranges.map(o => vscode_languageserver_protocol_1.TextEdit.replace(o, newName))
                                }
                            };
                        }
                    }
                    return undefined;
                }
            }));
            await helper_1.default.createDocument();
            await nvim.setLine('foo foo foo');
            let p = rename.rename();
            await helper_1.default.waitFloat();
            await nvim.input('<C-u>');
            await helper_1.default.wait(10);
            await nvim.input('bar');
            await nvim.input('<cr>');
            let res = await p;
            expect(res).toBe(true);
            let line = await nvim.getLine();
            expect(line).toBe('bar bar bar');
        });
        it('should return false when result is empty', async () => {
            disposables.push(languages_1.default.registerRenameProvider([{ language: '*' }], {
                provideRenameEdits: () => {
                    return null;
                }
            }));
            await helper_1.default.createDocument();
            await nvim.setLine('foo foo foo');
            let p = rename.rename();
            await helper_1.default.waitFloat();
            await nvim.input('<C-u>');
            await helper_1.default.wait(10);
            await nvim.input('bar');
            await nvim.input('<cr>');
            let res = await p;
            expect(res).toBe(false);
        });
    });
});
//# sourceMappingURL=rename.test.js.map