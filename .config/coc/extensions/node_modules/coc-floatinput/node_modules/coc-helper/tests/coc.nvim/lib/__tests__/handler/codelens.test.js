"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const commands_1 = tslib_1.__importDefault(require("../../commands"));
const events_1 = tslib_1.__importDefault(require("../../events"));
const buffer_1 = require("../../handler/codelens/buffer");
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
let nvim;
let codeLens;
let disposables = [];
let srcId;
jest.setTimeout(10000);
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    srcId = await nvim.createNamespace('coc-codelens');
    codeLens = helper_1.default.plugin.getHandler().codeLens;
});
beforeEach(() => {
    helper_1.default.updateConfiguration('codeLens.enable', true);
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    await helper_1.default.reset();
    (0, util_1.disposeAll)(disposables);
});
async function createBufferWithCodeLens() {
    disposables.push(languages_1.default.registerCodeLensProvider([{ language: 'javascript' }], {
        provideCodeLenses: () => {
            return [{
                    range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)
                }];
        },
        resolveCodeLens: codeLens => {
            codeLens.command = vscode_languageserver_protocol_1.Command.create('save', '__save', 1, 2, 3);
            return codeLens;
        }
    }));
    let doc = await helper_1.default.createDocument('e.js');
    await nvim.call('setline', [1, ['a', 'b', 'c']]);
    await doc.synchronize();
    await codeLens.checkProvider();
    return codeLens.buffers.getItem(doc.bufnr);
}
describe('codeLenes featrue', () => {
    it('should get text align', async () => {
        expect((0, buffer_1.getTextAlign)(undefined)).toBe('above');
        expect((0, buffer_1.getTextAlign)('top')).toBe('above');
        expect((0, buffer_1.getTextAlign)('eol')).toBe('after');
        expect((0, buffer_1.getTextAlign)('right_align')).toBe('right');
    });
    it('should not throw when srcId not exists', async () => {
        let doc = await workspace_1.default.document;
        let item = codeLens.buffers.getItem(doc.bufnr);
        item.clear();
        await item.doAction(0);
    });
    it('should invoke codeLenes action', async () => {
        let fn = jest.fn();
        disposables.push(commands_1.default.registerCommand('__save', (...args) => {
            fn(...args);
        }));
        await createBufferWithCodeLens();
        await helper_1.default.doAction('codeLensAction');
        expect(fn).toBeCalledWith(1, 2, 3);
        await nvim.command('normal! G');
        await helper_1.default.doAction('codeLensAction');
    });
    it('should toggle codeLens display', async () => {
        await codeLens.toggle(999);
        let line = await helper_1.default.getCmdline();
        expect(line).toMatch('not created');
        await createBufferWithCodeLens();
        await commands_1.default.executeCommand('document.toggleCodeLens');
        let doc = await workspace_1.default.document;
        let res = await doc.buffer.getExtMarks(srcId, 0, -1, { details: true });
        expect(res.length).toBe(0);
        await commands_1.default.executeCommand('document.toggleCodeLens');
        await helper_1.default.waitValue(async () => {
            let res = await doc.buffer.getExtMarks(srcId, 0, -1, { details: true });
            return res.length > 0;
        }, true);
    });
    it('should return codeLenes when resolve not exists', async () => {
        let codeLens = vscode_languageserver_protocol_1.CodeLens.create(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 1));
        let resolved = await languages_1.default.resolveCodeLens(codeLens, vscode_languageserver_protocol_1.CancellationToken.None);
        expect(resolved).toBeDefined();
    });
    it('should do codeLenes request and resolve codeLenes', async () => {
        let buf = await createBufferWithCodeLens();
        let doc = await workspace_1.default.document;
        await helper_1.default.waitValue(async () => {
            let codelens = buf.currentCodeLens;
            return Array.isArray(codelens) && codelens[0].command != null;
        }, true);
        let markers = await doc.buffer.getExtMarks(srcId, 0, -1);
        expect(markers.length).toBe(1);
        let codeLenes = buf.currentCodeLens;
        await languages_1.default.resolveCodeLens(codeLenes[0], vscode_languageserver_protocol_1.CancellationToken.None);
    });
    it('should refresh on empty changes', async () => {
        await createBufferWithCodeLens();
        let doc = await workspace_1.default.document;
        await nvim.call('setline', [1, ['a', 'b', 'c']]);
        await doc.synchronize();
        let markers = await doc.buffer.getExtMarks(srcId, 0, -1);
        expect(markers.length).toBeGreaterThan(0);
    });
    it('should work with empty codeLens', async () => {
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: 'javascript' }], {
            provideCodeLenses: () => {
                return [];
            }
        }));
        let doc = await helper_1.default.createDocument('t.js');
        let buf = codeLens.buffers.getItem(doc.bufnr);
        let codelens = buf.currentCodeLens;
        expect(codelens).toBeUndefined();
    });
    it('should change codeLenes position', async () => {
        helper_1.default.updateConfiguration('codeLens.position', 'eol');
        let bufnr = await nvim.call('bufnr', ['%']);
        let item = codeLens.buffers.getItem(bufnr);
        expect(item.config.position).toBe('eol');
    });
    it('should refresh codeLens on CursorHold', async () => {
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: 'javascript' }], {
            provideCodeLenses: document => {
                let n = document.lineCount;
                let arr = [];
                for (let i = 0; i <= n - 2; i++) {
                    arr.push({
                        range: vscode_languageserver_protocol_1.Range.create(i, 0, i, 1),
                        command: vscode_languageserver_protocol_1.Command.create('save', '__save', i)
                    });
                }
                return arr;
            }
        }));
        let doc = await helper_1.default.createDocument('example.js');
        await nvim.call('setline', [1, ['a', 'b', 'c']]);
        await doc.synchronize();
        await events_1.default.fire('CursorHold', [doc.bufnr]);
        await helper_1.default.waitValue(async () => {
            let markers = await doc.buffer.getExtMarks(srcId, 0, -1);
            return markers.length;
        }, 3);
        helper_1.default.updateConfiguration('codeLens.enable', false);
        await events_1.default.fire('CursorHold', [doc.bufnr]);
    });
    it('should cancel codeLenes request on document change', async () => {
        let cancelled = false;
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: 'javascript' }], {
            provideCodeLenses: (_, token) => {
                return new Promise(resolve => {
                    token.onCancellationRequested(() => {
                        cancelled = true;
                        clearTimeout(timer);
                        resolve(null);
                    });
                    let timer = setTimeout(() => {
                        resolve([{
                                range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1)
                            }, {
                                range: vscode_languageserver_protocol_1.Range.create(1, 0, 1, 1)
                            }]);
                    }, 2000);
                    disposables.push({
                        dispose: () => {
                            clearTimeout(timer);
                        }
                    });
                });
            },
            resolveCodeLens: codeLens => {
                codeLens.command = vscode_languageserver_protocol_1.Command.create('save', '__save');
                return codeLens;
            }
        }));
        let doc = await helper_1.default.createDocument('codelens.js');
        await helper_1.default.wait(50);
        await doc.applyEdits([vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(0, 0), 'a\nb\nc')]);
        expect(cancelled).toBe(true);
    });
    it('should resolve on CursorMoved', async () => {
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: 'javascript' }], {
            provideCodeLenses: () => {
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(90, 0, 90, 1)
                    }, {
                        range: vscode_languageserver_protocol_1.Range.create(91, 0, 91, 1)
                    }];
            },
            resolveCodeLens: async (codeLens) => {
                codeLens.command = vscode_languageserver_protocol_1.Command.create('save', '__save');
                return codeLens;
            }
        }));
        let doc = await helper_1.default.createDocument('example.js');
        let arr = new Array(100);
        arr.fill('');
        await nvim.call('setline', [1, arr]);
        await doc.synchronize();
        await codeLens.checkProvider();
        await nvim.command('normal! gg');
        await nvim.command('normal! G');
        await helper_1.default.wait(100);
        let buf = codeLens.buffers.getItem(doc.bufnr);
        let codelens = buf.currentCodeLens;
        expect(codelens).toBeDefined();
        expect(codelens[0].command).toBeDefined();
        expect(codelens[1].command).toBeDefined();
    });
    it('should use picker for multiple codeLenses', async () => {
        let fn = jest.fn();
        let resolved = false;
        disposables.push(commands_1.default.registerCommand('__save', (...args) => {
            fn(...args);
        }));
        disposables.push(commands_1.default.registerCommand('__delete', (...args) => {
            fn(...args);
        }));
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: 'javascript' }], {
            provideCodeLenses: () => {
                resolved = true;
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1),
                        command: vscode_languageserver_protocol_1.Command.create('save', '__save', 1, 2, 3)
                    }, {
                        range: vscode_languageserver_protocol_1.Range.create(0, 1, 0, 2),
                        command: vscode_languageserver_protocol_1.Command.create('save', '__delete', 4, 5, 6)
                    }];
            }
        }));
        let doc = await helper_1.default.createDocument('example.js');
        await nvim.call('setline', [1, ['a', 'b', 'c']]);
        await doc.synchronize();
        await codeLens.checkProvider();
        await helper_1.default.waitValue(() => {
            return resolved;
        }, true);
        let p = helper_1.default.doAction('codeLensAction');
        await helper_1.default.waitPrompt();
        await nvim.input('<cr>');
        await p;
        expect(fn).toBeCalledWith(1, 2, 3);
    });
    it('should refresh for failed codeLens request', async () => {
        let called = 0;
        let fn = jest.fn();
        disposables.push(commands_1.default.registerCommand('__save', (...args) => {
            fn(...args);
        }));
        disposables.push(commands_1.default.registerCommand('__foo', (...args) => {
            fn(...args);
        }));
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: '*' }], {
            provideCodeLenses: () => {
                called++;
                if (called == 1) {
                    return null;
                }
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1),
                        command: vscode_languageserver_protocol_1.Command.create('foo', '__foo')
                    }];
            }
        }));
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: '*' }], {
            provideCodeLenses: () => {
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 1),
                        command: vscode_languageserver_protocol_1.Command.create('save', '__save')
                    }];
            }
        }));
        let doc = await helper_1.default.createDocument('example.js');
        await helper_1.default.wait(50);
        await nvim.call('setline', [1, ['a', 'b', 'c']]);
        await codeLens.checkProvider();
        let markers = await doc.buffer.getExtMarks(srcId, 0, -1);
        expect(markers.length).toBeGreaterThan(0);
        let codeLensBuffer = codeLens.buffers.getItem(doc.buffer.id);
        await codeLensBuffer.forceFetch();
        let curr = codeLensBuffer.currentCodeLens;
        expect(curr.length).toBeGreaterThan(1);
    });
    it('should use custom separator & position', async () => {
        helper_1.default.updateConfiguration('codeLens.separator', '|');
        helper_1.default.updateConfiguration('codeLens.position', 'eol');
        let doc = await helper_1.default.createDocument('example.js');
        await nvim.call('setline', [1, ['a', 'b', 'c']]);
        await doc.synchronize();
        disposables.push(languages_1.default.registerCodeLensProvider([{ language: '*' }], {
            provideCodeLenses: () => {
                return [{
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0),
                        command: vscode_languageserver_protocol_1.Command.create('save', '__save')
                    }, {
                        range: vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0),
                        command: vscode_languageserver_protocol_1.Command.create('save', '__save')
                    }];
            }
        }));
        await codeLens.checkProvider();
        let res = await doc.buffer.getExtMarks(srcId, 0, -1, { details: true });
        expect(res.length).toBe(1);
    });
    it('should get commands from codeLenses', async () => {
        expect((0, buffer_1.getCommands)(1, undefined)).toEqual([]);
        let codeLenses = [vscode_languageserver_protocol_1.CodeLens.create(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0))];
        expect((0, buffer_1.getCommands)(0, codeLenses)).toEqual([]);
        codeLenses = [vscode_languageserver_protocol_1.CodeLens.create(vscode_languageserver_protocol_1.Range.create(0, 0, 1, 0)), vscode_languageserver_protocol_1.CodeLens.create(vscode_languageserver_protocol_1.Range.create(2, 0, 3, 0))];
        codeLenses[0].command = vscode_languageserver_protocol_1.Command.create('save', '__save');
        expect((0, buffer_1.getCommands)(0, codeLenses).length).toEqual(1);
    });
});
//# sourceMappingURL=codelens.test.js.map