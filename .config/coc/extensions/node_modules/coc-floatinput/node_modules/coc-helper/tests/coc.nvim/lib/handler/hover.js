'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.readLines = exports.isDocumentation = exports.addDocument = exports.addDefinitions = void 0;
const tslib_1 = require("tslib");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const languages_1 = tslib_1.__importStar(require("../languages"));
const util_1 = require("../util");
const array_1 = require("../util/array");
const fs_1 = require("../util/fs");
const is_1 = require("../util/is");
const node_1 = require("../util/node");
const protocol_1 = require("../util/protocol");
const string_1 = require("../util/string");
const window_1 = tslib_1.__importDefault(require("../window"));
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const highlightDelay = (0, util_1.getConditionValue)(500, 10);
class HoverHandler {
    constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.documentLines = [];
        this.hasProvider = false;
        this.loadConfiguration();
        workspace_1.default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.hoverFactory = window_1.default.createFloatFactory({
            modes: ['n'],
            autoHide: this.config.autoHide
        });
        this.disposables.push(this.hoverFactory);
        window_1.default.onDidChangeActiveTextEditor(() => {
            this.loadConfiguration();
        }, null, this.disposables);
    }
    registerProvider() {
        if (this.hasProvider)
            return;
        this.hasProvider = true;
        let { nvim } = this;
        let provider = {
            onDidChange: null,
            provideTextDocumentContent: async () => {
                nvim.pauseNotification();
                nvim.command('setlocal conceallevel=2 nospell nofoldenable wrap', true);
                nvim.command('setlocal bufhidden=wipe nobuflisted', true);
                nvim.command('setfiletype markdown', true);
                nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.config.previewMaxHeight)}\\<cr>" | endif`, true);
                await nvim.resumeNotification();
                return this.documentLines.join('\n');
            }
        };
        this.disposables.push(workspace_1.default.registerTextDocumentContentProvider('coc', provider));
    }
    loadConfiguration(e) {
        if (!e || e.affectsConfiguration('hover')) {
            let config = workspace_1.default.getConfiguration('hover', this.handler.uri);
            this.config = {
                floatConfig: config.get('floatConfig', {}),
                autoHide: config.get('autoHide', true),
                target: config.get('target', 'float'),
                previewMaxHeight: config.get('previewMaxHeight', 12)
            };
            if (this.config.target == 'preview') {
                this.registerProvider();
            }
        }
    }
    async onHover(hoverTarget) {
        let { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == 'preview')
            this.registerProvider();
        this.handler.checkProvider(languages_1.ProviderName.Hover, doc.textDocument);
        await doc.synchronize();
        let hovers = await this.handler.withRequestToken('hover', token => {
            return languages_1.default.getHover(doc.textDocument, position, token);
        }, true);
        if (hovers == null || !hovers.length)
            return false;
        let hover = hovers.find(o => vscode_languageserver_types_1.Range.is(o.range));
        if (hover === null || hover === void 0 ? void 0 : hover.range) {
            let win = this.nvim.createWindow(winid);
            win.highlightRanges('CocHoverRange', [hover.range], 99, true);
            this.timer = setTimeout(() => {
                win.clearMatchGroup('CocHoverRange');
                this.nvim.redrawVim();
            }, 500);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
    }
    async definitionHover(hoverTarget) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == 'preview')
            this.registerProvider();
        this.handler.checkProvider(languages_1.ProviderName.Hover, doc.textDocument);
        await doc.synchronize();
        const hovers = await this.handler.withRequestToken('hover', token => {
            return languages_1.default.getHover(doc.textDocument, position, token);
        }, true);
        if ((0, array_1.isFalsyOrEmpty)(hovers))
            return false;
        const defs = await this.handler.withRequestToken('definitionHover', token => {
            return languages_1.default.getDefinitionLinks(doc.textDocument, position, token);
        }, false);
        await addDefinitions(hovers, defs, doc.filetype);
        let hover = hovers.find(o => vscode_languageserver_types_1.Hover.is(o) && vscode_languageserver_types_1.Range.is(o.range));
        if (hover) {
            let win = this.nvim.createWindow(winid);
            win.highlightRanges('CocHoverRange', [hover.range], 99, true);
            this.timer = setTimeout(() => {
                win.clearMatchGroup('CocHoverRange');
                this.nvim.redrawVim();
            }, highlightDelay);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
    }
    async previewHover(hovers, target) {
        let docs = [];
        target = target !== null && target !== void 0 ? target : this.config.target;
        let isPreview = target === 'preview';
        for (let hover of hovers) {
            if (isDocumentation(hover)) {
                docs.push(hover);
                continue;
            }
            let { contents } = hover;
            if (Array.isArray(contents)) {
                for (let item of contents) {
                    if (typeof item === 'string') {
                        addDocument(docs, item, 'markdown', isPreview);
                    }
                    else {
                        addDocument(docs, item.value, item.language, isPreview);
                    }
                }
            }
            else if (vscode_languageserver_types_1.MarkedString.is(contents)) {
                if (typeof contents == 'string') {
                    addDocument(docs, contents, 'markdown', isPreview);
                }
                else {
                    addDocument(docs, contents.value, contents.language, isPreview);
                }
            }
            else if (vscode_languageserver_types_1.MarkupContent.is(contents)) {
                addDocument(docs, contents.value, (0, is_1.isMarkdown)(contents) ? 'markdown' : 'txt', isPreview);
            }
        }
        if (target == 'float') {
            await this.hoverFactory.show(docs, this.config.floatConfig);
            return;
        }
        let lines = docs.reduce((p, c) => {
            let arr = c.content.split(/\r?\n/);
            if (p.length > 0)
                p.push('');
            p.push(...arr);
            return p;
        }, []);
        if (target == 'echo') {
            const msg = lines.join('\n').trim();
            await this.nvim.call('coc#ui#echo_hover', [msg]);
        }
        else {
            this.documentLines = lines;
            await this.nvim.command(`noswapfile pedit coc://document`);
        }
    }
    /**
     * Get hover text array
     */
    async getHover(loc) {
        let result = [];
        let doc;
        let position;
        if (!loc) {
            let state = await this.handler.getCurrentState();
            doc = state.doc;
            position = state.position;
        }
        else {
            doc = loc.bufnr ? workspace_1.default.getAttachedDocument(loc.bufnr) : await workspace_1.default.document;
            let line = doc.getline(loc.line - 1);
            let character = (0, string_1.characterIndex)(line, loc.col - 1);
            position = vscode_languageserver_types_1.Position.create(loc.line - 1, character);
        }
        this.handler.checkProvider(languages_1.ProviderName.Hover, doc.textDocument);
        await doc.synchronize();
        let tokenSource = new protocol_1.CancellationTokenSource();
        let hovers = await languages_1.default.getHover(doc.textDocument, position, tokenSource.token);
        for (let h of hovers) {
            let { contents } = h;
            if (Array.isArray(contents)) {
                contents.forEach(c => {
                    result.push(typeof c === 'string' ? c : c.value);
                });
            }
            else if (vscode_languageserver_types_1.MarkupContent.is(contents)) {
                result.push(contents.value);
            }
            else {
                result.push(typeof contents === 'string' ? contents : contents.value);
            }
        }
        result = result.filter(s => s != null && s.length > 0);
        return result;
    }
    dispose() {
        if (this.timer)
            clearTimeout(this.timer);
        (0, util_1.disposeAll)(this.disposables);
    }
}
exports.default = HoverHandler;
async function addDefinitions(hovers, definitions, filetype) {
    for (const def of definitions) {
        if (!(def === null || def === void 0 ? void 0 : def.targetRange))
            continue;
        const { start, end } = def.targetRange;
        // def.targetSelectionRange
        const endLine = end.line - start.line >= 100 ? start.line + 100 : (end.character == 0 ? end.line - 1 : end.line);
        let lines = await readLines(def.targetUri, start.line, endLine);
        if (lines.length) {
            let indent = lines[0].match(/^\s*/)[0];
            if (indent)
                lines = lines.map(l => l.startsWith(indent) ? l.substring(indent.length) : l);
            hovers.push({ content: lines.join('\n'), filetype });
        }
    }
}
exports.addDefinitions = addDefinitions;
function addDocument(docs, text, filetype, isPreview = false) {
    let content = text.trim();
    if (!content.length)
        return;
    if (isPreview && filetype !== 'markdown') {
        content = '``` ' + filetype + '\n' + content + '\n```';
    }
    docs.push({ content, filetype });
}
exports.addDocument = addDocument;
function isDocumentation(obj) {
    if (!obj)
        return false;
    return typeof obj.filetype === 'string' && typeof obj.content === 'string';
}
exports.isDocumentation = isDocumentation;
async function readLines(uri, start, end) {
    let doc = workspace_1.default.getDocument(uri);
    if (doc)
        return doc.getLines(start, end + 1);
    let fsPath = vscode_uri_1.URI.parse(uri).fsPath;
    if (!node_1.fs.existsSync(fsPath))
        return [];
    return await (0, fs_1.readFileLines)(fsPath, start, end);
}
exports.readLines = readLines;
//# sourceMappingURL=hover.js.map