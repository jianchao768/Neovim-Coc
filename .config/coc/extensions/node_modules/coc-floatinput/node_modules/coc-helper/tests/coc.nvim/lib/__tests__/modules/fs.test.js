"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wait = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("../../util/fs");
const uuid_1 = require("uuid");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_2 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(undefined);
        }, ms);
    });
}
exports.wait = wait;
describe('fs', () => {
    describe('normalizeFilePath()', () => {
        it('should fs normalizeFilePath', () => {
            let res = (0, fs_1.normalizeFilePath)('//');
            expect(res).toBe('/');
            res = (0, fs_1.normalizeFilePath)('/a/b/');
            expect(res).toBe('/a/b');
        });
    });
    it('should check directory', () => {
        expect((0, fs_1.isDirectory)(null)).toBe(false);
        expect((0, fs_1.isDirectory)('')).toBe(false);
        expect((0, fs_1.isDirectory)(__filename)).toBe(false);
        expect((0, fs_1.isDirectory)(process.cwd())).toBe(true);
    });
    it('should watch file', async () => {
        let filepath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
        fs_2.default.writeFileSync(filepath, 'file', 'utf8');
        let called = false;
        let disposable = (0, fs_1.watchFile)(filepath, () => {
            called = true;
        }, true);
        fs_2.default.writeFileSync(filepath, 'new file', 'utf8');
        await wait(2);
        disposable.dispose();
        disposable = (0, fs_1.watchFile)('file_not_exists', () => { }, true);
        disposable.dispose();
    });
    describe('stat()', () => {
        it('fs statAsync', async () => {
            let res = await (0, fs_1.statAsync)(__filename);
            expect(res).toBeDefined;
            expect(res.isFile()).toBe(true);
        });
        it('fs statAsync #1', async () => {
            let res = await (0, fs_1.statAsync)(path_1.default.join(__dirname, 'file_not_exist'));
            expect(res).toBeNull;
        });
    });
    describe('loadJson()', () => {
        it('should loadJson()', () => {
            let file = path_1.default.join(__dirname, 'not_exists.json');
            expect((0, fs_1.loadJson)(file)).toEqual({});
        });
        it('should loadJson with bad format', async () => {
            let file = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_2.default.writeFileSync(file, 'foo', 'utf8');
            expect((0, fs_1.loadJson)(file)).toEqual({});
        });
    });
    describe('writeJson()', () => {
        it('should writeJson file', async () => {
            let file = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            (0, fs_1.writeJson)(file, { x: 1 });
            expect((0, fs_1.loadJson)(file)).toEqual({ x: 1 });
        });
        it('should create file with folder', async () => {
            let file = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)(), 'foo', 'bar');
            (0, fs_1.writeJson)(file, { foo: '1' });
            expect((0, fs_1.loadJson)(file)).toEqual({ foo: '1' });
        });
    });
    describe('lineToLocation', () => {
        it('should not throw when file not exists', async () => {
            let res = await (0, fs_1.lineToLocation)(path_1.default.join(os_1.default.tmpdir(), 'not_exists'), 'ab');
            expect(res).toBeDefined();
        });
        it('should use empty range when not found', async () => {
            let res = await (0, fs_1.lineToLocation)(__filename, 'a'.repeat(100));
            expect(res).toBeDefined();
            expect(res.range).toEqual(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0));
        });
        it('should get location', async () => {
            let file = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_2.default.writeFileSync(file, '\nfoo\n', 'utf8');
            let res = await (0, fs_1.lineToLocation)(file, 'foo', 'foo');
            expect(res.range).toEqual(vscode_languageserver_protocol_1.Range.create(1, 0, 1, 3));
        });
    });
    describe('remove()', () => {
        it('should remove files', async () => {
            await (0, fs_1.remove)(path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)()));
            let p = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_2.default.writeFileSync(p, 'data', 'utf8');
            await (0, fs_1.remove)(p);
            let exists = fs_2.default.existsSync(p);
            expect(exists).toBe(false);
            await (0, fs_1.remove)(undefined);
        });
        it('should not throw error', async () => {
            let spy = jest.spyOn(fs_2.default, 'rm').mockImplementation(() => {
                throw new Error('my error');
            });
            let p = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            await (0, fs_1.remove)(p);
            spy.mockRestore();
        });
        it('should remove folder', async () => {
            let f = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            let p = path_1.default.join(f, 'a/b/c');
            fs_2.default.mkdirSync(p, { recursive: true });
            await (0, fs_1.remove)(f);
            let exists = fs_2.default.existsSync(f);
            expect(exists).toBe(false);
        });
    });
    describe('getFileType()', () => {
        it('should get filetype', async () => {
            let res = await (0, fs_1.getFileType)(__dirname);
            expect(res).toBe(fs_1.FileType.Directory);
            res = await (0, fs_1.getFileType)(__filename);
            expect(res).toBe(fs_1.FileType.File);
            let newPath = path_1.default.join(os_1.default.tmpdir(), (0, uuid_1.v4)());
            fs_2.default.symlinkSync(__filename, newPath);
            res = await (0, fs_1.getFileType)(newPath);
            expect(res).toBe(fs_1.FileType.SymbolicLink);
            fs_2.default.unlinkSync(newPath);
            let spy = jest.spyOn(fs_2.default, 'lstat').mockImplementation((...args) => {
                let cb = args[args.length - 1];
                return cb(undefined, {
                    isFile: () => { return false; },
                    isDirectory: () => { return false; },
                    isSymbolicLink: () => { return false; }
                });
            });
            res = await (0, fs_1.getFileType)('__file');
            expect(res).toBe(fs_1.FileType.Unknown);
            spy.mockRestore();
        });
    });
    describe('checkFolder()', () => {
        it('should check file in folder', async () => {
            let cwd = process.cwd();
            let res = await (0, fs_1.checkFolder)(cwd, ['package.json']);
            expect(res).toBe(true);
            res = await (0, fs_1.checkFolder)(cwd, ['**/schema.json', 'package.json']);
            expect(res).toBe(true);
            res = await (0, fs_1.checkFolder)(cwd, []);
            expect(res).toBe(false);
            res = await (0, fs_1.checkFolder)(cwd, ['not_exists_fs'], vscode_languageserver_protocol_1.CancellationToken.None);
            expect(res).toBe(false);
            res = await (0, fs_1.checkFolder)(os_1.default.homedir(), ['not_exists_fs']);
            expect(res).toBe(false);
            res = await (0, fs_1.checkFolder)('/a/b/c', ['not_exists_fs']);
            expect(res).toBe(false);
            let tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
            let p = (0, fs_1.checkFolder)(cwd, ['**/a.java'], tokenSource.token);
            let fn = async () => {
                tokenSource.cancel();
                res = await p;
            };
            await expect(fn()).rejects.toThrow(Error);
            expect(res).toBe(false);
        });
    });
    describe('renameAsync()', () => {
        it('should rename file', async () => {
            let id = (0, uuid_1.v4)();
            let filepath = path_1.default.join(os_1.default.tmpdir(), id);
            await (0, fs_1.writeFile)(filepath, id);
            let dest = path_1.default.join(os_1.default.tmpdir(), 'bar');
            await (0, fs_1.renameAsync)(filepath, dest);
            let exists = fs_2.default.existsSync(dest);
            expect(exists).toBe(true);
            fs_2.default.unlinkSync(dest);
        });
        it('should throw when file does not exist', async () => {
            let err;
            try {
                await (0, fs_1.renameAsync)('/foo/bar', '/a');
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeDefined();
        });
    });
    describe('getFileLineCount', () => {
        it('should throw when file does not exist', async () => {
            let err;
            try {
                await (0, fs_1.getFileLineCount)('/foo/bar');
            }
            catch (e) {
                err = e;
            }
            expect(err).toBeDefined();
        });
    });
    describe('sameFile', () => {
        it('should be casesensitive', () => {
            expect((0, fs_1.sameFile)('/a', '/A', false)).toBe(false);
            expect((0, fs_1.sameFile)('/a', '/A', true)).toBe(true);
        });
    });
    describe('readFileLine', () => {
        it('should read line', async () => {
            let res = await (0, fs_1.readFileLine)(__filename, 1);
            expect(res).toBeDefined();
            res = await (0, fs_1.readFileLine)(__filename, 9999);
            expect(res).toBeDefined();
            expect(res).toBe('');
        });
        it('should throw when file does not exist', async () => {
            const fn = async () => {
                await (0, fs_1.readFileLine)(__filename + 'fooobar', 1);
            };
            await expect(fn()).rejects.toThrow(Error);
        });
    });
    describe('readFileLines', () => {
        it('should throw when file does not exist', async () => {
            const fn = async () => {
                await (0, fs_1.readFileLines)(__filename + 'fooobar', 0, 3);
            };
            await expect(fn()).rejects.toThrow(Error);
        });
        it('should read lines', async () => {
            let res = await (0, fs_1.readFileLines)(__filename, 0, 1);
            expect(res.length).toBe(2);
        });
    });
    describe('fileStartsWith()', () => {
        it('should check casesensitive case', () => {
            expect((0, fs_1.fileStartsWith)('/a/b', '/A', false)).toBe(false);
            expect((0, fs_1.fileStartsWith)('/a/b', '/A', true)).toBe(true);
        });
    });
    describe('isGitIgnored()', () => {
        it('should be not ignored', async () => {
            let res = await (0, fs_1.isGitIgnored)(__filename);
            expect(res).toBeFalsy();
            let filepath = path_1.default.join(process.cwd(), 'build/index.js');
            res = await (0, fs_1.isGitIgnored)(filepath);
            expect(res).toBe(true);
        });
        it('should be ignored', async () => {
            let res = await (0, fs_1.isGitIgnored)('');
            let uid = (0, uuid_1.v4)();
            expect(res).toBe(false);
            res = await (0, fs_1.isGitIgnored)(path_1.default.join(os_1.default.tmpdir(), uid));
            expect(res).toBe(false);
            res = await (0, fs_1.isGitIgnored)(path_1.default.resolve(__dirname, '../lib/index.js.map'));
            expect(res).toBe(false);
            res = await (0, fs_1.isGitIgnored)(__filename);
            expect(res).toBe(false);
            let filepath = path_1.default.join(os_1.default.tmpdir(), uid);
            fs_2.default.writeFileSync(filepath, '', { encoding: 'utf8' });
            res = await (0, fs_1.isGitIgnored)(filepath);
            expect(res).toBe(false);
            if (fs_2.default.existsSync(filepath))
                fs_2.default.unlinkSync(filepath);
        });
    });
    describe('inDirectory', () => {
        it('should support wildcard', async () => {
            let res = (0, fs_1.inDirectory)(__dirname, ['**/file_not_exist.json']);
            expect(res).toBe(false);
        });
    });
    describe('parentDirs', () => {
        it('get parentDirs', () => {
            let dirs = (0, fs_1.parentDirs)('/a/b/c');
            expect(dirs).toEqual(['/', '/a', '/a/b']);
            expect((0, fs_1.parentDirs)('/')).toEqual(['/']);
        });
    });
    describe('isParentFolder', () => {
        it('check parent folder', () => {
            expect((0, fs_1.isParentFolder)('/a/b', '/a/b/')).toBe(false);
            expect((0, fs_1.isParentFolder)('/a', '/a/b')).toBe(true);
            expect((0, fs_1.isParentFolder)('/a/b', '/a/b')).toBe(false);
            expect((0, fs_1.isParentFolder)('/a/b', '/a/b', true)).toBe(true);
            expect((0, fs_1.isParentFolder)('//', '/', true)).toBe(true);
            expect((0, fs_1.isParentFolder)('/a/b/', '/a/b/c', true)).toBe(true);
        });
    });
    describe('resolveRoot', () => {
        it('resolve root consider root path', () => {
            let res = (0, fs_1.resolveRoot)(__dirname, ['.git']);
            expect(res).toMatch('coc.nvim');
        });
        it('should ignore glob pattern', () => {
            let res = (0, fs_1.resolveRoot)(__dirname, [path_1.default.basename(__filename)], undefined, false, false, ["**/__tests__/**"]);
            expect(res).toBeFalsy();
        });
        it('should ignore glob pattern bottom up', () => {
            let res = (0, fs_1.resolveRoot)(__dirname, [path_1.default.basename(__filename)], undefined, true, false, ["**/__tests__/**"]);
            expect(res).toBeFalsy();
        });
        it('should resolve from parent folders', () => {
            let root = path_1.default.resolve(__dirname, '../extensions/snippet-sample');
            let res = (0, fs_1.resolveRoot)(root, ['package.json']);
            expect(res.endsWith('coc.nvim')).toBe(true);
        });
        it('should resolve from parent folders with bottom-up method', () => {
            let dir = path_1.default.join(os_1.default.tmpdir(), 'extensions/snippet-sample');
            fs_2.default.mkdirSync(dir, { recursive: true });
            fs_2.default.writeFileSync(path_1.default.resolve(dir, '../package.json'), '{}');
            let res = (0, fs_1.resolveRoot)(dir, ['package.json'], null, true);
            expect(res.endsWith('extensions')).toBe(true);
            fs_2.default.rmSync(path_1.default.dirname(dir), { recursive: true, force: true });
        });
        it('should resolve to cwd', () => {
            let root = path_1.default.resolve(__dirname, '../../..');
            let res = (0, fs_1.resolveRoot)(root, ['package.json'], root, false, true);
            expect(res).toBe(root);
        });
        it('should resolve to root', () => {
            let root = path_1.default.resolve(__dirname, '../extensions/test/');
            let res = (0, fs_1.resolveRoot)(root, ['package.json'], root, false, false);
            expect(res).toBe(path_1.default.resolve(__dirname, '../../../'));
        });
        it('should not resolve to home', () => {
            let res = (0, fs_1.resolveRoot)(__dirname, ['.config'], undefined, false, false, [os_1.default.homedir()]);
            expect(res != os_1.default.homedir()).toBeTruthy();
        });
    });
    describe('findUp', () => {
        it('should findMatch by pattern', async () => {
            let res = (0, fs_1.findMatch)(process.cwd(), ['*.json']);
            expect(res).toMatch('.json');
            res = (0, fs_1.findMatch)(process.cwd(), ['*.json_not_exists']);
            expect(res).toBeUndefined();
        });
        it('findUp by filename', () => {
            let filepath = (0, fs_1.findUp)('package.json', __dirname);
            expect(filepath).toMatch('coc.nvim');
            filepath = (0, fs_1.findUp)('not_exists', __dirname);
            expect(filepath).toBeNull();
        });
        it('findUp by filenames', async () => {
            let filepath = (0, fs_1.findUp)(['src'], __dirname);
            expect(filepath).toMatch('coc.nvim');
        });
    });
});
//# sourceMappingURL=fs.test.js.map