"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const events_1 = tslib_1.__importDefault(require("../../events"));
const languages_1 = tslib_1.__importDefault(require("../../languages"));
const util_1 = require("../../util");
const workspace_1 = tslib_1.__importDefault(require("../../workspace"));
const helper_1 = tslib_1.__importDefault(require("../helper"));
const parser_1 = tslib_1.__importDefault(require("./parser"));
let nvim;
let symbols;
let disposables = [];
beforeAll(async () => {
    await helper_1.default.setup();
    nvim = helper_1.default.nvim;
    symbols = helper_1.default.plugin.getHandler().symbols;
});
beforeEach(() => {
    disposables.push(languages_1.default.registerDocumentSymbolProvider([{ language: 'javascript' }], {
        provideDocumentSymbols: document => {
            let content = document.getText();
            let showDetail = content.includes('detail');
            let parser = new parser_1.default(content, showDetail);
            let res = parser.parse();
            if (res.length) {
                res[0].tags = [vscode_languageserver_protocol_1.SymbolTag.Deprecated];
            }
            return Promise.resolve(res);
        }
    }));
});
afterAll(async () => {
    await helper_1.default.shutdown();
});
afterEach(async () => {
    (0, util_1.disposeAll)(disposables);
    disposables = [];
    await helper_1.default.reset();
    await nvim.command(`let w:cocViewId = ''`);
});
async function getOutlineBuffer() {
    let winid = await nvim.call('coc#window#find', ['cocViewId', 'OUTLINE']);
    if (winid == -1)
        return undefined;
    let bufnr = await nvim.call('winbufnr', [winid]);
    if (bufnr == -1)
        return undefined;
    return nvim.createBuffer(bufnr);
}
describe('symbols outline', () => {
    let defaultCode = `class myClass {
  fun1() { }
  fun2() {}
}`;
    async function createBuffer(code = defaultCode) {
        await helper_1.default.edit();
        let buf = await nvim.buffer;
        await nvim.command('setf javascript');
        await buf.setOption('modifiable', true);
        await buf.setLines(code.split('\n'), { start: 0, end: -1, strictIndexing: false });
        let doc = await workspace_1.default.document;
        await doc.synchronize();
        return buf;
    }
    describe('configuration', () => {
        it('should follow cursor', async () => {
            await createBuffer(`  class myClass {
  fun1() { }
  fun2() {}
}`);
            let curr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(0);
            let bufnr = await nvim.call('bufnr', ['%']);
            await nvim.command('wincmd p');
            await nvim.command('exe 3');
            await events_1.default.fire('CursorHold', [curr, [3, 1]]);
            await helper_1.default.wait(50);
            await nvim.call('cursor', [1, 1]);
            await events_1.default.fire('CursorHold', [curr, [1, 1]]);
            await helper_1.default.wait(30);
            let buf = nvim.createBuffer(bufnr);
            let lines = await buf.getLines();
            expect(lines.slice(1)).toEqual([
                '- c myClass 1', '    m fun1 2', '    m fun2 3'
            ]);
            let signs = await buf.getSigns({ group: 'CocTree' });
            expect(signs.length).toBe(1);
            expect(signs[0]).toEqual({
                lnum: 2,
                id: 3001,
                name: 'CocTreeSelected',
                priority: 10,
                group: 'CocTree'
            });
            await nvim.command(`bd ${bufnr}`);
            await events_1.default.fire('CursorHold', [curr, [3, 1]]);
        });
        it('should not follow cursor', async () => {
            helper_1.default.updateConfiguration('outline.followCursor', false);
            await createBuffer();
            let curr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(0);
            let bufnr = await nvim.call('bufnr', ['%']);
            await nvim.command('wincmd p');
            await nvim.command('exe 3');
            await events_1.default.fire('CursorHold', [curr]);
            await helper_1.default.wait(50);
            let buf = nvim.createBuffer(bufnr);
            let signs = await buf.getSigns({ group: 'CocTree' });
            expect(signs.length).toBe(0);
        });
        it('should keep current window', async () => {
            helper_1.default.updateConfiguration('outline.keepWindow', true);
            await createBuffer();
            let curr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline();
            let bufnr = await nvim.call('bufnr', ['%']);
            expect(curr).toBe(bufnr);
        });
        it('should check on buffer switch', async () => {
            helper_1.default.updateConfiguration('outline.checkBufferSwitch', true);
            let b = await createBuffer();
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            let bufnr = buf.id;
            await helper_1.default.edit('unnamed');
            await helper_1.default.waitValue(async () => {
                let buf = await getOutlineBuffer();
                return buf.id > bufnr;
            }, true);
            buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines[0]).toMatch('Document symbol provider not found');
            await nvim.command(`bd! ${b.id}`);
            await helper_1.default.wait(10);
            let loaded = await buf.loaded;
            expect(loaded).toBe(true);
        });
        it('should not check on buffer switch', async () => {
            helper_1.default.updateConfiguration('outline.checkBufferSwitch', false);
            await createBuffer();
            await symbols.showOutline(1);
            await helper_1.default.edit('unnamed');
            await helper_1.default.wait(100);
            let buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines.slice(1)).toEqual([
                '- c myClass 1', '    m fun1 2', '    m fun2 3'
            ]);
        });
        it('should not check on buffer reload', async () => {
            helper_1.default.updateConfiguration('outline.checkBufferSwitch', false);
            await symbols.showOutline(1);
            await createBuffer();
            await helper_1.default.wait(50);
            let buf = await getOutlineBuffer();
            expect(buf).toBeDefined();
        });
        it('should sort by category', async () => {
            let code = `
class myClass {
}
fun1() {}
`;
            await createBuffer(code);
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines).toEqual([
                'OUTLINE Category', '  c myClass 2', '  m fun1 4'
            ]);
        });
        it('should sort by position', async () => {
            let code = `class myClass {
  fun2() { }
  fun1() {}
}`;
            helper_1.default.updateConfiguration('outline.sortBy', 'position');
            await createBuffer(code);
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines).toEqual([
                'OUTLINE Position', '- c myClass 1', '    m fun2 2', '    m fun1 3'
            ]);
        });
        it('should sort by name', async () => {
            let code = `class myClass {
  fun2() {}
  fun1() {}
}`;
            helper_1.default.updateConfiguration('outline.sortBy', 'name');
            await createBuffer(code);
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines).toEqual([
                'OUTLINE Name', '- c myClass 1', '    m fun1 3', '    m fun2 2'
            ]);
        });
        it('should change sort method', async () => {
            helper_1.default.updateConfiguration('outline.detailAsDescription', false);
            let code = `class detail {
  fun2() {}
  fun1() {}
}`;
            await createBuffer(code);
            await symbols.showOutline(0);
            await helper_1.default.wait(30);
            await nvim.input('<C-s>');
            await helper_1.default.waitPrompt();
            await nvim.input('<esc>');
            await helper_1.default.wait(30);
            await nvim.input('<C-s>');
            await helper_1.default.waitPrompt();
            await nvim.input('3');
            await helper_1.default.waitFor('getline', [1], 'OUTLINE Position');
        });
        it('should show detail as description', async () => {
            helper_1.default.updateConfiguration('outline.detailAsDescription', true);
            let code = `class detail {
  fun2() {}
}`;
            await createBuffer(code);
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines.slice(1)).toEqual([
                '- c detail 1', '    m fun2 () 2'
            ]);
        });
        it('should not showLineNumber', async () => {
            helper_1.default.updateConfiguration('outline.showLineNumber', false);
            let code = `class detail {
  fun2() {}
}`;
            await createBuffer(code);
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            let lines = await buf.lines;
            expect(lines.slice(1)).toEqual(['- c detail', '    m fun2 ()']);
        });
    });
    describe('events', () => {
        it('should not close TreeView on buffer reload', async () => {
            await createBuffer();
            await symbols.showOutline(0);
            await nvim.command('edit');
            await helper_1.default.wait(30);
            let winid = await nvim.call('coc#window#find', ['cocViewId', 'OUTLINE']);
            expect(winid).toBeGreaterThan(0);
        });
        it('should dispose on buffer unload', async () => {
            await createBuffer();
            let curr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(0);
            await nvim.command('tabe');
            await nvim.command(`bd! ${curr}`);
            await helper_1.default.waitValue(async () => {
                let buf = await getOutlineBuffer();
                return buf == null;
            }, true);
        });
        it('should check current window on BufEnter', async () => {
            await createBuffer();
            await symbols.showOutline(1);
            await nvim.command('enew');
            await helper_1.default.wait(50);
        });
        it('should recreated when original window exists', async () => {
            let win = await nvim.window;
            await symbols.showOutline(1);
            await helper_1.default.wait(50);
            await nvim.setWindow(win);
            await createBuffer();
            await helper_1.default.waitValue(async () => {
                let buf = await getOutlineBuffer();
                return buf != null;
            }, true);
        });
        it('should keep old outline when new buffer not attached', async () => {
            await createBuffer();
            await symbols.showOutline(1);
            await nvim.command(`vnew +setl\\ buftype=nofile`);
            await helper_1.default.wait(50);
            let buf = await getOutlineBuffer();
            expect(buf).toBeDefined();
            let lines = await buf.lines;
            expect(lines.slice(1)).toEqual([
                '- c myClass 1', '    m fun1 2', '    m fun2 3'
            ]);
        });
        it('should not reload when switch to original buffer', async () => {
            await createBuffer();
            await symbols.showOutline(0);
            let buf = await getOutlineBuffer();
            let name = await buf.name;
            await nvim.command('wincmd p');
            await helper_1.default.wait(50);
            buf = await getOutlineBuffer();
            let curr = await buf.name;
            expect(curr).toBe(name);
        });
    });
    describe('show()', () => {
        it('should not throw when document not attached', async () => {
            await nvim.command(`edit +setl\\ buftype=nofile t`);
            await workspace_1.default.document;
            await symbols.showOutline(1);
            let line = await helper_1.default.getCmdline();
            expect(line).toMatch('Unable to show outline');
        });
        it('should not throw when provider does not exist', async () => {
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            expect(buf).toBeDefined();
        });
        it('should not throw when symbols is empty', async () => {
            await createBuffer('');
            await symbols.showOutline(1);
            let buf = await getOutlineBuffer();
            expect(buf).toBeDefined();
        });
        it('should jump to selected symbol', async () => {
            await createBuffer();
            let bufnr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [3], '    m fun1 2');
            await nvim.command('exe 3');
            await nvim.input('<cr>');
            await helper_1.default.waitValue(async () => {
                return await nvim.call('bufnr', ['%']);
            }, bufnr);
            let cursor = await nvim.call('coc#cursor#position');
            expect(cursor).toEqual([1, 2]);
        });
        it('should update symbols', async () => {
            await createBuffer();
            let doc = await workspace_1.default.document;
            let bufnr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(1);
            await helper_1.default.waitFor('getline', [1], 'class myClass {');
            let buf = nvim.createBuffer(bufnr);
            let code = 'class foo{}';
            await buf.setLines(code.split('\n'), {
                start: 0,
                end: -1,
                strictIndexing: false
            });
            await doc.synchronize();
            buf = await getOutlineBuffer();
            await helper_1.default.waitFor('eval', [`getbufline(${buf.id},1)[0]`], /No\sresults/);
            let lines = await buf.lines;
            expect(lines).toEqual([
                'No results',
                '',
                'OUTLINE Category'
            ]);
        });
        it('should show label in description', async () => {
            disposables.push(languages_1.default.registerDocumentSymbolProvider([{ language: 'vim' }], {
                meta: {
                    label: 'vimlsp'
                },
                provideDocumentSymbols: _ => {
                    let res = [{
                            name: 'let',
                            range: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
                            kind: vscode_languageserver_protocol_1.SymbolKind.Constant,
                            selectionRange: vscode_languageserver_protocol_1.Range.create(0, 0, 0, 3),
                            tags: [vscode_languageserver_protocol_1.SymbolTag.Deprecated]
                        }];
                    return Promise.resolve(res);
                }
            }));
            let doc = await helper_1.default.createDocument('t.vim');
            await nvim.command('setf vim');
            let buf = await nvim.buffer;
            await buf.setLines(['let'], { start: 0, end: -1, strictIndexing: false });
            await doc.synchronize();
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [1], 'OUTLINE vimlsp');
        });
    });
    describe('autoPreview', () => {
        it('should toggle auto preview by press p', async () => {
            await createBuffer();
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [3], /fun1/);
            await nvim.command('exe 2');
            await nvim.input('p');
            let winid = await helper_1.default.waitFloat();
            expect(winid).toBeGreaterThan(1000);
            await nvim.input('p');
            await helper_1.default.waitValue(async () => {
                let win = nvim.createWindow(winid);
                let valid = await win.valid;
                return valid === false;
            }, true);
        });
        it('should close preview when move to line without node', async () => {
            await createBuffer();
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [3], /fun1/);
            await nvim.command('exe 2');
            await nvim.input('p');
            let winid = await helper_1.default.waitFloat();
            await nvim.input('l');
            await nvim.input('k');
            await helper_1.default.waitValue(async () => {
                let win = nvim.createWindow(winid);
                let valid = await win.valid;
                return valid === false;
            }, true);
        });
        it('should show preview when move cursor back', async () => {
            await createBuffer();
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [3], /fun1/);
            await nvim.command('exe 2');
            await nvim.input('p');
            let winid = await helper_1.default.waitFloat();
            await nvim.command('wincmd p');
            await helper_1.default.waitValue(async () => {
                let win = nvim.createWindow(winid);
                let valid = await win.valid;
                return valid === false;
            }, true);
            await nvim.command('wincmd p');
            winid = await helper_1.default.waitFloat();
            expect(winid).toBeGreaterThan(1000);
        });
        it('should enable auto preview by configuration', async () => {
            helper_1.default.updateConfiguration('outline.autoPreview', true);
            await createBuffer();
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [3], /fun1/);
            await nvim.command('exe 2');
            let winid = await helper_1.default.waitFloat();
            expect(winid).toBeGreaterThan(1000);
        });
    });
    describe('actions', () => {
        it('should invoke visual select', async () => {
            await createBuffer();
            let bufnr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(0);
            await helper_1.default.waitFor('getline', [3], /fun1/);
            await nvim.command('exe 3');
            await nvim.input('<tab>');
            await helper_1.default.waitPrompt();
            await nvim.input('<cr>');
            await helper_1.default.waitFor('mode', [], 'v');
            let buf = await nvim.buffer;
            expect(buf.id).toBe(bufnr);
        });
        it('should invoke selected code action', async () => {
            const codeAction = vscode_languageserver_protocol_1.CodeAction.create('my action', vscode_languageserver_protocol_1.CodeActionKind.Refactor);
            let uri;
            disposables.push(languages_1.default.registerCodeActionProvider([{ language: '*' }], {
                provideCodeActions: () => [codeAction],
                resolveCodeAction: (action) => {
                    action.edit = {
                        changes: {
                            [uri]: [vscode_languageserver_protocol_1.TextEdit.del(vscode_languageserver_protocol_1.Range.create(0, 0, 0, 5))]
                        }
                    };
                    return action;
                }
            }, undefined));
            await createBuffer();
            let bufnr = await nvim.call('bufnr', ['%']);
            let doc = workspace_1.default.getDocument(bufnr);
            uri = doc.uri;
            await symbols.showOutline(0);
            await helper_1.default.wait(200);
            await nvim.command('exe 3');
            await nvim.input('<tab>');
            await helper_1.default.wait(50);
            await nvim.input('<cr>');
            await helper_1.default.wait(200);
            let buf = await nvim.buffer;
            let lines = await buf.lines;
            expect(lines[0]).toBe(' myClass {');
        });
    });
    describe('hide()', () => {
        it('should hide outline', async () => {
            await createBuffer('');
            await helper_1.default.doAction('showOutline', 1);
            await helper_1.default.wait(10);
            await helper_1.default.doAction('hideOutline');
            let buf = await getOutlineBuffer();
            expect(buf).toBeUndefined();
        });
        it('should not throw when outline does not exist', async () => {
            await symbols.hideOutline();
            let buf = await getOutlineBuffer();
            expect(buf).toBeUndefined();
        });
    });
    describe('dispose', () => {
        it('should dispose provider and views', async () => {
            await createBuffer('');
            let bufnr = await nvim.call('bufnr', ['%']);
            await symbols.showOutline(1);
            symbols.dispose();
            await helper_1.default.waitValue(() => {
                return symbols.hasOutline(bufnr);
            }, false);
            let buf = await getOutlineBuffer();
            expect(buf).toBeUndefined();
        });
    });
});
//# sourceMappingURL=outline.test.js.map