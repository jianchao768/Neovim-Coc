'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlayHintsFeature = void 0;
const tslib_1 = require("tslib");
const languages_1 = tslib_1.__importDefault(require("../languages"));
const protocol_1 = require("../util/protocol");
const features_1 = require("./features");
const cv = tslib_1.__importStar(require("./utils/converter"));
class InlayHintsFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, protocol_1.InlayHintRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlayHint');
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
            properties: ['tooltip', 'textEdits', 'label.tooltip', 'label.location', 'label.command']
        };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlayHint').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(protocol_1.InlayHintRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlayHints.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const eventEmitter = new protocol_1.Emitter();
        const provider = {
            onDidChangeInlayHints: eventEmitter.event,
            provideInlayHints: (document, range, token) => {
                const client = this._client;
                const provideInlayHints = (document, range, token) => {
                    const requestParams = {
                        textDocument: cv.asTextDocumentIdentifier(document),
                        range
                    };
                    return this.sendRequest(protocol_1.InlayHintRequest.type, requestParams, token, null);
                };
                const middleware = client.middleware;
                return middleware.provideInlayHints
                    ? middleware.provideInlayHints(document, range, token, provideInlayHints)
                    : provideInlayHints(document, range, token);
            }
        };
        provider.resolveInlayHint = options.resolveProvider === true
            ? (hint, token) => {
                const client = this._client;
                const resolveInlayHint = (item, token) => {
                    return this.sendRequest(protocol_1.InlayHintResolveRequest.type, item, token);
                };
                const middleware = client.middleware;
                return middleware.resolveInlayHint
                    ? middleware.resolveInlayHint(hint, token, resolveInlayHint)
                    : resolveInlayHint(hint, token);
            }
            : undefined;
        const selector = options.documentSelector;
        return [languages_1.default.registerInlayHintsProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
    }
}
exports.InlayHintsFeature = InlayHintsFeature;
//# sourceMappingURL=inlayHint.js.map