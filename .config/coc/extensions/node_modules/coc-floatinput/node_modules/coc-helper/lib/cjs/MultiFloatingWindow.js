"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiFloatingWindow = void 0;
const coc_nvim_1 = require("coc.nvim");
const _1 = require(".");
const FloatingUtil_1 = require("./FloatingUtil");
const FloatingWindow_1 = require("./FloatingWindow");
class MultiFloatingWindow {
    static async create(options) {
        const borderWin = await FloatingWindow_1.FloatingWindow.create(Object.assign({ hasBorderBuf: false, mode: 'show' }, options));
        const wins = await Promise.all(Object.entries(options.wins).map(async ([key, win]) => [
            key,
            await FloatingWindow_1.FloatingWindow.create(Object.assign({ hasBorderBuf: false }, win)),
        ]));
        const winDict = wins.reduce((dict, [key, win]) => {
            dict[key] = win;
            return dict;
        }, {});
        const util = new FloatingUtil_1.FloatingUtil(FloatingWindow_1.FloatingWindow.srcId);
        return new MultiFloatingWindow(borderWin, winDict, util);
    }
    constructor(borderFloatWin, floatWinDict, util) {
        this.borderFloatWin = borderFloatWin;
        this.floatWinDict = floatWinDict;
        this.util = util;
        this.disposables = [];
        this.floatWins = Object.values(this.floatWinDict);
        this.nvim = coc_nvim_1.workspace.nvim;
        this.bufnrs = [borderFloatWin.bufnr, ...this.floatWins.map((w) => w.bufnr)];
        this.disposables.push(coc_nvim_1.events.on('BufWinLeave', async (bufnr) => {
            if (this.bufnrs.includes(bufnr)) {
                await this.close();
            }
        }), coc_nvim_1.Disposable.create(() => {
            borderFloatWin.dispose();
            (0, coc_nvim_1.disposeAll)(this.floatWins);
        }));
    }
    async opened() {
        return this.borderFloatWin.opened();
    }
    async sizeByWinsOptions(winsOptions) {
        var _a, _b;
        let width = 0, height = 0;
        for (const winOptions of winsOptions) {
            const ctx = await this.util.createContext(winOptions);
            const boxes = this.util.getBoxSizes(ctx, winOptions, false);
            const w = ((_a = winOptions.left) !== null && _a !== void 0 ? _a : 0) + boxes.borderBox[2];
            if (w > width) {
                width = w;
            }
            const h = ((_b = winOptions.top) !== null && _b !== void 0 ? _b : 0) + boxes.borderBox[3];
            if (h > height) {
                height = h;
            }
        }
        return [width, height];
    }
    async batchAction(notifierAction, options, { reverse = false, updateCursorPosition = true } = {}) {
        var _a, _b;
        const [width, height] = await this.sizeByWinsOptions(Object.values(options.wins));
        const finalOptions = Object.assign({ width,
            height }, options);
        const ctx = await this.util.createContext(finalOptions);
        const { contentBox } = this.util.getBoxSizes(ctx, finalOptions, updateCursorPosition);
        const notifiers = [];
        for (const [key, floatWin] of Object.entries(this.floatWinDict)) {
            const winOptions = options.wins[key];
            if (!winOptions) {
                continue;
            }
            notifiers.push(await floatWin[notifierAction](Object.assign(Object.assign({}, winOptions), { relative: 'editor', top: contentBox[0] + ((_a = winOptions.top) !== null && _a !== void 0 ? _a : 0), left: contentBox[1] + ((_b = winOptions.left) !== null && _b !== void 0 ? _b : 0) })));
        }
        notifiers.push(await this.borderFloatWin[notifierAction](Object.assign(Object.assign({}, finalOptions), { borderOnly: true })));
        if (reverse) {
            notifiers.reverse();
        }
        await _1.Notifier.runAll(notifiers);
    }
    async open(options) {
        return this.batchAction('openNotifier', options);
    }
    async resume(options) {
        return this.batchAction('resumeNotifier', options);
    }
    resize(options) {
        return this.batchAction('resizeNotifier', options, {
            updateCursorPosition: false,
        });
    }
    async win() {
        return {
            borderWin: await this.borderFloatWin.win(),
            wins: await this.wins(),
        };
    }
    async wins() {
        return await Promise.all(this.floatWins.map((win) => win.win()));
    }
    async close() {
        const notifiers = [];
        notifiers.push(this.borderFloatWin.closeNotifier());
        notifiers.push(...this.floatWins.map((win) => win.closeNotifier()));
        await _1.Notifier.runAll(notifiers);
    }
    dispose() {
        (0, coc_nvim_1.disposeAll)(this.disposables);
    }
}
exports.MultiFloatingWindow = MultiFloatingWindow;
