import { Disposable } from 'coc.nvim';
import type { HelperLogger } from './util';
type Arguments<F extends () => any> = F extends (...args: infer Args) => any ? Args : never;
declare namespace HelperEventEmitter {
    type EventResult = void | Promise<void>;
    type EventListener = (...args: any[]) => EventResult;
    type BufEventListener = (bufnr: number) => EventResult;
    interface VimEventOptions {
        eventExpr: string;
        argExprs?: string[];
        /**
         * @default
         */
        async?: boolean;
    }
}
export declare class HelperEventEmitter<Events extends Record<string, any>> {
    protected helperLogger: HelperLogger;
    readonly concurrent: boolean;
    listenersMap: Map<keyof Events, HelperEventEmitter.EventListener[]>;
    constructor(helperLogger: HelperLogger, concurrent?: boolean);
    listeners(event: keyof Events): HelperEventEmitter.EventListener[];
    once<E extends keyof Events>(event: E, listener: Events[E], disposables?: Disposable[]): Disposable;
    on<E extends keyof Events>(event: E, listener: Events[E], disposables?: Disposable[]): Disposable;
    off<E extends keyof Events>(event: E, listener: Events[E]): void;
    fire<E extends keyof Events>(event: E, ...args: Arguments<Events[E]>): Promise<void>;
}
export {};
