import { disposeAll, events, workspace } from 'coc.nvim';
import { Notifier } from './notifier';
import { floatingModule } from './modules/floating';
import { utilModule } from './modules/util';
import { helperLogger } from './util';
import { FloatingUtil } from './FloatingUtil';
/**
 * @deprecated Because VimModule deprecated
 */
export class FloatingWindow {
    static getInitedExecute(mode, options) {
        var _a, _b, _c, _d;
        let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, FloatingWindow.initedContextVars.create)) !== null && _b !== void 0 ? _b : '';
        initedExecute = `${FloatingWindow.modePresets[mode].createInitedExecute(FloatingWindow.initedContextVars.create)}\n${initedExecute}`;
        const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, FloatingWindow.initedContextVars.create)) !== null && _d !== void 0 ? _d : FloatingWindow.modePresets.show.createInitedExecute(FloatingWindow.initedContextVars.create);
        return [initedExecute, borderInitedExecute];
    }
    static async create(options = {}) {
        var _a, _b, _c;
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : 'default';
        const [initedExecute, borderInitedExecute] = this.getInitedExecute(mode, options);
        const [bufnr, borderBufnr] = await floatingModule.create.call((_b = options.name) !== null && _b !== void 0 ? _b : '', initedExecute, (_c = options.hasBorderBuf) !== null && _c !== void 0 ? _c : true, borderInitedExecute);
        const floatingUtil = new FloatingUtil(this.srcId);
        return new FloatingWindow(bufnr, borderBufnr !== null && borderBufnr !== void 0 ? borderBufnr : undefined, options, mode, floatingUtil);
    }
    constructor(bufnr, borderBufnr, createOptions, mode, util) {
        this.bufnr = bufnr;
        this.borderBufnr = borderBufnr;
        this.createOptions = createOptions;
        this.mode = mode;
        this.util = util;
        this.nvim = workspace.nvim;
        this.disposables = [];
        this.nvim = workspace.nvim;
        this.buffer = this.nvim.createBuffer(bufnr);
        if (borderBufnr) {
            this.borderBuffer = workspace.nvim.createBuffer(borderBufnr);
            this.disposables.push(events.on('BufWinLeave', helperLogger.asyncCatch(async (curBufnr) => {
                // close border win
                if (this.borderBufnr && curBufnr === this.bufnr) {
                    await utilModule.closeWinByBufnr.call([this.borderBufnr]);
                }
            })));
        }
    }
    getInitedExecute(options) {
        var _a, _b, _c, _d;
        let initedExecute = (_b = (_a = options.initedExecute) === null || _a === void 0 ? void 0 : _a.call(options, FloatingWindow.initedContextVars.open)) !== null && _b !== void 0 ? _b : '';
        initedExecute = `${FloatingWindow.modePresets[this.mode].openInitedExecute(FloatingWindow.initedContextVars.open)}\n${initedExecute}`;
        const borderInitedExecute = (_d = (_c = options.borderInitedExecute) === null || _c === void 0 ? void 0 : _c.call(options, FloatingWindow.initedContextVars.open)) !== null && _d !== void 0 ? _d : FloatingWindow.modePresets.show.openInitedExecute(FloatingWindow.initedContextVars.open);
        return [initedExecute, borderInitedExecute];
    }
    getFocus(options) {
        var _a, _b;
        return ((_b = (_a = options.focus) !== null && _a !== void 0 ? _a : (this.mode ? FloatingWindow.modePresets[this.mode].focus : undefined)) !== null && _b !== void 0 ? _b : false);
    }
    getModifiable(options) {
        var _a, _b;
        return ((_b = (_a = options.modifiable) !== null && _a !== void 0 ? _a : (this.mode
            ? FloatingWindow.modePresets[this.mode].modifiable
            : undefined)) !== null && _b !== void 0 ? _b : false);
    }
    setLinesNotifier(options) {
        return Notifier.create(() => {
            if (!options.lines && !options.modifiable) {
                return;
            }
            const modifiable = this.getModifiable(options);
            this.buffer.setOption('modifiable', true, true);
            this.buffer.setOption('readonly', false, true);
            if (options.lines) {
                void this.buffer.setLines(options.lines, { start: 0, end: -1 }, true);
            }
            if (!modifiable) {
                this.buffer.setOption('modifiable', false, true);
                this.buffer.setOption('readonly', true, true);
            }
            if (options.highlights) {
                for (const hl of options.highlights) {
                    this.util.addHighlightsNotify(this.buffer, [hl]);
                }
            }
            if (workspace.isVim) {
                this.nvim.command('redraw!', true);
            }
        });
    }
    async setLines(options) {
        await this.setLinesNotifier(options).run();
    }
    async opened() {
        const win = await this.win();
        return !!win;
    }
    async openNotifier(options) {
        var _a;
        if (options.width <= 0 || options.height <= 0) {
            return Notifier.noop();
        }
        const notifiers = [];
        notifiers.push(this.closeNotifier());
        const ctx = await this.util.createContext(options);
        const [initedExecute, borderInitedExecute] = this.getInitedExecute(options);
        const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
        if (options.borderOnly && borderWinConfig) {
            notifiers.push(floatingModule.open.callNotifier(this.bufnr, borderWinConfig, borderInitedExecute, null, null, '', false, this.util.nvimWinHl(options)));
            notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
        }
        else {
            notifiers.push(floatingModule.open.callNotifier(this.bufnr, winConfig, initedExecute, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, borderInitedExecute, this.getFocus(options), this.util.nvimWinHl(options)));
        }
        if (workspace.isNvim && this.borderBuffer && borderWinConfig) {
            notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
        }
        notifiers.push(this.setLinesNotifier(options), Notifier.create(() => {
            if (options.filetype) {
                this.buffer.setOption('filetype', options.filetype, true);
            }
        }));
        return Notifier.combine(notifiers);
    }
    async open(options) {
        await (await this.openNotifier(options)).run();
    }
    async resumeNotifier(options) {
        const ctx = await this.util.createContext(options);
        const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options);
        return Notifier.create(() => {
            var _a;
            floatingModule.resume.callNotify(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.getFocus(options), this.util.nvimWinHl(options));
            if (this.borderBuffer && borderWinConfig) {
                this.util
                    .renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig)
                    .notify();
            }
            if (workspace.isVim) {
                this.nvim.command('redraw!', true);
            }
        });
    }
    async resume(options) {
        await (await this.resumeNotifier(options)).run();
    }
    async resizeNotifier(options) {
        var _a;
        const ctx = await this.util.createContext(options);
        const [winConfig, borderWinConfig] = this.util.winConfig(ctx, options, false);
        const notifiers = [];
        if (options.borderOnly && borderWinConfig) {
            notifiers.push(floatingModule.update.callNotifier(this.bufnr, borderWinConfig, null, null, this.util.nvimWinHl(options)));
            notifiers.push(this.util.renderBorderNotifier(this.buffer, ctx, options, borderWinConfig));
        }
        else {
            notifiers.push(floatingModule.update.callNotifier(this.bufnr, winConfig, (_a = this.borderBufnr) !== null && _a !== void 0 ? _a : null, borderWinConfig !== null && borderWinConfig !== void 0 ? borderWinConfig : null, this.util.nvimWinHl(options)));
        }
        if (workspace.isNvim && this.borderBuffer && borderWinConfig) {
            notifiers.push(this.util.renderBorderNotifier(this.borderBuffer, ctx, options, borderWinConfig));
        }
        notifiers.push(Notifier.create(() => {
            if (workspace.isVim) {
                this.nvim.command('redraw!', true);
            }
        }));
        return Notifier.combine(notifiers);
    }
    async resize(options) {
        await (await this.resizeNotifier(options)).run();
    }
    async win() {
        const winid = await floatingModule.winid.call(this.bufnr);
        return winid ? this.nvim.createWindow(winid) : undefined;
    }
    async borderWin() {
        const borderWinid = await floatingModule.winid.call(this.bufnr);
        return borderWinid ? this.nvim.createWindow(borderWinid) : undefined;
    }
    closeNotifier() {
        return floatingModule.close.callNotifier(this.bufnr);
    }
    async close() {
        await this.closeNotifier().run();
    }
    dispose() {
        disposeAll(this.disposables);
        this.disposables.forEach((s) => s.dispose());
    }
}
FloatingWindow.modePresets = {
    default: {
        modifiable: false,
        focus: false,
        createInitedExecute: () => '',
        openInitedExecute: () => '',
    },
    base: {
        createInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&buftype', 'nofile')
        call setbufvar(${ctx.bufnr}, '&bufhidden', 'hide')
        call setbufvar(${ctx.bufnr}, '&buflisted', 0)

        call setbufvar(${ctx.bufnr}, '&wrap', 1)

        call setbufvar(${ctx.bufnr}, '&swapfile', 0)

        call setbufvar(${ctx.bufnr}, '&modeline', 0)
      `,
        openInitedExecute: (ctx) => `
        call setbufvar(${ctx.bufnr}, '&list', 0)

        call setbufvar(${ctx.bufnr}, '&listchars', '')
        if has('nvim')
          call setbufvar(${ctx.bufnr}, '&fillchars', 'eob: ')
        endif

        call setbufvar(${ctx.bufnr}, '&signcolumn', 'no')
        call setbufvar(${ctx.bufnr}, '&number', 0)
        call setbufvar(${ctx.bufnr}, '&relativenumber', 0)
        call setbufvar(${ctx.bufnr}, '&foldenable', 0)
        call setbufvar(${ctx.bufnr}, '&foldcolumn', 0)

        call setbufvar(${ctx.bufnr}, '&spell', 0)

        call setbufvar(${ctx.bufnr}, '&cursorcolumn', 0)
        call setbufvar(${ctx.bufnr}, '&cursorline', 0)
        call setbufvar(${ctx.bufnr}, '&colorcolumn', '')
      `,
    },
    show: {
        modifiable: false,
        createInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.createInitedExecute(ctx)}
        " call setbufvar(${ctx.bufnr}, '&undofile', 0)
        " call setbufvar(${ctx.bufnr}, '&undolevels', -1)

        call setbufvar(${ctx.bufnr}, '&modifiable', 0)
        call setbufvar(${ctx.bufnr}, '&modified', 0)
        call setbufvar(${ctx.bufnr}, '&readonly', 1)
      `,
        openInitedExecute: (ctx) => `
        ${FloatingWindow.modePresets.base.openInitedExecute(ctx)}
      `,
    },
};
FloatingWindow.initedContextVars = {
    create: { bufnr: 'a:ctx.bufnr' },
    open: { bufnr: 'a:ctx.bufnr', winid: 'a:ctx.winid' },
};
FloatingWindow.srcId = 'coc-helper-floatwin';
