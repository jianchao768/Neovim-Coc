import { workspace } from 'coc.nvim';
import { Notifier } from './notifier';
import { helperLogger, versionName } from './util';
import { getModuleId } from './util/module';
const mid = getModuleId('VimModule');
const globalKey = `coc_helper_module_m${mid}_v${versionName}`;
const globalVariable = `g:${globalKey}`;
const callFunc = `CocHelperCallFn_m${mid}_v${versionName}`;
const declareVar = `CocHelperCallVar_m${mid}_v${versionName}`;
function filterLineCont(content) {
    return content.replace(/\n\s*\\/g, '');
}
/**
 * @deprecated Because VimModule will make the code difficult to debug
 */
export class VimModule {
    static async init(context) {
        this.inited = true;
        await workspace.nvim.call('execute', `
        if !exists('${globalVariable}')
          let ${globalVariable} = {}
        endif

        function! ${callFunc}(module_key, method_name, args)
          try
            return call(${globalVariable}[a:module_key][a:method_name], a:args)
          catch
            let ex = v:exception
            let msg = printf('error when call %s.%s.%s, args: [%s]', '${globalVariable}', a:module_key, a:method_name, join(a:args, ','))
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction

        function! ${declareVar}(module_key, var_name, expression)
          try
            let ${globalVariable}[a:module_key][a:var_name] = eval(a:expression)
          catch
            let ex = v:exception
            let msg = printf('error when declare %s.%s.%s, expression: %s', '${globalVariable}', a:module_key, a:var_name, a:expression)
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction
      `);
        const queue = [...this.initQueue];
        while (queue.length) {
            const it = queue.shift();
            try {
                await it.fn(context);
            }
            catch (error) {
                helperLogger.error(error);
            }
            if (this.initAfterQueue.length) {
                queue.push(...this.initAfterQueue);
                this.initAfterQueue = [];
            }
        }
    }
    static registerInit(description, fn) {
        if (!this.inited) {
            this.initQueue.push({ description, fn });
        }
        else {
            this.initAfterQueue.push({ description, fn });
        }
    }
    static create(moduleName, cb) {
        const id = getModuleId('VimModule.module');
        const moduleKey = `${id}_${moduleName}`;
        const vMod = new VimModule(moduleKey);
        let mod = undefined;
        function initedMod() {
            if (!mod) {
                mod = cb(vMod);
            }
            return mod;
        }
        VimModule.registerInit(`module ${moduleKey}`, async () => {
            await workspace.nvim.call('execute', `
          if !exists('${globalVariable}.${moduleKey}')
            let ${globalVariable}.${moduleKey} = {}
          endif
        `);
            initedMod();
        });
        return new Proxy({}, {
            get(_o, key) {
                return Reflect.get(initedMod(), key);
            },
            has(_o, key) {
                return key in initedMod();
            },
            ownKeys() {
                return Object.keys(initedMod());
            },
        });
    }
    constructor(moduleKey) {
        this.moduleKey = moduleKey;
    }
    registerInit(description, fn) {
        if (typeof description === 'string') {
            return VimModule.registerInit(description, fn);
        }
        else {
            return this.registerInit('', description);
        }
    }
    fn(fnName, getContent) {
        const { nvim } = workspace;
        const name = `${globalVariable}.${this.moduleKey}.${fnName}`;
        const content = getContent({ name });
        this.registerInit(`fn ${name}`, async () => {
            helperLogger.debug(`declare fn ${name}`);
            await nvim.call('execute', [filterLineCont(content)]);
        });
        return {
            name,
            inlineCall: (argsExpression = '') => `${callFunc}('${this.moduleKey}', '${fnName}', [${argsExpression}])`,
            call: (...args) => {
                helperLogger.debug(`call ${name}`);
                return nvim.call(callFunc, [
                    this.moduleKey,
                    fnName,
                    args,
                ]);
            },
            callNotify: (...args) => {
                helperLogger.debug(`callNotify ${name}`);
                return nvim.call(callFunc, [this.moduleKey, fnName, args], true);
            },
            callNotifier: (...args) => {
                helperLogger.debug(`callNotifier ${name}`);
                return Notifier.create(() => {
                    nvim.call(callFunc, [this.moduleKey, fnName, args], true);
                });
            },
        };
    }
    var(varName, expression) {
        const { nvim } = workspace;
        const name = `${globalVariable}.${this.moduleKey}.${varName}`;
        this.registerInit(`var ${name}`, async () => {
            helperLogger.debug(`declare var ${name}`);
            await nvim.call(declareVar, [
                this.moduleKey,
                varName,
                filterLineCont(expression),
            ]);
        });
        return {
            name,
            inline: name,
            get: () => {
                return nvim.eval(name);
            },
            set: async (expression) => {
                await nvim.call(declareVar, [
                    this.moduleKey,
                    varName,
                    filterLineCont(expression),
                ]);
            },
            setNotify: (expression) => {
                nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression)], true);
            },
            setNotifier: (expression) => {
                return Notifier.create(() => {
                    nvim.call(declareVar, [this.moduleKey, varName, filterLineCont(expression)], true);
                });
            },
        };
    }
}
VimModule.inited = false;
VimModule.initQueue = [];
VimModule.initAfterQueue = [];
