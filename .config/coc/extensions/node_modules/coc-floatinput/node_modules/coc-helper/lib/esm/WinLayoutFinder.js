import { workspace } from 'coc.nvim';
/**
 * Find the vim window by `winlayout()`
 *
 * @example
 * ```
 * const winFinder = WinLayoutFinder.create(tabnr);
 * const leaf = winFinder.find(winid)
 * // Parent
 * const parent = leaf.parent;
 * // Group type, 'col' or 'row'
 * const parentType = parent.group.type;
 * // Siblings
 * const siblings = parent.group.children;
 * ```
 */
export class WinLayoutFinder {
    static convertVimLayoutNode(vimLayout, parent) {
        if (vimLayout[0] === 'leaf') {
            return {
                type: vimLayout[0],
                winid: vimLayout[1],
                parent,
            };
        }
        else {
            const group = {
                type: vimLayout[0],
                children: [],
            };
            group.children = vimLayout[1].map((child, idx) => this.convertVimLayoutNode(child, {
                group,
                indexInParent: idx,
            }));
            return group;
        }
    }
    /**
     * Create a WinLayoutFinder instance
     *
     * @param tabnr The tabnr or use current tab with undefined
     *
     * @return Promise<WinLayoutFinder> instance
     */
    static async create(tabnr) {
        const args = tabnr ? [tabnr] : [];
        const root = await workspace.nvim.call('winlayout', args);
        return new this(this.convertVimLayoutNode(root));
    }
    static getFirstLeafWinid(node) {
        if (node.type === 'leaf') {
            return node.winid;
        }
        else {
            return this.getFirstLeafWinid(node.children[0]);
        }
    }
    constructor(root) {
        this.root = root;
    }
    /**
     * @return [node, parent, indexInParent]
     */
    findWinid(winid, beginNode = this.root) {
        if (beginNode.type === 'leaf') {
            if (beginNode.winid === winid) {
                return beginNode;
            }
        }
        else {
            for (const child of beginNode.children) {
                const target = this.findWinid(winid, child);
                if (target) {
                    return target;
                }
            }
        }
    }
    findClosest(beginNode, matchWinids) {
        const checked = new Set([beginNode]);
        const queue = [beginNode];
        while (queue.length) {
            const node = queue.shift();
            if (node.type === 'leaf') {
                if (matchWinids.includes(node.winid)) {
                    return node;
                }
            }
            else {
                for (const child of node.children) {
                    if (!checked.has(child)) {
                        queue.push(child);
                        checked.add(child);
                        continue;
                    }
                }
            }
            if (node.parent && !checked.has(node.parent.group)) {
                queue.push(node.parent.group);
                checked.add(node.parent.group);
            }
        }
    }
}
