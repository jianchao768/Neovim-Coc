"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prettyPrint = exports.prettyObject = exports.helperLogger = exports.HelperLogger = void 0;
const coc_nvim_1 = require("coc.nvim");
const util_1 = __importDefault(require("util"));
const env_1 = require("./env");
const levelList = [
    'trace',
    'debug',
    'info',
    'warn',
    'error',
    'fatal',
    'off',
];
const levelErrorNum = levelList.indexOf('error');
function formatDate(date) {
    return `${date.toLocaleString()} ${date
        .getMilliseconds()
        .toString()
        .padStart(3, '0')}`;
}
class HelperLogger {
    constructor(channelName) {
        this.channelName = channelName;
        this.timeMarkers = new Map();
        this.levelStatus = 'trace';
        this.levelNumber = levelList.indexOf(this.levelStatus);
        this.appendLine = (line) => {
            this.outputChannel.appendLine(line);
        };
        this.appendErrorLine = (line) => {
            if (env_1.isTest) {
                console.error(line);
            }
            else {
                void coc_nvim_1.window.showErrorMessage(line);
            }
        };
        this.log = (levelName, data) => {
            var _a, _b;
            const levelNum = levelList[levelName];
            if (levelNum < this.levelNumber) {
                return;
            }
            const prefix = `[${formatDate(new Date())}] [${levelName}]: `;
            if (data instanceof Error) {
                this.appendLine(`${prefix}${(_a = data.stack) !== null && _a !== void 0 ? _a : data.toString()}`);
                this.appendErrorLine(data.message);
                if (env_1.isTest) {
                    console.error((_b = data.stack) !== null && _b !== void 0 ? _b : data.toString());
                }
                return;
            }
            this.appendLine(`${prefix}${data}`);
            if (levelNum > levelErrorNum) {
                this.appendErrorLine(data);
            }
        };
        this.trace = (line) => {
            this.log('trace', line);
        };
        this.debug = (line) => {
            this.log('debug', line);
        };
        this.info = (line) => {
            this.log('info', line);
        };
        this.warn = (line) => {
            this.log('warn', line);
        };
        /**
         * Log and print error
         */
        this.error = (data) => {
            if (!(data instanceof Error)) {
                data = new Error(data);
            }
            this.log('error', data);
        };
        this.fatal = (data) => {
            this.log('fatal', data);
        };
        /**
         * Print data to outputChannel and vim message
         */
        this.prettyPrint = (...data) => {
            this.info(prettyObject(...data));
            this.appendErrorLine(`[${formatDate(new Date())}] ${prettyObject(...data)}`);
        };
    }
    /**
     * Default level is 'trace'
     */
    set level(level) {
        this.levelStatus = level;
        this.levelNumber = levelList[level];
    }
    get level() {
        return this.levelStatus;
    }
    dispose() {
        var _a;
        (_a = this.outputChannel_) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    get outputChannel() {
        if (!this.outputChannel_) {
            this.outputChannel_ = coc_nvim_1.window.createOutputChannel(this.channelName);
        }
        return this.outputChannel_;
    }
    time(label = 'default') {
        this.timeMarkers.set(label, new Date().valueOf());
    }
    /**
     * @returns milliseconds
     */
    timeElapsed(label = 'default') {
        const time = this.timeMarkers.get(label);
        if (time !== undefined) {
            return new Date().valueOf() - time;
        }
    }
    timeLog(label = 'default') {
        const time = this.timeElapsed(label);
        if (time !== undefined) {
            this.appendLine(`${label}: ${time} ms`);
        }
    }
    measureTime(task) {
        const time = new Date().valueOf();
        const result = task();
        if (result instanceof Promise) {
            return result.then((r) => {
                return [r, new Date().valueOf() - time];
            });
        }
        return [result, new Date().valueOf() - time];
    }
    measureTask(task, label = 'default', level = 'info') {
        const response = this.measureTime(task);
        if (!('then' in response)) {
            const [result, time] = response;
            this.log(level, `[measureTask] ${label}: ${time} ms`);
            return result;
        }
        return response.then(([result, time]) => {
            this.log(level, `${label}: ${time} ms`);
            return result;
        });
    }
    /**
     * Wrap the async function and catch the error
     */
    asyncCatch(fn) {
        return async (...args) => {
            try {
                return await fn(...args);
            }
            catch (e) {
                this.error(e);
            }
        };
    }
}
exports.HelperLogger = HelperLogger;
exports.helperLogger = new HelperLogger('coc-helper');
function prettyObject(...data) {
    return data.map((d) => util_1.default.inspect(d)).join(' ');
}
exports.prettyObject = prettyObject;
function prettyPrint(...data) {
    exports.helperLogger.prettyPrint(...data);
}
exports.prettyPrint = prettyPrint;
