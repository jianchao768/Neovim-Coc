import { Range, workspace } from 'coc.nvim';
import { utilModule } from './modules/util';
import { Notifier } from './notifier';
import { displayWidth } from './util';
const defaultBorderChars = ['─', '│', '─', '│', '┌', '┐', '┘', '└'];
const defaultWinHl = 'CocHelperNormalFloat';
const defaultWinHlNC = 'CocHelperNormalFloatNC';
const defaultBorderWinHl = 'CocHelperNormalFloatBorder';
/**
 * @deprecated Because VimModule deprecated
 */
export class FloatingUtil {
    constructor(srcId) {
        this.srcId = srcId;
    }
    async createContext(options) {
        var _a, _b;
        return ((_a = options.context) !== null && _a !== void 0 ? _a : {
            lines: workspace.env.lines,
            columns: workspace.env.columns - workspace.env.cmdheight - 1,
            globalCursorPosition: await utilModule.globalCursorPosition.call(),
            title: options.title
                ? {
                    text: options.title,
                    width: await displayWidth(options.title),
                }
                : { text: '', width: 0 },
            borderEnabled: !!options.border,
            border: this.extendEdges((_b = options.border) === null || _b === void 0 ? void 0 : _b.map((b) => (typeof b === 'boolean' ? 1 : b))),
            paddingEnabled: !!options.padding,
            padding: this.extendEdges(options.padding),
        });
    }
    getCenterPos(ctx, box) {
        const [, , width, height] = box;
        const top = Math.floor((ctx.lines - height) / 2);
        const left = Math.floor((ctx.columns - width) / 2);
        return [top, left];
    }
    getPosForAround(ctx, size, cursorPosition, preferAbove = false) {
        const columns = ctx.columns;
        const lines = ctx.lines - 1;
        const [width, height] = size;
        let [top, left] = cursorPosition;
        if (preferAbove) {
            if (top - height < 0) {
                top += 1;
            }
            else {
                top -= height;
            }
        }
        else {
            if (top + height >= lines) {
                top -= height;
            }
            else {
                top += 1;
            }
        }
        if (left + width >= columns) {
            left -= width - 1;
        }
        return [top, left];
    }
    /**
     * Extend around number to 4
     */
    extendEdges(edges) {
        var _a, _b, _c, _d;
        if (!edges) {
            return [0, 0, 0, 0];
        }
        const top = (_a = edges[0]) !== null && _a !== void 0 ? _a : 1;
        const right = (_b = edges[1]) !== null && _b !== void 0 ? _b : top;
        const bottom = (_c = edges[2]) !== null && _c !== void 0 ? _c : top;
        const left = (_d = edges[3]) !== null && _d !== void 0 ? _d : right;
        return [top, right, bottom, left];
    }
    /**
     * Change window box by around edges
     */
    changeBoxByEdgesList(box, edgesList) {
        let retBox = [...box];
        for (const edges of edgesList) {
            retBox = this.changeBoxByEdges(retBox, edges);
        }
        return retBox;
    }
    /**
     * Change window box by around edge
     */
    changeBoxByEdges(box, edges) {
        if (!edges) {
            return box;
        }
        const [wTop, wRight, wBottom, wLeft] = edges;
        let [top, left, width, height] = box;
        top -= wTop;
        left -= wLeft;
        width += wLeft + wRight;
        height += wTop + wBottom;
        return [top, left, width, height];
    }
    getBoxSizes(ctx, options, updateCursorPosition) {
        var _a, _b;
        const [top, left] = [(_a = options.top) !== null && _a !== void 0 ? _a : 0, (_b = options.left) !== null && _b !== void 0 ? _b : 0];
        const width = Math.max(options.width, ctx.title.width);
        const contentBox = [0, 0, width, options.height];
        const paddingBox = this.changeBoxByEdges(contentBox, ctx.padding);
        const borderBox = this.changeBoxByEdges(paddingBox, ctx.border);
        let fullPos;
        if (options.relative === 'center') {
            fullPos = this.getCenterPos(ctx, borderBox);
        }
        else {
            const cursorPosition = !updateCursorPosition && this.storeCursorPosition
                ? this.storeCursorPosition
                : ctx.globalCursorPosition;
            if (options.relative === 'cursor') {
                fullPos = cursorPosition;
            }
            else if (options.relative === 'cursor-around') {
                fullPos = this.getPosForAround(ctx, [borderBox[2], borderBox[3]], cursorPosition);
            }
            else {
                fullPos = [top, left];
            }
            this.storeCursorPosition = cursorPosition;
        }
        [borderBox[0], borderBox[1]] = [fullPos[0], fullPos[1]];
        [paddingBox[0], paddingBox[1]] = [
            borderBox[0] + ctx.border[0],
            borderBox[1] + ctx.border[3],
        ];
        [contentBox[0], contentBox[1]] = [
            paddingBox[0] + ctx.padding[0],
            paddingBox[1] + ctx.padding[3],
        ];
        return {
            contentBox,
            paddingBox,
            borderBox,
        };
    }
    vimWinConfig(ctx, options, updateCursorPosition) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const [top, left, width, height] = [
            (_a = options.top) !== null && _a !== void 0 ? _a : 0,
            (_b = options.left) !== null && _b !== void 0 ? _b : 0,
            options.width,
            options.height,
        ];
        const config = {
            line: 0,
            col: 0,
            zindex: ((_c = options.borderOnly) !== null && _c !== void 0 ? _c : false) ? 1 : 100,
            minwidth: width,
            minheight: height,
            maxwidth: width,
            maxheight: height,
        };
        if (options.relative === 'center') {
            config.pos = 'center';
        }
        else {
            const cursorPosition = !updateCursorPosition && this.storeCursorPosition
                ? this.storeCursorPosition
                : ctx.globalCursorPosition;
            if (options.relative === 'cursor') {
                [config.line, config.col] = cursorPosition;
            }
            else if (options.relative === 'cursor-around') {
                const box = this.changeBoxByEdgesList([top, left, width, height], [ctx.padding, ctx.border]);
                [config.line, config.col] = this.getPosForAround(ctx, [box[2], box[3]], cursorPosition);
            }
            else {
                [config.line, config.col] = [top, left];
            }
            this.storeCursorPosition = cursorPosition;
            config.line += 1;
            config.col += 1;
        }
        const topOffset = (_d = options.topOffset) !== null && _d !== void 0 ? _d : 0;
        const leftOffset = (_e = options.leftOffset) !== null && _e !== void 0 ? _e : 0;
        config.line += topOffset;
        config.col += leftOffset;
        if (options.maxWidth) {
            config.maxwidth = options.maxWidth;
        }
        if (options.maxHeight) {
            config.maxheight = options.maxHeight;
        }
        config.highlight = (_f = options.winHl) !== null && _f !== void 0 ? _f : defaultWinHl;
        if (options.padding) {
            config.padding = options.padding;
        }
        if (ctx.borderEnabled) {
            config.border = ctx.border;
            if (config.border[0]) {
                if (ctx.title.width) {
                    config.title = ctx.title.text;
                }
                config.close = 'button';
            }
            config.borderchars = (_g = options.borderChars) !== null && _g !== void 0 ? _g : defaultBorderChars;
            config.borderhighlight = [(_h = options.borderWinHl) !== null && _h !== void 0 ? _h : defaultBorderWinHl];
        }
        return config;
    }
    nvimWinConfig(ctx, options, updateCursorPosition) {
        var _a, _b, _c;
        const { contentBox, borderBox } = this.getBoxSizes(ctx, options, updateCursorPosition);
        const topOffset = (_a = options.topOffset) !== null && _a !== void 0 ? _a : 0;
        const leftOffset = (_b = options.leftOffset) !== null && _b !== void 0 ? _b : 0;
        const winConfig = {
            relative: 'editor',
            row: contentBox[0] + topOffset,
            col: contentBox[1] + leftOffset,
            width: contentBox[2],
            height: contentBox[3],
            focusable: (_c = options.focusable) !== null && _c !== void 0 ? _c : true,
        };
        let winConfigBorder;
        if (borderBox) {
            winConfigBorder = {
                relative: 'editor',
                row: borderBox[0] + topOffset,
                col: borderBox[1] + leftOffset,
                width: borderBox[2],
                height: borderBox[3],
                focusable: false,
            };
        }
        return [winConfig, winConfigBorder];
    }
    winConfig(ctx, options, updateCursorPosition = true) {
        return workspace.isVim
            ? [this.vimWinConfig(ctx, options, updateCursorPosition), undefined]
            : this.nvimWinConfig(ctx, options, updateCursorPosition);
    }
    getRenderBorderData(ctx, options, winOptions) {
        var _a, _b, _c, _d, _e, _f;
        const title = (_b = (_a = ctx.title) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '';
        const titleWidth = (_d = (_c = ctx.title) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 0;
        if (!ctx.borderEnabled) {
            return;
        }
        const [bTop, bRight, bBottom, bLeft] = ctx.border;
        let [cTop, cRight, cBottom, cLeft, cTopleft, cTopright, cBotright, cBotleft,] = (_e = options.borderChars) !== null && _e !== void 0 ? _e : defaultBorderChars;
        if (!bTop) {
            cTop = '';
        }
        if (!bRight) {
            cRight = '';
        }
        if (!bBottom) {
            cBottom = '';
        }
        if (!bLeft) {
            cLeft = '';
        }
        if (!bTop || !bLeft) {
            cTopleft = '';
        }
        if (!bTop || !bRight) {
            cTopright = '';
        }
        if (!bBottom || !bLeft) {
            cBotleft = '';
        }
        if (!bBottom || !bRight) {
            cBotright = '';
        }
        const width = winOptions[0];
        const height = winOptions[1];
        const spaceWidth = width - bLeft - bRight;
        const spaceHeight = height - bTop - bBottom;
        const lines = [];
        if (bTop) {
            lines.push(cTopleft + title + cTop.repeat(spaceWidth - titleWidth) + cTopright);
        }
        lines.push(...Array.from({ length: spaceHeight }, () => cLeft + ' '.repeat(spaceWidth) + cRight));
        if (bBottom) {
            lines.push(cBotleft + cBottom.repeat(spaceWidth) + cBotright);
        }
        const highlights = [];
        const borderWinHl = (_f = options.borderWinHl) !== null && _f !== void 0 ? _f : defaultBorderWinHl;
        if (borderWinHl) {
            highlights.push({
                hlGroup: borderWinHl,
                line: 0,
                colStart: 0,
                colEnd: width,
            });
            for (let l = 0, len = spaceHeight; l < len; l++) {
                if (bLeft) {
                    highlights.push({
                        hlGroup: borderWinHl,
                        line: l + 1,
                        colStart: 0,
                        colEnd: bLeft,
                    });
                }
                if (bRight) {
                    highlights.push({
                        hlGroup: borderWinHl,
                        line: l + 1,
                        colStart: bLeft + spaceWidth,
                        colEnd: width,
                    });
                }
            }
            if (bBottom) {
                highlights.push({
                    hlGroup: borderWinHl,
                    line: height - 1,
                    colStart: 0,
                    colEnd: width,
                });
            }
        }
        return {
            lines,
            highlights,
        };
    }
    renderBorderNotifier(buf, ctx, options, winOptions) {
        const renderData = this.getRenderBorderData(ctx, options, 'width' in winOptions
            ? [winOptions.width, winOptions.height]
            : [winOptions.minwidth, winOptions.minheight]);
        if (!renderData) {
            return Notifier.noop();
        }
        const { lines, highlights } = renderData;
        return Notifier.create(() => {
            buf.setOption('modifiable', true, true);
            buf.setOption('readonly', false, true);
            void buf.setLines(lines, { start: 0, end: -1 }, true);
            buf.setOption('modifiable', false, true);
            buf.setOption('readonly', true, true);
            this.addHighlightsNotify(buf, highlights);
        });
    }
    nvimWinHl(options) {
        var _a, _b;
        if (workspace.isVim) {
            return '';
        }
        const arr = [];
        arr.push(`Normal:${(_a = options.winHl) !== null && _a !== void 0 ? _a : defaultWinHl}`);
        arr.push(`NormalNC:${(_b = options.winHlNC) !== null && _b !== void 0 ? _b : defaultWinHlNC}`);
        return arr.join(',');
    }
    addHighlightsNotify(buf, highlights) {
        for (const hl of highlights) {
            if (!hl.hlGroup ||
                hl.line === undefined ||
                hl.colStart === undefined ||
                hl.colEnd === undefined) {
                continue;
            }
            buf.highlightRanges(this.srcId, hl.hlGroup, [
                Range.create(hl.line, hl.colStart, hl.line, hl.colEnd),
            ]);
        }
    }
}
