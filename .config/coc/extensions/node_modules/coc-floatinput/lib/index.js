"use strict";var ai=Object.create;var xe=Object.defineProperty;var ci=Object.getOwnPropertyDescriptor;var li=Object.getOwnPropertyNames;var ui=Object.getPrototypeOf,di=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),fi=(r,e)=>{for(var t in e)xe(r,t,{get:e[t],enumerable:!0})},Ct=(r,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of li(e))!di.call(r,n)&&n!==t&&xe(r,n,{get:()=>e[n],enumerable:!(i=ci(e,n))||i.enumerable});return r};var K=(r,e,t)=>(t=r!=null?ai(ui(r)):{},Ct(e||!r||!r.__esModule?xe(t,"default",{value:r,enumerable:!0}):t,r)),pi=r=>Ct(xe({},"__esModule",{value:!0}),r);var et=v(re=>{"use strict";Object.defineProperty(re,"__esModule",{value:!0});re.sum=re.compactI=void 0;var mi=r=>r.filter(e=>e!=null);re.compactI=mi;var hi=r=>r.reduce((e,t)=>e+t);re.sum=hi});var Pe=v(O=>{"use strict";Object.defineProperty(O,"__esModule",{value:!0});O.isTest=O.isLinux=O.isMacintosh=O.isWindows=O.isWebpack=void 0;O.isWebpack=typeof __webpack_require__=="function";O.isWindows=process.platform==="win32";O.isMacintosh=process.platform==="darwin";O.isLinux=process.platform==="linux";O.isTest=process.env.NODE_ENV==="test"});var tt=v(M=>{"use strict";Object.defineProperty(M,"__esModule",{value:!0});M.displayHeight=M.displayWidth=M.byteLength=M.byteIndex=M.generateUri=void 0;var gi=require("coc.nvim"),bi=et(),wi=Pe();function vi(r,e="file"){return e==="file"&&wi.isWindows&&/^[A-Za-z]:/.test(r)&&(r=`/${r}`),`${e}://${r}`}M.generateUri=vi;function _i(r,e){let t=r.slice(0,e);return Buffer.byteLength(t)}M.byteIndex=_i;function yi(r){return Buffer.byteLength(r)}M.byteLength=yi;async function xt(r){return await gi.workspace.nvim.call("strdisplaywidth",[r])}M.displayWidth=xt;async function Ci(r,e,t,i="n"){let n=await Promise.all(e.map(async(o,s)=>{let a=await xt(o);return i==="i"&&t&&t[0]-1===s&&t[1]+1>=a&&(a+=1),Math.ceil(a/r)}));return(0,bi.sum)(n)}M.displayHeight=Ci});var $t=v($e=>{"use strict";Object.defineProperty($e,"__esModule",{value:!0});$e.getConfigLocal=void 0;var Pt=require("coc.nvim"),xi=tt(),Pi=r=>(e=(0,xi.generateUri)(Pt.workspace.cwd))=>Pt.workspace.getConfiguration(r,e);$e.getConfigLocal=Pi});var Mt=v(I=>{"use strict";var $i=I&&I.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(I,"__esModule",{value:!0});I.prettyPrint=I.prettyObject=I.helperLogger=I.HelperLogger=void 0;var Ie=require("coc.nvim"),Ii=$i(require("util")),It=Pe(),Oe=["trace","debug","info","warn","error","fatal","off"],Oi=Oe.indexOf("error");function Ot(r){return`${r.toLocaleString()} ${r.getMilliseconds().toString().padStart(3,"0")}`}var Me=class{constructor(e){this.channelName=e,this.timeMarkers=new Map,this.levelStatus="trace",this.levelNumber=Oe.indexOf(this.levelStatus),this.appendLine=t=>{this.outputChannel.appendLine(t)},this.log=(t,i)=>{var n,o;let s=Oe[t];if(s<this.levelNumber)return;let a=`[${Ot(new Date)}] [${t}]: `;if(i instanceof Error){this.appendLine(`${a}${(n=i.stack)!==null&&n!==void 0?n:i.toString()}`),Ie.window.showErrorMessage(i.message),It.isTest&&console.error((o=i.stack)!==null&&o!==void 0?o:i.toString());return}this.appendLine(`${a}${i}`),s>Oi&&(Ie.window.showErrorMessage(i),It.isTest&&console.error(i))},this.trace=t=>{this.log("trace",t)},this.debug=t=>{this.log("debug",t)},this.info=t=>{this.log("info",t)},this.warn=t=>{this.log("warn",t)},this.error=t=>{t instanceof Error||(t=new Error(t)),this.log("error",t)},this.fatal=t=>{this.log("fatal",t)}}set level(e){this.levelStatus=e,this.levelNumber=Oe[e]}get level(){return this.levelStatus}dispose(){var e;(e=this.outputChannel_)===null||e===void 0||e.dispose()}get outputChannel(){return this.outputChannel_||(this.outputChannel_=Ie.window.createOutputChannel(this.channelName)),this.outputChannel_}time(e="default"){this.timeMarkers.set(e,new Date().valueOf())}timeElapsed(e="default"){let t=this.timeMarkers.get(e);if(t!==void 0)return new Date().valueOf()-t}timeLog(e="default"){let t=this.timeElapsed(e);t!==void 0&&this.appendLine(`${e}: ${t} ms`)}measureTime(e){let t=new Date().valueOf(),i=e();return i instanceof Promise?i.then(n=>[n,new Date().valueOf()-t]):[i,new Date().valueOf()-t]}measureTask(e,t="default",i="info"){let n=this.measureTime(e);if(!("then"in n)){let[o,s]=n;return this.log(i,`[measureTask] ${t}: ${s} ms`),o}return n.then(([o,s])=>(this.log(i,`${t}: ${s} ms`),o))}asyncCatch(e){return async(...t)=>{try{return await e(...t)}catch(i){this.error(i)}}}prettyPrint(...e){this.info(it(...e)),Ie.window.showErrorMessage(`[${Ot(new Date)}] ${it(...e)}`)}};I.HelperLogger=Me;I.helperLogger=new Me("coc-helper");function it(...r){return r.map(e=>Ii.default.inspect(e)).join(" ")}I.prettyObject=it;function Mi(...r){I.helperLogger.prettyPrint(...r)}I.prettyPrint=Mi});var Wt=v((_n,Wi)=>{Wi.exports={name:"coc-helper",version:"0.16.0",description:"Helpers for coc.nvim",module:"lib/esm/index.js",main:"lib/cjs/index.js",homepage:"https://github.com/weirongxu/coc-helper",repository:"git@github.com:weirongxu/coc-helper.git",author:"Weirong Xu <weirongxu.raidou@gmail.com>",license:"MIT",files:["lib"],scripts:{clean:"shx rm -rf lib","copy:pkg":"shx cp package.json src/_package.json","build:esm":"tsc -p ./tsconfig.prod.json --module es2020 --outDir lib/esm","build:cjs":"tsc -p ./tsconfig.prod.json --module commonjs --outDir lib/cjs",build:"run-s clean copy:pkg build:esm build:cjs",lint:"eslint src --ext ts",prepare:"run-s clean build",unittest:"jest",test:"run-s copy:pkg lint unittest"},engines:{coc:"^0.0.77"},activationEvents:["*"],prettier:{singleQuote:!0,printWidth:80,semi:!0,trailingComma:"all"},peerDependencies:{"coc.nvim":"*"},devDependencies:{"@chemzqm/neovim":"^6.1.1","@raidou/eslint-config-base":"^1.6.0","@types/eslint":"^8.4.10","@types/jest":"^29.2.5","@types/node":"^18.11.18","@types/rimraf":"^3.0.2","@types/uuid":"^9.0.0","coc.nvim":"0.0.83-next.9",eslint:"^8.31.0",jest:"^29.3.1",log4js:"^6.7.1","npm-run-all":"^4.1.5",prettier:"^2.8.2",shx:"^0.3.4","ts-jest":"^29.0.4",typescript:"^4.9.4"},dependencies:{rimraf:"^3.0.2",uuid:"^9.0.0"}}});var Lt=v(A=>{"use strict";var Li=A&&A.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(A,"__esModule",{value:!0});A.versionName=A.version=void 0;var Ei=Li(Wt());A.version=Ei.default.version;A.versionName=A.version.replace(/[.-]/g,"_")});var Et=v(We=>{"use strict";Object.defineProperty(We,"__esModule",{value:!0});We.registerRuntimepath=void 0;var Ni=require("coc.nvim");async function Bi(r){let{nvim:e}=Ni.workspace,t=r.extensionPath;(await e.runtimePaths).includes(t)||await e.command(`execute 'noa set rtp+='.fnameescape('${t.replace(/'/g,"''")}')`)}We.registerRuntimepath=Bi});var ee=v(x=>{"use strict";var ki=x&&x.__createBinding||(Object.create?function(r,e,t,i){i===void 0&&(i=t);var n=Object.getOwnPropertyDescriptor(e,t);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[t]}}),Object.defineProperty(r,i,n)}:function(r,e,t,i){i===void 0&&(i=t),r[i]=e[t]}),Y=x&&x.__exportStar||function(r,e){for(var t in r)t!=="default"&&!Object.prototype.hasOwnProperty.call(e,t)&&ki(e,r,t)};Object.defineProperty(x,"__esModule",{value:!0});x.sleep=void 0;Y(et(),x);Y($t(),x);Y(Pe(),x);Y(Mt(),x);Y(tt(),x);Y(Lt(),x);Y(Et(),x);function Vi(r){return new Promise(e=>{setTimeout(e,r)})}x.sleep=Vi});var pe=v(Le=>{"use strict";Object.defineProperty(Le,"__esModule",{value:!0});Le.Notifier=void 0;var Nt=require("coc.nvim"),Di=ee(),U=class{static async run(e){if(e)if("then"in e){let t=await e;if(t)return t.run()}else return e.run()}static notifyAll(e){for(let t of e)t&&t.notify()}static async runAll(e){let t=await Promise.all(e);return Nt.workspace.nvim.pauseNotification(),this.notifyAll(t),Nt.workspace.nvim.resumeNotification()}static combine(e){let t=(0,Di.compactI)(e);return t.length<1?U.noop():t.length===1?t[0]:t.reduce((i,n)=>i.concat(n),U.noop())}static noop(){return this.create(()=>{})}static create(e){return new U(e)}constructor(e){this.notifyFns=[],this.notifyFns.push(e)}async run(){return U.runAll([this])}notify(){for(let e of this.notifyFns)e()}concat(e){return this.notifyFns.push(...e.notifyFns),this}};Le.Notifier=U});var Bt=v(Ee=>{"use strict";Object.defineProperty(Ee,"__esModule",{value:!0});Ee.getModuleId=void 0;var nt=Symbol("helper_module_max_id");function ji(r){nt in global||(global[nt]={});let e=global[nt];return r in e||(e[r]=0),e[r]+=1,e[r]}Ee.getModuleId=ji});var oe=v(Be=>{"use strict";Object.defineProperty(Be,"__esModule",{value:!0});Be.VimModule=void 0;var Ne=require("coc.nvim"),kt=pe(),F=ee(),Vt=Bt(),rt=(0,Vt.getModuleId)("VimModule"),qi=`coc_helper_module_m${rt}_v${F.versionName}`,k=`g:${qi}`,me=`CocHelperCallFn_m${rt}_v${F.versionName}`,he=`CocHelperCallVar_m${rt}_v${F.versionName}`;function ge(r){return r.replace(/\n\s*\\/g,"")}var V=class{static async init(e){this.inited=!0,await Ne.workspace.nvim.call("execute",`
        if !exists('${k}')
          let ${k} = {}
        endif

        function! ${me}(module_key, method_name, args)
          try
            return call(${k}[a:module_key][a:method_name], a:args)
          catch
            let ex = v:exception
            let msg = printf('error when call %s.%s.%s, args: [%s]', '${k}', a:module_key, a:method_name, join(a:args, ','))
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction

        function! ${he}(module_key, var_name, expression)
          try
            let ${k}[a:module_key][a:var_name] = eval(a:expression)
          catch
            let ex = v:exception
            let msg = printf('error when declare %s.%s.%s, expression: %s', '${k}', a:module_key, a:var_name, a:expression)
            echom msg
            echom ex
            throw msg . ' ' . ex
          endtry
        endfunction
      `);let t=[...this.initQueue];for(;t.length;){let i=t.shift();try{await i.fn(e)}catch(n){F.helperLogger.error(n)}this.initAfterQueue.length&&(t.push(...this.initAfterQueue),this.initAfterQueue=[])}}static registerInit(e,t){this.inited?this.initAfterQueue.push({description:e,fn:t}):this.initQueue.push({description:e,fn:t})}static create(e,t){let n=`${(0,Vt.getModuleId)("VimModule.module")}_${e}`,o=new V(n),s;function a(){return s||(s=t(o)),s}return V.registerInit(`module ${n}`,async()=>{await Ne.workspace.nvim.call("execute",`
          if !exists('${k}.${n}')
            let ${k}.${n} = {}
          endif
        `),a()}),new Proxy({},{get(c,l){return Reflect.get(a(),l)},has(c,l){return l in a()},ownKeys(){return Object.keys(a())}})}constructor(e){this.moduleKey=e}registerInit(e,t){return typeof e=="string"?V.registerInit(e,t):this.registerInit("",e)}fn(e,t){let{nvim:i}=Ne.workspace,n=`${k}.${this.moduleKey}.${e}`,o=t({name:n});return this.registerInit(`fn ${n}`,async()=>{F.helperLogger.debug(`declare fn ${n}`),await i.call("execute",[ge(o)])}),{name:n,inlineCall:(s="")=>`${me}('${this.moduleKey}', '${e}', [${s}])`,call:(...s)=>(F.helperLogger.debug(`call ${n}`),i.call(me,[this.moduleKey,e,s])),callNotify:(...s)=>(F.helperLogger.debug(`callNotify ${n}`),i.call(me,[this.moduleKey,e,s],!0)),callNotifier:(...s)=>(F.helperLogger.debug(`callNotifier ${n}`),kt.Notifier.create(()=>{i.call(me,[this.moduleKey,e,s],!0)}))}}var(e,t){let{nvim:i}=Ne.workspace,n=`${k}.${this.moduleKey}.${e}`;return this.registerInit(`var ${n}`,async()=>{F.helperLogger.debug(`declare var ${n}`),await i.call(he,[this.moduleKey,e,ge(t)])}),{name:n,inline:n,get:()=>i.eval(n),set:async o=>{await i.call(he,[this.moduleKey,e,ge(o)])},setNotify:o=>{i.call(he,[this.moduleKey,e,ge(o)],!0)},setNotifier:o=>kt.Notifier.create(()=>{i.call(he,[this.moduleKey,e,ge(o)],!0)})}}};Be.VimModule=V;V.inited=!1;V.initQueue=[];V.initAfterQueue=[]});var ot=v(ke=>{"use strict";Object.defineProperty(ke,"__esModule",{value:!0});ke.bufModule=void 0;var Hi=oe(),Si=require("coc.nvim");ke.bufModule=Hi.VimModule.create("buf",r=>{let e=Si.workspace.isNvim,t=r.fn("create_by_name",({name:i})=>`
      function! ${i}(name) abort
        return bufadd(a:name)
      endfunction
    `);return{createByName:t,create:r.fn("create",({name:i})=>e?`
          function! ${i}(...) abort
            let name = get(a:000, 0, '')
            if name is ''
              return nvim_create_buf(v:false, v:true)
            else
              return ${t.inlineCall("name")}
            endif
          endfunction
        `:`
          function! ${i}(...) abort
            let name = get(a:000, 0, '')
            return ${t.inlineCall("name")}
          endfunction
        `)}})});var st=v(Ve=>{"use strict";Object.defineProperty(Ve,"__esModule",{value:!0});Ve.floatingModule=void 0;var Ai=require("coc.nvim"),Fi=oe(),Dt=ot();Ve.floatingModule=Fi.VimModule.create("float",r=>{let e=Ai.workspace.isNvim,t=r.fn("init_execute",({name:n})=>`
      function! ${n}(ctx, inited_execute) abort
        execute a:inited_execute
      endfunction
    `),i=r.fn("open_win",({name:n})=>e?`
        function! ${n}(bufnr, focus, win_config, win_hl, inited_execute) abort
          noau let winid = nvim_open_win(a:bufnr, a:focus, a:win_config)
          if !empty(a:win_hl)
            call nvim_win_set_option(winid, 'winhl', a:win_hl)
          endif
          if !empty(a:inited_execute)
            call ${t.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}
          endif
          return winid
        endfunction
      `:`
        function! ${n}(bufnr, focus, win_config, win_hl, inited_execute) abort
          let winid = popup_create(a:bufnr, a:win_config)
          call ${t.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}

          return winid
        endfunction
      `);return{create:r.fn("create",({name:n})=>e?`
            function! ${n}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${Dt.bufModule.create.inlineCall("a:name")}
              call ${t.inlineCall("{'bufnr': bufnr}, a:inited_execute")}

              let border_bufnr = v:null
              if a:has_border_buf
                let border_bufnr = nvim_create_buf(v:false, v:true)
                call ${t.inlineCall("{'bufnr': border_bufnr}, a:border_inited_execute")}
              endif
              return [bufnr, border_bufnr]
            endfunction
          `:`
            function! ${n}(name, inited_execute, has_border_buf, border_inited_execute) abort
              let bufnr = ${Dt.bufModule.create.inlineCall("a:name")}
              call ${t.inlineCall("{'bufnr': bufnr}, a:inited_execute")}
              return [bufnr, v:null]
            endfunction
          `),open:r.fn("open",({name:n})=>`
        function! ${n}(bufnr, win_config, inited_execute, border_bufnr, border_win_config, border_inited_execute, focus, win_hl) abort
          let winid = ${i.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, a:inited_execute")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${i.inlineCall("a:border_bufnr, v:false, a:border_win_config, a:win_hl, a:border_inited_execute")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),resume:r.fn("resume",({name:n})=>`
        function! ${n}(bufnr, win_config, border_bufnr, border_win_config, focus, win_hl) abort
          let winid = ${i.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, ''")}
          call setbufvar(a:bufnr, 'coc_helper_winid', winid)

          if a:border_bufnr
            let border_winid = ${i.inlineCall("border_bufnr, v:false, a:border_win_config, a:win_hl, ''")}
            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)
          endif
        endfunction
      `),update:r.fn("update",({name:n})=>e?`
          function! ${n}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call nvim_win_set_config(winid, a:win_config)
            if !empty(a:win_hl)
              call nvim_win_set_option(winid, 'winhl', a:win_hl)
            endif
            if has('nvim')
              redraw!
            endif

            if a:border_bufnr
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              if border_winid
                call nvim_win_set_config(border_winid, a:border_win_config)
                if !empty(a:win_hl)
                  call nvim_win_set_option(border_winid, 'winhl', a:win_hl)
                endif
                if has('nvim')
                  redraw!
                endif
              endif
            endif
          endfunction
        `:`
          function! ${n}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort
            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
            if !winid
              return
            endif
            call popup_setoptions(winid, a:win_config)
          endfunction
        `),winid:r.fn("winid",({name:n})=>`
        function! ${n}(bufnr) abort
          let id = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
          let nr = win_id2win(id)
          return nr is 0 ? v:null : id
        endfunction
      `),borderWinid:r.fn("border_winid",({name:n})=>`
        function! ${n}(bufnr) abort
          return getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
        endfunction
      `),close:r.fn("close",({name:n})=>e?`
            function! ${n}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)
              try
                if winid
                  call nvim_win_close(winid, v:true)
                endif
                if border_winid
                  call nvim_win_close(border_winid, v:true)
                endif
              catch
              endtry
            endfunction
          `:`
            function! ${n}(bufnr) abort
              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)
              try
                if winid
                  call popup_close(winid)
                endif
              catch
              endtry
            endfunction
          `)}})});var je=v(De=>{"use strict";Object.defineProperty(De,"__esModule",{value:!0});De.utilModule=void 0;var Ti=oe(),Ri=require("coc.nvim");De.utilModule=Ti.VimModule.create("util",r=>{let e=Ri.workspace.isNvim;return{globalCursorPosition:r.fn("global_cursor_position",({name:t})=>`
        function! ${t}()
          let nr = winnr()
          let [row, col] = win_screenpos(nr)
          return [row + winline() - 2, col + wincol() - 2]
        endfunction
      `),isFloat:r.fn("is_float",({name:t})=>e?`
          function! ${t}(winnr) abort
            if !exists('*nvim_win_get_config')
              return v:false
            endif
            let winid = win_getid(a:winnr)
            return nvim_win_get_config(winid)['relative'] != ''
          endfunction
        `:`
          function! ${t}(winnr) abort
            return v:false
          endfunction
        `),closeWinByBufnr:r.fn("close_win_by_bufnr",({name:t})=>`
        if exists('*nvim_win_close')
          function! ${t}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winid = bufwinid(bufnr)
                if winid >= 0
                  call nvim_win_close(winid, v:true)
                endif
              catch
              endtry
            endfor
          endfunction
        else
          function! ${t}(bufnrs) abort
            for bufnr in a:bufnrs
              try
                let winnr = bufwinnr(bufnr)
                if winnr >= 0
                  execute winnr . 'wincmd c'
                endif
              catch
              endtry
            endfor
          endfunction
        endif
      `),runCocCmd:r.fn("run_coc_cmd",({name:t})=>`
        function! ${t}(name, ...) abort
          return call('CocAction', extend(['runCommand', a:name], a:000))
        endfunction
      `),runCocCmdAsync:r.fn("run_coc_cmd_async",({name:t})=>`
        function! ${t}(name, ...) abort
          return call('CocActionAsync', extend(['runCommand', a:name], a:000))
        endfunction
      `)}})});var ct=v(qe=>{"use strict";Object.defineProperty(qe,"__esModule",{value:!0});qe.FloatingUtil=void 0;var se=require("coc.nvim"),zi=je(),jt=pe(),Ki=ee(),qt=["\u2500","\u2502","\u2500","\u2502","\u250C","\u2510","\u2518","\u2514"],Ht="CocHelperNormalFloat",Ui="CocHelperNormalFloatNC",St="CocHelperNormalFloatBorder",at=class{constructor(e){this.srcId=e}async createContext(e){var t,i;return(t=e.context)!==null&&t!==void 0?t:{lines:se.workspace.env.lines,columns:se.workspace.env.columns-se.workspace.env.cmdheight-1,globalCursorPosition:await zi.utilModule.globalCursorPosition.call(),title:e.title?{text:e.title,width:await(0,Ki.displayWidth)(e.title)}:{text:"",width:0},borderEnabled:!!e.border,border:this.extendEdges((i=e.border)===null||i===void 0?void 0:i.map(n=>typeof n=="boolean"?1:n)),paddingEnabled:!!e.padding,padding:this.extendEdges(e.padding)}}getCenterPos(e,t){let[,,i,n]=t,o=Math.floor((e.lines-n)/2),s=Math.floor((e.columns-i)/2);return[o,s]}getPosForAround(e,t,i,n=!1){let o=e.columns,s=e.lines-1,[a,c]=t,[l,u]=i;return n?l-c<0?l+=1:l-=c:l+c>=s?l-=c:l+=1,u+a>=o&&(u-=a-1),[l,u]}extendEdges(e){var t,i,n,o;if(!e)return[0,0,0,0];let s=(t=e[0])!==null&&t!==void 0?t:1,a=(i=e[1])!==null&&i!==void 0?i:s,c=(n=e[2])!==null&&n!==void 0?n:s,l=(o=e[3])!==null&&o!==void 0?o:a;return[s,a,c,l]}changeBoxByEdgesList(e,t){let i=[...e];for(let n of t)i=this.changeBoxByEdges(i,n);return i}changeBoxByEdges(e,t){if(!t)return e;let[i,n,o,s]=t,[a,c,l,u]=e;return a-=i,c-=s,l+=s+n,u+=i+o,[a,c,l,u]}getBoxSizes(e,t,i){var n,o;let[s,a]=[(n=t.top)!==null&&n!==void 0?n:0,(o=t.left)!==null&&o!==void 0?o:0],l=[0,0,Math.max(t.width,e.title.width),t.height],u=this.changeBoxByEdges(l,e.padding),d=this.changeBoxByEdges(u,e.border),f;if(t.relative==="center")f=this.getCenterPos(e,d);else{let m=!i&&this.storeCursorPosition?this.storeCursorPosition:e.globalCursorPosition;t.relative==="cursor"?f=m:t.relative==="cursor-around"?f=this.getPosForAround(e,[d[2],d[3]],m):f=[s,a],this.storeCursorPosition=m}return[d[0],d[1]]=[f[0],f[1]],[u[0],u[1]]=[d[0]+e.border[0],d[1]+e.border[3]],[l[0],l[1]]=[u[0]+e.padding[0],u[1]+e.padding[3]],{contentBox:l,paddingBox:u,borderBox:d}}vimWinConfig(e,t,i){var n,o,s,a,c,l,u,d;let[f,m,h,b]=[(n=t.top)!==null&&n!==void 0?n:0,(o=t.left)!==null&&o!==void 0?o:0,t.width,t.height],p={line:0,col:0,zindex:(s=t.borderOnly)!==null&&s!==void 0&&s?1:100,minwidth:h,minheight:b,maxwidth:h,maxheight:b};if(t.relative==="center")p.pos="center";else{let B=!i&&this.storeCursorPosition?this.storeCursorPosition:e.globalCursorPosition;if(t.relative==="cursor")[p.line,p.col]=B;else if(t.relative==="cursor-around"){let Z=this.changeBoxByEdgesList([f,m,h,b],[e.padding,e.border]);[p.line,p.col]=this.getPosForAround(e,[Z[2],Z[3]],B)}else[p.line,p.col]=[f,m];this.storeCursorPosition=B,p.line+=1,p.col+=1}let W=(a=t.topOffset)!==null&&a!==void 0?a:0,N=(c=t.leftOffset)!==null&&c!==void 0?c:0;return p.line+=W,p.col+=N,t.maxWidth&&(p.maxwidth=t.maxWidth),t.maxHeight&&(p.maxheight=t.maxHeight),p.highlight=(l=t.winHl)!==null&&l!==void 0?l:Ht,t.padding&&(p.padding=t.padding),e.borderEnabled&&(p.border=e.border,p.border[0]&&(e.title.width&&(p.title=e.title.text),p.close="button"),p.borderchars=(u=t.borderChars)!==null&&u!==void 0?u:qt,p.borderhighlight=[(d=t.borderWinHl)!==null&&d!==void 0?d:St]),p}nvimWinConfig(e,t,i){var n,o,s;let{contentBox:a,borderBox:c}=this.getBoxSizes(e,t,i),l=(n=t.topOffset)!==null&&n!==void 0?n:0,u=(o=t.leftOffset)!==null&&o!==void 0?o:0,d={relative:"editor",row:a[0]+l,col:a[1]+u,width:a[2],height:a[3],focusable:(s=t.focusable)!==null&&s!==void 0?s:!0},f;return c&&(f={relative:"editor",row:c[0]+l,col:c[1]+u,width:c[2],height:c[3],focusable:!1}),[d,f]}winConfig(e,t,i=!0){return se.workspace.isVim?[this.vimWinConfig(e,t,i),void 0]:this.nvimWinConfig(e,t,i)}getRenderBorderData(e,t,i){var n,o,s,a,c,l;let u=(o=(n=e.title)===null||n===void 0?void 0:n.text)!==null&&o!==void 0?o:"",d=(a=(s=e.title)===null||s===void 0?void 0:s.width)!==null&&a!==void 0?a:0;if(!e.borderEnabled)return;let[f,m,h,b]=e.border,[p,W,N,B,Z,bt,wt,vt]=(c=t.borderChars)!==null&&c!==void 0?c:qt;f||(p=""),m||(W=""),h||(N=""),b||(B=""),(!f||!b)&&(Z=""),(!f||!m)&&(bt=""),(!h||!b)&&(vt=""),(!h||!m)&&(wt="");let ve=i[0],_t=i[1],_e=ve-b-m,yt=_t-f-h,ye=[];f&&ye.push(Z+u+p.repeat(_e-d)+bt),ye.push(...Array.from({length:yt},()=>B+" ".repeat(_e)+W)),h&&ye.push(vt+N.repeat(_e)+wt);let de=[],fe=(l=t.borderWinHl)!==null&&l!==void 0?l:St;if(fe){de.push({hlGroup:fe,line:0,colStart:0,colEnd:ve});for(let Ce=0,si=yt;Ce<si;Ce++)b&&de.push({hlGroup:fe,line:Ce+1,colStart:0,colEnd:b}),m&&de.push({hlGroup:fe,line:Ce+1,colStart:b+_e,colEnd:ve});h&&de.push({hlGroup:fe,line:_t-1,colStart:0,colEnd:ve})}return{lines:ye,highlights:de}}renderBorderNotifier(e,t,i,n){let o=this.getRenderBorderData(t,i,"width"in n?[n.width,n.height]:[n.minwidth,n.minheight]);if(!o)return jt.Notifier.noop();let{lines:s,highlights:a}=o;return jt.Notifier.create(()=>{e.setOption("modifiable",!0,!0),e.setOption("readonly",!1,!0),e.setLines(s,{start:0,end:-1},!0),e.setOption("modifiable",!1,!0),e.setOption("readonly",!0,!0),this.addHighlightsNotify(e,a)})}nvimWinHl(e){var t,i;if(se.workspace.isVim)return"";let n=[];return n.push(`Normal:${(t=e.winHl)!==null&&t!==void 0?t:Ht}`),n.push(`NormalNC:${(i=e.winHlNC)!==null&&i!==void 0?i:Ui}`),n.join(",")}addHighlightsNotify(e,t){for(let i of t)!i.hlGroup||i.line===void 0||i.colStart===void 0||i.colEnd===void 0||e.highlightRanges(this.srcId,i.hlGroup,[se.Range.create(i.line,i.colStart,i.line,i.colEnd)])}};qe.FloatingUtil=at});var Se=v(He=>{"use strict";Object.defineProperty(He,"__esModule",{value:!0});He.FloatingWindow=void 0;var D=require("coc.nvim"),te=pe(),T=st(),Qi=je(),Gi=ee(),Ji=ct(),w=class{static getInitedExecute(e,t){var i,n,o,s;let a=(n=(i=t.initedExecute)===null||i===void 0?void 0:i.call(t,w.initedContextVars.create))!==null&&n!==void 0?n:"";a=`${w.modePresets[e].createInitedExecute(w.initedContextVars.create)}
${a}`;let c=(s=(o=t.borderInitedExecute)===null||o===void 0?void 0:o.call(t,w.initedContextVars.create))!==null&&s!==void 0?s:w.modePresets.show.createInitedExecute(w.initedContextVars.create);return[a,c]}static async create(e={}){var t,i,n;let o=(t=e.mode)!==null&&t!==void 0?t:"default",[s,a]=this.getInitedExecute(o,e),[c,l]=await T.floatingModule.create.call((i=e.name)!==null&&i!==void 0?i:"",s,(n=e.hasBorderBuf)!==null&&n!==void 0?n:!0,a),u=new Ji.FloatingUtil(this.srcId);return new w(c,l!=null?l:void 0,e,o,u)}constructor(e,t,i,n,o){this.bufnr=e,this.borderBufnr=t,this.createOptions=i,this.mode=n,this.util=o,this.nvim=D.workspace.nvim,this.disposables=[],this.nvim=D.workspace.nvim,this.buffer=this.nvim.createBuffer(e),t&&(this.borderBuffer=D.workspace.nvim.createBuffer(t),this.disposables.push(D.events.on("BufWinLeave",Gi.helperLogger.asyncCatch(async s=>{this.borderBufnr&&s===this.bufnr&&await Qi.utilModule.closeWinByBufnr.call([this.borderBufnr])}))))}getInitedExecute(e){var t,i,n,o;let s=(i=(t=e.initedExecute)===null||t===void 0?void 0:t.call(e,w.initedContextVars.open))!==null&&i!==void 0?i:"";s=`${w.modePresets[this.mode].openInitedExecute(w.initedContextVars.open)}
${s}`;let a=(o=(n=e.borderInitedExecute)===null||n===void 0?void 0:n.call(e,w.initedContextVars.open))!==null&&o!==void 0?o:w.modePresets.show.openInitedExecute(w.initedContextVars.open);return[s,a]}getFocus(e){var t,i;return(i=(t=e.focus)!==null&&t!==void 0?t:this.mode?w.modePresets[this.mode].focus:void 0)!==null&&i!==void 0?i:!1}getModifiable(e){var t,i;return(i=(t=e.modifiable)!==null&&t!==void 0?t:this.mode?w.modePresets[this.mode].modifiable:void 0)!==null&&i!==void 0?i:!1}setLinesNotifier(e){return te.Notifier.create(()=>{if(!e.lines&&!e.modifiable)return;let t=this.getModifiable(e);if(this.buffer.setOption("modifiable",!0,!0),this.buffer.setOption("readonly",!1,!0),e.lines&&this.buffer.setLines(e.lines,{start:0,end:-1},!0),t||(this.buffer.setOption("modifiable",!1,!0),this.buffer.setOption("readonly",!0,!0)),e.highlights)for(let i of e.highlights)this.util.addHighlightsNotify(this.buffer,[i]);D.workspace.isVim&&this.nvim.command("redraw!",!0)})}async setLines(e){await this.setLinesNotifier(e).run()}async opened(){return!!await this.win()}async openNotifier(e){var t;if(e.width<=0||e.height<=0)return te.Notifier.noop();let i=[];i.push(this.closeNotifier());let n=await this.util.createContext(e),[o,s]=this.getInitedExecute(e),[a,c]=this.util.winConfig(n,e);return e.borderOnly&&c?(i.push(T.floatingModule.open.callNotifier(this.bufnr,c,s,null,null,"",!1,this.util.nvimWinHl(e))),i.push(this.util.renderBorderNotifier(this.buffer,n,e,c))):i.push(T.floatingModule.open.callNotifier(this.bufnr,a,o,(t=this.borderBufnr)!==null&&t!==void 0?t:null,c!=null?c:null,s,this.getFocus(e),this.util.nvimWinHl(e))),D.workspace.isNvim&&this.borderBuffer&&c&&i.push(this.util.renderBorderNotifier(this.borderBuffer,n,e,c)),i.push(this.setLinesNotifier(e),te.Notifier.create(()=>{e.filetype&&this.buffer.setOption("filetype",e.filetype,!0)})),te.Notifier.combine(i)}async open(e){await(await this.openNotifier(e)).run()}async resumeNotifier(e){let t=await this.util.createContext(e),[i,n]=this.util.winConfig(t,e);return te.Notifier.create(()=>{var o;T.floatingModule.resume.callNotify(this.bufnr,i,(o=this.borderBufnr)!==null&&o!==void 0?o:null,n!=null?n:null,this.getFocus(e),this.util.nvimWinHl(e)),this.borderBuffer&&n&&this.util.renderBorderNotifier(this.borderBuffer,t,e,n).notify(),D.workspace.isVim&&this.nvim.command("redraw!",!0)})}async resume(e){await(await this.resumeNotifier(e)).run()}async resizeNotifier(e){var t;let i=await this.util.createContext(e),[n,o]=this.util.winConfig(i,e,!1),s=[];return e.borderOnly&&o?(s.push(T.floatingModule.update.callNotifier(this.bufnr,o,null,null,this.util.nvimWinHl(e))),s.push(this.util.renderBorderNotifier(this.buffer,i,e,o))):s.push(T.floatingModule.update.callNotifier(this.bufnr,n,(t=this.borderBufnr)!==null&&t!==void 0?t:null,o!=null?o:null,this.util.nvimWinHl(e))),D.workspace.isNvim&&this.borderBuffer&&o&&s.push(this.util.renderBorderNotifier(this.borderBuffer,i,e,o)),s.push(te.Notifier.create(()=>{D.workspace.isVim&&this.nvim.command("redraw!",!0)})),te.Notifier.combine(s)}async resize(e){await(await this.resizeNotifier(e)).run()}async win(){let e=await T.floatingModule.winid.call(this.bufnr);return e?this.nvim.createWindow(e):void 0}async borderWin(){let e=await T.floatingModule.winid.call(this.bufnr);return e?this.nvim.createWindow(e):void 0}closeNotifier(){return T.floatingModule.close.callNotifier(this.bufnr)}async close(){await this.closeNotifier().run()}dispose(){(0,D.disposeAll)(this.disposables),this.disposables.forEach(e=>e.dispose())}};He.FloatingWindow=w;w.modePresets={default:{modifiable:!1,focus:!1,createInitedExecute:()=>"",openInitedExecute:()=>""},base:{createInitedExecute:r=>`
        call setbufvar(${r.bufnr}, '&buftype', 'nofile')
        call setbufvar(${r.bufnr}, '&bufhidden', 'hide')
        call setbufvar(${r.bufnr}, '&buflisted', 0)

        call setbufvar(${r.bufnr}, '&wrap', 1)

        call setbufvar(${r.bufnr}, '&swapfile', 0)

        call setbufvar(${r.bufnr}, '&modeline', 0)
      `,openInitedExecute:r=>`
        call setbufvar(${r.bufnr}, '&list', 0)

        call setbufvar(${r.bufnr}, '&listchars', '')
        if has('nvim')
          call setbufvar(${r.bufnr}, '&fillchars', 'eob: ')
        endif

        call setbufvar(${r.bufnr}, '&signcolumn', 'no')
        call setbufvar(${r.bufnr}, '&number', 0)
        call setbufvar(${r.bufnr}, '&relativenumber', 0)
        call setbufvar(${r.bufnr}, '&foldenable', 0)
        call setbufvar(${r.bufnr}, '&foldcolumn', 0)

        call setbufvar(${r.bufnr}, '&spell', 0)

        call setbufvar(${r.bufnr}, '&cursorcolumn', 0)
        call setbufvar(${r.bufnr}, '&cursorline', 0)
        call setbufvar(${r.bufnr}, '&colorcolumn', '')
      `},show:{modifiable:!1,createInitedExecute:r=>`
        ${w.modePresets.base.createInitedExecute(r)}
        " call setbufvar(${r.bufnr}, '&undofile', 0)
        " call setbufvar(${r.bufnr}, '&undolevels', -1)

        call setbufvar(${r.bufnr}, '&modifiable', 0)
        call setbufvar(${r.bufnr}, '&modified', 0)
        call setbufvar(${r.bufnr}, '&readonly', 1)
      `,openInitedExecute:r=>`
        ${w.modePresets.base.openInitedExecute(r)}
      `}};w.initedContextVars={create:{bufnr:"a:ctx.bufnr"},open:{bufnr:"a:ctx.bufnr",winid:"a:ctx.winid"}};w.srcId="coc-helper-floatwin"});var ut=v(Ae=>{"use strict";Object.defineProperty(Ae,"__esModule",{value:!0});Ae.MultiFloatingWindow=void 0;var be=require("coc.nvim"),At=j(),Xi=ct(),lt=Se(),we=class{static async create(e){let t=await lt.FloatingWindow.create(Object.assign({hasBorderBuf:!1,mode:"show"},e)),n=(await Promise.all(Object.entries(e.wins).map(async([s,a])=>[s,await lt.FloatingWindow.create(Object.assign({hasBorderBuf:!1},a))]))).reduce((s,[a,c])=>(s[a]=c,s),{}),o=new Xi.FloatingUtil(lt.FloatingWindow.srcId);return new we(t,n,o)}constructor(e,t,i){this.borderFloatWin=e,this.floatWinDict=t,this.util=i,this.disposables=[],this.floatWins=Object.values(this.floatWinDict),this.nvim=be.workspace.nvim,this.bufnrs=[e.bufnr,...this.floatWins.map(n=>n.bufnr)],this.disposables.push(be.events.on("BufWinLeave",async n=>{this.bufnrs.includes(n)&&await this.close()}),be.Disposable.create(()=>{e.dispose(),(0,be.disposeAll)(this.floatWins)}))}async opened(){return this.borderFloatWin.opened()}async sizeByWinsOptions(e){var t,i;let n=0,o=0;for(let s of e){let a=await this.util.createContext(s),c=this.util.getBoxSizes(a,s,!1),l=((t=s.left)!==null&&t!==void 0?t:0)+c.borderBox[2];l>n&&(n=l);let u=((i=s.top)!==null&&i!==void 0?i:0)+c.borderBox[3];u>o&&(o=u)}return[n,o]}async batchAction(e,t,{reverse:i=!1,updateCursorPosition:n=!0}={}){var o,s;let[a,c]=await this.sizeByWinsOptions(Object.values(t.wins)),l=Object.assign({width:a,height:c},t),u=await this.util.createContext(l),{contentBox:d}=this.util.getBoxSizes(u,l,n),f=[];for(let[m,h]of Object.entries(this.floatWinDict)){let b=t.wins[m];b&&f.push(await h[e](Object.assign(Object.assign({},b),{relative:"editor",top:d[0]+((o=b.top)!==null&&o!==void 0?o:0),left:d[1]+((s=b.left)!==null&&s!==void 0?s:0)})))}f.push(await this.borderFloatWin[e](Object.assign(Object.assign({},l),{borderOnly:!0}))),i&&f.reverse(),await At.Notifier.runAll(f)}async open(e){return this.batchAction("openNotifier",e)}async resume(e){return this.batchAction("resumeNotifier",e)}resize(e){return this.batchAction("resizeNotifier",e,{updateCursorPosition:!1})}async win(){return{borderWin:await this.borderFloatWin.win(),wins:await this.wins()}}async wins(){return await Promise.all(this.floatWins.map(e=>e.win()))}async close(){let e=[];e.push(this.borderFloatWin.closeNotifier()),e.push(...this.floatWins.map(t=>t.closeNotifier())),await At.Notifier.runAll(e)}dispose(){(0,be.disposeAll)(this.disposables)}};Ae.MultiFloatingWindow=we});var Tt=v(Fe=>{"use strict";Object.defineProperty(Fe,"__esModule",{value:!0});Fe.HelperEventEmitter=void 0;var Ft=require("coc.nvim"),dt=class{constructor(e,t=!1){this.helperLogger=e,this.concurrent=t,this.listenersMap=new Map}listeners(e){if(!this.listenersMap.has(e)){let t=[];return this.listenersMap.set(e,t),t}return this.listenersMap.get(e)}once(e,t,i){this.listeners(e).push(async(...o)=>{let s=await t(...o);return n.dispose(),s});let n=Ft.Disposable.create(()=>this.off(e,t));return i&&i.push(n),n}on(e,t,i){this.listeners(e).push(t);let n=Ft.Disposable.create(()=>this.off(e,t));return i&&i.push(n),n}off(e,t){typeof t.cancel=="function"&&t.cancel();let i=this.listeners(e),n=i.indexOf(t);n!==-1&&i.splice(n,1)}async fire(e,...t){if(this.concurrent)await Promise.all(this.listeners(e).map(async i=>{try{await i(...t)}catch(n){this.helperLogger.error(n)}}));else for(let i of this.listeners(e))try{await i(...t)}catch(n){this.helperLogger.error(n)}}};Fe.HelperEventEmitter=dt});var Rt=v(Te=>{"use strict";Object.defineProperty(Te,"__esModule",{value:!0});Te.WinLayoutFinder=void 0;var Zi=require("coc.nvim"),ft=class{static convertVimLayoutNode(e,t){if(e[0]==="leaf")return{type:e[0],winid:e[1],parent:t};{let i={type:e[0],children:[]};return i.children=e[1].map((n,o)=>this.convertVimLayoutNode(n,{group:i,indexInParent:o})),i}}static async create(e){let t=e?[e]:[],i=await Zi.workspace.nvim.call("winlayout",t);return new this(this.convertVimLayoutNode(i))}static getFirstLeafWinid(e){return e.type==="leaf"?e.winid:this.getFirstLeafWinid(e.children[0])}constructor(e){this.root=e}findWinid(e,t=this.root){if(t.type==="leaf"){if(t.winid===e)return t}else for(let i of t.children){let n=this.findWinid(e,i);if(n)return n}}findClosest(e,t){let i=new Set([e]),n=[e];for(;n.length;){let o=n.shift();if(o.type==="leaf"){if(t.includes(o.winid))return o}else for(let s of o.children)if(!i.has(s)){n.push(s),i.add(s);continue}o.parent&&!i.has(o.parent.group)&&(n.push(o.parent.group),i.add(o.parent.group))}}};Te.WinLayoutFinder=ft});var j=v(_=>{"use strict";var Yi=_&&_.__createBinding||(Object.create?function(r,e,t,i){i===void 0&&(i=t);var n=Object.getOwnPropertyDescriptor(e,t);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[t]}}),Object.defineProperty(r,i,n)}:function(r,e,t,i){i===void 0&&(i=t),r[i]=e[t]}),H=_&&_.__exportStar||function(r,e){for(var t in r)t!=="default"&&!Object.prototype.hasOwnProperty.call(e,t)&&Yi(e,r,t)};Object.defineProperty(_,"__esModule",{value:!0});_.activate=_.activateHelper=void 0;var Q=require("coc.nvim"),en=Se(),tn=ut(),q=ee(),nn=oe();H(Tt(),_);H(Se(),_);H(ot(),_);H(st(),_);H(je(),_);H(ut(),_);H(pe(),_);H(ee(),_);H(oe(),_);H(Rt(),_);async function zt(r,e={}){var t;(!((t=e.vimModule)!==null&&t!==void 0)||t)&&await nn.VimModule.init(r);try{await Q.workspace.nvim.command("hi default link CocHelperNormalFloatNC CocHelperNormalFloat")}catch(i){Q.window.showErrorMessage(i.toString())}}_.activateHelper=zt;async function rn(r){await zt(r),await q.helperLogger.measureTask(async()=>{await Q.workspace.nvim.command("hi CocHelperNormalFloat ctermbg=Red guibg=#aa0000"),await Q.workspace.nvim.command("hi CocHelperNormalFloatNC ctermbg=Red guibg=#aa0000"),await Q.workspace.nvim.command("hi CocHelperNormalFloatBorder ctermbg=Black ctermfg=Grey guibg=#0000aa guifg=#ffffff")},"highlight commands"),await q.helperLogger.measureTask(async()=>{let e=await en.FloatingWindow.create({mode:"base"});Q.commands.registerCommand("testHelper-floating",q.helperLogger.asyncCatch(async()=>{let t="hello";await e.open({relative:"cursor-around",lines:[t],top:0,left:0,title:"test",width:5,height:5,border:[1,1,1,0],padding:[],modifiable:!0,focus:!0,filetype:"test",highlights:[{line:0,srcId:0,colStart:0,colEnd:t.length,hlGroup:"Question"}]}),await(0,q.sleep)(2e3),await e.resize({relative:"cursor-around",top:0,left:0,title:"test",width:10,height:10,border:[],padding:[],winHl:"Pmenu",winHlNC:"Pmenu",modifiable:!0,focus:!1,filetype:"test"}),await(0,q.sleep)(2e3),await e.resize({relative:"cursor-around",top:0,left:0,title:"test",width:5,height:5,border:[1,1,1,0],padding:[],modifiable:!0,focus:!1,filetype:"test"})}))},"register floatWin"),await q.helperLogger.measureTask(async()=>{let e=await tn.MultiFloatingWindow.create({wins:{prompt:{mode:"show"},input:{mode:"base"}}});Q.commands.registerCommand("testHelper-multi-floating",q.helperLogger.asyncCatch(async()=>{let i="input your path:",n=await(0,q.displayHeight)(10,[i]),o="/home/users/repos",s=await(0,q.displayHeight)(10,[o]);Q.events.on("TextChangedI",async l=>{let u=e.floatWinDict.input;if(u.bufnr!==l)return;let d=await u.win();if(!d)return;let f=await d.cursor,m=await d.width,h=await d.height,b=await u.buffer.getLines(),p=await(0,q.displayHeight)(m,b,f,"i");p!==h&&(s=p,await c())});let a=()=>({relative:"cursor-around",top:0,left:0,title:"test",border:[],padding:[],modifiable:!0,filetype:"test",wins:{prompt:{top:0,left:0,width:10,height:n,highlights:[{line:0,srcId:0,colEnd:i.length,colStart:0,hlGroup:"Question"}],lines:[i]},input:{top:n,left:0,width:10,height:s,lines:[o],focus:!0,modifiable:!0,initedExecute:()=>`
            if has('nvim')
              call feedkeys('A')
            endif
          `}}}),c=async()=>{await e.resize(a())};await e.open(a())}))},"register multiFloatWin")}_.activate=rn});var pn={};fi(pn,{FloatInput:()=>oi,activate:()=>fn});module.exports=pi(pn);var Ye=K(j()),E=require("coc.nvim");var J=K(j()),S=require("coc.nvim");var Re=K(j());function on(r,e){let t=Math.ceil(r/e.length),i=new Array(e.length);for(let n=0;n<e.length;n++)i[n]===void 0&&(t<=r?(r-=t,i[n]=t):i[n]=r);return i}function sn(r,e){let t=(0,Re.sum)(e.map(s=>s.width)),i=r-t,n=on(i,e),o=0;return e.map((s,a)=>{var d;let c=(d=n[a])!=null?d:0,l;if(c){let f=Math.ceil(c/2),m=c-f;l=`${" ".padStart(f)} ${s.text} ${" ".padStart(m)}`}else l=` ${s.text} `;a!==0&&(l=`|${l}`,o+=1);let u=o;return o+=(0,Re.byteLength)(l),{...s,line:0,colStart:u,colEnd:o,width:s.width+c,text:l}})}function Kt(r,e){let t=[],i=0,n=[];for(let o of e)n.length&&(o.width+=1),o.width+=2,i+=o.width,n.length&&i>=r&&(t.push(n),n=[],i=o.width),n.push(o);return t.push(n),t.map((o,s)=>sn(r,o).map(a=>({...a,line:s})))}var Xt=K(j()),pt=require("coc.nvim");var Ut=require("coc.nvim");async function Qt(){return await Ut.workspace.nvim.call("coc_floatinput#escaped_keys#name_to_code")}var ae=K(j()),g=new ae.HelperLogger("floatinput");async function Gt(r){let{changedtick:e}=r;await r.patchChange(),e!==r.changedtick&&await(0,ae.sleep)(50)}var ze=(0,ae.getConfigLocal)("floatinput");async function Zt(r){let e=await Qt();Jt.startPrompt().catch(g.error);let t=g.asyncCatch(r),i=(n,o)=>o.some(s=>s in e?e[s]===n:n===s);return await new Promise(n=>{let o=async a=>{await Jt.stopPrompt(),s.dispose(),n(a)},s=mt.on("InputChar",(a,c)=>{t({char:a,mode:c,codes:e,matchCodeWith:i,matchCode:i.bind(void 0,a),stop:o})})})}var mt=new Xt.HelperEventEmitter(g),Jt={async startPrompt(){await pt.workspace.nvim.call("coc_floatinput#getchar#start_prompt")},async stopPrompt(){await pt.workspace.nvim.call("coc_floatinput#getchar#stop_prompt")}};var Ke=require("coc.nvim");var ht=class{constructor(){this._inited=!1;this.disposables=[];this.closeEmitter=new Ke.Emitter}get srcId(){return ht.srcId}dispose(){(0,Ke.disposeAll)(this.disposables)}async instance(){return this._instance||(this._instance=await this._create()),this._instance}async input(e){return new Promise(t=>{this.closeEmitter.event(t),this.open(e).catch(g.error)})}async opened(){return this._opened(await this.instance())}async open(e){return this.storeOptions=e,this._open(await this.instance(),e)}async resize(){if(this.storeOptions)return this._resize(await this.instance(),this.storeOptions)}async close(e){await this._close(await this.instance(),e),this.closeEmitter.fire(e)}},ie=ht;ie.srcId="coc-floatinput";var G=class extends ie{constructor(){super(...arguments);this.defaultValues=["yes","no"]}async _create(){return await J.MultiFloatingWindow.create({wins:{prompt:{mode:"show"},btn:{mode:"show",hasBorderBuf:!0}}})}async _opened(t){return t.opened()}async getFinalOpenOptions(t){var c,l,u;let i=(c=t.width)!=null?c:30,n=0,o={relative:(l=t.relative)!=null?l:"center",title:t.title,border:[],wins:{}};if(t.prompt){let d=t.prompt.split(/\r\n|[\n\r]/g),f=await(0,J.displayHeight)(i,d);o.wins.prompt={width:i,height:f,focusable:!0,lines:d,highlights:d.map((m,h)=>({line:h,colStart:0,colEnd:m.length,hlGroup:"Question"}))},n=f}let s=await Promise.all(((u=t.values)!=null?u:this.defaultValues).map(async(d,f)=>{var h,b;let m=(b=(h=t.buttonText)==null?void 0:h[f])!=null?b:`${d[0].toUpperCase()}${d.slice(1)} (${d[0]})`;return{text:m,value:d,width:await(0,J.displayWidth)(m)}}));this.btnLinesLayout=Kt(i,s);let a=this.btnLinesLayout.length;return o.wins.btn={top:n,width:i,height:a,lines:this.btnLinesLayout.map(d=>d.map(f=>f.text).join("")),border:[1,0,0,0]},o}async waitUserInput(t,i){try{let n=await Zt(async({char:o,mode:s,stop:a,matchCode:c})=>{let l=await t.floatWinDict.btn.win();if(!l){await a();return}if(s===0)if(c(["<Esc>","<C-c>"]))await a();else if(c(["k","<Up>","h","<Left>"])){let u=i.indexOf(this.value);this.value=i[(u+i.length-1)%i.length],await this.resize()}else if(c(["j","<Down>","l","<Right>"])){let u=i.indexOf(this.value);this.value=i[(u+1)%i.length],await this.resize()}else if(c(["<LeftMouse>"])){let[u,d,f]=await S.workspace.nvim.eval("[v:mouse_winid, v:mouse_lnum, v:mouse_col]");if(u===l.id&&this.btnLinesLayout){let m=this.btnLinesLayout[d-1].find(h=>h.colStart<=f&&f<h.colEnd);m&&await a(m.value)}}else if(c(["<Cr>"]))await a(this.value);else{let u=o.toLowerCase(),d=i.find(f=>f[0].toLowerCase()===u);d&&await a(d)}});await this.close(n)}catch{await this.close()}}async updateHighlights(t){var i;S.workspace.nvim.pauseNotification(),t.floatWinDict.btn.buffer.clearNamespace(this.srcId),(i=this.btnLinesLayout)==null||i.forEach(n=>{n.forEach(o=>{t.floatWinDict.btn.buffer.highlightRanges(this.srcId,this.value===o.value?"PmenuSel":"None",[S.Range.create(S.Position.create(o.line,o.colStart),S.Position.create(o.line,o.colEnd))])})}),S.workspace.nvim.command("redraw!",!0),await S.workspace.nvim.resumeNotification()}async _open(t,i){var o,s;let n=(o=i.values)!=null?o:this.defaultValues;this.value=(s=i.defaultValue)!=null?s:n[n.length-1],await t.open(await this.getFinalOpenOptions(i)),await this.updateHighlights(t),this.waitUserInput(t,n).catch(g.error)}async _resize(t,i){await t.resize(await this.getFinalOpenOptions(i)),await this.updateHighlights(t)}async _close(t){await t.close()}};G.actionCmd=`floatinput.input.action_${J.versionName}`,G._inited=!1;var R=K(j()),P=require("coc.nvim");var y=class extends ie{constructor(){super(...arguments);this.id=0}genFiletype(){return`coc_floatinput_input_${this.id}`}async changeMode(t,i){t!==i&&(i==="i"?t==="n"&&await P.workspace.nvim.command('call feedkeys("a", "n")'):t!=="n"&&await P.workspace.nvim.command('call feedkeys("\\<ESC>l", "n")'))}async getContent(){return(await(await this.instance()).floatWinDict.input.buffer.getLines({start:0,end:1,strictIndexing:!1}))[0]}async confirm(t){if(t==="cancel")await this.close();else if(t==="ok"){let i=await this.getContent();await this.validateContent(i)&&await this.close(await this.stringToValue(i))}}_init(){y._inited||(y._inited=!0,this.disposables.push(P.events.on("BufEnter",async t=>{if(y.inputMap.get(t))return;let n=[];for(let o of y.inputMap.values())await o.input.opened()&&n.push(o.input);await Promise.all(n.map(o=>o.confirm("cancel")))}),P.events.on("BufWinLeave",async t=>{let i=y.inputMap.get(t);i&&(await i.inputWin.buffer.setOption("buftype","nofile"),await i.input.opened()&&await i.input.confirm("cancel"))}),P.events.on("TextChangedI",async t=>{let i=y.inputMap.get(t);i&&await i.input.textChange("i")}),P.events.on("TextChanged",async t=>{let i=y.inputMap.get(t);i&&await i.input.textChange("n")}),P.commands.registerCommand(y.actionCmd,g.asyncCatch(async(t,i,n,o)=>{let s=y.inputMap.get(i);s&&(await s.input.changeMode(n,o),await s.input.confirm(t))}),void 0,!0)))}async _create(){this._init(),y.maxId++,this.id=y.maxId;let t=await R.MultiFloatingWindow.create({wins:{prompt:{mode:"show"},input:{mode:"base"}}}),i=t.floatWinDict.input;return y.inputMap.has(i.bufnr)||y.inputMap.set(i.bufnr,{input:this,instance:t,inputWin:i}),this.disposables.push(P.Disposable.create(()=>{var n;(n=this.completionDisposable)==null||n.dispose()})),t}async _opened(t){return t.opened()}async textChange(t){if(!this.storeOptions)return;let i=await this.instance();await i.resize(await this.getFinalOpenOptions(this.storeOptions,i,"resize",t))}async getFinalOpenOptions(t,i,n,o="n"){var h,b,p;let s=(await P.workspace.nvim.mode).mode,a=(h=t.width)!=null?h:30,c=0,l={relative:(b=t.relative)!=null?b:"center",title:t.title,border:t.border===!1?void 0:[],wins:{}};if(t.prompt){let W=t.prompt.split(/\r\n|[\n\r]/g),N=await(0,R.displayHeight)(a,W);l.wins.prompt={width:a,height:N,focusable:!1,lines:W,highlights:W.map((B,Z)=>({line:Z,colStart:0,colEnd:B.length,hlGroup:"Question"}))},c=N}let u,d;if(n==="open")u=[t.defaultValue?await this.valueToString(t.defaultValue):await this.defaultString()],d=await(0,R.displayHeight)(a,u);else{let W=i.floatWinDict.input;u=await W.buffer.getLines();let N=await W.win();if(N){let B=await N.cursor;d=await(0,R.displayHeight)(a,u,B,o)}else d=await(0,R.displayHeight)(a,u)}let f=i.floatWinDict.input.bufnr,m=(p=t.filetype)!=null?p:this.genFiletype();return l.wins.input={top:c,width:a,height:d||1,focus:!0,modifiable:!0,lines:u,filetype:m,initedExecute:()=>`
        call setbufvar(${f}, '&buftype', '')
        call setbufvar(${f}, '&wrap', 1)
        nmap <silent><buffer> <CR> :call CocAction('runCommand', '${y.actionCmd}', 'ok', ${f}, 'n', '${s}')<CR>
        imap <silent><buffer> <CR> <C-o>:call CocAction('runCommand', '${y.actionCmd}', 'ok', ${f}, 'i', '${s}')<CR>
        nmap <silent><buffer> <ESC> :call CocAction('runCommand', '${y.actionCmd}', 'cancel', ${f}, 'n', '${s}')<CR>
        imap <silent><buffer> <C-c> <C-o>:call CocAction('runCommand', '${y.actionCmd}', 'cancel', ${f}, 'i', '${s}')<CR>
        call feedkeys('A')
      `},t.completion&&(this.completionDisposable&&this.completionDisposable.dispose(),this.completionDisposable=P.languages.registerCompletionItemProvider(m,t.completion.short,[m],t.completion.provider)),l}async _open(t,i){await t.open(await this.getFinalOpenOptions(i,t,"open"))}async _resize(t,i){await t.resize(await this.getFinalOpenOptions(i,t,"resize"))}async _close(t){await t.close()}},$=y;$.maxId=0,$.actionCmd=`floatinput.input.action_${R.versionName}`,$.inputMap=new Map,$._inited=!1;var ce=class extends ${async defaultString(){return"0"}async valueToString(e){return e.toString()}async stringToValue(e){return parseInt(e,10)}async validateContent(e){return/^\s*[0-9]+\s*$/.test(e)}};var le=class extends ${async defaultString(){return"0"}async valueToString(e){return e.toString()}async stringToValue(e){return parseFloat(e)}async validateContent(e){return/^\s*(([0-9]*\.[0-9]+)|([0-9]+))\s*$/.test(e)}};var z=class extends ${async defaultString(){return""}async valueToString(e){return e}async stringToValue(e){return e}async validateContent(){return!0}};var Yt=K(j()),Ue=require("coc.nvim");var gt=new Yt.HelperEventEmitter(g);function ei(r){r.subscriptions.push(Ue.workspace.registerAutocmd({event:"User CocStatusChange",callback(){gt.fire("CocStatusChange").catch(g.error)}}),Ue.commands.registerCommand("floatinput.internal.inputchar",(e,t)=>{mt.fire("InputChar",e,t).catch(g.error)},void 0,!0))}var ti=new z,ii=new le,ni=new ce,an=new G,Qe;(n=>{n.stringInput=ti.input.bind(ti),n.numberInput=ii.input.bind(ii),n.intInput=ni.input.bind(ni);function i(o){return an.input(o)}n.confirm=i})(Qe||(Qe={}));var L=require("coc.nvim"),ne=class{constructor(){this.completionKind=L.CompletionItemKind.Method}async provideCompletionItems(e,t){let i=e.getText(L.Range.create(L.Position.create(t.line,0),t));return(await this.getList(i)).map(o=>{var s;return{label:o.name,kind:(s=o.kind)!=null?s:this.completionKind,insertText:o.name}})}},Ge=class extends ne{async getList(e){return(await L.workspace.nvim.call("getcompletion",[e,"cmdline"])).map(i=>({name:i}))}},Je=class extends ne{async getList(e){return L.commands.commandList.map(t=>({name:t.id})).filter(t=>t.name.startsWith(e))}},Xe=class extends ne{async getList(t){return this.document?(await L.workspace.nvim.call("CocAction",["documentSymbols",this.document.bufnr])).map(n=>({name:n.text})).filter(n=>n.name.startsWith(t)):[]}};var C=require("coc.nvim");async function cn(){return await C.workspace.nvim.call("CocHasProvider","rename")?!0:(C.window.showMessage("Rename provider not found for current document","error"),!1)}async function ln(r,e){let t=await C.languages.prepareRename(r.textDocument,e);return t||(C.window.showMessage("Invalid position for renmame","error"),!1)}async function un(r,e){let t=await ln(r,e);return t?"placeholder"in t?t.placeholder:r.textDocument.getText(t):void 0}async function ri(r){let e=new Xe,t=new z;async function i(){let n=await C.workspace.document;if(await Gt(n),!await cn())return;let o=await C.window.getCursorPosition(),s=await un(n,o);if(!s)return;e.document=n;let a=await t.input({title:"coc-rename",filetype:"floatinput_coc_rename",relative:"cursor-around",defaultValue:s,prompt:`${s} ->`,completion:{short:"C",provider:e}});if(a!==void 0){if(!a){C.window.showMessage("Empty name, canceled","warning");return}let c=await C.languages.provideRenameEdits(n.textDocument,o,a);if(!c){C.window.showMessage("Invalid position for rename","warning");return}await C.workspace.applyEdit(c)}}r.subscriptions.push(t,C.commands.registerCommand("floatinput.rename",()=>{i().catch(g.error)}),C.workspace.registerKeymap(["n","i"],"floatinput-rename",()=>{i().catch(g.error)}))}var Ze=K(j()),X=require("coc.nvim");async function dn(r,e,t){let i=e+2,n=t+2,o=await X.workspace.nvim.getOption("showtabline"),s=(await X.workspace.nvim.tabpages).length,a=X.workspace.env.lines,c=X.workspace.env.columns,l=o===0?0:o===2||s>1?1:0,u=0,d=l;return r==="top-left"?(d=l,u=0):r==="top-center"?(d=l,u=(c-i)/2):r==="top-right"?(d=l,u=c-i):r==="bottom-left"?(d=a-n,u=0):r==="bottom-center"||r==="bottom-right"?(d=a-n,u=(c-i)/2):r==="left-center"?(d=(a-n)/2,u=0):r==="right-center"&&(d=(a-n)/2,u=c-i),{top:d,left:u,width:e,height:t}}var ue=class{constructor(e,t,i=[]){this.context=e;this.config=t;this.disposables=i}static async create(e,t){let i=[];return new ue(e,t,i)}dispose(){(0,X.disposeAll)(this.disposables)}async floatWin(){return this._floatWin||(this._floatWin=await Ze.FloatingWindow.create({mode:"show"})),this._floatWin}async show(){let e=await X.workspace.nvim.getVar("coc_status");if(!e)return;let t=[e],i=this.config.get("status.direction"),n=this.config.get("status.width"),o=this.config.get("status.timeout"),s=await(0,Ze.displayHeight)(n,t),a=await dn(i,n,s),c=await this.floatWin(),l={title:"coc-status",...a,border:[],lines:t};await c.opened()?await c.resize(l):await c.open(l),await c.setLines({...l,lines:t}),this.autoCloseTimer&&clearTimeout(this.autoCloseTimer),this.autoCloseTimer=setTimeout(()=>{this.hide().catch(g.error)},o)}async hide(){var e;await((e=this._floatWin)==null?void 0:e.close())}async enable(){this.config=ze(),this.disposables.push(gt.on("CocStatusChange",()=>{this.show().catch(g.error)}))}async disable(){}};var oi={components:{Input:$,StringInput:z,NumberInput:le,IntInput:ce,Confirm:G},ListProvider:ne,FloatingUI:Qe};async function fn(r){if(E.workspace.isVim){E.window.showMessage("coc-floatinput only support neovim","warning");return}let{subscriptions:e}=r;await(0,Ye.activateHelper)(r);let t=new z;async function i(){let a=await t.input({title:"command",relative:"center",filetype:"floatinput_command",completion:{short:"C",provider:new Ge}});if(a)return E.workspace.nvim.command(a)}e.push(t,E.commands.registerCommand("floatinput.command",()=>{i().catch(g.error)}),E.workspace.registerKeymap(["n","i"],"floatinput-command",()=>{i().catch(g.error)}));async function n(){let a=await t.input({title:"coc-command",relative:"center",filetype:"floatinput_coc_command",completion:{short:"C",provider:new Je}});if(a)return E.commands.executeCommand(a)}e.push(t,E.commands.registerCommand("floatinput.coc.command",()=>{n().catch(g.error)}),E.workspace.registerKeymap(["n","i"],"floatinput-coc-command",()=>{n().catch(g.error)})),await ri(r),ei(r),await(0,Ye.registerRuntimepath)(r);let o=ze(),s=await ue.create(r,o);return o.get("status.enabled")&&await s.enable(),oi}0&&(module.exports={FloatInput,activate});
