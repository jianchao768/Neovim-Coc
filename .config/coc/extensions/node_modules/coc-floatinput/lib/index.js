!function(e,n){for(var t in n)e[t]=n[t];n.__esModule&&Object.defineProperty(e,"__esModule",{value:!0})}(exports,(()=>{"use strict";var e={555:(e,n,t)=>{t.r(n),t.d(n,{FloatingWindow:()=>K,HelperEventEmitter:()=>W,HelperLogger:()=>v,HelperVimEvents:()=>S,MultiFloatingWindow:()=>U,Notifier:()=>N,VimModule:()=>L,WinLayoutFinder:()=>G,activate:()=>q,activateHelper:()=>Q,bufModule:()=>j,byteIndex:()=>f,byteLength:()=>h,compactI:()=>o,displayHeight:()=>m,displayWidth:()=>p,eventsModule:()=>H,floatingModule:()=>D,generateUri:()=>d,getConfigLocal:()=>w,helperEvents:()=>F,helperLogger:()=>y,helperVimEvents:()=>A,isLinux:()=>c,isMacintosh:()=>l,isTest:()=>u,isWebpack:()=>a,isWindows:()=>s,prettyObject:()=>_,prettyPrint:()=>C,sleep:()=>I,sum:()=>r,utilModule:()=>B,version:()=>x,versionName:()=>$});var i=t(888);const o=e=>e.filter((e=>null!=e)),r=e=>e.reduce(((e,n)=>e+n)),a="function"==typeof t,s="win32"===process.platform,l="darwin"===process.platform,c="linux"===process.platform,u=!1;function d(e,n="file"){return"file"===n&&s&&/^[A-Za-z]:/.test(e)&&(e="/"+e),n+"://"+e}function f(e,n){const t=e.slice(0,n);return Buffer.byteLength(t)}function h(e){return Buffer.byteLength(e)}async function p(e){return await i.workspace.nvim.call("strdisplaywidth",[e])}async function m(e,n,t,i="n"){const o=await Promise.all(n.map((async(n,o)=>{let r=await p(n);return"i"===i&&t&&t[0]-1===o&&t[1]+1>=r&&(r+=1),Math.ceil(r/e)})));return r(o)}const w=e=>(n=d(i.workspace.cwd))=>i.workspace.getConfiguration(e,n),b=require("util");var g=t.n(b);class v{constructor(e){this.channelName=e,this.appendLine=this.appendLine.bind(this),this.error=this.error.bind(this)}dispose(){var e;null===(e=this.outputChannel_)||void 0===e||e.dispose()}get outputChannel(){return this.outputChannel_||(this.outputChannel_=i.window.createOutputChannel(this.channelName)),this.outputChannel_}appendLine(e){this.outputChannel.appendLine(e)}error(e){var n,t,o,r;e instanceof Error?(i.window.showMessage(e.message,"error"),null===(n=this.outputChannel)||void 0===n||n.appendLine(null!==(t=e.stack)&&void 0!==t?t:e.toString()),u&&console.error(null!==(o=e.stack)&&void 0!==o?o:e.toString())):(i.window.showMessage(e,"error"),null===(r=this.outputChannel)||void 0===r||r.appendLine(e),u&&console.error(e))}asyncCatch(e){return async(...n)=>{try{return await e(...n)}catch(e){this.error(e)}}}}const y=new v("coc-helper");function _(...e){const n=e=>e.toString(10).padStart(2,"0"),t=new Date;let i=`[${t.getFullYear()}/${n(t.getMonth()+1)}/${n(t.getDate())} ${n(t.getHours())}:${n(t.getMinutes())}:${n(t.getSeconds())}.${n(t.getMilliseconds())}]`;for(const n of e)i+=" "+g().inspect(n);return i}function C(...e){y.appendLine(_(...e)),i.window.showMessage(_(...e))}const x="0.8.4",$=x.replace(/[.-]/g,"_");function I(e){return new Promise((n=>{setTimeout(n,e)}))}class N{constructor(e){this.notifyFns=[],this.notifyFns.push(e)}static async run(e){if(e){if(!("then"in e))return e.run();{const n=await e;if(n)return n.run()}}}static notifyAll(e){for(const n of e)n&&n.notify()}static async runAll(e){const n=await Promise.all(e);return i.workspace.nvim.pauseNotification(),this.notifyAll(n),i.workspace.nvim.resumeNotification()}static combine(e){const n=o(e);return n.length<1?N.noop():1===n.length?n[0]:n.reduce(((e,n)=>e.concat(n)),N.noop())}static noop(){return this.create((()=>{}))}static create(e){return new N(e)}async run(){return N.runAll([this])}notify(){for(const e of this.notifyFns)e()}concat(e){return this.notifyFns.push(...e.notifyFns),this}}const k=`g:coc_helper_module_p${process.pid}_${$}`,O=`CocHelperCallFn_${$}`,E=`CocHelperCallVar_${$}`,M="__coc_helper_module_max_id";function P(e){return e.replace(/\n\s*\\/g,"")}class L{constructor(e){this.moduleKey=e}static async init(e){for(await i.workspace.nvim.call("execute",`\n        if !exists('${k}')\n          let ${k} = {}\n        endif\n\n        function! ${O}(module_key, method_name, args)\n          try\n            return call(${k}[a:module_key][a:method_name], a:args)\n          catch\n            let ex = v:exception\n            let msg = 'error when call ' . a:module_key . '.' . a:method_name\n            echom msg\n            echom ex\n            throw msg . ex\n          endtry\n        endfunction\n\n        function! ${E}(module_key, var_name, expression)\n          try\n            let ${k}[a:module_key][a:var_name] = eval(a:expression)\n          catch\n            let ex = v:exception\n            let msg = 'error when declare ' . a:module_key . '.' . a:var_name\n            echom msg\n            echom ex\n            throw msg . ex\n          endtry\n        endfunction\n      `);L.initQueue.length;){const n=L.initQueue.shift();try{await n(e)}catch(e){y.error(e)}}}static create(e,n){const t=`${M in global||(global[M]=0),global[M]+=1,global[M]}_${e}`,o=new L(t);let r;function a(){return r||(r=n(o)),r}return L.initQueue.push((async()=>{await i.workspace.nvim.call("execute",`let ${k}.${t} = {}`),a()})),new Proxy({},{get:(e,n)=>Reflect.get(a(),n),has:(e,n)=>n in a(),ownKeys:()=>Object.keys(a())})}registerInit(e){L.initQueue.push(e)}fn(e,n){const{nvim:t}=i.workspace,o=`${k}.${this.moduleKey}.${e}`,r=n({name:o}),a=`${this.moduleKey}.${e}`;return this.registerInit((async()=>{y.appendLine(`declare fn ${a}`),await t.call("execute",[P(r)])})),{name:o,inlineCall:(n="")=>`${O}('${this.moduleKey}', '${e}', [${n}])`,call:(...n)=>(y.appendLine(`call ${a}`),t.call(O,[this.moduleKey,e,n])),callNotify:(...n)=>(y.appendLine(`callNotify ${a}`),t.call(O,[this.moduleKey,e,n],!0)),callNotifier:(...n)=>(y.appendLine(`callNotifier ${a}`),N.create((()=>{t.call(O,[this.moduleKey,e,n],!0)})))}}var(e,n){const{nvim:t}=i.workspace,o=`${k}.${this.moduleKey}.${e}`,r=`${this.moduleKey}.${e}`;return this.registerInit((async()=>{y.appendLine(`declare var ${r}`),await t.call(E,[this.moduleKey,e,P(n)])})),{name:o,inline:o,get:()=>t.eval(o),set:async n=>{await t.call(E,[this.moduleKey,e,P(n)])},setNotify:n=>{t.call(E,[this.moduleKey,e,P(n)],!0)},setNotifier:n=>N.create((()=>{t.call(E,[this.moduleKey,e,P(n)],!0)}))}}}L.initQueue=[];const B=L.create("util",(e=>{const n=i.workspace.isNvim;return{globalCursorPosition:e.fn("global_cursor_position",(({name:e})=>`\n        function! ${e}()\n          let nr = winnr()\n          let [row, col] = win_screenpos(nr)\n          return [row + winline() - 2, col + wincol() - 2]\n        endfunction\n      `)),isFloat:e.fn("is_float",(({name:e})=>n?`\n          function! ${e}(winnr) abort\n            if !exists('*nvim_win_get_config')\n              return v:false\n            endif\n            let winid = win_getid(a:winnr)\n            return nvim_win_get_config(winid)['relative'] != ''\n          endfunction\n        `:`\n          function! ${e}(winnr) abort\n            return v:false\n          endfunction\n        `)),closeWinByBufnr:e.fn("close_win_by_bufnr",(({name:e})=>`\n        if exists('*nvim_win_close')\n          function! ${e}(bufnrs) abort\n            for bufnr in a:bufnrs\n              try\n                let winid = bufwinid(bufnr)\n                if winid >= 0\n                  call nvim_win_close(winid, v:true)\n                endif\n              catch\n              endtry\n            endfor\n          endfunction\n        else\n          function! ${e}(bufnrs) abort\n            for bufnr in a:bufnrs\n              try\n                let winnr = bufwinnr(bufnr)\n                if winnr >= 0\n                  execute winnr . 'wincmd c'\n                endif\n              catch\n              endtry\n            endfor\n          endfunction\n        endif\n      `)),runCocCmd:e.fn("run_coc_cmd",(({name:e})=>`\n      function! ${e}(name, ...) abort\n        return call('CocAction', extend(['runCommand', a:name], a:000))\n      endfunction\n    `)),runCocCmdAsync:e.fn("run_coc_cmd_async",(({name:e})=>`\n      function! ${e}(name, ...) abort\n        return call('CocActionAsync', extend(['runCommand', a:name], a:000))\n      endfunction\n    `))}}));class W{constructor(e,n=!1){this.helperLogger=e,this.concurrent=n,this.listenersMap=new Map}listeners(e){if(!this.listenersMap.has(e)){const n=[];return this.listenersMap.set(e,n),n}return this.listenersMap.get(e)}on(e,n,t){this.listeners(e).push(n);const o=i.Disposable.create((()=>this.off(e,n)));return t&&t.push(o),o}off(e,n){"function"==typeof n.cancel&&n.cancel();const t=this.listeners(e),i=t.indexOf(n);-1!==i&&t.splice(i,1)}async fire(e,...n){if(this.concurrent)await Promise.all(this.listeners(e).map((async e=>{try{await e(...n)}catch(e){this.helperLogger.error(e)}})));else for(const t of this.listeners(e))try{await t(...n)}catch(e){this.helperLogger.error(e)}}}class S{constructor(e,n,t={}){var i,o,r,a;this.vimEvents=e,this.helperLogger=n,this.options=t,++S.ID,this.id=S.ID,this.augroupName=null!==(i=t.augroupName)&&void 0!==i?i:`CocHelperInternal_${$}_${t.name?`${t.name}_`:""}${this.id}`,this.commandName=null!==(r=null!==(o=t.commandName)&&void 0!==o?o:t.commandName)&&void 0!==r?r:`coc-helper.internal.didVimEvent_${t.name?`${t.name}_`:""}${this.id}`,this.events=new W(this.helperLogger,null!==(a=t.concurrent)&&void 0!==a&&a)}async register(e){await H.activate.call(this.augroupName,this.commandName,Object.entries(this.vimEvents).map((([e,n])=>Object.assign({event:e},n)))),e.subscriptions.push(i.Disposable.create((async()=>{await H.deactivate.call(this.augroupName)}))),e.subscriptions.push(i.commands.registerCommand(this.commandName,y.asyncCatch(((e,...n)=>this.events.fire(e,...n))),void 0,!0))}}S.ID=0;const A=new S({BufDelete:{eventExpr:"BufDelete *",argExprs:["+expand('<abuf>')"]},BufWipeout:{eventExpr:"BufWipeout *",argExprs:["+expand('<abuf>')"]}},y),F=A.events,H=L.create("events",(e=>{const n=e.fn("activate",(({name:e})=>`\n      function! ${e}(augroup_name, autocmd_events) abort\n        execute 'augroup ' . a:augroup_name\n          autocmd!\n          for autocmd_event in a:autocmd_events\n            execute autocmd_event\n          endfor\n        augroup END\n      endfunction\n    `));function t(e,n){return n.map((n=>{var t;const i=`${[`'${e}'`,`'${n.event}'`,...null!==(t=n.argExprs)&&void 0!==t?t:[]].join(", ")}`;return`autocmd ${n.eventExpr} call ${!1===n.async?B.runCocCmd.inlineCall(i):B.runCocCmdAsync.inlineCall(i)}`}))}return{activate:{call:(e,i,o)=>n.call(e,t(i,o)),callNotify:(e,i,o)=>n.callNotify(e,t(i,o)),callNotifier:(e,i,o)=>n.callNotifier(e,t(i,o))},deactivate:e.fn("deactivate",(({name:e})=>`\n        function! ${e}(augroup_name) abort\n          execute 'augroup ' . a:augroup_name\n            autocmd!\n          augroup END\n        endfunction\n      `)),doAutocmd:e.fn("do_autocmd",(({name:e})=>`\n        function! ${e}(name) abort\n          if exists('#User#'.a:name)\n            exe 'doautocmd <nomodeline> User '.a:name\n          endif\n        endfunction\n      `))}})),j=L.create("buf",(e=>{const n=i.workspace.isNvim,t=e.fn("create_by_name",(({name:e})=>`\n      function! ${e}(name) abort\n        return bufadd(a:name)\n      endfunction\n    `));return{createByName:t,create:e.fn("create",(({name:e})=>n?`\n          function! ${e}(...) abort\n            let name = get(a:000, 0, '')\n            if name is ''\n              return nvim_create_buf(v:false, v:true)\n            else\n              return ${t.inlineCall("name")}\n            endif\n          endfunction\n        `:`\n          function! ${e}(...) abort\n            let name = get(a:000, 0, '')\n            return ${t.inlineCall("name")}\n          endfunction\n        `))}})),D=L.create("float",(e=>{const n=i.workspace.isNvim,t=e.fn("init_execute",(({name:e})=>`\n      function! ${e}(ctx, inited_execute) abort\n        execute a:inited_execute\n      endfunction\n    `)),o=e.fn("open_win",(({name:e})=>n?`\n        function! ${e}(bufnr, focus, win_config, win_hl, inited_execute) abort\n          let winid = nvim_open_win(a:bufnr, a:focus, a:win_config)\n          if !empty(a:win_hl)\n            call nvim_win_set_option(winid, 'winhl', a:win_hl)\n          endif\n          if !empty(a:inited_execute)\n            call ${t.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}\n          endif\n          return winid\n        endfunction\n      `:`\n        function! ${e}(bufnr, focus, win_config, win_hl, inited_execute) abort\n          let winid = popup_create(a:bufnr, a:win_config)\n          call ${t.inlineCall("{'bufnr': a:bufnr, 'winid': winid}, a:inited_execute")}\n\n          return winid\n        endfunction\n      `));return{create:e.fn("create",(({name:e})=>n?`\n            function! ${e}(name, inited_execute, has_border_buf, border_inited_execute) abort\n              let bufnr = ${j.create.inlineCall("a:name")}\n              call ${t.inlineCall("{'bufnr': bufnr}, a:inited_execute")}\n\n              let border_bufnr = v:null\n              if a:has_border_buf\n                let border_bufnr = nvim_create_buf(v:false, v:true)\n                call ${t.inlineCall("{'bufnr': border_bufnr}, a:border_inited_execute")}\n              endif\n              return [bufnr, border_bufnr]\n            endfunction\n          `:`\n            function! ${e}(name, inited_execute, has_border_buf, border_inited_execute) abort\n              let bufnr = ${j.create.inlineCall("a:name")}\n              call ${t.inlineCall("{'bufnr': bufnr}, a:inited_execute")}\n              return [bufnr, v:null]\n            endfunction\n          `)),open:e.fn("open",(({name:e})=>`\n        function! ${e}(bufnr, win_config, inited_execute, border_bufnr, border_win_config, border_inited_execute, focus, win_hl) abort\n          let winid = ${o.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, a:inited_execute")}\n          call setbufvar(a:bufnr, 'coc_helper_winid', winid)\n\n          if a:border_bufnr\n            let border_winid = ${o.inlineCall("a:border_bufnr, v:false, a:border_win_config, a:win_hl, a:border_inited_execute")}\n            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)\n          endif\n        endfunction\n      `)),resume:e.fn("resume",(({name:e})=>`\n        function! ${e}(bufnr, win_config, border_bufnr, border_win_config, focus, win_hl) abort\n          let winid = ${o.inlineCall("a:bufnr, a:focus, a:win_config, a:win_hl, ''")}\n          call setbufvar(a:bufnr, 'coc_helper_winid', winid)\n\n          if a:border_bufnr\n            let border_winid = ${o.inlineCall("border_bufnr, v:false, a:border_win_config, a:win_hl, ''")}\n            call setbufvar(a:bufnr, 'coc_helper_border_winid', border_winid)\n          endif\n        endfunction\n      `)),update:e.fn("update",(({name:e})=>n?`\n          function! ${e}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort\n            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)\n            if !winid\n              return\n            endif\n            call nvim_win_set_config(winid, a:win_config)\n            if !empty(a:win_hl)\n              call nvim_win_set_option(winid, 'winhl', a:win_hl)\n            endif\n            if has('nvim')\n              redraw!\n            endif\n\n            if a:border_bufnr\n              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)\n              if border_winid\n                call nvim_win_set_config(border_winid, a:border_win_config)\n                if !empty(a:win_hl)\n                  call nvim_win_set_option(border_winid, 'winhl', a:win_hl)\n                endif\n                if has('nvim')\n                  redraw!\n                endif\n              endif\n            endif\n          endfunction\n        `:`\n          function! ${e}(bufnr, win_config, border_bufnr, border_win_config, win_hl) abort\n            let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)\n            if !winid\n              return\n            endif\n            call popup_setoptions(winid, a:win_config)\n          endfunction\n        `)),winid:e.fn("winid",(({name:e})=>`\n        function! ${e}(bufnr) abort\n          let id = getbufvar(a:bufnr, 'coc_helper_winid', v:null)\n          let nr = win_id2win(id)\n          return nr is 0 ? v:null : id\n        endfunction\n      `)),borderWinid:e.fn("border_winid",(({name:e})=>`\n        function! ${e}(bufnr) abort\n          return getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)\n        endfunction\n      `)),close:e.fn("close",(({name:e})=>n?`\n            function! ${e}(bufnr) abort\n              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)\n              let border_winid = getbufvar(a:bufnr, 'coc_helper_border_winid', v:null)\n              try\n                if winid\n                  call nvim_win_close(winid, v:true)\n                endif\n                if border_winid\n                  call nvim_win_close(border_winid, v:true)\n                endif\n              catch\n              endtry\n            endfunction\n          `:`\n            function! ${e}(bufnr) abort\n              let winid = getbufvar(a:bufnr, 'coc_helper_winid', v:null)\n              try\n                if winid\n                  call popup_close(winid)\n                endif\n              catch\n              endtry\n            endfunction\n          `))}})),V=["─","│","─","│","┌","┐","┘","└"],T="CocHelperNormalFloat",z="CocHelperNormalFloatBorder";class R{constructor(e){this.srcId=e}async createContext(e){var n,t;return null!==(n=e.context)&&void 0!==n?n:{lines:i.workspace.env.lines,columns:i.workspace.env.columns-i.workspace.env.cmdheight-1,globalCursorPosition:await B.globalCursorPosition.call(),title:e.title?{text:e.title,width:await p(e.title)}:{text:"",width:0},borderEnabled:!!e.border,border:this.extendEdges(null===(t=e.border)||void 0===t?void 0:t.map((e=>"boolean"==typeof e?1:e))),paddingEnabled:!!e.padding,padding:this.extendEdges(e.padding)}}getCenterPos(e,n){const[,,t,i]=n;return[Math.floor((e.lines-i)/2),Math.floor((e.columns-t)/2)]}getPosForAround(e,n,t,i=!1){const o=e.columns,r=e.lines-1,[a,s]=n;let[l,c]=t;return i?l-s<0?l+=1:l-=s:l+s>=r?l-=s:l+=1,c+a>=o&&(c-=a-1),[l,c]}extendEdges(e){var n,t,i,o;if(!e)return[0,0,0,0];const r=null!==(n=e[0])&&void 0!==n?n:1,a=null!==(t=e[1])&&void 0!==t?t:r;return[r,a,null!==(i=e[2])&&void 0!==i?i:r,null!==(o=e[3])&&void 0!==o?o:a]}changeBoxByEdgesList(e,n){let t=[...e];for(const e of n)t=this.changeBoxByEdges(t,e);return t}changeBoxByEdges(e,n){if(!n)return e;const[t,i,o,r]=n;let[a,s,l,c]=e;return a-=t,s-=r,l+=r+i,c+=t+o,[a,s,l,c]}getBoxSizes(e,n,t){var i,o;const[r,a]=[null!==(i=n.top)&&void 0!==i?i:0,null!==(o=n.left)&&void 0!==o?o:0],s=[0,0,Math.max(n.width,e.title.width),n.height],l=this.changeBoxByEdges(s,e.padding),c=this.changeBoxByEdges(l,e.border);let u;if("center"===n.relative)u=this.getCenterPos(e,c);else{const i=!t&&this.storeCursorPosition?this.storeCursorPosition:e.globalCursorPosition;u="cursor"===n.relative?i:"cursor-around"===n.relative?this.getPosForAround(e,[c[2],c[3]],i):[r,a],this.storeCursorPosition=i}return[c[0],c[1]]=[u[0],u[1]],[l[0],l[1]]=[c[0]+e.border[0],c[1]+e.border[3]],[s[0],s[1]]=[l[0]+e.padding[0],l[1]+e.padding[3]],{contentBox:s,paddingBox:l,borderBox:c}}vimWinConfig(e,n,t){var i,o,r,a,s,l,c,u;const[d,f,h,p]=[null!==(i=n.top)&&void 0!==i?i:0,null!==(o=n.left)&&void 0!==o?o:0,n.width,n.height],m={line:0,col:0,zindex:null!==(r=n.borderOnly)&&void 0!==r&&r?1:100,minwidth:h,minheight:p,maxwidth:h,maxheight:p};if("center"===n.relative)m.pos="center";else{const i=!t&&this.storeCursorPosition?this.storeCursorPosition:e.globalCursorPosition;if("cursor"===n.relative)[m.line,m.col]=i;else if("cursor-around"===n.relative){const n=this.changeBoxByEdgesList([d,f,h,p],[e.padding,e.border]);[m.line,m.col]=this.getPosForAround(e,[n[2],n[3]],i)}else[m.line,m.col]=[d,f];this.storeCursorPosition=i,m.line+=1,m.col+=1}const w=null!==(a=n.topOffset)&&void 0!==a?a:0,b=null!==(s=n.leftOffset)&&void 0!==s?s:0;return m.line+=w,m.col+=b,n.maxWidth&&(m.maxwidth=n.maxWidth),n.maxHeight&&(m.maxheight=n.maxHeight),m.highlight=null!==(l=n.winHl)&&void 0!==l?l:T,n.padding&&(m.padding=n.padding),e.borderEnabled&&(m.border=e.border,m.border[0]&&(e.title.width&&(m.title=e.title.text),m.close="button"),m.borderchars=null!==(c=n.borderChars)&&void 0!==c?c:V,m.borderhighlight=[null!==(u=n.borderWinHl)&&void 0!==u?u:z]),m}nvimWinConfig(e,n,t){var i,o,r;const{contentBox:a,borderBox:s}=this.getBoxSizes(e,n,t),l=null!==(i=n.topOffset)&&void 0!==i?i:0,c=null!==(o=n.leftOffset)&&void 0!==o?o:0,u={relative:"editor",row:a[0]+l,col:a[1]+c,width:a[2],height:a[3],focusable:null===(r=n.focusable)||void 0===r||r};let d;return s&&(d={relative:"editor",row:s[0]+l,col:s[1]+c,width:s[2],height:s[3],focusable:!1}),[u,d]}winConfig(e,n,t=!0){return i.workspace.isVim?[this.vimWinConfig(e,n,t),void 0]:this.nvimWinConfig(e,n,t)}getRenderBorderData(e,n,t){var i,o,r,a,s,l;const c=null!==(o=null===(i=e.title)||void 0===i?void 0:i.text)&&void 0!==o?o:"",u=null!==(a=null===(r=e.title)||void 0===r?void 0:r.width)&&void 0!==a?a:0;if(!e.borderEnabled)return;const[d,f,h,p]=e.border;let[m,w,b,g,v,y,_,C]=null!==(s=n.borderChars)&&void 0!==s?s:V;d||(m=""),f||(w=""),h||(b=""),p||(g=""),d&&p||(v=""),d&&f||(y=""),h&&p||(C=""),h&&f||(_="");const x=t[0],$=t[1],I=x-p-f,N=$-d-h,k=[];d&&k.push(v+c+m.repeat(I-u)+y),k.push(...Array.from({length:N},(()=>g+" ".repeat(I)+w))),h&&k.push(C+b.repeat(I)+_);const O=[],E=null!==(l=n.borderWinHl)&&void 0!==l?l:z;if(E){O.push({srcId:this.srcId,hlGroup:E,line:0,colStart:0,colEnd:x});for(let e=0,n=N;e<n;e++)p&&O.push({srcId:this.srcId,hlGroup:E,line:e+1,colStart:0,colEnd:p}),f&&O.push({srcId:this.srcId,hlGroup:E,line:e+1,colStart:p+I,colEnd:x});h&&O.push({srcId:this.srcId,hlGroup:E,line:$-1,colStart:0,colEnd:x})}return{lines:k,highlights:O}}renderBorderNotifier(e,n,t,i){const o=this.getRenderBorderData(n,t,"width"in i?[i.width,i.height]:[i.minwidth,i.minheight]);if(!o)return N.noop();const{lines:r,highlights:a}=o;return N.create((()=>{e.setOption("modifiable",!0,!0),e.setOption("readonly",!1,!0),e.setLines(r,{start:0,end:-1},!0),e.setOption("modifiable",!1,!0),e.setOption("readonly",!0,!0),this.addHighlightsNotify(e,a)}))}nvimWinHl(e){var n,t;if(i.workspace.isVim)return"";const o=[];return o.push("Normal:"+(null!==(n=e.winHl)&&void 0!==n?n:T)),o.push("NormalNC:"+(null!==(t=e.winHlNC)&&void 0!==t?t:"CocHelperNormalFloatNC")),o.join(",")}addHighlightsNotify(e,n){for(const t of n)t.srcId&&t.hlGroup&&void 0!==t.line&&void 0!==t.colStart&&void 0!==t.colEnd&&e.highlightRanges(this.srcId,t.hlGroup,[i.Range.create(t.line,t.colStart,t.line,t.colEnd)])}}class K{constructor(e,n,t,o,r){this.bufnr=e,this.borderBufnr=n,this.createOptions=t,this.mode=o,this.util=r,this.nvim=i.workspace.nvim,this.disposables=[],this.nvim=i.workspace.nvim,this.buffer=this.nvim.createBuffer(e),n&&(this.borderBuffer=i.workspace.nvim.createBuffer(n),this.disposables.push(i.events.on("BufWinLeave",y.asyncCatch((async e=>{this.borderBufnr&&e===this.bufnr&&await B.closeWinByBufnr.call([this.borderBufnr])})))))}static getInitedExecute(e,n){var t,i,o,r;let a=null!==(i=null===(t=n.initedExecute)||void 0===t?void 0:t.call(n,K.initedContextVars.create))&&void 0!==i?i:"";return a=K.modePresets[e].createInitedExecute(K.initedContextVars.create)+"\n"+a,[a,null!==(r=null===(o=n.borderInitedExecute)||void 0===o?void 0:o.call(n,K.initedContextVars.create))&&void 0!==r?r:K.modePresets.show.createInitedExecute(K.initedContextVars.create)]}static async create(e={}){var n,t,i;const o=null!==(n=e.mode)&&void 0!==n?n:"default",[r,a]=this.getInitedExecute(o,e),[s,l]=await D.create.call(null!==(t=e.name)&&void 0!==t?t:"",r,null===(i=e.hasBorderBuf)||void 0===i||i,a),c=new R(this.srcId);return new K(s,null!=l?l:void 0,e,o,c)}getInitedExecute(e){var n,t,i,o;let r=null!==(t=null===(n=e.initedExecute)||void 0===n?void 0:n.call(e,K.initedContextVars.open))&&void 0!==t?t:"";return r=K.modePresets[this.mode].openInitedExecute(K.initedContextVars.open)+"\n"+r,[r,null!==(o=null===(i=e.borderInitedExecute)||void 0===i?void 0:i.call(e,K.initedContextVars.open))&&void 0!==o?o:K.modePresets.show.openInitedExecute(K.initedContextVars.open)]}getFocus(e){var n,t;return null!==(t=null!==(n=e.focus)&&void 0!==n?n:this.mode?K.modePresets[this.mode].focus:void 0)&&void 0!==t&&t}getModifiable(e){var n,t;return null!==(t=null!==(n=e.modifiable)&&void 0!==n?n:this.mode?K.modePresets[this.mode].modifiable:void 0)&&void 0!==t&&t}setLinesNotifier(e){return N.create((()=>{if(!e.lines&&!e.modifiable)return;const n=this.getModifiable(e);if(this.buffer.setOption("modifiable",!0,!0),this.buffer.setOption("readonly",!1,!0),e.lines&&this.buffer.setLines(e.lines,{start:0,end:-1},!0),n||(this.buffer.setOption("modifiable",!1,!0),this.buffer.setOption("readonly",!0,!0)),e.highlights)for(const n of e.highlights)void 0!==n.srcId&&-1!==n.srcId&&0!==n.srcId||(n.srcId=K.srcId),this.util.addHighlightsNotify(this.buffer,[n]);i.workspace.isVim&&this.nvim.command("redraw!",!0)}))}async setLines(e){await this.setLinesNotifier(e).run()}async opened(){return!!await this.win()}async openNotifier(e){var n;if(e.width<=0||e.height<=0)return N.noop();const t=[];t.push(this.closeNotifier());const o=await this.util.createContext(e),[r,a]=this.getInitedExecute(e),[s,l]=this.util.winConfig(o,e);return e.borderOnly&&l?(t.push(D.open.callNotifier(this.bufnr,l,a,null,null,"",!1,this.util.nvimWinHl(e))),t.push(this.util.renderBorderNotifier(this.buffer,o,e,l))):t.push(D.open.callNotifier(this.bufnr,s,r,null!==(n=this.borderBufnr)&&void 0!==n?n:null,null!=l?l:null,a,this.getFocus(e),this.util.nvimWinHl(e))),i.workspace.isNvim&&this.borderBuffer&&l&&t.push(this.util.renderBorderNotifier(this.borderBuffer,o,e,l)),t.push(this.setLinesNotifier(e),N.create((()=>{e.filetype&&this.buffer.setOption("filetype",e.filetype,!0)}))),N.combine(t)}async open(e){await(await this.openNotifier(e)).run()}async resumeNotifier(e){const n=await this.util.createContext(e),[t,o]=this.util.winConfig(n,e);return N.create((()=>{var r;D.resume.callNotify(this.bufnr,t,null!==(r=this.borderBufnr)&&void 0!==r?r:null,null!=o?o:null,this.getFocus(e),this.util.nvimWinHl(e)),this.borderBuffer&&o&&this.util.renderBorderNotifier(this.borderBuffer,n,e,o).notify(),i.workspace.isVim&&this.nvim.command("redraw!",!0)}))}async resume(e){await(await this.resumeNotifier(e)).run()}async resizeNotifier(e){var n;const t=await this.util.createContext(e),[o,r]=this.util.winConfig(t,e,!1),a=[];return e.borderOnly&&r?(a.push(D.update.callNotifier(this.bufnr,r,null,null,this.util.nvimWinHl(e))),a.push(this.util.renderBorderNotifier(this.buffer,t,e,r))):a.push(D.update.callNotifier(this.bufnr,o,null!==(n=this.borderBufnr)&&void 0!==n?n:null,null!=r?r:null,this.util.nvimWinHl(e))),i.workspace.isNvim&&this.borderBuffer&&r&&a.push(this.util.renderBorderNotifier(this.borderBuffer,t,e,r)),a.push(N.create((()=>{i.workspace.isVim&&this.nvim.command("redraw!",!0)}))),N.combine(a)}async resize(e){await(await this.resizeNotifier(e)).run()}async win(){const e=await D.winid.call(this.bufnr);return e?this.nvim.createWindow(e):void 0}async borderWin(){const e=await D.winid.call(this.bufnr);return e?this.nvim.createWindow(e):void 0}closeNotifier(){return D.close.callNotifier(this.bufnr)}async close(){await this.closeNotifier().run()}dispose(){(0,i.disposeAll)(this.disposables),this.disposables.forEach((e=>e.dispose()))}}K.modePresets={default:{modifiable:!1,focus:!1,createInitedExecute:()=>"",openInitedExecute:()=>""},base:{createInitedExecute:e=>`\n        call setbufvar(${e.bufnr}, '&buftype', 'nofile')\n        call setbufvar(${e.bufnr}, '&bufhidden', 'hide')\n        call setbufvar(${e.bufnr}, '&buflisted', 0)\n\n        call setbufvar(${e.bufnr}, '&wrap', 1)\n\n        call setbufvar(${e.bufnr}, '&swapfile', 0)\n\n        call setbufvar(${e.bufnr}, '&modeline', 0)\n      `,openInitedExecute:e=>`\n        call setbufvar(${e.bufnr}, '&list', 0)\n\n        call setbufvar(${e.bufnr}, '&listchars', '')\n        if has('nvim')\n          call setbufvar(${e.bufnr}, '&fillchars', 'eob: ')\n        endif\n\n        call setbufvar(${e.bufnr}, '&signcolumn', 'no')\n        call setbufvar(${e.bufnr}, '&number', 0)\n        call setbufvar(${e.bufnr}, '&relativenumber', 0)\n        call setbufvar(${e.bufnr}, '&foldenable', 0)\n        call setbufvar(${e.bufnr}, '&foldcolumn', 0)\n\n        call setbufvar(${e.bufnr}, '&spell', 0)\n\n        call setbufvar(${e.bufnr}, '&cursorcolumn', 0)\n        call setbufvar(${e.bufnr}, '&cursorline', 0)\n        call setbufvar(${e.bufnr}, '&colorcolumn', '')\n      `},show:{modifiable:!1,createInitedExecute:e=>`\n        ${K.modePresets.base.createInitedExecute(e)}\n        " call setbufvar(${e.bufnr}, '&undofile', 0)\n        " call setbufvar(${e.bufnr}, '&undolevels', -1)\n\n        call setbufvar(${e.bufnr}, '&modifiable', 0)\n        call setbufvar(${e.bufnr}, '&modified', 0)\n        call setbufvar(${e.bufnr}, '&readonly', 1)\n      `,openInitedExecute:e=>`\n        ${K.modePresets.base.openInitedExecute(e)}\n      `}},K.initedContextVars={create:{bufnr:"a:ctx.bufnr"},open:{bufnr:"a:ctx.bufnr",winid:"a:ctx.winid"}},K.srcId=i.workspace.createNameSpace("coc-helper-floatwin");class U{constructor(e,n,t){this.borderFloatWin=e,this.floatWinDict=n,this.util=t,this.disposables=[],this.floatWins=Object.values(this.floatWinDict),this.nvim=i.workspace.nvim,this.bufnrs=[e.bufnr,...this.floatWins.map((e=>e.bufnr))],this.disposables.push(i.events.on("BufWinLeave",(async e=>{this.bufnrs.includes(e)&&await this.close()})),i.Disposable.create((()=>{e.dispose(),(0,i.disposeAll)(this.floatWins)})))}static async create(e){const n=await K.create(Object.assign({hasBorderBuf:!1,mode:"show"},e)),t=(await Promise.all(Object.entries(e.wins).map((async([e,n])=>[e,await K.create(Object.assign({hasBorderBuf:!1},n))])))).reduce(((e,[n,t])=>(e[n]=t,e)),{}),i=new R(K.srcId);return new U(n,t,i)}async opened(){return this.borderFloatWin.opened()}async sizeByWinsOptions(e){var n,t;let i=0,o=0;for(const r of e){const e=await this.util.createContext(r),a=this.util.getBoxSizes(e,r,!1),s=(null!==(n=r.left)&&void 0!==n?n:0)+a.borderBox[2];s>i&&(i=s);const l=(null!==(t=r.top)&&void 0!==t?t:0)+a.borderBox[3];l>o&&(o=l)}return[i,o]}async batchAction(e,n,{reverse:t=!1,updateCursorPosition:i=!0}={}){var o,r;const[a,s]=await this.sizeByWinsOptions(Object.values(n.wins)),l=Object.assign({width:a,height:s},n),c=await this.util.createContext(l),{contentBox:u}=this.util.getBoxSizes(c,l,i),d=[];for(const[t,i]of Object.entries(this.floatWinDict)){const a=n.wins[t];a&&d.push(await i[e](Object.assign(Object.assign({},a),{relative:"editor",top:u[0]+(null!==(o=a.top)&&void 0!==o?o:0),left:u[1]+(null!==(r=a.left)&&void 0!==r?r:0)})))}d.push(await this.borderFloatWin[e](Object.assign(Object.assign({},l),{borderOnly:!0}))),t&&d.reverse(),await N.runAll(d)}async open(e){return this.batchAction("openNotifier",e)}async resume(e){return this.batchAction("resumeNotifier",e)}resize(e){return this.batchAction("resizeNotifier",e,{updateCursorPosition:!1})}async win(){return{borderWin:await this.borderFloatWin.win(),wins:await this.wins()}}async wins(){return await Promise.all(this.floatWins.map((e=>e.win())))}async close(){const e=[];e.push(this.borderFloatWin.closeNotifier()),e.push(...this.floatWins.map((e=>e.closeNotifier()))),await N.runAll(e)}dispose(){(0,i.disposeAll)(this.disposables)}}class G{constructor(e){this.root=e}static convertVimLayoutNode(e,n){if("leaf"===e[0])return{type:e[0],winid:e[1],parent:n};{const n={type:e[0],children:[]};return n.children=e[1].map(((e,t)=>this.convertVimLayoutNode(e,{group:n,indexInParent:t}))),n}}static async create(){const e=await i.workspace.nvim.call("winlayout",[]);return new this(this.convertVimLayoutNode(e))}static getFirstLeafWinid(e){return"leaf"===e.type?e.winid:this.getFirstLeafWinid(e.children[0])}findWinid(e,n=this.root){if("leaf"===n.type)return n.winid===e?n:void 0;for(const t of n.children){const n=this.findWinid(e,t);if(n)return n}}findClosest(e,n){const t=new Set([e]),i=[e];for(;i.length;){const e=i.shift();if("leaf"===e.type){if(n.includes(e.winid))return e}else for(const n of e.children)t.has(n)||(i.push(n),t.add(n));e.parent&&!t.has(e.parent.group)&&(i.push(e.parent.group),t.add(e.parent.group))}}}async function Q(e,n={}){var t,o;(null===(t=n.vimModule)||void 0===t||t)&&await L.init(e),(null===(o=n.events)||void 0===o||o)&&await A.register(e);try{await i.workspace.nvim.command("hi default link CocHelperNormalFloatNC CocHelperNormalFloat")}catch(e){i.window.showMessage(e,"error")}}async function q(e){await Q(e,{events:!0}),F.on("BufDelete",(e=>{i.window.showMessage("buffer delete "+e)})),await i.workspace.nvim.command("hi CocHelperNormalFloat ctermbg=Red guibg=#aa0000"),await i.workspace.nvim.command("hi CocHelperNormalFloatNC ctermbg=Red guibg=#aa0000"),await i.workspace.nvim.command("hi CocHelperNormalFloatBorder ctermbg=Black ctermfg=Grey guibg=#0000aa guifg=#ffffff");const n=await K.create({mode:"base"});i.commands.registerCommand("testHelper-floating",(async()=>{const e="hello";await n.open({relative:"cursor-around",lines:[e],top:0,left:0,title:"test",width:5,height:5,border:[1,1,1,0],padding:[],modifiable:!0,focus:!0,filetype:"test",highlights:[{line:0,srcId:0,colStart:0,colEnd:e.length,hlGroup:"Question"}]}),await I(2e3),await n.resize({relative:"cursor-around",top:0,left:0,title:"test",width:10,height:10,border:[],padding:[],winHl:"Pmenu",winHlNC:"Pmenu",modifiable:!0,focus:!1,filetype:"test"}),await I(2e3),await n.resize({relative:"cursor-around",top:0,left:0,title:"test",width:5,height:5,border:[1,1,1,0],padding:[],modifiable:!0,focus:!1,filetype:"test"})}));const t=await U.create({wins:{prompt:{mode:"show"},input:{mode:"base"}}});i.commands.registerCommand("testHelper-multi-floating",(async()=>{const e="input your path:",n=await m(10,[e]),o="/home/users/repos";let r=await m(10,[o]);i.events.on("TextChangedI",(async e=>{const n=t.floatWinDict.input;if(n.bufnr!==e)return;const i=await n.win();if(!i)return;const o=await i.cursor,a=await i.width,l=await i.height,c=await n.buffer.getLines(),u=await m(a,c,o,"i");u!==l&&(r=u,await s())}));const a=()=>({relative:"cursor-around",top:0,left:0,title:"test",border:[],padding:[],modifiable:!0,filetype:"test",wins:{prompt:{top:0,left:0,width:10,height:n,highlights:[{line:0,srcId:0,colEnd:e.length,colStart:0,hlGroup:"Question"}],lines:[e]},input:{top:n,left:0,width:10,height:r,lines:[o],focus:!0,modifiable:!0,initedExecute:()=>"\n            if has('nvim')\n              call feedkeys('A')\n            endif\n          "}}}),s=async()=>{await t.resize(a())};await t.open(a())}))}},367:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.BaseComponent=void 0;const i=t(888);class o{constructor(){this._inited=!1,this.disposables=[],this.closeEmitter=new i.Emitter}get srcId(){return o.srcId}dispose(){i.disposeAll(this.disposables)}async instance(){return this._instance||(this._instance=await this._create()),this._instance}async input(e){return new Promise((async n=>{this.closeEmitter.event(n),await this.open(e)}))}async opened(){return this._opened(await this.instance())}async open(e){return this.storeOptions=e,this._open(await this.instance(),e)}async resize(){if(this.storeOptions)return this._resize(await this.instance(),this.storeOptions)}async close(e){await this._close(await this.instance(),e),this.closeEmitter.fire(e)}}n.BaseComponent=o,o.srcId=i.workspace.createNameSpace("coc-floatinput")},402:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.Confirm=void 0;const i=t(555),o=t(888),r=t(425),a=t(638),s=t(462),l=t(367);class c extends l.BaseComponent{constructor(){super(...arguments),this.defaultValues=["yes","no"]}async _create(){return await i.MultiFloatingWindow.create({wins:{prompt:{mode:"show"},btn:{mode:"show",hasBorderBuf:!0}}})}async _opened(e){return e.opened()}async getFinalOpenOptions(e){var n,t,o;const a=null!==(n=e.width)&&void 0!==n?n:30;let s=0;const l={relative:null!==(t=e.relative)&&void 0!==t?t:"center",title:e.title,border:[],wins:{}};if(e.prompt){const n=e.prompt.split(/\r\n|[\n\r]/g),t=await i.displayHeight(a,n);l.wins.prompt={width:a,height:t,focusable:!0,lines:n,highlights:n.map(((e,n)=>({srcId:this.srcId,line:n,colStart:0,colEnd:e.length,hlGroup:"Question"})))},s=t}const c=await Promise.all((null!==(o=e.values)&&void 0!==o?o:this.defaultValues).map((async(n,t)=>{var o,r;const a=null!==(r=null===(o=e.buttonText)||void 0===o?void 0:o[t])&&void 0!==r?r:`${n[0].toUpperCase()}${n.slice(1)} (${n[0]})`;return{text:a,value:n,width:await i.displayWidth(a)}})));this.btnLinesLayout=r.columnsFlexLayout(a,c);const u=this.btnLinesLayout.length;return l.wins.btn={top:s,width:a,height:u,lines:this.btnLinesLayout.map((e=>e.map((e=>e.text)).join(""))),border:[1,0,0,0]},l}async waitUserInput(e,n){try{const t=await a.getcharStart((async({char:t,mode:i,stop:r,matchCode:s})=>{const l=await e.floatWinDict.btn.win();if(l){if(i===a.CharMode.none)if(s(["<Esc>","<C-c>"]))await r();else if(s(["k","<Up>","h","<Left>"])){const e=n.indexOf(this.value);this.value=n[(e+n.length-1)%n.length],await this.resize()}else if(s(["j","<Down>","l","<Right>"])){const e=n.indexOf(this.value);this.value=n[(e+1)%n.length],await this.resize()}else if(s(["<LeftMouse>"])){const[e,n,t]=await o.workspace.nvim.eval("[v:mouse_winid, v:mouse_lnum, v:mouse_col]");if(e===l.id&&this.btnLinesLayout){const e=this.btnLinesLayout[n-1].find((e=>e.colStart<=t&&t<e.colEnd));e&&await r(e.value)}}else if(s(["<Cr>"]))await r(this.value);else{const e=t.toLowerCase(),i=n.find((n=>n[0].toLowerCase()===e));i&&await r(i)}}else await r()}));await this.close(t)}catch(e){await this.close()}}async updateHighlights(e){var n;o.workspace.nvim.pauseNotification(),e.floatWinDict.btn.buffer.clearNamespace(this.srcId),null===(n=this.btnLinesLayout)||void 0===n||n.forEach((n=>{n.forEach((n=>{e.floatWinDict.btn.buffer.highlightRanges(this.srcId,this.value===n.value?"PmenuSel":"None",[o.Range.create(o.Position.create(n.line,n.colStart),o.Position.create(n.line,n.colEnd))])}))})),o.workspace.nvim.command("redraw!",!0),await o.workspace.nvim.resumeNotification()}async _open(e,n){var t,i;const o=null!==(t=n.values)&&void 0!==t?t:this.defaultValues;this.value=null!==(i=n.defaultValue)&&void 0!==i?i:o[o.length-1],await e.open(await this.getFinalOpenOptions(n)),await this.updateHighlights(e),this.waitUserInput(e,o).catch(s.logger.error)}async _resize(e,n){await e.resize(await this.getFinalOpenOptions(n)),await this.updateHighlights(e)}async _close(e){await e.close()}}n.Confirm=c,c.actionCmd="floatinput.input.action_"+i.versionName,c._inited=!1},111:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.Input=void 0;const i=t(555),o=t(888),r=t(367);class a extends r.BaseComponent{constructor(){super(...arguments),this.id=0}genFiletype(){return"coc-floatinput-input-"+this.id}async changeMode(e,n){e!==n&&("i"===n?"n"===e&&await o.workspace.nvim.command('call feedkeys("a", "n")'):"n"!==e&&await o.workspace.nvim.command('call feedkeys("\\<ESC>l", "n")'))}async getContent(){const e=(await this.instance()).floatWinDict.input.buffer;return(await e.getLines({start:0,end:1,strictIndexing:!1}))[0]}async confirm(e){if("cancel"===e)await this.close();else if("ok"===e){const e=await this.getContent();await this.validateContent(e)&&await this.close(await this.stringToValue(e))}}_init(){a._inited||(a._inited=!0,this.disposables.push(o.events.on("BufEnter",(async e=>{if(a.inputMap.get(e))return;const n=[];for(const e of a.inputMap.values())await e.input.opened()&&n.push(e.input);await Promise.all(n.map((e=>e.confirm("cancel"))))})),o.events.on("BufWinLeave",(async e=>{const n=a.inputMap.get(e);n&&(await n.inputWin.buffer.setOption("buftype","nofile"),await n.input.opened()&&await n.input.confirm("cancel"))})),o.events.on("TextChangedI",(async e=>{const n=a.inputMap.get(e);n&&await n.input.textChange("i")})),o.events.on("TextChanged",(async e=>{const n=a.inputMap.get(e);n&&await n.input.textChange("n")})),o.commands.registerCommand(a.actionCmd,(async(e,n,t,i)=>{const o=a.inputMap.get(n);o&&(await o.input.changeMode(t,i),await o.input.confirm(e))}),void 0,!0)))}async _create(){this._init(),a.maxId++,this.id=a.maxId;const e=await i.MultiFloatingWindow.create({wins:{prompt:{mode:"show"},input:{mode:"base"}}}),n=e.floatWinDict.input;return a.inputMap.has(n.bufnr)||a.inputMap.set(n.bufnr,{input:this,instance:e,inputWin:n}),this.disposables.push(o.Disposable.create((()=>{var e;null===(e=this.completionDisposable)||void 0===e||e.dispose()}))),e}async _opened(e){return e.opened()}async textChange(e){if(!this.storeOptions)return;const n=await this.instance();await n.resize(await this.getFinalOpenOptions(this.storeOptions,n,"resize",e))}async getFinalOpenOptions(e,n,t,r="n"){var s,l,c;const u=(await o.workspace.nvim.mode).mode,d=null!==(s=e.width)&&void 0!==s?s:30;let f=0;const h={relative:null!==(l=e.relative)&&void 0!==l?l:"center",title:e.title,border:!1===e.border?void 0:[],wins:{}};if(e.prompt){const n=e.prompt.split(/\r\n|[\n\r]/g),t=await i.displayHeight(d,n);h.wins.prompt={width:d,height:t,focusable:!1,lines:n,highlights:n.map(((e,n)=>({srcId:this.srcId,line:n,colStart:0,colEnd:e.length,hlGroup:"Question"})))},f=t}let p,m;if("open"===t)p=[e.defaultValue?await this.valueToString(e.defaultValue):await this.defaultString()],m=await i.displayHeight(d,p);else{const e=n.floatWinDict.input;p=await e.buffer.getLines();const t=await e.win();if(t){const e=await t.cursor;m=await i.displayHeight(d,p,e,r)}else m=await i.displayHeight(d,p)}const w=n.floatWinDict.input.bufnr,b=null!==(c=e.filetype)&&void 0!==c?c:this.genFiletype();return h.wins.input={top:f,width:d,height:m||1,focus:!0,modifiable:!0,lines:p,filetype:b,initedExecute:()=>`\n        call setbufvar(${w}, '&buftype', '')\n        call setbufvar(${w}, '&wrap', 1)\n        nmap <silent><buffer> <CR> :call CocAction('runCommand', '${a.actionCmd}', 'ok', ${w}, 'n', '${u}')<CR>\n        imap <silent><buffer> <CR> <C-o>:call CocAction('runCommand', '${a.actionCmd}', 'ok', ${w}, 'i', '${u}')<CR>\n        nmap <silent><buffer> <ESC> :call CocAction('runCommand', '${a.actionCmd}', 'cancel', ${w}, 'n', '${u}')<CR>\n        imap <silent><buffer> <C-c> <C-o>:call CocAction('runCommand', '${a.actionCmd}', 'cancel', ${w}, 'i', '${u}')<CR>\n        call feedkeys('A')\n      `},e.completion&&(this.completionDisposable&&this.completionDisposable.dispose(),this.completionDisposable=o.languages.registerCompletionItemProvider(b,e.completion.short,[b],e.completion.provider)),h}async _open(e,n){await e.open(await this.getFinalOpenOptions(n,e,"open"))}async _resize(e,n){await e.resize(await this.getFinalOpenOptions(n,e,"resize"))}async _close(e){await e.close()}}n.Input=a,a.maxId=0,a.actionCmd="floatinput.input.action_"+i.versionName,a.inputMap=new Map,a._inited=!1},677:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.IntInput=void 0;const i=t(111);class o extends i.Input{async defaultString(){return"0"}async valueToString(e){return e.toString()}async stringToValue(e){return parseInt(e,10)}async validateContent(e){return/^\s*[0-9]+\s*$/.test(e)}}n.IntInput=o},162:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.NumberInput=void 0;const i=t(111);class o extends i.Input{async defaultString(){return"0"}async valueToString(e){return e.toString()}async stringToValue(e){return parseFloat(e)}async validateContent(e){return/^\s*(([0-9]*\.[0-9]+)|([0-9]+))\s*$/.test(e)}}n.NumberInput=o},762:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.StringInput=void 0;const i=t(111);class o extends i.Input{async defaultString(){return""}async valueToString(e){return e}async stringToValue(e){return e}async validateContent(e){return!0}}n.StringInput=o},553:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.FloatingUI=void 0;const i=t(402),o=t(677),r=t(162),a=new(t(762).StringInput),s=new r.NumberInput,l=new o.IntInput,c=new i.Confirm;var u;(u=n.FloatingUI||(n.FloatingUI={})).stringInput=a.input.bind(a),u.numberInput=s.input.bind(s),u.intInput=l.input.bind(l),u.confirm=function(e){return c.input(e)}},152:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.CocSymbolProvider=n.CocCommandProvider=n.VimCommandProvider=n.ListProvider=void 0;const i=t(888);class o{constructor(){this.completionKind=i.CompletionItemKind.Method}async provideCompletionItems(e,n){const t=e.getText(i.Range.create(i.Position.create(n.line,0),n));return(await this.getList(t)).map((e=>{var n;return{label:e.name,kind:null!==(n=e.kind)&&void 0!==n?n:this.completionKind,insertText:e.name}}))}}n.ListProvider=o,n.VimCommandProvider=class extends o{async getList(e){return(await i.workspace.nvim.call("getcompletion",[e,"cmdline"])).map((e=>({name:e})))}},n.CocCommandProvider=class extends o{async getList(e){return i.commands.commandList.map((e=>({name:e.id}))).filter((n=>n.name.startsWith(e)))}},n.CocSymbolProvider=class extends o{async getList(e){return this.document?(await i.workspace.nvim.request("documentSymbols",[this.document.bufnr])).map((e=>({name:e.text}))).filter((n=>n.name.startsWith(e))):[]}}},425:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.columnsFlexLayout=void 0;const i=t(555);n.columnsFlexLayout=function(e,n){const t=[];let o=0,r=[];for(const i of n)r.length&&(i.width+=1),i.width+=2,o+=i.width,r.length&&o>=e&&(t.push(r),r=[],o=i.width),r.push(i);return t.push(r),t.map(((n,t)=>function(e,n){const t=function(e,n){const t=Math.ceil(e/n.length),i=new Array(n.length);for(let o=0;o<n.length;o++)void 0===i[o]&&(t<=e?(e-=t,i[o]=t):i[o]=e);return i}(e-i.sum(n.map((e=>e.width))),n);let o=0;return n.map(((e,n)=>{var r;const a=null!==(r=t[n])&&void 0!==r?r:0;let s;if(a){const n=Math.ceil(a/2),t=a-n;s=`${" ".padStart(n)} ${e.text} ${" ".padStart(t)}`}else s=` ${e.text} `;0!==n&&(s="|"+s,o+=1);const l=o;return o+=i.byteLength(s),Object.assign(Object.assign({},e),{line:0,colStart:l,colEnd:o,width:e.width+a,text:s})}))}(e,n).map((e=>Object.assign(Object.assign({},e),{line:t})))))}},144:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.escapedKeysModule=n.codeToName=n.nameToCode=n.keyNames=void 0;const i=t(555);n.keyNames=["<Plug>","<Esc>","<Tab>","<S-Tab>","<Bs>","<Right>","<Left>","<Up>","<Down>","<Home>","<End>","<Cr>","<PageUp>","<PageDown>","<FocusGained>","<ScrollWheelUp>","<ScrollWheelDown>","<LeftMouse>","<LeftDrag>","<LeftRelease>","<2-LeftMouse>","<C-a>","<C-b>","<C-c>","<C-d>","<C-e>","<C-f>","<C-g>","<C-h>","<C-i>","<C-j>","<C-k>","<C-l>","<C-m>","<C-n>","<C-o>","<C-p>","<C-q>","<C-r>","<C-s>","<C-t>","<C-u>","<C-v>","<C-w>","<C-x>","<C-y>","<C-z>","<A-a>","<A-b>","<A-c>","<A-d>","<A-e>","<A-f>","<A-g>","<A-h>","<A-i>","<A-j>","<A-k>","<A-l>","<A-m>","<A-n>","<A-o>","<A-p>","<A-q>","<A-r>","<A-s>","<A-t>","<A-u>","<A-v>","<A-w>","<A-x>","<A-y>","<A-z>"],n.nameToCode=async function(){return await n.escapedKeysModule.nameToCode.get()},n.codeToName=async function(){const e=await n.escapedKeysModule.nameToCode.get(),t={};return Object.entries(e).forEach((([e,n])=>{t[n]=e})),t},n.escapedKeysModule=i.VimModule.create("escaped_keys",(e=>{const t=`{${n.keyNames.map((e=>`"${e}": "\\${e}"`)).join(",")}}`;return{nameToCode:e.var("codes_to_name",t)}}))},771:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.vimEvents=void 0;const i=t(555),o=t(462);n.vimEvents=new i.HelperVimEvents({CocStatusChange:{eventExpr:"User CocStatusChange"}},o.logger,{name:"FloatinputStatus"})},638:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.getcharModule=n.getcharStart=n.CharMode=void 0;const i=t(555),o=t(888),r=t(144),a=t(462);var s;(s=n.CharMode||(n.CharMode={}))[s.none=0]="none",s[s.shift=2]="shift",s[s.control=4]="control",s[s.alt=8]="alt",s[s.meta=16]="meta",s[s.mouseDoubleClick=32]="mouseDoubleClick",s[s.mouseTripleClick=64]="mouseTripleClick",s[s.mouseQuadrupleClick=96]="mouseQuadrupleClick",s[s.command=128]="command",n.getcharStart=async function(e){const t=await r.nameToCode();n.getcharModule.startPrompt.call().catch(a.logger.error);const i=a.logger.asyncCatch(e),o=(e,n)=>n.some((n=>n in t?t[n]===e:e===n));return await new Promise((e=>{const r=async t=>{await n.getcharModule.stopPrompt.call(),a.dispose(),e(t)},a=l.on("InputChar",((e,n)=>{i({char:e,mode:n,codes:t,matchCodeWith:o,matchCode:o.bind(void 0,e),stop:r})}))}))};const l=new i.HelperEventEmitter(a.logger);n.getcharModule=i.VimModule.create("getchar",(e=>{const n=e.var("activated","0");e.registerInit((e=>{e.subscriptions.push(o.commands.registerCommand("floatinput.inputchar",((e,n)=>{l.fire("InputChar",e,n).catch(a.logger.error)}),void 0,!0))}));const t=e.fn("getc",(({name:e})=>`\n      function! ${e}() abort\n        try\n          let c = getchar()\n          return type(c) == type(0) ? nr2char(c) : c\n        catch /^Vim:Interrupt$/\n          return "\\<C-c>"\n        endtry\n      endfunction\n    `));return{activated:n,getc:t,startPrompt:e.fn("start_prompt",(({name:e})=>`\n        function! ${e}() abort\n          if ${n.inline}\n            return\n          endif\n          let ${n.inline} = 1\n          while ${n.inline}\n            let ch = ${t.inlineCall()}\n            if ch ==# "\\<FocusLost>" || ch ==# "\\<FocusGained>" || ch ==# "\\<CursorHold>"\n              continue\n            else\n              call CocActionAsync('runCommand', 'floatinput.inputchar', ch, getcharmod())\n            endif\n          endwhile\n        endfunction\n      `)),stopPrompt:e.fn("stop_prompt",(({name:e})=>`\n        function! ${e}() abort\n          if ${n.inline}\n            let ${n.inline} = 0\n            call feedkeys("\\<C-c>")\n          endif\n        endfunction\n      `))}}))},465:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.activate=n.FloatInput=void 0;const i=t(555),o=t(888),r=t(402),a=t(111),s=t(677),l=t(162),c=t(762),u=t(771),d=t(553),f=t(152),h=t(322),p=t(49),m=t(462);n.FloatInput={components:{Input:a.Input,StringInput:c.StringInput,NumberInput:l.NumberInput,IntInput:s.IntInput,Confirm:r.Confirm},ListProvider:f.ListProvider,FloatingUI:d.FloatingUI},n.activate=async function(e){if(o.workspace.isVim)return void o.window.showMessage("coc-floatinput only support neovim","warning");const{subscriptions:t}=e;await i.activateHelper(e,{events:!0});const r=new c.StringInput;async function a(){const e=await r.input({title:"command",relative:"center",filetype:"floatinput-command",completion:{short:"C",provider:new f.VimCommandProvider}});if(e)return o.workspace.nvim.command(e)}async function s(){const e=await r.input({title:"coc-command",relative:"center",filetype:"floatinput-coc-command",completion:{short:"C",provider:new f.CocCommandProvider}});if(e)return o.commands.executeCommand(e)}t.push(r,o.commands.registerCommand("floatinput.command",(()=>{a().catch(m.logger.error)})),o.workspace.registerKeymap(["n","i"],"floatinput-command",(()=>{a().catch(m.logger.error)}))),t.push(r,o.commands.registerCommand("floatinput.coc.command",(()=>{s().catch(m.logger.error)})),o.workspace.registerKeymap(["n","i"],"floatinput-coc-command",(()=>{s().catch(m.logger.error)}))),await h.registerRename(e),await u.vimEvents.register(e);const l=m.configLocal(),d=await p.CocStatusManager.create(e,l);return l.get("status.enabled")&&await d.enable(),n.FloatInput}},322:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.registerRename=void 0;const i=t(888),o=t(462),r=t(152),a=t(762);n.registerRename=async function(e){const n=new r.CocSymbolProvider,t=new a.StringInput;async function s(){const e=await i.workspace.document;if(await o.synchronizeDocument(e),!await async function(){return!!await i.workspace.nvim.call("CocHasProvider","rename")||(i.window.showMessage("Rename provider not found for current document","error"),!1)}())return;const r=await i.window.getCursorPosition(),a=await async function(e,n){const t=await async function(e,n){return await i.languages.prepareRename(e.textDocument,n)||(i.window.showMessage("Invalid position for renmame","error"),!1)}(e,n);if(t)return"placeholder"in t?t.placeholder:e.textDocument.getText(t)}(e,r);if(!a)return;n.document=e;const s=await t.input({title:"coc-rename",filetype:"floatinput-coc-rename",relative:"cursor-around",defaultValue:a,prompt:a+" ->",completion:{short:"C",provider:n}});if(void 0!==s){if(!s)return void i.window.showMessage("Empty name, canceled","warning");const n=await i.languages.provideRenameEdits(e.textDocument,r,s);if(!n)return void i.window.showMessage("Invalid position for rename","warning");await i.workspace.applyEdit(n)}}e.subscriptions.push(t,i.commands.registerCommand("floatinput.rename",(()=>{s().catch(o.logger.error)})),i.workspace.registerKeymap(["n","i"],"floatinput-rename",(()=>{s().catch(o.logger.error)})))}},49:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.CocStatusManager=void 0;const i=t(555),o=t(888),r=t(771),a=t(462);class s{constructor(e,n,t=[]){this.context=e,this.config=n,this.disposables=t}static async create(e,n){return new s(e,n,[])}dispose(){o.disposeAll(this.disposables)}async floatWin(){return this._floatWin||(this._floatWin=await i.FloatingWindow.create({mode:"show"})),this._floatWin}async show(){const e=await o.workspace.nvim.getVar("coc_status");if(!e)return;const n=[e],t=this.config.get("status.direction"),r=this.config.get("status.width"),a=this.config.get("status.timeout"),s=await i.displayHeight(r,n),l=await async function(e,n,t){const i=n+2,r=t+2,a=await o.workspace.nvim.getOption("showtabline"),s=(await o.workspace.nvim.tabpages).length,l=o.workspace.env.lines,c=o.workspace.env.columns,u=0===a?0:2===a||s>1?1:0;let d=0,f=u;return"top-left"===e?(f=u,d=0):"top-center"===e?(f=u,d=(c-i)/2):"top-right"===e?(f=u,d=c-i):"bottom-left"===e?(f=l-r,d=0):"bottom-center"===e||"bottom-right"===e?(f=l-r,d=(c-i)/2):"left-center"===e?(f=(l-r)/2,d=0):"right-center"===e&&(f=(l-r)/2,d=c-i),{top:f,left:d,width:n,height:t}}(t,r,s),c=await this.floatWin(),u=Object.assign(Object.assign({title:"coc-status"},l),{border:[],lines:n});await c.opened()?await c.resize(u):await c.open(u),await c.setLines(Object.assign(Object.assign({},u),{lines:n})),this.autoCloseTimer&&clearTimeout(this.autoCloseTimer),this.autoCloseTimer=setTimeout((async()=>{await this.hide()}),a)}async hide(){var e;await(null===(e=this._floatWin)||void 0===e?void 0:e.close())}async enable(){this.config=a.configLocal(),this.disposables.push(r.vimEvents.events.on("CocStatusChange",(async()=>{await this.show()})))}async disable(){}}n.CocStatusManager=s},462:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.configLocal=n.synchronizeDocument=n.logger=void 0;const i=t(555);n.logger=new i.HelperLogger("floatinput"),n.synchronizeDocument=async function(e){const{changedtick:n}=e;await e.patchChange(),n!==e.changedtick&&await i.sleep(50)},n.configLocal=i.getConfigLocal("floatinput")},888:e=>{e.exports=require("coc.nvim")}},n={};function t(i){if(n[i])return n[i].exports;var o=n[i]={exports:{}};return e[i](o,o.exports,t),o.exports}return t.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},t.d=(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t(465)})());